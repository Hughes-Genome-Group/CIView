/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/indexes/index_ciview.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/ciview.js":
/*!***********************!*\
  !*** ./src/ciview.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.CIView = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _graphs = __webpack_require__(/*! ./graphs.js */ \"./src/graphs.js\");\n\nvar _dc = __webpack_require__(/*! ./vendor/dc.js */ \"./src/vendor/dc.js\");\n\nvar _image_table = __webpack_require__(/*! ./image_table.js */ \"./src/image_table.js\");\n\nvar _slickDataview = __webpack_require__(/*! ./vendor/slick.dataview.js */ \"./src/vendor/slick.dataview.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar CIView = function () {\n\tfunction CIView(config) {\n\t\t_classCallCheck(this, CIView);\n\n\t\tvar self = this;\n\n\t\tthis.filters = {};\n\n\t\tthis.data_view = new _slickDataview.DataView();\n\t\tvar div = $(\"#\" + config.table_div);\n\t\tthis.control_div = $(\"<div>\").css({ width: \"100%\", height: \"26px\" }).attr(\"id\", \"civ-control\").appendTo(div);\n\t\tvar table_div = $(\"<div>\").css({ top: \"25px\", height: \"calc(100% - 26px)\" }).attr(\"id\", \"civ-table\").appendTo(div);\n\t\tthis.filter_panel = new _graphs.FilterPanel(config.filter_div, config.data, function (info) {\n\t\t\tself._filterChanged(info);\n\t\t\tif (self.listener) {\n\t\t\t\tself.listener(info);\n\t\t\t}\n\t\t});\n\t\tthis.image_table = new _image_table.MLVImageTable(table_div, this.data_view, config.image_base_url);\n\t\tthis.data = config.data;\n\n\t\tnew _image_table.MLVImageTableControls(this.image_table, this.control_div);\n\n\t\tvar _iteratorNormalCompletion = true;\n\t\tvar _didIteratorError = false;\n\t\tvar _iteratorError = undefined;\n\n\t\ttry {\n\t\t\tfor (var _iterator = config.graph_groups[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\t\tvar item = _step.value;\n\n\t\t\t\tthis.filter_panel.addFilterSet(item.name, item.height_weight);\n\t\t\t\tvar _iteratorNormalCompletion2 = true;\n\t\t\t\tvar _didIteratorError2 = false;\n\t\t\t\tvar _iteratorError2 = undefined;\n\n\t\t\t\ttry {\n\t\t\t\t\tfor (var _iterator2 = item.graphs[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t\t\t\t\t\tvar graph = _step2.value;\n\n\t\t\t\t\t\tthis.filter_panel.addChart(item.name, graph.type, graph.params, graph.name);\n\t\t\t\t\t}\n\t\t\t\t} catch (err) {\n\t\t\t\t\t_didIteratorError2 = true;\n\t\t\t\t\t_iteratorError2 = err;\n\t\t\t\t} finally {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t\t\t\t\t\t\t_iterator2.return();\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tif (_didIteratorError2) {\n\t\t\t\t\t\t\tthrow _iteratorError2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (err) {\n\t\t\t_didIteratorError = true;\n\t\t\t_iteratorError = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t\t_iterator.return();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError) {\n\t\t\t\t\tthrow _iteratorError;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.filter_panel.refresh();\n\t\tthis.data_view.setItems(config.data);\n\n\t\tthis.image_table.addListener(\"data_changed\", function (field, data) {\n\t\t\tself.filter_panel.dataChanged(field, true);\n\t\t});\n\t}\n\n\t_createClass(CIView, [{\n\t\tkey: \"addFilterSet\",\n\t\tvalue: function addFilterSet(name, config, div) {\n\t\t\tthis.filter_panel.addFilterSet(name, null, div);\n\t\t\tvar _iteratorNormalCompletion3 = true;\n\t\t\tvar _didIteratorError3 = false;\n\t\t\tvar _iteratorError3 = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator3 = config[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t\t\t\t\tvar graph = _step3.value;\n\n\t\t\t\t\tthis.filter_panel.addChart(name, graph.type, graph.params, graph.name);\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError3 = true;\n\t\t\t\t_iteratorError3 = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t\t\t\t\t\t_iterator3.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError3) {\n\t\t\t\t\t\tthrow _iteratorError3;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"removeFilterSet\",\n\t\tvalue: function removeFilterSet(name) {\n\t\t\tthis.filter_panel.removeFilterSet(name);\n\t\t}\n\t}, {\n\t\tkey: \"addFilter\",\n\t\tvalue: function addFilter(param, filter, name) {\n\t\t\tvar dim = this.filter_panel.ndx.dimension(function (d) {\n\t\t\t\treturn d[param];\n\t\t\t});\n\t\t\tdim.filter(function (d) {\n\t\t\t\treturn filter(d);\n\t\t\t});\n\t\t\tthis.filters[name] = dim;\n\t\t\t_dc.dc.redrawAll();\n\t\t\tthis.filter_panel._chartFiltered(dim.top(1000000));\n\t\t}\n\t}, {\n\t\tkey: \"removeFilter\",\n\t\tvalue: function removeFilter(name) {\n\t\t\tvar dim = this.filters[name];\n\t\t\tif (!dim) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tdim.filter(null);\n\t\t\t_dc.dc.redrawAll();\n\t\t\tthis.filter_panel._chartFiltered(dim.top(1000000));\n\t\t\tdim.remove();\n\t\t\tdelete this.filters[name];\n\t\t}\n\t}, {\n\t\tkey: \"addButton\",\n\t\tvalue: function addButton(text, func) {\n\t\t\tvar self = this;\n\t\t\tthis.control_div.append($(\"<button>\").attr(\"class\", \"btn btn-sm btn-primary\").css({ \"margin-left\": \"5px\", \"height\": \"24px\", \"padding\": \"0px 5px\" }).text(text).click(function (e) {\n\t\t\t\tfunc(self.data);\n\t\t\t}));\n\t\t}\n\t}, {\n\t\tkey: \"_filterChanged\",\n\t\tvalue: function _filterChanged(data) {\n\t\t\tthis.data_view.setItems(data);\n\t\t\tthis.image_table.show(1);\n\t\t}\n\t}, {\n\t\tkey: \"setListener\",\n\t\tvalue: function setListener(func) {\n\t\t\tthis.listener = func;\n\t\t}\n\t}]);\n\n\treturn CIView;\n}();\n\nexports.CIView = CIView;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY2l2aWV3LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3NyYy9jaXZpZXcuanM/NmQ1NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0ZpbHRlclBhbmVsfSAgZnJvbSBcIi4vZ3JhcGhzLmpzXCI7XHJcbmltcG9ydCB7ZGN9IGZyb20gXCIuL3ZlbmRvci9kYy5qc1wiO1xyXG5pbXBvcnQge01MVkltYWdlVGFibGUsTUxWSW1hZ2VUYWJsZUNvbnRyb2xzfSBmcm9tIFwiLi9pbWFnZV90YWJsZS5qc1wiO1xyXG5pbXBvcnQge0RhdGFWaWV3fSBmcm9tIFwiLi92ZW5kb3Ivc2xpY2suZGF0YXZpZXcuanNcIjtcclxuXHJcbmNsYXNzIENJVmlld3tcclxuXHJcblx0XHJcblxyXG5cdGNvbnN0cnVjdG9yKGNvbmZpZyl7XHJcblx0XHRsZXQgc2VsZj10aGlzO1xyXG5cclxuXHRcdHRoaXMuZmlsdGVycz17fTtcclxuXHJcblx0XHR0aGlzLmRhdGFfdmlldyA9ICBuZXcgRGF0YVZpZXcoKTtcclxuXHRcdGxldCBkaXYgPSAkKFwiI1wiK2NvbmZpZy50YWJsZV9kaXYpO1xyXG5cdFx0dGhpcy5jb250cm9sX2Rpdj0kKFwiPGRpdj5cIikuY3NzKHt3aWR0aDpcIjEwMCVcIixoZWlnaHQ6XCIyNnB4XCJ9KS5hdHRyKFwiaWRcIixcImNpdi1jb250cm9sXCIpLmFwcGVuZFRvKGRpdik7XHJcblx0XHRsZXQgdGFibGVfZGl2PSAkKFwiPGRpdj5cIikuY3NzKHt0b3A6XCIyNXB4XCIsaGVpZ2h0OlwiY2FsYygxMDAlIC0gMjZweClcIn0pLmF0dHIoXCJpZFwiLFwiY2l2LXRhYmxlXCIpLmFwcGVuZFRvKGRpdik7XHJcblx0XHR0aGlzLmZpbHRlcl9wYW5lbCA9IG5ldyBGaWx0ZXJQYW5lbChjb25maWcuZmlsdGVyX2Rpdixjb25maWcuZGF0YSxmdW5jdGlvbihpbmZvKXtcclxuXHRcdFx0c2VsZi5fZmlsdGVyQ2hhbmdlZChpbmZvKTtcclxuXHRcdFx0aWYgKHNlbGYubGlzdGVuZXIpe1xyXG5cdFx0XHRcdHNlbGYubGlzdGVuZXIoaW5mbyk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0dGhpcy5pbWFnZV90YWJsZSA9ICBuZXcgTUxWSW1hZ2VUYWJsZSh0YWJsZV9kaXYsdGhpcy5kYXRhX3ZpZXcsY29uZmlnLmltYWdlX2Jhc2VfdXJsKTtcclxuXHRcdHRoaXMuZGF0YSA9IGNvbmZpZy5kYXRhO1xyXG5cclxuXHRcdG5ldyBNTFZJbWFnZVRhYmxlQ29udHJvbHModGhpcy5pbWFnZV90YWJsZSx0aGlzLmNvbnRyb2xfZGl2KTtcclxuXHJcblx0XHRcclxuXHRcdGZvciAobGV0IGl0ZW0gb2YgY29uZmlnLmdyYXBoX2dyb3Vwcyl7XHJcblx0XHRcdHRoaXMuZmlsdGVyX3BhbmVsLmFkZEZpbHRlclNldChpdGVtLm5hbWUsaXRlbS5oZWlnaHRfd2VpZ2h0KTtcclxuXHRcdFx0Zm9yIChsZXQgZ3JhcGggb2YgaXRlbS5ncmFwaHMpe1xyXG5cdFx0XHRcdHRoaXMuZmlsdGVyX3BhbmVsLmFkZENoYXJ0KGl0ZW0ubmFtZSxncmFwaC50eXBlLGdyYXBoLnBhcmFtcyxncmFwaC5uYW1lKTtcdFx0XHRcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0dGhpcy5maWx0ZXJfcGFuZWwucmVmcmVzaCgpO1xyXG5cdFx0dGhpcy5kYXRhX3ZpZXcuc2V0SXRlbXMoY29uZmlnLmRhdGEpO1xyXG5cclxuXHRcdHRoaXMuaW1hZ2VfdGFibGUuYWRkTGlzdGVuZXIoXCJkYXRhX2NoYW5nZWRcIixmdW5jdGlvbihmaWVsZCxkYXRhKXtcclxuXHRcdFx0c2VsZi5maWx0ZXJfcGFuZWwuZGF0YUNoYW5nZWQoZmllbGQsdHJ1ZSk7XHJcblx0XHR9KVxyXG5cclxuXHR9XHJcblxyXG5cdGFkZEZpbHRlclNldChuYW1lLGNvbmZpZyxkaXYpe1xyXG5cdFx0XHR0aGlzLmZpbHRlcl9wYW5lbC5hZGRGaWx0ZXJTZXQobmFtZSxudWxsLGRpdik7XHJcblx0XHRcdGZvciAobGV0IGdyYXBoIG9mIGNvbmZpZyl7XHJcblx0XHRcdFx0dGhpcy5maWx0ZXJfcGFuZWwuYWRkQ2hhcnQobmFtZSxncmFwaC50eXBlLGdyYXBoLnBhcmFtcyxncmFwaC5uYW1lKVxyXG5cdFx0XHR9XHJcblxyXG5cdH1cclxuXHJcblxyXG5cdHJlbW92ZUZpbHRlclNldChuYW1lKXtcclxuXHRcdHRoaXMuZmlsdGVyX3BhbmVsLnJlbW92ZUZpbHRlclNldChuYW1lKTtcclxuXHR9XHJcblxyXG5cclxuXHJcblx0YWRkRmlsdGVyKHBhcmFtLGZpbHRlcixuYW1lKXtcclxuXHRcdGxldCBkaW0gPSB0aGlzLmZpbHRlcl9wYW5lbC5uZHguZGltZW5zaW9uKGZ1bmN0aW9uKGQpe1xyXG5cdFx0XHRyZXR1cm4gZFtwYXJhbV07XHJcblx0XHR9KTtcclxuXHRcdGRpbS5maWx0ZXIoZnVuY3Rpb24oZCl7XHJcblx0XHRcdHJldHVybiBmaWx0ZXIoZCk7XHJcblx0XHR9KTtcclxuXHRcdHRoaXMuZmlsdGVyc1tuYW1lXT1kaW07XHJcblx0XHRkYy5yZWRyYXdBbGwoKTtcclxuXHRcdHRoaXMuZmlsdGVyX3BhbmVsLl9jaGFydEZpbHRlcmVkKGRpbS50b3AoMTAwMDAwMCkpO1xyXG5cclxuXHR9XHJcblxyXG5cdHJlbW92ZUZpbHRlcihuYW1lKXtcclxuXHRcdGxldCBkaW0gPSB0aGlzLmZpbHRlcnNbbmFtZV07XHJcblx0XHRpZiAoIWRpbSl7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHRcdGRpbS5maWx0ZXIobnVsbClcclxuXHRcdGRjLnJlZHJhd0FsbCgpO1xyXG5cdFx0dGhpcy5maWx0ZXJfcGFuZWwuX2NoYXJ0RmlsdGVyZWQoZGltLnRvcCgxMDAwMDAwKSk7XHJcblx0XHRkaW0ucmVtb3ZlKCk7XHJcblx0XHRkZWxldGUgdGhpcy5maWx0ZXJzW25hbWVdO1xyXG5cclxuXHR9XHJcblxyXG5cdGFkZEJ1dHRvbih0ZXh0LGZ1bmMpe1xyXG5cdFx0bGV0IHNlbGY9dGhpcztcclxuXHRcdHRoaXMuY29udHJvbF9kaXYuYXBwZW5kKCQoXCI8YnV0dG9uPlwiKS5hdHRyKFwiY2xhc3NcIixcImJ0biBidG4tc20gYnRuLXByaW1hcnlcIikuY3NzKHtcIm1hcmdpbi1sZWZ0XCI6XCI1cHhcIixcImhlaWdodFwiOlwiMjRweFwiLFwicGFkZGluZ1wiOlwiMHB4IDVweFwifSkudGV4dCh0ZXh0KS5jbGljayhmdW5jdGlvbihlKXtcclxuXHRcdFx0ZnVuYyhzZWxmLmRhdGEpO1xyXG5cdFx0fSkpO1xyXG5cclxuXHR9XHJcblxyXG5cdF9maWx0ZXJDaGFuZ2VkKGRhdGEpe1xyXG5cdFx0dGhpcy5kYXRhX3ZpZXcuc2V0SXRlbXMoZGF0YSk7XHJcblx0XHR0aGlzLmltYWdlX3RhYmxlLnNob3coMSk7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0TGlzdGVuZXIoZnVuYyl7XHJcblx0XHR0aGlzLmxpc3RlbmVyPWZ1bmM7XHJcblx0fVxyXG5cclxuXHJcblxyXG59XHJcblxyXG5leHBvcnQge0NJVmlld307Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBOzs7QUFDQTtBQUlBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbkJBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFxQkE7QUFBQTtBQUNBO0FBQUE7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUpBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFLQTtBQTFCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUEwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7O0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBSkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU1BOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTs7Ozs7O0FBTUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/ciview.js\n");

/***/ }),

/***/ "./src/graphs.js":
/*!***********************!*\
  !*** ./src/graphs.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.FilterPanel = exports.MLVChart = exports.MLVBarChart = exports.MLVScatterPlot = exports.MLVRingChart = undefined;\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _d = __webpack_require__(/*! ./vendor/d3.js */ \"./src/vendor/d3.js\");\n\nvar _dc = __webpack_require__(/*! ./vendor/dc.js */ \"./src/vendor/dc.js\");\n\nvar _crossfilter = __webpack_require__(/*! ./vendor/crossfilter.js */ \"./src/vendor/crossfilter.js\");\n\nvar _wgl2di = __webpack_require__(/*! ./webgl/wgl2di.js */ \"./src/webgl/wgl2di.js\");\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n$('html > head').append($('<style>.div-bar_chart svg {padding-left:5px; }</style>'));\n\nvar FilterPanel = function () {\n    function FilterPanel(div_id, data, listener) {\n        _classCallCheck(this, FilterPanel);\n\n        var self = this;\n        this.div = $(\"#\" + div_id);\n        this.extra_divs = {};\n        this.ndx = (0, _crossfilter.crossfilter)(data);\n        this.filtered_ids;\n        this.filter_sets = {};\n        this.filter_sets_length = 0;\n        this.charts = {};\n        this.listener = listener;\n        this.total_height_weight = 0;\n        this.set_margin = 30;\n        this.param_to_graph = {};\n        $(window).on(\"resize\", function (e) {\n            self.resize();\n        });\n    }\n\n    _createClass(FilterPanel, [{\n        key: \"resize\",\n        value: function resize() {\n            var n = this.filter_sets_length;\n            var t_height = this.div.height() - n * this.set_margin;\n            for (var name in this.filter_sets) {\n\n                var fs = this.filter_sets[name];\n                var width = fs.div.width() / fs.charts.length;\n                if (width > fs.dimensions[0][0]) {\n                    width = fs.dimensions[0][0];\n                } else if (width < fs.dimensions[0][1]) {\n                    width = fs.dimensions[0][0];\n                }\n\n                var height = t_height * (fs.height_weight / this.total_height_weight);\n                if (this.extra_divs[name]) {\n                    height = fs.div.parent().height() - this.set_margin;\n                }\n                if (height > fs.dimensions[1][0]) {\n                    height = fs.dimensions[1][0];\n                } else if (height < fs.dimensions[1][1]) {\n                    height = fs.dimensions[1][1];\n                }\n\n                var _iteratorNormalCompletion = true;\n                var _didIteratorError = false;\n                var _iteratorError = undefined;\n\n                try {\n                    for (var _iterator = fs.charts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                        var chart = _step.value;\n\n                        chart.setSize(width, height);\n                    }\n                } catch (err) {\n                    _didIteratorError = true;\n                    _iteratorError = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion && _iterator.return) {\n                            _iterator.return();\n                        }\n                    } finally {\n                        if (_didIteratorError) {\n                            throw _iteratorError;\n                        }\n                    }\n                }\n            }\n            _dc.dc.redrawAll();\n        }\n    }, {\n        key: \"dataChanged\",\n        value: function dataChanged(field, not_broadcast) {\n            var chart = this.param_to_graph[field];\n            if (chart) {\n                chart.dataChanged(not_broadcast);\n                chart.chart.redraw();\n            }\n        }\n    }, {\n        key: \"addFilterSet\",\n        value: function addFilterSet(name, height_weight, custom_div) {\n            var div = $(\"<div style='display:flex'></div>\");\n            if (!custom_div) {\n                div.appendTo(this.div);\n                this.filter_sets_length++;\n            } else {\n                div.appendTo(custom_div);\n                this.extra_divs[name] = custom_div;\n            }\n\n            this.filter_sets[name] = { div: div, dimensions: [[2000, 80], [2000, 80]], charts: [] };\n\n            if (!height_weight) {\n                height_weight = 1;\n            }\n            if (!custom_div) {\n                this.filter_sets[name].height_weight = height_weight;\n                this.total_height_weight += height_weight;\n            }\n        }\n    }, {\n        key: \"removeFilterSet\",\n        value: function removeFilterSet(name) {\n            var fs = this.filter_sets[name];\n            if (!fs) {\n                return false;\n            }\n            var left = null;\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n                for (var _iterator2 = fs.charts[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var chart = _step2.value;\n\n                    left = chart.remove();\n                }\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally {\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n\n            if (!this.extra_divs[name]) {\n                this.filter_sets_length--;\n                this.total_height_weight -= fs.height_weight;\n            } else {\n                delete this.extra_divs[name];\n            }\n\n            fs.div.remove();\n            delete this.filter_sets[name];\n            this._chartFiltered(left);\n            this.resize();\n        }\n    }, {\n        key: \"addChart\",\n        value: function addChart(set, type, params, label, size, cap) {\n            var self = this;\n\n            var id = \"filter-chart-\" + FilterPanel.count++;\n            var div = $(\"<div>\").attr(\"id\", id);\n            div.appendTo(this.filter_sets[set].div);\n            var chart = new FilterPanel.chart_types[type](this.ndx, params, id, label, size, cap);\n            this.charts[label] = chart;\n            this.filter_sets[set].charts.push(chart);\n            chart.setUpdateListener(function (filtered_items, name) {\n                self._chartFiltered(filtered_items, name);\n            });\n            if (typeof params !== \"string\") {\n                var _iteratorNormalCompletion3 = true;\n                var _didIteratorError3 = false;\n                var _iteratorError3 = undefined;\n\n                try {\n                    for (var _iterator3 = params[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                        var param = _step3.value;\n\n                        this.param_to_graph[param] = chart;\n                    }\n                } catch (err) {\n                    _didIteratorError3 = true;\n                    _iteratorError3 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                            _iterator3.return();\n                        }\n                    } finally {\n                        if (_didIteratorError3) {\n                            throw _iteratorError3;\n                        }\n                    }\n                }\n            } else {\n                this.param_to_graph[params] = chart;\n            }\n        }\n    }, {\n        key: \"_chartFiltered\",\n        value: function _chartFiltered(filtered_items, chart_exclude) {\n            this.filtered_ids = {};\n            var _iteratorNormalCompletion4 = true;\n            var _didIteratorError4 = false;\n            var _iteratorError4 = undefined;\n\n            try {\n                for (var _iterator4 = filtered_items[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                    var item = _step4.value;\n\n                    this.filtered_ids[item.id] = true;\n                }\n            } catch (err) {\n                _didIteratorError4 = true;\n                _iteratorError4 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                        _iterator4.return();\n                    }\n                } finally {\n                    if (_didIteratorError4) {\n                        throw _iteratorError4;\n                    }\n                }\n            }\n\n            for (var name in this.charts) {\n                var chart = this.charts[name];\n                if (chart._hide) {\n                    if (name == chart_exclude) {\n                        chart._filter(this.filtered_ids);\n                    } else {\n                        chart._hide(this.filtered_ids);\n                    }\n                }\n            }\n            this.listener(filtered_items, this.filtered_ids);\n        }\n    }, {\n        key: \"setListener\",\n        value: function setListener(func) {\n            this.listener = func;\n        }\n    }, {\n        key: \"refresh\",\n        value: function refresh() {\n\n            _dc.dc.renderAll();\n            this.resize();\n        }\n    }]);\n\n    return FilterPanel;\n}();\n\nvar MLVChart = function () {\n    function MLVChart(ndx, div_id, chart_type, title) {\n        _classCallCheck(this, MLVChart);\n\n        var self = this;\n        this.ndx = ndx;\n        this.div = $(\"#\" + div_id).css({ \"display\": \"inline-block\" });\n        var ti = $(\"<span>\").text(title).appendTo(this.div).css({ \"display\": \"flex\", \"white-space\": \"nowrap\" });\n        this.chart = chart_type(\"#\" + div_id);\n        this.chart.on(\"filtered\", function () {\n            if (self.not_broadcast) {\n                self.not_broadcast = false;\n            } else {\n                self.updateListener(self.dim.top(100000));\n            }\n        });\n\n        this.title = title;\n\n        this.chart.controlsUseVisibility(true);\n\n        //let inner_div=$(\"<div>\");\n        //inner_div.append(\"<span style='font-weight:bold'>\"+this.title+\"</span>\");\n        //inner_div.appendTo(this.div);\n        var reset_but = $(\"<button>\").text(\"reset\").attr(\"class\", \"pull-right reset btn btn-sm btn-primary\").css({ height: \"20px\", \"padding\": \"2px\", \"margin-left\": \"5px\", \"visibility\": \"hidden\" }).click(function (e) {\n            self.chart.filterAll();\n            _dc.dc.redrawAll();\n        }).appendTo(ti);\n\n        this.updateListener = function () {};\n    }\n\n    _createClass(MLVChart, [{\n        key: \"setUpdateListener\",\n        value: function setUpdateListener(func) {\n            this.updateListener = func;\n        }\n    }, {\n        key: \"setSize\",\n        value: function setSize(x, y) {\n            this.chart.width(x).height(y);\n            this.width = x;\n            this.height = y;\n        }\n    }, {\n        key: \"remove\",\n        value: function remove() {\n\n            this.dim.filter(null);\n            var left = this.dim.top(1000000);\n            this.dim.dispose();\n            this.chart.resetSvg();\n            this.div.remove();\n            return left;\n        }\n    }, {\n        key: \"dataChanged\",\n        value: function dataChanged() {}\n    }]);\n\n    return MLVChart;\n}();\n\nvar MLVBarChart = function (_MLVChart) {\n    _inherits(MLVBarChart, _MLVChart);\n\n    function MLVBarChart(ndx, param, div_id, title, size) {\n        _classCallCheck(this, MLVBarChart);\n\n        var _this = _possibleConstructorReturn(this, (MLVBarChart.__proto__ || Object.getPrototypeOf(MLVBarChart)).call(this, ndx, div_id, _dc.dc.barChart, title));\n\n        var self = _this;\n        _this.div.addClass(\"class\", \"div-bar_chart\");\n\n        _this.default_bin_number = 10;\n        _this.param = param;\n\n        //work out \n        _this.dim = ndx.dimension(function (d) {\n            return d[self.param];\n        });\n        _this.max = _this.dim.top(1)[0][param];\n        _this.min = _this.dim.bottom(1)[0][param];\n        if (!size) {\n            size = [300, 200];\n        }\n        _this.setSize(size[0], size[1]);\n\n        _this.setParameters({ max: _this.max, min: _this.min, bin_number: _this.default_bin_number });\n        return _this;\n    }\n\n    _createClass(MLVBarChart, [{\n        key: \"setSize\",\n        value: function setSize(x, y) {\n            this.chart.x(_d.d3.scaleLinear().domain([this.display_min - this.bin_width, this.display_max + this.bin_width]));\n            _get(MLVBarChart.prototype.__proto__ || Object.getPrototypeOf(MLVBarChart.prototype), \"setSize\", this).call(this, x, y);\n        }\n    }, {\n        key: \"setParameters\",\n        value: function setParameters(params) {\n            var self = this;\n            if (!params) {\n                this.display_max = this.max;\n                this.display_min = this.min;\n                this.bin_number = this.default_bin_number;\n            } else {\n                if (params.max || params.max === 0) {\n                    this.display_max = params.max;\n                }\n                if (params.min || params.min === 0) {\n                    this.display_min = params.min;\n                }\n                if (params.bin_number) {\n                    this.bin_number = params.bin_number;\n                }\n            }\n            this.dim.dispose();\n            this.range = this.display_max - this.display_min;\n\n            this.bin_width = this.range / this.bin_number;\n            this.dim = this.ndx.dimension(function (d) {\n                if (d[self.param] > self.display_max) {\n                    return self.display_max;\n                }\n                if (d[self.param] < self.display_min) {\n                    return self.display_min;\n                }\n\n                return d[self.param];\n            });\n            if (this.group) {\n                this.group.dispose();\n            }\n            this.group = this.dim.group(function (d) {\n                return self.bin_width * Math.floor(d / self.bin_width);\n            });\n            this.chart.dimension(this.dim).xUnits(_dc.dc.units.fp.precision(this.bin_width)).group(this.group).x(_d.d3.scaleLinear().domain([this.display_min - this.bin_width, this.display_max + this.bin_width])).elasticY(true);\n            this.chart.render();\n        }\n    }]);\n\n    return MLVBarChart;\n}(MLVChart);\n\nvar WGLScatterPlot = function () {\n    function WGLScatterPlot(ndx, params, div_id, title, size) {\n        _classCallCheck(this, WGLScatterPlot);\n\n        this.name = title;\n        if (!size) {\n            size = [200, 200];\n        }\n        this.x = params[0];\n        this.y = params[1];\n        var self = this;\n        this.dim = ndx.dimension(function (d) {\n            return [d[self.x], d[self.y]];\n        }), this.group = this.dim.group();\n\n        var y_dim = ndx.dimension(function (d) {\n            return d[self.y];\n        });\n        this.max_y = y_dim.top(1)[0][self.y];\n        this.min_y = y_dim.bottom(1)[0][self.y];\n        y_dim.dispose();\n        var x_dim = ndx.dimension(function (d) {\n            return d[self.x];\n        });\n        this.max_x = x_dim.top(1)[0][self.x];\n        this.min_x = x_dim.bottom(1)[0][self.x];\n        x_dim.dispose();\n        var x_margin = Math.round((this.max_x - this.min_x) / 10);\n        var y_margin = Math.round((this.max_y - this.min_y) / 10);\n\n        var x_range = this.max_x - this.min_x;\n        this.x_scale = 1000 / x_range;\n        this.x_scale = this.x_scale > 1 ? 1 : this.x_scale;\n\n        var y_range = this.max_y - this.min_y;\n        this.y_scale = 1000 / y_range;\n        this.y_scale = this.y_scale > 1 ? 1 : this.y_scale;\n\n        var div = $(\"#\" + div_id);\n        this.div = div;\n        var title_div = $(\"<div>\").css({ \"display\": \"flex\", \"white-space\": \"no-wrap\" }).text(title);\n        this.reset_but = $(\"<button>\").attr(\"class\", \"pull-right btn btn-sm btn-primary\").text(\"reset\").css({ height: \"20px\", \"padding\": \"2px\", \"margin-left\": \"5px\", \"visibility\": \"hidden\" }).click(function (e) {\n            self.app.clearBrush();\n            self._createFilter(null);\n            self.reset_but.css(\"visibility\", \"hidden\");\n        }).appendTo(title_div);\n        title_div.appendTo(div);\n        var id = \"wg-graph-\" + WGLScatterPlot.count++;\n        var graph_div = $(\"<div>\").css(\"position\", \"relative\").attr(\"id\", id).appendTo(div);\n        $(\"#\" + div_id).css(\"position\", \"relative\");\n\n        this.radius = y_range / 50;\n        this.app = new _wgl2di.WGL2DI(id, 200, 200);\n        var data = this.dim.top(10000000);\n        var _iteratorNormalCompletion5 = true;\n        var _didIteratorError5 = false;\n        var _iteratorError5 = undefined;\n\n        try {\n            for (var _iterator5 = data[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n                var item = _step5.value;\n\n                this.app.addCircle([item[params[0]], -item[params[1]]], this.radius, [123, 45, 67], item.id);\n            }\n        } catch (err) {\n            _didIteratorError5 = true;\n            _iteratorError5 = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion5 && _iterator5.return) {\n                    _iterator5.return();\n                }\n            } finally {\n                if (_didIteratorError5) {\n                    throw _iteratorError5;\n                }\n            }\n        }\n\n        this.app.initialise();\n        this.app.addHandler(\"brush_stopped\", function (range) {\n            self.reset_but.css(\"visibility\", \"visible\");\n            range.y_max = -range.y_max;\n            range.y_min = -range.y_min;\n            self._createFilter(range);\n        });\n    }\n\n    _createClass(WGLScatterPlot, [{\n        key: \"setUpdateListener\",\n        value: function setUpdateListener(func) {\n            this.updateListener = func;\n        }\n    }, {\n        key: \"remove\",\n        value: function remove() {\n            this.dim.filter(null);\n            var left = this.dim.top(1000000);\n            this.dim.dispose();\n            this.div.remove();\n            return left;\n        }\n    }, {\n        key: \"_createFilter\",\n        value: function _createFilter(range) {\n            if (range == null) {\n                this.dim.filter(null);\n            } else {\n\n                this.dim.filter(function (d) {\n                    if (d[0] > range.x_max || d[0] < range.x_min) {\n                        return false;\n                    }\n                    if (d[1] < range.y_max || d[1] > range.y_min) {\n                        return false;\n                    }\n                    return true;\n                });\n            }\n            _dc.dc.redrawAll();\n            var name = this.name;\n            if (range == null) {\n                name = null;\n            }\n            this.updateListener(this.dim.top(1000000), name);\n        }\n    }, {\n        key: \"setSize\",\n        value: function setSize(x, y) {\n            this.app.setSize(x, y);\n\n            var x_margin = Math.round((this.max_x - this.min_x) / 10);\n            var y_margin = Math.round((this.max_y - this.min_y) / 10);\n            var x_range = this.max_x - this.min_x + 2 * x_margin;\n            var y_range = this.max_y - this.min_y + 2 * y_margin;\n\n            var x_scale = x / x_range;\n            var y_scale = y / y_range;\n\n            this.app.x_scale = x / x_range;\n            this.app.y_scale = y / y_range;\n            this.app.offset[0] = -(this.min_x - x_margin);\n            this.app.offset[1] = this.max_y + y_margin;\n            this.app.refresh();\n        }\n    }, {\n        key: \"_hide\",\n        value: function _hide(ids) {\n            this.app.hideObjects(ids);\n            this.app.refresh();\n        }\n    }, {\n        key: \"_filter\",\n        value: function _filter(ids) {\n            this.app.filterObjects(ids);\n            this.app.refresh();\n        }\n    }]);\n\n    return WGLScatterPlot;\n}();\n\nWGLScatterPlot.count = 0;\n\nvar MLVScatterPlot = function (_MLVChart2) {\n    _inherits(MLVScatterPlot, _MLVChart2);\n\n    function MLVScatterPlot(ndx, params, div_id, title, width, size) {\n        _classCallCheck(this, MLVScatterPlot);\n\n        var _this2 = _possibleConstructorReturn(this, (MLVScatterPlot.__proto__ || Object.getPrototypeOf(MLVScatterPlot)).call(this, ndx, div_id, _dc.dc.scatterPlot, title));\n\n        _this2.x = params[0];\n        _this2.y = params[1];\n        var self = _this2;\n        _this2.dim = ndx.dimension(function (d) {\n            return [d[self.x], d[self.y]];\n        }), _this2.group = _this2.dim.group();\n\n        var y_dim = ndx.dimension(function (d) {\n            return d[self.y];\n        });\n        _this2.max_y = y_dim.top(1)[0][self.y];\n        _this2.min_y = y_dim.bottom(1)[0][self.y];\n        y_dim.dispose();\n        var x_dim = ndx.dimension(function (d) {\n            return d[self.x];\n        });\n        _this2.max_x = x_dim.top(1)[0][self.x];\n        _this2.min_x = x_dim.bottom(1)[0][self.x];\n        x_dim.dispose();\n        var x_margin = Math.round((_this2.max_x - _this2.min_x) / 10);\n        var y_margin = Math.round((_this2.max_y - _this2.min_y) / 10);\n\n        _this2.chart.x(_d.d3.scaleLinear().domain([_this2.min_x - x_margin, _this2.max_x + x_margin])).y(_d.d3.scaleLinear().domain([_this2.min_y - y_margin, _this2.max_y + y_margin])).yAxisLabel(\"y\").xAxisLabel(\"x\").clipPadding(10).dimension(_this2.dim).excludedOpacity(0.5).group(_this2.group).colorAccessor(function (d) {\n            return \"red\";\n        });\n\n        if (!size) {\n            size = [300, 300];\n        }\n        _this2.setSize(size[0], size[1]);\n        return _this2;\n    }\n\n    _createClass(MLVScatterPlot, [{\n        key: \"setSize\",\n        value: function setSize(x, y) {\n            var x_margin = Math.round((this.max_x - this.min_x) / 10);\n            var y_margin = Math.round((this.max_y - this.min_y) / 10);\n\n            this.chart.x(_d.d3.scaleLinear().domain([this.min_x - x_margin, this.max_x + x_margin])).y(_d.d3.scaleLinear().domain([this.min_y - y_margin, this.max_y + y_margin]));\n            _get(MLVScatterPlot.prototype.__proto__ || Object.getPrototypeOf(MLVScatterPlot.prototype), \"setSize\", this).call(this, x, y);\n        }\n    }]);\n\n    return MLVScatterPlot;\n}(MLVChart);\n\nvar MLVRowChart = function (_MLVChart3) {\n    _inherits(MLVRowChart, _MLVChart3);\n\n    function MLVRowChart(ndx, param, div_id, title, size, cap) {\n        _classCallCheck(this, MLVRowChart);\n\n        var _this3 = _possibleConstructorReturn(this, (MLVRowChart.__proto__ || Object.getPrototypeOf(MLVRowChart)).call(this, ndx, div_id, _dc.dc.rowChart, title));\n\n        var self = _this3;\n        _this3.param = param;\n\n        _this3.dim = ndx.dimension(function (d) {\n            if (!d[self.param]) {\n                return \"none\";\n            }\n            return d[self.param];\n        });\n        _this3.group = _this3.dim.group().reduceCount();\n        if (!size) {\n            size = [100, 100];\n        }\n        _this3.setSize(size[0], size[1]);\n        _this3.chart.dimension(_this3.dim).group(_this3.group).elasticX(true);\n\n        if (cap) {\n            _this3.chart.cap(5);\n        }\n        _this3.chart.render();\n\n        return _this3;\n    }\n\n    _createClass(MLVRowChart, [{\n        key: \"dataChanged\",\n        value: function dataChanged(not_broadcast) {\n            var self = this;\n            this.not_broadcast = not_broadcast;\n\n            var filter = this.chart.filters();\n            if (filter.length > 0) {\n                this.chart.filter(null);\n            }\n\n            this.dim.dispose();\n\n            this.dim = this.ndx.dimension(function (d) {\n                if (!d[self.param]) {\n                    return \"none\";\n                }\n                return d[self.param];\n            });\n            this.group = this.dim.group().reduceCount();\n            this.chart.dimension(this.dim).group(this.group);\n\n            if (filter.length > 0) {\n                this.not_broadcast = not_broadcast;\n\n                this.chart.filter(filter);\n            }\n        }\n    }, {\n        key: \"setSize\",\n        value: function setSize(x, y) {\n            _get(MLVRowChart.prototype.__proto__ || Object.getPrototypeOf(MLVRowChart.prototype), \"setSize\", this).call(this, x, y);\n            //this.resetDimension()\n        }\n    }]);\n\n    return MLVRowChart;\n}(MLVChart);\n\nvar MLVRingChart = function (_MLVChart4) {\n    _inherits(MLVRingChart, _MLVChart4);\n\n    function MLVRingChart(ndx, param, div_id, title, size) {\n        _classCallCheck(this, MLVRingChart);\n\n        var _this4 = _possibleConstructorReturn(this, (MLVRingChart.__proto__ || Object.getPrototypeOf(MLVRingChart)).call(this, ndx, div_id, _dc.dc.pieChart, title));\n\n        var self = _this4;\n        _this4.param = param;\n        _this4.dim = ndx.dimension(function (d) {\n            return d[self.param];\n        });\n        _this4.group = _this4.dim.group().reduceCount();\n\n        if (!size) {\n            size = [100, 100];\n        }\n        _this4.setSize(size[0], size[1]);\n        _this4.chart.dimension(_this4.dim).group(_this4.group).innerRadius(0.1 * _this4.height);\n\n        return _this4;\n    }\n\n    _createClass(MLVRingChart, [{\n        key: \"setSize\",\n        value: function setSize(x, y) {\n            if (x > y) {\n                x = y;\n            } else if (y > x) {\n                y = x;\n            }\n            _get(MLVRingChart.prototype.__proto__ || Object.getPrototypeOf(MLVRingChart.prototype), \"setSize\", this).call(this, x, y);\n        }\n    }]);\n\n    return MLVRingChart;\n}(MLVChart);\n\nFilterPanel.chart_types = {\n    \"scatter_plot\": MLVScatterPlot,\n    \"bar_chart\": MLVBarChart,\n    \"ring_chart\": MLVRingChart,\n    \"row_chart\": MLVRowChart,\n    \"wgl_scatter_plot\": WGLScatterPlot\n};\n\nFilterPanel.count = 0;\n\nexports.MLVRingChart = MLVRingChart;\nexports.MLVScatterPlot = MLVScatterPlot;\nexports.MLVBarChart = MLVBarChart;\nexports.MLVChart = MLVChart;\nexports.FilterPanel = FilterPanel;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZ3JhcGhzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3NyYy9ncmFwaHMuanM/NjIyOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2QzfSBmcm9tIFwiLi92ZW5kb3IvZDMuanNcIjtcclxuaW1wb3J0IHtkY30gZnJvbSBcIi4vdmVuZG9yL2RjLmpzXCI7XHJcbmltcG9ydCB7Y3Jvc3NmaWx0ZXJ9IGZyb20gXCIuL3ZlbmRvci9jcm9zc2ZpbHRlci5qc1wiO1xyXG5pbXBvcnQge1dHTDJESX0gZnJvbSBcIi4vd2ViZ2wvd2dsMmRpLmpzXCI7XHJcblxyXG5cclxuJCgnaHRtbCA+IGhlYWQnKS5hcHBlbmQoICQoJzxzdHlsZT4uZGl2LWJhcl9jaGFydCBzdmcge3BhZGRpbmctbGVmdDo1cHg7IH08L3N0eWxlPicpKTtcclxuXHJcbmNsYXNzIEZpbHRlclBhbmVse1xyXG4gICAgY29uc3RydWN0b3IoZGl2X2lkLGRhdGEsbGlzdGVuZXIpe1xyXG4gICAgICAgIGxldCBzZWxmPXRoaXM7XHJcbiAgICAgICAgdGhpcy5kaXY9JChcIiNcIitkaXZfaWQpO1xyXG4gICAgICAgIHRoaXMuZXh0cmFfZGl2cz17fTtcclxuICAgICAgICB0aGlzLm5keD0gY3Jvc3NmaWx0ZXIoZGF0YSk7XHJcbiAgICAgICAgdGhpcy5maWx0ZXJlZF9pZHM7XHJcbiAgICAgICAgdGhpcy5maWx0ZXJfc2V0cz17fTtcclxuICAgICAgICB0aGlzLmZpbHRlcl9zZXRzX2xlbmd0aD0wO1xyXG4gICAgICAgIHRoaXMuY2hhcnRzPXt9O1xyXG4gICAgICAgIHRoaXMubGlzdGVuZXI9bGlzdGVuZXI7XHJcbiAgICAgICAgdGhpcy50b3RhbF9oZWlnaHRfd2VpZ2h0PTA7XHJcbiAgICAgICAgdGhpcy5zZXRfbWFyZ2luPTMwO1xyXG4gICAgICAgIHRoaXMucGFyYW1fdG9fZ3JhcGg9e307XHJcbiAgICAgICAgJCh3aW5kb3cpLm9uKFwicmVzaXplXCIsZnVuY3Rpb24oZSl7ICAgICBcclxuICAgICAgICAgICAgc2VsZi5yZXNpemUoKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJlc2l6ZSgpe1xyXG4gICAgICAgIGxldCBuID0gdGhpcy5maWx0ZXJfc2V0c19sZW5ndGg7XHJcbiAgICAgICAgbGV0IHRfaGVpZ2h0PSAodGhpcy5kaXYuaGVpZ2h0KCktKG4qdGhpcy5zZXRfbWFyZ2luKSlcclxuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHRoaXMuZmlsdGVyX3NldHMpe1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAgIGxldCBmcz0gdGhpcy5maWx0ZXJfc2V0c1tuYW1lXTtcclxuICAgICAgICAgICAgbGV0IHdpZHRoID0gZnMuZGl2LndpZHRoKCkvZnMuY2hhcnRzLmxlbmd0aDtcclxuICAgICAgICAgICAgaWYgKHdpZHRoPmZzLmRpbWVuc2lvbnNbMF1bMF0pe1xyXG4gICAgICAgICAgICAgICAgd2lkdGg9ZnMuZGltZW5zaW9uc1swXVswXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh3aWR0aDxmcy5kaW1lbnNpb25zWzBdWzFdKXtcclxuICAgICAgICAgICAgICAgIHdpZHRoPWZzLmRpbWVuc2lvbnNbMF1bMF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIFxyXG4gICAgICAgICAgICBsZXQgaGVpZ2h0ID0gdF9oZWlnaHQgKiAoZnMuaGVpZ2h0X3dlaWdodC90aGlzLnRvdGFsX2hlaWdodF93ZWlnaHQpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5leHRyYV9kaXZzW25hbWVdKXtcclxuICAgICAgICAgICAgICAgIGhlaWdodCA9IGZzLmRpdi5wYXJlbnQoKS5oZWlnaHQoKS10aGlzLnNldF9tYXJnaW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGhlaWdodD5mcy5kaW1lbnNpb25zWzFdWzBdKXtcclxuICAgICAgICAgICAgICAgIGhlaWdodD1mcy5kaW1lbnNpb25zWzFdWzBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGhlaWdodDxmcy5kaW1lbnNpb25zWzFdWzFdKXtcclxuICAgICAgICAgICAgICAgIGhlaWdodD1mcy5kaW1lbnNpb25zWzFdWzFdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IgKGxldCBjaGFydCBvZiBmcy5jaGFydHMpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0LnNldFNpemUod2lkdGgsaGVpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBkYy5yZWRyYXdBbGwoKTtcclxuICAgICAgICBcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZGF0YUNoYW5nZWQoZmllbGQsbm90X2Jyb2FkY2FzdCl7XHJcbiAgICAgICAgbGV0IGNoYXJ0ID0gdGhpcy5wYXJhbV90b19ncmFwaFtmaWVsZF07XHJcbiAgICAgICAgaWYgKGNoYXJ0KXtcclxuICAgICAgICAgICAgY2hhcnQuZGF0YUNoYW5nZWQobm90X2Jyb2FkY2FzdCk7XHJcbiAgICAgICAgICAgIGNoYXJ0LmNoYXJ0LnJlZHJhdygpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGFkZEZpbHRlclNldChuYW1lLGhlaWdodF93ZWlnaHQsY3VzdG9tX2Rpdil7XHJcbiAgICAgICAgbGV0IGRpdiA9JChcIjxkaXYgc3R5bGU9J2Rpc3BsYXk6ZmxleCc+PC9kaXY+XCIpXHJcbiAgICAgICAgaWYgKCFjdXN0b21fZGl2KXtcclxuICAgICAgICAgICAgZGl2LmFwcGVuZFRvKHRoaXMuZGl2KTtcclxuICAgICAgICAgICAgdGhpcy5maWx0ZXJfc2V0c19sZW5ndGgrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgZGl2LmFwcGVuZFRvKGN1c3RvbV9kaXYpO1xyXG4gICAgICAgICAgICB0aGlzLmV4dHJhX2RpdnNbbmFtZV09Y3VzdG9tX2RpdjtcclxuICAgICAgICB9XHJcbiAgICAgICAgIFxyXG4gICAgICAgIHRoaXMuZmlsdGVyX3NldHNbbmFtZV09e2RpdjpkaXYsZGltZW5zaW9uczpbWzIwMDAsODBdLFsyMDAwLDgwXV0sY2hhcnRzOltdfTtcclxuICAgICAgIFxyXG4gICAgICAgIGlmICghaGVpZ2h0X3dlaWdodCl7XHJcbiAgICAgICAgICAgIGhlaWdodF93ZWlnaHQ9MTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFjdXN0b21fZGl2KXtcclxuICAgICAgICAgICAgdGhpcy5maWx0ZXJfc2V0c1tuYW1lXS5oZWlnaHRfd2VpZ2h0PWhlaWdodF93ZWlnaHQ7XHJcbiAgICAgICAgICAgIHRoaXMudG90YWxfaGVpZ2h0X3dlaWdodCs9aGVpZ2h0X3dlaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgICAgIFxyXG4gICAgICAgICAgXHJcbiAgICB9XHJcblxyXG4gICAgcmVtb3ZlRmlsdGVyU2V0KG5hbWUpe1xyXG4gICAgICAgIGxldCBmcyA9IHRoaXMuZmlsdGVyX3NldHNbbmFtZV07XHJcbiAgICAgICAgaWYgKCFmcyl7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGxlZnQgPSBudWxsXHJcbiAgICAgICAgZm9yIChsZXQgY2hhcnQgb2YgZnMuY2hhcnRzKXtcclxuICAgICAgICAgICAgbGVmdCA9Y2hhcnQucmVtb3ZlKClcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLmV4dHJhX2RpdnNbbmFtZV0pe1xyXG4gICAgICAgICAgICB0aGlzLmZpbHRlcl9zZXRzX2xlbmd0aC0tO1xyXG4gICAgICAgICAgICB0aGlzLnRvdGFsX2hlaWdodF93ZWlnaHQtPWZzLmhlaWdodF93ZWlnaHQ7XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5leHRyYV9kaXZzW25hbWVdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnMuZGl2LnJlbW92ZSgpO1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLmZpbHRlcl9zZXRzW25hbWVdO1xyXG4gICAgICAgIHRoaXMuX2NoYXJ0RmlsdGVyZWQobGVmdCk7XHJcbiAgICAgICAgdGhpcy5yZXNpemUoKTtcclxuICAgIH1cclxuXHJcbiAgICBhZGRDaGFydChzZXQsdHlwZSxwYXJhbXMsbGFiZWwsc2l6ZSxjYXApe1xyXG4gICAgICAgIGxldCBzZWxmID0gdGhpcztcclxuICAgICAgICBcclxuICAgICAgICBcclxuICAgICAgICBsZXQgaWQgPSBcImZpbHRlci1jaGFydC1cIitGaWx0ZXJQYW5lbC5jb3VudCsrO1xyXG4gICAgICAgIGxldCBkaXY9JChcIjxkaXY+XCIpLmF0dHIoXCJpZFwiLGlkKTtcclxuICAgICAgICBkaXYuYXBwZW5kVG8odGhpcy5maWx0ZXJfc2V0c1tzZXRdLmRpdik7XHJcbiAgICAgICAgbGV0IGNoYXJ0ID0gbmV3IEZpbHRlclBhbmVsLmNoYXJ0X3R5cGVzW3R5cGVdKHRoaXMubmR4LHBhcmFtcyxpZCxsYWJlbCxzaXplLGNhcCk7XHJcbiAgICAgICAgdGhpcy5jaGFydHNbbGFiZWxdPWNoYXJ0O1xyXG4gICAgICAgIHRoaXMuZmlsdGVyX3NldHNbc2V0XS5jaGFydHMucHVzaChjaGFydCk7XHJcbiAgICAgICAgY2hhcnQuc2V0VXBkYXRlTGlzdGVuZXIoZnVuY3Rpb24oZmlsdGVyZWRfaXRlbXMsbmFtZSl7XHJcbiAgICAgICAgICAgIHNlbGYuX2NoYXJ0RmlsdGVyZWQoZmlsdGVyZWRfaXRlbXMsbmFtZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgICh0eXBlb2YocGFyYW1zKSAhPT1cInN0cmluZ1wiKXtcclxuICAgICAgICAgICAgZm9yIChsZXQgcGFyYW0gb2YgcGFyYW1zKXtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFyYW1fdG9fZ3JhcGhbcGFyYW1dPWNoYXJ0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgIHRoaXMucGFyYW1fdG9fZ3JhcGhbcGFyYW1zXT1jaGFydDtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIF9jaGFydEZpbHRlcmVkKGZpbHRlcmVkX2l0ZW1zLGNoYXJ0X2V4Y2x1ZGUpe1xyXG4gICAgICAgIHRoaXMuZmlsdGVyZWRfaWRzPXt9O1xyXG4gICAgICAgIGZvciAobGV0IGl0ZW0gb2YgZmlsdGVyZWRfaXRlbXMpe1xyXG4gICAgICAgICAgICB0aGlzLmZpbHRlcmVkX2lkc1tpdGVtLmlkXT10cnVlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gdGhpcy5jaGFydHMpe1xyXG4gICAgICAgICAgICBsZXQgY2hhcnQgPSB0aGlzLmNoYXJ0c1tuYW1lXTtcclxuICAgICAgICAgICAgaWYgKGNoYXJ0Ll9oaWRlKXtcclxuICAgICAgICAgICAgICAgIGlmIChuYW1lID09IGNoYXJ0X2V4Y2x1ZGUpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0Ll9maWx0ZXIodGhpcy5maWx0ZXJlZF9pZHMpO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhcnQuX2hpZGUodGhpcy5maWx0ZXJlZF9pZHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgdGhpcy5saXN0ZW5lcihmaWx0ZXJlZF9pdGVtcyx0aGlzLmZpbHRlcmVkX2lkcyk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0TGlzdGVuZXIoZnVuYyl7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5lcj1mdW5jO1xyXG4gICAgfVxyXG5cclxuICAgIHJlZnJlc2goKXtcclxuICAgICAgIFxyXG4gICAgICAgIGRjLnJlbmRlckFsbCgpO1xyXG4gICAgICAgIHRoaXMucmVzaXplKCk7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5cclxuXHJcbmNsYXNzIE1MVkNoYXJ0e1xyXG4gICAgY29uc3RydWN0b3IobmR4LGRpdl9pZCxjaGFydF90eXBlLHRpdGxlKXtcclxuICAgICAgICBsZXQgc2VsZj10aGlzO1xyXG4gICAgICAgIHRoaXMubmR4PW5keDtcclxuICAgICAgICB0aGlzLmRpdj0kKFwiI1wiK2Rpdl9pZCkuY3NzKHtcImRpc3BsYXlcIjpcImlubGluZS1ibG9ja1wifSk7XHJcbiAgICAgICAgbGV0IHRpPSQoXCI8c3Bhbj5cIikudGV4dCh0aXRsZSkuYXBwZW5kVG8odGhpcy5kaXYpLmNzcyh7XCJkaXNwbGF5XCI6XCJmbGV4XCIsXCJ3aGl0ZS1zcGFjZVwiOlwibm93cmFwXCJ9KTtcclxuICAgICAgICB0aGlzLmNoYXJ0PWNoYXJ0X3R5cGUoXCIjXCIrZGl2X2lkKTtcclxuICAgICAgICB0aGlzLmNoYXJ0Lm9uKFwiZmlsdGVyZWRcIixmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICBpZiAoc2VsZi5ub3RfYnJvYWRjYXN0KXtcclxuICAgICAgICAgICAgICAgIHNlbGYubm90X2Jyb2FkY2FzdD1mYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgc2VsZi51cGRhdGVMaXN0ZW5lcihzZWxmLmRpbS50b3AoMTAwMDAwKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMudGl0bGU9dGl0bGU7XHJcblxyXG4gICAgICAgIHRoaXMuY2hhcnQuY29udHJvbHNVc2VWaXNpYmlsaXR5KHRydWUpO1xyXG4gICAgICAgIFxyXG4gICAgICBcclxuICAgICAgICAgXHJcbiAgICAgICAgLy9sZXQgaW5uZXJfZGl2PSQoXCI8ZGl2PlwiKTtcclxuICAgICAgICAvL2lubmVyX2Rpdi5hcHBlbmQoXCI8c3BhbiBzdHlsZT0nZm9udC13ZWlnaHQ6Ym9sZCc+XCIrdGhpcy50aXRsZStcIjwvc3Bhbj5cIik7XHJcbiAgICAgICAgLy9pbm5lcl9kaXYuYXBwZW5kVG8odGhpcy5kaXYpO1xyXG4gICAgICAgIGxldCByZXNldF9idXQgPSAkKFwiPGJ1dHRvbj5cIikudGV4dChcInJlc2V0XCIpLmF0dHIoXCJjbGFzc1wiLFwicHVsbC1yaWdodCByZXNldCBidG4gYnRuLXNtIGJ0bi1wcmltYXJ5XCIpLmNzcyh7aGVpZ2h0OlwiMjBweFwiLFwicGFkZGluZ1wiOlwiMnB4XCIsXCJtYXJnaW4tbGVmdFwiOlwiNXB4XCIsXCJ2aXNpYmlsaXR5XCI6XCJoaWRkZW5cIn0pXHJcbiAgICAgICAgICAgIC5jbGljayhmdW5jdGlvbihlKXtcclxuICAgICAgICAgICAgc2VsZi5jaGFydC5maWx0ZXJBbGwoKTtcclxuICAgICAgICAgICAgZGMucmVkcmF3QWxsKCk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5hcHBlbmRUbyh0aSk7XHJcblxyXG4gICAgICAgIHRoaXMudXBkYXRlTGlzdGVuZXI9ZnVuY3Rpb24oKXt9O1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBzZXRVcGRhdGVMaXN0ZW5lcihmdW5jKXtcclxuICAgICAgICB0aGlzLnVwZGF0ZUxpc3RlbmVyPWZ1bmM7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0U2l6ZSh4LHkpe1xyXG4gICAgICAgIHRoaXMuY2hhcnQud2lkdGgoeCkuaGVpZ2h0KHkpO1xyXG4gICAgICAgIHRoaXMud2lkdGg9eDtcclxuICAgICAgICB0aGlzLmhlaWdodD15O1xyXG4gICAgICAgXHJcbiAgICB9XHJcblxyXG4gICAgcmVtb3ZlKCl7XHJcbiAgICAgICBcclxuICAgICAgICB0aGlzLmRpbS5maWx0ZXIobnVsbCk7XHJcbiAgICAgICAgbGV0IGxlZnQgPSB0aGlzLmRpbS50b3AoMTAwMDAwMCk7XHJcbiAgICAgICAgdGhpcy5kaW0uZGlzcG9zZSgpO1xyXG4gICAgICAgIHRoaXMuY2hhcnQucmVzZXRTdmcoKTtcclxuICAgICAgICB0aGlzLmRpdi5yZW1vdmUoKTtcclxuICAgICAgICByZXR1cm4gbGVmdDtcclxuICAgIH1cclxuXHJcbiAgICBkYXRhQ2hhbmdlZCgpe1xyXG5cclxuICAgIH1cclxuXHJcbn1cclxuXHJcblxyXG5cclxuXHJcblxyXG5jbGFzcyBNTFZCYXJDaGFydCBleHRlbmRzIE1MVkNoYXJ0e1xyXG4gICAgY29uc3RydWN0b3IobmR4LHBhcmFtLGRpdl9pZCx0aXRsZSxzaXplKXtcclxuICAgICAgIFxyXG4gICAgICAgICAgXHJcbiAgICAgICAgXHJcbiAgICAgICAgc3VwZXIobmR4LGRpdl9pZCxkYy5iYXJDaGFydCx0aXRsZSk7XHJcbiAgICAgICAgbGV0IHNlbGYgPXRoaXM7XHJcbiAgICAgICAgdGhpcy5kaXYuYWRkQ2xhc3MoXCJjbGFzc1wiLFwiZGl2LWJhcl9jaGFydFwiKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgIHRoaXMuZGVmYXVsdF9iaW5fbnVtYmVyPTEwO1xyXG4gICAgICAgIHRoaXMucGFyYW09cGFyYW07XHJcbiAgICAgICBcclxuICAgICAgICAvL3dvcmsgb3V0IFxyXG4gICAgICAgIHRoaXMuZGltID0gbmR4LmRpbWVuc2lvbihcclxuICAgICAgICAgICAgZnVuY3Rpb24oZCl7cmV0dXJuIGRbc2VsZi5wYXJhbV07fVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgdGhpcy5tYXggPSB0aGlzLmRpbS50b3AoMSlbMF1bcGFyYW1dO1xyXG4gICAgICAgIHRoaXMubWluPSB0aGlzLmRpbS5ib3R0b20oMSlbMF1bcGFyYW1dO1xyXG4gICAgICAgIGlmICghc2l6ZSl7XHJcbiAgICAgICAgICAgIHNpemU9WzMwMCwyMDBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNldFNpemUoc2l6ZVswXSxzaXplWzFdKTtcclxuICAgICBcclxuXHJcbiAgICAgICAgdGhpcy5zZXRQYXJhbWV0ZXJzKHttYXg6dGhpcy5tYXgsbWluOnRoaXMubWluLGJpbl9udW1iZXI6dGhpcy5kZWZhdWx0X2Jpbl9udW1iZXJ9KTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRTaXplKHgseSl7XHJcbiAgICAgICAgIHRoaXMuY2hhcnQueChkMy5zY2FsZUxpbmVhcigpLmRvbWFpbihbdGhpcy5kaXNwbGF5X21pbi10aGlzLmJpbl93aWR0aCx0aGlzLmRpc3BsYXlfbWF4K3RoaXMuYmluX3dpZHRoXSkpO1xyXG4gICAgICAgICBzdXBlci5zZXRTaXplKHgseSk7XHJcbiAgICB9XHJcblxyXG4gICBcclxuXHJcbiAgICBzZXRQYXJhbWV0ZXJzKHBhcmFtcyl7XHJcbiAgICAgICAgbGV0IHNlbGY9dGhpcztcclxuICAgICAgICBpZiAoIXBhcmFtcyl7XHJcbiAgICAgICAgICB0aGlzLmRpc3BsYXlfbWF4PXRoaXMubWF4O1xyXG4gICAgICAgICAgdGhpcy5kaXNwbGF5X21pbj10aGlzLm1pbjtcclxuICAgICAgICAgIHRoaXMuYmluX251bWJlcj10aGlzLmRlZmF1bHRfYmluX251bWJlcjsgIFxyXG5cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgaWYgKHBhcmFtcy5tYXggfHwgcGFyYW1zLm1heD09PTApe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5X21heD1wYXJhbXMubWF4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwYXJhbXMubWluIHx8IHBhcmFtcy5taW49PT0wKXtcclxuICAgICAgICAgICAgdGhpcy5kaXNwbGF5X21pbj1wYXJhbXMubWluO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwYXJhbXMuYmluX251bWJlcil7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJpbl9udW1iZXI9cGFyYW1zLmJpbl9udW1iZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kaW0uZGlzcG9zZSgpO1xyXG4gICAgICAgIHRoaXMucmFuZ2UgPSB0aGlzLmRpc3BsYXlfbWF4LXRoaXMuZGlzcGxheV9taW5cclxuXHJcbiAgICAgICAgdGhpcy5iaW5fd2lkdGg9dGhpcy5yYW5nZS90aGlzLmJpbl9udW1iZXJcclxuICAgICAgICB0aGlzLmRpbT10aGlzLm5keC5kaW1lbnNpb24oXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uKGQpe1xyXG4gICAgICAgICAgICAgICAgaWYgKGRbc2VsZi5wYXJhbV0+c2VsZi5kaXNwbGF5X21heCl7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZGlzcGxheV9tYXhcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChkW3NlbGYucGFyYW1dPHNlbGYuZGlzcGxheV9taW4pe1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmRpc3BsYXlfbWluXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRbc2VsZi5wYXJhbV07XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgaWYgKHRoaXMuZ3JvdXApe1xyXG4gICAgICAgICAgICB0aGlzLmdyb3VwLmRpc3Bvc2UoKVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmdyb3VwID0gdGhpcy5kaW0uZ3JvdXAoZnVuY3Rpb24oZCl7XHJcbiAgICAgICAgICAgICByZXR1cm4gc2VsZi5iaW5fd2lkdGggKiBNYXRoLmZsb29yKGQvc2VsZi5iaW5fd2lkdGgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuY2hhcnQuZGltZW5zaW9uKHRoaXMuZGltKVxyXG4gICAgICAgICAgICAgICAgICAgLnhVbml0cyhkYy51bml0cy5mcC5wcmVjaXNpb24odGhpcy5iaW5fd2lkdGgpKVxyXG4gICAgICAgICAgICAgICAgICAgLmdyb3VwKHRoaXMuZ3JvdXApXHJcbiAgICAgICAgICAgICAgICAgICAueChkMy5zY2FsZUxpbmVhcigpLmRvbWFpbihbdGhpcy5kaXNwbGF5X21pbi10aGlzLmJpbl93aWR0aCx0aGlzLmRpc3BsYXlfbWF4K3RoaXMuYmluX3dpZHRoXSkpXHJcbiAgICAgICAgICAgICAgICAgICAuZWxhc3RpY1kodHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5jaGFydC5yZW5kZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5jbGFzcyBXR0xTY2F0dGVyUGxvdHtcclxuICAgIGNvbnN0cnVjdG9yKG5keCxwYXJhbXMsZGl2X2lkLHRpdGxlLHNpemUpe1xyXG4gICAgICAgIHRoaXMubmFtZT10aXRsZTtcclxuICAgICAgICBpZiAoIXNpemUpe1xyXG4gICAgICAgICAgICBzaXplPVsyMDAsMjAwXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy54PSBwYXJhbXNbMF07XHJcbiAgICAgICAgdGhpcy55PXBhcmFtc1sxXTtcclxuICAgICAgICBsZXQgc2VsZiA9IHRoaXNcclxuICAgICAgICB0aGlzLmRpbSA9IG5keC5kaW1lbnNpb24oZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtkW3NlbGYueF0sIGRbc2VsZi55XV07XHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgdGhpcy5ncm91cD10aGlzLmRpbS5ncm91cCgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGxldCB5X2RpbSA9IG5keC5kaW1lbnNpb24oZnVuY3Rpb24oZCl7cmV0dXJuIGRbc2VsZi55XX0pO1xyXG4gICAgICAgIHRoaXMubWF4X3k9eV9kaW0udG9wKDEpWzBdW3NlbGYueV07XHJcbiAgICAgICAgdGhpcy5taW5feT15X2RpbS5ib3R0b20oMSlbMF1bc2VsZi55XTtcclxuICAgICAgICB5X2RpbS5kaXNwb3NlKCk7XHJcbiAgICAgICAgbGV0IHhfZGltID0gbmR4LmRpbWVuc2lvbihmdW5jdGlvbihkKXtyZXR1cm4gZFtzZWxmLnhdfSk7XHJcbiAgICAgICAgdGhpcy5tYXhfeD0geF9kaW0udG9wKDEpWzBdW3NlbGYueF07XHJcbiAgICAgICAgdGhpcy5taW5feD0geF9kaW0uYm90dG9tKDEpWzBdW3NlbGYueF07XHJcbiAgICAgICAgeF9kaW0uZGlzcG9zZSgpO1xyXG4gICAgICAgIGxldCB4X21hcmdpbj1NYXRoLnJvdW5kKCh0aGlzLm1heF94LXRoaXMubWluX3gpLzEwKTtcclxuICAgICAgICBsZXQgeV9tYXJnaW49TWF0aC5yb3VuZCgodGhpcy5tYXhfeS10aGlzLm1pbl95KS8xMCk7XHJcblxyXG4gICAgICAgIGxldCB4X3JhbmdlID0gdGhpcy5tYXhfeC10aGlzLm1pbl94O1xyXG4gICAgICAgIHRoaXMueF9zY2FsZT0xMDAwL3hfcmFuZ2U7XHJcbiAgICAgICAgdGhpcy54X3NjYWxlID0gdGhpcy54X3NjYWxlPjE/MTp0aGlzLnhfc2NhbGU7XHJcblxyXG4gICAgICAgIGxldCB5X3JhbmdlID0gdGhpcy5tYXhfeS10aGlzLm1pbl95O1xyXG4gICAgICAgIHRoaXMueV9zY2FsZT0xMDAwL3lfcmFuZ2U7XHJcbiAgICAgICAgdGhpcy55X3NjYWxlID0gdGhpcy55X3NjYWxlPjE/MTp0aGlzLnlfc2NhbGU7XHJcblxyXG4gICAgICAgIGxldCBkaXYgPSAkKFwiI1wiK2Rpdl9pZCk7XHJcbiAgICAgICAgdGhpcy5kaXY9ZGl2O1xyXG4gICAgICAgIGxldCB0aXRsZV9kaXY9JChcIjxkaXY+XCIpLmNzcyh7XCJkaXNwbGF5XCI6XCJmbGV4XCIsXCJ3aGl0ZS1zcGFjZVwiOlwibm8td3JhcFwifSkudGV4dCh0aXRsZSk7XHJcbiAgICAgICAgdGhpcy5yZXNldF9idXQgPSAkKFwiPGJ1dHRvbj5cIikuYXR0cihcImNsYXNzXCIsXCJwdWxsLXJpZ2h0IGJ0biBidG4tc20gYnRuLXByaW1hcnlcIilcclxuICAgICAgICAgICAgIC50ZXh0KFwicmVzZXRcIikuY3NzKHtoZWlnaHQ6XCIyMHB4XCIsXCJwYWRkaW5nXCI6XCIycHhcIixcIm1hcmdpbi1sZWZ0XCI6XCI1cHhcIixcInZpc2liaWxpdHlcIjpcImhpZGRlblwifSlcclxuICAgICAgICAgICAgIC5jbGljayhmdW5jdGlvbihlKXtcclxuICAgICAgICAgICAgICAgICBzZWxmLmFwcC5jbGVhckJydXNoKCk7XHJcbiAgICAgICAgICAgICAgICAgc2VsZi5fY3JlYXRlRmlsdGVyKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgIHNlbGYucmVzZXRfYnV0LmNzcyhcInZpc2liaWxpdHlcIixcImhpZGRlblwiKTtcclxuICAgICAgICAgICAgIH0pLmFwcGVuZFRvKHRpdGxlX2Rpdik7XHJcbiAgICAgICAgdGl0bGVfZGl2LmFwcGVuZFRvKGRpdik7XHJcbiAgICAgICAgbGV0IGlkID0gXCJ3Zy1ncmFwaC1cIitXR0xTY2F0dGVyUGxvdC5jb3VudCsrO1xyXG4gICAgICAgIGxldCBncmFwaF9kaXY9ICQoXCI8ZGl2PlwiKS5jc3MoXCJwb3NpdGlvblwiLFwicmVsYXRpdmVcIikuYXR0cihcImlkXCIsaWQpLmFwcGVuZFRvKGRpdilcclxuICAgICAgICAkKFwiI1wiK2Rpdl9pZCkuY3NzKFwicG9zaXRpb25cIixcInJlbGF0aXZlXCIpO1xyXG5cclxuXHJcblxyXG4gICAgICAgIHRoaXMucmFkaXVzID0geV9yYW5nZS81MDtcclxuICAgICAgICB0aGlzLmFwcCA9IG5ldyBXR0wyREkoaWQsMjAwLDIwMCk7XHJcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmRpbS50b3AoMTAwMDAwMDApO1xyXG4gICAgICAgIGZvciAobGV0IGl0ZW0gb2YgZGF0YSl7XHJcblx0XHRcdHRoaXMuYXBwLmFkZENpcmNsZShbaXRlbVtwYXJhbXNbMF1dLC0oaXRlbVtwYXJhbXNbMV1dKV0sdGhpcy5yYWRpdXMsWzEyMyw0NSw2N10saXRlbS5pZCk7XHJcblx0XHR9XHJcblxyXG5cclxuXHRcdFxyXG5cdFx0XHJcblx0XHR0aGlzLmFwcC5pbml0aWFsaXNlKCk7XHJcblx0XHR0aGlzLmFwcC5hZGRIYW5kbGVyKFwiYnJ1c2hfc3RvcHBlZFwiLGZ1bmN0aW9uKHJhbmdlKXtcclxuXHRcdCAgICBzZWxmLnJlc2V0X2J1dC5jc3MoXCJ2aXNpYmlsaXR5XCIsXCJ2aXNpYmxlXCIpO1xyXG5cdFx0ICAgIHJhbmdlLnlfbWF4PS1yYW5nZS55X21heDtcclxuXHRcdCAgICByYW5nZS55X21pbj0tcmFuZ2UueV9taW47XHJcblx0XHQgICAgc2VsZi5fY3JlYXRlRmlsdGVyKHJhbmdlKTtcclxuXHRcdH0pXHJcbiAgICB9XHJcbiAgICBzZXRVcGRhdGVMaXN0ZW5lcihmdW5jKXtcclxuICAgICAgICB0aGlzLnVwZGF0ZUxpc3RlbmVyPWZ1bmM7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHJlbW92ZSgpe1xyXG4gICAgICAgIHRoaXMuZGltLmZpbHRlcihudWxsKTtcclxuICAgICAgICBsZXQgbGVmdCAgPSB0aGlzLmRpbS50b3AoMTAwMDAwMCk7XHJcbiAgICAgICAgdGhpcy5kaW0uZGlzcG9zZSgpO1xyXG4gICAgICAgIHRoaXMuZGl2LnJlbW92ZSgpO1xyXG4gICAgICAgIHJldHVybiBsZWZ0O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBfY3JlYXRlRmlsdGVyKHJhbmdlKXtcclxuICAgICAgICBpZiAocmFuZ2U9PW51bGwpe1xyXG4gICAgICAgICAgICB0aGlzLmRpbS5maWx0ZXIobnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgIFxyXG4gICAgICAgICAgICB0aGlzLmRpbS5maWx0ZXIoZnVuY3Rpb24oZCl7XHJcbiAgICAgICAgICAgICAgICBpZiAoZFswXT5yYW5nZS54X21heCB8fCBkWzBdPHJhbmdlLnhfbWluKXtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZFsxXTxyYW5nZS55X21heCB8fCBkWzFdPnJhbmdlLnlfbWluKXtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRjLnJlZHJhd0FsbCgpO1xyXG4gICAgICAgIGxldCBuYW1lID0gdGhpcy5uYW1lO1xyXG4gICAgICAgIGlmIChyYW5nZT09bnVsbCl7XHJcbiAgICAgICAgICAgIG5hbWU9bnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy51cGRhdGVMaXN0ZW5lcih0aGlzLmRpbS50b3AoMTAwMDAwMCksbmFtZSk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0U2l6ZSh4LHkpe1xyXG4gICAgICAgIHRoaXMuYXBwLnNldFNpemUoeCx5KTtcclxuICAgICAgICBcclxuICAgICAgXHJcbiAgICAgICAgbGV0IHhfbWFyZ2luPU1hdGgucm91bmQoKHRoaXMubWF4X3gtdGhpcy5taW5feCkvMTApO1xyXG4gICAgICAgIGxldCB5X21hcmdpbj1NYXRoLnJvdW5kKCh0aGlzLm1heF95LXRoaXMubWluX3kpLzEwKTtcclxuICAgICAgICBsZXQgeF9yYW5nZSA9ICh0aGlzLm1heF94LXRoaXMubWluX3gpKzIqeF9tYXJnaW47XHJcbiAgICAgICAgbGV0IHlfcmFuZ2U9ICh0aGlzLm1heF95LXRoaXMubWluX3kpKzIqeV9tYXJnaW47XHJcblxyXG4gICAgICAgIGxldCB4X3NjYWxlPSB4L3hfcmFuZ2U7XHJcbiAgICAgICAgbGV0IHlfc2NhbGU9IHkveV9yYW5nZVxyXG5cclxuICAgICAgICB0aGlzLmFwcC54X3NjYWxlID0geC94X3JhbmdlO1xyXG4gICAgICAgIHRoaXMuYXBwLnlfc2NhbGUgPSB5L3lfcmFuZ2U7XHJcbiAgICAgICAgdGhpcy5hcHAub2Zmc2V0WzBdPS0odGhpcy5taW5feC14X21hcmdpbik7XHJcbiAgICAgICAgdGhpcy5hcHAub2Zmc2V0WzFdPSh0aGlzLm1heF95K3lfbWFyZ2luKTtcclxuICAgICAgIHRoaXMuYXBwLnJlZnJlc2goKTtcclxuICAgICAgICBcclxuICAgIH1cclxuICAgIF9oaWRlKGlkcyl7IFxyXG4gICAgICAgIHRoaXMuYXBwLmhpZGVPYmplY3RzKGlkcyk7XHJcbiAgICAgICAgdGhpcy5hcHAucmVmcmVzaCgpO1xyXG4gICAgfVxyXG5cclxuICAgIF9maWx0ZXIoaWRzKXtcclxuICAgICAgICB0aGlzLmFwcC5maWx0ZXJPYmplY3RzKGlkcyk7XHJcbiAgICAgICAgdGhpcy5hcHAucmVmcmVzaCgpXHJcbiAgICB9XHJcblxyXG59XHJcbldHTFNjYXR0ZXJQbG90LmNvdW50PTA7XHJcblxyXG5cclxuY2xhc3MgTUxWU2NhdHRlclBsb3QgZXh0ZW5kcyBNTFZDaGFydHtcclxuICAgIGNvbnN0cnVjdG9yKG5keCxwYXJhbXMsZGl2X2lkLHRpdGxlLHdpZHRoLHNpemUpe1xyXG4gICAgXHJcbiAgICAgICAgc3VwZXIobmR4LGRpdl9pZCxkYy5zY2F0dGVyUGxvdCx0aXRsZSk7XHJcbiAgICAgICAgdGhpcy54PSBwYXJhbXNbMF07XHJcbiAgICAgICAgdGhpcy55PXBhcmFtc1sxXTtcclxuICAgICAgICBsZXQgc2VsZiA9IHRoaXNcclxuICAgICAgICB0aGlzLmRpbSA9IG5keC5kaW1lbnNpb24oZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtkW3NlbGYueF0sIGRbc2VsZi55XV07XHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgdGhpcy5ncm91cD10aGlzLmRpbS5ncm91cCgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGxldCB5X2RpbSA9IG5keC5kaW1lbnNpb24oZnVuY3Rpb24oZCl7cmV0dXJuIGRbc2VsZi55XX0pO1xyXG4gICAgICAgIHRoaXMubWF4X3k9eV9kaW0udG9wKDEpWzBdW3NlbGYueV07XHJcbiAgICAgICAgdGhpcy5taW5feT15X2RpbS5ib3R0b20oMSlbMF1bc2VsZi55XTtcclxuICAgICAgICB5X2RpbS5kaXNwb3NlKCk7XHJcbiAgICAgICAgbGV0IHhfZGltID0gbmR4LmRpbWVuc2lvbihmdW5jdGlvbihkKXtyZXR1cm4gZFtzZWxmLnhdfSk7XHJcbiAgICAgICAgdGhpcy5tYXhfeD0geF9kaW0udG9wKDEpWzBdW3NlbGYueF07XHJcbiAgICAgICAgdGhpcy5taW5feD0geF9kaW0uYm90dG9tKDEpWzBdW3NlbGYueF07XHJcbiAgICAgICAgeF9kaW0uZGlzcG9zZSgpO1xyXG4gICAgICAgIGxldCB4X21hcmdpbj1NYXRoLnJvdW5kKCh0aGlzLm1heF94LXRoaXMubWluX3gpLzEwKTtcclxuICAgICAgICBsZXQgeV9tYXJnaW49TWF0aC5yb3VuZCgodGhpcy5tYXhfeS10aGlzLm1pbl95KS8xMClcclxuXHJcbiAgICAgICAgdGhpcy5jaGFydFxyXG4gICAgICAgICAgICAueChkMy5zY2FsZUxpbmVhcigpLmRvbWFpbihbdGhpcy5taW5feC14X21hcmdpbix0aGlzLm1heF94K3hfbWFyZ2luXSkpXHJcbiAgICAgICAgICAgIC55KGQzLnNjYWxlTGluZWFyKCkuZG9tYWluKFt0aGlzLm1pbl95LXlfbWFyZ2luLHRoaXMubWF4X3kreV9tYXJnaW5dKSlcclxuICAgICAgICAgICAgLnlBeGlzTGFiZWwoXCJ5XCIpICAgIFxyXG4gICAgICAgICAgICAueEF4aXNMYWJlbChcInhcIilcclxuICAgICAgICAgICAgLmNsaXBQYWRkaW5nKDEwKVxyXG4gICAgICAgICAgICAuZGltZW5zaW9uKHRoaXMuZGltKVxyXG4gICAgICAgICAgICAuZXhjbHVkZWRPcGFjaXR5KDAuNSlcclxuICAgICAgICAgICAgLmdyb3VwKHRoaXMuZ3JvdXApLlxyXG4gICAgICAgICAgICBjb2xvckFjY2Vzc29yKGZ1bmN0aW9uIChkKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBcInJlZFwiO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKCFzaXplKXtcclxuICAgICAgICAgICAgc2l6ZT1bMzAwLDMwMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2V0U2l6ZShzaXplWzBdLHNpemVbMV0pOyAgIFxyXG4gICAgfVxyXG5cclxuICAgIHNldFNpemUoeCx5KXtcclxuICAgICAgICBsZXQgeF9tYXJnaW49TWF0aC5yb3VuZCgodGhpcy5tYXhfeC10aGlzLm1pbl94KS8xMCk7XHJcbiAgICAgICAgbGV0IHlfbWFyZ2luPU1hdGgucm91bmQoKHRoaXMubWF4X3ktdGhpcy5taW5feSkvMTApXHJcblxyXG4gICAgICAgIHRoaXMuY2hhcnRcclxuICAgICAgICAgICAgLngoZDMuc2NhbGVMaW5lYXIoKS5kb21haW4oW3RoaXMubWluX3gteF9tYXJnaW4sdGhpcy5tYXhfeCt4X21hcmdpbl0pKVxyXG4gICAgICAgICAgICAueShkMy5zY2FsZUxpbmVhcigpLmRvbWFpbihbdGhpcy5taW5feS15X21hcmdpbix0aGlzLm1heF95K3lfbWFyZ2luXSkpO1xyXG4gICAgICAgIHN1cGVyLnNldFNpemUoeCx5KTtcclxuICAgIH1cclxufVxyXG5cclxuXHJcblxyXG5jbGFzcyBNTFZSb3dDaGFydCBleHRlbmRzIE1MVkNoYXJ0e1xyXG4gICAgY29uc3RydWN0b3IobmR4LHBhcmFtLGRpdl9pZCx0aXRsZSxzaXplLGNhcCl7XHJcbiAgICAgXHJcbiAgICAgICAgc3VwZXIobmR4LGRpdl9pZCxkYy5yb3dDaGFydCx0aXRsZSk7XHJcbiAgICAgICAgbGV0IHNlbGYgPXRoaXM7XHJcbiAgICAgICAgdGhpcy5wYXJhbT1wYXJhbTtcclxuICAgIFxyXG4gICAgICAgIHRoaXMuZGltID0gbmR4LmRpbWVuc2lvbihmdW5jdGlvbihkKSB7XHJcbiAgICAgICAgICAgIGlmICghZFtzZWxmLnBhcmFtXSl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJub25lXCJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZFtzZWxmLnBhcmFtXTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmdyb3VwPXRoaXMuZGltLmdyb3VwKCkucmVkdWNlQ291bnQoKTtcclxuICAgICAgICBpZiAoIXNpemUpe1xyXG4gICAgICAgICAgIHNpemU9WzEwMCwxMDBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNldFNpemUoc2l6ZVswXSxzaXplWzFdKTtcclxuICAgICAgICB0aGlzLmNoYXJ0XHJcbiAgICAgICAgICAgIC5kaW1lbnNpb24odGhpcy5kaW0pXHJcbiAgICAgICAgICAgIC5ncm91cCh0aGlzLmdyb3VwKVxyXG4gICAgICAgICAgICAgLmVsYXN0aWNYKHRydWUpO1xyXG5cclxuICAgICAgICBpZiAoY2FwKXtcclxuICAgICAgICAgICAgdGhpcy5jaGFydC5jYXAoNSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2hhcnQucmVuZGVyKCk7XHJcbiAgXHJcbiAgICAgICAgIFxyXG5cclxuICAgIH1cclxuXHJcbiAgICBkYXRhQ2hhbmdlZChub3RfYnJvYWRjYXN0KXtcclxuICAgICAgICBsZXQgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5ub3RfYnJvYWRjYXN0PW5vdF9icm9hZGNhc3Q7XHJcblxyXG4gICAgICAgIGxldCBmaWx0ZXI9IHRoaXMuY2hhcnQuZmlsdGVycygpO1xyXG4gICAgICAgICAgaWYgKGZpbHRlci5sZW5ndGg+MCl7XHJcbiAgICAgICAgICAgdGhpcy5jaGFydC5maWx0ZXIobnVsbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmRpbS5kaXNwb3NlKCk7XHJcbiAgXHJcbiAgICBcclxuICAgICAgICB0aGlzLmRpbSA9IHRoaXMubmR4LmRpbWVuc2lvbihmdW5jdGlvbihkKSB7XHJcbiAgICAgICAgICAgIGlmICghZFtzZWxmLnBhcmFtXSl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJub25lXCJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZFtzZWxmLnBhcmFtXTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmdyb3VwPXRoaXMuZGltLmdyb3VwKCkucmVkdWNlQ291bnQoKTtcclxuICAgICAgICB0aGlzLmNoYXJ0XHJcbiAgICAgICAgICAgIC5kaW1lbnNpb24odGhpcy5kaW0pXHJcbiAgICAgICAgICAgIC5ncm91cCh0aGlzLmdyb3VwKVxyXG4gICAgICBcclxuICAgICAgICBpZiAoZmlsdGVyLmxlbmd0aD4wKXtcclxuICAgICAgICAgICAgIHRoaXMubm90X2Jyb2FkY2FzdD1ub3RfYnJvYWRjYXN0XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHRoaXMuY2hhcnQuZmlsdGVyKGZpbHRlcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgXHJcbiAgICB9XHJcblxyXG4gICAgc2V0U2l6ZSh4LHkpe1xyXG4gICAgICAgIHN1cGVyLnNldFNpemUoeCx5KTtcclxuICAgICAgICAvL3RoaXMucmVzZXREaW1lbnNpb24oKVxyXG4gICAgfVxyXG5cclxuXHJcbn1cclxuXHJcbmNsYXNzIE1MVlJpbmdDaGFydCBleHRlbmRzIE1MVkNoYXJ0e1xyXG4gICAgY29uc3RydWN0b3IobmR4LHBhcmFtLGRpdl9pZCx0aXRsZSxzaXplKXtcclxuICAgICAgICBzdXBlcihuZHgsZGl2X2lkLGRjLnBpZUNoYXJ0LHRpdGxlKTtcclxuICAgIFxyXG4gICAgICAgIGxldCBzZWxmID0gdGhpcztcclxuICAgICAgICB0aGlzLnBhcmFtPXBhcmFtO1xyXG4gICAgICAgIHRoaXMuZGltID0gbmR4LmRpbWVuc2lvbihmdW5jdGlvbihkKSB7cmV0dXJuIGRbc2VsZi5wYXJhbV07fSk7XHJcbiAgICAgICAgdGhpcy5ncm91cD10aGlzLmRpbS5ncm91cCgpLnJlZHVjZUNvdW50KCk7XHJcbiAgICAgICBcclxuXHJcblxyXG4gICAgICAgIGlmICghc2l6ZSl7XHJcbiAgICAgICAgICAgc2l6ZT1bMTAwLDEwMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2V0U2l6ZShzaXplWzBdLHNpemVbMV0pO1xyXG4gICAgICAgIHRoaXMuY2hhcnRcclxuICAgICAgICAgICAgLmRpbWVuc2lvbih0aGlzLmRpbSlcclxuICAgICAgICAgICAgLmdyb3VwKHRoaXMuZ3JvdXApXHJcbiAgICAgICAgICAgIC5pbm5lclJhZGl1cygwLjEqdGhpcy5oZWlnaHQpO1xyXG5cclxuXHJcbiAgICB9XHJcblxyXG4gICAgc2V0U2l6ZSh4LHkpe1xyXG4gICAgICAgaWYgKHg+eSl7XHJcbiAgICAgICAgICAgIHg9eTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoeT54KXtcclxuICAgICAgICAgICAgeT14O1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdXBlci5zZXRTaXplKHgseSk7XHJcbiAgICAgICBcclxuICAgIH1cclxufVxyXG5cclxuRmlsdGVyUGFuZWwuY2hhcnRfdHlwZXM9e1xyXG4gICAgXCJzY2F0dGVyX3Bsb3RcIjpNTFZTY2F0dGVyUGxvdCxcclxuICAgIFwiYmFyX2NoYXJ0XCI6TUxWQmFyQ2hhcnQsXHJcbiAgICBcInJpbmdfY2hhcnRcIjpNTFZSaW5nQ2hhcnQsXHJcbiAgICBcInJvd19jaGFydFwiOk1MVlJvd0NoYXJ0LFxyXG4gICAgXCJ3Z2xfc2NhdHRlcl9wbG90XCI6V0dMU2NhdHRlclBsb3RcclxufVxyXG5cclxuRmlsdGVyUGFuZWwuY291bnQ9MDtcclxuXHJcblxyXG5leHBvcnQge01MVlJpbmdDaGFydCxNTFZTY2F0dGVyUGxvdCxNTFZCYXJDaGFydCxNTFZDaGFydCxGaWx0ZXJQYW5lbH07XHJcblxyXG5cclxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBckJBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFzQkE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQXhCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBeUJBO0FBQ0E7QUFHQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFNQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBUkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBSEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUlBO0FBRUE7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFKQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBOzs7Ozs7QUFVQTs7O0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQXZCQTtBQXdCQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBRUE7Ozs7QUFsRkE7QUFDQTtBQXFGQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFuREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQW9EQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBdERBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQTBEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUFBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUdBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXRDQTtBQXVDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTs7OztBQWxEQTtBQUNBO0FBc0RBOzs7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBMUJBO0FBNkJBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBbkVBO0FBQ0E7QUF1RUE7OztBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWZBO0FBb0JBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7Ozs7QUFoQ0E7QUFDQTtBQWtDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUNBO0FBT0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/graphs.js\n");

/***/ }),

/***/ "./src/image_table.js":
/*!****************************!*\
  !*** ./src/image_table.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar MLVImageTable = function () {\n    function MLVImageTable(parent_div, data_view, base_url) {\n        _classCallCheck(this, MLVImageTable);\n\n        this.row_first = 0;\n        this.row_last = 139;\n        this.tile_height = 205;\n        this.tile_width = 205;\n        var self = this;\n\n        var im = new Image();\n        im.src = base_url + \"1.png\";\n        im.onload = function (e) {\n            self.img_width = im.width;\n            self.img_height = im.height;\n            self.setImageDimensions([im.width, im.height]);\n            self.show();\n        };\n        this.base_url = base_url;\n        this.parent = parent_div;\n        this.selected_tiles = {};\n        this.margin = 10;\n\n        this.cache_size = 5;\n\n        this.view_port = $(\"<div>\").height(this.parent.height()).width(this.parent.width()).css({ \"overflow\": \"auto\", \"display\": \"none\" });\n        this.canvas = $(\"<div>\");\n        this.data_view = data_view;\n        parent_div.append(this.view_port);\n        this.width = this.view_port.width();\n        this.height = this.view_port.height();\n\n        this.num_per_row = Math.floor((this.width - 10) / this.tile_width);\n\n        //work out canvas height\n\n        this.canvas.css({ \"position\": \"relative\", \"background-color\": \" LightGray\" }).click(function (e) {\n            var img = $(e.originalEvent.srcElement);\n            var id = img.attr(\"id\");\n            if (!id) {\n                return;\n            }\n            var arr = id.split(\"-\");\n            if (arr[1] === \"tile\") {\n                var range = null;\n                var item = self.data_view.getItemById(arr[2]);\n                var index = self.data_view.getRowById(arr[2]);\n                if (e.shiftKey && (self.last_index_clicked || self.last_index_clicked === 0)) {\n                    range = [];\n                    var diff = index - self.last_index_clicked < 0 ? -1 : 1;\n                    var st = self.last_index_clicked + 1;\n                    var en = index + 1;\n                    if (diff === -1) {\n                        st = index;\n                        en = self.last_index_clicked;\n                    }\n                    for (var i = st; i < en; i++) {\n                        range.push(self.data_view.getItem(i));\n                    }\n                }\n                self.listeners.image_clicked.forEach(function (func) {\n                    func(e, item, img, range);\n                });\n                self.last_index_clicked = index;\n            }\n            //self.mlv_iv.goToLocation(id);\n        });\n        this._setCanvasHeight();\n\n        this.view_port.append(this.canvas).scroll(function (e) {\n            self._hasScrolled();\n        });\n        this.parent.append(this.view_port);\n        var end_row = Math.floor((this.height + this.cache_size * this.tile_height) / this.tile_height);\n        this.max_difference = end_row + this.cache_size;\n        this._addListeners();\n        //this.render(0,end_row,true);\n        this.resize_timeout = null;\n        this.resize_timeout_length = 50;\n\n        this.listeners = {\n            \"image_clicked\": new Map(),\n            \"data_changed\": new Map()\n        };\n\n        this.highlight_colors = null;\n    }\n\n    _createClass(MLVImageTable, [{\n        key: \"addListener\",\n        value: function addListener(type, func, id) {\n            var listener = this.listeners[type];\n            if (!listener) {\n                return null;\n            }\n            if (!id) {\n                id = type + \"_\" + listener.size;\n            }\n            listener.set(id, func);\n            return id;\n        }\n    }, {\n        key: \"removeListener\",\n        value: function removeListener(type, id) {\n            var listener = this.listeners[type];\n            if (!listener) {\n                return false;\n            }\n            return listener.delete(id);\n        }\n    }, {\n        key: \"setImageDimensions\",\n        value: function setImageDimensions(dim) {\n            this.tile_width = parseInt(dim[0]) + this.margin;\n            this.tile_height = parseInt(dim[1]) + this.margin;\n            this.t_width = parseInt(dim[0]);\n            this.t_height = parseInt(dim[1]);\n        }\n    }, {\n        key: \"_addListeners\",\n        value: function _addListeners() {\n            var self = this;\n            clearTimeout(this.resize_timeout);\n            $(window).on(\"resize\", function () {\n                if (self.view_port.css(\"display\") === \"none\") {\n                    return;\n                }\n                self.resize_timeout = setTimeout(function () {\n\n                    self.show();\n                }, self.resize_timeout_length);\n            });\n        }\n    }, {\n        key: \"resize\",\n        value: function resize() {\n            var self = this;\n            clearTimeout(this.resize_timeout);\n            self.resize_timeout = setTimeout(function () {\n                self._resize();\n                self.show();\n            }, self.resize_timeout_length);\n        }\n    }, {\n        key: \"getFirstTileInView\",\n        value: function getFirstTileInView() {\n            var top = this.view_port.scrollTop();\n            return Math.floor(top / this.tile_height) * this.num_per_row;\n        }\n    }, {\n        key: \"_setCanvasHeight\",\n        value: function _setCanvasHeight() {\n            var h = Math.ceil(this.data_view.getLength() / this.num_per_row) * this.tile_height;\n            this.canvas.height(h);\n        }\n    }, {\n        key: \"_hasScrolled\",\n        value: function _hasScrolled() {\n            var _this = this;\n\n            clearTimeout(this.scroll_timeout);\n            var height = this.view_port.height();\n            var s_top = this.view_port.scrollTop();\n            var begin_row = Math.floor((s_top - this.cache_size * this.tile_height) / this.tile_height);\n            var end_row = Math.floor((s_top + height + this.cache_size * this.tile_height) / this.tile_height);\n            if (begin_row < 0) {\n                begin_row = 0;\n            }\n            var elapse = 10;\n            if (Math.abs(begin_row - this.row_displayed_first) > this.max_difference) {\n                elapse = 50;\n            }\n            this.scroll_timeout = setTimeout(function () {\n\n                if (Math.abs(begin_row - _this.row_displayed_first) > _this.max_difference) {\n                    _this.render(begin_row, end_row, true);\n                } else {\n                    _this.render(begin_row, end_row);\n                }\n            }, elapse);\n        }\n    }, {\n        key: \"render\",\n        value: function render(begin_row, end_row, all) {\n\n            if (all) {\n                $(\".mlv-tile\").remove();\n                for (var n = begin_row; n < end_row; n++) {\n                    this._addRow(n);\n                }\n            } else if (begin_row === this.row_displayed_first) {\n                return;\n            } else {\n                if (begin_row < this.row_displayed_first) {\n                    for (var _n = begin_row; _n < this.row_displayed_first; _n++) {\n                        this._addRow(_n);\n                    }\n                    for (var _n2 = end_row; _n2 < this.row_displayed_last; _n2++) {\n                        $(\".mlv-tile-row-\" + _n2).remove();\n                    }\n                } else {\n                    for (var _n3 = this.row_displayed_last; _n3 < end_row; _n3++) {\n                        this._addRow(_n3);\n                    }\n\n                    for (var _n4 = this.row_displayed_first; _n4 < begin_row; _n4++) {\n                        $(\".mlv-tile-row-\" + _n4).remove();\n                    }\n                }\n            }\n\n            for (var id in this.selected_tiles) {\n                $(\"#mlv-tile-\" + id).addClass(\"mlv-tile-selected\");\n            }\n            /*$(\".mlv-tile\").bstooltip({\r\n                 title:function(){\r\n                     return $(this).attr(\"id\");\r\n                 },\r\n                 html:true,\r\n                 container:'body'\r\n            }); \r\n            */\n            this.row_displayed_first = begin_row;\n            this.row_displayed_last = end_row;\n        }\n    }, {\n        key: \"_resize\",\n        value: function _resize() {\n            this.width = this.parent.width();\n            this.height = this.parent.height();\n            this.view_port.height(this.height).width(this.width);\n            this.num_per_row = Math.floor((this.width - 10) / this.tile_width);\n        }\n    }, {\n        key: \"_calculateTopBottomRow\",\n        value: function _calculateTopBottomRow(first_tile_index) {\n            var s_top = 0;\n            if (first_tile_index || first_tile_index === 0) {\n                s_top = Math.floor(first_tile_index / (this.num_per_row + 1)) * this.tile_height;\n            } else {\n                s_top = this.view_port.scrollTop();\n            }\n            var height = this.view_port.height();\n            var begin_row = Math.floor((s_top - this.cache_size * this.tile_height) / this.tile_height);\n            var end_row = Math.floor((s_top + height + this.cache_size * this.tile_height) / this.tile_height);\n            if (begin_row < 0) {\n                begin_row = 0;\n            }\n            return { top: begin_row, bottom: end_row, scroll_top: s_top };\n        }\n    }, {\n        key: \"clearHighlights\",\n        value: function clearHighlights() {\n            this.highlight_colors = null;\n            $(\".mlv-tile\").css(\"border\", \"none\");\n        }\n    }, {\n        key: \"setSelectedTiles\",\n        value: function setSelectedTiles(ids, append) {\n            if (!append) {\n                $(\".mlv-highlight-tile-div\").remove();\n                this.selected_tiles = {};\n            }\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = ids[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var id = _step.value;\n\n                    var tile = $(\"#mlv-tile-\" + id);\n                    var highlight_div = $(\"<div>\").css({\n                        position: \"absolute\",\n                        top: tile.css(\"top\"),\n                        left: tile.css(\"left\")\n                    }).attr(\"class\", \"mlv-highlight-tile-div\").height(tile.height()).width(tile.width());\n                    this.canvas.append(highlight_div);\n                    this.selected_tiles[id] = true;\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"scrollToTile\",\n        value: function scrollToTile(image_index, select) {\n            var item = this.data_view.getItem(image_index);\n            var obj = this._calculateTopBottomRow(image_index);\n            if (Math.abs(obj.top - this.row_displayed_first) > this.max_difference) {\n                this.render(obj.top, obj.bottom, true);\n            } else {\n                this.render(obj.top, obj.bottom);\n            }\n            this.view_port.scrollTop(obj.scroll_top);\n            if (select) {\n                this.setSelectedTiles([item.id]);\n            }\n        }\n    }, {\n        key: \"show\",\n        value: function show(first_tile_id) {\n            this._resize();\n            this._setCanvasHeight();\n            var obj = this._calculateTopBottomRow(first_tile_id);\n            this.view_port.show();\n            this.view_port.scrollTop(obj.scroll_top);\n            this.render(obj.top, obj.bottom, true);\n        }\n    }, {\n        key: \"hide\",\n        value: function hide() {\n            $(\".mlv-tile\").remove();\n            this.view_port.hide();\n        }\n    }, {\n        key: \"_addRow\",\n        value: function _addRow(row) {\n            var st = row * this.num_per_row;\n            var en = st + this.num_per_row;\n            var top = row * this.tile_height + this.margin;\n            var x = 0;\n            for (var i = st; i < en; i++) {\n                var left = x * this.tile_width + this.margin;\n                x++;\n                var item = this.data_view.getItem(i);\n                if (!item) {\n                    return;\n                }\n                var border = \"\";\n                if (this.highlight_colors) {\n                    var val = item[this.highlight_colors['field']];\n                    var color = this.highlight_colors.colors[val];\n                    if (color) {\n                        border = \"border:4px solid \" + color + \";\";\n                    }\n                }\n                var url = this.base_url + item.id + \".png\";\n                var img = $(\"<img src='\" + url + \"' style='\" + border + \"height:\" + this.t_height + \"px;width:\" + this.t_width + \"px;position:absolute;box-sizing:border-box;left:\" + left + \"px\" + \";top:\" + top + \"px' class='mlv-tile mlv-tile-row-\" + row + \"' id='mlv-tile-\" + item.id + \"'>\");\n\n                this.canvas.append(img);\n            }\n        }\n    }]);\n\n    return MLVImageTable;\n}();\n\nvar MLVImageTableControls = function () {\n    function MLVImageTableControls(app, div) {\n        _classCallCheck(this, MLVImageTableControls);\n\n        this.div = div;\n        this.app = app;\n        var self = this;\n        div.append($(\"<i class='fas fa-tags'></i>\").css({ \"cursor\": \"pointer\" }).click(function () {\n            new TaggingDialog(self.app, { name: \"tags\", label: \"Tags\" }, [\"Peak\", \"Noise\"]);\n        }));\n        var slider = $(\"<div>\").css({ width: \"250px\", display: \"inline-block\" }).slider({\n            max: 200,\n            min: 0,\n            value: 100,\n            stop: function stop(e, ui) {\n                var val = ui.value / 100;\n                var width = parseInt(self.app.img_width * val);\n                var height = parseInt(self.app.img_height * val);\n                self.app.setImageDimensions([width, height]);\n                self.app.show();\n            }\n        }).appendTo(this.div);\n        self.total_row_text = $(\"<span>\").css({ \"font-weight\": \"bold\", \"float\": \"right\" }).appendTo(this.div);\n        this._setUpListeners();\n        this.div.children().css({ \"margin-left\": \"5px\" });\n    }\n\n    _createClass(MLVImageTableControls, [{\n        key: \"_setUpListeners\",\n        value: function _setUpListeners() {\n            var self = this;\n            this.app.data_view.onRowCountChanged.subscribe(function (e, args) {\n                self.total_row_text.text(args.current);\n            });\n        }\n    }]);\n\n    return MLVImageTableControls;\n}();\n\nvar TaggingDialog = function () {\n    function TaggingDialog(app, field, options) {\n        _classCallCheck(this, TaggingDialog);\n\n        var self = this;\n        this.field = field;\n        this.options = options;\n        this.color_pallete = [\"#7FFF00\", \"#DC143C\", \"blue\"];\n        this.app = app;\n        this.div = $(\"<div>\");\n        this.div.dialog({\n            autoOpen: true,\n            close: function close() {\n                self.app.removeListener(\"image_clicked\", self.listener);\n                self.app.clearHighlights();\n                $(this).dialog('destroy').remove();\n            },\n            title: \"Tagging\",\n            width: 250\n        });\n        this.init();\n    }\n\n    _createClass(TaggingDialog, [{\n        key: \"imageClicked\",\n        value: function imageClicked(event, data, img, range) {\n            if (!range) {\n                range = [data];\n            }\n            var radio_button = $(\"input[name='tag-option-radio']:checked\");\n            var option = radio_button.val();\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n                for (var _iterator2 = range[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var item = _step2.value;\n\n                    var im = $(\"#mlv-tile-\" + item.id);\n                    if (option === \"None\") {\n                        im.css(\"border\", \"none\");\n                        delete item[this.field.name];\n                    } else {\n                        item[this.field.name] = option;\n                        var color = this.app.highlight_colors.colors[option];\n                        im.css(\"border\", \"4px solid \" + color);\n                    }\n                }\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally {\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n\n            var field = this.field.name;\n            this.app.listeners.data_changed.forEach(function (func) {\n                func(field, range);\n            });\n        }\n    }, {\n        key: \"init\",\n        value: function init() {\n            var self = this;\n            this.options.push(\"None\");\n            var option_grouo_id = \"sc-ra-name-\" + this.id;\n            var count = 0;\n            var colors = {};\n            var _iteratorNormalCompletion3 = true;\n            var _didIteratorError3 = false;\n            var _iteratorError3 = undefined;\n\n            try {\n                for (var _iterator3 = this.options[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                    var option = _step3.value;\n\n                    var checked = count === 0;\n                    var div = $(\"<div>\").height(40);\n                    div.append($(\"<input>\").attr({ type: \"radio\", value: option, checked: checked, name: \"tag-option-radio\" }));\n                    div.append(\"<span>\" + option + \"</span>\");\n\n                    this.div.append(div);\n                    if (option !== \"None\") {\n                        var color_input = $(\"<input>\").attr({ type: \"color\", \"class\": \"tag-option-color\" }).css({ \"display\": \"inline\", \"width\": \"40px\", \"float\": \"right\" }).height(20).val(this.color_pallete[count]).appendTo(div);\n                        colors[option] = this.color_pallete[count];\n                    }\n                    count++;\n                }\n            } catch (err) {\n                _didIteratorError3 = true;\n                _iteratorError3 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                        _iterator3.return();\n                    }\n                } finally {\n                    if (_didIteratorError3) {\n                        throw _iteratorError3;\n                    }\n                }\n            }\n\n            this.app.highlight_colors = { \"field\": this.field.name, \"colors\": colors };\n            this.app.show();\n\n            this.listener = this.app.addListener(\"image_clicked\", function (event, data, img, range) {\n                self.imageClicked(event, data, img, range);\n            });\n        }\n    }]);\n\n    return TaggingDialog;\n}();\n\nexports.MLVImageTable = MLVImageTable;\nexports.MLVImageTableControls = MLVImageTableControls;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW1hZ2VfdGFibGUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2ltYWdlX3RhYmxlLmpzP2U5MGMiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgTUxWSW1hZ2VUYWJsZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnRfZGl2LGRhdGFfdmlldyxiYXNlX3VybCl7XHJcbiAgICAgICAgdGhpcy5yb3dfZmlyc3Q9MDtcclxuICAgICAgICB0aGlzLnJvd19sYXN0PTEzOTtcclxuICAgICAgICB0aGlzLnRpbGVfaGVpZ2h0PTIwNTtcclxuICAgICAgICB0aGlzLnRpbGVfd2lkdGg9MjA1O1xyXG4gICAgICAgIGxldCBzZWxmID10aGlzO1xyXG5cclxuXHJcbiAgICAgICAgbGV0IGltID0gbmV3IEltYWdlKCk7XHJcbiAgICAgICAgaW0uc3JjPWJhc2VfdXJsK1wiMS5wbmdcIjtcclxuICAgICAgICBpbS5vbmxvYWQ9ZnVuY3Rpb24oZSl7XHJcbiAgICAgICAgICAgIHNlbGYuaW1nX3dpZHRoPWltLndpZHRoO1xyXG4gICAgICAgICAgICBzZWxmLmltZ19oZWlnaHQ9aW0uaGVpZ2h0O1xyXG4gICAgICAgICAgICBzZWxmLnNldEltYWdlRGltZW5zaW9ucyhbaW0ud2lkdGgsaW0uaGVpZ2h0XSk7XHJcbiAgICAgICAgICAgIHNlbGYuc2hvdygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmJhc2VfdXJsPWJhc2VfdXJsO1xyXG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50X2RpdjtcclxuICAgICAgICB0aGlzLnNlbGVjdGVkX3RpbGVzPXt9O1xyXG4gICAgICAgIHRoaXMubWFyZ2luPTEwO1xyXG4gICAgICAgXHJcbiAgICAgICAgdGhpcy5jYWNoZV9zaXplPTU7XHJcblxyXG4gICAgICAgIHRoaXMudmlld19wb3J0ID0gJChcIjxkaXY+XCIpLmhlaWdodCh0aGlzLnBhcmVudC5oZWlnaHQoKSkud2lkdGgodGhpcy5wYXJlbnQud2lkdGgoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY3NzKHtcIm92ZXJmbG93XCI6XCJhdXRvXCIsXCJkaXNwbGF5XCI6XCJub25lXCJ9KTtcclxuICAgICAgICB0aGlzLmNhbnZhcyA9ICQoXCI8ZGl2PlwiKTtcclxuICAgICAgICB0aGlzLmRhdGFfdmlldyA9IGRhdGFfdmlldztcclxuICAgICAgICBwYXJlbnRfZGl2LmFwcGVuZCh0aGlzLnZpZXdfcG9ydCk7XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMudmlld19wb3J0LndpZHRoKCk7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLnZpZXdfcG9ydC5oZWlnaHQoKTtcclxuXHJcbiAgICAgICAgdGhpcy5udW1fcGVyX3Jvdz0gTWF0aC5mbG9vcigodGhpcy53aWR0aC0xMCkvdGhpcy50aWxlX3dpZHRoKTtcclxuICAgICAgICBcclxuICAgICAgICAvL3dvcmsgb3V0IGNhbnZhcyBoZWlnaHRcclxuICAgICBcclxuICAgICAgICB0aGlzLmNhbnZhcy5jc3Moe1wicG9zaXRpb25cIjpcInJlbGF0aXZlXCIsXCJiYWNrZ3JvdW5kLWNvbG9yXCI6XCIgTGlnaHRHcmF5XCJ9KS5jbGljayhmdW5jdGlvbihlKXtcclxuICAgICAgICAgICAgbGV0IGltZyA9JChlLm9yaWdpbmFsRXZlbnQuc3JjRWxlbWVudCk7XHJcbiAgICAgICAgICAgIGxldCBpZD0gaW1nLmF0dHIoXCJpZFwiKTtcclxuICAgICAgICAgICAgaWYgKCFpZCl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGFyciA9aWQuc3BsaXQoXCItXCIpO1xyXG4gICAgICAgICAgICBpZiAoYXJyWzFdPT09XCJ0aWxlXCIpe1xyXG4gICAgICAgICAgICAgICAgbGV0IHJhbmdlPW51bGxcclxuICAgICAgICAgICAgICAgIGxldCBpdGVtID0gc2VsZi5kYXRhX3ZpZXcuZ2V0SXRlbUJ5SWQoYXJyWzJdKTtcclxuICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IHNlbGYuZGF0YV92aWV3LmdldFJvd0J5SWQoYXJyWzJdKTtcclxuICAgICAgICAgICAgICAgIGlmIChlLnNoaWZ0S2V5ICYmIChzZWxmLmxhc3RfaW5kZXhfY2xpY2tlZCB8fCBzZWxmLmxhc3RfaW5kZXhfY2xpY2tlZD09PTApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U9W11cclxuICAgICAgICAgICAgICAgICAgICBsZXQgZGlmZiA9IGluZGV4LXNlbGYubGFzdF9pbmRleF9jbGlja2VkPDA/LTE6MTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgc3Q9IHNlbGYubGFzdF9pbmRleF9jbGlja2VkKzE7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVuID1pbmRleCsxO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkaWZmPT09LTEpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdD1pbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW49c2VsZi5sYXN0X2luZGV4X2NsaWNrZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGk9c3Q7aTxlbjtpKyspe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZS5wdXNoKHNlbGYuZGF0YV92aWV3LmdldEl0ZW0oaSkpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIFxyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNlbGYubGlzdGVuZXJzLmltYWdlX2NsaWNrZWQuZm9yRWFjaCgoZnVuYyk9PntmdW5jKGUsaXRlbSxpbWcscmFuZ2UpfSk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmxhc3RfaW5kZXhfY2xpY2tlZD1pbmRleDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL3NlbGYubWx2X2l2LmdvVG9Mb2NhdGlvbihpZCk7XHJcbiAgICAgICAgICBcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9zZXRDYW52YXNIZWlnaHQoKTtcclxuXHJcbiAgICAgICAgdGhpcy52aWV3X3BvcnQuYXBwZW5kKHRoaXMuY2FudmFzKS5zY3JvbGwoZnVuY3Rpb24oZSl7XHJcbiAgICAgICAgICAgIHNlbGYuX2hhc1Njcm9sbGVkKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQuYXBwZW5kKHRoaXMudmlld19wb3J0KTtcclxuICAgICAgICBsZXQgZW5kX3JvdyA9IE1hdGguZmxvb3IoKHRoaXMuaGVpZ2h0Kyh0aGlzLmNhY2hlX3NpemUqdGhpcy50aWxlX2hlaWdodCkpL3RoaXMudGlsZV9oZWlnaHQpO1xyXG4gICAgICAgIHRoaXMubWF4X2RpZmZlcmVuY2U9IGVuZF9yb3crdGhpcy5jYWNoZV9zaXplO1xyXG4gICAgICAgIHRoaXMuX2FkZExpc3RlbmVycygpO1xyXG4gICAgICAgIC8vdGhpcy5yZW5kZXIoMCxlbmRfcm93LHRydWUpO1xyXG4gICAgICAgIHRoaXMucmVzaXplX3RpbWVvdXQ9bnVsbDtcclxuICAgICAgICB0aGlzLnJlc2l6ZV90aW1lb3V0X2xlbmd0aD01MDtcclxuXHJcbiAgICAgICAgdGhpcy5saXN0ZW5lcnM9e1xyXG4gICAgICAgXHRcdFwiaW1hZ2VfY2xpY2tlZFwiOm5ldyBNYXAoKSxcclxuICAgICAgIFx0XHRcImRhdGFfY2hhbmdlZFwiOm5ldyBNYXAoKVxyXG4gICAgICAgXHR9O1xyXG5cclxuICAgICAgIFx0dGhpcy5oaWdobGlnaHRfY29sb3JzPW51bGw7XHJcblxyXG5cclxuXHJcbiAgICB9XHJcblxyXG4gICAgYWRkTGlzdGVuZXIodHlwZSxmdW5jLGlkKXtcclxuICAgIFx0bGV0IGxpc3RlbmVyID0gdGhpcy5saXN0ZW5lcnNbdHlwZV07XHJcbiAgICBcdGlmICghbGlzdGVuZXIpe1xyXG4gICAgXHRcdHJldHVybiBudWxsO1xyXG4gICAgXHR9XHJcbiAgICBcdGlmICghaWQpe1xyXG4gICAgXHRcdGlkID0gdHlwZStcIl9cIitsaXN0ZW5lci5zaXplXHJcbiAgICBcdH1cclxuICAgIFx0bGlzdGVuZXIuc2V0KGlkLGZ1bmMpO1xyXG4gICAgXHRyZXR1cm4gaWQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmVtb3ZlTGlzdGVuZXIodHlwZSxpZCl7XHJcbiAgICBcdGxldCBsaXN0ZW5lciA9IHRoaXMubGlzdGVuZXJzW3R5cGVdO1xyXG4gICAgXHRpZiAoIWxpc3RlbmVyKXtcclxuICAgIFx0XHRyZXR1cm4gZmFsc2U7XHJcbiAgICBcdH1cclxuICAgIFx0cmV0dXJuIGxpc3RlbmVyLmRlbGV0ZShpZCk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIFxyXG4gICAgc2V0SW1hZ2VEaW1lbnNpb25zKGRpbSl7XHJcbiAgICBcdHRoaXMudGlsZV93aWR0aD1wYXJzZUludChkaW1bMF0pK3RoaXMubWFyZ2luO1xyXG4gICAgICAgIHRoaXMudGlsZV9oZWlnaHQ9cGFyc2VJbnQoZGltWzFdKSt0aGlzLm1hcmdpbjtcclxuICAgICAgICB0aGlzLnRfd2lkdGggPSBwYXJzZUludChkaW1bMF0pO1xyXG4gICAgICAgIHRoaXMudF9oZWlnaHQgPSBwYXJzZUludChkaW1bMV0pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBfYWRkTGlzdGVuZXJzKCl7XHJcbiAgICAgICAgbGV0IHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlc2l6ZV90aW1lb3V0KTtcclxuICAgICAgICAkKHdpbmRvdykub24oXCJyZXNpemVcIiwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmIChzZWxmLnZpZXdfcG9ydC5jc3MoXCJkaXNwbGF5XCIpPT09XCJub25lXCIpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICBzZWxmLnJlc2l6ZV90aW1lb3V0PXNldFRpbWVvdXQoKCk9PntcclxuICAgICAgICAgICAgXHQgXHJcbiAgICAgICAgICAgICAgICBzZWxmLnNob3coKTtcclxuICAgICAgICAgICAgfSxzZWxmLnJlc2l6ZV90aW1lb3V0X2xlbmd0aCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcblxyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXNpemUoKXtcclxuICAgIFx0bGV0IHNlbGY9dGhpcztcclxuICAgIFx0Y2xlYXJUaW1lb3V0KHRoaXMucmVzaXplX3RpbWVvdXQpO1xyXG4gICAgXHQgc2VsZi5yZXNpemVfdGltZW91dD1zZXRUaW1lb3V0KCgpPT57XHJcbiAgICBcdFx0IHNlbGYuX3Jlc2l6ZSgpO1xyXG4gICAgICAgICAgICAgc2VsZi5zaG93KCk7XHJcbiAgICAgICAgIH0sc2VsZi5yZXNpemVfdGltZW91dF9sZW5ndGgpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBnZXRGaXJzdFRpbGVJblZpZXcoKXtcclxuICAgICAgICBsZXQgdG9wID0gdGhpcy52aWV3X3BvcnQuc2Nyb2xsVG9wKCk7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IodG9wL3RoaXMudGlsZV9oZWlnaHQpKnRoaXMubnVtX3Blcl9yb3c7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIF9zZXRDYW52YXNIZWlnaHQoKXtcclxuICAgICAgICBsZXQgaCA9IChNYXRoLmNlaWwodGhpcy5kYXRhX3ZpZXcuZ2V0TGVuZ3RoKCkvdGhpcy5udW1fcGVyX3JvdykpKnRoaXMudGlsZV9oZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0KGgpO1xyXG4gICAgfVxyXG5cclxuICAgIF9oYXNTY3JvbGxlZCgpe1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnNjcm9sbF90aW1lb3V0KTtcclxuICAgICAgICAgbGV0IGhlaWdodCA9IHRoaXMudmlld19wb3J0LmhlaWdodCgpO1xyXG4gICAgICAgICAgICBsZXQgc190b3AgPSB0aGlzLnZpZXdfcG9ydC5zY3JvbGxUb3AoKTtcclxuICAgICAgICAgICAgbGV0IGJlZ2luX3JvdyA9IE1hdGguZmxvb3IoKHNfdG9wLSh0aGlzLmNhY2hlX3NpemUqdGhpcy50aWxlX2hlaWdodCkpL3RoaXMudGlsZV9oZWlnaHQpO1xyXG4gICAgICAgICAgICBsZXQgZW5kX3JvdyA9IE1hdGguZmxvb3IoKHNfdG9wK2hlaWdodCsodGhpcy5jYWNoZV9zaXplKnRoaXMudGlsZV9oZWlnaHQpKS90aGlzLnRpbGVfaGVpZ2h0KTtcclxuICAgICAgICAgICAgaWYgKGJlZ2luX3JvdzwwKXtcclxuICAgICAgICAgICAgICAgIGJlZ2luX3Jvdz0wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBlbGFwc2U9MTA7XHJcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhiZWdpbl9yb3ctdGhpcy5yb3dfZGlzcGxheWVkX2ZpcnN0KT50aGlzLm1heF9kaWZmZXJlbmNlKXtcclxuICAgICAgICAgICAgICAgIGVsYXBzZT01MDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2Nyb2xsX3RpbWVvdXQ9IHNldFRpbWVvdXQoKCk9PntcclxuICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGJlZ2luX3Jvdy10aGlzLnJvd19kaXNwbGF5ZWRfZmlyc3QpPnRoaXMubWF4X2RpZmZlcmVuY2Upe1xyXG4gICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyKGJlZ2luX3JvdyxlbmRfcm93LHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcihiZWdpbl9yb3csZW5kX3Jvdyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LGVsYXBzZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyKGJlZ2luX3JvdyxlbmRfcm93LGFsbCl7XHJcbiAgICAgICAgXHJcbiAgICAgICAgIFxyXG4gICAgICAgIGlmIChhbGwpe1xyXG4gICAgICAgICAgICAkKFwiLm1sdi10aWxlXCIpLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBuPWJlZ2luX3JvdztuPGVuZF9yb3c7bisrKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FkZFJvdyhuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChiZWdpbl9yb3c9PT10aGlzLnJvd19kaXNwbGF5ZWRfZmlyc3Qpe1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgIGlmIChiZWdpbl9yb3c8dGhpcy5yb3dfZGlzcGxheWVkX2ZpcnN0KXtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IG49YmVnaW5fcm93O248dGhpcy5yb3dfZGlzcGxheWVkX2ZpcnN0O24rKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkUm93KG4pICAgICBcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAobGV0IG49ZW5kX3JvdztuPHRoaXMucm93X2Rpc3BsYXllZF9sYXN0O24rKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgJChcIi5tbHYtdGlsZS1yb3ctXCIrbikucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IG49dGhpcy5yb3dfZGlzcGxheWVkX2xhc3Q7bjxlbmRfcm93O24rKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkUm93KG4pXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbj10aGlzLnJvd19kaXNwbGF5ZWRfZmlyc3Q7bjxiZWdpbl9yb3c7bisrKXtcclxuICAgICAgICAgICAgICAgICAgICAkKFwiLm1sdi10aWxlLXJvdy1cIituKS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgZm9yIChsZXQgaWQgaW4gdGhpcy5zZWxlY3RlZF90aWxlcyl7XHJcbiAgICAgICAgICAgICQoXCIjbWx2LXRpbGUtXCIraWQpLmFkZENsYXNzKFwibWx2LXRpbGUtc2VsZWN0ZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qJChcIi5tbHYtdGlsZVwiKS5ic3Rvb2x0aXAoe1xyXG4gICAgICAgICAgICAgdGl0bGU6ZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgICByZXR1cm4gJCh0aGlzKS5hdHRyKFwiaWRcIik7XHJcbiAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgaHRtbDp0cnVlLFxyXG4gICAgICAgICAgICAgY29udGFpbmVyOidib2R5J1xyXG4gICAgICAgIH0pOyBcclxuICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucm93X2Rpc3BsYXllZF9maXJzdD1iZWdpbl9yb3c7XHJcbiAgICAgICAgdGhpcy5yb3dfZGlzcGxheWVkX2xhc3Q9ZW5kX3JvdztcclxuXHJcbiAgICB9XHJcblxyXG4gICAgX3Jlc2l6ZSgpe1xyXG4gICAgICAgIHRoaXMud2lkdGggPSB0aGlzLnBhcmVudC53aWR0aCgpO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5wYXJlbnQuaGVpZ2h0KCk7XHJcbiAgICAgICAgdGhpcy52aWV3X3BvcnQuaGVpZ2h0KHRoaXMuaGVpZ2h0KS53aWR0aCh0aGlzLndpZHRoKTtcclxuICAgICAgICB0aGlzLm51bV9wZXJfcm93PSBNYXRoLmZsb29yKCh0aGlzLndpZHRoLTEwKS90aGlzLnRpbGVfd2lkdGgpO1xyXG4gICAgfVxyXG5cclxuICAgIF9jYWxjdWxhdGVUb3BCb3R0b21Sb3coZmlyc3RfdGlsZV9pbmRleCl7XHJcbiAgICAgICAgbGV0IHNfdG9wPTA7XHJcbiAgICAgICAgaWYgKGZpcnN0X3RpbGVfaW5kZXggfHwgZmlyc3RfdGlsZV9pbmRleD09PTApe1xyXG4gICAgICAgICAgICBzX3RvcD0oTWF0aC5mbG9vcihmaXJzdF90aWxlX2luZGV4Lyh0aGlzLm51bV9wZXJfcm93KzEpKSkqdGhpcy50aWxlX2hlaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgc190b3AgPSB0aGlzLnZpZXdfcG9ydC5zY3JvbGxUb3AoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGhlaWdodCA9IHRoaXMudmlld19wb3J0LmhlaWdodCgpO1xyXG4gICAgICAgIGxldCBiZWdpbl9yb3cgPSBNYXRoLmZsb29yKChzX3RvcC0odGhpcy5jYWNoZV9zaXplKnRoaXMudGlsZV9oZWlnaHQpKS90aGlzLnRpbGVfaGVpZ2h0KTtcclxuICAgICAgICBsZXQgZW5kX3JvdyA9IE1hdGguZmxvb3IoKHNfdG9wK2hlaWdodCsodGhpcy5jYWNoZV9zaXplKnRoaXMudGlsZV9oZWlnaHQpKS90aGlzLnRpbGVfaGVpZ2h0KTtcclxuICAgICAgICBpZiAoYmVnaW5fcm93PDApe1xyXG4gICAgICAgICAgICAgICAgYmVnaW5fcm93PTA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAoe3RvcDpiZWdpbl9yb3csYm90dG9tOmVuZF9yb3csc2Nyb2xsX3RvcDpzX3RvcH0pICAgIFxyXG4gICAgfVxyXG5cclxuICAgIGNsZWFySGlnaGxpZ2h0cygpe1xyXG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0X2NvbG9ycz1udWxsO1xyXG4gICAgICAgICQoXCIubWx2LXRpbGVcIikuY3NzKFwiYm9yZGVyXCIsXCJub25lXCIpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBzZXRTZWxlY3RlZFRpbGVzKGlkcyxhcHBlbmQpe1xyXG4gICAgICAgIGlmICghYXBwZW5kKXtcclxuICAgICAgICAgICAgJChcIi5tbHYtaGlnaGxpZ2h0LXRpbGUtZGl2XCIpLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkX3RpbGVzPXt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpZCBvZiBpZHMpe1xyXG4gICAgICAgICAgICBsZXQgdGlsZSA9ICQoXCIjbWx2LXRpbGUtXCIraWQpO1xyXG4gICAgICAgICAgICBsZXQgaGlnaGxpZ2h0X2Rpdj0kKFwiPGRpdj5cIilcclxuICAgICAgICAgICAgLmNzcyh7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjpcImFic29sdXRlXCIsXHJcbiAgICAgICAgICAgICAgICB0b3A6dGlsZS5jc3MoXCJ0b3BcIiksXHJcbiAgICAgICAgICAgICAgICBsZWZ0OnRpbGUuY3NzKFwibGVmdFwiKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsXCJtbHYtaGlnaGxpZ2h0LXRpbGUtZGl2XCIpXHJcbiAgICAgICAgICAgIC5oZWlnaHQodGlsZS5oZWlnaHQoKSlcclxuICAgICAgICAgICAgLndpZHRoKHRpbGUud2lkdGgoKSk7XHJcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLmFwcGVuZChoaWdobGlnaHRfZGl2KVxyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkX3RpbGVzW2lkXT10cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgIH1cclxuXHJcbiAgICBzY3JvbGxUb1RpbGUoaW1hZ2VfaW5kZXgsc2VsZWN0KXtcclxuICAgICAgICBsZXQgaXRlbT0gdGhpcy5kYXRhX3ZpZXcuZ2V0SXRlbShpbWFnZV9pbmRleCk7XHJcbiAgICAgICAgbGV0IG9iaiA9IHRoaXMuX2NhbGN1bGF0ZVRvcEJvdHRvbVJvdyhpbWFnZV9pbmRleCk7XHJcbiAgICAgICAgaWYgKE1hdGguYWJzKG9iai50b3AtdGhpcy5yb3dfZGlzcGxheWVkX2ZpcnN0KT50aGlzLm1heF9kaWZmZXJlbmNlKXtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXIob2JqLnRvcCxvYmouYm90dG9tLHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlcihvYmoudG9wLG9iai5ib3R0b20pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnZpZXdfcG9ydC5zY3JvbGxUb3Aob2JqLnNjcm9sbF90b3ApO1xyXG4gICAgICAgIGlmIChzZWxlY3Qpe1xyXG4gICAgICAgICAgICB0aGlzLnNldFNlbGVjdGVkVGlsZXMoW2l0ZW0uaWRdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHNob3coZmlyc3RfdGlsZV9pZCl7XHJcbiAgICAgICAgdGhpcy5fcmVzaXplKCk7XHJcbiAgICAgICAgdGhpcy5fc2V0Q2FudmFzSGVpZ2h0KCk7XHJcbiAgICAgICAgbGV0IG9iaj10aGlzLl9jYWxjdWxhdGVUb3BCb3R0b21Sb3coZmlyc3RfdGlsZV9pZCk7XHJcbiAgICAgICAgdGhpcy52aWV3X3BvcnQuc2hvdygpO1xyXG4gICAgICAgIHRoaXMudmlld19wb3J0LnNjcm9sbFRvcChvYmouc2Nyb2xsX3RvcCk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXIob2JqLnRvcCxvYmouYm90dG9tLHRydWUpO1xyXG4gICAgfVxyXG4gICAgaGlkZSgpe1xyXG4gICAgICAgICQoXCIubWx2LXRpbGVcIikucmVtb3ZlKCk7XHJcbiAgICAgICAgdGhpcy52aWV3X3BvcnQuaGlkZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIF9hZGRSb3cocm93KXtcclxuICAgICAgICBsZXQgc3QgPSByb3cqdGhpcy5udW1fcGVyX3JvdztcclxuICAgICAgICBsZXQgZW4gPSBzdCt0aGlzLm51bV9wZXJfcm93O1xyXG4gICAgICAgIGxldCB0b3AgPSByb3cgKiB0aGlzLnRpbGVfaGVpZ2h0K3RoaXMubWFyZ2luO1xyXG4gICAgICAgIGxldCB4PTA7XHJcbiAgICAgICAgZm9yIChsZXQgaT1zdDtpPGVuO2krKyl7XHJcbiAgICAgICAgICAgIGxldCBsZWZ0PXgqdGhpcy50aWxlX3dpZHRoK3RoaXMubWFyZ2luO1xyXG4gICAgICAgICAgICB4Kys7XHJcbiAgICAgICAgICAgIGxldCBpdGVtID10aGlzLmRhdGFfdmlldy5nZXRJdGVtKGkpO1xyXG4gICAgICAgICAgICBpZiAoIWl0ZW0pe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBib3JkZXI9XCJcIlxyXG4gICAgICAgICAgICBpZiAodGhpcy5oaWdobGlnaHRfY29sb3JzKXtcclxuICAgICAgICAgICAgICAgIGxldCB2YWwgPWl0ZW1bdGhpcy5oaWdobGlnaHRfY29sb3JzWydmaWVsZCddXTtcclxuICAgICAgICAgICAgICAgIGxldCBjb2xvciA9IHRoaXMuaGlnaGxpZ2h0X2NvbG9ycy5jb2xvcnNbdmFsXTtcclxuICAgICAgICAgICAgICAgIGlmIChjb2xvcil7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyPSBcImJvcmRlcjo0cHggc29saWQgXCIrY29sb3IrXCI7XCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCB1cmwgPSB0aGlzLmJhc2VfdXJsK2l0ZW0uaWQrXCIucG5nXCI7XHJcbiAgICAgICAgICAgIGxldCBpbWcgPSAkKFwiPGltZyBzcmM9J1wiK3VybCtcIicgc3R5bGU9J1wiK2JvcmRlcitcImhlaWdodDpcIit0aGlzLnRfaGVpZ2h0K1wicHg7d2lkdGg6XCIrdGhpcy50X3dpZHRoK1wicHg7cG9zaXRpb246YWJzb2x1dGU7Ym94LXNpemluZzpib3JkZXItYm94O2xlZnQ6XCIrbGVmdCtcInB4XCIrXCI7dG9wOlwiK3RvcCtcInB4JyBjbGFzcz0nbWx2LXRpbGUgbWx2LXRpbGUtcm93LVwiK3JvdytcIicgaWQ9J21sdi10aWxlLVwiK2l0ZW0uaWQrXCInPlwiKTtcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgdGhpcy5jYW52YXMuYXBwZW5kKGltZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuY2xhc3MgTUxWSW1hZ2VUYWJsZUNvbnRyb2xze1xyXG4gICAgY29uc3RydWN0b3IoYXBwLGRpdil7XHJcbiAgICAgICAgdGhpcy5kaXY9ZGl2O1xyXG4gICAgICAgIHRoaXMuYXBwPWFwcDtcclxuICAgICAgICBsZXQgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgZGl2LmFwcGVuZCgkKFwiPGkgY2xhc3M9J2ZhcyBmYS10YWdzJz48L2k+XCIpXHJcbiAgICAgICAgICAgICAgICAuY3NzKHtcImN1cnNvclwiOlwicG9pbnRlclwifSlcclxuICAgICAgICAgICAgICAgIC5jbGljayhmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgICAgIG5ldyBUYWdnaW5nRGlhbG9nKHNlbGYuYXBwLHtuYW1lOlwidGFnc1wiLGxhYmVsOlwiVGFnc1wifSxbXCJQZWFrXCIsXCJOb2lzZVwiXSk7XHJcbiAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgIGxldCBzbGlkZXIgPSAkKFwiPGRpdj5cIikuY3NzKHt3aWR0aDpcIjI1MHB4XCIsZGlzcGxheTpcImlubGluZS1ibG9ja1wifSkuc2xpZGVyKHtcclxuICAgICAgICAgICAgbWF4OjIwMCxcclxuICAgICAgICAgICAgbWluOjAsXHJcbiAgICAgICAgICAgIHZhbHVlOjEwMCxcclxuICAgICAgICAgICAgc3RvcDpmdW5jdGlvbihlLHVpKXtcclxuICAgICAgICAgICAgICAgICBsZXQgdmFsID11aS52YWx1ZS8xMDA7XHJcbiAgICAgICAgICAgICAgICAgbGV0IHdpZHRoID0gcGFyc2VJbnQoc2VsZi5hcHAuaW1nX3dpZHRoKnZhbCk7XHJcbiAgICAgICAgICAgICAgICAgbGV0IGhlaWdodD0gcGFyc2VJbnQoc2VsZi5hcHAuaW1nX2hlaWdodCp2YWwpO1xyXG4gICAgICAgICAgICAgICAgIHNlbGYuYXBwLnNldEltYWdlRGltZW5zaW9ucyhbd2lkdGgsaGVpZ2h0XSk7XHJcbiAgICAgICAgICAgICAgICAgc2VsZi5hcHAuc2hvdygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkuYXBwZW5kVG8odGhpcy5kaXYpO1xyXG4gICAgICAgIHNlbGYudG90YWxfcm93X3RleHQ9JChcIjxzcGFuPlwiKS5jc3Moe1wiZm9udC13ZWlnaHRcIjpcImJvbGRcIixcImZsb2F0XCI6XCJyaWdodFwifSkuYXBwZW5kVG8odGhpcy5kaXYpO1xyXG4gICAgICAgIHRoaXMuX3NldFVwTGlzdGVuZXJzKCk7XHJcbiAgICAgICAgdGhpcy5kaXYuY2hpbGRyZW4oKS5jc3Moe1wibWFyZ2luLWxlZnRcIjpcIjVweFwifSk7XHJcbiAgICB9XHJcblxyXG4gICAgX3NldFVwTGlzdGVuZXJzKCl7XHJcbiAgICAgICAgbGV0IHNlbGYgPXRoaXM7XHJcbiAgICAgICAgdGhpcy5hcHAuZGF0YV92aWV3Lm9uUm93Q291bnRDaGFuZ2VkLnN1YnNjcmliZShmdW5jdGlvbiAoZSwgYXJncykge1xyXG4gICAgICAgICAgICBzZWxmLnRvdGFsX3Jvd190ZXh0LnRleHQoYXJncy5jdXJyZW50KTtcclxuICAgICAgICB9KVxyXG4gICBcclxuICAgIH1cclxuXHJcbn1cclxuXHJcblxyXG5cclxuY2xhc3MgVGFnZ2luZ0RpYWxvZ3tcclxuICAgIGNvbnN0cnVjdG9yKGFwcCxmaWVsZCxvcHRpb25zKXtcclxuICAgICAgICBsZXQgc2VsZj10aGlzO1xyXG4gICAgICAgIHRoaXMuZmllbGQ9ZmllbGQ7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zPW9wdGlvbnM7XHJcbiAgICAgICAgdGhpcy5jb2xvcl9wYWxsZXRlPVtcIiM3RkZGMDBcIixcIiNEQzE0M0NcIixcImJsdWVcIl07XHJcbiAgICAgICAgdGhpcy5hcHA9YXBwO1xyXG4gICAgICAgIHRoaXMuZGl2ID0gJChcIjxkaXY+XCIpOyAgIFxyXG4gICAgICAgIHRoaXMuZGl2LmRpYWxvZyh7XHJcbiAgICAgICAgICAgIGF1dG9PcGVuOiB0cnVlLCAgICAgIFxyXG4gICAgICAgICAgICBjbG9zZTpmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgc2VsZi5hcHAucmVtb3ZlTGlzdGVuZXIoXCJpbWFnZV9jbGlja2VkXCIsc2VsZi5saXN0ZW5lcik7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmFwcC5jbGVhckhpZ2hsaWdodHMoKTtcclxuICAgICAgICAgICAgICAgICQodGhpcykuZGlhbG9nKCdkZXN0cm95JykucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHRpdGxlOiBcIlRhZ2dpbmdcIixcclxuICAgICAgICAgICAgd2lkdGg6MjUwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5pbml0KCk7XHJcbiAgICAgICAgXHJcbiAgICB9XHJcblxyXG5cclxuICAgIGltYWdlQ2xpY2tlZChldmVudCxkYXRhLGltZyxyYW5nZSl7XHJcbiAgICAgICAgaWYgKCFyYW5nZSl7XHJcbiAgICAgICAgICAgIHJhbmdlPVtkYXRhXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHJhZGlvX2J1dHRvbj0kKFwiaW5wdXRbbmFtZT0ndGFnLW9wdGlvbi1yYWRpbyddOmNoZWNrZWRcIik7XHJcbiAgICAgICAgbGV0IG9wdGlvbiA9IHJhZGlvX2J1dHRvbi52YWwoKTtcclxuICAgICAgICBmb3IgKGxldCBpdGVtIG9mIHJhbmdlKXtcclxuICAgICAgICAgICAgbGV0IGltID0gJChcIiNtbHYtdGlsZS1cIitpdGVtLmlkKTtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbiA9PT0gXCJOb25lXCIpe1xyXG4gICAgICAgICAgICAgICAgaW0uY3NzKFwiYm9yZGVyXCIsXCJub25lXCIpO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGl0ZW1bdGhpcy5maWVsZC5uYW1lXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgaXRlbVt0aGlzLmZpZWxkLm5hbWVdPW9wdGlvbjtcclxuICAgICAgICAgICAgICAgIGxldCBjb2xvciA9IHRoaXMuYXBwLmhpZ2hsaWdodF9jb2xvcnMuY29sb3JzW29wdGlvbl07XHJcbiAgICAgICAgICAgICAgICBpbS5jc3MoXCJib3JkZXJcIixcIjRweCBzb2xpZCBcIitjb2xvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGZpZWxkPSB0aGlzLmZpZWxkLm5hbWVcclxuICAgICAgICB0aGlzLmFwcC5saXN0ZW5lcnMuZGF0YV9jaGFuZ2VkLmZvckVhY2goKGZ1bmMpPT57ZnVuYyhmaWVsZCxyYW5nZSl9KTsgICAgICAgXHJcbiAgICB9XHJcblxyXG4gICAgIFxyXG4gICAgaW5pdCgpe1xyXG4gICAgICAgIGxldCBzZWxmPXRoaXM7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zLnB1c2goXCJOb25lXCIpO1xyXG4gICAgICAgIGxldCBvcHRpb25fZ3JvdW9faWQ9IFwic2MtcmEtbmFtZS1cIit0aGlzLmlkO1xyXG4gICAgICAgIGxldCBjb3VudD0wO1xyXG4gICAgICAgIGxldCBjb2xvcnM9IHt9O1xyXG4gICAgICAgIGZvciAobGV0IG9wdGlvbiBvZiB0aGlzLm9wdGlvbnMpe1xyXG4gICAgICAgICAgICBsZXQgY2hlY2tlZD0oY291bnQ9PT0wKVxyXG4gICAgICAgICAgICBsZXQgZGl2ID0gJChcIjxkaXY+XCIpLmhlaWdodCg0MCk7XHJcbiAgICAgICAgICAgIGRpdi5hcHBlbmQoJChcIjxpbnB1dD5cIikuYXR0cih7dHlwZTpcInJhZGlvXCIsdmFsdWU6b3B0aW9uLGNoZWNrZWQ6Y2hlY2tlZCxuYW1lOlwidGFnLW9wdGlvbi1yYWRpb1wifSkpO1xyXG4gICAgICAgICAgICBkaXYuYXBwZW5kKFwiPHNwYW4+XCIrb3B0aW9uK1wiPC9zcGFuPlwiKTtcclxuICAgICAgICAgICBcclxuICAgICAgICAgICAgdGhpcy5kaXYuYXBwZW5kKGRpdik7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb24gIT09XCJOb25lXCIpe1xyXG4gICAgICAgICAgICAgICAgbGV0IGNvbG9yX2lucHV0PSQoXCI8aW5wdXQ+XCIpLmF0dHIoe3R5cGU6XCJjb2xvclwiLFwiY2xhc3NcIjpcInRhZy1vcHRpb24tY29sb3JcIn0pLmNzcyh7XCJkaXNwbGF5XCI6XCJpbmxpbmVcIixcIndpZHRoXCI6XCI0MHB4XCIsXCJmbG9hdFwiOlwicmlnaHRcIn0pLmhlaWdodCgyMCkudmFsKHRoaXMuY29sb3JfcGFsbGV0ZVtjb3VudF0pLmFwcGVuZFRvKGRpdik7XHJcbiAgICAgICAgICAgICAgICBjb2xvcnNbb3B0aW9uXT10aGlzLmNvbG9yX3BhbGxldGVbY291bnRdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvdW50Kys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYXBwLmhpZ2hsaWdodF9jb2xvcnM9e1wiZmllbGRcIjp0aGlzLmZpZWxkLm5hbWUsXCJjb2xvcnNcIjpjb2xvcnN9O1xyXG4gICAgICAgIHRoaXMuYXBwLnNob3coKTtcclxuXHJcbiAgICAgICAgdGhpcy5saXN0ZW5lcj0gdGhpcy5hcHAuYWRkTGlzdGVuZXIoXCJpbWFnZV9jbGlja2VkXCIsZnVuY3Rpb24oZXZlbnQsZGF0YSxpbWcscmFuZ2Upe1xyXG4gICAgICAgICAgICAgc2VsZi5pbWFnZUNsaWNrZWQoZXZlbnQsZGF0YSxpbWcscmFuZ2UpXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICB9ICAgXHJcbn1cclxuXHJcblxyXG5cclxuZXhwb3J0IHtNTFZJbWFnZVRhYmxlLE1MVkltYWdlVGFibGVDb250cm9sc307Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUlBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFLQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBSEE7QUFRQTtBQUNBO0FBQ0E7QUFsQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQW9CQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBTUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVVBO0FBRUE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQU1BO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBakJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQWlCQTtBQUNBO0FBQUE7QUFBQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBTUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbEJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBS0E7QUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/image_table.js\n");

/***/ }),

/***/ "./src/indexes/index_ciview.js":
/*!*************************************!*\
  !*** ./src/indexes/index_ciview.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _ciview = __webpack_require__(/*! ../ciview.js */ \"./src/ciview.js\");\n\nvar _d = __webpack_require__(/*! ../vendor/d3.js */ \"./src/vendor/d3.js\");\n\nwindow.CIView = _ciview.CIView;\nwindow.d3 = _d.d3;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXhlcy9pbmRleF9jaXZpZXcuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2luZGV4ZXMvaW5kZXhfY2l2aWV3LmpzP2M2NjQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtDSVZpZXd9IGZyb20gXCIuLi9jaXZpZXcuanNcIjtcclxuaW1wb3J0IHtkM30gZnJvbSBcIi4uL3ZlbmRvci9kMy5qc1wiO1xyXG53aW5kb3cuQ0lWaWV3ID0gQ0lWaWV3O1xyXG53aW5kb3cuZDM9ZDM7Il0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/indexes/index_ciview.js\n");

/***/ }),

/***/ "./src/vendor/crossfilter.js":
/*!***********************************!*\
  !*** ./src/vendor/crossfilter.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nfunction crossfilter() {\n  var crossfilter = {\n    add: add,\n    remove: removeData,\n    dimension: dimension,\n    groupAll: groupAll,\n    size: size\n  };\n\n  var data = [],\n      // the records\n  n = 0,\n      // the number of records; data.length\n  m = 0,\n      // a bit mask representing which dimensions are in use\n  M = 8,\n      // number of dimensions that can fit in `filters`\n  filters = crossfilter_array8(0),\n      // M bits per record; 1 is filtered out\n  filterListeners = [],\n      // when the filters change\n  dataListeners = [],\n      // when data is added\n  removeDataListeners = []; // when data is removed\n\n  // Adds the specified new records to this crossfilter.\n  function add(newData) {\n    var n0 = n,\n        n1 = newData.length;\n\n    // If there's actually new data to add…\n    // Merge the new data into the existing data.\n    // Lengthen the filter bitset to handle the new records.\n    // Notify listeners (dimensions and groups) that new data is available.\n    if (n1) {\n      data = data.concat(newData);\n      filters = crossfilter_arrayLengthen(filters, n += n1);\n      dataListeners.forEach(function (l) {\n        l(newData, n0, n1);\n      });\n    }\n\n    return crossfilter;\n  }\n\n  // Removes all records that match the current filters.\n  function removeData() {\n    var newIndex = crossfilter_index(n, n),\n        removed = [];\n    for (var i = 0, j = 0; i < n; ++i) {\n      if (filters[i]) newIndex[i] = j++;else removed.push(i);\n    }\n\n    // Remove all matching records from groups.\n    filterListeners.forEach(function (l) {\n      l(0, [], removed);\n    });\n\n    // Update indexes.\n    removeDataListeners.forEach(function (l) {\n      l(newIndex);\n    });\n\n    // Remove old filters and data by overwriting.\n    for (var i = 0, j = 0, k; i < n; ++i) {\n      if (k = filters[i]) {\n        if (i !== j) filters[j] = k, data[j] = data[i];\n        ++j;\n      }\n    }\n    data.length = j;\n    while (n > j) {\n      filters[--n] = 0;\n    }\n  }\n\n  // Adds a new dimension with the specified value accessor function.\n  function dimension(value) {\n    var dimension = {\n      filter: filter,\n      filterExact: filterExact,\n      filterRange: filterRange,\n      filterFunction: filterFunction,\n      filterAll: filterAll,\n      top: top,\n      bottom: bottom,\n      group: group,\n      groupAll: groupAll,\n      dispose: dispose,\n      remove: dispose // for backwards-compatibility\n    };\n\n    var one = ~m & -~m,\n        // lowest unset bit as mask, e.g., 00001000\n    zero = ~one,\n        // inverted one, e.g., 11110111\n    values,\n        // sorted, cached array\n    index,\n        // value rank ↦ object id\n    newValues,\n        // temporary array storing newly-added values\n    newIndex,\n        // temporary array storing newly-added index\n    sort = quicksort_by(function (i) {\n      return newValues[i];\n    }),\n        refilter = crossfilter_filterAll,\n        // for recomputing filter\n    refilterFunction,\n        // the custom filter function in use\n    indexListeners = [],\n        // when data is added\n    dimensionGroups = [],\n        lo0 = 0,\n        hi0 = 0;\n\n    // Updating a dimension is a two-stage process. First, we must update the\n    // associated filters for the newly-added records. Once all dimensions have\n    // updated their filters, the groups are notified to update.\n    dataListeners.unshift(preAdd);\n    dataListeners.push(postAdd);\n\n    removeDataListeners.push(removeData);\n\n    // Incorporate any existing data into this dimension, and make sure that the\n    // filter bitset is wide enough to handle the new dimension.\n    m |= one;\n    if (M >= 32 ? !one : m & -(1 << M)) {\n      filters = crossfilter_arrayWiden(filters, M <<= 1);\n    }\n    preAdd(data, 0, n);\n    postAdd(data, 0, n);\n\n    // Incorporates the specified new records into this dimension.\n    // This function is responsible for updating filters, values, and index.\n    function preAdd(newData, n0, n1) {\n\n      // Permute new values into natural order using a sorted index.\n      newValues = newData.map(value);\n      newIndex = sort(crossfilter_range(n1), 0, n1);\n      newValues = permute(newValues, newIndex);\n\n      // Bisect newValues to determine which new records are selected.\n      var bounds = refilter(newValues),\n          lo1 = bounds[0],\n          hi1 = bounds[1],\n          i;\n      if (refilterFunction) {\n        for (i = 0; i < n1; ++i) {\n          if (!refilterFunction(newValues[i], i)) filters[newIndex[i] + n0] |= one;\n        }\n      } else {\n        for (i = 0; i < lo1; ++i) {\n          filters[newIndex[i] + n0] |= one;\n        }for (i = hi1; i < n1; ++i) {\n          filters[newIndex[i] + n0] |= one;\n        }\n      }\n\n      // If this dimension previously had no data, then we don't need to do the\n      // more expensive merge operation; use the new values and index as-is.\n      if (!n0) {\n        values = newValues;\n        index = newIndex;\n        lo0 = lo1;\n        hi0 = hi1;\n        return;\n      }\n\n      var oldValues = values,\n          oldIndex = index,\n          i0 = 0,\n          i1 = 0;\n\n      // Otherwise, create new arrays into which to merge new and old.\n      values = new Array(n);\n      index = crossfilter_index(n, n);\n\n      // Merge the old and new sorted values, and old and new index.\n      for (i = 0; i0 < n0 && i1 < n1; ++i) {\n        if (oldValues[i0] < newValues[i1]) {\n          values[i] = oldValues[i0];\n          index[i] = oldIndex[i0++];\n        } else {\n          values[i] = newValues[i1];\n          index[i] = newIndex[i1++] + n0;\n        }\n      }\n\n      // Add any remaining old values.\n      for (; i0 < n0; ++i0, ++i) {\n        values[i] = oldValues[i0];\n        index[i] = oldIndex[i0];\n      }\n\n      // Add any remaining new values.\n      for (; i1 < n1; ++i1, ++i) {\n        values[i] = newValues[i1];\n        index[i] = newIndex[i1] + n0;\n      }\n\n      // Bisect again to recompute lo0 and hi0.\n      bounds = refilter(values), lo0 = bounds[0], hi0 = bounds[1];\n    }\n\n    // When all filters have updated, notify index listeners of the new values.\n    function postAdd(newData, n0, n1) {\n      indexListeners.forEach(function (l) {\n        l(newValues, newIndex, n0, n1);\n      });\n      newValues = newIndex = null;\n    }\n\n    function removeData(reIndex) {\n      for (var i = 0, j = 0, k; i < n; ++i) {\n        if (filters[k = index[i]]) {\n          if (i !== j) values[j] = values[i];\n          index[j] = reIndex[k];\n          ++j;\n        }\n      }\n      values.length = j;\n      while (j < n) {\n        index[j++] = 0;\n      } // Bisect again to recompute lo0 and hi0.\n      var bounds = refilter(values);\n      lo0 = bounds[0], hi0 = bounds[1];\n    }\n\n    // Updates the selected values based on the specified bounds [lo, hi].\n    // This implementation is used by all the public filter methods.\n    function filterIndexBounds(bounds) {\n      var lo1 = bounds[0],\n          hi1 = bounds[1];\n\n      if (refilterFunction) {\n        refilterFunction = null;\n        filterIndexFunction(function (d, i) {\n          return lo1 <= i && i < hi1;\n        });\n        lo0 = lo1;\n        hi0 = hi1;\n        return dimension;\n      }\n\n      var i,\n          j,\n          k,\n          added = [],\n          removed = [];\n\n      // Fast incremental update based on previous lo index.\n      if (lo1 < lo0) {\n        for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n          filters[k = index[i]] ^= one;\n          added.push(k);\n        }\n      } else if (lo1 > lo0) {\n        for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n          filters[k = index[i]] ^= one;\n          removed.push(k);\n        }\n      }\n\n      // Fast incremental update based on previous hi index.\n      if (hi1 > hi0) {\n        for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n          filters[k = index[i]] ^= one;\n          added.push(k);\n        }\n      } else if (hi1 < hi0) {\n        for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n          filters[k = index[i]] ^= one;\n          removed.push(k);\n        }\n      }\n\n      lo0 = lo1;\n      hi0 = hi1;\n      filterListeners.forEach(function (l) {\n        l(one, added, removed);\n      });\n      return dimension;\n    }\n\n    // Filters this dimension using the specified range, value, or null.\n    // If the range is null, this is equivalent to filterAll.\n    // If the range is an array, this is equivalent to filterRange.\n    // Otherwise, this is equivalent to filterExact.\n    function filter(range) {\n      return range == null ? filterAll() : Array.isArray(range) ? filterRange(range) : typeof range === \"function\" ? filterFunction(range) : filterExact(range);\n    }\n\n    // Filters this dimension to select the exact value.\n    function filterExact(value) {\n      return filterIndexBounds((refilter = crossfilter_filterExact(bisect, value))(values));\n    }\n\n    // Filters this dimension to select the specified range [lo, hi].\n    // The lower bound is inclusive, and the upper bound is exclusive.\n    function filterRange(range) {\n      return filterIndexBounds((refilter = crossfilter_filterRange(bisect, range))(values));\n    }\n\n    // Clears any filters on this dimension.\n    function filterAll() {\n      return filterIndexBounds((refilter = crossfilter_filterAll)(values));\n    }\n\n    // Filters this dimension using an arbitrary function.\n    function filterFunction(f) {\n      refilter = crossfilter_filterAll;\n\n      filterIndexFunction(refilterFunction = f);\n\n      lo0 = 0;\n      hi0 = n;\n\n      return dimension;\n    }\n\n    function filterIndexFunction(f) {\n      var i,\n          k,\n          x,\n          added = [],\n          removed = [];\n\n      for (i = 0; i < n; ++i) {\n        if (!(filters[k = index[i]] & one) ^ !!(x = f(values[i], i))) {\n          if (x) filters[k] &= zero, added.push(k);else filters[k] |= one, removed.push(k);\n        }\n      }\n      filterListeners.forEach(function (l) {\n        l(one, added, removed);\n      });\n    }\n\n    // Returns the top K selected records based on this dimension's order.\n    // Note: observes this dimension's filter, unlike group and groupAll.\n    function top(k) {\n      var array = [],\n          i = hi0,\n          j;\n\n      while (--i >= lo0 && k > 0) {\n        if (!filters[j = index[i]]) {\n          array.push(data[j]);\n          --k;\n        }\n      }\n\n      return array;\n    }\n\n    // Returns the bottom K selected records based on this dimension's order.\n    // Note: observes this dimension's filter, unlike group and groupAll.\n    function bottom(k) {\n      var array = [],\n          i = lo0,\n          j;\n\n      while (i < hi0 && k > 0) {\n        if (!filters[j = index[i]]) {\n          array.push(data[j]);\n          --k;\n        }\n        i++;\n      }\n\n      return array;\n    }\n\n    // Adds a new group to this dimension, using the specified key function.\n    function group(key) {\n      var group = {\n        top: top,\n        all: all,\n        reduce: reduce,\n        reduceCount: reduceCount,\n        reduceSum: reduceSum,\n        order: order,\n        orderNatural: orderNatural,\n        size: size,\n        dispose: dispose,\n        remove: dispose // for backwards-compatibility\n      };\n\n      // Ensure that this group will be removed when the dimension is removed.\n      dimensionGroups.push(group);\n\n      var groups,\n          // array of {key, value}\n      groupIndex,\n          // object id ↦ group id\n      groupWidth = 8,\n          groupCapacity = crossfilter_capacity(groupWidth),\n          k = 0,\n          // cardinality\n      select,\n          heap,\n          reduceAdd,\n          reduceRemove,\n          reduceInitial,\n          update = crossfilter_null,\n          reset = crossfilter_null,\n          resetNeeded = true,\n          groupAll = key === crossfilter_null;\n\n      if (arguments.length < 1) key = crossfilter_identity;\n\n      // The group listens to the crossfilter for when any dimension changes, so\n      // that it can update the associated reduce values. It must also listen to\n      // the parent dimension for when data is added, and compute new keys.\n      filterListeners.push(update);\n      indexListeners.push(add);\n      removeDataListeners.push(removeData);\n\n      // Incorporate any existing data into the grouping.\n      add(values, index, 0, n);\n\n      // Incorporates the specified new values into this group.\n      // This function is responsible for updating groups and groupIndex.\n      function add(newValues, newIndex, n0, n1) {\n        var oldGroups = groups,\n            reIndex = crossfilter_index(k, groupCapacity),\n            add = reduceAdd,\n            initial = reduceInitial,\n            k0 = k,\n            // old cardinality\n        i0 = 0,\n            // index of old group\n        i1 = 0,\n            // index of new record\n        j,\n            // object id\n        g0,\n            // old group\n        x0,\n            // old key\n        x1,\n            // new key\n        g,\n            // group to add\n        x; // key of group to add\n\n        // If a reset is needed, we don't need to update the reduce values.\n        if (resetNeeded) add = initial = crossfilter_null;\n\n        // Reset the new groups (k is a lower bound).\n        // Also, make sure that groupIndex exists and is long enough.\n        groups = new Array(k), k = 0;\n        groupIndex = k0 > 1 ? crossfilter_arrayLengthen(groupIndex, n) : crossfilter_index(n, groupCapacity);\n\n        // Get the first old key (x0 of g0), if it exists.\n        if (k0) x0 = (g0 = oldGroups[0]).key;\n\n        // Find the first new key (x1), skipping NaN keys.\n        while (i1 < n1 && !((x1 = key(newValues[i1])) >= x1)) {\n          ++i1;\n        } // While new keys remain…\n        while (i1 < n1) {\n\n          // Determine the lesser of the two current keys; new and old.\n          // If there are no old keys remaining, then always add the new key.\n          if (g0 && x0 <= x1) {\n            g = g0, x = x0;\n\n            // Record the new index of the old group.\n            reIndex[i0] = k;\n\n            // Retrieve the next old key.\n            if (g0 = oldGroups[++i0]) x0 = g0.key;\n          } else {\n            g = { key: x1, value: initial() }, x = x1;\n          }\n\n          // Add the lesser group.\n          groups[k] = g;\n\n          // Add any selected records belonging to the added group, while\n          // advancing the new key and populating the associated group index.\n          while (!(x1 > x)) {\n            groupIndex[j = newIndex[i1] + n0] = k;\n            if (!(filters[j] & zero)) g.value = add(g.value, data[j]);\n            if (++i1 >= n1) break;\n            x1 = key(newValues[i1]);\n          }\n\n          groupIncrement();\n        }\n\n        // Add any remaining old groups that were greater than all new keys.\n        // No incremental reduce is needed; these groups have no new records.\n        // Also record the new index of the old group.\n        while (i0 < k0) {\n          groups[reIndex[i0] = k] = oldGroups[i0++];\n          groupIncrement();\n        }\n\n        // If we added any new groups before any old groups,\n        // update the group index of all the old records.\n        if (k > i0) for (i0 = 0; i0 < n0; ++i0) {\n          groupIndex[i0] = reIndex[groupIndex[i0]];\n        }\n\n        // Modify the update and reset behavior based on the cardinality.\n        // If the cardinality is less than or equal to one, then the groupIndex\n        // is not needed. If the cardinality is zero, then there are no records\n        // and therefore no groups to update or reset. Note that we also must\n        // change the registered listener to point to the new method.\n        j = filterListeners.indexOf(update);\n        if (k > 1) {\n          update = updateMany;\n          reset = resetMany;\n        } else {\n          if (!k && groupAll) {\n            k = 1;\n            groups = [{ key: null, value: initial() }];\n          }\n          if (k === 1) {\n            update = updateOne;\n            reset = resetOne;\n          } else {\n            update = crossfilter_null;\n            reset = crossfilter_null;\n          }\n          groupIndex = null;\n        }\n        filterListeners[j] = update;\n\n        // Count the number of added groups,\n        // and widen the group index as needed.\n        function groupIncrement() {\n          if (++k === groupCapacity) {\n            reIndex = crossfilter_arrayWiden(reIndex, groupWidth <<= 1);\n            groupIndex = crossfilter_arrayWiden(groupIndex, groupWidth);\n            groupCapacity = crossfilter_capacity(groupWidth);\n          }\n        }\n      }\n\n      function removeData() {\n        if (k > 1) {\n          var oldK = k,\n              oldGroups = groups,\n              seenGroups = crossfilter_index(oldK, oldK);\n\n          // Filter out non-matches by copying matching group index entries to\n          // the beginning of the array.\n          for (var i = 0, j = 0; i < n; ++i) {\n            if (filters[i]) {\n              seenGroups[groupIndex[j] = groupIndex[i]] = 1;\n              ++j;\n            }\n          }\n\n          // Reassemble groups including only those groups that were referred\n          // to by matching group index entries.  Note the new group index in\n          // seenGroups.\n          groups = [], k = 0;\n          for (i = 0; i < oldK; ++i) {\n            if (seenGroups[i]) {\n              seenGroups[i] = k++;\n              groups.push(oldGroups[i]);\n            }\n          }\n\n          if (k > 1) {\n            // Reindex the group index using seenGroups to find the new index.\n            for (var i = 0; i < j; ++i) {\n              groupIndex[i] = seenGroups[groupIndex[i]];\n            }\n          } else {\n            groupIndex = null;\n          }\n          filterListeners[filterListeners.indexOf(update)] = k > 1 ? (reset = resetMany, update = updateMany) : k === 1 ? (reset = resetOne, update = updateOne) : reset = update = crossfilter_null;\n        } else if (k === 1) {\n          if (groupAll) return;\n          for (var i = 0; i < n; ++i) {\n            if (filters[i]) return;\n          }groups = [], k = 0;\n          filterListeners[filterListeners.indexOf(update)] = update = reset = crossfilter_null;\n        }\n      }\n\n      // Reduces the specified selected or deselected records.\n      // This function is only used when the cardinality is greater than 1.\n      function updateMany(filterOne, added, removed) {\n        if (filterOne === one || resetNeeded) return;\n\n        var i, k, n, g;\n\n        // Add the added values.\n        for (i = 0, n = added.length; i < n; ++i) {\n          if (!(filters[k = added[i]] & zero)) {\n            g = groups[groupIndex[k]];\n            g.value = reduceAdd(g.value, data[k]);\n          }\n        }\n\n        // Remove the removed values.\n        for (i = 0, n = removed.length; i < n; ++i) {\n          if ((filters[k = removed[i]] & zero) === filterOne) {\n            g = groups[groupIndex[k]];\n            g.value = reduceRemove(g.value, data[k]);\n          }\n        }\n      }\n\n      // Reduces the specified selected or deselected records.\n      // This function is only used when the cardinality is 1.\n      function updateOne(filterOne, added, removed) {\n        if (filterOne === one || resetNeeded) return;\n\n        var i,\n            k,\n            n,\n            g = groups[0];\n\n        // Add the added values.\n        for (i = 0, n = added.length; i < n; ++i) {\n          if (!(filters[k = added[i]] & zero)) {\n            g.value = reduceAdd(g.value, data[k]);\n          }\n        }\n\n        // Remove the removed values.\n        for (i = 0, n = removed.length; i < n; ++i) {\n          if ((filters[k = removed[i]] & zero) === filterOne) {\n            g.value = reduceRemove(g.value, data[k]);\n          }\n        }\n      }\n\n      // Recomputes the group reduce values from scratch.\n      // This function is only used when the cardinality is greater than 1.\n      function resetMany() {\n        var i, g;\n\n        // Reset all group values.\n        for (i = 0; i < k; ++i) {\n          groups[i].value = reduceInitial();\n        }\n\n        // Add any selected records.\n        for (i = 0; i < n; ++i) {\n          if (!(filters[i] & zero)) {\n            g = groups[groupIndex[i]];\n            g.value = reduceAdd(g.value, data[i]);\n          }\n        }\n      }\n\n      // Recomputes the group reduce values from scratch.\n      // This function is only used when the cardinality is 1.\n      function resetOne() {\n        var i,\n            g = groups[0];\n\n        // Reset the singleton group values.\n        g.value = reduceInitial();\n\n        // Add any selected records.\n        for (i = 0; i < n; ++i) {\n          if (!(filters[i] & zero)) {\n            g.value = reduceAdd(g.value, data[i]);\n          }\n        }\n      }\n\n      // Returns the array of group values, in the dimension's natural order.\n      function all() {\n        if (resetNeeded) reset(), resetNeeded = false;\n        return groups;\n      }\n\n      // Returns a new array containing the top K group values, in reduce order.\n      function top(k) {\n        var top = select(all(), 0, groups.length, k);\n        return heap.sort(top, 0, top.length);\n      }\n\n      // Sets the reduce behavior for this group to use the specified functions.\n      // This method lazily recomputes the reduce values, waiting until needed.\n      function reduce(add, remove, initial) {\n        reduceAdd = add;\n        reduceRemove = remove;\n        reduceInitial = initial;\n        resetNeeded = true;\n        return group;\n      }\n\n      // A convenience method for reducing by count.\n      function reduceCount() {\n        return reduce(crossfilter_reduceIncrement, crossfilter_reduceDecrement, crossfilter_zero);\n      }\n\n      // A convenience method for reducing by sum(value).\n      function reduceSum(value) {\n        return reduce(crossfilter_reduceAdd(value), crossfilter_reduceSubtract(value), crossfilter_zero);\n      }\n\n      // Sets the reduce order, using the specified accessor.\n      function order(value) {\n        select = heapselect_by(valueOf);\n        heap = heap_by(valueOf);\n        function valueOf(d) {\n          return value(d.value);\n        }\n        return group;\n      }\n\n      // A convenience method for natural ordering by reduce value.\n      function orderNatural() {\n        return order(crossfilter_identity);\n      }\n\n      // Returns the cardinality of this group, irrespective of any filters.\n      function size() {\n        return k;\n      }\n\n      // Removes this group and associated event listeners.\n      function dispose() {\n        var i = filterListeners.indexOf(update);\n        if (i >= 0) filterListeners.splice(i, 1);\n        i = indexListeners.indexOf(add);\n        if (i >= 0) indexListeners.splice(i, 1);\n        i = removeDataListeners.indexOf(removeData);\n        if (i >= 0) removeDataListeners.splice(i, 1);\n        return group;\n      }\n\n      return reduceCount().orderNatural();\n    }\n\n    // A convenience function for generating a singleton group.\n    function groupAll() {\n      var g = group(crossfilter_null),\n          all = g.all;\n      delete g.all;\n      delete g.top;\n      delete g.order;\n      delete g.orderNatural;\n      delete g.size;\n      g.value = function () {\n        return all()[0].value;\n      };\n      return g;\n    }\n\n    // Removes this dimension and associated groups and event listeners.\n    function dispose() {\n      dimensionGroups.forEach(function (group) {\n        group.dispose();\n      });\n      var i = dataListeners.indexOf(preAdd);\n      if (i >= 0) dataListeners.splice(i, 1);\n      i = dataListeners.indexOf(postAdd);\n      if (i >= 0) dataListeners.splice(i, 1);\n      i = removeDataListeners.indexOf(removeData);\n      if (i >= 0) removeDataListeners.splice(i, 1);\n      m &= zero;\n      return filterAll();\n    }\n\n    return dimension;\n  }\n\n  // A convenience method for groupAll on a dummy dimension.\n  // This implementation can be optimized since it always has cardinality 1.\n  function groupAll() {\n    var group = {\n      reduce: reduce,\n      reduceCount: reduceCount,\n      reduceSum: reduceSum,\n      value: value,\n      dispose: dispose,\n      remove: dispose // for backwards-compatibility\n    };\n\n    var reduceValue,\n        reduceAdd,\n        reduceRemove,\n        reduceInitial,\n        resetNeeded = true;\n\n    // The group listens to the crossfilter for when any dimension changes, so\n    // that it can update the reduce value. It must also listen to the parent\n    // dimension for when data is added.\n    filterListeners.push(update);\n    dataListeners.push(add);\n\n    // For consistency; actually a no-op since resetNeeded is true.\n    add(data, 0, n);\n\n    // Incorporates the specified new values into this group.\n    function add(newData, n0) {\n      var i;\n\n      if (resetNeeded) return;\n\n      // Add the added values.\n      for (i = n0; i < n; ++i) {\n        if (!filters[i]) {\n          reduceValue = reduceAdd(reduceValue, data[i]);\n        }\n      }\n    }\n\n    // Reduces the specified selected or deselected records.\n    function update(filterOne, added, removed) {\n      var i, k, n;\n\n      if (resetNeeded) return;\n\n      // Add the added values.\n      for (i = 0, n = added.length; i < n; ++i) {\n        if (!filters[k = added[i]]) {\n          reduceValue = reduceAdd(reduceValue, data[k]);\n        }\n      }\n\n      // Remove the removed values.\n      for (i = 0, n = removed.length; i < n; ++i) {\n        if (filters[k = removed[i]] === filterOne) {\n          reduceValue = reduceRemove(reduceValue, data[k]);\n        }\n      }\n    }\n\n    // Recomputes the group reduce value from scratch.\n    function reset() {\n      var i;\n\n      reduceValue = reduceInitial();\n\n      for (i = 0; i < n; ++i) {\n        if (!filters[i]) {\n          reduceValue = reduceAdd(reduceValue, data[i]);\n        }\n      }\n    }\n\n    // Sets the reduce behavior for this group to use the specified functions.\n    // This method lazily recomputes the reduce value, waiting until needed.\n    function reduce(add, remove, initial) {\n      reduceAdd = add;\n      reduceRemove = remove;\n      reduceInitial = initial;\n      resetNeeded = true;\n      return group;\n    }\n\n    // A convenience method for reducing by count.\n    function reduceCount() {\n      return reduce(crossfilter_reduceIncrement, crossfilter_reduceDecrement, crossfilter_zero);\n    }\n\n    // A convenience method for reducing by sum(value).\n    function reduceSum(value) {\n      return reduce(crossfilter_reduceAdd(value), crossfilter_reduceSubtract(value), crossfilter_zero);\n    }\n\n    // Returns the computed reduce value.\n    function value() {\n      if (resetNeeded) reset(), resetNeeded = false;\n      return reduceValue;\n    }\n\n    // Removes this group and associated event listeners.\n    function dispose() {\n      var i = filterListeners.indexOf(update);\n      if (i >= 0) filterListeners.splice(i);\n      i = dataListeners.indexOf(add);\n      if (i >= 0) dataListeners.splice(i);\n      return group;\n    }\n\n    return reduceCount();\n  }\n\n  // Returns the number of records in this crossfilter, irrespective of any filters.\n  function size() {\n    return n;\n  }\n\n  return arguments.length ? add(arguments[0]) : crossfilter;\n}\n\ncrossfilter.version = \"1.3.12\";\nfunction crossfilter_identity(d) {\n  return d;\n}\ncrossfilter.permute = permute;\n\nfunction permute(array, index) {\n  for (var i = 0, n = index.length, copy = new Array(n); i < n; ++i) {\n    copy[i] = array[index[i]];\n  }\n  return copy;\n}\nvar bisect = crossfilter.bisect = bisect_by(crossfilter_identity);\n\nbisect.by = bisect_by;\n\nfunction bisect_by(f) {\n\n  // Locate the insertion point for x in a to maintain sorted order. The\n  // arguments lo and hi may be used to specify a subset of the array which\n  // should be considered; by default the entire array is used. If x is already\n  // present in a, the insertion point will be before (to the left of) any\n  // existing entries. The return value is suitable for use as the first\n  // argument to `array.splice` assuming that a is already sorted.\n  //\n  // The returned insertion point i partitions the array a into two halves so\n  // that all v < x for v in a[lo:i] for the left side and all v >= x for v in\n  // a[i:hi] for the right side.\n  function bisectLeft(a, x, lo, hi) {\n    while (lo < hi) {\n      var mid = lo + hi >>> 1;\n      if (f(a[mid]) < x) lo = mid + 1;else hi = mid;\n    }\n    return lo;\n  }\n\n  // Similar to bisectLeft, but returns an insertion point which comes after (to\n  // the right of) any existing entries of x in a.\n  //\n  // The returned insertion point i partitions the array into two halves so that\n  // all v <= x for v in a[lo:i] for the left side and all v > x for v in\n  // a[i:hi] for the right side.\n  function bisectRight(a, x, lo, hi) {\n    while (lo < hi) {\n      var mid = lo + hi >>> 1;\n      if (x < f(a[mid])) hi = mid;else lo = mid + 1;\n    }\n    return lo;\n  }\n\n  bisectRight.right = bisectRight;\n  bisectRight.left = bisectLeft;\n  return bisectRight;\n}\nvar heap = crossfilter.heap = heap_by(crossfilter_identity);\n\nheap.by = heap_by;\n\nfunction heap_by(f) {\n\n  // Builds a binary heap within the specified array a[lo:hi]. The heap has the\n  // property such that the parent a[lo+i] is always less than or equal to its\n  // two children: a[lo+2*i+1] and a[lo+2*i+2].\n  function heap(a, lo, hi) {\n    var n = hi - lo,\n        i = (n >>> 1) + 1;\n    while (--i > 0) {\n      sift(a, i, n, lo);\n    }return a;\n  }\n\n  // Sorts the specified array a[lo:hi] in descending order, assuming it is\n  // already a heap.\n  function sort(a, lo, hi) {\n    var n = hi - lo,\n        t;\n    while (--n > 0) {\n      t = a[lo], a[lo] = a[lo + n], a[lo + n] = t, sift(a, 1, n, lo);\n    }return a;\n  }\n\n  // Sifts the element a[lo+i-1] down the heap, where the heap is the contiguous\n  // slice of array a[lo:lo+n]. This method can also be used to update the heap\n  // incrementally, without incurring the full cost of reconstructing the heap.\n  function sift(a, i, n, lo) {\n    var d = a[--lo + i],\n        x = f(d),\n        child;\n    while ((child = i << 1) <= n) {\n      if (child < n && f(a[lo + child]) > f(a[lo + child + 1])) child++;\n      if (x <= f(a[lo + child])) break;\n      a[lo + i] = a[lo + child];\n      i = child;\n    }\n    a[lo + i] = d;\n  }\n\n  heap.sort = sort;\n  return heap;\n}\nvar heapselect = crossfilter.heapselect = heapselect_by(crossfilter_identity);\n\nheapselect.by = heapselect_by;\n\nfunction heapselect_by(f) {\n  var heap = heap_by(f);\n\n  // Returns a new array containing the top k elements in the array a[lo:hi].\n  // The returned array is not sorted, but maintains the heap property. If k is\n  // greater than hi - lo, then fewer than k elements will be returned. The\n  // order of elements in a is unchanged by this operation.\n  function heapselect(a, lo, hi, k) {\n    var queue = new Array(k = Math.min(hi - lo, k)),\n        min,\n        i,\n        x,\n        d;\n\n    for (i = 0; i < k; ++i) {\n      queue[i] = a[lo++];\n    }heap(queue, 0, k);\n\n    if (lo < hi) {\n      min = f(queue[0]);\n      do {\n        if (x = f(d = a[lo]) > min) {\n          queue[0] = d;\n          min = f(heap(queue, 0, k)[0]);\n        }\n      } while (++lo < hi);\n    }\n\n    return queue;\n  }\n\n  return heapselect;\n}\nvar insertionsort = crossfilter.insertionsort = insertionsort_by(crossfilter_identity);\n\ninsertionsort.by = insertionsort_by;\n\nfunction insertionsort_by(f) {\n\n  function insertionsort(a, lo, hi) {\n    for (var i = lo + 1; i < hi; ++i) {\n      for (var j = i, t = a[i], x = f(t); j > lo && f(a[j - 1]) > x; --j) {\n        a[j] = a[j - 1];\n      }\n      a[j] = t;\n    }\n    return a;\n  }\n\n  return insertionsort;\n}\n// Algorithm designed by Vladimir Yaroslavskiy.\n// Implementation based on the Dart project; see lib/dart/LICENSE for details.\n\nvar quicksort = crossfilter.quicksort = quicksort_by(crossfilter_identity);\n\nquicksort.by = quicksort_by;\n\nfunction quicksort_by(f) {\n  var insertionsort = insertionsort_by(f);\n\n  function sort(a, lo, hi) {\n    return (hi - lo < quicksort_sizeThreshold ? insertionsort : quicksort)(a, lo, hi);\n  }\n\n  function quicksort(a, lo, hi) {\n    // Compute the two pivots by looking at 5 elements.\n    var sixth = (hi - lo) / 6 | 0,\n        i1 = lo + sixth,\n        i5 = hi - 1 - sixth,\n        i3 = lo + hi - 1 >> 1,\n        // The midpoint.\n    i2 = i3 - sixth,\n        i4 = i3 + sixth;\n\n    var e1 = a[i1],\n        x1 = f(e1),\n        e2 = a[i2],\n        x2 = f(e2),\n        e3 = a[i3],\n        x3 = f(e3),\n        e4 = a[i4],\n        x4 = f(e4),\n        e5 = a[i5],\n        x5 = f(e5);\n\n    var t;\n\n    // Sort the selected 5 elements using a sorting network.\n    if (x1 > x2) t = e1, e1 = e2, e2 = t, t = x1, x1 = x2, x2 = t;\n    if (x4 > x5) t = e4, e4 = e5, e5 = t, t = x4, x4 = x5, x5 = t;\n    if (x1 > x3) t = e1, e1 = e3, e3 = t, t = x1, x1 = x3, x3 = t;\n    if (x2 > x3) t = e2, e2 = e3, e3 = t, t = x2, x2 = x3, x3 = t;\n    if (x1 > x4) t = e1, e1 = e4, e4 = t, t = x1, x1 = x4, x4 = t;\n    if (x3 > x4) t = e3, e3 = e4, e4 = t, t = x3, x3 = x4, x4 = t;\n    if (x2 > x5) t = e2, e2 = e5, e5 = t, t = x2, x2 = x5, x5 = t;\n    if (x2 > x3) t = e2, e2 = e3, e3 = t, t = x2, x2 = x3, x3 = t;\n    if (x4 > x5) t = e4, e4 = e5, e5 = t, t = x4, x4 = x5, x5 = t;\n\n    var pivot1 = e2,\n        pivotValue1 = x2,\n        pivot2 = e4,\n        pivotValue2 = x4;\n\n    // e2 and e4 have been saved in the pivot variables. They will be written\n    // back, once the partitioning is finished.\n    a[i1] = e1;\n    a[i2] = a[lo];\n    a[i3] = e3;\n    a[i4] = a[hi - 1];\n    a[i5] = e5;\n\n    var less = lo + 1,\n        // First element in the middle partition.\n    great = hi - 2; // Last element in the middle partition.\n\n    // Note that for value comparison, <, <=, >= and > coerce to a primitive via\n    // Object.prototype.valueOf; == and === do not, so in order to be consistent\n    // with natural order (such as for Date objects), we must do two compares.\n    var pivotsEqual = pivotValue1 <= pivotValue2 && pivotValue1 >= pivotValue2;\n    if (pivotsEqual) {\n\n      // Degenerated case where the partitioning becomes a dutch national flag\n      // problem.\n      //\n      // [ |  < pivot  | == pivot | unpartitioned | > pivot  | ]\n      //  ^             ^          ^             ^            ^\n      // left         less         k           great         right\n      //\n      // a[left] and a[right] are undefined and are filled after the\n      // partitioning.\n      //\n      // Invariants:\n      //   1) for x in ]left, less[ : x < pivot.\n      //   2) for x in [less, k[ : x == pivot.\n      //   3) for x in ]great, right[ : x > pivot.\n      for (var k = less; k <= great; ++k) {\n        var ek = a[k],\n            xk = f(ek);\n        if (xk < pivotValue1) {\n          if (k !== less) {\n            a[k] = a[less];\n            a[less] = ek;\n          }\n          ++less;\n        } else if (xk > pivotValue1) {\n\n          // Find the first element <= pivot in the range [k - 1, great] and\n          // put [:ek:] there. We know that such an element must exist:\n          // When k == less, then el3 (which is equal to pivot) lies in the\n          // interval. Otherwise a[k - 1] == pivot and the search stops at k-1.\n          // Note that in the latter case invariant 2 will be violated for a\n          // short amount of time. The invariant will be restored when the\n          // pivots are put into their final positions.\n          while (true) {\n            var greatValue = f(a[great]);\n            if (greatValue > pivotValue1) {\n              great--;\n              // This is the only location in the while-loop where a new\n              // iteration is started.\n              continue;\n            } else if (greatValue < pivotValue1) {\n              // Triple exchange.\n              a[k] = a[less];\n              a[less++] = a[great];\n              a[great--] = ek;\n              break;\n            } else {\n              a[k] = a[great];\n              a[great--] = ek;\n              // Note: if great < k then we will exit the outer loop and fix\n              // invariant 2 (which we just violated).\n              break;\n            }\n          }\n        }\n      }\n    } else {\n\n      // We partition the list into three parts:\n      //  1. < pivot1\n      //  2. >= pivot1 && <= pivot2\n      //  3. > pivot2\n      //\n      // During the loop we have:\n      // [ | < pivot1 | >= pivot1 && <= pivot2 | unpartitioned  | > pivot2  | ]\n      //  ^            ^                        ^              ^             ^\n      // left         less                     k              great        right\n      //\n      // a[left] and a[right] are undefined and are filled after the\n      // partitioning.\n      //\n      // Invariants:\n      //   1. for x in ]left, less[ : x < pivot1\n      //   2. for x in [less, k[ : pivot1 <= x && x <= pivot2\n      //   3. for x in ]great, right[ : x > pivot2\n      for (var k = less; k <= great; k++) {\n        var ek = a[k],\n            xk = f(ek);\n        if (xk < pivotValue1) {\n          if (k !== less) {\n            a[k] = a[less];\n            a[less] = ek;\n          }\n          ++less;\n        } else {\n          if (xk > pivotValue2) {\n            while (true) {\n              var greatValue = f(a[great]);\n              if (greatValue > pivotValue2) {\n                great--;\n                if (great < k) break;\n                // This is the only location inside the loop where a new\n                // iteration is started.\n                continue;\n              } else {\n                // a[great] <= pivot2.\n                if (greatValue < pivotValue1) {\n                  // Triple exchange.\n                  a[k] = a[less];\n                  a[less++] = a[great];\n                  a[great--] = ek;\n                } else {\n                  // a[great] >= pivot1.\n                  a[k] = a[great];\n                  a[great--] = ek;\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Move pivots into their final positions.\n    // We shrunk the list from both sides (a[left] and a[right] have\n    // meaningless values in them) and now we move elements from the first\n    // and third partition into these locations so that we can store the\n    // pivots.\n    a[lo] = a[less - 1];\n    a[less - 1] = pivot1;\n    a[hi - 1] = a[great + 1];\n    a[great + 1] = pivot2;\n\n    // The list is now partitioned into three partitions:\n    // [ < pivot1   | >= pivot1 && <= pivot2   |  > pivot2   ]\n    //  ^            ^                        ^             ^\n    // left         less                     great        right\n\n    // Recursive descent. (Don't include the pivot values.)\n    sort(a, lo, less - 1);\n    sort(a, great + 2, hi);\n\n    if (pivotsEqual) {\n      // All elements in the second partition are equal to the pivot. No\n      // need to sort them.\n      return a;\n    }\n\n    // In theory it should be enough to call _doSort recursively on the second\n    // partition.\n    // The Android source however removes the pivot elements from the recursive\n    // call if the second partition is too large (more than 2/3 of the list).\n    if (less < i1 && great > i5) {\n      var lessValue, greatValue;\n      while ((lessValue = f(a[less])) <= pivotValue1 && lessValue >= pivotValue1) {\n        ++less;\n      }while ((greatValue = f(a[great])) <= pivotValue2 && greatValue >= pivotValue2) {\n        --great;\n      } // Copy paste of the previous 3-way partitioning with adaptions.\n      //\n      // We partition the list into three parts:\n      //  1. == pivot1\n      //  2. > pivot1 && < pivot2\n      //  3. == pivot2\n      //\n      // During the loop we have:\n      // [ == pivot1 | > pivot1 && < pivot2 | unpartitioned  | == pivot2 ]\n      //              ^                      ^              ^\n      //            less                     k              great\n      //\n      // Invariants:\n      //   1. for x in [ *, less[ : x == pivot1\n      //   2. for x in [less, k[ : pivot1 < x && x < pivot2\n      //   3. for x in ]great, * ] : x == pivot2\n      for (var k = less; k <= great; k++) {\n        var ek = a[k],\n            xk = f(ek);\n        if (xk <= pivotValue1 && xk >= pivotValue1) {\n          if (k !== less) {\n            a[k] = a[less];\n            a[less] = ek;\n          }\n          less++;\n        } else {\n          if (xk <= pivotValue2 && xk >= pivotValue2) {\n            while (true) {\n              var greatValue = f(a[great]);\n              if (greatValue <= pivotValue2 && greatValue >= pivotValue2) {\n                great--;\n                if (great < k) break;\n                // This is the only location inside the loop where a new\n                // iteration is started.\n                continue;\n              } else {\n                // a[great] < pivot2.\n                if (greatValue < pivotValue1) {\n                  // Triple exchange.\n                  a[k] = a[less];\n                  a[less++] = a[great];\n                  a[great--] = ek;\n                } else {\n                  // a[great] == pivot1.\n                  a[k] = a[great];\n                  a[great--] = ek;\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // The second partition has now been cleared of pivot elements and looks\n    // as follows:\n    // [  *  |  > pivot1 && < pivot2  | * ]\n    //        ^                      ^\n    //       less                  great\n    // Sort the second partition using recursive descent.\n\n    // The second partition looks as follows:\n    // [  *  |  >= pivot1 && <= pivot2  | * ]\n    //        ^                        ^\n    //       less                    great\n    // Simply sort it by recursive descent.\n\n    return sort(a, less, great + 1);\n  }\n\n  return sort;\n}\n\nvar quicksort_sizeThreshold = 32;\nvar crossfilter_array8 = crossfilter_arrayUntyped,\n    crossfilter_array16 = crossfilter_arrayUntyped,\n    crossfilter_array32 = crossfilter_arrayUntyped,\n    crossfilter_arrayLengthen = crossfilter_arrayLengthenUntyped,\n    crossfilter_arrayWiden = crossfilter_arrayWidenUntyped;\n\nif (typeof Uint8Array !== \"undefined\") {\n  crossfilter_array8 = function crossfilter_array8(n) {\n    return new Uint8Array(n);\n  };\n  crossfilter_array16 = function crossfilter_array16(n) {\n    return new Uint16Array(n);\n  };\n  crossfilter_array32 = function crossfilter_array32(n) {\n    return new Uint32Array(n);\n  };\n\n  crossfilter_arrayLengthen = function crossfilter_arrayLengthen(array, length) {\n    if (array.length >= length) return array;\n    var copy = new array.constructor(length);\n    copy.set(array);\n    return copy;\n  };\n\n  crossfilter_arrayWiden = function crossfilter_arrayWiden(array, width) {\n    var copy;\n    switch (width) {\n      case 16:\n        copy = crossfilter_array16(array.length);break;\n      case 32:\n        copy = crossfilter_array32(array.length);break;\n      default:\n        throw new Error(\"invalid array width!\");\n    }\n    copy.set(array);\n    return copy;\n  };\n}\n\nfunction crossfilter_arrayUntyped(n) {\n  var array = new Array(n),\n      i = -1;\n  while (++i < n) {\n    array[i] = 0;\n  }return array;\n}\n\nfunction crossfilter_arrayLengthenUntyped(array, length) {\n  var n = array.length;\n  while (n < length) {\n    array[n++] = 0;\n  }return array;\n}\n\nfunction crossfilter_arrayWidenUntyped(array, width) {\n  if (width > 32) throw new Error(\"invalid array width!\");\n  return array;\n}\nfunction crossfilter_filterExact(bisect, value) {\n  return function (values) {\n    var n = values.length;\n    return [bisect.left(values, value, 0, n), bisect.right(values, value, 0, n)];\n  };\n}\n\nfunction crossfilter_filterRange(bisect, range) {\n  var min = range[0],\n      max = range[1];\n  return function (values) {\n    var n = values.length;\n    return [bisect.left(values, min, 0, n), bisect.left(values, max, 0, n)];\n  };\n}\n\nfunction crossfilter_filterAll(values) {\n  return [0, values.length];\n}\nfunction crossfilter_null() {\n  return null;\n}\nfunction crossfilter_zero() {\n  return 0;\n}\nfunction crossfilter_reduceIncrement(p) {\n  return p + 1;\n}\n\nfunction crossfilter_reduceDecrement(p) {\n  return p - 1;\n}\n\nfunction crossfilter_reduceAdd(f) {\n  return function (p, v) {\n    return p + +f(v);\n  };\n}\n\nfunction crossfilter_reduceSubtract(f) {\n  return function (p, v) {\n    return p - f(v);\n  };\n}\n\n// Returns an array of size n, big enough to store ids up to m.\nfunction crossfilter_index(n, m) {\n  return (m < 0x101 ? crossfilter_array8 : m < 0x10001 ? crossfilter_array16 : crossfilter_array32)(n);\n}\n\n// Constructs a new array of size n, with sequential values from 0 to n - 1.\nfunction crossfilter_range(n) {\n  var range = crossfilter_index(n, n);\n  for (var i = -1; ++i < n;) {\n    range[i] = i;\n  }return range;\n}\n\nfunction crossfilter_capacity(w) {\n  return w === 8 ? 0x100 : w === 16 ? 0x10000 : 0x100000000;\n}\nexports.crossfilter = crossfilter;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdmVuZG9yL2Nyb3NzZmlsdGVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3NyYy92ZW5kb3IvY3Jvc3NmaWx0ZXIuanM/OGM1ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBjcm9zc2ZpbHRlcigpIHtcclxuICB2YXIgY3Jvc3NmaWx0ZXIgPSB7XHJcbiAgICBhZGQ6IGFkZCxcclxuICAgIHJlbW92ZTogcmVtb3ZlRGF0YSxcclxuICAgIGRpbWVuc2lvbjogZGltZW5zaW9uLFxyXG4gICAgZ3JvdXBBbGw6IGdyb3VwQWxsLFxyXG4gICAgc2l6ZTogc2l6ZVxyXG4gIH07XHJcblxyXG4gIHZhciBkYXRhID0gW10sIC8vIHRoZSByZWNvcmRzXHJcbiAgICAgIG4gPSAwLCAvLyB0aGUgbnVtYmVyIG9mIHJlY29yZHM7IGRhdGEubGVuZ3RoXHJcbiAgICAgIG0gPSAwLCAvLyBhIGJpdCBtYXNrIHJlcHJlc2VudGluZyB3aGljaCBkaW1lbnNpb25zIGFyZSBpbiB1c2VcclxuICAgICAgTSA9IDgsIC8vIG51bWJlciBvZiBkaW1lbnNpb25zIHRoYXQgY2FuIGZpdCBpbiBgZmlsdGVyc2BcclxuICAgICAgZmlsdGVycyA9IGNyb3NzZmlsdGVyX2FycmF5OCgwKSwgLy8gTSBiaXRzIHBlciByZWNvcmQ7IDEgaXMgZmlsdGVyZWQgb3V0XHJcbiAgICAgIGZpbHRlckxpc3RlbmVycyA9IFtdLCAvLyB3aGVuIHRoZSBmaWx0ZXJzIGNoYW5nZVxyXG4gICAgICBkYXRhTGlzdGVuZXJzID0gW10sIC8vIHdoZW4gZGF0YSBpcyBhZGRlZFxyXG4gICAgICByZW1vdmVEYXRhTGlzdGVuZXJzID0gW107IC8vIHdoZW4gZGF0YSBpcyByZW1vdmVkXHJcblxyXG4gIC8vIEFkZHMgdGhlIHNwZWNpZmllZCBuZXcgcmVjb3JkcyB0byB0aGlzIGNyb3NzZmlsdGVyLlxyXG4gIGZ1bmN0aW9uIGFkZChuZXdEYXRhKSB7XHJcbiAgICB2YXIgbjAgPSBuLFxyXG4gICAgICAgIG4xID0gbmV3RGF0YS5sZW5ndGg7XHJcblxyXG4gICAgLy8gSWYgdGhlcmUncyBhY3R1YWxseSBuZXcgZGF0YSB0byBhZGTigKZcclxuICAgIC8vIE1lcmdlIHRoZSBuZXcgZGF0YSBpbnRvIHRoZSBleGlzdGluZyBkYXRhLlxyXG4gICAgLy8gTGVuZ3RoZW4gdGhlIGZpbHRlciBiaXRzZXQgdG8gaGFuZGxlIHRoZSBuZXcgcmVjb3Jkcy5cclxuICAgIC8vIE5vdGlmeSBsaXN0ZW5lcnMgKGRpbWVuc2lvbnMgYW5kIGdyb3VwcykgdGhhdCBuZXcgZGF0YSBpcyBhdmFpbGFibGUuXHJcbiAgICBpZiAobjEpIHtcclxuICAgICAgZGF0YSA9IGRhdGEuY29uY2F0KG5ld0RhdGEpO1xyXG4gICAgICBmaWx0ZXJzID0gY3Jvc3NmaWx0ZXJfYXJyYXlMZW5ndGhlbihmaWx0ZXJzLCBuICs9IG4xKTtcclxuICAgICAgZGF0YUxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uKGwpIHsgbChuZXdEYXRhLCBuMCwgbjEpOyB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY3Jvc3NmaWx0ZXI7XHJcbiAgfVxyXG5cclxuICAvLyBSZW1vdmVzIGFsbCByZWNvcmRzIHRoYXQgbWF0Y2ggdGhlIGN1cnJlbnQgZmlsdGVycy5cclxuICBmdW5jdGlvbiByZW1vdmVEYXRhKCkge1xyXG4gICAgdmFyIG5ld0luZGV4ID0gY3Jvc3NmaWx0ZXJfaW5kZXgobiwgbiksXHJcbiAgICAgICAgcmVtb3ZlZCA9IFtdO1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSAwOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgIGlmIChmaWx0ZXJzW2ldKSBuZXdJbmRleFtpXSA9IGorKztcclxuICAgICAgZWxzZSByZW1vdmVkLnB1c2goaSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVtb3ZlIGFsbCBtYXRjaGluZyByZWNvcmRzIGZyb20gZ3JvdXBzLlxyXG4gICAgZmlsdGVyTGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24obCkgeyBsKDAsIFtdLCByZW1vdmVkKTsgfSk7XHJcblxyXG4gICAgLy8gVXBkYXRlIGluZGV4ZXMuXHJcbiAgICByZW1vdmVEYXRhTGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24obCkgeyBsKG5ld0luZGV4KTsgfSk7XHJcblxyXG4gICAgLy8gUmVtb3ZlIG9sZCBmaWx0ZXJzIGFuZCBkYXRhIGJ5IG92ZXJ3cml0aW5nLlxyXG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSAwLCBrOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgIGlmIChrID0gZmlsdGVyc1tpXSkge1xyXG4gICAgICAgIGlmIChpICE9PSBqKSBmaWx0ZXJzW2pdID0gaywgZGF0YVtqXSA9IGRhdGFbaV07XHJcbiAgICAgICAgKytqO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBkYXRhLmxlbmd0aCA9IGo7XHJcbiAgICB3aGlsZSAobiA+IGopIGZpbHRlcnNbLS1uXSA9IDA7XHJcbiAgfVxyXG5cclxuICAvLyBBZGRzIGEgbmV3IGRpbWVuc2lvbiB3aXRoIHRoZSBzcGVjaWZpZWQgdmFsdWUgYWNjZXNzb3IgZnVuY3Rpb24uXHJcbiAgZnVuY3Rpb24gZGltZW5zaW9uKHZhbHVlKSB7XHJcbiAgICB2YXIgZGltZW5zaW9uID0ge1xyXG4gICAgICBmaWx0ZXI6IGZpbHRlcixcclxuICAgICAgZmlsdGVyRXhhY3Q6IGZpbHRlckV4YWN0LFxyXG4gICAgICBmaWx0ZXJSYW5nZTogZmlsdGVyUmFuZ2UsXHJcbiAgICAgIGZpbHRlckZ1bmN0aW9uOiBmaWx0ZXJGdW5jdGlvbixcclxuICAgICAgZmlsdGVyQWxsOiBmaWx0ZXJBbGwsXHJcbiAgICAgIHRvcDogdG9wLFxyXG4gICAgICBib3R0b206IGJvdHRvbSxcclxuICAgICAgZ3JvdXA6IGdyb3VwLFxyXG4gICAgICBncm91cEFsbDogZ3JvdXBBbGwsXHJcbiAgICAgIGRpc3Bvc2U6IGRpc3Bvc2UsXHJcbiAgICAgIHJlbW92ZTogZGlzcG9zZSAvLyBmb3IgYmFja3dhcmRzLWNvbXBhdGliaWxpdHlcclxuICAgIH07XHJcblxyXG4gICAgdmFyIG9uZSA9IH5tICYgLX5tLCAvLyBsb3dlc3QgdW5zZXQgYml0IGFzIG1hc2ssIGUuZy4sIDAwMDAxMDAwXHJcbiAgICAgICAgemVybyA9IH5vbmUsIC8vIGludmVydGVkIG9uZSwgZS5nLiwgMTExMTAxMTFcclxuICAgICAgICB2YWx1ZXMsIC8vIHNvcnRlZCwgY2FjaGVkIGFycmF5XHJcbiAgICAgICAgaW5kZXgsIC8vIHZhbHVlIHJhbmsg4oamIG9iamVjdCBpZFxyXG4gICAgICAgIG5ld1ZhbHVlcywgLy8gdGVtcG9yYXJ5IGFycmF5IHN0b3JpbmcgbmV3bHktYWRkZWQgdmFsdWVzXHJcbiAgICAgICAgbmV3SW5kZXgsIC8vIHRlbXBvcmFyeSBhcnJheSBzdG9yaW5nIG5ld2x5LWFkZGVkIGluZGV4XHJcbiAgICAgICAgc29ydCA9IHF1aWNrc29ydF9ieShmdW5jdGlvbihpKSB7IHJldHVybiBuZXdWYWx1ZXNbaV07IH0pLFxyXG4gICAgICAgIHJlZmlsdGVyID0gY3Jvc3NmaWx0ZXJfZmlsdGVyQWxsLCAvLyBmb3IgcmVjb21wdXRpbmcgZmlsdGVyXHJcbiAgICAgICAgcmVmaWx0ZXJGdW5jdGlvbiwgLy8gdGhlIGN1c3RvbSBmaWx0ZXIgZnVuY3Rpb24gaW4gdXNlXHJcbiAgICAgICAgaW5kZXhMaXN0ZW5lcnMgPSBbXSwgLy8gd2hlbiBkYXRhIGlzIGFkZGVkXHJcbiAgICAgICAgZGltZW5zaW9uR3JvdXBzID0gW10sXHJcbiAgICAgICAgbG8wID0gMCxcclxuICAgICAgICBoaTAgPSAwO1xyXG5cclxuICAgIC8vIFVwZGF0aW5nIGEgZGltZW5zaW9uIGlzIGEgdHdvLXN0YWdlIHByb2Nlc3MuIEZpcnN0LCB3ZSBtdXN0IHVwZGF0ZSB0aGVcclxuICAgIC8vIGFzc29jaWF0ZWQgZmlsdGVycyBmb3IgdGhlIG5ld2x5LWFkZGVkIHJlY29yZHMuIE9uY2UgYWxsIGRpbWVuc2lvbnMgaGF2ZVxyXG4gICAgLy8gdXBkYXRlZCB0aGVpciBmaWx0ZXJzLCB0aGUgZ3JvdXBzIGFyZSBub3RpZmllZCB0byB1cGRhdGUuXHJcbiAgICBkYXRhTGlzdGVuZXJzLnVuc2hpZnQocHJlQWRkKTtcclxuICAgIGRhdGFMaXN0ZW5lcnMucHVzaChwb3N0QWRkKTtcclxuXHJcbiAgICByZW1vdmVEYXRhTGlzdGVuZXJzLnB1c2gocmVtb3ZlRGF0YSk7XHJcblxyXG4gICAgLy8gSW5jb3Jwb3JhdGUgYW55IGV4aXN0aW5nIGRhdGEgaW50byB0aGlzIGRpbWVuc2lvbiwgYW5kIG1ha2Ugc3VyZSB0aGF0IHRoZVxyXG4gICAgLy8gZmlsdGVyIGJpdHNldCBpcyB3aWRlIGVub3VnaCB0byBoYW5kbGUgdGhlIG5ldyBkaW1lbnNpb24uXHJcbiAgICBtIHw9IG9uZTtcclxuICAgIGlmIChNID49IDMyID8gIW9uZSA6IG0gJiAtKDEgPDwgTSkpIHtcclxuICAgICAgZmlsdGVycyA9IGNyb3NzZmlsdGVyX2FycmF5V2lkZW4oZmlsdGVycywgTSA8PD0gMSk7XHJcbiAgICB9XHJcbiAgICBwcmVBZGQoZGF0YSwgMCwgbik7XHJcbiAgICBwb3N0QWRkKGRhdGEsIDAsIG4pO1xyXG5cclxuICAgIC8vIEluY29ycG9yYXRlcyB0aGUgc3BlY2lmaWVkIG5ldyByZWNvcmRzIGludG8gdGhpcyBkaW1lbnNpb24uXHJcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHJlc3BvbnNpYmxlIGZvciB1cGRhdGluZyBmaWx0ZXJzLCB2YWx1ZXMsIGFuZCBpbmRleC5cclxuICAgIGZ1bmN0aW9uIHByZUFkZChuZXdEYXRhLCBuMCwgbjEpIHtcclxuXHJcbiAgICAgIC8vIFBlcm11dGUgbmV3IHZhbHVlcyBpbnRvIG5hdHVyYWwgb3JkZXIgdXNpbmcgYSBzb3J0ZWQgaW5kZXguXHJcbiAgICAgIG5ld1ZhbHVlcyA9IG5ld0RhdGEubWFwKHZhbHVlKTtcclxuICAgICAgbmV3SW5kZXggPSBzb3J0KGNyb3NzZmlsdGVyX3JhbmdlKG4xKSwgMCwgbjEpO1xyXG4gICAgICBuZXdWYWx1ZXMgPSBwZXJtdXRlKG5ld1ZhbHVlcywgbmV3SW5kZXgpO1xyXG5cclxuICAgICAgLy8gQmlzZWN0IG5ld1ZhbHVlcyB0byBkZXRlcm1pbmUgd2hpY2ggbmV3IHJlY29yZHMgYXJlIHNlbGVjdGVkLlxyXG4gICAgICB2YXIgYm91bmRzID0gcmVmaWx0ZXIobmV3VmFsdWVzKSwgbG8xID0gYm91bmRzWzBdLCBoaTEgPSBib3VuZHNbMV0sIGk7XHJcbiAgICAgIGlmIChyZWZpbHRlckZ1bmN0aW9uKSB7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG4xOyArK2kpIHtcclxuICAgICAgICAgIGlmICghcmVmaWx0ZXJGdW5jdGlvbihuZXdWYWx1ZXNbaV0sIGkpKSBmaWx0ZXJzW25ld0luZGV4W2ldICsgbjBdIHw9IG9uZTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxvMTsgKytpKSBmaWx0ZXJzW25ld0luZGV4W2ldICsgbjBdIHw9IG9uZTtcclxuICAgICAgICBmb3IgKGkgPSBoaTE7IGkgPCBuMTsgKytpKSBmaWx0ZXJzW25ld0luZGV4W2ldICsgbjBdIHw9IG9uZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSWYgdGhpcyBkaW1lbnNpb24gcHJldmlvdXNseSBoYWQgbm8gZGF0YSwgdGhlbiB3ZSBkb24ndCBuZWVkIHRvIGRvIHRoZVxyXG4gICAgICAvLyBtb3JlIGV4cGVuc2l2ZSBtZXJnZSBvcGVyYXRpb247IHVzZSB0aGUgbmV3IHZhbHVlcyBhbmQgaW5kZXggYXMtaXMuXHJcbiAgICAgIGlmICghbjApIHtcclxuICAgICAgICB2YWx1ZXMgPSBuZXdWYWx1ZXM7XHJcbiAgICAgICAgaW5kZXggPSBuZXdJbmRleDtcclxuICAgICAgICBsbzAgPSBsbzE7XHJcbiAgICAgICAgaGkwID0gaGkxO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIG9sZFZhbHVlcyA9IHZhbHVlcyxcclxuICAgICAgICAgIG9sZEluZGV4ID0gaW5kZXgsXHJcbiAgICAgICAgICBpMCA9IDAsXHJcbiAgICAgICAgICBpMSA9IDA7XHJcblxyXG4gICAgICAvLyBPdGhlcndpc2UsIGNyZWF0ZSBuZXcgYXJyYXlzIGludG8gd2hpY2ggdG8gbWVyZ2UgbmV3IGFuZCBvbGQuXHJcbiAgICAgIHZhbHVlcyA9IG5ldyBBcnJheShuKTtcclxuICAgICAgaW5kZXggPSBjcm9zc2ZpbHRlcl9pbmRleChuLCBuKTtcclxuXHJcbiAgICAgIC8vIE1lcmdlIHRoZSBvbGQgYW5kIG5ldyBzb3J0ZWQgdmFsdWVzLCBhbmQgb2xkIGFuZCBuZXcgaW5kZXguXHJcbiAgICAgIGZvciAoaSA9IDA7IGkwIDwgbjAgJiYgaTEgPCBuMTsgKytpKSB7XHJcbiAgICAgICAgaWYgKG9sZFZhbHVlc1tpMF0gPCBuZXdWYWx1ZXNbaTFdKSB7XHJcbiAgICAgICAgICB2YWx1ZXNbaV0gPSBvbGRWYWx1ZXNbaTBdO1xyXG4gICAgICAgICAgaW5kZXhbaV0gPSBvbGRJbmRleFtpMCsrXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdmFsdWVzW2ldID0gbmV3VmFsdWVzW2kxXTtcclxuICAgICAgICAgIGluZGV4W2ldID0gbmV3SW5kZXhbaTErK10gKyBuMDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEFkZCBhbnkgcmVtYWluaW5nIG9sZCB2YWx1ZXMuXHJcbiAgICAgIGZvciAoOyBpMCA8IG4wOyArK2kwLCArK2kpIHtcclxuICAgICAgICB2YWx1ZXNbaV0gPSBvbGRWYWx1ZXNbaTBdO1xyXG4gICAgICAgIGluZGV4W2ldID0gb2xkSW5kZXhbaTBdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBBZGQgYW55IHJlbWFpbmluZyBuZXcgdmFsdWVzLlxyXG4gICAgICBmb3IgKDsgaTEgPCBuMTsgKytpMSwgKytpKSB7XHJcbiAgICAgICAgdmFsdWVzW2ldID0gbmV3VmFsdWVzW2kxXTtcclxuICAgICAgICBpbmRleFtpXSA9IG5ld0luZGV4W2kxXSArIG4wO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBCaXNlY3QgYWdhaW4gdG8gcmVjb21wdXRlIGxvMCBhbmQgaGkwLlxyXG4gICAgICBib3VuZHMgPSByZWZpbHRlcih2YWx1ZXMpLCBsbzAgPSBib3VuZHNbMF0sIGhpMCA9IGJvdW5kc1sxXTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBXaGVuIGFsbCBmaWx0ZXJzIGhhdmUgdXBkYXRlZCwgbm90aWZ5IGluZGV4IGxpc3RlbmVycyBvZiB0aGUgbmV3IHZhbHVlcy5cclxuICAgIGZ1bmN0aW9uIHBvc3RBZGQobmV3RGF0YSwgbjAsIG4xKSB7XHJcbiAgICAgIGluZGV4TGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24obCkgeyBsKG5ld1ZhbHVlcywgbmV3SW5kZXgsIG4wLCBuMSk7IH0pO1xyXG4gICAgICBuZXdWYWx1ZXMgPSBuZXdJbmRleCA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVtb3ZlRGF0YShyZUluZGV4KSB7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gMCwgazsgaSA8IG47ICsraSkge1xyXG4gICAgICAgIGlmIChmaWx0ZXJzW2sgPSBpbmRleFtpXV0pIHtcclxuICAgICAgICAgIGlmIChpICE9PSBqKSB2YWx1ZXNbal0gPSB2YWx1ZXNbaV07XHJcbiAgICAgICAgICBpbmRleFtqXSA9IHJlSW5kZXhba107XHJcbiAgICAgICAgICArK2o7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHZhbHVlcy5sZW5ndGggPSBqO1xyXG4gICAgICB3aGlsZSAoaiA8IG4pIGluZGV4W2orK10gPSAwO1xyXG5cclxuICAgICAgLy8gQmlzZWN0IGFnYWluIHRvIHJlY29tcHV0ZSBsbzAgYW5kIGhpMC5cclxuICAgICAgdmFyIGJvdW5kcyA9IHJlZmlsdGVyKHZhbHVlcyk7XHJcbiAgICAgIGxvMCA9IGJvdW5kc1swXSwgaGkwID0gYm91bmRzWzFdO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFVwZGF0ZXMgdGhlIHNlbGVjdGVkIHZhbHVlcyBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIGJvdW5kcyBbbG8sIGhpXS5cclxuICAgIC8vIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgdXNlZCBieSBhbGwgdGhlIHB1YmxpYyBmaWx0ZXIgbWV0aG9kcy5cclxuICAgIGZ1bmN0aW9uIGZpbHRlckluZGV4Qm91bmRzKGJvdW5kcykge1xyXG4gICAgICB2YXIgbG8xID0gYm91bmRzWzBdLFxyXG4gICAgICAgICAgaGkxID0gYm91bmRzWzFdO1xyXG5cclxuICAgICAgaWYgKHJlZmlsdGVyRnVuY3Rpb24pIHtcclxuICAgICAgICByZWZpbHRlckZ1bmN0aW9uID0gbnVsbDtcclxuICAgICAgICBmaWx0ZXJJbmRleEZ1bmN0aW9uKGZ1bmN0aW9uKGQsIGkpIHsgcmV0dXJuIGxvMSA8PSBpICYmIGkgPCBoaTE7IH0pO1xyXG4gICAgICAgIGxvMCA9IGxvMTtcclxuICAgICAgICBoaTAgPSBoaTE7XHJcbiAgICAgICAgcmV0dXJuIGRpbWVuc2lvbjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGksXHJcbiAgICAgICAgICBqLFxyXG4gICAgICAgICAgayxcclxuICAgICAgICAgIGFkZGVkID0gW10sXHJcbiAgICAgICAgICByZW1vdmVkID0gW107XHJcblxyXG4gICAgICAvLyBGYXN0IGluY3JlbWVudGFsIHVwZGF0ZSBiYXNlZCBvbiBwcmV2aW91cyBsbyBpbmRleC5cclxuICAgICAgaWYgKGxvMSA8IGxvMCkge1xyXG4gICAgICAgIGZvciAoaSA9IGxvMSwgaiA9IE1hdGgubWluKGxvMCwgaGkxKTsgaSA8IGo7ICsraSkge1xyXG4gICAgICAgICAgZmlsdGVyc1trID0gaW5kZXhbaV1dIF49IG9uZTtcclxuICAgICAgICAgIGFkZGVkLnB1c2goayk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKGxvMSA+IGxvMCkge1xyXG4gICAgICAgIGZvciAoaSA9IGxvMCwgaiA9IE1hdGgubWluKGxvMSwgaGkwKTsgaSA8IGo7ICsraSkge1xyXG4gICAgICAgICAgZmlsdGVyc1trID0gaW5kZXhbaV1dIF49IG9uZTtcclxuICAgICAgICAgIHJlbW92ZWQucHVzaChrKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEZhc3QgaW5jcmVtZW50YWwgdXBkYXRlIGJhc2VkIG9uIHByZXZpb3VzIGhpIGluZGV4LlxyXG4gICAgICBpZiAoaGkxID4gaGkwKSB7XHJcbiAgICAgICAgZm9yIChpID0gTWF0aC5tYXgobG8xLCBoaTApLCBqID0gaGkxOyBpIDwgajsgKytpKSB7XHJcbiAgICAgICAgICBmaWx0ZXJzW2sgPSBpbmRleFtpXV0gXj0gb25lO1xyXG4gICAgICAgICAgYWRkZWQucHVzaChrKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAoaGkxIDwgaGkwKSB7XHJcbiAgICAgICAgZm9yIChpID0gTWF0aC5tYXgobG8wLCBoaTEpLCBqID0gaGkwOyBpIDwgajsgKytpKSB7XHJcbiAgICAgICAgICBmaWx0ZXJzW2sgPSBpbmRleFtpXV0gXj0gb25lO1xyXG4gICAgICAgICAgcmVtb3ZlZC5wdXNoKGspO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgbG8wID0gbG8xO1xyXG4gICAgICBoaTAgPSBoaTE7XHJcbiAgICAgIGZpbHRlckxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uKGwpIHsgbChvbmUsIGFkZGVkLCByZW1vdmVkKTsgfSk7XHJcbiAgICAgIHJldHVybiBkaW1lbnNpb247XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRmlsdGVycyB0aGlzIGRpbWVuc2lvbiB1c2luZyB0aGUgc3BlY2lmaWVkIHJhbmdlLCB2YWx1ZSwgb3IgbnVsbC5cclxuICAgIC8vIElmIHRoZSByYW5nZSBpcyBudWxsLCB0aGlzIGlzIGVxdWl2YWxlbnQgdG8gZmlsdGVyQWxsLlxyXG4gICAgLy8gSWYgdGhlIHJhbmdlIGlzIGFuIGFycmF5LCB0aGlzIGlzIGVxdWl2YWxlbnQgdG8gZmlsdGVyUmFuZ2UuXHJcbiAgICAvLyBPdGhlcndpc2UsIHRoaXMgaXMgZXF1aXZhbGVudCB0byBmaWx0ZXJFeGFjdC5cclxuICAgIGZ1bmN0aW9uIGZpbHRlcihyYW5nZSkge1xyXG4gICAgICByZXR1cm4gcmFuZ2UgPT0gbnVsbFxyXG4gICAgICAgICAgPyBmaWx0ZXJBbGwoKSA6IEFycmF5LmlzQXJyYXkocmFuZ2UpXHJcbiAgICAgICAgICA/IGZpbHRlclJhbmdlKHJhbmdlKSA6IHR5cGVvZiByYW5nZSA9PT0gXCJmdW5jdGlvblwiXHJcbiAgICAgICAgICA/IGZpbHRlckZ1bmN0aW9uKHJhbmdlKVxyXG4gICAgICAgICAgOiBmaWx0ZXJFeGFjdChyYW5nZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRmlsdGVycyB0aGlzIGRpbWVuc2lvbiB0byBzZWxlY3QgdGhlIGV4YWN0IHZhbHVlLlxyXG4gICAgZnVuY3Rpb24gZmlsdGVyRXhhY3QodmFsdWUpIHtcclxuICAgICAgcmV0dXJuIGZpbHRlckluZGV4Qm91bmRzKChyZWZpbHRlciA9IGNyb3NzZmlsdGVyX2ZpbHRlckV4YWN0KGJpc2VjdCwgdmFsdWUpKSh2YWx1ZXMpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBGaWx0ZXJzIHRoaXMgZGltZW5zaW9uIHRvIHNlbGVjdCB0aGUgc3BlY2lmaWVkIHJhbmdlIFtsbywgaGldLlxyXG4gICAgLy8gVGhlIGxvd2VyIGJvdW5kIGlzIGluY2x1c2l2ZSwgYW5kIHRoZSB1cHBlciBib3VuZCBpcyBleGNsdXNpdmUuXHJcbiAgICBmdW5jdGlvbiBmaWx0ZXJSYW5nZShyYW5nZSkge1xyXG4gICAgICByZXR1cm4gZmlsdGVySW5kZXhCb3VuZHMoKHJlZmlsdGVyID0gY3Jvc3NmaWx0ZXJfZmlsdGVyUmFuZ2UoYmlzZWN0LCByYW5nZSkpKHZhbHVlcykpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENsZWFycyBhbnkgZmlsdGVycyBvbiB0aGlzIGRpbWVuc2lvbi5cclxuICAgIGZ1bmN0aW9uIGZpbHRlckFsbCgpIHtcclxuICAgICAgcmV0dXJuIGZpbHRlckluZGV4Qm91bmRzKChyZWZpbHRlciA9IGNyb3NzZmlsdGVyX2ZpbHRlckFsbCkodmFsdWVzKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRmlsdGVycyB0aGlzIGRpbWVuc2lvbiB1c2luZyBhbiBhcmJpdHJhcnkgZnVuY3Rpb24uXHJcbiAgICBmdW5jdGlvbiBmaWx0ZXJGdW5jdGlvbihmKSB7XHJcbiAgICAgIHJlZmlsdGVyID0gY3Jvc3NmaWx0ZXJfZmlsdGVyQWxsO1xyXG5cclxuICAgICAgZmlsdGVySW5kZXhGdW5jdGlvbihyZWZpbHRlckZ1bmN0aW9uID0gZik7XHJcblxyXG4gICAgICBsbzAgPSAwO1xyXG4gICAgICBoaTAgPSBuO1xyXG5cclxuICAgICAgcmV0dXJuIGRpbWVuc2lvbjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBmaWx0ZXJJbmRleEZ1bmN0aW9uKGYpIHtcclxuICAgICAgdmFyIGksXHJcbiAgICAgICAgICBrLFxyXG4gICAgICAgICAgeCxcclxuICAgICAgICAgIGFkZGVkID0gW10sXHJcbiAgICAgICAgICByZW1vdmVkID0gW107XHJcblxyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgICAgaWYgKCEoZmlsdGVyc1trID0gaW5kZXhbaV1dICYgb25lKSBeICEhKHggPSBmKHZhbHVlc1tpXSwgaSkpKSB7XHJcbiAgICAgICAgICBpZiAoeCkgZmlsdGVyc1trXSAmPSB6ZXJvLCBhZGRlZC5wdXNoKGspO1xyXG4gICAgICAgICAgZWxzZSBmaWx0ZXJzW2tdIHw9IG9uZSwgcmVtb3ZlZC5wdXNoKGspO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBmaWx0ZXJMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbihsKSB7IGwob25lLCBhZGRlZCwgcmVtb3ZlZCk7IH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJldHVybnMgdGhlIHRvcCBLIHNlbGVjdGVkIHJlY29yZHMgYmFzZWQgb24gdGhpcyBkaW1lbnNpb24ncyBvcmRlci5cclxuICAgIC8vIE5vdGU6IG9ic2VydmVzIHRoaXMgZGltZW5zaW9uJ3MgZmlsdGVyLCB1bmxpa2UgZ3JvdXAgYW5kIGdyb3VwQWxsLlxyXG4gICAgZnVuY3Rpb24gdG9wKGspIHtcclxuICAgICAgdmFyIGFycmF5ID0gW10sXHJcbiAgICAgICAgICBpID0gaGkwLFxyXG4gICAgICAgICAgajtcclxuXHJcbiAgICAgIHdoaWxlICgtLWkgPj0gbG8wICYmIGsgPiAwKSB7XHJcbiAgICAgICAgaWYgKCFmaWx0ZXJzW2ogPSBpbmRleFtpXV0pIHtcclxuICAgICAgICAgIGFycmF5LnB1c2goZGF0YVtqXSk7XHJcbiAgICAgICAgICAtLWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gYXJyYXk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmV0dXJucyB0aGUgYm90dG9tIEsgc2VsZWN0ZWQgcmVjb3JkcyBiYXNlZCBvbiB0aGlzIGRpbWVuc2lvbidzIG9yZGVyLlxyXG4gICAgLy8gTm90ZTogb2JzZXJ2ZXMgdGhpcyBkaW1lbnNpb24ncyBmaWx0ZXIsIHVubGlrZSBncm91cCBhbmQgZ3JvdXBBbGwuXHJcbiAgICBmdW5jdGlvbiBib3R0b20oaykge1xyXG4gICAgICB2YXIgYXJyYXkgPSBbXSxcclxuICAgICAgICAgIGkgPSBsbzAsXHJcbiAgICAgICAgICBqO1xyXG5cclxuICAgICAgd2hpbGUgKGkgPCBoaTAgJiYgayA+IDApIHtcclxuICAgICAgICBpZiAoIWZpbHRlcnNbaiA9IGluZGV4W2ldXSkge1xyXG4gICAgICAgICAgYXJyYXkucHVzaChkYXRhW2pdKTtcclxuICAgICAgICAgIC0taztcclxuICAgICAgICB9XHJcbiAgICAgICAgaSsrO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gYXJyYXk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQWRkcyBhIG5ldyBncm91cCB0byB0aGlzIGRpbWVuc2lvbiwgdXNpbmcgdGhlIHNwZWNpZmllZCBrZXkgZnVuY3Rpb24uXHJcbiAgICBmdW5jdGlvbiBncm91cChrZXkpIHtcclxuICAgICAgdmFyIGdyb3VwID0ge1xyXG4gICAgICAgIHRvcDogdG9wLFxyXG4gICAgICAgIGFsbDogYWxsLFxyXG4gICAgICAgIHJlZHVjZTogcmVkdWNlLFxyXG4gICAgICAgIHJlZHVjZUNvdW50OiByZWR1Y2VDb3VudCxcclxuICAgICAgICByZWR1Y2VTdW06IHJlZHVjZVN1bSxcclxuICAgICAgICBvcmRlcjogb3JkZXIsXHJcbiAgICAgICAgb3JkZXJOYXR1cmFsOiBvcmRlck5hdHVyYWwsXHJcbiAgICAgICAgc2l6ZTogc2l6ZSxcclxuICAgICAgICBkaXNwb3NlOiBkaXNwb3NlLFxyXG4gICAgICAgIHJlbW92ZTogZGlzcG9zZSAvLyBmb3IgYmFja3dhcmRzLWNvbXBhdGliaWxpdHlcclxuICAgICAgfTtcclxuXHJcbiAgICAgIC8vIEVuc3VyZSB0aGF0IHRoaXMgZ3JvdXAgd2lsbCBiZSByZW1vdmVkIHdoZW4gdGhlIGRpbWVuc2lvbiBpcyByZW1vdmVkLlxyXG4gICAgICBkaW1lbnNpb25Hcm91cHMucHVzaChncm91cCk7XHJcblxyXG4gICAgICB2YXIgZ3JvdXBzLCAvLyBhcnJheSBvZiB7a2V5LCB2YWx1ZX1cclxuICAgICAgICAgIGdyb3VwSW5kZXgsIC8vIG9iamVjdCBpZCDihqYgZ3JvdXAgaWRcclxuICAgICAgICAgIGdyb3VwV2lkdGggPSA4LFxyXG4gICAgICAgICAgZ3JvdXBDYXBhY2l0eSA9IGNyb3NzZmlsdGVyX2NhcGFjaXR5KGdyb3VwV2lkdGgpLFxyXG4gICAgICAgICAgayA9IDAsIC8vIGNhcmRpbmFsaXR5XHJcbiAgICAgICAgICBzZWxlY3QsXHJcbiAgICAgICAgICBoZWFwLFxyXG4gICAgICAgICAgcmVkdWNlQWRkLFxyXG4gICAgICAgICAgcmVkdWNlUmVtb3ZlLFxyXG4gICAgICAgICAgcmVkdWNlSW5pdGlhbCxcclxuICAgICAgICAgIHVwZGF0ZSA9IGNyb3NzZmlsdGVyX251bGwsXHJcbiAgICAgICAgICByZXNldCA9IGNyb3NzZmlsdGVyX251bGwsXHJcbiAgICAgICAgICByZXNldE5lZWRlZCA9IHRydWUsXHJcbiAgICAgICAgICBncm91cEFsbCA9IGtleSA9PT0gY3Jvc3NmaWx0ZXJfbnVsbDtcclxuXHJcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkga2V5ID0gY3Jvc3NmaWx0ZXJfaWRlbnRpdHk7XHJcblxyXG4gICAgICAvLyBUaGUgZ3JvdXAgbGlzdGVucyB0byB0aGUgY3Jvc3NmaWx0ZXIgZm9yIHdoZW4gYW55IGRpbWVuc2lvbiBjaGFuZ2VzLCBzb1xyXG4gICAgICAvLyB0aGF0IGl0IGNhbiB1cGRhdGUgdGhlIGFzc29jaWF0ZWQgcmVkdWNlIHZhbHVlcy4gSXQgbXVzdCBhbHNvIGxpc3RlbiB0b1xyXG4gICAgICAvLyB0aGUgcGFyZW50IGRpbWVuc2lvbiBmb3Igd2hlbiBkYXRhIGlzIGFkZGVkLCBhbmQgY29tcHV0ZSBuZXcga2V5cy5cclxuICAgICAgZmlsdGVyTGlzdGVuZXJzLnB1c2godXBkYXRlKTtcclxuICAgICAgaW5kZXhMaXN0ZW5lcnMucHVzaChhZGQpO1xyXG4gICAgICByZW1vdmVEYXRhTGlzdGVuZXJzLnB1c2gocmVtb3ZlRGF0YSk7XHJcblxyXG4gICAgICAvLyBJbmNvcnBvcmF0ZSBhbnkgZXhpc3RpbmcgZGF0YSBpbnRvIHRoZSBncm91cGluZy5cclxuICAgICAgYWRkKHZhbHVlcywgaW5kZXgsIDAsIG4pO1xyXG5cclxuICAgICAgLy8gSW5jb3Jwb3JhdGVzIHRoZSBzcGVjaWZpZWQgbmV3IHZhbHVlcyBpbnRvIHRoaXMgZ3JvdXAuXHJcbiAgICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgcmVzcG9uc2libGUgZm9yIHVwZGF0aW5nIGdyb3VwcyBhbmQgZ3JvdXBJbmRleC5cclxuICAgICAgZnVuY3Rpb24gYWRkKG5ld1ZhbHVlcywgbmV3SW5kZXgsIG4wLCBuMSkge1xyXG4gICAgICAgIHZhciBvbGRHcm91cHMgPSBncm91cHMsXHJcbiAgICAgICAgICAgIHJlSW5kZXggPSBjcm9zc2ZpbHRlcl9pbmRleChrLCBncm91cENhcGFjaXR5KSxcclxuICAgICAgICAgICAgYWRkID0gcmVkdWNlQWRkLFxyXG4gICAgICAgICAgICBpbml0aWFsID0gcmVkdWNlSW5pdGlhbCxcclxuICAgICAgICAgICAgazAgPSBrLCAvLyBvbGQgY2FyZGluYWxpdHlcclxuICAgICAgICAgICAgaTAgPSAwLCAvLyBpbmRleCBvZiBvbGQgZ3JvdXBcclxuICAgICAgICAgICAgaTEgPSAwLCAvLyBpbmRleCBvZiBuZXcgcmVjb3JkXHJcbiAgICAgICAgICAgIGosIC8vIG9iamVjdCBpZFxyXG4gICAgICAgICAgICBnMCwgLy8gb2xkIGdyb3VwXHJcbiAgICAgICAgICAgIHgwLCAvLyBvbGQga2V5XHJcbiAgICAgICAgICAgIHgxLCAvLyBuZXcga2V5XHJcbiAgICAgICAgICAgIGcsIC8vIGdyb3VwIHRvIGFkZFxyXG4gICAgICAgICAgICB4OyAvLyBrZXkgb2YgZ3JvdXAgdG8gYWRkXHJcblxyXG4gICAgICAgIC8vIElmIGEgcmVzZXQgaXMgbmVlZGVkLCB3ZSBkb24ndCBuZWVkIHRvIHVwZGF0ZSB0aGUgcmVkdWNlIHZhbHVlcy5cclxuICAgICAgICBpZiAocmVzZXROZWVkZWQpIGFkZCA9IGluaXRpYWwgPSBjcm9zc2ZpbHRlcl9udWxsO1xyXG5cclxuICAgICAgICAvLyBSZXNldCB0aGUgbmV3IGdyb3VwcyAoayBpcyBhIGxvd2VyIGJvdW5kKS5cclxuICAgICAgICAvLyBBbHNvLCBtYWtlIHN1cmUgdGhhdCBncm91cEluZGV4IGV4aXN0cyBhbmQgaXMgbG9uZyBlbm91Z2guXHJcbiAgICAgICAgZ3JvdXBzID0gbmV3IEFycmF5KGspLCBrID0gMDtcclxuICAgICAgICBncm91cEluZGV4ID0gazAgPiAxID8gY3Jvc3NmaWx0ZXJfYXJyYXlMZW5ndGhlbihncm91cEluZGV4LCBuKSA6IGNyb3NzZmlsdGVyX2luZGV4KG4sIGdyb3VwQ2FwYWNpdHkpO1xyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIGZpcnN0IG9sZCBrZXkgKHgwIG9mIGcwKSwgaWYgaXQgZXhpc3RzLlxyXG4gICAgICAgIGlmIChrMCkgeDAgPSAoZzAgPSBvbGRHcm91cHNbMF0pLmtleTtcclxuXHJcbiAgICAgICAgLy8gRmluZCB0aGUgZmlyc3QgbmV3IGtleSAoeDEpLCBza2lwcGluZyBOYU4ga2V5cy5cclxuICAgICAgICB3aGlsZSAoaTEgPCBuMSAmJiAhKCh4MSA9IGtleShuZXdWYWx1ZXNbaTFdKSkgPj0geDEpKSArK2kxO1xyXG5cclxuICAgICAgICAvLyBXaGlsZSBuZXcga2V5cyByZW1haW7igKZcclxuICAgICAgICB3aGlsZSAoaTEgPCBuMSkge1xyXG5cclxuICAgICAgICAgIC8vIERldGVybWluZSB0aGUgbGVzc2VyIG9mIHRoZSB0d28gY3VycmVudCBrZXlzOyBuZXcgYW5kIG9sZC5cclxuICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBvbGQga2V5cyByZW1haW5pbmcsIHRoZW4gYWx3YXlzIGFkZCB0aGUgbmV3IGtleS5cclxuICAgICAgICAgIGlmIChnMCAmJiB4MCA8PSB4MSkge1xyXG4gICAgICAgICAgICBnID0gZzAsIHggPSB4MDtcclxuXHJcbiAgICAgICAgICAgIC8vIFJlY29yZCB0aGUgbmV3IGluZGV4IG9mIHRoZSBvbGQgZ3JvdXAuXHJcbiAgICAgICAgICAgIHJlSW5kZXhbaTBdID0gaztcclxuXHJcbiAgICAgICAgICAgIC8vIFJldHJpZXZlIHRoZSBuZXh0IG9sZCBrZXkuXHJcbiAgICAgICAgICAgIGlmIChnMCA9IG9sZEdyb3Vwc1srK2kwXSkgeDAgPSBnMC5rZXk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBnID0ge2tleTogeDEsIHZhbHVlOiBpbml0aWFsKCl9LCB4ID0geDE7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gQWRkIHRoZSBsZXNzZXIgZ3JvdXAuXHJcbiAgICAgICAgICBncm91cHNba10gPSBnO1xyXG5cclxuICAgICAgICAgIC8vIEFkZCBhbnkgc2VsZWN0ZWQgcmVjb3JkcyBiZWxvbmdpbmcgdG8gdGhlIGFkZGVkIGdyb3VwLCB3aGlsZVxyXG4gICAgICAgICAgLy8gYWR2YW5jaW5nIHRoZSBuZXcga2V5IGFuZCBwb3B1bGF0aW5nIHRoZSBhc3NvY2lhdGVkIGdyb3VwIGluZGV4LlxyXG4gICAgICAgICAgd2hpbGUgKCEoeDEgPiB4KSkge1xyXG4gICAgICAgICAgICBncm91cEluZGV4W2ogPSBuZXdJbmRleFtpMV0gKyBuMF0gPSBrO1xyXG4gICAgICAgICAgICBpZiAoIShmaWx0ZXJzW2pdICYgemVybykpIGcudmFsdWUgPSBhZGQoZy52YWx1ZSwgZGF0YVtqXSk7XHJcbiAgICAgICAgICAgIGlmICgrK2kxID49IG4xKSBicmVhaztcclxuICAgICAgICAgICAgeDEgPSBrZXkobmV3VmFsdWVzW2kxXSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZ3JvdXBJbmNyZW1lbnQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEFkZCBhbnkgcmVtYWluaW5nIG9sZCBncm91cHMgdGhhdCB3ZXJlIGdyZWF0ZXIgdGhhbiBhbGwgbmV3IGtleXMuXHJcbiAgICAgICAgLy8gTm8gaW5jcmVtZW50YWwgcmVkdWNlIGlzIG5lZWRlZDsgdGhlc2UgZ3JvdXBzIGhhdmUgbm8gbmV3IHJlY29yZHMuXHJcbiAgICAgICAgLy8gQWxzbyByZWNvcmQgdGhlIG5ldyBpbmRleCBvZiB0aGUgb2xkIGdyb3VwLlxyXG4gICAgICAgIHdoaWxlIChpMCA8IGswKSB7XHJcbiAgICAgICAgICBncm91cHNbcmVJbmRleFtpMF0gPSBrXSA9IG9sZEdyb3Vwc1tpMCsrXTtcclxuICAgICAgICAgIGdyb3VwSW5jcmVtZW50KCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJZiB3ZSBhZGRlZCBhbnkgbmV3IGdyb3VwcyBiZWZvcmUgYW55IG9sZCBncm91cHMsXHJcbiAgICAgICAgLy8gdXBkYXRlIHRoZSBncm91cCBpbmRleCBvZiBhbGwgdGhlIG9sZCByZWNvcmRzLlxyXG4gICAgICAgIGlmIChrID4gaTApIGZvciAoaTAgPSAwOyBpMCA8IG4wOyArK2kwKSB7XHJcbiAgICAgICAgICBncm91cEluZGV4W2kwXSA9IHJlSW5kZXhbZ3JvdXBJbmRleFtpMF1dO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gTW9kaWZ5IHRoZSB1cGRhdGUgYW5kIHJlc2V0IGJlaGF2aW9yIGJhc2VkIG9uIHRoZSBjYXJkaW5hbGl0eS5cclxuICAgICAgICAvLyBJZiB0aGUgY2FyZGluYWxpdHkgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIG9uZSwgdGhlbiB0aGUgZ3JvdXBJbmRleFxyXG4gICAgICAgIC8vIGlzIG5vdCBuZWVkZWQuIElmIHRoZSBjYXJkaW5hbGl0eSBpcyB6ZXJvLCB0aGVuIHRoZXJlIGFyZSBubyByZWNvcmRzXHJcbiAgICAgICAgLy8gYW5kIHRoZXJlZm9yZSBubyBncm91cHMgdG8gdXBkYXRlIG9yIHJlc2V0LiBOb3RlIHRoYXQgd2UgYWxzbyBtdXN0XHJcbiAgICAgICAgLy8gY2hhbmdlIHRoZSByZWdpc3RlcmVkIGxpc3RlbmVyIHRvIHBvaW50IHRvIHRoZSBuZXcgbWV0aG9kLlxyXG4gICAgICAgIGogPSBmaWx0ZXJMaXN0ZW5lcnMuaW5kZXhPZih1cGRhdGUpO1xyXG4gICAgICAgIGlmIChrID4gMSkge1xyXG4gICAgICAgICAgdXBkYXRlID0gdXBkYXRlTWFueTtcclxuICAgICAgICAgIHJlc2V0ID0gcmVzZXRNYW55O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpZiAoIWsgJiYgZ3JvdXBBbGwpIHtcclxuICAgICAgICAgICAgayA9IDE7XHJcbiAgICAgICAgICAgIGdyb3VwcyA9IFt7a2V5OiBudWxsLCB2YWx1ZTogaW5pdGlhbCgpfV07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoayA9PT0gMSkge1xyXG4gICAgICAgICAgICB1cGRhdGUgPSB1cGRhdGVPbmU7XHJcbiAgICAgICAgICAgIHJlc2V0ID0gcmVzZXRPbmU7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB1cGRhdGUgPSBjcm9zc2ZpbHRlcl9udWxsO1xyXG4gICAgICAgICAgICByZXNldCA9IGNyb3NzZmlsdGVyX251bGw7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBncm91cEluZGV4ID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmlsdGVyTGlzdGVuZXJzW2pdID0gdXBkYXRlO1xyXG5cclxuICAgICAgICAvLyBDb3VudCB0aGUgbnVtYmVyIG9mIGFkZGVkIGdyb3VwcyxcclxuICAgICAgICAvLyBhbmQgd2lkZW4gdGhlIGdyb3VwIGluZGV4IGFzIG5lZWRlZC5cclxuICAgICAgICBmdW5jdGlvbiBncm91cEluY3JlbWVudCgpIHtcclxuICAgICAgICAgIGlmICgrK2sgPT09IGdyb3VwQ2FwYWNpdHkpIHtcclxuICAgICAgICAgICAgcmVJbmRleCA9IGNyb3NzZmlsdGVyX2FycmF5V2lkZW4ocmVJbmRleCwgZ3JvdXBXaWR0aCA8PD0gMSk7XHJcbiAgICAgICAgICAgIGdyb3VwSW5kZXggPSBjcm9zc2ZpbHRlcl9hcnJheVdpZGVuKGdyb3VwSW5kZXgsIGdyb3VwV2lkdGgpO1xyXG4gICAgICAgICAgICBncm91cENhcGFjaXR5ID0gY3Jvc3NmaWx0ZXJfY2FwYWNpdHkoZ3JvdXBXaWR0aCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiByZW1vdmVEYXRhKCkge1xyXG4gICAgICAgIGlmIChrID4gMSkge1xyXG4gICAgICAgICAgdmFyIG9sZEsgPSBrLFxyXG4gICAgICAgICAgICAgIG9sZEdyb3VwcyA9IGdyb3VwcyxcclxuICAgICAgICAgICAgICBzZWVuR3JvdXBzID0gY3Jvc3NmaWx0ZXJfaW5kZXgob2xkSywgb2xkSyk7XHJcblxyXG4gICAgICAgICAgLy8gRmlsdGVyIG91dCBub24tbWF0Y2hlcyBieSBjb3B5aW5nIG1hdGNoaW5nIGdyb3VwIGluZGV4IGVudHJpZXMgdG9cclxuICAgICAgICAgIC8vIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5LlxyXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSAwOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgICAgICAgIGlmIChmaWx0ZXJzW2ldKSB7XHJcbiAgICAgICAgICAgICAgc2Vlbkdyb3Vwc1tncm91cEluZGV4W2pdID0gZ3JvdXBJbmRleFtpXV0gPSAxO1xyXG4gICAgICAgICAgICAgICsrajtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJlYXNzZW1ibGUgZ3JvdXBzIGluY2x1ZGluZyBvbmx5IHRob3NlIGdyb3VwcyB0aGF0IHdlcmUgcmVmZXJyZWRcclxuICAgICAgICAgIC8vIHRvIGJ5IG1hdGNoaW5nIGdyb3VwIGluZGV4IGVudHJpZXMuICBOb3RlIHRoZSBuZXcgZ3JvdXAgaW5kZXggaW5cclxuICAgICAgICAgIC8vIHNlZW5Hcm91cHMuXHJcbiAgICAgICAgICBncm91cHMgPSBbXSwgayA9IDA7XHJcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb2xkSzsgKytpKSB7XHJcbiAgICAgICAgICAgIGlmIChzZWVuR3JvdXBzW2ldKSB7XHJcbiAgICAgICAgICAgICAgc2Vlbkdyb3Vwc1tpXSA9IGsrKztcclxuICAgICAgICAgICAgICBncm91cHMucHVzaChvbGRHcm91cHNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKGsgPiAxKSB7XHJcbiAgICAgICAgICAgIC8vIFJlaW5kZXggdGhlIGdyb3VwIGluZGV4IHVzaW5nIHNlZW5Hcm91cHMgdG8gZmluZCB0aGUgbmV3IGluZGV4LlxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGo7ICsraSkgZ3JvdXBJbmRleFtpXSA9IHNlZW5Hcm91cHNbZ3JvdXBJbmRleFtpXV07XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBncm91cEluZGV4ID0gbnVsbDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGZpbHRlckxpc3RlbmVyc1tmaWx0ZXJMaXN0ZW5lcnMuaW5kZXhPZih1cGRhdGUpXSA9IGsgPiAxXHJcbiAgICAgICAgICAgICAgPyAocmVzZXQgPSByZXNldE1hbnksIHVwZGF0ZSA9IHVwZGF0ZU1hbnkpXHJcbiAgICAgICAgICAgICAgOiBrID09PSAxID8gKHJlc2V0ID0gcmVzZXRPbmUsIHVwZGF0ZSA9IHVwZGF0ZU9uZSlcclxuICAgICAgICAgICAgICA6IHJlc2V0ID0gdXBkYXRlID0gY3Jvc3NmaWx0ZXJfbnVsbDtcclxuICAgICAgICB9IGVsc2UgaWYgKGsgPT09IDEpIHtcclxuICAgICAgICAgIGlmIChncm91cEFsbCkgcmV0dXJuO1xyXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIGlmIChmaWx0ZXJzW2ldKSByZXR1cm47XHJcbiAgICAgICAgICBncm91cHMgPSBbXSwgayA9IDA7XHJcbiAgICAgICAgICBmaWx0ZXJMaXN0ZW5lcnNbZmlsdGVyTGlzdGVuZXJzLmluZGV4T2YodXBkYXRlKV0gPVxyXG4gICAgICAgICAgdXBkYXRlID0gcmVzZXQgPSBjcm9zc2ZpbHRlcl9udWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUmVkdWNlcyB0aGUgc3BlY2lmaWVkIHNlbGVjdGVkIG9yIGRlc2VsZWN0ZWQgcmVjb3Jkcy5cclxuICAgICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBvbmx5IHVzZWQgd2hlbiB0aGUgY2FyZGluYWxpdHkgaXMgZ3JlYXRlciB0aGFuIDEuXHJcbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZU1hbnkoZmlsdGVyT25lLCBhZGRlZCwgcmVtb3ZlZCkge1xyXG4gICAgICAgIGlmIChmaWx0ZXJPbmUgPT09IG9uZSB8fCByZXNldE5lZWRlZCkgcmV0dXJuO1xyXG5cclxuICAgICAgICB2YXIgaSxcclxuICAgICAgICAgICAgayxcclxuICAgICAgICAgICAgbixcclxuICAgICAgICAgICAgZztcclxuXHJcbiAgICAgICAgLy8gQWRkIHRoZSBhZGRlZCB2YWx1ZXMuXHJcbiAgICAgICAgZm9yIChpID0gMCwgbiA9IGFkZGVkLmxlbmd0aDsgaSA8IG47ICsraSkge1xyXG4gICAgICAgICAgaWYgKCEoZmlsdGVyc1trID0gYWRkZWRbaV1dICYgemVybykpIHtcclxuICAgICAgICAgICAgZyA9IGdyb3Vwc1tncm91cEluZGV4W2tdXTtcclxuICAgICAgICAgICAgZy52YWx1ZSA9IHJlZHVjZUFkZChnLnZhbHVlLCBkYXRhW2tdKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgcmVtb3ZlZCB2YWx1ZXMuXHJcbiAgICAgICAgZm9yIChpID0gMCwgbiA9IHJlbW92ZWQubGVuZ3RoOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgICAgICBpZiAoKGZpbHRlcnNbayA9IHJlbW92ZWRbaV1dICYgemVybykgPT09IGZpbHRlck9uZSkge1xyXG4gICAgICAgICAgICBnID0gZ3JvdXBzW2dyb3VwSW5kZXhba11dO1xyXG4gICAgICAgICAgICBnLnZhbHVlID0gcmVkdWNlUmVtb3ZlKGcudmFsdWUsIGRhdGFba10pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUmVkdWNlcyB0aGUgc3BlY2lmaWVkIHNlbGVjdGVkIG9yIGRlc2VsZWN0ZWQgcmVjb3Jkcy5cclxuICAgICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBvbmx5IHVzZWQgd2hlbiB0aGUgY2FyZGluYWxpdHkgaXMgMS5cclxuICAgICAgZnVuY3Rpb24gdXBkYXRlT25lKGZpbHRlck9uZSwgYWRkZWQsIHJlbW92ZWQpIHtcclxuICAgICAgICBpZiAoZmlsdGVyT25lID09PSBvbmUgfHwgcmVzZXROZWVkZWQpIHJldHVybjtcclxuXHJcbiAgICAgICAgdmFyIGksXHJcbiAgICAgICAgICAgIGssXHJcbiAgICAgICAgICAgIG4sXHJcbiAgICAgICAgICAgIGcgPSBncm91cHNbMF07XHJcblxyXG4gICAgICAgIC8vIEFkZCB0aGUgYWRkZWQgdmFsdWVzLlxyXG4gICAgICAgIGZvciAoaSA9IDAsIG4gPSBhZGRlZC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcclxuICAgICAgICAgIGlmICghKGZpbHRlcnNbayA9IGFkZGVkW2ldXSAmIHplcm8pKSB7XHJcbiAgICAgICAgICAgIGcudmFsdWUgPSByZWR1Y2VBZGQoZy52YWx1ZSwgZGF0YVtrXSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZW1vdmUgdGhlIHJlbW92ZWQgdmFsdWVzLlxyXG4gICAgICAgIGZvciAoaSA9IDAsIG4gPSByZW1vdmVkLmxlbmd0aDsgaSA8IG47ICsraSkge1xyXG4gICAgICAgICAgaWYgKChmaWx0ZXJzW2sgPSByZW1vdmVkW2ldXSAmIHplcm8pID09PSBmaWx0ZXJPbmUpIHtcclxuICAgICAgICAgICAgZy52YWx1ZSA9IHJlZHVjZVJlbW92ZShnLnZhbHVlLCBkYXRhW2tdKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFJlY29tcHV0ZXMgdGhlIGdyb3VwIHJlZHVjZSB2YWx1ZXMgZnJvbSBzY3JhdGNoLlxyXG4gICAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIG9ubHkgdXNlZCB3aGVuIHRoZSBjYXJkaW5hbGl0eSBpcyBncmVhdGVyIHRoYW4gMS5cclxuICAgICAgZnVuY3Rpb24gcmVzZXRNYW55KCkge1xyXG4gICAgICAgIHZhciBpLFxyXG4gICAgICAgICAgICBnO1xyXG5cclxuICAgICAgICAvLyBSZXNldCBhbGwgZ3JvdXAgdmFsdWVzLlxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrOyArK2kpIHtcclxuICAgICAgICAgIGdyb3Vwc1tpXS52YWx1ZSA9IHJlZHVjZUluaXRpYWwoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEFkZCBhbnkgc2VsZWN0ZWQgcmVjb3Jkcy5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgICAgICBpZiAoIShmaWx0ZXJzW2ldICYgemVybykpIHtcclxuICAgICAgICAgICAgZyA9IGdyb3Vwc1tncm91cEluZGV4W2ldXTtcclxuICAgICAgICAgICAgZy52YWx1ZSA9IHJlZHVjZUFkZChnLnZhbHVlLCBkYXRhW2ldKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFJlY29tcHV0ZXMgdGhlIGdyb3VwIHJlZHVjZSB2YWx1ZXMgZnJvbSBzY3JhdGNoLlxyXG4gICAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIG9ubHkgdXNlZCB3aGVuIHRoZSBjYXJkaW5hbGl0eSBpcyAxLlxyXG4gICAgICBmdW5jdGlvbiByZXNldE9uZSgpIHtcclxuICAgICAgICB2YXIgaSxcclxuICAgICAgICAgICAgZyA9IGdyb3Vwc1swXTtcclxuXHJcbiAgICAgICAgLy8gUmVzZXQgdGhlIHNpbmdsZXRvbiBncm91cCB2YWx1ZXMuXHJcbiAgICAgICAgZy52YWx1ZSA9IHJlZHVjZUluaXRpYWwoKTtcclxuXHJcbiAgICAgICAgLy8gQWRkIGFueSBzZWxlY3RlZCByZWNvcmRzLlxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcclxuICAgICAgICAgIGlmICghKGZpbHRlcnNbaV0gJiB6ZXJvKSkge1xyXG4gICAgICAgICAgICBnLnZhbHVlID0gcmVkdWNlQWRkKGcudmFsdWUsIGRhdGFbaV0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUmV0dXJucyB0aGUgYXJyYXkgb2YgZ3JvdXAgdmFsdWVzLCBpbiB0aGUgZGltZW5zaW9uJ3MgbmF0dXJhbCBvcmRlci5cclxuICAgICAgZnVuY3Rpb24gYWxsKCkge1xyXG4gICAgICAgIGlmIChyZXNldE5lZWRlZCkgcmVzZXQoKSwgcmVzZXROZWVkZWQgPSBmYWxzZTtcclxuICAgICAgICByZXR1cm4gZ3JvdXBzO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZXR1cm5zIGEgbmV3IGFycmF5IGNvbnRhaW5pbmcgdGhlIHRvcCBLIGdyb3VwIHZhbHVlcywgaW4gcmVkdWNlIG9yZGVyLlxyXG4gICAgICBmdW5jdGlvbiB0b3Aoaykge1xyXG4gICAgICAgIHZhciB0b3AgPSBzZWxlY3QoYWxsKCksIDAsIGdyb3Vwcy5sZW5ndGgsIGspO1xyXG4gICAgICAgIHJldHVybiBoZWFwLnNvcnQodG9wLCAwLCB0b3AubGVuZ3RoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gU2V0cyB0aGUgcmVkdWNlIGJlaGF2aW9yIGZvciB0aGlzIGdyb3VwIHRvIHVzZSB0aGUgc3BlY2lmaWVkIGZ1bmN0aW9ucy5cclxuICAgICAgLy8gVGhpcyBtZXRob2QgbGF6aWx5IHJlY29tcHV0ZXMgdGhlIHJlZHVjZSB2YWx1ZXMsIHdhaXRpbmcgdW50aWwgbmVlZGVkLlxyXG4gICAgICBmdW5jdGlvbiByZWR1Y2UoYWRkLCByZW1vdmUsIGluaXRpYWwpIHtcclxuICAgICAgICByZWR1Y2VBZGQgPSBhZGQ7XHJcbiAgICAgICAgcmVkdWNlUmVtb3ZlID0gcmVtb3ZlO1xyXG4gICAgICAgIHJlZHVjZUluaXRpYWwgPSBpbml0aWFsO1xyXG4gICAgICAgIHJlc2V0TmVlZGVkID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gZ3JvdXA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEEgY29udmVuaWVuY2UgbWV0aG9kIGZvciByZWR1Y2luZyBieSBjb3VudC5cclxuICAgICAgZnVuY3Rpb24gcmVkdWNlQ291bnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlZHVjZShjcm9zc2ZpbHRlcl9yZWR1Y2VJbmNyZW1lbnQsIGNyb3NzZmlsdGVyX3JlZHVjZURlY3JlbWVudCwgY3Jvc3NmaWx0ZXJfemVybyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEEgY29udmVuaWVuY2UgbWV0aG9kIGZvciByZWR1Y2luZyBieSBzdW0odmFsdWUpLlxyXG4gICAgICBmdW5jdGlvbiByZWR1Y2VTdW0odmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gcmVkdWNlKGNyb3NzZmlsdGVyX3JlZHVjZUFkZCh2YWx1ZSksIGNyb3NzZmlsdGVyX3JlZHVjZVN1YnRyYWN0KHZhbHVlKSwgY3Jvc3NmaWx0ZXJfemVybyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFNldHMgdGhlIHJlZHVjZSBvcmRlciwgdXNpbmcgdGhlIHNwZWNpZmllZCBhY2Nlc3Nvci5cclxuICAgICAgZnVuY3Rpb24gb3JkZXIodmFsdWUpIHtcclxuICAgICAgICBzZWxlY3QgPSBoZWFwc2VsZWN0X2J5KHZhbHVlT2YpO1xyXG4gICAgICAgIGhlYXAgPSBoZWFwX2J5KHZhbHVlT2YpO1xyXG4gICAgICAgIGZ1bmN0aW9uIHZhbHVlT2YoZCkgeyByZXR1cm4gdmFsdWUoZC52YWx1ZSk7IH1cclxuICAgICAgICByZXR1cm4gZ3JvdXA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEEgY29udmVuaWVuY2UgbWV0aG9kIGZvciBuYXR1cmFsIG9yZGVyaW5nIGJ5IHJlZHVjZSB2YWx1ZS5cclxuICAgICAgZnVuY3Rpb24gb3JkZXJOYXR1cmFsKCkge1xyXG4gICAgICAgIHJldHVybiBvcmRlcihjcm9zc2ZpbHRlcl9pZGVudGl0eSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFJldHVybnMgdGhlIGNhcmRpbmFsaXR5IG9mIHRoaXMgZ3JvdXAsIGlycmVzcGVjdGl2ZSBvZiBhbnkgZmlsdGVycy5cclxuICAgICAgZnVuY3Rpb24gc2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gaztcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUmVtb3ZlcyB0aGlzIGdyb3VwIGFuZCBhc3NvY2lhdGVkIGV2ZW50IGxpc3RlbmVycy5cclxuICAgICAgZnVuY3Rpb24gZGlzcG9zZSgpIHtcclxuICAgICAgICB2YXIgaSA9IGZpbHRlckxpc3RlbmVycy5pbmRleE9mKHVwZGF0ZSk7XHJcbiAgICAgICAgaWYgKGkgPj0gMCkgZmlsdGVyTGlzdGVuZXJzLnNwbGljZShpLCAxKTtcclxuICAgICAgICBpID0gaW5kZXhMaXN0ZW5lcnMuaW5kZXhPZihhZGQpO1xyXG4gICAgICAgIGlmIChpID49IDApIGluZGV4TGlzdGVuZXJzLnNwbGljZShpLCAxKTtcclxuICAgICAgICBpID0gcmVtb3ZlRGF0YUxpc3RlbmVycy5pbmRleE9mKHJlbW92ZURhdGEpO1xyXG4gICAgICAgIGlmIChpID49IDApIHJlbW92ZURhdGFMaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgIHJldHVybiBncm91cDtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJlZHVjZUNvdW50KCkub3JkZXJOYXR1cmFsKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQSBjb252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgZ2VuZXJhdGluZyBhIHNpbmdsZXRvbiBncm91cC5cclxuICAgIGZ1bmN0aW9uIGdyb3VwQWxsKCkge1xyXG4gICAgICB2YXIgZyA9IGdyb3VwKGNyb3NzZmlsdGVyX251bGwpLCBhbGwgPSBnLmFsbDtcclxuICAgICAgZGVsZXRlIGcuYWxsO1xyXG4gICAgICBkZWxldGUgZy50b3A7XHJcbiAgICAgIGRlbGV0ZSBnLm9yZGVyO1xyXG4gICAgICBkZWxldGUgZy5vcmRlck5hdHVyYWw7XHJcbiAgICAgIGRlbGV0ZSBnLnNpemU7XHJcbiAgICAgIGcudmFsdWUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGFsbCgpWzBdLnZhbHVlOyB9O1xyXG4gICAgICByZXR1cm4gZztcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZW1vdmVzIHRoaXMgZGltZW5zaW9uIGFuZCBhc3NvY2lhdGVkIGdyb3VwcyBhbmQgZXZlbnQgbGlzdGVuZXJzLlxyXG4gICAgZnVuY3Rpb24gZGlzcG9zZSgpIHtcclxuICAgICAgZGltZW5zaW9uR3JvdXBzLmZvckVhY2goZnVuY3Rpb24oZ3JvdXApIHsgZ3JvdXAuZGlzcG9zZSgpOyB9KTtcclxuICAgICAgdmFyIGkgPSBkYXRhTGlzdGVuZXJzLmluZGV4T2YocHJlQWRkKTtcclxuICAgICAgaWYgKGkgPj0gMCkgZGF0YUxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgIGkgPSBkYXRhTGlzdGVuZXJzLmluZGV4T2YocG9zdEFkZCk7XHJcbiAgICAgIGlmIChpID49IDApIGRhdGFMaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICBpID0gcmVtb3ZlRGF0YUxpc3RlbmVycy5pbmRleE9mKHJlbW92ZURhdGEpO1xyXG4gICAgICBpZiAoaSA+PSAwKSByZW1vdmVEYXRhTGlzdGVuZXJzLnNwbGljZShpLCAxKTtcclxuICAgICAgbSAmPSB6ZXJvO1xyXG4gICAgICByZXR1cm4gZmlsdGVyQWxsKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGRpbWVuc2lvbjtcclxuICB9XHJcblxyXG4gIC8vIEEgY29udmVuaWVuY2UgbWV0aG9kIGZvciBncm91cEFsbCBvbiBhIGR1bW15IGRpbWVuc2lvbi5cclxuICAvLyBUaGlzIGltcGxlbWVudGF0aW9uIGNhbiBiZSBvcHRpbWl6ZWQgc2luY2UgaXQgYWx3YXlzIGhhcyBjYXJkaW5hbGl0eSAxLlxyXG4gIGZ1bmN0aW9uIGdyb3VwQWxsKCkge1xyXG4gICAgdmFyIGdyb3VwID0ge1xyXG4gICAgICByZWR1Y2U6IHJlZHVjZSxcclxuICAgICAgcmVkdWNlQ291bnQ6IHJlZHVjZUNvdW50LFxyXG4gICAgICByZWR1Y2VTdW06IHJlZHVjZVN1bSxcclxuICAgICAgdmFsdWU6IHZhbHVlLFxyXG4gICAgICBkaXNwb3NlOiBkaXNwb3NlLFxyXG4gICAgICByZW1vdmU6IGRpc3Bvc2UgLy8gZm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciByZWR1Y2VWYWx1ZSxcclxuICAgICAgICByZWR1Y2VBZGQsXHJcbiAgICAgICAgcmVkdWNlUmVtb3ZlLFxyXG4gICAgICAgIHJlZHVjZUluaXRpYWwsXHJcbiAgICAgICAgcmVzZXROZWVkZWQgPSB0cnVlO1xyXG5cclxuICAgIC8vIFRoZSBncm91cCBsaXN0ZW5zIHRvIHRoZSBjcm9zc2ZpbHRlciBmb3Igd2hlbiBhbnkgZGltZW5zaW9uIGNoYW5nZXMsIHNvXHJcbiAgICAvLyB0aGF0IGl0IGNhbiB1cGRhdGUgdGhlIHJlZHVjZSB2YWx1ZS4gSXQgbXVzdCBhbHNvIGxpc3RlbiB0byB0aGUgcGFyZW50XHJcbiAgICAvLyBkaW1lbnNpb24gZm9yIHdoZW4gZGF0YSBpcyBhZGRlZC5cclxuICAgIGZpbHRlckxpc3RlbmVycy5wdXNoKHVwZGF0ZSk7XHJcbiAgICBkYXRhTGlzdGVuZXJzLnB1c2goYWRkKTtcclxuXHJcbiAgICAvLyBGb3IgY29uc2lzdGVuY3k7IGFjdHVhbGx5IGEgbm8tb3Agc2luY2UgcmVzZXROZWVkZWQgaXMgdHJ1ZS5cclxuICAgIGFkZChkYXRhLCAwLCBuKTtcclxuXHJcbiAgICAvLyBJbmNvcnBvcmF0ZXMgdGhlIHNwZWNpZmllZCBuZXcgdmFsdWVzIGludG8gdGhpcyBncm91cC5cclxuICAgIGZ1bmN0aW9uIGFkZChuZXdEYXRhLCBuMCkge1xyXG4gICAgICB2YXIgaTtcclxuXHJcbiAgICAgIGlmIChyZXNldE5lZWRlZCkgcmV0dXJuO1xyXG5cclxuICAgICAgLy8gQWRkIHRoZSBhZGRlZCB2YWx1ZXMuXHJcbiAgICAgIGZvciAoaSA9IG4wOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgICAgaWYgKCFmaWx0ZXJzW2ldKSB7XHJcbiAgICAgICAgICByZWR1Y2VWYWx1ZSA9IHJlZHVjZUFkZChyZWR1Y2VWYWx1ZSwgZGF0YVtpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVkdWNlcyB0aGUgc3BlY2lmaWVkIHNlbGVjdGVkIG9yIGRlc2VsZWN0ZWQgcmVjb3Jkcy5cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZShmaWx0ZXJPbmUsIGFkZGVkLCByZW1vdmVkKSB7XHJcbiAgICAgIHZhciBpLFxyXG4gICAgICAgICAgayxcclxuICAgICAgICAgIG47XHJcblxyXG4gICAgICBpZiAocmVzZXROZWVkZWQpIHJldHVybjtcclxuXHJcbiAgICAgIC8vIEFkZCB0aGUgYWRkZWQgdmFsdWVzLlxyXG4gICAgICBmb3IgKGkgPSAwLCBuID0gYWRkZWQubGVuZ3RoOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgICAgaWYgKCFmaWx0ZXJzW2sgPSBhZGRlZFtpXV0pIHtcclxuICAgICAgICAgIHJlZHVjZVZhbHVlID0gcmVkdWNlQWRkKHJlZHVjZVZhbHVlLCBkYXRhW2tdKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFJlbW92ZSB0aGUgcmVtb3ZlZCB2YWx1ZXMuXHJcbiAgICAgIGZvciAoaSA9IDAsIG4gPSByZW1vdmVkLmxlbmd0aDsgaSA8IG47ICsraSkge1xyXG4gICAgICAgIGlmIChmaWx0ZXJzW2sgPSByZW1vdmVkW2ldXSA9PT0gZmlsdGVyT25lKSB7XHJcbiAgICAgICAgICByZWR1Y2VWYWx1ZSA9IHJlZHVjZVJlbW92ZShyZWR1Y2VWYWx1ZSwgZGF0YVtrXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVjb21wdXRlcyB0aGUgZ3JvdXAgcmVkdWNlIHZhbHVlIGZyb20gc2NyYXRjaC5cclxuICAgIGZ1bmN0aW9uIHJlc2V0KCkge1xyXG4gICAgICB2YXIgaTtcclxuXHJcbiAgICAgIHJlZHVjZVZhbHVlID0gcmVkdWNlSW5pdGlhbCgpO1xyXG5cclxuICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xyXG4gICAgICAgIGlmICghZmlsdGVyc1tpXSkge1xyXG4gICAgICAgICAgcmVkdWNlVmFsdWUgPSByZWR1Y2VBZGQocmVkdWNlVmFsdWUsIGRhdGFbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFNldHMgdGhlIHJlZHVjZSBiZWhhdmlvciBmb3IgdGhpcyBncm91cCB0byB1c2UgdGhlIHNwZWNpZmllZCBmdW5jdGlvbnMuXHJcbiAgICAvLyBUaGlzIG1ldGhvZCBsYXppbHkgcmVjb21wdXRlcyB0aGUgcmVkdWNlIHZhbHVlLCB3YWl0aW5nIHVudGlsIG5lZWRlZC5cclxuICAgIGZ1bmN0aW9uIHJlZHVjZShhZGQsIHJlbW92ZSwgaW5pdGlhbCkge1xyXG4gICAgICByZWR1Y2VBZGQgPSBhZGQ7XHJcbiAgICAgIHJlZHVjZVJlbW92ZSA9IHJlbW92ZTtcclxuICAgICAgcmVkdWNlSW5pdGlhbCA9IGluaXRpYWw7XHJcbiAgICAgIHJlc2V0TmVlZGVkID0gdHJ1ZTtcclxuICAgICAgcmV0dXJuIGdyb3VwO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEEgY29udmVuaWVuY2UgbWV0aG9kIGZvciByZWR1Y2luZyBieSBjb3VudC5cclxuICAgIGZ1bmN0aW9uIHJlZHVjZUNvdW50KCkge1xyXG4gICAgICByZXR1cm4gcmVkdWNlKGNyb3NzZmlsdGVyX3JlZHVjZUluY3JlbWVudCwgY3Jvc3NmaWx0ZXJfcmVkdWNlRGVjcmVtZW50LCBjcm9zc2ZpbHRlcl96ZXJvKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBIGNvbnZlbmllbmNlIG1ldGhvZCBmb3IgcmVkdWNpbmcgYnkgc3VtKHZhbHVlKS5cclxuICAgIGZ1bmN0aW9uIHJlZHVjZVN1bSh2YWx1ZSkge1xyXG4gICAgICByZXR1cm4gcmVkdWNlKGNyb3NzZmlsdGVyX3JlZHVjZUFkZCh2YWx1ZSksIGNyb3NzZmlsdGVyX3JlZHVjZVN1YnRyYWN0KHZhbHVlKSwgY3Jvc3NmaWx0ZXJfemVybyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmV0dXJucyB0aGUgY29tcHV0ZWQgcmVkdWNlIHZhbHVlLlxyXG4gICAgZnVuY3Rpb24gdmFsdWUoKSB7XHJcbiAgICAgIGlmIChyZXNldE5lZWRlZCkgcmVzZXQoKSwgcmVzZXROZWVkZWQgPSBmYWxzZTtcclxuICAgICAgcmV0dXJuIHJlZHVjZVZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlbW92ZXMgdGhpcyBncm91cCBhbmQgYXNzb2NpYXRlZCBldmVudCBsaXN0ZW5lcnMuXHJcbiAgICBmdW5jdGlvbiBkaXNwb3NlKCkge1xyXG4gICAgICB2YXIgaSA9IGZpbHRlckxpc3RlbmVycy5pbmRleE9mKHVwZGF0ZSk7XHJcbiAgICAgIGlmIChpID49IDApIGZpbHRlckxpc3RlbmVycy5zcGxpY2UoaSk7XHJcbiAgICAgIGkgPSBkYXRhTGlzdGVuZXJzLmluZGV4T2YoYWRkKTtcclxuICAgICAgaWYgKGkgPj0gMCkgZGF0YUxpc3RlbmVycy5zcGxpY2UoaSk7XHJcbiAgICAgIHJldHVybiBncm91cDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVkdWNlQ291bnQoKTtcclxuICB9XHJcblxyXG4gIC8vIFJldHVybnMgdGhlIG51bWJlciBvZiByZWNvcmRzIGluIHRoaXMgY3Jvc3NmaWx0ZXIsIGlycmVzcGVjdGl2ZSBvZiBhbnkgZmlsdGVycy5cclxuICBmdW5jdGlvbiBzaXplKCkge1xyXG4gICAgcmV0dXJuIG47XHJcbiAgfVxyXG5cclxuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxyXG4gICAgICA/IGFkZChhcmd1bWVudHNbMF0pXHJcbiAgICAgIDogY3Jvc3NmaWx0ZXI7XHJcbn1cclxuXHJcbmNyb3NzZmlsdGVyLnZlcnNpb24gPSBcIjEuMy4xMlwiO1xyXG5mdW5jdGlvbiBjcm9zc2ZpbHRlcl9pZGVudGl0eShkKSB7XHJcbiAgcmV0dXJuIGQ7XHJcbn1cclxuY3Jvc3NmaWx0ZXIucGVybXV0ZSA9IHBlcm11dGU7XHJcblxyXG5mdW5jdGlvbiBwZXJtdXRlKGFycmF5LCBpbmRleCkge1xyXG4gIGZvciAodmFyIGkgPSAwLCBuID0gaW5kZXgubGVuZ3RoLCBjb3B5ID0gbmV3IEFycmF5KG4pOyBpIDwgbjsgKytpKSB7XHJcbiAgICBjb3B5W2ldID0gYXJyYXlbaW5kZXhbaV1dO1xyXG4gIH1cclxuICByZXR1cm4gY29weTtcclxufVxyXG52YXIgYmlzZWN0ID0gY3Jvc3NmaWx0ZXIuYmlzZWN0ID0gYmlzZWN0X2J5KGNyb3NzZmlsdGVyX2lkZW50aXR5KTtcclxuXHJcbmJpc2VjdC5ieSA9IGJpc2VjdF9ieTtcclxuXHJcbmZ1bmN0aW9uIGJpc2VjdF9ieShmKSB7XHJcblxyXG4gIC8vIExvY2F0ZSB0aGUgaW5zZXJ0aW9uIHBvaW50IGZvciB4IGluIGEgdG8gbWFpbnRhaW4gc29ydGVkIG9yZGVyLiBUaGVcclxuICAvLyBhcmd1bWVudHMgbG8gYW5kIGhpIG1heSBiZSB1c2VkIHRvIHNwZWNpZnkgYSBzdWJzZXQgb2YgdGhlIGFycmF5IHdoaWNoXHJcbiAgLy8gc2hvdWxkIGJlIGNvbnNpZGVyZWQ7IGJ5IGRlZmF1bHQgdGhlIGVudGlyZSBhcnJheSBpcyB1c2VkLiBJZiB4IGlzIGFscmVhZHlcclxuICAvLyBwcmVzZW50IGluIGEsIHRoZSBpbnNlcnRpb24gcG9pbnQgd2lsbCBiZSBiZWZvcmUgKHRvIHRoZSBsZWZ0IG9mKSBhbnlcclxuICAvLyBleGlzdGluZyBlbnRyaWVzLiBUaGUgcmV0dXJuIHZhbHVlIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdGhlIGZpcnN0XHJcbiAgLy8gYXJndW1lbnQgdG8gYGFycmF5LnNwbGljZWAgYXNzdW1pbmcgdGhhdCBhIGlzIGFscmVhZHkgc29ydGVkLlxyXG4gIC8vXHJcbiAgLy8gVGhlIHJldHVybmVkIGluc2VydGlvbiBwb2ludCBpIHBhcnRpdGlvbnMgdGhlIGFycmF5IGEgaW50byB0d28gaGFsdmVzIHNvXHJcbiAgLy8gdGhhdCBhbGwgdiA8IHggZm9yIHYgaW4gYVtsbzppXSBmb3IgdGhlIGxlZnQgc2lkZSBhbmQgYWxsIHYgPj0geCBmb3IgdiBpblxyXG4gIC8vIGFbaTpoaV0gZm9yIHRoZSByaWdodCBzaWRlLlxyXG4gIGZ1bmN0aW9uIGJpc2VjdExlZnQoYSwgeCwgbG8sIGhpKSB7XHJcbiAgICB3aGlsZSAobG8gPCBoaSkge1xyXG4gICAgICB2YXIgbWlkID0gbG8gKyBoaSA+Pj4gMTtcclxuICAgICAgaWYgKGYoYVttaWRdKSA8IHgpIGxvID0gbWlkICsgMTtcclxuICAgICAgZWxzZSBoaSA9IG1pZDtcclxuICAgIH1cclxuICAgIHJldHVybiBsbztcclxuICB9XHJcblxyXG4gIC8vIFNpbWlsYXIgdG8gYmlzZWN0TGVmdCwgYnV0IHJldHVybnMgYW4gaW5zZXJ0aW9uIHBvaW50IHdoaWNoIGNvbWVzIGFmdGVyICh0b1xyXG4gIC8vIHRoZSByaWdodCBvZikgYW55IGV4aXN0aW5nIGVudHJpZXMgb2YgeCBpbiBhLlxyXG4gIC8vXHJcbiAgLy8gVGhlIHJldHVybmVkIGluc2VydGlvbiBwb2ludCBpIHBhcnRpdGlvbnMgdGhlIGFycmF5IGludG8gdHdvIGhhbHZlcyBzbyB0aGF0XHJcbiAgLy8gYWxsIHYgPD0geCBmb3IgdiBpbiBhW2xvOmldIGZvciB0aGUgbGVmdCBzaWRlIGFuZCBhbGwgdiA+IHggZm9yIHYgaW5cclxuICAvLyBhW2k6aGldIGZvciB0aGUgcmlnaHQgc2lkZS5cclxuICBmdW5jdGlvbiBiaXNlY3RSaWdodChhLCB4LCBsbywgaGkpIHtcclxuICAgIHdoaWxlIChsbyA8IGhpKSB7XHJcbiAgICAgIHZhciBtaWQgPSBsbyArIGhpID4+PiAxO1xyXG4gICAgICBpZiAoeCA8IGYoYVttaWRdKSkgaGkgPSBtaWQ7XHJcbiAgICAgIGVsc2UgbG8gPSBtaWQgKyAxO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxvO1xyXG4gIH1cclxuXHJcbiAgYmlzZWN0UmlnaHQucmlnaHQgPSBiaXNlY3RSaWdodDtcclxuICBiaXNlY3RSaWdodC5sZWZ0ID0gYmlzZWN0TGVmdDtcclxuICByZXR1cm4gYmlzZWN0UmlnaHQ7XHJcbn1cclxudmFyIGhlYXAgPSBjcm9zc2ZpbHRlci5oZWFwID0gaGVhcF9ieShjcm9zc2ZpbHRlcl9pZGVudGl0eSk7XHJcblxyXG5oZWFwLmJ5ID0gaGVhcF9ieTtcclxuXHJcbmZ1bmN0aW9uIGhlYXBfYnkoZikge1xyXG5cclxuICAvLyBCdWlsZHMgYSBiaW5hcnkgaGVhcCB3aXRoaW4gdGhlIHNwZWNpZmllZCBhcnJheSBhW2xvOmhpXS4gVGhlIGhlYXAgaGFzIHRoZVxyXG4gIC8vIHByb3BlcnR5IHN1Y2ggdGhhdCB0aGUgcGFyZW50IGFbbG8raV0gaXMgYWx3YXlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byBpdHNcclxuICAvLyB0d28gY2hpbGRyZW46IGFbbG8rMippKzFdIGFuZCBhW2xvKzIqaSsyXS5cclxuICBmdW5jdGlvbiBoZWFwKGEsIGxvLCBoaSkge1xyXG4gICAgdmFyIG4gPSBoaSAtIGxvLFxyXG4gICAgICAgIGkgPSAobiA+Pj4gMSkgKyAxO1xyXG4gICAgd2hpbGUgKC0taSA+IDApIHNpZnQoYSwgaSwgbiwgbG8pO1xyXG4gICAgcmV0dXJuIGE7XHJcbiAgfVxyXG5cclxuICAvLyBTb3J0cyB0aGUgc3BlY2lmaWVkIGFycmF5IGFbbG86aGldIGluIGRlc2NlbmRpbmcgb3JkZXIsIGFzc3VtaW5nIGl0IGlzXHJcbiAgLy8gYWxyZWFkeSBhIGhlYXAuXHJcbiAgZnVuY3Rpb24gc29ydChhLCBsbywgaGkpIHtcclxuICAgIHZhciBuID0gaGkgLSBsbyxcclxuICAgICAgICB0O1xyXG4gICAgd2hpbGUgKC0tbiA+IDApIHQgPSBhW2xvXSwgYVtsb10gPSBhW2xvICsgbl0sIGFbbG8gKyBuXSA9IHQsIHNpZnQoYSwgMSwgbiwgbG8pO1xyXG4gICAgcmV0dXJuIGE7XHJcbiAgfVxyXG5cclxuICAvLyBTaWZ0cyB0aGUgZWxlbWVudCBhW2xvK2ktMV0gZG93biB0aGUgaGVhcCwgd2hlcmUgdGhlIGhlYXAgaXMgdGhlIGNvbnRpZ3VvdXNcclxuICAvLyBzbGljZSBvZiBhcnJheSBhW2xvOmxvK25dLiBUaGlzIG1ldGhvZCBjYW4gYWxzbyBiZSB1c2VkIHRvIHVwZGF0ZSB0aGUgaGVhcFxyXG4gIC8vIGluY3JlbWVudGFsbHksIHdpdGhvdXQgaW5jdXJyaW5nIHRoZSBmdWxsIGNvc3Qgb2YgcmVjb25zdHJ1Y3RpbmcgdGhlIGhlYXAuXHJcbiAgZnVuY3Rpb24gc2lmdChhLCBpLCBuLCBsbykge1xyXG4gICAgdmFyIGQgPSBhWy0tbG8gKyBpXSxcclxuICAgICAgICB4ID0gZihkKSxcclxuICAgICAgICBjaGlsZDtcclxuICAgIHdoaWxlICgoY2hpbGQgPSBpIDw8IDEpIDw9IG4pIHtcclxuICAgICAgaWYgKGNoaWxkIDwgbiAmJiBmKGFbbG8gKyBjaGlsZF0pID4gZihhW2xvICsgY2hpbGQgKyAxXSkpIGNoaWxkKys7XHJcbiAgICAgIGlmICh4IDw9IGYoYVtsbyArIGNoaWxkXSkpIGJyZWFrO1xyXG4gICAgICBhW2xvICsgaV0gPSBhW2xvICsgY2hpbGRdO1xyXG4gICAgICBpID0gY2hpbGQ7XHJcbiAgICB9XHJcbiAgICBhW2xvICsgaV0gPSBkO1xyXG4gIH1cclxuXHJcbiAgaGVhcC5zb3J0ID0gc29ydDtcclxuICByZXR1cm4gaGVhcDtcclxufVxyXG52YXIgaGVhcHNlbGVjdCA9IGNyb3NzZmlsdGVyLmhlYXBzZWxlY3QgPSBoZWFwc2VsZWN0X2J5KGNyb3NzZmlsdGVyX2lkZW50aXR5KTtcclxuXHJcbmhlYXBzZWxlY3QuYnkgPSBoZWFwc2VsZWN0X2J5O1xyXG5cclxuZnVuY3Rpb24gaGVhcHNlbGVjdF9ieShmKSB7XHJcbiAgdmFyIGhlYXAgPSBoZWFwX2J5KGYpO1xyXG5cclxuICAvLyBSZXR1cm5zIGEgbmV3IGFycmF5IGNvbnRhaW5pbmcgdGhlIHRvcCBrIGVsZW1lbnRzIGluIHRoZSBhcnJheSBhW2xvOmhpXS5cclxuICAvLyBUaGUgcmV0dXJuZWQgYXJyYXkgaXMgbm90IHNvcnRlZCwgYnV0IG1haW50YWlucyB0aGUgaGVhcCBwcm9wZXJ0eS4gSWYgayBpc1xyXG4gIC8vIGdyZWF0ZXIgdGhhbiBoaSAtIGxvLCB0aGVuIGZld2VyIHRoYW4gayBlbGVtZW50cyB3aWxsIGJlIHJldHVybmVkLiBUaGVcclxuICAvLyBvcmRlciBvZiBlbGVtZW50cyBpbiBhIGlzIHVuY2hhbmdlZCBieSB0aGlzIG9wZXJhdGlvbi5cclxuICBmdW5jdGlvbiBoZWFwc2VsZWN0KGEsIGxvLCBoaSwgaykge1xyXG4gICAgdmFyIHF1ZXVlID0gbmV3IEFycmF5KGsgPSBNYXRoLm1pbihoaSAtIGxvLCBrKSksXHJcbiAgICAgICAgbWluLFxyXG4gICAgICAgIGksXHJcbiAgICAgICAgeCxcclxuICAgICAgICBkO1xyXG5cclxuICAgIGZvciAoaSA9IDA7IGkgPCBrOyArK2kpIHF1ZXVlW2ldID0gYVtsbysrXTtcclxuICAgIGhlYXAocXVldWUsIDAsIGspO1xyXG5cclxuICAgIGlmIChsbyA8IGhpKSB7XHJcbiAgICAgIG1pbiA9IGYocXVldWVbMF0pO1xyXG4gICAgICBkbyB7XHJcbiAgICAgICAgaWYgKHggPSBmKGQgPSBhW2xvXSkgPiBtaW4pIHtcclxuICAgICAgICAgIHF1ZXVlWzBdID0gZDtcclxuICAgICAgICAgIG1pbiA9IGYoaGVhcChxdWV1ZSwgMCwgaylbMF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSB3aGlsZSAoKytsbyA8IGhpKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcXVldWU7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gaGVhcHNlbGVjdDtcclxufVxyXG52YXIgaW5zZXJ0aW9uc29ydCA9IGNyb3NzZmlsdGVyLmluc2VydGlvbnNvcnQgPSBpbnNlcnRpb25zb3J0X2J5KGNyb3NzZmlsdGVyX2lkZW50aXR5KTtcclxuXHJcbmluc2VydGlvbnNvcnQuYnkgPSBpbnNlcnRpb25zb3J0X2J5O1xyXG5cclxuZnVuY3Rpb24gaW5zZXJ0aW9uc29ydF9ieShmKSB7XHJcblxyXG4gIGZ1bmN0aW9uIGluc2VydGlvbnNvcnQoYSwgbG8sIGhpKSB7XHJcbiAgICBmb3IgKHZhciBpID0gbG8gKyAxOyBpIDwgaGk7ICsraSkge1xyXG4gICAgICBmb3IgKHZhciBqID0gaSwgdCA9IGFbaV0sIHggPSBmKHQpOyBqID4gbG8gJiYgZihhW2ogLSAxXSkgPiB4OyAtLWopIHtcclxuICAgICAgICBhW2pdID0gYVtqIC0gMV07XHJcbiAgICAgIH1cclxuICAgICAgYVtqXSA9IHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYTtcclxuICB9XHJcblxyXG4gIHJldHVybiBpbnNlcnRpb25zb3J0O1xyXG59XHJcbi8vIEFsZ29yaXRobSBkZXNpZ25lZCBieSBWbGFkaW1pciBZYXJvc2xhdnNraXkuXHJcbi8vIEltcGxlbWVudGF0aW9uIGJhc2VkIG9uIHRoZSBEYXJ0IHByb2plY3Q7IHNlZSBsaWIvZGFydC9MSUNFTlNFIGZvciBkZXRhaWxzLlxyXG5cclxudmFyIHF1aWNrc29ydCA9IGNyb3NzZmlsdGVyLnF1aWNrc29ydCA9IHF1aWNrc29ydF9ieShjcm9zc2ZpbHRlcl9pZGVudGl0eSk7XHJcblxyXG5xdWlja3NvcnQuYnkgPSBxdWlja3NvcnRfYnk7XHJcblxyXG5mdW5jdGlvbiBxdWlja3NvcnRfYnkoZikge1xyXG4gIHZhciBpbnNlcnRpb25zb3J0ID0gaW5zZXJ0aW9uc29ydF9ieShmKTtcclxuXHJcbiAgZnVuY3Rpb24gc29ydChhLCBsbywgaGkpIHtcclxuICAgIHJldHVybiAoaGkgLSBsbyA8IHF1aWNrc29ydF9zaXplVGhyZXNob2xkXHJcbiAgICAgICAgPyBpbnNlcnRpb25zb3J0XHJcbiAgICAgICAgOiBxdWlja3NvcnQpKGEsIGxvLCBoaSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBxdWlja3NvcnQoYSwgbG8sIGhpKSB7XHJcbiAgICAvLyBDb21wdXRlIHRoZSB0d28gcGl2b3RzIGJ5IGxvb2tpbmcgYXQgNSBlbGVtZW50cy5cclxuICAgIHZhciBzaXh0aCA9IChoaSAtIGxvKSAvIDYgfCAwLFxyXG4gICAgICAgIGkxID0gbG8gKyBzaXh0aCxcclxuICAgICAgICBpNSA9IGhpIC0gMSAtIHNpeHRoLFxyXG4gICAgICAgIGkzID0gbG8gKyBoaSAtIDEgPj4gMSwgIC8vIFRoZSBtaWRwb2ludC5cclxuICAgICAgICBpMiA9IGkzIC0gc2l4dGgsXHJcbiAgICAgICAgaTQgPSBpMyArIHNpeHRoO1xyXG5cclxuICAgIHZhciBlMSA9IGFbaTFdLCB4MSA9IGYoZTEpLFxyXG4gICAgICAgIGUyID0gYVtpMl0sIHgyID0gZihlMiksXHJcbiAgICAgICAgZTMgPSBhW2kzXSwgeDMgPSBmKGUzKSxcclxuICAgICAgICBlNCA9IGFbaTRdLCB4NCA9IGYoZTQpLFxyXG4gICAgICAgIGU1ID0gYVtpNV0sIHg1ID0gZihlNSk7XHJcblxyXG4gICAgdmFyIHQ7XHJcblxyXG4gICAgLy8gU29ydCB0aGUgc2VsZWN0ZWQgNSBlbGVtZW50cyB1c2luZyBhIHNvcnRpbmcgbmV0d29yay5cclxuICAgIGlmICh4MSA+IHgyKSB0ID0gZTEsIGUxID0gZTIsIGUyID0gdCwgdCA9IHgxLCB4MSA9IHgyLCB4MiA9IHQ7XHJcbiAgICBpZiAoeDQgPiB4NSkgdCA9IGU0LCBlNCA9IGU1LCBlNSA9IHQsIHQgPSB4NCwgeDQgPSB4NSwgeDUgPSB0O1xyXG4gICAgaWYgKHgxID4geDMpIHQgPSBlMSwgZTEgPSBlMywgZTMgPSB0LCB0ID0geDEsIHgxID0geDMsIHgzID0gdDtcclxuICAgIGlmICh4MiA+IHgzKSB0ID0gZTIsIGUyID0gZTMsIGUzID0gdCwgdCA9IHgyLCB4MiA9IHgzLCB4MyA9IHQ7XHJcbiAgICBpZiAoeDEgPiB4NCkgdCA9IGUxLCBlMSA9IGU0LCBlNCA9IHQsIHQgPSB4MSwgeDEgPSB4NCwgeDQgPSB0O1xyXG4gICAgaWYgKHgzID4geDQpIHQgPSBlMywgZTMgPSBlNCwgZTQgPSB0LCB0ID0geDMsIHgzID0geDQsIHg0ID0gdDtcclxuICAgIGlmICh4MiA+IHg1KSB0ID0gZTIsIGUyID0gZTUsIGU1ID0gdCwgdCA9IHgyLCB4MiA9IHg1LCB4NSA9IHQ7XHJcbiAgICBpZiAoeDIgPiB4MykgdCA9IGUyLCBlMiA9IGUzLCBlMyA9IHQsIHQgPSB4MiwgeDIgPSB4MywgeDMgPSB0O1xyXG4gICAgaWYgKHg0ID4geDUpIHQgPSBlNCwgZTQgPSBlNSwgZTUgPSB0LCB0ID0geDQsIHg0ID0geDUsIHg1ID0gdDtcclxuXHJcbiAgICB2YXIgcGl2b3QxID0gZTIsIHBpdm90VmFsdWUxID0geDIsXHJcbiAgICAgICAgcGl2b3QyID0gZTQsIHBpdm90VmFsdWUyID0geDQ7XHJcblxyXG4gICAgLy8gZTIgYW5kIGU0IGhhdmUgYmVlbiBzYXZlZCBpbiB0aGUgcGl2b3QgdmFyaWFibGVzLiBUaGV5IHdpbGwgYmUgd3JpdHRlblxyXG4gICAgLy8gYmFjaywgb25jZSB0aGUgcGFydGl0aW9uaW5nIGlzIGZpbmlzaGVkLlxyXG4gICAgYVtpMV0gPSBlMTtcclxuICAgIGFbaTJdID0gYVtsb107XHJcbiAgICBhW2kzXSA9IGUzO1xyXG4gICAgYVtpNF0gPSBhW2hpIC0gMV07XHJcbiAgICBhW2k1XSA9IGU1O1xyXG5cclxuICAgIHZhciBsZXNzID0gbG8gKyAxLCAgIC8vIEZpcnN0IGVsZW1lbnQgaW4gdGhlIG1pZGRsZSBwYXJ0aXRpb24uXHJcbiAgICAgICAgZ3JlYXQgPSBoaSAtIDI7ICAvLyBMYXN0IGVsZW1lbnQgaW4gdGhlIG1pZGRsZSBwYXJ0aXRpb24uXHJcblxyXG4gICAgLy8gTm90ZSB0aGF0IGZvciB2YWx1ZSBjb21wYXJpc29uLCA8LCA8PSwgPj0gYW5kID4gY29lcmNlIHRvIGEgcHJpbWl0aXZlIHZpYVxyXG4gICAgLy8gT2JqZWN0LnByb3RvdHlwZS52YWx1ZU9mOyA9PSBhbmQgPT09IGRvIG5vdCwgc28gaW4gb3JkZXIgdG8gYmUgY29uc2lzdGVudFxyXG4gICAgLy8gd2l0aCBuYXR1cmFsIG9yZGVyIChzdWNoIGFzIGZvciBEYXRlIG9iamVjdHMpLCB3ZSBtdXN0IGRvIHR3byBjb21wYXJlcy5cclxuICAgIHZhciBwaXZvdHNFcXVhbCA9IHBpdm90VmFsdWUxIDw9IHBpdm90VmFsdWUyICYmIHBpdm90VmFsdWUxID49IHBpdm90VmFsdWUyO1xyXG4gICAgaWYgKHBpdm90c0VxdWFsKSB7XHJcblxyXG4gICAgICAvLyBEZWdlbmVyYXRlZCBjYXNlIHdoZXJlIHRoZSBwYXJ0aXRpb25pbmcgYmVjb21lcyBhIGR1dGNoIG5hdGlvbmFsIGZsYWdcclxuICAgICAgLy8gcHJvYmxlbS5cclxuICAgICAgLy9cclxuICAgICAgLy8gWyB8ICA8IHBpdm90ICB8ID09IHBpdm90IHwgdW5wYXJ0aXRpb25lZCB8ID4gcGl2b3QgIHwgXVxyXG4gICAgICAvLyAgXiAgICAgICAgICAgICBeICAgICAgICAgIF4gICAgICAgICAgICAgXiAgICAgICAgICAgIF5cclxuICAgICAgLy8gbGVmdCAgICAgICAgIGxlc3MgICAgICAgICBrICAgICAgICAgICBncmVhdCAgICAgICAgIHJpZ2h0XHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIGFbbGVmdF0gYW5kIGFbcmlnaHRdIGFyZSB1bmRlZmluZWQgYW5kIGFyZSBmaWxsZWQgYWZ0ZXIgdGhlXHJcbiAgICAgIC8vIHBhcnRpdGlvbmluZy5cclxuICAgICAgLy9cclxuICAgICAgLy8gSW52YXJpYW50czpcclxuICAgICAgLy8gICAxKSBmb3IgeCBpbiBdbGVmdCwgbGVzc1sgOiB4IDwgcGl2b3QuXHJcbiAgICAgIC8vICAgMikgZm9yIHggaW4gW2xlc3MsIGtbIDogeCA9PSBwaXZvdC5cclxuICAgICAgLy8gICAzKSBmb3IgeCBpbiBdZ3JlYXQsIHJpZ2h0WyA6IHggPiBwaXZvdC5cclxuICAgICAgZm9yICh2YXIgayA9IGxlc3M7IGsgPD0gZ3JlYXQ7ICsraykge1xyXG4gICAgICAgIHZhciBlayA9IGFba10sIHhrID0gZihlayk7XHJcbiAgICAgICAgaWYgKHhrIDwgcGl2b3RWYWx1ZTEpIHtcclxuICAgICAgICAgIGlmIChrICE9PSBsZXNzKSB7XHJcbiAgICAgICAgICAgIGFba10gPSBhW2xlc3NdO1xyXG4gICAgICAgICAgICBhW2xlc3NdID0gZWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICArK2xlc3M7XHJcbiAgICAgICAgfSBlbHNlIGlmICh4ayA+IHBpdm90VmFsdWUxKSB7XHJcblxyXG4gICAgICAgICAgLy8gRmluZCB0aGUgZmlyc3QgZWxlbWVudCA8PSBwaXZvdCBpbiB0aGUgcmFuZ2UgW2sgLSAxLCBncmVhdF0gYW5kXHJcbiAgICAgICAgICAvLyBwdXQgWzplazpdIHRoZXJlLiBXZSBrbm93IHRoYXQgc3VjaCBhbiBlbGVtZW50IG11c3QgZXhpc3Q6XHJcbiAgICAgICAgICAvLyBXaGVuIGsgPT0gbGVzcywgdGhlbiBlbDMgKHdoaWNoIGlzIGVxdWFsIHRvIHBpdm90KSBsaWVzIGluIHRoZVxyXG4gICAgICAgICAgLy8gaW50ZXJ2YWwuIE90aGVyd2lzZSBhW2sgLSAxXSA9PSBwaXZvdCBhbmQgdGhlIHNlYXJjaCBzdG9wcyBhdCBrLTEuXHJcbiAgICAgICAgICAvLyBOb3RlIHRoYXQgaW4gdGhlIGxhdHRlciBjYXNlIGludmFyaWFudCAyIHdpbGwgYmUgdmlvbGF0ZWQgZm9yIGFcclxuICAgICAgICAgIC8vIHNob3J0IGFtb3VudCBvZiB0aW1lLiBUaGUgaW52YXJpYW50IHdpbGwgYmUgcmVzdG9yZWQgd2hlbiB0aGVcclxuICAgICAgICAgIC8vIHBpdm90cyBhcmUgcHV0IGludG8gdGhlaXIgZmluYWwgcG9zaXRpb25zLlxyXG4gICAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgdmFyIGdyZWF0VmFsdWUgPSBmKGFbZ3JlYXRdKTtcclxuICAgICAgICAgICAgaWYgKGdyZWF0VmFsdWUgPiBwaXZvdFZhbHVlMSkge1xyXG4gICAgICAgICAgICAgIGdyZWF0LS07XHJcbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgb25seSBsb2NhdGlvbiBpbiB0aGUgd2hpbGUtbG9vcCB3aGVyZSBhIG5ld1xyXG4gICAgICAgICAgICAgIC8vIGl0ZXJhdGlvbiBpcyBzdGFydGVkLlxyXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGdyZWF0VmFsdWUgPCBwaXZvdFZhbHVlMSkge1xyXG4gICAgICAgICAgICAgIC8vIFRyaXBsZSBleGNoYW5nZS5cclxuICAgICAgICAgICAgICBhW2tdID0gYVtsZXNzXTtcclxuICAgICAgICAgICAgICBhW2xlc3MrK10gPSBhW2dyZWF0XTtcclxuICAgICAgICAgICAgICBhW2dyZWF0LS1dID0gZWs7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgYVtrXSA9IGFbZ3JlYXRdO1xyXG4gICAgICAgICAgICAgIGFbZ3JlYXQtLV0gPSBlaztcclxuICAgICAgICAgICAgICAvLyBOb3RlOiBpZiBncmVhdCA8IGsgdGhlbiB3ZSB3aWxsIGV4aXQgdGhlIG91dGVyIGxvb3AgYW5kIGZpeFxyXG4gICAgICAgICAgICAgIC8vIGludmFyaWFudCAyICh3aGljaCB3ZSBqdXN0IHZpb2xhdGVkKS5cclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuXHJcbiAgICAgIC8vIFdlIHBhcnRpdGlvbiB0aGUgbGlzdCBpbnRvIHRocmVlIHBhcnRzOlxyXG4gICAgICAvLyAgMS4gPCBwaXZvdDFcclxuICAgICAgLy8gIDIuID49IHBpdm90MSAmJiA8PSBwaXZvdDJcclxuICAgICAgLy8gIDMuID4gcGl2b3QyXHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIER1cmluZyB0aGUgbG9vcCB3ZSBoYXZlOlxyXG4gICAgICAvLyBbIHwgPCBwaXZvdDEgfCA+PSBwaXZvdDEgJiYgPD0gcGl2b3QyIHwgdW5wYXJ0aXRpb25lZCAgfCA+IHBpdm90MiAgfCBdXHJcbiAgICAgIC8vICBeICAgICAgICAgICAgXiAgICAgICAgICAgICAgICAgICAgICAgIF4gICAgICAgICAgICAgIF4gICAgICAgICAgICAgXlxyXG4gICAgICAvLyBsZWZ0ICAgICAgICAgbGVzcyAgICAgICAgICAgICAgICAgICAgIGsgICAgICAgICAgICAgIGdyZWF0ICAgICAgICByaWdodFxyXG4gICAgICAvL1xyXG4gICAgICAvLyBhW2xlZnRdIGFuZCBhW3JpZ2h0XSBhcmUgdW5kZWZpbmVkIGFuZCBhcmUgZmlsbGVkIGFmdGVyIHRoZVxyXG4gICAgICAvLyBwYXJ0aXRpb25pbmcuXHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIEludmFyaWFudHM6XHJcbiAgICAgIC8vICAgMS4gZm9yIHggaW4gXWxlZnQsIGxlc3NbIDogeCA8IHBpdm90MVxyXG4gICAgICAvLyAgIDIuIGZvciB4IGluIFtsZXNzLCBrWyA6IHBpdm90MSA8PSB4ICYmIHggPD0gcGl2b3QyXHJcbiAgICAgIC8vICAgMy4gZm9yIHggaW4gXWdyZWF0LCByaWdodFsgOiB4ID4gcGl2b3QyXHJcbiAgICAgIGZvciAodmFyIGsgPSBsZXNzOyBrIDw9IGdyZWF0OyBrKyspIHtcclxuICAgICAgICB2YXIgZWsgPSBhW2tdLCB4ayA9IGYoZWspO1xyXG4gICAgICAgIGlmICh4ayA8IHBpdm90VmFsdWUxKSB7XHJcbiAgICAgICAgICBpZiAoayAhPT0gbGVzcykge1xyXG4gICAgICAgICAgICBhW2tdID0gYVtsZXNzXTtcclxuICAgICAgICAgICAgYVtsZXNzXSA9IGVrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgKytsZXNzO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpZiAoeGsgPiBwaXZvdFZhbHVlMikge1xyXG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgIHZhciBncmVhdFZhbHVlID0gZihhW2dyZWF0XSk7XHJcbiAgICAgICAgICAgICAgaWYgKGdyZWF0VmFsdWUgPiBwaXZvdFZhbHVlMikge1xyXG4gICAgICAgICAgICAgICAgZ3JlYXQtLTtcclxuICAgICAgICAgICAgICAgIGlmIChncmVhdCA8IGspIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgb25seSBsb2NhdGlvbiBpbnNpZGUgdGhlIGxvb3Agd2hlcmUgYSBuZXdcclxuICAgICAgICAgICAgICAgIC8vIGl0ZXJhdGlvbiBpcyBzdGFydGVkLlxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGFbZ3JlYXRdIDw9IHBpdm90Mi5cclxuICAgICAgICAgICAgICAgIGlmIChncmVhdFZhbHVlIDwgcGl2b3RWYWx1ZTEpIHtcclxuICAgICAgICAgICAgICAgICAgLy8gVHJpcGxlIGV4Y2hhbmdlLlxyXG4gICAgICAgICAgICAgICAgICBhW2tdID0gYVtsZXNzXTtcclxuICAgICAgICAgICAgICAgICAgYVtsZXNzKytdID0gYVtncmVhdF07XHJcbiAgICAgICAgICAgICAgICAgIGFbZ3JlYXQtLV0gPSBlaztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIC8vIGFbZ3JlYXRdID49IHBpdm90MS5cclxuICAgICAgICAgICAgICAgICAgYVtrXSA9IGFbZ3JlYXRdO1xyXG4gICAgICAgICAgICAgICAgICBhW2dyZWF0LS1dID0gZWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBNb3ZlIHBpdm90cyBpbnRvIHRoZWlyIGZpbmFsIHBvc2l0aW9ucy5cclxuICAgIC8vIFdlIHNocnVuayB0aGUgbGlzdCBmcm9tIGJvdGggc2lkZXMgKGFbbGVmdF0gYW5kIGFbcmlnaHRdIGhhdmVcclxuICAgIC8vIG1lYW5pbmdsZXNzIHZhbHVlcyBpbiB0aGVtKSBhbmQgbm93IHdlIG1vdmUgZWxlbWVudHMgZnJvbSB0aGUgZmlyc3RcclxuICAgIC8vIGFuZCB0aGlyZCBwYXJ0aXRpb24gaW50byB0aGVzZSBsb2NhdGlvbnMgc28gdGhhdCB3ZSBjYW4gc3RvcmUgdGhlXHJcbiAgICAvLyBwaXZvdHMuXHJcbiAgICBhW2xvXSA9IGFbbGVzcyAtIDFdO1xyXG4gICAgYVtsZXNzIC0gMV0gPSBwaXZvdDE7XHJcbiAgICBhW2hpIC0gMV0gPSBhW2dyZWF0ICsgMV07XHJcbiAgICBhW2dyZWF0ICsgMV0gPSBwaXZvdDI7XHJcblxyXG4gICAgLy8gVGhlIGxpc3QgaXMgbm93IHBhcnRpdGlvbmVkIGludG8gdGhyZWUgcGFydGl0aW9uczpcclxuICAgIC8vIFsgPCBwaXZvdDEgICB8ID49IHBpdm90MSAmJiA8PSBwaXZvdDIgICB8ICA+IHBpdm90MiAgIF1cclxuICAgIC8vICBeICAgICAgICAgICAgXiAgICAgICAgICAgICAgICAgICAgICAgIF4gICAgICAgICAgICAgXlxyXG4gICAgLy8gbGVmdCAgICAgICAgIGxlc3MgICAgICAgICAgICAgICAgICAgICBncmVhdCAgICAgICAgcmlnaHRcclxuXHJcbiAgICAvLyBSZWN1cnNpdmUgZGVzY2VudC4gKERvbid0IGluY2x1ZGUgdGhlIHBpdm90IHZhbHVlcy4pXHJcbiAgICBzb3J0KGEsIGxvLCBsZXNzIC0gMSk7XHJcbiAgICBzb3J0KGEsIGdyZWF0ICsgMiwgaGkpO1xyXG5cclxuICAgIGlmIChwaXZvdHNFcXVhbCkge1xyXG4gICAgICAvLyBBbGwgZWxlbWVudHMgaW4gdGhlIHNlY29uZCBwYXJ0aXRpb24gYXJlIGVxdWFsIHRvIHRoZSBwaXZvdC4gTm9cclxuICAgICAgLy8gbmVlZCB0byBzb3J0IHRoZW0uXHJcbiAgICAgIHJldHVybiBhO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEluIHRoZW9yeSBpdCBzaG91bGQgYmUgZW5vdWdoIHRvIGNhbGwgX2RvU29ydCByZWN1cnNpdmVseSBvbiB0aGUgc2Vjb25kXHJcbiAgICAvLyBwYXJ0aXRpb24uXHJcbiAgICAvLyBUaGUgQW5kcm9pZCBzb3VyY2UgaG93ZXZlciByZW1vdmVzIHRoZSBwaXZvdCBlbGVtZW50cyBmcm9tIHRoZSByZWN1cnNpdmVcclxuICAgIC8vIGNhbGwgaWYgdGhlIHNlY29uZCBwYXJ0aXRpb24gaXMgdG9vIGxhcmdlIChtb3JlIHRoYW4gMi8zIG9mIHRoZSBsaXN0KS5cclxuICAgIGlmIChsZXNzIDwgaTEgJiYgZ3JlYXQgPiBpNSkge1xyXG4gICAgICB2YXIgbGVzc1ZhbHVlLCBncmVhdFZhbHVlO1xyXG4gICAgICB3aGlsZSAoKGxlc3NWYWx1ZSA9IGYoYVtsZXNzXSkpIDw9IHBpdm90VmFsdWUxICYmIGxlc3NWYWx1ZSA+PSBwaXZvdFZhbHVlMSkgKytsZXNzO1xyXG4gICAgICB3aGlsZSAoKGdyZWF0VmFsdWUgPSBmKGFbZ3JlYXRdKSkgPD0gcGl2b3RWYWx1ZTIgJiYgZ3JlYXRWYWx1ZSA+PSBwaXZvdFZhbHVlMikgLS1ncmVhdDtcclxuXHJcbiAgICAgIC8vIENvcHkgcGFzdGUgb2YgdGhlIHByZXZpb3VzIDMtd2F5IHBhcnRpdGlvbmluZyB3aXRoIGFkYXB0aW9ucy5cclxuICAgICAgLy9cclxuICAgICAgLy8gV2UgcGFydGl0aW9uIHRoZSBsaXN0IGludG8gdGhyZWUgcGFydHM6XHJcbiAgICAgIC8vICAxLiA9PSBwaXZvdDFcclxuICAgICAgLy8gIDIuID4gcGl2b3QxICYmIDwgcGl2b3QyXHJcbiAgICAgIC8vICAzLiA9PSBwaXZvdDJcclxuICAgICAgLy9cclxuICAgICAgLy8gRHVyaW5nIHRoZSBsb29wIHdlIGhhdmU6XHJcbiAgICAgIC8vIFsgPT0gcGl2b3QxIHwgPiBwaXZvdDEgJiYgPCBwaXZvdDIgfCB1bnBhcnRpdGlvbmVkICB8ID09IHBpdm90MiBdXHJcbiAgICAgIC8vICAgICAgICAgICAgICBeICAgICAgICAgICAgICAgICAgICAgIF4gICAgICAgICAgICAgIF5cclxuICAgICAgLy8gICAgICAgICAgICBsZXNzICAgICAgICAgICAgICAgICAgICAgayAgICAgICAgICAgICAgZ3JlYXRcclxuICAgICAgLy9cclxuICAgICAgLy8gSW52YXJpYW50czpcclxuICAgICAgLy8gICAxLiBmb3IgeCBpbiBbICosIGxlc3NbIDogeCA9PSBwaXZvdDFcclxuICAgICAgLy8gICAyLiBmb3IgeCBpbiBbbGVzcywga1sgOiBwaXZvdDEgPCB4ICYmIHggPCBwaXZvdDJcclxuICAgICAgLy8gICAzLiBmb3IgeCBpbiBdZ3JlYXQsICogXSA6IHggPT0gcGl2b3QyXHJcbiAgICAgIGZvciAodmFyIGsgPSBsZXNzOyBrIDw9IGdyZWF0OyBrKyspIHtcclxuICAgICAgICB2YXIgZWsgPSBhW2tdLCB4ayA9IGYoZWspO1xyXG4gICAgICAgIGlmICh4ayA8PSBwaXZvdFZhbHVlMSAmJiB4ayA+PSBwaXZvdFZhbHVlMSkge1xyXG4gICAgICAgICAgaWYgKGsgIT09IGxlc3MpIHtcclxuICAgICAgICAgICAgYVtrXSA9IGFbbGVzc107XHJcbiAgICAgICAgICAgIGFbbGVzc10gPSBlaztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGxlc3MrKztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaWYgKHhrIDw9IHBpdm90VmFsdWUyICYmIHhrID49IHBpdm90VmFsdWUyKSB7XHJcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgdmFyIGdyZWF0VmFsdWUgPSBmKGFbZ3JlYXRdKTtcclxuICAgICAgICAgICAgICBpZiAoZ3JlYXRWYWx1ZSA8PSBwaXZvdFZhbHVlMiAmJiBncmVhdFZhbHVlID49IHBpdm90VmFsdWUyKSB7XHJcbiAgICAgICAgICAgICAgICBncmVhdC0tO1xyXG4gICAgICAgICAgICAgICAgaWYgKGdyZWF0IDwgaykgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBvbmx5IGxvY2F0aW9uIGluc2lkZSB0aGUgbG9vcCB3aGVyZSBhIG5ld1xyXG4gICAgICAgICAgICAgICAgLy8gaXRlcmF0aW9uIGlzIHN0YXJ0ZWQuXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gYVtncmVhdF0gPCBwaXZvdDIuXHJcbiAgICAgICAgICAgICAgICBpZiAoZ3JlYXRWYWx1ZSA8IHBpdm90VmFsdWUxKSB7XHJcbiAgICAgICAgICAgICAgICAgIC8vIFRyaXBsZSBleGNoYW5nZS5cclxuICAgICAgICAgICAgICAgICAgYVtrXSA9IGFbbGVzc107XHJcbiAgICAgICAgICAgICAgICAgIGFbbGVzcysrXSA9IGFbZ3JlYXRdO1xyXG4gICAgICAgICAgICAgICAgICBhW2dyZWF0LS1dID0gZWs7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAvLyBhW2dyZWF0XSA9PSBwaXZvdDEuXHJcbiAgICAgICAgICAgICAgICAgIGFba10gPSBhW2dyZWF0XTtcclxuICAgICAgICAgICAgICAgICAgYVtncmVhdC0tXSA9IGVrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVGhlIHNlY29uZCBwYXJ0aXRpb24gaGFzIG5vdyBiZWVuIGNsZWFyZWQgb2YgcGl2b3QgZWxlbWVudHMgYW5kIGxvb2tzXHJcbiAgICAvLyBhcyBmb2xsb3dzOlxyXG4gICAgLy8gWyAgKiAgfCAgPiBwaXZvdDEgJiYgPCBwaXZvdDIgIHwgKiBdXHJcbiAgICAvLyAgICAgICAgXiAgICAgICAgICAgICAgICAgICAgICBeXHJcbiAgICAvLyAgICAgICBsZXNzICAgICAgICAgICAgICAgICAgZ3JlYXRcclxuICAgIC8vIFNvcnQgdGhlIHNlY29uZCBwYXJ0aXRpb24gdXNpbmcgcmVjdXJzaXZlIGRlc2NlbnQuXHJcblxyXG4gICAgLy8gVGhlIHNlY29uZCBwYXJ0aXRpb24gbG9va3MgYXMgZm9sbG93czpcclxuICAgIC8vIFsgICogIHwgID49IHBpdm90MSAmJiA8PSBwaXZvdDIgIHwgKiBdXHJcbiAgICAvLyAgICAgICAgXiAgICAgICAgICAgICAgICAgICAgICAgIF5cclxuICAgIC8vICAgICAgIGxlc3MgICAgICAgICAgICAgICAgICAgIGdyZWF0XHJcbiAgICAvLyBTaW1wbHkgc29ydCBpdCBieSByZWN1cnNpdmUgZGVzY2VudC5cclxuXHJcbiAgICByZXR1cm4gc29ydChhLCBsZXNzLCBncmVhdCArIDEpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHNvcnQ7XHJcbn1cclxuXHJcbnZhciBxdWlja3NvcnRfc2l6ZVRocmVzaG9sZCA9IDMyO1xyXG52YXIgY3Jvc3NmaWx0ZXJfYXJyYXk4ID0gY3Jvc3NmaWx0ZXJfYXJyYXlVbnR5cGVkLFxyXG4gICAgY3Jvc3NmaWx0ZXJfYXJyYXkxNiA9IGNyb3NzZmlsdGVyX2FycmF5VW50eXBlZCxcclxuICAgIGNyb3NzZmlsdGVyX2FycmF5MzIgPSBjcm9zc2ZpbHRlcl9hcnJheVVudHlwZWQsXHJcbiAgICBjcm9zc2ZpbHRlcl9hcnJheUxlbmd0aGVuID0gY3Jvc3NmaWx0ZXJfYXJyYXlMZW5ndGhlblVudHlwZWQsXHJcbiAgICBjcm9zc2ZpbHRlcl9hcnJheVdpZGVuID0gY3Jvc3NmaWx0ZXJfYXJyYXlXaWRlblVudHlwZWQ7XHJcblxyXG5pZiAodHlwZW9mIFVpbnQ4QXJyYXkgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICBjcm9zc2ZpbHRlcl9hcnJheTggPSBmdW5jdGlvbihuKSB7IHJldHVybiBuZXcgVWludDhBcnJheShuKTsgfTtcclxuICBjcm9zc2ZpbHRlcl9hcnJheTE2ID0gZnVuY3Rpb24obikgeyByZXR1cm4gbmV3IFVpbnQxNkFycmF5KG4pOyB9O1xyXG4gIGNyb3NzZmlsdGVyX2FycmF5MzIgPSBmdW5jdGlvbihuKSB7IHJldHVybiBuZXcgVWludDMyQXJyYXkobik7IH07XHJcblxyXG4gIGNyb3NzZmlsdGVyX2FycmF5TGVuZ3RoZW4gPSBmdW5jdGlvbihhcnJheSwgbGVuZ3RoKSB7XHJcbiAgICBpZiAoYXJyYXkubGVuZ3RoID49IGxlbmd0aCkgcmV0dXJuIGFycmF5O1xyXG4gICAgdmFyIGNvcHkgPSBuZXcgYXJyYXkuY29uc3RydWN0b3IobGVuZ3RoKTtcclxuICAgIGNvcHkuc2V0KGFycmF5KTtcclxuICAgIHJldHVybiBjb3B5O1xyXG4gIH07XHJcblxyXG4gIGNyb3NzZmlsdGVyX2FycmF5V2lkZW4gPSBmdW5jdGlvbihhcnJheSwgd2lkdGgpIHtcclxuICAgIHZhciBjb3B5O1xyXG4gICAgc3dpdGNoICh3aWR0aCkge1xyXG4gICAgICBjYXNlIDE2OiBjb3B5ID0gY3Jvc3NmaWx0ZXJfYXJyYXkxNihhcnJheS5sZW5ndGgpOyBicmVhaztcclxuICAgICAgY2FzZSAzMjogY29weSA9IGNyb3NzZmlsdGVyX2FycmF5MzIoYXJyYXkubGVuZ3RoKTsgYnJlYWs7XHJcbiAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYXJyYXkgd2lkdGghXCIpO1xyXG4gICAgfVxyXG4gICAgY29weS5zZXQoYXJyYXkpO1xyXG4gICAgcmV0dXJuIGNvcHk7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3Jvc3NmaWx0ZXJfYXJyYXlVbnR5cGVkKG4pIHtcclxuICB2YXIgYXJyYXkgPSBuZXcgQXJyYXkobiksIGkgPSAtMTtcclxuICB3aGlsZSAoKytpIDwgbikgYXJyYXlbaV0gPSAwO1xyXG4gIHJldHVybiBhcnJheTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3Jvc3NmaWx0ZXJfYXJyYXlMZW5ndGhlblVudHlwZWQoYXJyYXksIGxlbmd0aCkge1xyXG4gIHZhciBuID0gYXJyYXkubGVuZ3RoO1xyXG4gIHdoaWxlIChuIDwgbGVuZ3RoKSBhcnJheVtuKytdID0gMDtcclxuICByZXR1cm4gYXJyYXk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyb3NzZmlsdGVyX2FycmF5V2lkZW5VbnR5cGVkKGFycmF5LCB3aWR0aCkge1xyXG4gIGlmICh3aWR0aCA+IDMyKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGFycmF5IHdpZHRoIVwiKTtcclxuICByZXR1cm4gYXJyYXk7XHJcbn1cclxuZnVuY3Rpb24gY3Jvc3NmaWx0ZXJfZmlsdGVyRXhhY3QoYmlzZWN0LCB2YWx1ZSkge1xyXG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZXMpIHtcclxuICAgIHZhciBuID0gdmFsdWVzLmxlbmd0aDtcclxuICAgIHJldHVybiBbYmlzZWN0LmxlZnQodmFsdWVzLCB2YWx1ZSwgMCwgbiksIGJpc2VjdC5yaWdodCh2YWx1ZXMsIHZhbHVlLCAwLCBuKV07XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3Jvc3NmaWx0ZXJfZmlsdGVyUmFuZ2UoYmlzZWN0LCByYW5nZSkge1xyXG4gIHZhciBtaW4gPSByYW5nZVswXSxcclxuICAgICAgbWF4ID0gcmFuZ2VbMV07XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlcykge1xyXG4gICAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoO1xyXG4gICAgcmV0dXJuIFtiaXNlY3QubGVmdCh2YWx1ZXMsIG1pbiwgMCwgbiksIGJpc2VjdC5sZWZ0KHZhbHVlcywgbWF4LCAwLCBuKV07XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3Jvc3NmaWx0ZXJfZmlsdGVyQWxsKHZhbHVlcykge1xyXG4gIHJldHVybiBbMCwgdmFsdWVzLmxlbmd0aF07XHJcbn1cclxuZnVuY3Rpb24gY3Jvc3NmaWx0ZXJfbnVsbCgpIHtcclxuICByZXR1cm4gbnVsbDtcclxufVxyXG5mdW5jdGlvbiBjcm9zc2ZpbHRlcl96ZXJvKCkge1xyXG4gIHJldHVybiAwO1xyXG59XHJcbmZ1bmN0aW9uIGNyb3NzZmlsdGVyX3JlZHVjZUluY3JlbWVudChwKSB7XHJcbiAgcmV0dXJuIHAgKyAxO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcm9zc2ZpbHRlcl9yZWR1Y2VEZWNyZW1lbnQocCkge1xyXG4gIHJldHVybiBwIC0gMTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3Jvc3NmaWx0ZXJfcmVkdWNlQWRkKGYpIHtcclxuICByZXR1cm4gZnVuY3Rpb24ocCwgdikge1xyXG4gICAgcmV0dXJuIHAgKyArZih2KTtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcm9zc2ZpbHRlcl9yZWR1Y2VTdWJ0cmFjdChmKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKHAsIHYpIHtcclxuICAgIHJldHVybiBwIC0gZih2KTtcclxuICB9O1xyXG59XHJcblxyXG5cclxuLy8gUmV0dXJucyBhbiBhcnJheSBvZiBzaXplIG4sIGJpZyBlbm91Z2ggdG8gc3RvcmUgaWRzIHVwIHRvIG0uXHJcbmZ1bmN0aW9uIGNyb3NzZmlsdGVyX2luZGV4KG4sIG0pIHtcclxuICByZXR1cm4gKG0gPCAweDEwMVxyXG4gICAgICA/IGNyb3NzZmlsdGVyX2FycmF5OCA6IG0gPCAweDEwMDAxXHJcbiAgICAgID8gY3Jvc3NmaWx0ZXJfYXJyYXkxNlxyXG4gICAgICA6IGNyb3NzZmlsdGVyX2FycmF5MzIpKG4pO1xyXG59XHJcblxyXG4vLyBDb25zdHJ1Y3RzIGEgbmV3IGFycmF5IG9mIHNpemUgbiwgd2l0aCBzZXF1ZW50aWFsIHZhbHVlcyBmcm9tIDAgdG8gbiAtIDEuXHJcbmZ1bmN0aW9uIGNyb3NzZmlsdGVyX3JhbmdlKG4pIHtcclxuICB2YXIgcmFuZ2UgPSBjcm9zc2ZpbHRlcl9pbmRleChuLCBuKTtcclxuICBmb3IgKHZhciBpID0gLTE7ICsraSA8IG47KSByYW5nZVtpXSA9IGk7XHJcbiAgcmV0dXJuIHJhbmdlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcm9zc2ZpbHRlcl9jYXBhY2l0eSh3KSB7XHJcbiAgcmV0dXJuIHcgPT09IDhcclxuICAgICAgPyAweDEwMCA6IHcgPT09IDE2XHJcbiAgICAgID8gMHgxMDAwMFxyXG4gICAgICA6IDB4MTAwMDAwMDAwO1xyXG59XHJcbmV4cG9ydCB7Y3Jvc3NmaWx0ZXJ9O1xyXG4iXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUNBO0FBT0E7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUZBO0FBR0E7QUFIQTtBQUlBO0FBSkE7QUFLQTtBQUxBO0FBTUE7QUFOQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWEE7QUFDQTtBQWFBO0FBQUE7QUFDQTtBQURBO0FBRUE7QUFGQTtBQUdBO0FBSEE7QUFJQTtBQUpBO0FBS0E7QUFMQTtBQU1BO0FBQUE7QUFBQTtBQU5BO0FBQUE7QUFRQTtBQVJBO0FBU0E7QUFUQTtBQVVBO0FBVkE7QUFBQTtBQUNBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFDQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBRUE7QUFGQTtBQUFBO0FBQUE7QUFLQTtBQUxBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUtBO0FBTEE7QUFNQTtBQU5BO0FBT0E7QUFQQTtBQVFBO0FBUkE7QUFTQTtBQVRBO0FBVUE7QUFWQTtBQVdBO0FBWEE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQUNBO0FBUUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFKQTtBQUNBO0FBTUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBS0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/vendor/crossfilter.js\n");

/***/ }),

/***/ "./src/vendor/d3.js":
/*!**************************!*\
  !*** ./src/vendor/d3.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("Object.defineProperty(exports,\"__esModule\",{value:true});var _typeof=typeof Symbol===\"function\"&&typeof Symbol.iterator===\"symbol\"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol===\"function\"&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj;};var d3={};var version=\"5.4.0\";function ascending(a,b){return a<b?-1:a>b?1:a>=b?0:NaN;}function bisector(compare){if(compare.length===1)compare=ascendingComparator(compare);return{left:function left(a,x,lo,hi){if(lo==null)lo=0;if(hi==null)hi=a.length;while(lo<hi){var mid=lo+hi>>>1;if(compare(a[mid],x)<0)lo=mid+1;else hi=mid;}return lo;},right:function right(a,x,lo,hi){if(lo==null)lo=0;if(hi==null)hi=a.length;while(lo<hi){var mid=lo+hi>>>1;if(compare(a[mid],x)>0)hi=mid;else lo=mid+1;}return lo;}};}function ascendingComparator(f){return function(d,x){return ascending(f(d),x);};}var ascendingBisect=bisector(ascending);var bisectRight=ascendingBisect.right;var bisectLeft=ascendingBisect.left;function pairs(array,f){if(f==null)f=pair;var i=0,n=array.length-1,p=array[0],pairs=new Array(n<0?0:n);while(i<n){pairs[i]=f(p,p=array[++i]);}return pairs;}function pair(a,b){return[a,b];}function cross(values0,values1,reduce){var n0=values0.length,n1=values1.length,values=new Array(n0*n1),i0,i1,i,value0;if(reduce==null)reduce=pair;for(i0=i=0;i0<n0;++i0){for(value0=values0[i0],i1=0;i1<n1;++i1,++i){values[i]=reduce(value0,values1[i1]);}}return values;}function descending(a,b){return b<a?-1:b>a?1:b>=a?0:NaN;}function number(x){return x===null?NaN:+x;}function variance(values,valueof){var n=values.length,m=0,i=-1,mean=0,value,delta,sum=0;if(valueof==null){while(++i<n){if(!isNaN(value=number(values[i]))){delta=value-mean;mean+=delta/++m;sum+=delta*(value-mean);}}}else{while(++i<n){if(!isNaN(value=number(valueof(values[i],i,values)))){delta=value-mean;mean+=delta/++m;sum+=delta*(value-mean);}}}if(m>1)return sum/(m-1);}function deviation(array,f){var v=variance(array,f);return v?Math.sqrt(v):v;}function extent(values,valueof){var n=values.length,i=-1,value,min,max;if(valueof==null){while(++i<n){// Find the first comparable value.\nif((value=values[i])!=null&&value>=value){min=max=value;while(++i<n){// Compare the remaining values.\nif((value=values[i])!=null){if(min>value)min=value;if(max<value)max=value;}}}}}else{while(++i<n){// Find the first comparable value.\nif((value=valueof(values[i],i,values))!=null&&value>=value){min=max=value;while(++i<n){// Compare the remaining values.\nif((value=valueof(values[i],i,values))!=null){if(min>value)min=value;if(max<value)max=value;}}}}}return[min,max];}var array=Array.prototype;var slice=array.slice;var map=array.map;function constant(x){return function(){return x;};}function identity(x){return x;}function sequence(start,stop,step){start=+start,stop=+stop,step=(n=arguments.length)<2?(stop=start,start=0,1):n<3?1:+step;var i=-1,n=Math.max(0,Math.ceil((stop-start)/step))|0,range=new Array(n);while(++i<n){range[i]=start+i*step;}return range;}var e10=Math.sqrt(50),e5=Math.sqrt(10),e2=Math.sqrt(2);function ticks(start,stop,count){var reverse,i=-1,n,ticks,step;stop=+stop,start=+start,count=+count;if(start===stop&&count>0)return[start];if(reverse=stop<start)n=start,start=stop,stop=n;if((step=tickIncrement(start,stop,count))===0||!isFinite(step))return[];if(step>0){start=Math.ceil(start/step);stop=Math.floor(stop/step);ticks=new Array(n=Math.ceil(stop-start+1));while(++i<n){ticks[i]=(start+i)*step;}}else{start=Math.floor(start*step);stop=Math.ceil(stop*step);ticks=new Array(n=Math.ceil(start-stop+1));while(++i<n){ticks[i]=(start-i)/step;}}if(reverse)ticks.reverse();return ticks;}function tickIncrement(start,stop,count){var step=(stop-start)/Math.max(0,count),power=Math.floor(Math.log(step)/Math.LN10),error=step/Math.pow(10,power);return power>=0?(error>=e10?10:error>=e5?5:error>=e2?2:1)*Math.pow(10,power):-Math.pow(10,-power)/(error>=e10?10:error>=e5?5:error>=e2?2:1);}function tickStep(start,stop,count){var step0=Math.abs(stop-start)/Math.max(0,count),step1=Math.pow(10,Math.floor(Math.log(step0)/Math.LN10)),error=step0/step1;if(error>=e10)step1*=10;else if(error>=e5)step1*=5;else if(error>=e2)step1*=2;return stop<start?-step1:step1;}function thresholdSturges(values){return Math.ceil(Math.log(values.length)/Math.LN2)+1;}function histogram(){var value=identity,domain=extent,threshold=thresholdSturges;function histogram(data){var i,n=data.length,x,values=new Array(n);for(i=0;i<n;++i){values[i]=value(data[i],i,data);}var xz=domain(values),x0=xz[0],x1=xz[1],tz=threshold(values,x0,x1);// Convert number of thresholds into uniform thresholds.\nif(!Array.isArray(tz)){tz=tickStep(x0,x1,tz);tz=sequence(Math.ceil(x0/tz)*tz,Math.floor(x1/tz)*tz,tz);// exclusive\n}// Remove any thresholds outside the domain.\nvar m=tz.length;while(tz[0]<=x0){tz.shift(),--m;}while(tz[m-1]>x1){tz.pop(),--m;}var bins=new Array(m+1),bin;// Initialize bins.\nfor(i=0;i<=m;++i){bin=bins[i]=[];bin.x0=i>0?tz[i-1]:x0;bin.x1=i<m?tz[i]:x1;}// Assign data to bins by value, ignoring any outside the domain.\nfor(i=0;i<n;++i){x=values[i];if(x0<=x&&x<=x1){bins[bisectRight(tz,x,0,m)].push(data[i]);}}return bins;}histogram.value=function(_){return arguments.length?(value=typeof _===\"function\"?_:constant(_),histogram):value;};histogram.domain=function(_){return arguments.length?(domain=typeof _===\"function\"?_:constant([_[0],_[1]]),histogram):domain;};histogram.thresholds=function(_){return arguments.length?(threshold=typeof _===\"function\"?_:Array.isArray(_)?constant(slice.call(_)):constant(_),histogram):threshold;};return histogram;}function threshold(values,p,valueof){if(valueof==null)valueof=number;if(!(n=values.length))return;if((p=+p)<=0||n<2)return+valueof(values[0],0,values);if(p>=1)return+valueof(values[n-1],n-1,values);var n,i=(n-1)*p,i0=Math.floor(i),value0=+valueof(values[i0],i0,values),value1=+valueof(values[i0+1],i0+1,values);return value0+(value1-value0)*(i-i0);}function freedmanDiaconis(values,min,max){values=map.call(values,number).sort(ascending);return Math.ceil((max-min)/(2*(threshold(values,0.75)-threshold(values,0.25))*Math.pow(values.length,-1/3)));}function scott(values,min,max){return Math.ceil((max-min)/(3.5*deviation(values)*Math.pow(values.length,-1/3)));}function max(values,valueof){var n=values.length,i=-1,value,max;if(valueof==null){while(++i<n){// Find the first comparable value.\nif((value=values[i])!=null&&value>=value){max=value;while(++i<n){// Compare the remaining values.\nif((value=values[i])!=null&&value>max){max=value;}}}}}else{while(++i<n){// Find the first comparable value.\nif((value=valueof(values[i],i,values))!=null&&value>=value){max=value;while(++i<n){// Compare the remaining values.\nif((value=valueof(values[i],i,values))!=null&&value>max){max=value;}}}}}return max;}function mean(values,valueof){var n=values.length,m=n,i=-1,value,sum=0;if(valueof==null){while(++i<n){if(!isNaN(value=number(values[i])))sum+=value;else--m;}}else{while(++i<n){if(!isNaN(value=number(valueof(values[i],i,values))))sum+=value;else--m;}}if(m)return sum/m;}function median(values,valueof){var n=values.length,i=-1,value,numbers=[];if(valueof==null){while(++i<n){if(!isNaN(value=number(values[i]))){numbers.push(value);}}}else{while(++i<n){if(!isNaN(value=number(valueof(values[i],i,values)))){numbers.push(value);}}}return threshold(numbers.sort(ascending),0.5);}function merge(arrays){var n=arrays.length,m,i=-1,j=0,merged,array;while(++i<n){j+=arrays[i].length;}merged=new Array(j);while(--n>=0){array=arrays[n];m=array.length;while(--m>=0){merged[--j]=array[m];}}return merged;}function min(values,valueof){var n=values.length,i=-1,value,min;if(valueof==null){while(++i<n){// Find the first comparable value.\nif((value=values[i])!=null&&value>=value){min=value;while(++i<n){// Compare the remaining values.\nif((value=values[i])!=null&&min>value){min=value;}}}}}else{while(++i<n){// Find the first comparable value.\nif((value=valueof(values[i],i,values))!=null&&value>=value){min=value;while(++i<n){// Compare the remaining values.\nif((value=valueof(values[i],i,values))!=null&&min>value){min=value;}}}}}return min;}function permute(array,indexes){var i=indexes.length,permutes=new Array(i);while(i--){permutes[i]=array[indexes[i]];}return permutes;}function scan(values,compare){if(!(n=values.length))return;var n,i=0,j=0,xi,xj=values[j];if(compare==null)compare=ascending;while(++i<n){if(compare(xi=values[i],xj)<0||compare(xj,xj)!==0){xj=xi,j=i;}}if(compare(xj,xj)===0)return j;}function shuffle(array,i0,i1){var m=(i1==null?array.length:i1)-(i0=i0==null?0:+i0),t,i;while(m){i=Math.random()*m--|0;t=array[m+i0];array[m+i0]=array[i+i0];array[i+i0]=t;}return array;}function sum(values,valueof){var n=values.length,i=-1,value,sum=0;if(valueof==null){while(++i<n){if(value=+values[i])sum+=value;// Note: zero and null are equivalent.\n}}else{while(++i<n){if(value=+valueof(values[i],i,values))sum+=value;}}return sum;}function transpose(matrix){if(!(n=matrix.length))return[];for(var i=-1,m=min(matrix,length),transpose=new Array(m);++i<m;){for(var j=-1,n,row=transpose[i]=new Array(n);++j<n;){row[j]=matrix[j][i];}}return transpose;}function length(d){return d.length;}function zip(){return transpose(arguments);}var slice$1=Array.prototype.slice;function identity$1(x){return x;}var top=1,right=2,bottom=3,left=4,epsilon=1e-6;function translateX(x){return\"translate(\"+(x+0.5)+\",0)\";}function translateY(y){return\"translate(0,\"+(y+0.5)+\")\";}function number$1(scale){return function(d){return+scale(d);};}function center(scale){var offset=Math.max(0,scale.bandwidth()-1)/2;// Adjust for 0.5px offset.\nif(scale.round())offset=Math.round(offset);return function(d){return+scale(d)+offset;};}function entering(){return!this.__axis;}function axis(orient,scale){var tickArguments=[],tickValues=null,tickFormat=null,tickSizeInner=6,tickSizeOuter=6,tickPadding=3,k=orient===top||orient===left?-1:1,x=orient===left||orient===right?\"x\":\"y\",transform=orient===top||orient===bottom?translateX:translateY;function axis(context){var values=tickValues==null?scale.ticks?scale.ticks.apply(scale,tickArguments):scale.domain():tickValues,format=tickFormat==null?scale.tickFormat?scale.tickFormat.apply(scale,tickArguments):identity$1:tickFormat,spacing=Math.max(tickSizeInner,0)+tickPadding,range=scale.range(),range0=+range[0]+0.5,range1=+range[range.length-1]+0.5,position=(scale.bandwidth?center:number$1)(scale.copy()),selection=context.selection?context.selection():context,path=selection.selectAll(\".domain\").data([null]),tick=selection.selectAll(\".tick\").data(values,scale).order(),tickExit=tick.exit(),tickEnter=tick.enter().append(\"g\").attr(\"class\",\"tick\"),line=tick.select(\"line\"),text=tick.select(\"text\");path=path.merge(path.enter().insert(\"path\",\".tick\").attr(\"class\",\"domain\").attr(\"stroke\",\"#000\"));tick=tick.merge(tickEnter);line=line.merge(tickEnter.append(\"line\").attr(\"stroke\",\"#000\").attr(x+\"2\",k*tickSizeInner));text=text.merge(tickEnter.append(\"text\").attr(\"fill\",\"#000\").attr(x,k*spacing).attr(\"dy\",orient===top?\"0em\":orient===bottom?\"0.71em\":\"0.32em\"));if(context!==selection){path=path.transition(context);tick=tick.transition(context);line=line.transition(context);text=text.transition(context);tickExit=tickExit.transition(context).attr(\"opacity\",epsilon).attr(\"transform\",function(d){return isFinite(d=position(d))?transform(d):this.getAttribute(\"transform\");});tickEnter.attr(\"opacity\",epsilon).attr(\"transform\",function(d){var p=this.parentNode.__axis;return transform(p&&isFinite(p=p(d))?p:position(d));});}tickExit.remove();path.attr(\"d\",orient===left||orient==right?\"M\"+k*tickSizeOuter+\",\"+range0+\"H0.5V\"+range1+\"H\"+k*tickSizeOuter:\"M\"+range0+\",\"+k*tickSizeOuter+\"V0.5H\"+range1+\"V\"+k*tickSizeOuter);tick.attr(\"opacity\",1).attr(\"transform\",function(d){return transform(position(d));});line.attr(x+\"2\",k*tickSizeInner);text.attr(x,k*spacing).text(format);selection.filter(entering).attr(\"fill\",\"none\").attr(\"font-size\",10).attr(\"font-family\",\"sans-serif\").attr(\"text-anchor\",orient===right?\"start\":orient===left?\"end\":\"middle\");selection.each(function(){this.__axis=position;});}axis.scale=function(_){return arguments.length?(scale=_,axis):scale;};axis.ticks=function(){return tickArguments=slice$1.call(arguments),axis;};axis.tickArguments=function(_){return arguments.length?(tickArguments=_==null?[]:slice$1.call(_),axis):tickArguments.slice();};axis.tickValues=function(_){return arguments.length?(tickValues=_==null?null:slice$1.call(_),axis):tickValues&&tickValues.slice();};axis.tickFormat=function(_){return arguments.length?(tickFormat=_,axis):tickFormat;};axis.tickSize=function(_){return arguments.length?(tickSizeInner=tickSizeOuter=+_,axis):tickSizeInner;};axis.tickSizeInner=function(_){return arguments.length?(tickSizeInner=+_,axis):tickSizeInner;};axis.tickSizeOuter=function(_){return arguments.length?(tickSizeOuter=+_,axis):tickSizeOuter;};axis.tickPadding=function(_){return arguments.length?(tickPadding=+_,axis):tickPadding;};return axis;}function axisTop(scale){return axis(top,scale);}function axisRight(scale){return axis(right,scale);}function axisBottom(scale){return axis(bottom,scale);}function axisLeft(scale){return axis(left,scale);}var noop={value:function value(){}};function dispatch(){for(var i=0,n=arguments.length,_={},t;i<n;++i){if(!(t=arguments[i]+\"\")||t in _)throw new Error(\"illegal type: \"+t);_[t]=[];}return new Dispatch(_);}function Dispatch(_){this._=_;}function parseTypenames(typenames,types){return typenames.trim().split(/^|\\s+/).map(function(t){var name=\"\",i=t.indexOf(\".\");if(i>=0)name=t.slice(i+1),t=t.slice(0,i);if(t&&!types.hasOwnProperty(t))throw new Error(\"unknown type: \"+t);return{type:t,name:name};});}Dispatch.prototype=dispatch.prototype={constructor:Dispatch,on:function on(typename,callback){var _=this._,T=parseTypenames(typename+\"\",_),t,i=-1,n=T.length;// If no callback was specified, return the callback of the given type and name.\nif(arguments.length<2){while(++i<n){if((t=(typename=T[i]).type)&&(t=get(_[t],typename.name)))return t;}return;}// If a type was specified, set the callback for the given type and name.\n// Otherwise, if a null callback was specified, remove callbacks of the given name.\nif(callback!=null&&typeof callback!==\"function\")throw new Error(\"invalid callback: \"+callback);while(++i<n){if(t=(typename=T[i]).type)_[t]=set(_[t],typename.name,callback);else if(callback==null)for(t in _){_[t]=set(_[t],typename.name,null);}}return this;},copy:function copy(){var copy={},_=this._;for(var t in _){copy[t]=_[t].slice();}return new Dispatch(copy);},call:function call(type,that){if((n=arguments.length-2)>0)for(var args=new Array(n),i=0,n,t;i<n;++i){args[i]=arguments[i+2];}if(!this._.hasOwnProperty(type))throw new Error(\"unknown type: \"+type);for(t=this._[type],i=0,n=t.length;i<n;++i){t[i].value.apply(that,args);}},apply:function apply(type,that,args){if(!this._.hasOwnProperty(type))throw new Error(\"unknown type: \"+type);for(var t=this._[type],i=0,n=t.length;i<n;++i){t[i].value.apply(that,args);}}};function get(type,name){for(var i=0,n=type.length,c;i<n;++i){if((c=type[i]).name===name){return c.value;}}}function set(type,name,callback){for(var i=0,n=type.length;i<n;++i){if(type[i].name===name){type[i]=noop,type=type.slice(0,i).concat(type.slice(i+1));break;}}if(callback!=null)type.push({name:name,value:callback});return type;}var xhtml=\"http://www.w3.org/1999/xhtml\";var namespaces={svg:\"http://www.w3.org/2000/svg\",xhtml:xhtml,xlink:\"http://www.w3.org/1999/xlink\",xml:\"http://www.w3.org/XML/1998/namespace\",xmlns:\"http://www.w3.org/2000/xmlns/\"};function namespace(name){var prefix=name+=\"\",i=prefix.indexOf(\":\");if(i>=0&&(prefix=name.slice(0,i))!==\"xmlns\")name=name.slice(i+1);return namespaces.hasOwnProperty(prefix)?{space:namespaces[prefix],local:name}:name;}function creatorInherit(name){return function(){var document=this.ownerDocument,uri=this.namespaceURI;return uri===xhtml&&document.documentElement.namespaceURI===xhtml?document.createElement(name):document.createElementNS(uri,name);};}function creatorFixed(fullname){return function(){return this.ownerDocument.createElementNS(fullname.space,fullname.local);};}function creator(name){var fullname=namespace(name);return(fullname.local?creatorFixed:creatorInherit)(fullname);}function none(){}function selector(selector){return selector==null?none:function(){return this.querySelector(selector);};}function selection_select(select){if(typeof select!==\"function\")select=selector(select);for(var groups=this._groups,m=groups.length,subgroups=new Array(m),j=0;j<m;++j){for(var group=groups[j],n=group.length,subgroup=subgroups[j]=new Array(n),node,subnode,i=0;i<n;++i){if((node=group[i])&&(subnode=select.call(node,node.__data__,i,group))){if(\"__data__\"in node)subnode.__data__=node.__data__;subgroup[i]=subnode;}}}return new Selection(subgroups,this._parents);}function empty(){return[];}function selectorAll(selector){return selector==null?empty:function(){return this.querySelectorAll(selector);};}function selection_selectAll(select){if(typeof select!==\"function\")select=selectorAll(select);for(var groups=this._groups,m=groups.length,subgroups=[],parents=[],j=0;j<m;++j){for(var group=groups[j],n=group.length,node,i=0;i<n;++i){if(node=group[i]){subgroups.push(select.call(node,node.__data__,i,group));parents.push(node);}}}return new Selection(subgroups,parents);}var matcher=function matcher(selector){return function(){return this.matches(selector);};};if(typeof document!==\"undefined\"){var element=document.documentElement;if(!element.matches){var vendorMatches=element.webkitMatchesSelector||element.msMatchesSelector||element.mozMatchesSelector||element.oMatchesSelector;matcher=function matcher(selector){return function(){return vendorMatches.call(this,selector);};};}}var matcher$1=matcher;function selection_filter(match){if(typeof match!==\"function\")match=matcher$1(match);for(var groups=this._groups,m=groups.length,subgroups=new Array(m),j=0;j<m;++j){for(var group=groups[j],n=group.length,subgroup=subgroups[j]=[],node,i=0;i<n;++i){if((node=group[i])&&match.call(node,node.__data__,i,group)){subgroup.push(node);}}}return new Selection(subgroups,this._parents);}function sparse(update){return new Array(update.length);}function selection_enter(){return new Selection(this._enter||this._groups.map(sparse),this._parents);}function EnterNode(parent,datum){this.ownerDocument=parent.ownerDocument;this.namespaceURI=parent.namespaceURI;this._next=null;this._parent=parent;this.__data__=datum;}EnterNode.prototype={constructor:EnterNode,appendChild:function appendChild(child){return this._parent.insertBefore(child,this._next);},insertBefore:function insertBefore(child,next){return this._parent.insertBefore(child,next);},querySelector:function querySelector(selector){return this._parent.querySelector(selector);},querySelectorAll:function querySelectorAll(selector){return this._parent.querySelectorAll(selector);}};function constant$1(x){return function(){return x;};}var keyPrefix=\"$\";// Protect against keys like “__proto__”.\nfunction bindIndex(parent,group,enter,update,exit,data){var i=0,node,groupLength=group.length,dataLength=data.length;// Put any non-null nodes that fit into update.\n// Put any null nodes into enter.\n// Put any remaining data into enter.\nfor(;i<dataLength;++i){if(node=group[i]){node.__data__=data[i];update[i]=node;}else{enter[i]=new EnterNode(parent,data[i]);}}// Put any non-null nodes that don’t fit into exit.\nfor(;i<groupLength;++i){if(node=group[i]){exit[i]=node;}}}function bindKey(parent,group,enter,update,exit,data,key){var i,node,nodeByKeyValue={},groupLength=group.length,dataLength=data.length,keyValues=new Array(groupLength),keyValue;// Compute the key for each node.\n// If multiple nodes have the same key, the duplicates are added to exit.\nfor(i=0;i<groupLength;++i){if(node=group[i]){keyValues[i]=keyValue=keyPrefix+key.call(node,node.__data__,i,group);if(keyValue in nodeByKeyValue){exit[i]=node;}else{nodeByKeyValue[keyValue]=node;}}}// Compute the key for each datum.\n// If there a node associated with this key, join and add it to update.\n// If there is not (or the key is a duplicate), add it to enter.\nfor(i=0;i<dataLength;++i){keyValue=keyPrefix+key.call(parent,data[i],i,data);if(node=nodeByKeyValue[keyValue]){update[i]=node;node.__data__=data[i];nodeByKeyValue[keyValue]=null;}else{enter[i]=new EnterNode(parent,data[i]);}}// Add any remaining nodes that were not bound to data to exit.\nfor(i=0;i<groupLength;++i){if((node=group[i])&&nodeByKeyValue[keyValues[i]]===node){exit[i]=node;}}}function selection_data(value,key){if(!value){data=new Array(this.size()),j=-1;this.each(function(d){data[++j]=d;});return data;}var bind=key?bindKey:bindIndex,parents=this._parents,groups=this._groups;if(typeof value!==\"function\")value=constant$1(value);for(var m=groups.length,update=new Array(m),enter=new Array(m),exit=new Array(m),j=0;j<m;++j){var parent=parents[j],group=groups[j],groupLength=group.length,data=value.call(parent,parent&&parent.__data__,j,parents),dataLength=data.length,enterGroup=enter[j]=new Array(dataLength),updateGroup=update[j]=new Array(dataLength),exitGroup=exit[j]=new Array(groupLength);bind(parent,group,enterGroup,updateGroup,exitGroup,data,key);// Now connect the enter nodes to their following update node, such that\n// appendChild can insert the materialized enter node before this node,\n// rather than at the end of the parent node.\nfor(var i0=0,i1=0,previous,next;i0<dataLength;++i0){if(previous=enterGroup[i0]){if(i0>=i1)i1=i0+1;while(!(next=updateGroup[i1])&&++i1<dataLength){}previous._next=next||null;}}}update=new Selection(update,parents);update._enter=enter;update._exit=exit;return update;}function selection_exit(){return new Selection(this._exit||this._groups.map(sparse),this._parents);}function selection_merge(selection$$1){for(var groups0=this._groups,groups1=selection$$1._groups,m0=groups0.length,m1=groups1.length,m=Math.min(m0,m1),merges=new Array(m0),j=0;j<m;++j){for(var group0=groups0[j],group1=groups1[j],n=group0.length,merge=merges[j]=new Array(n),node,i=0;i<n;++i){if(node=group0[i]||group1[i]){merge[i]=node;}}}for(;j<m0;++j){merges[j]=groups0[j];}return new Selection(merges,this._parents);}function selection_order(){for(var groups=this._groups,j=-1,m=groups.length;++j<m;){for(var group=groups[j],i=group.length-1,next=group[i],node;--i>=0;){if(node=group[i]){if(next&&next!==node.nextSibling)next.parentNode.insertBefore(node,next);next=node;}}}return this;}function selection_sort(compare){if(!compare)compare=ascending$1;function compareNode(a,b){return a&&b?compare(a.__data__,b.__data__):!a-!b;}for(var groups=this._groups,m=groups.length,sortgroups=new Array(m),j=0;j<m;++j){for(var group=groups[j],n=group.length,sortgroup=sortgroups[j]=new Array(n),node,i=0;i<n;++i){if(node=group[i]){sortgroup[i]=node;}}sortgroup.sort(compareNode);}return new Selection(sortgroups,this._parents).order();}function ascending$1(a,b){return a<b?-1:a>b?1:a>=b?0:NaN;}function selection_call(){var callback=arguments[0];arguments[0]=this;callback.apply(null,arguments);return this;}function selection_nodes(){var nodes=new Array(this.size()),i=-1;this.each(function(){nodes[++i]=this;});return nodes;}function selection_node(){for(var groups=this._groups,j=0,m=groups.length;j<m;++j){for(var group=groups[j],i=0,n=group.length;i<n;++i){var node=group[i];if(node)return node;}}return null;}function selection_size(){var size=0;this.each(function(){++size;});return size;}function selection_empty(){return!this.node();}function selection_each(callback){for(var groups=this._groups,j=0,m=groups.length;j<m;++j){for(var group=groups[j],i=0,n=group.length,node;i<n;++i){if(node=group[i])callback.call(node,node.__data__,i,group);}}return this;}function attrRemove(name){return function(){this.removeAttribute(name);};}function attrRemoveNS(fullname){return function(){this.removeAttributeNS(fullname.space,fullname.local);};}function attrConstant(name,value){return function(){this.setAttribute(name,value);};}function attrConstantNS(fullname,value){return function(){this.setAttributeNS(fullname.space,fullname.local,value);};}function attrFunction(name,value){return function(){var v=value.apply(this,arguments);if(v==null)this.removeAttribute(name);else this.setAttribute(name,v);};}function attrFunctionNS(fullname,value){return function(){var v=value.apply(this,arguments);if(v==null)this.removeAttributeNS(fullname.space,fullname.local);else this.setAttributeNS(fullname.space,fullname.local,v);};}function selection_attr(name,value){var fullname=namespace(name);if(arguments.length<2){var node=this.node();return fullname.local?node.getAttributeNS(fullname.space,fullname.local):node.getAttribute(fullname);}return this.each((value==null?fullname.local?attrRemoveNS:attrRemove:typeof value===\"function\"?fullname.local?attrFunctionNS:attrFunction:fullname.local?attrConstantNS:attrConstant)(fullname,value));}function defaultView(node){return node.ownerDocument&&node.ownerDocument.defaultView||// node is a Node\nnode.document&&node// node is a Window\n||node.defaultView;// node is a Document\n}function styleRemove(name){return function(){this.style.removeProperty(name);};}function styleConstant(name,value,priority){return function(){this.style.setProperty(name,value,priority);};}function styleFunction(name,value,priority){return function(){var v=value.apply(this,arguments);if(v==null)this.style.removeProperty(name);else this.style.setProperty(name,v,priority);};}function selection_style(name,value,priority){return arguments.length>1?this.each((value==null?styleRemove:typeof value===\"function\"?styleFunction:styleConstant)(name,value,priority==null?\"\":priority)):styleValue(this.node(),name);}function styleValue(node,name){return node.style.getPropertyValue(name)||defaultView(node).getComputedStyle(node,null).getPropertyValue(name);}function propertyRemove(name){return function(){delete this[name];};}function propertyConstant(name,value){return function(){this[name]=value;};}function propertyFunction(name,value){return function(){var v=value.apply(this,arguments);if(v==null)delete this[name];else this[name]=v;};}function selection_property(name,value){return arguments.length>1?this.each((value==null?propertyRemove:typeof value===\"function\"?propertyFunction:propertyConstant)(name,value)):this.node()[name];}function classArray(string){return string.trim().split(/^|\\s+/);}function classList(node){return node.classList||new ClassList(node);}function ClassList(node){this._node=node;this._names=classArray(node.getAttribute(\"class\")||\"\");}ClassList.prototype={add:function add(name){var i=this._names.indexOf(name);if(i<0){this._names.push(name);this._node.setAttribute(\"class\",this._names.join(\" \"));}},remove:function remove(name){var i=this._names.indexOf(name);if(i>=0){this._names.splice(i,1);this._node.setAttribute(\"class\",this._names.join(\" \"));}},contains:function contains(name){return this._names.indexOf(name)>=0;}};function classedAdd(node,names){var list=classList(node),i=-1,n=names.length;while(++i<n){list.add(names[i]);}}function classedRemove(node,names){var list=classList(node),i=-1,n=names.length;while(++i<n){list.remove(names[i]);}}function classedTrue(names){return function(){classedAdd(this,names);};}function classedFalse(names){return function(){classedRemove(this,names);};}function classedFunction(names,value){return function(){(value.apply(this,arguments)?classedAdd:classedRemove)(this,names);};}function selection_classed(name,value){var names=classArray(name+\"\");if(arguments.length<2){var list=classList(this.node()),i=-1,n=names.length;while(++i<n){if(!list.contains(names[i]))return false;}return true;}return this.each((typeof value===\"function\"?classedFunction:value?classedTrue:classedFalse)(names,value));}function textRemove(){this.textContent=\"\";}function textConstant(value){return function(){this.textContent=value;};}function textFunction(value){return function(){var v=value.apply(this,arguments);this.textContent=v==null?\"\":v;};}function selection_text(value){return arguments.length?this.each(value==null?textRemove:(typeof value===\"function\"?textFunction:textConstant)(value)):this.node().textContent;}function htmlRemove(){this.innerHTML=\"\";}function htmlConstant(value){return function(){this.innerHTML=value;};}function htmlFunction(value){return function(){var v=value.apply(this,arguments);this.innerHTML=v==null?\"\":v;};}function selection_html(value){return arguments.length?this.each(value==null?htmlRemove:(typeof value===\"function\"?htmlFunction:htmlConstant)(value)):this.node().innerHTML;}function raise(){if(this.nextSibling)this.parentNode.appendChild(this);}function selection_raise(){return this.each(raise);}function lower(){if(this.previousSibling)this.parentNode.insertBefore(this,this.parentNode.firstChild);}function selection_lower(){return this.each(lower);}function selection_append(name){var create=typeof name===\"function\"?name:creator(name);return this.select(function(){return this.appendChild(create.apply(this,arguments));});}function constantNull(){return null;}function selection_insert(name,before){var create=typeof name===\"function\"?name:creator(name),select=before==null?constantNull:typeof before===\"function\"?before:selector(before);return this.select(function(){return this.insertBefore(create.apply(this,arguments),select.apply(this,arguments)||null);});}function remove(){var parent=this.parentNode;if(parent)parent.removeChild(this);}function selection_remove(){return this.each(remove);}function selection_cloneShallow(){return this.parentNode.insertBefore(this.cloneNode(false),this.nextSibling);}function selection_cloneDeep(){return this.parentNode.insertBefore(this.cloneNode(true),this.nextSibling);}function selection_clone(deep){return this.select(deep?selection_cloneDeep:selection_cloneShallow);}function selection_datum(value){return arguments.length?this.property(\"__data__\",value):this.node().__data__;}var filterEvents={};d3.event=null;if(typeof document!==\"undefined\"){var element$1=document.documentElement;if(!(\"onmouseenter\"in element$1)){filterEvents={mouseenter:\"mouseover\",mouseleave:\"mouseout\"};}}function filterContextListener(listener,index,group){listener=contextListener(listener,index,group);return function(event){var related=event.relatedTarget;if(!related||related!==this&&!(related.compareDocumentPosition(this)&8)){listener.call(this,event);}};}function contextListener(listener,index,group){return function(event1){var event0=d3.event;// Events can be reentrant (e.g., focus).\nd3.event=event1;try{listener.call(this,this.__data__,index,group);}finally{d3.event=event0;}};}function parseTypenames$1(typenames){return typenames.trim().split(/^|\\s+/).map(function(t){var name=\"\",i=t.indexOf(\".\");if(i>=0)name=t.slice(i+1),t=t.slice(0,i);return{type:t,name:name};});}function onRemove(typename){return function(){var on=this.__on;if(!on)return;for(var j=0,i=-1,m=on.length,o;j<m;++j){if(o=on[j],(!typename.type||o.type===typename.type)&&o.name===typename.name){this.removeEventListener(o.type,o.listener,o.capture);}else{on[++i]=o;}}if(++i)on.length=i;else delete this.__on;};}function onAdd(typename,value,capture){var wrap=filterEvents.hasOwnProperty(typename.type)?filterContextListener:contextListener;return function(d,i,group){var on=this.__on,o,listener=wrap(value,i,group);if(on)for(var j=0,m=on.length;j<m;++j){if((o=on[j]).type===typename.type&&o.name===typename.name){this.removeEventListener(o.type,o.listener,o.capture);this.addEventListener(o.type,o.listener=listener,o.capture=capture);o.value=value;return;}}this.addEventListener(typename.type,listener,capture);o={type:typename.type,name:typename.name,value:value,listener:listener,capture:capture};if(!on)this.__on=[o];else on.push(o);};}function selection_on(typename,value,capture){var typenames=parseTypenames$1(typename+\"\"),i,n=typenames.length,t;if(arguments.length<2){var on=this.node().__on;if(on)for(var j=0,m=on.length,o;j<m;++j){for(i=0,o=on[j];i<n;++i){if((t=typenames[i]).type===o.type&&t.name===o.name){return o.value;}}}return;}on=value?onAdd:onRemove;if(capture==null)capture=false;for(i=0;i<n;++i){this.each(on(typenames[i],value,capture));}return this;}function customEvent(event1,listener,that,args){var event0=d3.event;event1.sourceEvent=d3.event;d3.event=event1;try{return listener.apply(that,args);}finally{d3.event=event0;}}function dispatchEvent(node,type,params){var window=defaultView(node),event=window.CustomEvent;if(typeof event===\"function\"){event=new event(type,params);}else{event=window.document.createEvent(\"Event\");if(params)event.initEvent(type,params.bubbles,params.cancelable),event.detail=params.detail;else event.initEvent(type,false,false);}node.dispatchEvent(event);}function dispatchConstant(type,params){return function(){return dispatchEvent(this,type,params);};}function dispatchFunction(type,params){return function(){return dispatchEvent(this,type,params.apply(this,arguments));};}function selection_dispatch(type,params){return this.each((typeof params===\"function\"?dispatchFunction:dispatchConstant)(type,params));}var root=[null];function Selection(groups,parents){this._groups=groups;this._parents=parents;}function selection(){return new Selection([[document.documentElement]],root);}Selection.prototype=selection.prototype={constructor:Selection,select:selection_select,selectAll:selection_selectAll,filter:selection_filter,data:selection_data,enter:selection_enter,exit:selection_exit,merge:selection_merge,order:selection_order,sort:selection_sort,call:selection_call,nodes:selection_nodes,node:selection_node,size:selection_size,empty:selection_empty,each:selection_each,attr:selection_attr,style:selection_style,property:selection_property,classed:selection_classed,text:selection_text,html:selection_html,raise:selection_raise,lower:selection_lower,append:selection_append,insert:selection_insert,remove:selection_remove,clone:selection_clone,datum:selection_datum,on:selection_on,dispatch:selection_dispatch};function select(selector){return typeof selector===\"string\"?new Selection([[document.querySelector(selector)]],[document.documentElement]):new Selection([[selector]],root);}function create(name){return select(creator(name).call(document.documentElement));}var nextId=0;function local(){return new Local();}function Local(){this._=\"@\"+(++nextId).toString(36);}Local.prototype=local.prototype={constructor:Local,get:function get(node){var id=this._;while(!(id in node)){if(!(node=node.parentNode))return;}return node[id];},set:function set(node,value){return node[this._]=value;},remove:function remove(node){return this._ in node&&delete node[this._];},toString:function toString(){return this._;}};function sourceEvent(){var current=d3.event,source;while(source=current.sourceEvent){current=source;}return current;}function point(node,event){var svg=node.ownerSVGElement||node;if(svg.createSVGPoint){var point=svg.createSVGPoint();point.x=event.clientX,point.y=event.clientY;point=point.matrixTransform(node.getScreenCTM().inverse());return[point.x,point.y];}var rect=node.getBoundingClientRect();return[event.clientX-rect.left-node.clientLeft,event.clientY-rect.top-node.clientTop];}function mouse(node){var event=sourceEvent();if(event.changedTouches)event=event.changedTouches[0];return point(node,event);}function selectAll(selector){return typeof selector===\"string\"?new Selection([document.querySelectorAll(selector)],[document.documentElement]):new Selection([selector==null?[]:selector],root);}function touch(node,touches,identifier){if(arguments.length<3)identifier=touches,touches=sourceEvent().changedTouches;for(var i=0,n=touches?touches.length:0,touch;i<n;++i){if((touch=touches[i]).identifier===identifier){return point(node,touch);}}return null;}function touches(node,touches){if(touches==null)touches=sourceEvent().touches;for(var i=0,n=touches?touches.length:0,points=new Array(n);i<n;++i){points[i]=point(node,touches[i]);}return points;}function nopropagation(){d3.event.stopImmediatePropagation();}function noevent(){d3.event.preventDefault();d3.event.stopImmediatePropagation();}function dragDisable(view){var root=view.document.documentElement,selection$$1=select(view).on(\"dragstart.drag\",noevent,true);if(\"onselectstart\"in root){selection$$1.on(\"selectstart.drag\",noevent,true);}else{root.__noselect=root.style.MozUserSelect;root.style.MozUserSelect=\"none\";}}function yesdrag(view,noclick){var root=view.document.documentElement,selection$$1=select(view).on(\"dragstart.drag\",null);if(noclick){selection$$1.on(\"click.drag\",noevent,true);setTimeout(function(){selection$$1.on(\"click.drag\",null);},0);}if(\"onselectstart\"in root){selection$$1.on(\"selectstart.drag\",null);}else{root.style.MozUserSelect=root.__noselect;delete root.__noselect;}}function constant$2(x){return function(){return x;};}function DragEvent(target,type,subject,id,active,x,y,dx,dy,dispatch){this.target=target;this.type=type;this.subject=subject;this.identifier=id;this.active=active;this.x=x;this.y=y;this.dx=dx;this.dy=dy;this._=dispatch;}DragEvent.prototype.on=function(){var value=this._.on.apply(this._,arguments);return value===this._?this:value;};// Ignore right-click, since that should open the context menu.\nfunction defaultFilter(){return!d3.event.button;}function defaultContainer(){return this.parentNode;}function defaultSubject(d){return d==null?{x:d3.event.x,y:d3.event.y}:d;}function defaultTouchable(){return\"ontouchstart\"in this;}function drag(){var filter=defaultFilter,container=defaultContainer,subject=defaultSubject,touchable=defaultTouchable,gestures={},listeners=dispatch(\"start\",\"drag\",\"end\"),active=0,mousedownx,mousedowny,mousemoving,touchending,clickDistance2=0;function drag(selection$$1){selection$$1.on(\"mousedown.drag\",mousedowned).filter(touchable).on(\"touchstart.drag\",touchstarted).on(\"touchmove.drag\",touchmoved).on(\"touchend.drag touchcancel.drag\",touchended).style(\"touch-action\",\"none\").style(\"-webkit-tap-highlight-color\",\"rgba(0,0,0,0)\");}function mousedowned(){if(touchending||!filter.apply(this,arguments))return;var gesture=beforestart(\"mouse\",container.apply(this,arguments),mouse,this,arguments);if(!gesture)return;select(d3.event.view).on(\"mousemove.drag\",mousemoved,true).on(\"mouseup.drag\",mouseupped,true);dragDisable(d3.event.view);nopropagation();mousemoving=false;mousedownx=d3.event.clientX;mousedowny=d3.event.clientY;gesture(\"start\");}function mousemoved(){noevent();if(!mousemoving){var dx=d3.event.clientX-mousedownx,dy=d3.event.clientY-mousedowny;mousemoving=dx*dx+dy*dy>clickDistance2;}gestures.mouse(\"drag\");}function mouseupped(){select(d3.event.view).on(\"mousemove.drag mouseup.drag\",null);yesdrag(d3.event.view,mousemoving);noevent();gestures.mouse(\"end\");}function touchstarted(){if(!filter.apply(this,arguments))return;var touches$$1=d3.event.changedTouches,c=container.apply(this,arguments),n=touches$$1.length,i,gesture;for(i=0;i<n;++i){if(gesture=beforestart(touches$$1[i].identifier,c,touch,this,arguments)){nopropagation();gesture(\"start\");}}}function touchmoved(){var touches$$1=d3.event.changedTouches,n=touches$$1.length,i,gesture;for(i=0;i<n;++i){if(gesture=gestures[touches$$1[i].identifier]){noevent();gesture(\"drag\");}}}function touchended(){var touches$$1=d3.event.changedTouches,n=touches$$1.length,i,gesture;if(touchending)clearTimeout(touchending);touchending=setTimeout(function(){touchending=null;},500);// Ghost clicks are delayed!\nfor(i=0;i<n;++i){if(gesture=gestures[touches$$1[i].identifier]){nopropagation();gesture(\"end\");}}}function beforestart(id,container,point$$1,that,args){var p=point$$1(container,id),s,dx,dy,sublisteners=listeners.copy();if(!customEvent(new DragEvent(drag,\"beforestart\",s,id,active,p[0],p[1],0,0,sublisteners),function(){if((d3.event.subject=s=subject.apply(that,args))==null)return false;dx=s.x-p[0]||0;dy=s.y-p[1]||0;return true;}))return;return function gesture(type){var p0=p,n;switch(type){case\"start\":gestures[id]=gesture,n=active++;break;case\"end\":delete gestures[id],--active;// nobreak\ncase\"drag\":p=point$$1(container,id),n=active;break;}customEvent(new DragEvent(drag,type,s,id,n,p[0]+dx,p[1]+dy,p[0]-p0[0],p[1]-p0[1],sublisteners),sublisteners.apply,sublisteners,[type,that,args]);};}drag.filter=function(_){return arguments.length?(filter=typeof _===\"function\"?_:constant$2(!!_),drag):filter;};drag.container=function(_){return arguments.length?(container=typeof _===\"function\"?_:constant$2(_),drag):container;};drag.subject=function(_){return arguments.length?(subject=typeof _===\"function\"?_:constant$2(_),drag):subject;};drag.touchable=function(_){return arguments.length?(touchable=typeof _===\"function\"?_:constant$2(!!_),drag):touchable;};drag.on=function(){var value=listeners.on.apply(listeners,arguments);return value===listeners?drag:value;};drag.clickDistance=function(_){return arguments.length?(clickDistance2=(_=+_)*_,drag):Math.sqrt(clickDistance2);};return drag;}function define(constructor,factory,prototype){constructor.prototype=factory.prototype=prototype;prototype.constructor=constructor;}function extend(parent,definition){var prototype=Object.create(parent.prototype);for(var key in definition){prototype[key]=definition[key];}return prototype;}function Color(){}var _darker=0.7;var _brighter=1/_darker;var reI=\"\\\\s*([+-]?\\\\d+)\\\\s*\",reN=\"\\\\s*([+-]?\\\\d*\\\\.?\\\\d+(?:[eE][+-]?\\\\d+)?)\\\\s*\",reP=\"\\\\s*([+-]?\\\\d*\\\\.?\\\\d+(?:[eE][+-]?\\\\d+)?)%\\\\s*\",reHex3=/^#([0-9a-f]{3})$/,reHex6=/^#([0-9a-f]{6})$/,reRgbInteger=new RegExp(\"^rgb\\\\(\"+[reI,reI,reI]+\"\\\\)$\"),reRgbPercent=new RegExp(\"^rgb\\\\(\"+[reP,reP,reP]+\"\\\\)$\"),reRgbaInteger=new RegExp(\"^rgba\\\\(\"+[reI,reI,reI,reN]+\"\\\\)$\"),reRgbaPercent=new RegExp(\"^rgba\\\\(\"+[reP,reP,reP,reN]+\"\\\\)$\"),reHslPercent=new RegExp(\"^hsl\\\\(\"+[reN,reP,reP]+\"\\\\)$\"),reHslaPercent=new RegExp(\"^hsla\\\\(\"+[reN,reP,reP,reN]+\"\\\\)$\");var named={aliceblue:0xf0f8ff,antiquewhite:0xfaebd7,aqua:0x00ffff,aquamarine:0x7fffd4,azure:0xf0ffff,beige:0xf5f5dc,bisque:0xffe4c4,black:0x000000,blanchedalmond:0xffebcd,blue:0x0000ff,blueviolet:0x8a2be2,brown:0xa52a2a,burlywood:0xdeb887,cadetblue:0x5f9ea0,chartreuse:0x7fff00,chocolate:0xd2691e,coral:0xff7f50,cornflowerblue:0x6495ed,cornsilk:0xfff8dc,crimson:0xdc143c,cyan:0x00ffff,darkblue:0x00008b,darkcyan:0x008b8b,darkgoldenrod:0xb8860b,darkgray:0xa9a9a9,darkgreen:0x006400,darkgrey:0xa9a9a9,darkkhaki:0xbdb76b,darkmagenta:0x8b008b,darkolivegreen:0x556b2f,darkorange:0xff8c00,darkorchid:0x9932cc,darkred:0x8b0000,darksalmon:0xe9967a,darkseagreen:0x8fbc8f,darkslateblue:0x483d8b,darkslategray:0x2f4f4f,darkslategrey:0x2f4f4f,darkturquoise:0x00ced1,darkviolet:0x9400d3,deeppink:0xff1493,deepskyblue:0x00bfff,dimgray:0x696969,dimgrey:0x696969,dodgerblue:0x1e90ff,firebrick:0xb22222,floralwhite:0xfffaf0,forestgreen:0x228b22,fuchsia:0xff00ff,gainsboro:0xdcdcdc,ghostwhite:0xf8f8ff,gold:0xffd700,goldenrod:0xdaa520,gray:0x808080,green:0x008000,greenyellow:0xadff2f,grey:0x808080,honeydew:0xf0fff0,hotpink:0xff69b4,indianred:0xcd5c5c,indigo:0x4b0082,ivory:0xfffff0,khaki:0xf0e68c,lavender:0xe6e6fa,lavenderblush:0xfff0f5,lawngreen:0x7cfc00,lemonchiffon:0xfffacd,lightblue:0xadd8e6,lightcoral:0xf08080,lightcyan:0xe0ffff,lightgoldenrodyellow:0xfafad2,lightgray:0xd3d3d3,lightgreen:0x90ee90,lightgrey:0xd3d3d3,lightpink:0xffb6c1,lightsalmon:0xffa07a,lightseagreen:0x20b2aa,lightskyblue:0x87cefa,lightslategray:0x778899,lightslategrey:0x778899,lightsteelblue:0xb0c4de,lightyellow:0xffffe0,lime:0x00ff00,limegreen:0x32cd32,linen:0xfaf0e6,magenta:0xff00ff,maroon:0x800000,mediumaquamarine:0x66cdaa,mediumblue:0x0000cd,mediumorchid:0xba55d3,mediumpurple:0x9370db,mediumseagreen:0x3cb371,mediumslateblue:0x7b68ee,mediumspringgreen:0x00fa9a,mediumturquoise:0x48d1cc,mediumvioletred:0xc71585,midnightblue:0x191970,mintcream:0xf5fffa,mistyrose:0xffe4e1,moccasin:0xffe4b5,navajowhite:0xffdead,navy:0x000080,oldlace:0xfdf5e6,olive:0x808000,olivedrab:0x6b8e23,orange:0xffa500,orangered:0xff4500,orchid:0xda70d6,palegoldenrod:0xeee8aa,palegreen:0x98fb98,paleturquoise:0xafeeee,palevioletred:0xdb7093,papayawhip:0xffefd5,peachpuff:0xffdab9,peru:0xcd853f,pink:0xffc0cb,plum:0xdda0dd,powderblue:0xb0e0e6,purple:0x800080,rebeccapurple:0x663399,red:0xff0000,rosybrown:0xbc8f8f,royalblue:0x4169e1,saddlebrown:0x8b4513,salmon:0xfa8072,sandybrown:0xf4a460,seagreen:0x2e8b57,seashell:0xfff5ee,sienna:0xa0522d,silver:0xc0c0c0,skyblue:0x87ceeb,slateblue:0x6a5acd,slategray:0x708090,slategrey:0x708090,snow:0xfffafa,springgreen:0x00ff7f,steelblue:0x4682b4,tan:0xd2b48c,teal:0x008080,thistle:0xd8bfd8,tomato:0xff6347,turquoise:0x40e0d0,violet:0xee82ee,wheat:0xf5deb3,white:0xffffff,whitesmoke:0xf5f5f5,yellow:0xffff00,yellowgreen:0x9acd32};define(Color,color,{displayable:function displayable(){return this.rgb().displayable();},hex:function hex(){return this.rgb().hex();},toString:function toString(){return this.rgb()+\"\";}});function color(format){var m;format=(format+\"\").trim().toLowerCase();return(m=reHex3.exec(format))?(m=parseInt(m[1],16),new Rgb(m>>8&0xf|m>>4&0x0f0,m>>4&0xf|m&0xf0,(m&0xf)<<4|m&0xf,1)// #f00\n):(m=reHex6.exec(format))?rgbn(parseInt(m[1],16))// #ff0000\n:(m=reRgbInteger.exec(format))?new Rgb(m[1],m[2],m[3],1)// rgb(255, 0, 0)\n:(m=reRgbPercent.exec(format))?new Rgb(m[1]*255/100,m[2]*255/100,m[3]*255/100,1)// rgb(100%, 0%, 0%)\n:(m=reRgbaInteger.exec(format))?rgba(m[1],m[2],m[3],m[4])// rgba(255, 0, 0, 1)\n:(m=reRgbaPercent.exec(format))?rgba(m[1]*255/100,m[2]*255/100,m[3]*255/100,m[4])// rgb(100%, 0%, 0%, 1)\n:(m=reHslPercent.exec(format))?hsla(m[1],m[2]/100,m[3]/100,1)// hsl(120, 50%, 50%)\n:(m=reHslaPercent.exec(format))?hsla(m[1],m[2]/100,m[3]/100,m[4])// hsla(120, 50%, 50%, 1)\n:named.hasOwnProperty(format)?rgbn(named[format]):format===\"transparent\"?new Rgb(NaN,NaN,NaN,0):null;}function rgbn(n){return new Rgb(n>>16&0xff,n>>8&0xff,n&0xff,1);}function rgba(r,g,b,a){if(a<=0)r=g=b=NaN;return new Rgb(r,g,b,a);}function rgbConvert(o){if(!(o instanceof Color))o=color(o);if(!o)return new Rgb();o=o.rgb();return new Rgb(o.r,o.g,o.b,o.opacity);}function rgb(r,g,b,opacity){return arguments.length===1?rgbConvert(r):new Rgb(r,g,b,opacity==null?1:opacity);}function Rgb(r,g,b,opacity){this.r=+r;this.g=+g;this.b=+b;this.opacity=+opacity;}define(Rgb,rgb,extend(Color,{brighter:function brighter(k){k=k==null?_brighter:Math.pow(_brighter,k);return new Rgb(this.r*k,this.g*k,this.b*k,this.opacity);},darker:function darker(k){k=k==null?_darker:Math.pow(_darker,k);return new Rgb(this.r*k,this.g*k,this.b*k,this.opacity);},rgb:function rgb(){return this;},displayable:function displayable(){return 0<=this.r&&this.r<=255&&0<=this.g&&this.g<=255&&0<=this.b&&this.b<=255&&0<=this.opacity&&this.opacity<=1;},hex:function hex(){return\"#\"+_hex(this.r)+_hex(this.g)+_hex(this.b);},toString:function toString(){var a=this.opacity;a=isNaN(a)?1:Math.max(0,Math.min(1,a));return(a===1?\"rgb(\":\"rgba(\")+Math.max(0,Math.min(255,Math.round(this.r)||0))+\", \"+Math.max(0,Math.min(255,Math.round(this.g)||0))+\", \"+Math.max(0,Math.min(255,Math.round(this.b)||0))+(a===1?\")\":\", \"+a+\")\");}}));function _hex(value){value=Math.max(0,Math.min(255,Math.round(value)||0));return(value<16?\"0\":\"\")+value.toString(16);}function hsla(h,s,l,a){if(a<=0)h=s=l=NaN;else if(l<=0||l>=1)h=s=NaN;else if(s<=0)h=NaN;return new Hsl(h,s,l,a);}function hslConvert(o){if(o instanceof Hsl)return new Hsl(o.h,o.s,o.l,o.opacity);if(!(o instanceof Color))o=color(o);if(!o)return new Hsl();if(o instanceof Hsl)return o;o=o.rgb();var r=o.r/255,g=o.g/255,b=o.b/255,min=Math.min(r,g,b),max=Math.max(r,g,b),h=NaN,s=max-min,l=(max+min)/2;if(s){if(r===max)h=(g-b)/s+(g<b)*6;else if(g===max)h=(b-r)/s+2;else h=(r-g)/s+4;s/=l<0.5?max+min:2-max-min;h*=60;}else{s=l>0&&l<1?0:h;}return new Hsl(h,s,l,o.opacity);}function hsl(h,s,l,opacity){return arguments.length===1?hslConvert(h):new Hsl(h,s,l,opacity==null?1:opacity);}function Hsl(h,s,l,opacity){this.h=+h;this.s=+s;this.l=+l;this.opacity=+opacity;}define(Hsl,hsl,extend(Color,{brighter:function brighter(k){k=k==null?_brighter:Math.pow(_brighter,k);return new Hsl(this.h,this.s,this.l*k,this.opacity);},darker:function darker(k){k=k==null?_darker:Math.pow(_darker,k);return new Hsl(this.h,this.s,this.l*k,this.opacity);},rgb:function rgb(){var h=this.h%360+(this.h<0)*360,s=isNaN(h)||isNaN(this.s)?0:this.s,l=this.l,m2=l+(l<0.5?l:1-l)*s,m1=2*l-m2;return new Rgb(hsl2rgb(h>=240?h-240:h+120,m1,m2),hsl2rgb(h,m1,m2),hsl2rgb(h<120?h+240:h-120,m1,m2),this.opacity);},displayable:function displayable(){return(0<=this.s&&this.s<=1||isNaN(this.s))&&0<=this.l&&this.l<=1&&0<=this.opacity&&this.opacity<=1;}}));/* From FvD 13.37, CSS Color Module Level 3 */function hsl2rgb(h,m1,m2){return(h<60?m1+(m2-m1)*h/60:h<180?m2:h<240?m1+(m2-m1)*(240-h)/60:m1)*255;}var deg2rad=Math.PI/180;var rad2deg=180/Math.PI;// https://beta.observablehq.com/@mbostock/lab-and-rgb\nvar K=18,Xn=0.96422,Yn=1,Zn=0.82521,t0=4/29,t1=6/29,t2=3*t1*t1,t3=t1*t1*t1;function labConvert(o){if(o instanceof Lab)return new Lab(o.l,o.a,o.b,o.opacity);if(o instanceof Hcl){if(isNaN(o.h))return new Lab(o.l,0,0,o.opacity);var h=o.h*deg2rad;return new Lab(o.l,Math.cos(h)*o.c,Math.sin(h)*o.c,o.opacity);}if(!(o instanceof Rgb))o=rgbConvert(o);var r=rgb2lrgb(o.r),g=rgb2lrgb(o.g),b=rgb2lrgb(o.b),y=xyz2lab((0.2225045*r+0.7168786*g+0.0606169*b)/Yn),x,z;if(r===g&&g===b)x=z=y;else{x=xyz2lab((0.4360747*r+0.3850649*g+0.1430804*b)/Xn);z=xyz2lab((0.0139322*r+0.0971045*g+0.7141733*b)/Zn);}return new Lab(116*y-16,500*(x-y),200*(y-z),o.opacity);}function gray(l,opacity){return new Lab(l,0,0,opacity==null?1:opacity);}function lab(l,a,b,opacity){return arguments.length===1?labConvert(l):new Lab(l,a,b,opacity==null?1:opacity);}function Lab(l,a,b,opacity){this.l=+l;this.a=+a;this.b=+b;this.opacity=+opacity;}define(Lab,lab,extend(Color,{brighter:function brighter(k){return new Lab(this.l+K*(k==null?1:k),this.a,this.b,this.opacity);},darker:function darker(k){return new Lab(this.l-K*(k==null?1:k),this.a,this.b,this.opacity);},rgb:function rgb(){var y=(this.l+16)/116,x=isNaN(this.a)?y:y+this.a/500,z=isNaN(this.b)?y:y-this.b/200;x=Xn*lab2xyz(x);y=Yn*lab2xyz(y);z=Zn*lab2xyz(z);return new Rgb(lrgb2rgb(3.1338561*x-1.6168667*y-0.4906146*z),lrgb2rgb(-0.9787684*x+1.9161415*y+0.0334540*z),lrgb2rgb(0.0719453*x-0.2289914*y+1.4052427*z),this.opacity);}}));function xyz2lab(t){return t>t3?Math.pow(t,1/3):t/t2+t0;}function lab2xyz(t){return t>t1?t*t*t:t2*(t-t0);}function lrgb2rgb(x){return 255*(x<=0.0031308?12.92*x:1.055*Math.pow(x,1/2.4)-0.055);}function rgb2lrgb(x){return(x/=255)<=0.04045?x/12.92:Math.pow((x+0.055)/1.055,2.4);}function hclConvert(o){if(o instanceof Hcl)return new Hcl(o.h,o.c,o.l,o.opacity);if(!(o instanceof Lab))o=labConvert(o);if(o.a===0&&o.b===0)return new Hcl(NaN,0,o.l,o.opacity);var h=Math.atan2(o.b,o.a)*rad2deg;return new Hcl(h<0?h+360:h,Math.sqrt(o.a*o.a+o.b*o.b),o.l,o.opacity);}function lch(l,c,h,opacity){return arguments.length===1?hclConvert(l):new Hcl(h,c,l,opacity==null?1:opacity);}function hcl(h,c,l,opacity){return arguments.length===1?hclConvert(h):new Hcl(h,c,l,opacity==null?1:opacity);}function Hcl(h,c,l,opacity){this.h=+h;this.c=+c;this.l=+l;this.opacity=+opacity;}define(Hcl,hcl,extend(Color,{brighter:function brighter(k){return new Hcl(this.h,this.c,this.l+K*(k==null?1:k),this.opacity);},darker:function darker(k){return new Hcl(this.h,this.c,this.l-K*(k==null?1:k),this.opacity);},rgb:function rgb(){return labConvert(this).rgb();}}));var A=-0.14861,B=+1.78277,C=-0.29227,D=-0.90649,E=+1.97294,ED=E*D,EB=E*B,BC_DA=B*C-D*A;function cubehelixConvert(o){if(o instanceof Cubehelix)return new Cubehelix(o.h,o.s,o.l,o.opacity);if(!(o instanceof Rgb))o=rgbConvert(o);var r=o.r/255,g=o.g/255,b=o.b/255,l=(BC_DA*b+ED*r-EB*g)/(BC_DA+ED-EB),bl=b-l,k=(E*(g-l)-C*bl)/D,s=Math.sqrt(k*k+bl*bl)/(E*l*(1-l)),// NaN if l=0 or l=1\nh=s?Math.atan2(k,bl)*rad2deg-120:NaN;return new Cubehelix(h<0?h+360:h,s,l,o.opacity);}function cubehelix(h,s,l,opacity){return arguments.length===1?cubehelixConvert(h):new Cubehelix(h,s,l,opacity==null?1:opacity);}function Cubehelix(h,s,l,opacity){this.h=+h;this.s=+s;this.l=+l;this.opacity=+opacity;}define(Cubehelix,cubehelix,extend(Color,{brighter:function brighter(k){k=k==null?_brighter:Math.pow(_brighter,k);return new Cubehelix(this.h,this.s,this.l*k,this.opacity);},darker:function darker(k){k=k==null?_darker:Math.pow(_darker,k);return new Cubehelix(this.h,this.s,this.l*k,this.opacity);},rgb:function rgb(){var h=isNaN(this.h)?0:(this.h+120)*deg2rad,l=+this.l,a=isNaN(this.s)?0:this.s*l*(1-l),cosh=Math.cos(h),sinh=Math.sin(h);return new Rgb(255*(l+a*(A*cosh+B*sinh)),255*(l+a*(C*cosh+D*sinh)),255*(l+a*(E*cosh)),this.opacity);}}));function basis(t1,v0,v1,v2,v3){var t2=t1*t1,t3=t2*t1;return((1-3*t1+3*t2-t3)*v0+(4-6*t2+3*t3)*v1+(1+3*t1+3*t2-3*t3)*v2+t3*v3)/6;}function basis$1(values){var n=values.length-1;return function(t){var i=t<=0?t=0:t>=1?(t=1,n-1):Math.floor(t*n),v1=values[i],v2=values[i+1],v0=i>0?values[i-1]:2*v1-v2,v3=i<n-1?values[i+2]:2*v2-v1;return basis((t-i/n)*n,v0,v1,v2,v3);};}function basisClosed(values){var n=values.length;return function(t){var i=Math.floor(((t%=1)<0?++t:t)*n),v0=values[(i+n-1)%n],v1=values[i%n],v2=values[(i+1)%n],v3=values[(i+2)%n];return basis((t-i/n)*n,v0,v1,v2,v3);};}function constant$3(x){return function(){return x;};}function linear(a,d){return function(t){return a+t*d;};}function exponential(a,b,y){return a=Math.pow(a,y),b=Math.pow(b,y)-a,y=1/y,function(t){return Math.pow(a+t*b,y);};}function hue(a,b){var d=b-a;return d?linear(a,d>180||d<-180?d-360*Math.round(d/360):d):constant$3(isNaN(a)?b:a);}function gamma(y){return(y=+y)===1?nogamma:function(a,b){return b-a?exponential(a,b,y):constant$3(isNaN(a)?b:a);};}function nogamma(a,b){var d=b-a;return d?linear(a,d):constant$3(isNaN(a)?b:a);}var interpolateRgb=function rgbGamma(y){var color$$1=gamma(y);function rgb$$1(start,end){var r=color$$1((start=rgb(start)).r,(end=rgb(end)).r),g=color$$1(start.g,end.g),b=color$$1(start.b,end.b),opacity=nogamma(start.opacity,end.opacity);return function(t){start.r=r(t);start.g=g(t);start.b=b(t);start.opacity=opacity(t);return start+\"\";};}rgb$$1.gamma=rgbGamma;return rgb$$1;}(1);function rgbSpline(spline){return function(colors){var n=colors.length,r=new Array(n),g=new Array(n),b=new Array(n),i,color$$1;for(i=0;i<n;++i){color$$1=rgb(colors[i]);r[i]=color$$1.r||0;g[i]=color$$1.g||0;b[i]=color$$1.b||0;}r=spline(r);g=spline(g);b=spline(b);color$$1.opacity=1;return function(t){color$$1.r=r(t);color$$1.g=g(t);color$$1.b=b(t);return color$$1+\"\";};};}var rgbBasis=rgbSpline(basis$1);var rgbBasisClosed=rgbSpline(basisClosed);function array$1(a,b){var nb=b?b.length:0,na=a?Math.min(nb,a.length):0,x=new Array(na),c=new Array(nb),i;for(i=0;i<na;++i){x[i]=interpolateValue(a[i],b[i]);}for(;i<nb;++i){c[i]=b[i];}return function(t){for(i=0;i<na;++i){c[i]=x[i](t);}return c;};}function date(a,b){var d=new Date();return a=+a,b-=a,function(t){return d.setTime(a+b*t),d;};}function reinterpolate(a,b){return a=+a,b-=a,function(t){return a+b*t;};}function object(a,b){var i={},c={},k;if(a===null||(typeof a===\"undefined\"?\"undefined\":_typeof(a))!==\"object\")a={};if(b===null||(typeof b===\"undefined\"?\"undefined\":_typeof(b))!==\"object\")b={};for(k in b){if(k in a){i[k]=interpolateValue(a[k],b[k]);}else{c[k]=b[k];}}return function(t){for(k in i){c[k]=i[k](t);}return c;};}var reA=/[-+]?(?:\\d+\\.?\\d*|\\.?\\d+)(?:[eE][-+]?\\d+)?/g,reB=new RegExp(reA.source,\"g\");function zero(b){return function(){return b;};}function one(b){return function(t){return b(t)+\"\";};}function interpolateString(a,b){var bi=reA.lastIndex=reB.lastIndex=0,// scan index for next number in b\nam,// current match in a\nbm,// current match in b\nbs,// string preceding current number in b, if any\ni=-1,// index in s\ns=[],// string constants and placeholders\nq=[];// number interpolators\n// Coerce inputs to strings.\na=a+\"\",b=b+\"\";// Interpolate pairs of numbers in a & b.\nwhile((am=reA.exec(a))&&(bm=reB.exec(b))){if((bs=bm.index)>bi){// a string precedes the next number in b\nbs=b.slice(bi,bs);if(s[i])s[i]+=bs;// coalesce with previous string\nelse s[++i]=bs;}if((am=am[0])===(bm=bm[0])){// numbers in a & b match\nif(s[i])s[i]+=bm;// coalesce with previous string\nelse s[++i]=bm;}else{// interpolate non-matching numbers\ns[++i]=null;q.push({i:i,x:reinterpolate(am,bm)});}bi=reB.lastIndex;}// Add remains of b.\nif(bi<b.length){bs=b.slice(bi);if(s[i])s[i]+=bs;// coalesce with previous string\nelse s[++i]=bs;}// Special optimization for only a single match.\n// Otherwise, interpolate each of the numbers and rejoin the string.\nreturn s.length<2?q[0]?one(q[0].x):zero(b):(b=q.length,function(t){for(var i=0,o;i<b;++i){s[(o=q[i]).i]=o.x(t);}return s.join(\"\");});}function interpolateValue(a,b){var t=typeof b===\"undefined\"?\"undefined\":_typeof(b),c;return b==null||t===\"boolean\"?constant$3(b):(t===\"number\"?reinterpolate:t===\"string\"?(c=color(b))?(b=c,interpolateRgb):interpolateString:b instanceof color?interpolateRgb:b instanceof Date?date:Array.isArray(b)?array$1:typeof b.valueOf!==\"function\"&&typeof b.toString!==\"function\"||isNaN(b)?object:reinterpolate)(a,b);}function interpolateRound(a,b){return a=+a,b-=a,function(t){return Math.round(a+b*t);};}var degrees=180/Math.PI;var identity$2={translateX:0,translateY:0,rotate:0,skewX:0,scaleX:1,scaleY:1};function decompose(a,b,c,d,e,f){var scaleX,scaleY,skewX;if(scaleX=Math.sqrt(a*a+b*b))a/=scaleX,b/=scaleX;if(skewX=a*c+b*d)c-=a*skewX,d-=b*skewX;if(scaleY=Math.sqrt(c*c+d*d))c/=scaleY,d/=scaleY,skewX/=scaleY;if(a*d<b*c)a=-a,b=-b,skewX=-skewX,scaleX=-scaleX;return{translateX:e,translateY:f,rotate:Math.atan2(b,a)*degrees,skewX:Math.atan(skewX)*degrees,scaleX:scaleX,scaleY:scaleY};}var cssNode,cssRoot,cssView,svgNode;function parseCss(value){if(value===\"none\")return identity$2;if(!cssNode)cssNode=document.createElement(\"DIV\"),cssRoot=document.documentElement,cssView=document.defaultView;cssNode.style.transform=value;value=cssView.getComputedStyle(cssRoot.appendChild(cssNode),null).getPropertyValue(\"transform\");cssRoot.removeChild(cssNode);value=value.slice(7,-1).split(\",\");return decompose(+value[0],+value[1],+value[2],+value[3],+value[4],+value[5]);}function parseSvg(value){if(value==null)return identity$2;if(!svgNode)svgNode=document.createElementNS(\"http://www.w3.org/2000/svg\",\"g\");svgNode.setAttribute(\"transform\",value);if(!(value=svgNode.transform.baseVal.consolidate()))return identity$2;value=value.matrix;return decompose(value.a,value.b,value.c,value.d,value.e,value.f);}function interpolateTransform(parse,pxComma,pxParen,degParen){function pop(s){return s.length?s.pop()+\" \":\"\";}function translate(xa,ya,xb,yb,s,q){if(xa!==xb||ya!==yb){var i=s.push(\"translate(\",null,pxComma,null,pxParen);q.push({i:i-4,x:reinterpolate(xa,xb)},{i:i-2,x:reinterpolate(ya,yb)});}else if(xb||yb){s.push(\"translate(\"+xb+pxComma+yb+pxParen);}}function rotate(a,b,s,q){if(a!==b){if(a-b>180)b+=360;else if(b-a>180)a+=360;// shortest path\nq.push({i:s.push(pop(s)+\"rotate(\",null,degParen)-2,x:reinterpolate(a,b)});}else if(b){s.push(pop(s)+\"rotate(\"+b+degParen);}}function skewX(a,b,s,q){if(a!==b){q.push({i:s.push(pop(s)+\"skewX(\",null,degParen)-2,x:reinterpolate(a,b)});}else if(b){s.push(pop(s)+\"skewX(\"+b+degParen);}}function scale(xa,ya,xb,yb,s,q){if(xa!==xb||ya!==yb){var i=s.push(pop(s)+\"scale(\",null,\",\",null,\")\");q.push({i:i-4,x:reinterpolate(xa,xb)},{i:i-2,x:reinterpolate(ya,yb)});}else if(xb!==1||yb!==1){s.push(pop(s)+\"scale(\"+xb+\",\"+yb+\")\");}}return function(a,b){var s=[],// string constants and placeholders\nq=[];// number interpolators\na=parse(a),b=parse(b);translate(a.translateX,a.translateY,b.translateX,b.translateY,s,q);rotate(a.rotate,b.rotate,s,q);skewX(a.skewX,b.skewX,s,q);scale(a.scaleX,a.scaleY,b.scaleX,b.scaleY,s,q);a=b=null;// gc\nreturn function(t){var i=-1,n=q.length,o;while(++i<n){s[(o=q[i]).i]=o.x(t);}return s.join(\"\");};};}var interpolateTransformCss=interpolateTransform(parseCss,\"px, \",\"px)\",\"deg)\");var interpolateTransformSvg=interpolateTransform(parseSvg,\", \",\")\",\")\");var rho=Math.SQRT2,rho2=2,rho4=4,epsilon2=1e-12;function cosh(x){return((x=Math.exp(x))+1/x)/2;}function sinh(x){return((x=Math.exp(x))-1/x)/2;}function tanh(x){return((x=Math.exp(2*x))-1)/(x+1);}// p0 = [ux0, uy0, w0]\n// p1 = [ux1, uy1, w1]\nfunction interpolateZoom(p0,p1){var ux0=p0[0],uy0=p0[1],w0=p0[2],ux1=p1[0],uy1=p1[1],w1=p1[2],dx=ux1-ux0,dy=uy1-uy0,d2=dx*dx+dy*dy,i,S;// Special case for u0 ≅ u1.\nif(d2<epsilon2){S=Math.log(w1/w0)/rho;i=function i(t){return[ux0+t*dx,uy0+t*dy,w0*Math.exp(rho*t*S)];};}// General case.\nelse{var d1=Math.sqrt(d2),b0=(w1*w1-w0*w0+rho4*d2)/(2*w0*rho2*d1),b1=(w1*w1-w0*w0-rho4*d2)/(2*w1*rho2*d1),r0=Math.log(Math.sqrt(b0*b0+1)-b0),r1=Math.log(Math.sqrt(b1*b1+1)-b1);S=(r1-r0)/rho;i=function i(t){var s=t*S,coshr0=cosh(r0),u=w0/(rho2*d1)*(coshr0*tanh(rho*s+r0)-sinh(r0));return[ux0+u*dx,uy0+u*dy,w0*coshr0/cosh(rho*s+r0)];};}i.duration=S*1000;return i;}function hsl$1(hue$$1){return function(start,end){var h=hue$$1((start=hsl(start)).h,(end=hsl(end)).h),s=nogamma(start.s,end.s),l=nogamma(start.l,end.l),opacity=nogamma(start.opacity,end.opacity);return function(t){start.h=h(t);start.s=s(t);start.l=l(t);start.opacity=opacity(t);return start+\"\";};};}var hsl$2=hsl$1(hue);var hslLong=hsl$1(nogamma);function lab$1(start,end){var l=nogamma((start=lab(start)).l,(end=lab(end)).l),a=nogamma(start.a,end.a),b=nogamma(start.b,end.b),opacity=nogamma(start.opacity,end.opacity);return function(t){start.l=l(t);start.a=a(t);start.b=b(t);start.opacity=opacity(t);return start+\"\";};}function hcl$1(hue$$1){return function(start,end){var h=hue$$1((start=hcl(start)).h,(end=hcl(end)).h),c=nogamma(start.c,end.c),l=nogamma(start.l,end.l),opacity=nogamma(start.opacity,end.opacity);return function(t){start.h=h(t);start.c=c(t);start.l=l(t);start.opacity=opacity(t);return start+\"\";};};}var hcl$2=hcl$1(hue);var hclLong=hcl$1(nogamma);function cubehelix$1(hue$$1){return function cubehelixGamma(y){y=+y;function cubehelix$$1(start,end){var h=hue$$1((start=cubehelix(start)).h,(end=cubehelix(end)).h),s=nogamma(start.s,end.s),l=nogamma(start.l,end.l),opacity=nogamma(start.opacity,end.opacity);return function(t){start.h=h(t);start.s=s(t);start.l=l(Math.pow(t,y));start.opacity=opacity(t);return start+\"\";};}cubehelix$$1.gamma=cubehelixGamma;return cubehelix$$1;}(1);}var cubehelix$2=cubehelix$1(hue);var cubehelixLong=cubehelix$1(nogamma);function piecewise(interpolate,values){var i=0,n=values.length-1,v=values[0],I=new Array(n<0?0:n);while(i<n){I[i]=interpolate(v,v=values[++i]);}return function(t){var i=Math.max(0,Math.min(n-1,Math.floor(t*=n)));return I[i](t-i);};}function quantize(interpolator,n){var samples=new Array(n);for(var i=0;i<n;++i){samples[i]=interpolator(i/(n-1));}return samples;}var frame=0,// is an animation frame pending?\ntimeout=0,// is a timeout pending?\ninterval=0,// are any timers active?\npokeDelay=1000,// how frequently we check for clock skew\ntaskHead,taskTail,clockLast=0,clockNow=0,clockSkew=0,clock=(typeof performance===\"undefined\"?\"undefined\":_typeof(performance))===\"object\"&&performance.now?performance:Date,setFrame=(typeof window===\"undefined\"?\"undefined\":_typeof(window))===\"object\"&&window.requestAnimationFrame?window.requestAnimationFrame.bind(window):function(f){setTimeout(f,17);};function now(){return clockNow||(setFrame(clearNow),clockNow=clock.now()+clockSkew);}function clearNow(){clockNow=0;}function Timer(){this._call=this._time=this._next=null;}Timer.prototype=timer.prototype={constructor:Timer,restart:function restart(callback,delay,time){if(typeof callback!==\"function\")throw new TypeError(\"callback is not a function\");time=(time==null?now():+time)+(delay==null?0:+delay);if(!this._next&&taskTail!==this){if(taskTail)taskTail._next=this;else taskHead=this;taskTail=this;}this._call=callback;this._time=time;sleep();},stop:function stop(){if(this._call){this._call=null;this._time=Infinity;sleep();}}};function timer(callback,delay,time){var t=new Timer();t.restart(callback,delay,time);return t;}function timerFlush(){now();// Get the current time, if not already set.\n++frame;// Pretend we’ve set an alarm, if we haven’t already.\nvar t=taskHead,e;while(t){if((e=clockNow-t._time)>=0)t._call.call(null,e);t=t._next;}--frame;}function wake(){clockNow=(clockLast=clock.now())+clockSkew;frame=timeout=0;try{timerFlush();}finally{frame=0;nap();clockNow=0;}}function poke(){var now=clock.now(),delay=now-clockLast;if(delay>pokeDelay)clockSkew-=delay,clockLast=now;}function nap(){var t0,t1=taskHead,t2,time=Infinity;while(t1){if(t1._call){if(time>t1._time)time=t1._time;t0=t1,t1=t1._next;}else{t2=t1._next,t1._next=null;t1=t0?t0._next=t2:taskHead=t2;}}taskTail=t0;sleep(time);}function sleep(time){if(frame)return;// Soonest alarm already set, or will be.\nif(timeout)timeout=clearTimeout(timeout);var delay=time-clockNow;// Strictly less than if we recomputed clockNow.\nif(delay>24){if(time<Infinity)timeout=setTimeout(wake,time-clock.now()-clockSkew);if(interval)interval=clearInterval(interval);}else{if(!interval)clockLast=clock.now(),interval=setInterval(poke,pokeDelay);frame=1,setFrame(wake);}}function timeout$1(callback,delay,time){var t=new Timer();delay=delay==null?0:+delay;t.restart(function(elapsed){t.stop();callback(elapsed+delay);},delay,time);return t;}function interval$1(callback,delay,time){var t=new Timer(),total=delay;if(delay==null)return t.restart(callback,delay,time),t;delay=+delay,time=time==null?now():+time;t.restart(function tick(elapsed){elapsed+=total;t.restart(tick,total+=delay,time);callback(elapsed);},delay,time);return t;}var emptyOn=dispatch(\"start\",\"end\",\"interrupt\");var emptyTween=[];var CREATED=0;var SCHEDULED=1;var STARTING=2;var STARTED=3;var RUNNING=4;var ENDING=5;var ENDED=6;function schedule(node,name,id,index,group,timing){var schedules=node.__transition;if(!schedules)node.__transition={};else if(id in schedules)return;create$1(node,id,{name:name,index:index,// For context during callback.\ngroup:group,// For context during callback.\non:emptyOn,tween:emptyTween,time:timing.time,delay:timing.delay,duration:timing.duration,ease:timing.ease,timer:null,state:CREATED});}function init(node,id){var schedule=get$1(node,id);if(schedule.state>CREATED)throw new Error(\"too late; already scheduled\");return schedule;}function set$1(node,id){var schedule=get$1(node,id);if(schedule.state>STARTING)throw new Error(\"too late; already started\");return schedule;}function get$1(node,id){var schedule=node.__transition;if(!schedule||!(schedule=schedule[id]))throw new Error(\"transition not found\");return schedule;}function create$1(node,id,self){var schedules=node.__transition,tween;// Initialize the self timer when the transition is created.\n// Note the actual delay is not known until the first callback!\nschedules[id]=self;self.timer=timer(schedule,0,self.time);function schedule(elapsed){self.state=SCHEDULED;self.timer.restart(start,self.delay,self.time);// If the elapsed delay is less than our first sleep, start immediately.\nif(self.delay<=elapsed)start(elapsed-self.delay);}function start(elapsed){var i,j,n,o;// If the state is not SCHEDULED, then we previously errored on start.\nif(self.state!==SCHEDULED)return stop();for(i in schedules){o=schedules[i];if(o.name!==self.name)continue;// While this element already has a starting transition during this frame,\n// defer starting an interrupting transition until that transition has a\n// chance to tick (and possibly end); see d3/d3-transition#54!\nif(o.state===STARTED)return timeout$1(start);// Interrupt the active transition, if any.\n// Dispatch the interrupt event.\nif(o.state===RUNNING){o.state=ENDED;o.timer.stop();o.on.call(\"interrupt\",node,node.__data__,o.index,o.group);delete schedules[i];}// Cancel any pre-empted transitions. No interrupt event is dispatched\n// because the cancelled transitions never started. Note that this also\n// removes this transition from the pending list!\nelse if(+i<id){o.state=ENDED;o.timer.stop();delete schedules[i];}}// Defer the first tick to end of the current frame; see d3/d3#1576.\n// Note the transition may be canceled after start and before the first tick!\n// Note this must be scheduled before the start event; see d3/d3-transition#16!\n// Assuming this is successful, subsequent callbacks go straight to tick.\ntimeout$1(function(){if(self.state===STARTED){self.state=RUNNING;self.timer.restart(tick,self.delay,self.time);tick(elapsed);}});// Dispatch the start event.\n// Note this must be done before the tween are initialized.\nself.state=STARTING;self.on.call(\"start\",node,node.__data__,self.index,self.group);if(self.state!==STARTING)return;// interrupted\nself.state=STARTED;// Initialize the tween, deleting null tween.\ntween=new Array(n=self.tween.length);for(i=0,j=-1;i<n;++i){if(o=self.tween[i].value.call(node,node.__data__,self.index,self.group)){tween[++j]=o;}}tween.length=j+1;}function tick(elapsed){var t=elapsed<self.duration?self.ease.call(null,elapsed/self.duration):(self.timer.restart(stop),self.state=ENDING,1),i=-1,n=tween.length;while(++i<n){tween[i].call(null,t);}// Dispatch the end event.\nif(self.state===ENDING){self.on.call(\"end\",node,node.__data__,self.index,self.group);stop();}}function stop(){self.state=ENDED;self.timer.stop();delete schedules[id];for(var i in schedules){return;}// eslint-disable-line no-unused-vars\ndelete node.__transition;}}function interrupt(node,name){var schedules=node.__transition,schedule$$1,active,empty=true,i;if(!schedules)return;name=name==null?null:name+\"\";for(i in schedules){if((schedule$$1=schedules[i]).name!==name){empty=false;continue;}active=schedule$$1.state>STARTING&&schedule$$1.state<ENDING;schedule$$1.state=ENDED;schedule$$1.timer.stop();if(active)schedule$$1.on.call(\"interrupt\",node,node.__data__,schedule$$1.index,schedule$$1.group);delete schedules[i];}if(empty)delete node.__transition;}function selection_interrupt(name){return this.each(function(){interrupt(this,name);});}function tweenRemove(id,name){var tween0,tween1;return function(){var schedule$$1=set$1(this,id),tween=schedule$$1.tween;// If this node shared tween with the previous node,\n// just assign the updated shared tween and we’re done!\n// Otherwise, copy-on-write.\nif(tween!==tween0){tween1=tween0=tween;for(var i=0,n=tween1.length;i<n;++i){if(tween1[i].name===name){tween1=tween1.slice();tween1.splice(i,1);break;}}}schedule$$1.tween=tween1;};}function tweenFunction(id,name,value){var tween0,tween1;if(typeof value!==\"function\")throw new Error();return function(){var schedule$$1=set$1(this,id),tween=schedule$$1.tween;// If this node shared tween with the previous node,\n// just assign the updated shared tween and we’re done!\n// Otherwise, copy-on-write.\nif(tween!==tween0){tween1=(tween0=tween).slice();for(var t={name:name,value:value},i=0,n=tween1.length;i<n;++i){if(tween1[i].name===name){tween1[i]=t;break;}}if(i===n)tween1.push(t);}schedule$$1.tween=tween1;};}function transition_tween(name,value){var id=this._id;name+=\"\";if(arguments.length<2){var tween=get$1(this.node(),id).tween;for(var i=0,n=tween.length,t;i<n;++i){if((t=tween[i]).name===name){return t.value;}}return null;}return this.each((value==null?tweenRemove:tweenFunction)(id,name,value));}function tweenValue(transition,name,value){var id=transition._id;transition.each(function(){var schedule$$1=set$1(this,id);(schedule$$1.value||(schedule$$1.value={}))[name]=value.apply(this,arguments);});return function(node){return get$1(node,id).value[name];};}function interpolate(a,b){var c;return(typeof b===\"number\"?reinterpolate:b instanceof color?interpolateRgb:(c=color(b))?(b=c,interpolateRgb):interpolateString)(a,b);}function attrRemove$1(name){return function(){this.removeAttribute(name);};}function attrRemoveNS$1(fullname){return function(){this.removeAttributeNS(fullname.space,fullname.local);};}function attrConstant$1(name,interpolate$$1,value1){var value00,interpolate0;return function(){var value0=this.getAttribute(name);return value0===value1?null:value0===value00?interpolate0:interpolate0=interpolate$$1(value00=value0,value1);};}function attrConstantNS$1(fullname,interpolate$$1,value1){var value00,interpolate0;return function(){var value0=this.getAttributeNS(fullname.space,fullname.local);return value0===value1?null:value0===value00?interpolate0:interpolate0=interpolate$$1(value00=value0,value1);};}function attrFunction$1(name,interpolate$$1,value){var value00,value10,interpolate0;return function(){var value0,value1=value(this);if(value1==null)return void this.removeAttribute(name);value0=this.getAttribute(name);return value0===value1?null:value0===value00&&value1===value10?interpolate0:interpolate0=interpolate$$1(value00=value0,value10=value1);};}function attrFunctionNS$1(fullname,interpolate$$1,value){var value00,value10,interpolate0;return function(){var value0,value1=value(this);if(value1==null)return void this.removeAttributeNS(fullname.space,fullname.local);value0=this.getAttributeNS(fullname.space,fullname.local);return value0===value1?null:value0===value00&&value1===value10?interpolate0:interpolate0=interpolate$$1(value00=value0,value10=value1);};}function transition_attr(name,value){var fullname=namespace(name),i=fullname===\"transform\"?interpolateTransformSvg:interpolate;return this.attrTween(name,typeof value===\"function\"?(fullname.local?attrFunctionNS$1:attrFunction$1)(fullname,i,tweenValue(this,\"attr.\"+name,value)):value==null?(fullname.local?attrRemoveNS$1:attrRemove$1)(fullname):(fullname.local?attrConstantNS$1:attrConstant$1)(fullname,i,value+\"\"));}function attrTweenNS(fullname,value){function tween(){var node=this,i=value.apply(node,arguments);return i&&function(t){node.setAttributeNS(fullname.space,fullname.local,i(t));};}tween._value=value;return tween;}function attrTween(name,value){function tween(){var node=this,i=value.apply(node,arguments);return i&&function(t){node.setAttribute(name,i(t));};}tween._value=value;return tween;}function transition_attrTween(name,value){var key=\"attr.\"+name;if(arguments.length<2)return(key=this.tween(key))&&key._value;if(value==null)return this.tween(key,null);if(typeof value!==\"function\")throw new Error();var fullname=namespace(name);return this.tween(key,(fullname.local?attrTweenNS:attrTween)(fullname,value));}function delayFunction(id,value){return function(){init(this,id).delay=+value.apply(this,arguments);};}function delayConstant(id,value){return value=+value,function(){init(this,id).delay=value;};}function transition_delay(value){var id=this._id;return arguments.length?this.each((typeof value===\"function\"?delayFunction:delayConstant)(id,value)):get$1(this.node(),id).delay;}function durationFunction(id,value){return function(){set$1(this,id).duration=+value.apply(this,arguments);};}function durationConstant(id,value){return value=+value,function(){set$1(this,id).duration=value;};}function transition_duration(value){var id=this._id;return arguments.length?this.each((typeof value===\"function\"?durationFunction:durationConstant)(id,value)):get$1(this.node(),id).duration;}function easeConstant(id,value){if(typeof value!==\"function\")throw new Error();return function(){set$1(this,id).ease=value;};}function transition_ease(value){var id=this._id;return arguments.length?this.each(easeConstant(id,value)):get$1(this.node(),id).ease;}function transition_filter(match){if(typeof match!==\"function\")match=matcher$1(match);for(var groups=this._groups,m=groups.length,subgroups=new Array(m),j=0;j<m;++j){for(var group=groups[j],n=group.length,subgroup=subgroups[j]=[],node,i=0;i<n;++i){if((node=group[i])&&match.call(node,node.__data__,i,group)){subgroup.push(node);}}}return new Transition(subgroups,this._parents,this._name,this._id);}function transition_merge(transition$$1){if(transition$$1._id!==this._id)throw new Error();for(var groups0=this._groups,groups1=transition$$1._groups,m0=groups0.length,m1=groups1.length,m=Math.min(m0,m1),merges=new Array(m0),j=0;j<m;++j){for(var group0=groups0[j],group1=groups1[j],n=group0.length,merge=merges[j]=new Array(n),node,i=0;i<n;++i){if(node=group0[i]||group1[i]){merge[i]=node;}}}for(;j<m0;++j){merges[j]=groups0[j];}return new Transition(merges,this._parents,this._name,this._id);}function start(name){return(name+\"\").trim().split(/^|\\s+/).every(function(t){var i=t.indexOf(\".\");if(i>=0)t=t.slice(0,i);return!t||t===\"start\";});}function onFunction(id,name,listener){var on0,on1,sit=start(name)?init:set$1;return function(){var schedule$$1=sit(this,id),on=schedule$$1.on;// If this node shared a dispatch with the previous node,\n// just assign the updated shared dispatch and we’re done!\n// Otherwise, copy-on-write.\nif(on!==on0)(on1=(on0=on).copy()).on(name,listener);schedule$$1.on=on1;};}function transition_on(name,listener){var id=this._id;return arguments.length<2?get$1(this.node(),id).on.on(name):this.each(onFunction(id,name,listener));}function removeFunction(id){return function(){var parent=this.parentNode;for(var i in this.__transition){if(+i!==id)return;}if(parent)parent.removeChild(this);};}function transition_remove(){return this.on(\"end.remove\",removeFunction(this._id));}function transition_select(select$$1){var name=this._name,id=this._id;if(typeof select$$1!==\"function\")select$$1=selector(select$$1);for(var groups=this._groups,m=groups.length,subgroups=new Array(m),j=0;j<m;++j){for(var group=groups[j],n=group.length,subgroup=subgroups[j]=new Array(n),node,subnode,i=0;i<n;++i){if((node=group[i])&&(subnode=select$$1.call(node,node.__data__,i,group))){if(\"__data__\"in node)subnode.__data__=node.__data__;subgroup[i]=subnode;schedule(subgroup[i],name,id,i,subgroup,get$1(node,id));}}}return new Transition(subgroups,this._parents,name,id);}function transition_selectAll(select$$1){var name=this._name,id=this._id;if(typeof select$$1!==\"function\")select$$1=selectorAll(select$$1);for(var groups=this._groups,m=groups.length,subgroups=[],parents=[],j=0;j<m;++j){for(var group=groups[j],n=group.length,node,i=0;i<n;++i){if(node=group[i]){for(var children=select$$1.call(node,node.__data__,i,group),child,inherit=get$1(node,id),k=0,l=children.length;k<l;++k){if(child=children[k]){schedule(child,name,id,k,children,inherit);}}subgroups.push(children);parents.push(node);}}}return new Transition(subgroups,parents,name,id);}var Selection$1=selection.prototype.constructor;function transition_selection(){return new Selection$1(this._groups,this._parents);}function styleRemove$1(name,interpolate$$1){var value00,value10,interpolate0;return function(){var value0=styleValue(this,name),value1=(this.style.removeProperty(name),styleValue(this,name));return value0===value1?null:value0===value00&&value1===value10?interpolate0:interpolate0=interpolate$$1(value00=value0,value10=value1);};}function styleRemoveEnd(name){return function(){this.style.removeProperty(name);};}function styleConstant$1(name,interpolate$$1,value1){var value00,interpolate0;return function(){var value0=styleValue(this,name);return value0===value1?null:value0===value00?interpolate0:interpolate0=interpolate$$1(value00=value0,value1);};}function styleFunction$1(name,interpolate$$1,value){var value00,value10,interpolate0;return function(){var value0=styleValue(this,name),value1=value(this);if(value1==null)value1=(this.style.removeProperty(name),styleValue(this,name));return value0===value1?null:value0===value00&&value1===value10?interpolate0:interpolate0=interpolate$$1(value00=value0,value10=value1);};}function transition_style(name,value,priority){var i=(name+=\"\")===\"transform\"?interpolateTransformCss:interpolate;return value==null?this.styleTween(name,styleRemove$1(name,i)).on(\"end.style.\"+name,styleRemoveEnd(name)):this.styleTween(name,typeof value===\"function\"?styleFunction$1(name,i,tweenValue(this,\"style.\"+name,value)):styleConstant$1(name,i,value+\"\"),priority);}function styleTween(name,value,priority){function tween(){var node=this,i=value.apply(node,arguments);return i&&function(t){node.style.setProperty(name,i(t),priority);};}tween._value=value;return tween;}function transition_styleTween(name,value,priority){var key=\"style.\"+(name+=\"\");if(arguments.length<2)return(key=this.tween(key))&&key._value;if(value==null)return this.tween(key,null);if(typeof value!==\"function\")throw new Error();return this.tween(key,styleTween(name,value,priority==null?\"\":priority));}function textConstant$1(value){return function(){this.textContent=value;};}function textFunction$1(value){return function(){var value1=value(this);this.textContent=value1==null?\"\":value1;};}function transition_text(value){return this.tween(\"text\",typeof value===\"function\"?textFunction$1(tweenValue(this,\"text\",value)):textConstant$1(value==null?\"\":value+\"\"));}function transition_transition(){var name=this._name,id0=this._id,id1=newId();for(var groups=this._groups,m=groups.length,j=0;j<m;++j){for(var group=groups[j],n=group.length,node,i=0;i<n;++i){if(node=group[i]){var inherit=get$1(node,id0);schedule(node,name,id1,i,group,{time:inherit.time+inherit.delay+inherit.duration,delay:0,duration:inherit.duration,ease:inherit.ease});}}}return new Transition(groups,this._parents,name,id1);}var id=0;function Transition(groups,parents,name,id){this._groups=groups;this._parents=parents;this._name=name;this._id=id;}function transition(name){return selection().transition(name);}function newId(){return++id;}var selection_prototype=selection.prototype;Transition.prototype=transition.prototype={constructor:Transition,select:transition_select,selectAll:transition_selectAll,filter:transition_filter,merge:transition_merge,selection:transition_selection,transition:transition_transition,call:selection_prototype.call,nodes:selection_prototype.nodes,node:selection_prototype.node,size:selection_prototype.size,empty:selection_prototype.empty,each:selection_prototype.each,on:transition_on,attr:transition_attr,attrTween:transition_attrTween,style:transition_style,styleTween:transition_styleTween,text:transition_text,remove:transition_remove,tween:transition_tween,delay:transition_delay,duration:transition_duration,ease:transition_ease};function linear$1(t){return+t;}function quadIn(t){return t*t;}function quadOut(t){return t*(2-t);}function quadInOut(t){return((t*=2)<=1?t*t:--t*(2-t)+1)/2;}function cubicIn(t){return t*t*t;}function cubicOut(t){return--t*t*t+1;}function cubicInOut(t){return((t*=2)<=1?t*t*t:(t-=2)*t*t+2)/2;}var exponent=3;var polyIn=function custom(e){e=+e;function polyIn(t){return Math.pow(t,e);}polyIn.exponent=custom;return polyIn;}(exponent);var polyOut=function custom(e){e=+e;function polyOut(t){return 1-Math.pow(1-t,e);}polyOut.exponent=custom;return polyOut;}(exponent);var polyInOut=function custom(e){e=+e;function polyInOut(t){return((t*=2)<=1?Math.pow(t,e):2-Math.pow(2-t,e))/2;}polyInOut.exponent=custom;return polyInOut;}(exponent);var pi=Math.PI,halfPi=pi/2;function sinIn(t){return 1-Math.cos(t*halfPi);}function sinOut(t){return Math.sin(t*halfPi);}function sinInOut(t){return(1-Math.cos(pi*t))/2;}function expIn(t){return Math.pow(2,10*t-10);}function expOut(t){return 1-Math.pow(2,-10*t);}function expInOut(t){return((t*=2)<=1?Math.pow(2,10*t-10):2-Math.pow(2,10-10*t))/2;}function circleIn(t){return 1-Math.sqrt(1-t*t);}function circleOut(t){return Math.sqrt(1- --t*t);}function circleInOut(t){return((t*=2)<=1?1-Math.sqrt(1-t*t):Math.sqrt(1-(t-=2)*t)+1)/2;}var b1=4/11,b2=6/11,b3=8/11,b4=3/4,b5=9/11,b6=10/11,b7=15/16,b8=21/22,b9=63/64,b0=1/b1/b1;function bounceIn(t){return 1-bounceOut(1-t);}function bounceOut(t){return(t=+t)<b1?b0*t*t:t<b3?b0*(t-=b2)*t+b4:t<b6?b0*(t-=b5)*t+b7:b0*(t-=b8)*t+b9;}function bounceInOut(t){return((t*=2)<=1?1-bounceOut(1-t):bounceOut(t-1)+1)/2;}var overshoot=1.70158;var backIn=function custom(s){s=+s;function backIn(t){return t*t*((s+1)*t-s);}backIn.overshoot=custom;return backIn;}(overshoot);var backOut=function custom(s){s=+s;function backOut(t){return--t*t*((s+1)*t+s)+1;}backOut.overshoot=custom;return backOut;}(overshoot);var backInOut=function custom(s){s=+s;function backInOut(t){return((t*=2)<1?t*t*((s+1)*t-s):(t-=2)*t*((s+1)*t+s)+2)/2;}backInOut.overshoot=custom;return backInOut;}(overshoot);var tau=2*Math.PI,amplitude=1,period=0.3;var elasticIn=function custom(a,p){var s=Math.asin(1/(a=Math.max(1,a)))*(p/=tau);function elasticIn(t){return a*Math.pow(2,10*--t)*Math.sin((s-t)/p);}elasticIn.amplitude=function(a){return custom(a,p*tau);};elasticIn.period=function(p){return custom(a,p);};return elasticIn;}(amplitude,period);var elasticOut=function custom(a,p){var s=Math.asin(1/(a=Math.max(1,a)))*(p/=tau);function elasticOut(t){return 1-a*Math.pow(2,-10*(t=+t))*Math.sin((t+s)/p);}elasticOut.amplitude=function(a){return custom(a,p*tau);};elasticOut.period=function(p){return custom(a,p);};return elasticOut;}(amplitude,period);var elasticInOut=function custom(a,p){var s=Math.asin(1/(a=Math.max(1,a)))*(p/=tau);function elasticInOut(t){return((t=t*2-1)<0?a*Math.pow(2,10*t)*Math.sin((s-t)/p):2-a*Math.pow(2,-10*t)*Math.sin((s+t)/p))/2;}elasticInOut.amplitude=function(a){return custom(a,p*tau);};elasticInOut.period=function(p){return custom(a,p);};return elasticInOut;}(amplitude,period);var defaultTiming={time:null,// Set on use.\ndelay:0,duration:250,ease:cubicInOut};function inherit(node,id){var timing;while(!(timing=node.__transition)||!(timing=timing[id])){if(!(node=node.parentNode)){return defaultTiming.time=now(),defaultTiming;}}return timing;}function selection_transition(name){var id,timing;if(name instanceof Transition){id=name._id,name=name._name;}else{id=newId(),(timing=defaultTiming).time=now(),name=name==null?null:name+\"\";}for(var groups=this._groups,m=groups.length,j=0;j<m;++j){for(var group=groups[j],n=group.length,node,i=0;i<n;++i){if(node=group[i]){schedule(node,name,id,i,group,timing||inherit(node,id));}}}return new Transition(groups,this._parents,name,id);}selection.prototype.interrupt=selection_interrupt;selection.prototype.transition=selection_transition;var root$1=[null];function active(node,name){var schedules=node.__transition,schedule$$1,i;if(schedules){name=name==null?null:name+\"\";for(i in schedules){if((schedule$$1=schedules[i]).state>SCHEDULED&&schedule$$1.name===name){return new Transition([[node]],root$1,name,+i);}}}return null;}function constant$4(x){return function(){return x;};}function BrushEvent(target,type,selection){this.target=target;this.type=type;this.selection=selection;}function nopropagation$1(){d3.event.stopImmediatePropagation();}function noevent$1(){d3.event.preventDefault();d3.event.stopImmediatePropagation();}var MODE_DRAG={name:\"drag\"},MODE_SPACE={name:\"space\"},MODE_HANDLE={name:\"handle\"},MODE_CENTER={name:\"center\"};var X={name:\"x\",handles:[\"e\",\"w\"].map(type),input:function input(x,e){return x&&[[x[0],e[0][1]],[x[1],e[1][1]]];},output:function output(xy){return xy&&[xy[0][0],xy[1][0]];}};var Y={name:\"y\",handles:[\"n\",\"s\"].map(type),input:function input(y,e){return y&&[[e[0][0],y[0]],[e[1][0],y[1]]];},output:function output(xy){return xy&&[xy[0][1],xy[1][1]];}};var XY={name:\"xy\",handles:[\"n\",\"e\",\"s\",\"w\",\"nw\",\"ne\",\"se\",\"sw\"].map(type),input:function input(xy){return xy;},output:function output(xy){return xy;}};var cursors={overlay:\"crosshair\",selection:\"move\",n:\"ns-resize\",e:\"ew-resize\",s:\"ns-resize\",w:\"ew-resize\",nw:\"nwse-resize\",ne:\"nesw-resize\",se:\"nwse-resize\",sw:\"nesw-resize\"};var flipX={e:\"w\",w:\"e\",nw:\"ne\",ne:\"nw\",se:\"sw\",sw:\"se\"};var flipY={n:\"s\",s:\"n\",nw:\"sw\",ne:\"se\",se:\"ne\",sw:\"nw\"};var signsX={overlay:+1,selection:+1,n:null,e:+1,s:null,w:-1,nw:-1,ne:+1,se:+1,sw:-1};var signsY={overlay:+1,selection:+1,n:-1,e:null,s:+1,w:null,nw:-1,ne:-1,se:+1,sw:+1};function type(t){return{type:t};}// Ignore right-click, since that should open the context menu.\nfunction defaultFilter$1(){return!d3.event.button;}function defaultExtent(){var svg=this.ownerSVGElement||this;return[[0,0],[svg.width.baseVal.value,svg.height.baseVal.value]];}// Like d3.local, but with the name “__brush” rather than auto-generated.\nfunction local$1(node){while(!node.__brush){if(!(node=node.parentNode))return;}return node.__brush;}function empty$1(extent){return extent[0][0]===extent[1][0]||extent[0][1]===extent[1][1];}function brushSelection(node){var state=node.__brush;return state?state.dim.output(state.selection):null;}function brushX(){return brush$1(X);}function brushY(){return brush$1(Y);}function brush(){return brush$1(XY);}function brush$1(dim){var extent=defaultExtent,filter=defaultFilter$1,listeners=dispatch(brush,\"start\",\"brush\",\"end\"),handleSize=6,touchending;function brush(group){var overlay=group.property(\"__brush\",initialize).selectAll(\".overlay\").data([type(\"overlay\")]);overlay.enter().append(\"rect\").attr(\"class\",\"overlay\").attr(\"pointer-events\",\"all\").attr(\"cursor\",cursors.overlay).merge(overlay).each(function(){var extent=local$1(this).extent;select(this).attr(\"x\",extent[0][0]).attr(\"y\",extent[0][1]).attr(\"width\",extent[1][0]-extent[0][0]).attr(\"height\",extent[1][1]-extent[0][1]);});group.selectAll(\".selection\").data([type(\"selection\")]).enter().append(\"rect\").attr(\"class\",\"selection\").attr(\"cursor\",cursors.selection).attr(\"fill\",\"#777\").attr(\"fill-opacity\",0.3).attr(\"stroke\",\"#fff\").attr(\"shape-rendering\",\"crispEdges\");var handle=group.selectAll(\".handle\").data(dim.handles,function(d){return d.type;});handle.exit().remove();handle.enter().append(\"rect\").attr(\"class\",function(d){return\"handle handle--\"+d.type;}).attr(\"cursor\",function(d){return cursors[d.type];});group.each(redraw).attr(\"fill\",\"none\").attr(\"pointer-events\",\"all\").style(\"-webkit-tap-highlight-color\",\"rgba(0,0,0,0)\").on(\"mousedown.brush touchstart.brush\",started);}brush.move=function(group,selection$$1){if(group.selection){group.on(\"start.brush\",function(){emitter(this,arguments).beforestart().start();}).on(\"interrupt.brush end.brush\",function(){emitter(this,arguments).end();}).tween(\"brush\",function(){var that=this,state=that.__brush,emit=emitter(that,arguments),selection0=state.selection,selection1=dim.input(typeof selection$$1===\"function\"?selection$$1.apply(this,arguments):selection$$1,state.extent),i=interpolateValue(selection0,selection1);function tween(t){state.selection=t===1&&empty$1(selection1)?null:i(t);redraw.call(that);emit.brush();}return selection0&&selection1?tween:tween(1);});}else{group.each(function(){var that=this,args=arguments,state=that.__brush,selection1=dim.input(typeof selection$$1===\"function\"?selection$$1.apply(that,args):selection$$1,state.extent),emit=emitter(that,args).beforestart();interrupt(that);state.selection=selection1==null||empty$1(selection1)?null:selection1;redraw.call(that);emit.start().brush().end();});}};function redraw(){var group=select(this),selection$$1=local$1(this).selection;if(selection$$1){group.selectAll(\".selection\").style(\"display\",null).attr(\"x\",selection$$1[0][0]).attr(\"y\",selection$$1[0][1]).attr(\"width\",selection$$1[1][0]-selection$$1[0][0]).attr(\"height\",selection$$1[1][1]-selection$$1[0][1]);group.selectAll(\".handle\").style(\"display\",null).attr(\"x\",function(d){return d.type[d.type.length-1]===\"e\"?selection$$1[1][0]-handleSize/2:selection$$1[0][0]-handleSize/2;}).attr(\"y\",function(d){return d.type[0]===\"s\"?selection$$1[1][1]-handleSize/2:selection$$1[0][1]-handleSize/2;}).attr(\"width\",function(d){return d.type===\"n\"||d.type===\"s\"?selection$$1[1][0]-selection$$1[0][0]+handleSize:handleSize;}).attr(\"height\",function(d){return d.type===\"e\"||d.type===\"w\"?selection$$1[1][1]-selection$$1[0][1]+handleSize:handleSize;});}else{group.selectAll(\".selection,.handle\").style(\"display\",\"none\").attr(\"x\",null).attr(\"y\",null).attr(\"width\",null).attr(\"height\",null);}}function emitter(that,args){return that.__brush.emitter||new Emitter(that,args);}function Emitter(that,args){this.that=that;this.args=args;this.state=that.__brush;this.active=0;}Emitter.prototype={beforestart:function beforestart(){if(++this.active===1)this.state.emitter=this,this.starting=true;return this;},start:function start(){if(this.starting)this.starting=false,this.emit(\"start\");return this;},brush:function brush(){this.emit(\"brush\");return this;},end:function end(){if(--this.active===0)delete this.state.emitter,this.emit(\"end\");return this;},emit:function emit(type){customEvent(new BrushEvent(brush,type,dim.output(this.state.selection)),listeners.apply,listeners,[type,this.that,this.args]);}};function started(){if(d3.event.touches){if(d3.event.changedTouches.length<d3.event.touches.length)return noevent$1();}else if(touchending)return;if(!filter.apply(this,arguments))return;var that=this,type=d3.event.target.__data__.type,mode=(d3.event.metaKey?type=\"overlay\":type)===\"selection\"?MODE_DRAG:d3.event.altKey?MODE_CENTER:MODE_HANDLE,signX=dim===Y?null:signsX[type],signY=dim===X?null:signsY[type],state=local$1(that),extent=state.extent,selection$$1=state.selection,W=extent[0][0],w0,w1,N=extent[0][1],n0,n1,E=extent[1][0],e0,e1,S=extent[1][1],s0,s1,dx,dy,moving,shifting=signX&&signY&&d3.event.shiftKey,lockX,lockY,point0=mouse(that),point$$1=point0,emit=emitter(that,arguments).beforestart();if(type===\"overlay\"){state.selection=selection$$1=[[w0=dim===Y?W:point0[0],n0=dim===X?N:point0[1]],[e0=dim===Y?E:w0,s0=dim===X?S:n0]];}else{w0=selection$$1[0][0];n0=selection$$1[0][1];e0=selection$$1[1][0];s0=selection$$1[1][1];}w1=w0;n1=n0;e1=e0;s1=s0;var group=select(that).attr(\"pointer-events\",\"none\");var overlay=group.selectAll(\".overlay\").attr(\"cursor\",cursors[type]);if(d3.event.touches){group.on(\"touchmove.brush\",moved,true).on(\"touchend.brush touchcancel.brush\",ended,true);}else{var view=select(d3.event.view).on(\"keydown.brush\",keydowned,true).on(\"keyup.brush\",keyupped,true).on(\"mousemove.brush\",moved,true).on(\"mouseup.brush\",ended,true);dragDisable(d3.event.view);}nopropagation$1();interrupt(that);redraw.call(that);emit.start();function moved(){var point1=mouse(that);if(shifting&&!lockX&&!lockY){if(Math.abs(point1[0]-point$$1[0])>Math.abs(point1[1]-point$$1[1]))lockY=true;else lockX=true;}point$$1=point1;moving=true;noevent$1();move();}function move(){var t;dx=point$$1[0]-point0[0];dy=point$$1[1]-point0[1];switch(mode){case MODE_SPACE:case MODE_DRAG:{if(signX)dx=Math.max(W-w0,Math.min(E-e0,dx)),w1=w0+dx,e1=e0+dx;if(signY)dy=Math.max(N-n0,Math.min(S-s0,dy)),n1=n0+dy,s1=s0+dy;break;}case MODE_HANDLE:{if(signX<0)dx=Math.max(W-w0,Math.min(E-w0,dx)),w1=w0+dx,e1=e0;else if(signX>0)dx=Math.max(W-e0,Math.min(E-e0,dx)),w1=w0,e1=e0+dx;if(signY<0)dy=Math.max(N-n0,Math.min(S-n0,dy)),n1=n0+dy,s1=s0;else if(signY>0)dy=Math.max(N-s0,Math.min(S-s0,dy)),n1=n0,s1=s0+dy;break;}case MODE_CENTER:{if(signX)w1=Math.max(W,Math.min(E,w0-dx*signX)),e1=Math.max(W,Math.min(E,e0+dx*signX));if(signY)n1=Math.max(N,Math.min(S,n0-dy*signY)),s1=Math.max(N,Math.min(S,s0+dy*signY));break;}}if(e1<w1){signX*=-1;t=w0,w0=e0,e0=t;t=w1,w1=e1,e1=t;if(type in flipX)overlay.attr(\"cursor\",cursors[type=flipX[type]]);}if(s1<n1){signY*=-1;t=n0,n0=s0,s0=t;t=n1,n1=s1,s1=t;if(type in flipY)overlay.attr(\"cursor\",cursors[type=flipY[type]]);}if(state.selection)selection$$1=state.selection;// May be set by brush.move!\nif(lockX)w1=selection$$1[0][0],e1=selection$$1[1][0];if(lockY)n1=selection$$1[0][1],s1=selection$$1[1][1];if(selection$$1[0][0]!==w1||selection$$1[0][1]!==n1||selection$$1[1][0]!==e1||selection$$1[1][1]!==s1){state.selection=[[w1,n1],[e1,s1]];redraw.call(that);emit.brush();}}function ended(){nopropagation$1();if(d3.event.touches){if(d3.event.touches.length)return;if(touchending)clearTimeout(touchending);touchending=setTimeout(function(){touchending=null;},500);// Ghost clicks are delayed!\ngroup.on(\"touchmove.brush touchend.brush touchcancel.brush\",null);}else{yesdrag(d3.event.view,moving);view.on(\"keydown.brush keyup.brush mousemove.brush mouseup.brush\",null);}group.attr(\"pointer-events\",\"all\");overlay.attr(\"cursor\",cursors.overlay);if(state.selection)selection$$1=state.selection;// May be set by brush.move (on start)!\nif(empty$1(selection$$1))state.selection=null,redraw.call(that);emit.end();}function keydowned(){switch(d3.event.keyCode){case 16:{// SHIFT\nshifting=signX&&signY;break;}case 18:{// ALT\nif(mode===MODE_HANDLE){if(signX)e0=e1-dx*signX,w0=w1+dx*signX;if(signY)s0=s1-dy*signY,n0=n1+dy*signY;mode=MODE_CENTER;move();}break;}case 32:{// SPACE; takes priority over ALT\nif(mode===MODE_HANDLE||mode===MODE_CENTER){if(signX<0)e0=e1-dx;else if(signX>0)w0=w1-dx;if(signY<0)s0=s1-dy;else if(signY>0)n0=n1-dy;mode=MODE_SPACE;overlay.attr(\"cursor\",cursors.selection);move();}break;}default:return;}noevent$1();}function keyupped(){switch(d3.event.keyCode){case 16:{// SHIFT\nif(shifting){lockX=lockY=shifting=false;move();}break;}case 18:{// ALT\nif(mode===MODE_CENTER){if(signX<0)e0=e1;else if(signX>0)w0=w1;if(signY<0)s0=s1;else if(signY>0)n0=n1;mode=MODE_HANDLE;move();}break;}case 32:{// SPACE\nif(mode===MODE_SPACE){if(d3.event.altKey){if(signX)e0=e1-dx*signX,w0=w1+dx*signX;if(signY)s0=s1-dy*signY,n0=n1+dy*signY;mode=MODE_CENTER;}else{if(signX<0)e0=e1;else if(signX>0)w0=w1;if(signY<0)s0=s1;else if(signY>0)n0=n1;mode=MODE_HANDLE;}overlay.attr(\"cursor\",cursors[type]);move();}break;}default:return;}noevent$1();}}function initialize(){var state=this.__brush||{selection:null};state.extent=extent.apply(this,arguments);state.dim=dim;return state;}brush.extent=function(_){return arguments.length?(extent=typeof _===\"function\"?_:constant$4([[+_[0][0],+_[0][1]],[+_[1][0],+_[1][1]]]),brush):extent;};brush.filter=function(_){return arguments.length?(filter=typeof _===\"function\"?_:constant$4(!!_),brush):filter;};brush.handleSize=function(_){return arguments.length?(handleSize=+_,brush):handleSize;};brush.on=function(){var value=listeners.on.apply(listeners,arguments);return value===listeners?brush:value;};return brush;}var cos=Math.cos;var sin=Math.sin;var pi$1=Math.PI;var halfPi$1=pi$1/2;var tau$1=pi$1*2;var max$1=Math.max;function compareValue(compare){return function(a,b){return compare(a.source.value+a.target.value,b.source.value+b.target.value);};}function chord(){var padAngle=0,sortGroups=null,sortSubgroups=null,sortChords=null;function chord(matrix){var n=matrix.length,groupSums=[],groupIndex=sequence(n),subgroupIndex=[],chords=[],groups=chords.groups=new Array(n),subgroups=new Array(n*n),k,x,x0,dx,i,j;// Compute the sum.\nk=0,i=-1;while(++i<n){x=0,j=-1;while(++j<n){x+=matrix[i][j];}groupSums.push(x);subgroupIndex.push(sequence(n));k+=x;}// Sort groups…\nif(sortGroups)groupIndex.sort(function(a,b){return sortGroups(groupSums[a],groupSums[b]);});// Sort subgroups…\nif(sortSubgroups)subgroupIndex.forEach(function(d,i){d.sort(function(a,b){return sortSubgroups(matrix[i][a],matrix[i][b]);});});// Convert the sum to scaling factor for [0, 2pi].\n// TODO Allow start and end angle to be specified?\n// TODO Allow padding to be specified as percentage?\nk=max$1(0,tau$1-padAngle*n)/k;dx=k?padAngle:tau$1/n;// Compute the start and end angle for each group and subgroup.\n// Note: Opera has a bug reordering object literal properties!\nx=0,i=-1;while(++i<n){x0=x,j=-1;while(++j<n){var di=groupIndex[i],dj=subgroupIndex[di][j],v=matrix[di][dj],a0=x,a1=x+=v*k;subgroups[dj*n+di]={index:di,subindex:dj,startAngle:a0,endAngle:a1,value:v};}groups[di]={index:di,startAngle:x0,endAngle:x,value:groupSums[di]};x+=dx;}// Generate chords for each (non-empty) subgroup-subgroup link.\ni=-1;while(++i<n){j=i-1;while(++j<n){var source=subgroups[j*n+i],target=subgroups[i*n+j];if(source.value||target.value){chords.push(source.value<target.value?{source:target,target:source}:{source:source,target:target});}}}return sortChords?chords.sort(sortChords):chords;}chord.padAngle=function(_){return arguments.length?(padAngle=max$1(0,_),chord):padAngle;};chord.sortGroups=function(_){return arguments.length?(sortGroups=_,chord):sortGroups;};chord.sortSubgroups=function(_){return arguments.length?(sortSubgroups=_,chord):sortSubgroups;};chord.sortChords=function(_){return arguments.length?(_==null?sortChords=null:(sortChords=compareValue(_))._=_,chord):sortChords&&sortChords._;};return chord;}var slice$2=Array.prototype.slice;function constant$5(x){return function(){return x;};}var pi$2=Math.PI,tau$2=2*pi$2,epsilon$1=1e-6,tauEpsilon=tau$2-epsilon$1;function Path(){this._x0=this._y0=// start of current subpath\nthis._x1=this._y1=null;// end of current subpath\nthis._=\"\";}function path(){return new Path();}Path.prototype=path.prototype={constructor:Path,moveTo:function moveTo(x,y){this._+=\"M\"+(this._x0=this._x1=+x)+\",\"+(this._y0=this._y1=+y);},closePath:function closePath(){if(this._x1!==null){this._x1=this._x0,this._y1=this._y0;this._+=\"Z\";}},lineTo:function lineTo(x,y){this._+=\"L\"+(this._x1=+x)+\",\"+(this._y1=+y);},quadraticCurveTo:function quadraticCurveTo(x1,y1,x,y){this._+=\"Q\"+ +x1+\",\"+ +y1+\",\"+(this._x1=+x)+\",\"+(this._y1=+y);},bezierCurveTo:function bezierCurveTo(x1,y1,x2,y2,x,y){this._+=\"C\"+ +x1+\",\"+ +y1+\",\"+ +x2+\",\"+ +y2+\",\"+(this._x1=+x)+\",\"+(this._y1=+y);},arcTo:function arcTo(x1,y1,x2,y2,r){x1=+x1,y1=+y1,x2=+x2,y2=+y2,r=+r;var x0=this._x1,y0=this._y1,x21=x2-x1,y21=y2-y1,x01=x0-x1,y01=y0-y1,l01_2=x01*x01+y01*y01;// Is the radius negative? Error.\nif(r<0)throw new Error(\"negative radius: \"+r);// Is this path empty? Move to (x1,y1).\nif(this._x1===null){this._+=\"M\"+(this._x1=x1)+\",\"+(this._y1=y1);}// Or, is (x1,y1) coincident with (x0,y0)? Do nothing.\nelse if(!(l01_2>epsilon$1)){}// Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?\n// Equivalently, is (x1,y1) coincident with (x2,y2)?\n// Or, is the radius zero? Line to (x1,y1).\nelse if(!(Math.abs(y01*x21-y21*x01)>epsilon$1)||!r){this._+=\"L\"+(this._x1=x1)+\",\"+(this._y1=y1);}// Otherwise, draw an arc!\nelse{var x20=x2-x0,y20=y2-y0,l21_2=x21*x21+y21*y21,l20_2=x20*x20+y20*y20,l21=Math.sqrt(l21_2),l01=Math.sqrt(l01_2),l=r*Math.tan((pi$2-Math.acos((l21_2+l01_2-l20_2)/(2*l21*l01)))/2),t01=l/l01,t21=l/l21;// If the start tangent is not coincident with (x0,y0), line to.\nif(Math.abs(t01-1)>epsilon$1){this._+=\"L\"+(x1+t01*x01)+\",\"+(y1+t01*y01);}this._+=\"A\"+r+\",\"+r+\",0,0,\"+ +(y01*x20>x01*y20)+\",\"+(this._x1=x1+t21*x21)+\",\"+(this._y1=y1+t21*y21);}},arc:function arc(x,y,r,a0,a1,ccw){x=+x,y=+y,r=+r;var dx=r*Math.cos(a0),dy=r*Math.sin(a0),x0=x+dx,y0=y+dy,cw=1^ccw,da=ccw?a0-a1:a1-a0;// Is the radius negative? Error.\nif(r<0)throw new Error(\"negative radius: \"+r);// Is this path empty? Move to (x0,y0).\nif(this._x1===null){this._+=\"M\"+x0+\",\"+y0;}// Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).\nelse if(Math.abs(this._x1-x0)>epsilon$1||Math.abs(this._y1-y0)>epsilon$1){this._+=\"L\"+x0+\",\"+y0;}// Is this arc empty? We’re done.\nif(!r)return;// Does the angle go the wrong way? Flip the direction.\nif(da<0)da=da%tau$2+tau$2;// Is this a complete circle? Draw two arcs to complete the circle.\nif(da>tauEpsilon){this._+=\"A\"+r+\",\"+r+\",0,1,\"+cw+\",\"+(x-dx)+\",\"+(y-dy)+\"A\"+r+\",\"+r+\",0,1,\"+cw+\",\"+(this._x1=x0)+\",\"+(this._y1=y0);}// Is this arc non-empty? Draw an arc!\nelse if(da>epsilon$1){this._+=\"A\"+r+\",\"+r+\",0,\"+ +(da>=pi$2)+\",\"+cw+\",\"+(this._x1=x+r*Math.cos(a1))+\",\"+(this._y1=y+r*Math.sin(a1));}},rect:function rect(x,y,w,h){this._+=\"M\"+(this._x0=this._x1=+x)+\",\"+(this._y0=this._y1=+y)+\"h\"+ +w+\"v\"+ +h+\"h\"+-w+\"Z\";},toString:function toString(){return this._;}};function defaultSource(d){return d.source;}function defaultTarget(d){return d.target;}function defaultRadius(d){return d.radius;}function defaultStartAngle(d){return d.startAngle;}function defaultEndAngle(d){return d.endAngle;}function ribbon(){var source=defaultSource,target=defaultTarget,radius=defaultRadius,startAngle=defaultStartAngle,endAngle=defaultEndAngle,context=null;function ribbon(){var buffer,argv=slice$2.call(arguments),s=source.apply(this,argv),t=target.apply(this,argv),sr=+radius.apply(this,(argv[0]=s,argv)),sa0=startAngle.apply(this,argv)-halfPi$1,sa1=endAngle.apply(this,argv)-halfPi$1,sx0=sr*cos(sa0),sy0=sr*sin(sa0),tr=+radius.apply(this,(argv[0]=t,argv)),ta0=startAngle.apply(this,argv)-halfPi$1,ta1=endAngle.apply(this,argv)-halfPi$1;if(!context)context=buffer=path();context.moveTo(sx0,sy0);context.arc(0,0,sr,sa0,sa1);if(sa0!==ta0||sa1!==ta1){// TODO sr !== tr?\ncontext.quadraticCurveTo(0,0,tr*cos(ta0),tr*sin(ta0));context.arc(0,0,tr,ta0,ta1);}context.quadraticCurveTo(0,0,sx0,sy0);context.closePath();if(buffer)return context=null,buffer+\"\"||null;}ribbon.radius=function(_){return arguments.length?(radius=typeof _===\"function\"?_:constant$5(+_),ribbon):radius;};ribbon.startAngle=function(_){return arguments.length?(startAngle=typeof _===\"function\"?_:constant$5(+_),ribbon):startAngle;};ribbon.endAngle=function(_){return arguments.length?(endAngle=typeof _===\"function\"?_:constant$5(+_),ribbon):endAngle;};ribbon.source=function(_){return arguments.length?(source=_,ribbon):source;};ribbon.target=function(_){return arguments.length?(target=_,ribbon):target;};ribbon.context=function(_){return arguments.length?(context=_==null?null:_,ribbon):context;};return ribbon;}var prefix=\"$\";function Map(){}Map.prototype=map$1.prototype={constructor:Map,has:function has(key){return prefix+key in this;},get:function get(key){return this[prefix+key];},set:function set(key,value){this[prefix+key]=value;return this;},remove:function remove(key){var property=prefix+key;return property in this&&delete this[property];},clear:function clear(){for(var property in this){if(property[0]===prefix)delete this[property];}},keys:function keys(){var keys=[];for(var property in this){if(property[0]===prefix)keys.push(property.slice(1));}return keys;},values:function values(){var values=[];for(var property in this){if(property[0]===prefix)values.push(this[property]);}return values;},entries:function entries(){var entries=[];for(var property in this){if(property[0]===prefix)entries.push({key:property.slice(1),value:this[property]});}return entries;},size:function size(){var size=0;for(var property in this){if(property[0]===prefix)++size;}return size;},empty:function empty(){for(var property in this){if(property[0]===prefix)return false;}return true;},each:function each(f){for(var property in this){if(property[0]===prefix)f(this[property],property.slice(1),this);}}};function map$1(object,f){var map=new Map();// Copy constructor.\nif(object instanceof Map)object.each(function(value,key){map.set(key,value);});// Index array by numeric index or specified key function.\nelse if(Array.isArray(object)){var i=-1,n=object.length,o;if(f==null)while(++i<n){map.set(i,object[i]);}else while(++i<n){map.set(f(o=object[i],i,object),o);}}// Convert object to map.\nelse if(object)for(var key in object){map.set(key,object[key]);}return map;}function nest(){var keys=[],_sortKeys=[],_sortValues,_rollup,nest;function apply(array,depth,createResult,setResult){if(depth>=keys.length){if(_sortValues!=null)array.sort(_sortValues);return _rollup!=null?_rollup(array):array;}var i=-1,n=array.length,key=keys[depth++],keyValue,value,valuesByKey=map$1(),values,result=createResult();while(++i<n){if(values=valuesByKey.get(keyValue=key(value=array[i])+\"\")){values.push(value);}else{valuesByKey.set(keyValue,[value]);}}valuesByKey.each(function(values,key){setResult(result,key,apply(values,depth,createResult,setResult));});return result;}function _entries(map,depth){if(++depth>keys.length)return map;var array,sortKey=_sortKeys[depth-1];if(_rollup!=null&&depth>=keys.length)array=map.entries();else array=[],map.each(function(v,k){array.push({key:k,values:_entries(v,depth)});});return sortKey!=null?array.sort(function(a,b){return sortKey(a.key,b.key);}):array;}return nest={object:function object(array){return apply(array,0,createObject,setObject);},map:function map(array){return apply(array,0,createMap,setMap);},entries:function entries(array){return _entries(apply(array,0,createMap,setMap),0);},key:function key(d){keys.push(d);return nest;},sortKeys:function sortKeys(order){_sortKeys[keys.length-1]=order;return nest;},sortValues:function sortValues(order){_sortValues=order;return nest;},rollup:function rollup(f){_rollup=f;return nest;}};}function createObject(){return{};}function setObject(object,key,value){object[key]=value;}function createMap(){return map$1();}function setMap(map,key,value){map.set(key,value);}function Set(){}var proto=map$1.prototype;Set.prototype=set$2.prototype={constructor:Set,has:proto.has,add:function add(value){value+=\"\";this[prefix+value]=value;return this;},remove:proto.remove,clear:proto.clear,values:proto.keys,size:proto.size,empty:proto.empty,each:proto.each};function set$2(object,f){var set=new Set();// Copy constructor.\nif(object instanceof Set)object.each(function(value){set.add(value);});// Otherwise, assume it’s an array.\nelse if(object){var i=-1,n=object.length;if(f==null)while(++i<n){set.add(object[i]);}else while(++i<n){set.add(f(object[i],i,object));}}return set;}function keys(map){var keys=[];for(var key in map){keys.push(key);}return keys;}function values(map){var values=[];for(var key in map){values.push(map[key]);}return values;}function entries(map){var entries=[];for(var key in map){entries.push({key:key,value:map[key]});}return entries;}var array$2=Array.prototype;var slice$3=array$2.slice;function ascending$2(a,b){return a-b;}function area(ring){var i=0,n=ring.length,area=ring[n-1][1]*ring[0][0]-ring[n-1][0]*ring[0][1];while(++i<n){area+=ring[i-1][1]*ring[i][0]-ring[i-1][0]*ring[i][1];}return area;}function constant$6(x){return function(){return x;};}function contains(ring,hole){var i=-1,n=hole.length,c;while(++i<n){if(c=ringContains(ring,hole[i]))return c;}return 0;}function ringContains(ring,point){var x=point[0],y=point[1],contains=-1;for(var i=0,n=ring.length,j=n-1;i<n;j=i++){var pi=ring[i],xi=pi[0],yi=pi[1],pj=ring[j],xj=pj[0],yj=pj[1];if(segmentContains(pi,pj,point))return 0;if(yi>y!==yj>y&&x<(xj-xi)*(y-yi)/(yj-yi)+xi)contains=-contains;}return contains;}function segmentContains(a,b,c){var i;return collinear(a,b,c)&&within(a[i=+(a[0]===b[0])],c[i],b[i]);}function collinear(a,b,c){return(b[0]-a[0])*(c[1]-a[1])===(c[0]-a[0])*(b[1]-a[1]);}function within(p,q,r){return p<=q&&q<=r||r<=q&&q<=p;}function noop$1(){}var cases=[[],[[[1.0,1.5],[0.5,1.0]]],[[[1.5,1.0],[1.0,1.5]]],[[[1.5,1.0],[0.5,1.0]]],[[[1.0,0.5],[1.5,1.0]]],[[[1.0,1.5],[0.5,1.0]],[[1.0,0.5],[1.5,1.0]]],[[[1.0,0.5],[1.0,1.5]]],[[[1.0,0.5],[0.5,1.0]]],[[[0.5,1.0],[1.0,0.5]]],[[[1.0,1.5],[1.0,0.5]]],[[[0.5,1.0],[1.0,0.5]],[[1.5,1.0],[1.0,1.5]]],[[[1.5,1.0],[1.0,0.5]]],[[[0.5,1.0],[1.5,1.0]]],[[[1.0,1.5],[1.5,1.0]]],[[[0.5,1.0],[1.0,1.5]]],[]];function contours(){var dx=1,dy=1,threshold$$1=thresholdSturges,smooth=smoothLinear;function contours(values){var tz=threshold$$1(values);// Convert number of thresholds into uniform thresholds.\nif(!Array.isArray(tz)){var domain=extent(values),start=domain[0],stop=domain[1];tz=tickStep(start,stop,tz);tz=sequence(Math.floor(start/tz)*tz,Math.floor(stop/tz)*tz,tz);}else{tz=tz.slice().sort(ascending$2);}return tz.map(function(value){return contour(values,value);});}// Accumulate, smooth contour rings, assign holes to exterior rings.\n// Based on https://github.com/mbostock/shapefile/blob/v0.6.2/shp/polygon.js\nfunction contour(values,value){var polygons=[],holes=[];isorings(values,value,function(ring){smooth(ring,values,value);if(area(ring)>0)polygons.push([ring]);else holes.push(ring);});holes.forEach(function(hole){for(var i=0,n=polygons.length,polygon;i<n;++i){if(contains((polygon=polygons[i])[0],hole)!==-1){polygon.push(hole);return;}}});return{type:\"MultiPolygon\",value:value,coordinates:polygons};}// Marching squares with isolines stitched into rings.\n// Based on https://github.com/topojson/topojson-client/blob/v3.0.0/src/stitch.js\nfunction isorings(values,value,callback){var fragmentByStart=new Array(),fragmentByEnd=new Array(),x,y,t0,t1,t2,t3;// Special case for the first row (y = -1, t2 = t3 = 0).\nx=y=-1;t1=values[0]>=value;cases[t1<<1].forEach(stitch);while(++x<dx-1){t0=t1,t1=values[x+1]>=value;cases[t0|t1<<1].forEach(stitch);}cases[t1<<0].forEach(stitch);// General case for the intermediate rows.\nwhile(++y<dy-1){x=-1;t1=values[y*dx+dx]>=value;t2=values[y*dx]>=value;cases[t1<<1|t2<<2].forEach(stitch);while(++x<dx-1){t0=t1,t1=values[y*dx+dx+x+1]>=value;t3=t2,t2=values[y*dx+x+1]>=value;cases[t0|t1<<1|t2<<2|t3<<3].forEach(stitch);}cases[t1|t2<<3].forEach(stitch);}// Special case for the last row (y = dy - 1, t0 = t1 = 0).\nx=-1;t2=values[y*dx]>=value;cases[t2<<2].forEach(stitch);while(++x<dx-1){t3=t2,t2=values[y*dx+x+1]>=value;cases[t2<<2|t3<<3].forEach(stitch);}cases[t2<<3].forEach(stitch);function stitch(line){var start=[line[0][0]+x,line[0][1]+y],end=[line[1][0]+x,line[1][1]+y],startIndex=index(start),endIndex=index(end),f,g;if(f=fragmentByEnd[startIndex]){if(g=fragmentByStart[endIndex]){delete fragmentByEnd[f.end];delete fragmentByStart[g.start];if(f===g){f.ring.push(end);callback(f.ring);}else{fragmentByStart[f.start]=fragmentByEnd[g.end]={start:f.start,end:g.end,ring:f.ring.concat(g.ring)};}}else{delete fragmentByEnd[f.end];f.ring.push(end);fragmentByEnd[f.end=endIndex]=f;}}else if(f=fragmentByStart[endIndex]){if(g=fragmentByEnd[startIndex]){delete fragmentByStart[f.start];delete fragmentByEnd[g.end];if(f===g){f.ring.push(end);callback(f.ring);}else{fragmentByStart[g.start]=fragmentByEnd[f.end]={start:g.start,end:f.end,ring:g.ring.concat(f.ring)};}}else{delete fragmentByStart[f.start];f.ring.unshift(start);fragmentByStart[f.start=startIndex]=f;}}else{fragmentByStart[startIndex]=fragmentByEnd[endIndex]={start:startIndex,end:endIndex,ring:[start,end]};}}}function index(point){return point[0]*2+point[1]*(dx+1)*4;}function smoothLinear(ring,values,value){ring.forEach(function(point){var x=point[0],y=point[1],xt=x|0,yt=y|0,v0,v1=values[yt*dx+xt];if(x>0&&x<dx&&xt===x){v0=values[yt*dx+xt-1];point[0]=x+(value-v0)/(v1-v0)-0.5;}if(y>0&&y<dy&&yt===y){v0=values[(yt-1)*dx+xt];point[1]=y+(value-v0)/(v1-v0)-0.5;}});}contours.contour=contour;contours.size=function(_){if(!arguments.length)return[dx,dy];var _0=Math.ceil(_[0]),_1=Math.ceil(_[1]);if(!(_0>0)||!(_1>0))throw new Error(\"invalid size\");return dx=_0,dy=_1,contours;};contours.thresholds=function(_){return arguments.length?(threshold$$1=typeof _===\"function\"?_:Array.isArray(_)?constant$6(slice$3.call(_)):constant$6(_),contours):threshold$$1;};contours.smooth=function(_){return arguments.length?(smooth=_?smoothLinear:noop$1,contours):smooth===smoothLinear;};return contours;}// TODO Optimize edge cases.\n// TODO Optimize index calculation.\n// TODO Optimize arguments.\nfunction blurX(source,target,r){var n=source.width,m=source.height,w=(r<<1)+1;for(var j=0;j<m;++j){for(var i=0,sr=0;i<n+r;++i){if(i<n){sr+=source.data[i+j*n];}if(i>=r){if(i>=w){sr-=source.data[i-w+j*n];}target.data[i-r+j*n]=sr/Math.min(i+1,n-1+w-i,w);}}}}// TODO Optimize edge cases.\n// TODO Optimize index calculation.\n// TODO Optimize arguments.\nfunction blurY(source,target,r){var n=source.width,m=source.height,w=(r<<1)+1;for(var i=0;i<n;++i){for(var j=0,sr=0;j<m+r;++j){if(j<m){sr+=source.data[i+j*n];}if(j>=r){if(j>=w){sr-=source.data[i+(j-w)*n];}target.data[i+(j-r)*n]=sr/Math.min(j+1,m-1+w-j,w);}}}}function defaultX(d){return d[0];}function defaultY(d){return d[1];}function density(){var x=defaultX,y=defaultY,dx=960,dy=500,r=20,// blur radius\nk=2,// log2(grid cell size)\no=r*3,// grid offset, to pad for blur\nn=dx+o*2>>k,// grid width\nm=dy+o*2>>k,// grid height\nthreshold$$1=constant$6(20);function density(data){var values0=new Float32Array(n*m),values1=new Float32Array(n*m);data.forEach(function(d,i,data){var xi=x(d,i,data)+o>>k,yi=y(d,i,data)+o>>k;if(xi>=0&&xi<n&&yi>=0&&yi<m){++values0[xi+yi*n];}});// TODO Optimize.\nblurX({width:n,height:m,data:values0},{width:n,height:m,data:values1},r>>k);blurY({width:n,height:m,data:values1},{width:n,height:m,data:values0},r>>k);blurX({width:n,height:m,data:values0},{width:n,height:m,data:values1},r>>k);blurY({width:n,height:m,data:values1},{width:n,height:m,data:values0},r>>k);blurX({width:n,height:m,data:values0},{width:n,height:m,data:values1},r>>k);blurY({width:n,height:m,data:values1},{width:n,height:m,data:values0},r>>k);var tz=threshold$$1(values0);// Convert number of thresholds into uniform thresholds.\nif(!Array.isArray(tz)){var stop=max(values0);tz=tickStep(0,stop,tz);tz=sequence(0,Math.floor(stop/tz)*tz,tz);tz.shift();}return contours().thresholds(tz).size([n,m])(values0).map(transform);}function transform(geometry){geometry.value*=Math.pow(2,-2*k);// Density in points per square pixel.\ngeometry.coordinates.forEach(transformPolygon);return geometry;}function transformPolygon(coordinates){coordinates.forEach(transformRing);}function transformRing(coordinates){coordinates.forEach(transformPoint);}// TODO Optimize.\nfunction transformPoint(coordinates){coordinates[0]=coordinates[0]*Math.pow(2,k)-o;coordinates[1]=coordinates[1]*Math.pow(2,k)-o;}function resize(){o=r*3;n=dx+o*2>>k;m=dy+o*2>>k;return density;}density.x=function(_){return arguments.length?(x=typeof _===\"function\"?_:constant$6(+_),density):x;};density.y=function(_){return arguments.length?(y=typeof _===\"function\"?_:constant$6(+_),density):y;};density.size=function(_){if(!arguments.length)return[dx,dy];var _0=Math.ceil(_[0]),_1=Math.ceil(_[1]);if(!(_0>=0)&&!(_0>=0))throw new Error(\"invalid size\");return dx=_0,dy=_1,resize();};density.cellSize=function(_){if(!arguments.length)return 1<<k;if(!((_=+_)>=1))throw new Error(\"invalid cell size\");return k=Math.floor(Math.log(_)/Math.LN2),resize();};density.thresholds=function(_){return arguments.length?(threshold$$1=typeof _===\"function\"?_:Array.isArray(_)?constant$6(slice$3.call(_)):constant$6(_),density):threshold$$1;};density.bandwidth=function(_){if(!arguments.length)return Math.sqrt(r*(r+1));if(!((_=+_)>=0))throw new Error(\"invalid bandwidth\");return r=Math.round((Math.sqrt(4*_*_+1)-1)/2),resize();};return density;}var EOL={},EOF={},QUOTE=34,NEWLINE=10,RETURN=13;function objectConverter(columns){return new Function(\"d\",\"return {\"+columns.map(function(name,i){return JSON.stringify(name)+\": d[\"+i+\"]\";}).join(\",\")+\"}\");}function customConverter(columns,f){var object=objectConverter(columns);return function(row,i){return f(object(row),i,columns);};}// Compute unique columns in order of discovery.\nfunction inferColumns(rows){var columnSet=Object.create(null),columns=[];rows.forEach(function(row){for(var column in row){if(!(column in columnSet)){columns.push(columnSet[column]=column);}}});return columns;}function dsvFormat(delimiter){var reFormat=new RegExp(\"[\\\"\"+delimiter+\"\\n\\r]\"),DELIMITER=delimiter.charCodeAt(0);function parse(text,f){var convert,columns,rows=parseRows(text,function(row,i){if(convert)return convert(row,i-1);columns=row,convert=f?customConverter(row,f):objectConverter(row);});rows.columns=columns||[];return rows;}function parseRows(text,f){var rows=[],// output rows\nN=text.length,I=0,// current character index\nn=0,// current line number\nt,// current token\neof=N<=0,// current token followed by EOF?\neol=false;// current token followed by EOL?\n// Strip the trailing newline.\nif(text.charCodeAt(N-1)===NEWLINE)--N;if(text.charCodeAt(N-1)===RETURN)--N;function token(){if(eof)return EOF;if(eol)return eol=false,EOL;// Unescape quotes.\nvar i,j=I,c;if(text.charCodeAt(j)===QUOTE){while(I++<N&&text.charCodeAt(I)!==QUOTE||text.charCodeAt(++I)===QUOTE){}if((i=I)>=N)eof=true;else if((c=text.charCodeAt(I++))===NEWLINE)eol=true;else if(c===RETURN){eol=true;if(text.charCodeAt(I)===NEWLINE)++I;}return text.slice(j+1,i-1).replace(/\"\"/g,\"\\\"\");}// Find next delimiter or newline.\nwhile(I<N){if((c=text.charCodeAt(i=I++))===NEWLINE)eol=true;else if(c===RETURN){eol=true;if(text.charCodeAt(I)===NEWLINE)++I;}else if(c!==DELIMITER)continue;return text.slice(j,i);}// Return last token before EOF.\nreturn eof=true,text.slice(j,N);}while((t=token())!==EOF){var row=[];while(t!==EOL&&t!==EOF){row.push(t),t=token();}if(f&&(row=f(row,n++))==null)continue;rows.push(row);}return rows;}function format(rows,columns){if(columns==null)columns=inferColumns(rows);return[columns.map(formatValue).join(delimiter)].concat(rows.map(function(row){return columns.map(function(column){return formatValue(row[column]);}).join(delimiter);})).join(\"\\n\");}function formatRows(rows){return rows.map(formatRow).join(\"\\n\");}function formatRow(row){return row.map(formatValue).join(delimiter);}function formatValue(text){return text==null?\"\":reFormat.test(text+=\"\")?\"\\\"\"+text.replace(/\"/g,\"\\\"\\\"\")+\"\\\"\":text;}return{parse:parse,parseRows:parseRows,format:format,formatRows:formatRows};}var csv=dsvFormat(\",\");var csvParse=csv.parse;var csvParseRows=csv.parseRows;var csvFormat=csv.format;var csvFormatRows=csv.formatRows;var tsv=dsvFormat(\"\\t\");var tsvParse=tsv.parse;var tsvParseRows=tsv.parseRows;var tsvFormat=tsv.format;var tsvFormatRows=tsv.formatRows;function responseBlob(response){if(!response.ok)throw new Error(response.status+\" \"+response.statusText);return response.blob();}function blob(input,init){return fetch(input,init).then(responseBlob);}function responseArrayBuffer(response){if(!response.ok)throw new Error(response.status+\" \"+response.statusText);return response.arrayBuffer();}function buffer(input,init){return fetch(input,init).then(responseArrayBuffer);}function responseText(response){if(!response.ok)throw new Error(response.status+\" \"+response.statusText);return response.text();}function text(input,init){return fetch(input,init).then(responseText);}function dsvParse(parse){return function(input,init,row){if(arguments.length===2&&typeof init===\"function\")row=init,init=undefined;return text(input,init).then(function(response){return parse(response,row);});};}function dsv(delimiter,input,init,row){if(arguments.length===3&&typeof init===\"function\")row=init,init=undefined;var format=dsvFormat(delimiter);return text(input,init).then(function(response){return format.parse(response,row);});}var csv$1=dsvParse(csvParse);var tsv$1=dsvParse(tsvParse);function image(input,init){return new Promise(function(resolve,reject){var image=new Image();for(var key in init){image[key]=init[key];}image.onerror=reject;image.onload=function(){resolve(image);};image.src=input;});}function responseJson(response){if(!response.ok)throw new Error(response.status+\" \"+response.statusText);return response.json();}function json(input,init){return fetch(input,init).then(responseJson);}function parser(type){return function(input,init){return text(input,init).then(function(text$$1){return new DOMParser().parseFromString(text$$1,type);});};}var xml=parser(\"application/xml\");var html=parser(\"text/html\");var svg=parser(\"image/svg+xml\");function center$1(x,y){var nodes;if(x==null)x=0;if(y==null)y=0;function force(){var i,n=nodes.length,node,sx=0,sy=0;for(i=0;i<n;++i){node=nodes[i],sx+=node.x,sy+=node.y;}for(sx=sx/n-x,sy=sy/n-y,i=0;i<n;++i){node=nodes[i],node.x-=sx,node.y-=sy;}}force.initialize=function(_){nodes=_;};force.x=function(_){return arguments.length?(x=+_,force):x;};force.y=function(_){return arguments.length?(y=+_,force):y;};return force;}function constant$7(x){return function(){return x;};}function jiggle(){return(Math.random()-0.5)*1e-6;}function tree_add(d){var x=+this._x.call(null,d),y=+this._y.call(null,d);return add(this.cover(x,y),x,y,d);}function add(tree,x,y,d){if(isNaN(x)||isNaN(y))return tree;// ignore invalid points\nvar parent,node=tree._root,leaf={data:d},x0=tree._x0,y0=tree._y0,x1=tree._x1,y1=tree._y1,xm,ym,xp,yp,right,bottom,i,j;// If the tree is empty, initialize the root as a leaf.\nif(!node)return tree._root=leaf,tree;// Find the existing leaf for the new point, or add it.\nwhile(node.length){if(right=x>=(xm=(x0+x1)/2))x0=xm;else x1=xm;if(bottom=y>=(ym=(y0+y1)/2))y0=ym;else y1=ym;if(parent=node,!(node=node[i=bottom<<1|right]))return parent[i]=leaf,tree;}// Is the new point is exactly coincident with the existing point?\nxp=+tree._x.call(null,node.data);yp=+tree._y.call(null,node.data);if(x===xp&&y===yp)return leaf.next=node,parent?parent[i]=leaf:tree._root=leaf,tree;// Otherwise, split the leaf node until the old and new point are separated.\ndo{parent=parent?parent[i]=new Array(4):tree._root=new Array(4);if(right=x>=(xm=(x0+x1)/2))x0=xm;else x1=xm;if(bottom=y>=(ym=(y0+y1)/2))y0=ym;else y1=ym;}while((i=bottom<<1|right)===(j=(yp>=ym)<<1|xp>=xm));return parent[j]=node,parent[i]=leaf,tree;}function addAll(data){var d,i,n=data.length,x,y,xz=new Array(n),yz=new Array(n),x0=Infinity,y0=Infinity,x1=-Infinity,y1=-Infinity;// Compute the points and their extent.\nfor(i=0;i<n;++i){if(isNaN(x=+this._x.call(null,d=data[i]))||isNaN(y=+this._y.call(null,d)))continue;xz[i]=x;yz[i]=y;if(x<x0)x0=x;if(x>x1)x1=x;if(y<y0)y0=y;if(y>y1)y1=y;}// If there were no (valid) points, inherit the existing extent.\nif(x1<x0)x0=this._x0,x1=this._x1;if(y1<y0)y0=this._y0,y1=this._y1;// Expand the tree to cover the new points.\nthis.cover(x0,y0).cover(x1,y1);// Add the new points.\nfor(i=0;i<n;++i){add(this,xz[i],yz[i],data[i]);}return this;}function tree_cover(x,y){if(isNaN(x=+x)||isNaN(y=+y))return this;// ignore invalid points\nvar x0=this._x0,y0=this._y0,x1=this._x1,y1=this._y1;// If the quadtree has no extent, initialize them.\n// Integer extent are necessary so that if we later double the extent,\n// the existing quadrant boundaries don’t change due to floating point error!\nif(isNaN(x0)){x1=(x0=Math.floor(x))+1;y1=(y0=Math.floor(y))+1;}// Otherwise, double repeatedly to cover.\nelse if(x0>x||x>x1||y0>y||y>y1){var z=x1-x0,node=this._root,parent,i;switch(i=(y<(y0+y1)/2)<<1|x<(x0+x1)/2){case 0:{do{parent=new Array(4),parent[i]=node,node=parent;}while((z*=2,x1=x0+z,y1=y0+z,x>x1||y>y1));break;}case 1:{do{parent=new Array(4),parent[i]=node,node=parent;}while((z*=2,x0=x1-z,y1=y0+z,x0>x||y>y1));break;}case 2:{do{parent=new Array(4),parent[i]=node,node=parent;}while((z*=2,x1=x0+z,y0=y1-z,x>x1||y0>y));break;}case 3:{do{parent=new Array(4),parent[i]=node,node=parent;}while((z*=2,x0=x1-z,y0=y1-z,x0>x||y0>y));break;}}if(this._root&&this._root.length)this._root=node;}// If the quadtree covers the point already, just return.\nelse return this;this._x0=x0;this._y0=y0;this._x1=x1;this._y1=y1;return this;}function tree_data(){var data=[];this.visit(function(node){if(!node.length)do{data.push(node.data);}while(node=node.next);});return data;}function tree_extent(_){return arguments.length?this.cover(+_[0][0],+_[0][1]).cover(+_[1][0],+_[1][1]):isNaN(this._x0)?undefined:[[this._x0,this._y0],[this._x1,this._y1]];}function Quad(node,x0,y0,x1,y1){this.node=node;this.x0=x0;this.y0=y0;this.x1=x1;this.y1=y1;}function tree_find(x,y,radius){var data,x0=this._x0,y0=this._y0,x1,y1,x2,y2,x3=this._x1,y3=this._y1,quads=[],node=this._root,q,i;if(node)quads.push(new Quad(node,x0,y0,x3,y3));if(radius==null)radius=Infinity;else{x0=x-radius,y0=y-radius;x3=x+radius,y3=y+radius;radius*=radius;}while(q=quads.pop()){// Stop searching if this quadrant can’t contain a closer node.\nif(!(node=q.node)||(x1=q.x0)>x3||(y1=q.y0)>y3||(x2=q.x1)<x0||(y2=q.y1)<y0)continue;// Bisect the current quadrant.\nif(node.length){var xm=(x1+x2)/2,ym=(y1+y2)/2;quads.push(new Quad(node[3],xm,ym,x2,y2),new Quad(node[2],x1,ym,xm,y2),new Quad(node[1],xm,y1,x2,ym),new Quad(node[0],x1,y1,xm,ym));// Visit the closest quadrant first.\nif(i=(y>=ym)<<1|x>=xm){q=quads[quads.length-1];quads[quads.length-1]=quads[quads.length-1-i];quads[quads.length-1-i]=q;}}// Visit this point. (Visiting coincident points isn’t necessary!)\nelse{var dx=x-+this._x.call(null,node.data),dy=y-+this._y.call(null,node.data),d2=dx*dx+dy*dy;if(d2<radius){var d=Math.sqrt(radius=d2);x0=x-d,y0=y-d;x3=x+d,y3=y+d;data=node.data;}}}return data;}function tree_remove(d){if(isNaN(x=+this._x.call(null,d))||isNaN(y=+this._y.call(null,d)))return this;// ignore invalid points\nvar parent,node=this._root,retainer,previous,next,x0=this._x0,y0=this._y0,x1=this._x1,y1=this._y1,x,y,xm,ym,right,bottom,i,j;// If the tree is empty, initialize the root as a leaf.\nif(!node)return this;// Find the leaf node for the point.\n// While descending, also retain the deepest parent with a non-removed sibling.\nif(node.length)while(true){if(right=x>=(xm=(x0+x1)/2))x0=xm;else x1=xm;if(bottom=y>=(ym=(y0+y1)/2))y0=ym;else y1=ym;if(!(parent=node,node=node[i=bottom<<1|right]))return this;if(!node.length)break;if(parent[i+1&3]||parent[i+2&3]||parent[i+3&3])retainer=parent,j=i;}// Find the point to remove.\nwhile(node.data!==d){if(!(previous=node,node=node.next))return this;}if(next=node.next)delete node.next;// If there are multiple coincident points, remove just the point.\nif(previous)return next?previous.next=next:delete previous.next,this;// If this is the root point, remove it.\nif(!parent)return this._root=next,this;// Remove this leaf.\nnext?parent[i]=next:delete parent[i];// If the parent now contains exactly one leaf, collapse superfluous parents.\nif((node=parent[0]||parent[1]||parent[2]||parent[3])&&node===(parent[3]||parent[2]||parent[1]||parent[0])&&!node.length){if(retainer)retainer[j]=node;else this._root=node;}return this;}function removeAll(data){for(var i=0,n=data.length;i<n;++i){this.remove(data[i]);}return this;}function tree_root(){return this._root;}function tree_size(){var size=0;this.visit(function(node){if(!node.length)do{++size;}while(node=node.next);});return size;}function tree_visit(callback){var quads=[],q,node=this._root,child,x0,y0,x1,y1;if(node)quads.push(new Quad(node,this._x0,this._y0,this._x1,this._y1));while(q=quads.pop()){if(!callback(node=q.node,x0=q.x0,y0=q.y0,x1=q.x1,y1=q.y1)&&node.length){var xm=(x0+x1)/2,ym=(y0+y1)/2;if(child=node[3])quads.push(new Quad(child,xm,ym,x1,y1));if(child=node[2])quads.push(new Quad(child,x0,ym,xm,y1));if(child=node[1])quads.push(new Quad(child,xm,y0,x1,ym));if(child=node[0])quads.push(new Quad(child,x0,y0,xm,ym));}}return this;}function tree_visitAfter(callback){var quads=[],next=[],q;if(this._root)quads.push(new Quad(this._root,this._x0,this._y0,this._x1,this._y1));while(q=quads.pop()){var node=q.node;if(node.length){var child,x0=q.x0,y0=q.y0,x1=q.x1,y1=q.y1,xm=(x0+x1)/2,ym=(y0+y1)/2;if(child=node[0])quads.push(new Quad(child,x0,y0,xm,ym));if(child=node[1])quads.push(new Quad(child,xm,y0,x1,ym));if(child=node[2])quads.push(new Quad(child,x0,ym,xm,y1));if(child=node[3])quads.push(new Quad(child,xm,ym,x1,y1));}next.push(q);}while(q=next.pop()){callback(q.node,q.x0,q.y0,q.x1,q.y1);}return this;}function defaultX$1(d){return d[0];}function tree_x(_){return arguments.length?(this._x=_,this):this._x;}function defaultY$1(d){return d[1];}function tree_y(_){return arguments.length?(this._y=_,this):this._y;}function quadtree(nodes,x,y){var tree=new Quadtree(x==null?defaultX$1:x,y==null?defaultY$1:y,NaN,NaN,NaN,NaN);return nodes==null?tree:tree.addAll(nodes);}function Quadtree(x,y,x0,y0,x1,y1){this._x=x;this._y=y;this._x0=x0;this._y0=y0;this._x1=x1;this._y1=y1;this._root=undefined;}function leaf_copy(leaf){var copy={data:leaf.data},next=copy;while(leaf=leaf.next){next=next.next={data:leaf.data};}return copy;}var treeProto=quadtree.prototype=Quadtree.prototype;treeProto.copy=function(){var copy=new Quadtree(this._x,this._y,this._x0,this._y0,this._x1,this._y1),node=this._root,nodes,child;if(!node)return copy;if(!node.length)return copy._root=leaf_copy(node),copy;nodes=[{source:node,target:copy._root=new Array(4)}];while(node=nodes.pop()){for(var i=0;i<4;++i){if(child=node.source[i]){if(child.length)nodes.push({source:child,target:node.target[i]=new Array(4)});else node.target[i]=leaf_copy(child);}}}return copy;};treeProto.add=tree_add;treeProto.addAll=addAll;treeProto.cover=tree_cover;treeProto.data=tree_data;treeProto.extent=tree_extent;treeProto.find=tree_find;treeProto.remove=tree_remove;treeProto.removeAll=removeAll;treeProto.root=tree_root;treeProto.size=tree_size;treeProto.visit=tree_visit;treeProto.visitAfter=tree_visitAfter;treeProto.x=tree_x;treeProto.y=tree_y;function x(d){return d.x+d.vx;}function y(d){return d.y+d.vy;}function collide(radius){var nodes,radii,strength=1,iterations=1;if(typeof radius!==\"function\")radius=constant$7(radius==null?1:+radius);function force(){var i,n=nodes.length,tree,node,xi,yi,ri,ri2;for(var k=0;k<iterations;++k){tree=quadtree(nodes,x,y).visitAfter(prepare);for(i=0;i<n;++i){node=nodes[i];ri=radii[node.index],ri2=ri*ri;xi=node.x+node.vx;yi=node.y+node.vy;tree.visit(apply);}}function apply(quad,x0,y0,x1,y1){var data=quad.data,rj=quad.r,r=ri+rj;if(data){if(data.index>node.index){var x=xi-data.x-data.vx,y=yi-data.y-data.vy,l=x*x+y*y;if(l<r*r){if(x===0)x=jiggle(),l+=x*x;if(y===0)y=jiggle(),l+=y*y;l=(r-(l=Math.sqrt(l)))/l*strength;node.vx+=(x*=l)*(r=(rj*=rj)/(ri2+rj));node.vy+=(y*=l)*r;data.vx-=x*(r=1-r);data.vy-=y*r;}}return;}return x0>xi+r||x1<xi-r||y0>yi+r||y1<yi-r;}}function prepare(quad){if(quad.data)return quad.r=radii[quad.data.index];for(var i=quad.r=0;i<4;++i){if(quad[i]&&quad[i].r>quad.r){quad.r=quad[i].r;}}}function initialize(){if(!nodes)return;var i,n=nodes.length,node;radii=new Array(n);for(i=0;i<n;++i){node=nodes[i],radii[node.index]=+radius(node,i,nodes);}}force.initialize=function(_){nodes=_;initialize();};force.iterations=function(_){return arguments.length?(iterations=+_,force):iterations;};force.strength=function(_){return arguments.length?(strength=+_,force):strength;};force.radius=function(_){return arguments.length?(radius=typeof _===\"function\"?_:constant$7(+_),initialize(),force):radius;};return force;}function index(d){return d.index;}function find(nodeById,nodeId){var node=nodeById.get(nodeId);if(!node)throw new Error(\"missing: \"+nodeId);return node;}function link(links){var id=index,strength=defaultStrength,strengths,distance=constant$7(30),distances,nodes,count,bias,iterations=1;if(links==null)links=[];function defaultStrength(link){return 1/Math.min(count[link.source.index],count[link.target.index]);}function force(alpha){for(var k=0,n=links.length;k<iterations;++k){for(var i=0,link,source,target,x,y,l,b;i<n;++i){link=links[i],source=link.source,target=link.target;x=target.x+target.vx-source.x-source.vx||jiggle();y=target.y+target.vy-source.y-source.vy||jiggle();l=Math.sqrt(x*x+y*y);l=(l-distances[i])/l*alpha*strengths[i];x*=l,y*=l;target.vx-=x*(b=bias[i]);target.vy-=y*b;source.vx+=x*(b=1-b);source.vy+=y*b;}}}function initialize(){if(!nodes)return;var i,n=nodes.length,m=links.length,nodeById=map$1(nodes,id),link;for(i=0,count=new Array(n);i<m;++i){link=links[i],link.index=i;if(_typeof(link.source)!==\"object\")link.source=find(nodeById,link.source);if(_typeof(link.target)!==\"object\")link.target=find(nodeById,link.target);count[link.source.index]=(count[link.source.index]||0)+1;count[link.target.index]=(count[link.target.index]||0)+1;}for(i=0,bias=new Array(m);i<m;++i){link=links[i],bias[i]=count[link.source.index]/(count[link.source.index]+count[link.target.index]);}strengths=new Array(m),initializeStrength();distances=new Array(m),initializeDistance();}function initializeStrength(){if(!nodes)return;for(var i=0,n=links.length;i<n;++i){strengths[i]=+strength(links[i],i,links);}}function initializeDistance(){if(!nodes)return;for(var i=0,n=links.length;i<n;++i){distances[i]=+distance(links[i],i,links);}}force.initialize=function(_){nodes=_;initialize();};force.links=function(_){return arguments.length?(links=_,initialize(),force):links;};force.id=function(_){return arguments.length?(id=_,force):id;};force.iterations=function(_){return arguments.length?(iterations=+_,force):iterations;};force.strength=function(_){return arguments.length?(strength=typeof _===\"function\"?_:constant$7(+_),initializeStrength(),force):strength;};force.distance=function(_){return arguments.length?(distance=typeof _===\"function\"?_:constant$7(+_),initializeDistance(),force):distance;};return force;}function x$1(d){return d.x;}function y$1(d){return d.y;}var initialRadius=10,initialAngle=Math.PI*(3-Math.sqrt(5));function simulation(_nodes){var simulation,_alpha=1,_alphaMin=0.001,_alphaDecay=1-Math.pow(_alphaMin,1/300),_alphaTarget=0,_velocityDecay=0.6,forces=map$1(),stepper=timer(step),event=dispatch(\"tick\",\"end\");if(_nodes==null)_nodes=[];function step(){tick();event.call(\"tick\",simulation);if(_alpha<_alphaMin){stepper.stop();event.call(\"end\",simulation);}}function tick(){var i,n=_nodes.length,node;_alpha+=(_alphaTarget-_alpha)*_alphaDecay;forces.each(function(force){force(_alpha);});for(i=0;i<n;++i){node=_nodes[i];if(node.fx==null)node.x+=node.vx*=_velocityDecay;else node.x=node.fx,node.vx=0;if(node.fy==null)node.y+=node.vy*=_velocityDecay;else node.y=node.fy,node.vy=0;}}function initializeNodes(){for(var i=0,n=_nodes.length,node;i<n;++i){node=_nodes[i],node.index=i;if(isNaN(node.x)||isNaN(node.y)){var radius=initialRadius*Math.sqrt(i),angle=i*initialAngle;node.x=radius*Math.cos(angle);node.y=radius*Math.sin(angle);}if(isNaN(node.vx)||isNaN(node.vy)){node.vx=node.vy=0;}}}function initializeForce(force){if(force.initialize)force.initialize(_nodes);return force;}initializeNodes();return simulation={tick:tick,restart:function restart(){return stepper.restart(step),simulation;},stop:function stop(){return stepper.stop(),simulation;},nodes:function nodes(_){return arguments.length?(_nodes=_,initializeNodes(),forces.each(initializeForce),simulation):_nodes;},alpha:function alpha(_){return arguments.length?(_alpha=+_,simulation):_alpha;},alphaMin:function alphaMin(_){return arguments.length?(_alphaMin=+_,simulation):_alphaMin;},alphaDecay:function alphaDecay(_){return arguments.length?(_alphaDecay=+_,simulation):+_alphaDecay;},alphaTarget:function alphaTarget(_){return arguments.length?(_alphaTarget=+_,simulation):_alphaTarget;},velocityDecay:function velocityDecay(_){return arguments.length?(_velocityDecay=1-_,simulation):1-_velocityDecay;},force:function force(name,_){return arguments.length>1?(_==null?forces.remove(name):forces.set(name,initializeForce(_)),simulation):forces.get(name);},find:function find(x,y,radius){var i=0,n=_nodes.length,dx,dy,d2,node,closest;if(radius==null)radius=Infinity;else radius*=radius;for(i=0;i<n;++i){node=_nodes[i];dx=x-node.x;dy=y-node.y;d2=dx*dx+dy*dy;if(d2<radius)closest=node,radius=d2;}return closest;},on:function on(name,_){return arguments.length>1?(event.on(name,_),simulation):event.on(name);}};}function manyBody(){var nodes,node,alpha,strength=constant$7(-30),strengths,distanceMin2=1,distanceMax2=Infinity,theta2=0.81;function force(_){var i,n=nodes.length,tree=quadtree(nodes,x$1,y$1).visitAfter(accumulate);for(alpha=_,i=0;i<n;++i){node=nodes[i],tree.visit(apply);}}function initialize(){if(!nodes)return;var i,n=nodes.length,node;strengths=new Array(n);for(i=0;i<n;++i){node=nodes[i],strengths[node.index]=+strength(node,i,nodes);}}function accumulate(quad){var strength=0,q,c,weight=0,x,y,i;// For internal nodes, accumulate forces from child quadrants.\nif(quad.length){for(x=y=i=0;i<4;++i){if((q=quad[i])&&(c=Math.abs(q.value))){strength+=q.value,weight+=c,x+=c*q.x,y+=c*q.y;}}quad.x=x/weight;quad.y=y/weight;}// For leaf nodes, accumulate forces from coincident quadrants.\nelse{q=quad;q.x=q.data.x;q.y=q.data.y;do{strength+=strengths[q.data.index];}while(q=q.next);}quad.value=strength;}function apply(quad,x1,_,x2){if(!quad.value)return true;var x=quad.x-node.x,y=quad.y-node.y,w=x2-x1,l=x*x+y*y;// Apply the Barnes-Hut approximation if possible.\n// Limit forces for very close nodes; randomize direction if coincident.\nif(w*w/theta2<l){if(l<distanceMax2){if(x===0)x=jiggle(),l+=x*x;if(y===0)y=jiggle(),l+=y*y;if(l<distanceMin2)l=Math.sqrt(distanceMin2*l);node.vx+=x*quad.value*alpha/l;node.vy+=y*quad.value*alpha/l;}return true;}// Otherwise, process points directly.\nelse if(quad.length||l>=distanceMax2)return;// Limit forces for very close nodes; randomize direction if coincident.\nif(quad.data!==node||quad.next){if(x===0)x=jiggle(),l+=x*x;if(y===0)y=jiggle(),l+=y*y;if(l<distanceMin2)l=Math.sqrt(distanceMin2*l);}do{if(quad.data!==node){w=strengths[quad.data.index]*alpha/l;node.vx+=x*w;node.vy+=y*w;}}while(quad=quad.next);}force.initialize=function(_){nodes=_;initialize();};force.strength=function(_){return arguments.length?(strength=typeof _===\"function\"?_:constant$7(+_),initialize(),force):strength;};force.distanceMin=function(_){return arguments.length?(distanceMin2=_*_,force):Math.sqrt(distanceMin2);};force.distanceMax=function(_){return arguments.length?(distanceMax2=_*_,force):Math.sqrt(distanceMax2);};force.theta=function(_){return arguments.length?(theta2=_*_,force):Math.sqrt(theta2);};return force;}function radial(radius,x,y){var nodes,strength=constant$7(0.1),strengths,radiuses;if(typeof radius!==\"function\")radius=constant$7(+radius);if(x==null)x=0;if(y==null)y=0;function force(alpha){for(var i=0,n=nodes.length;i<n;++i){var node=nodes[i],dx=node.x-x||1e-6,dy=node.y-y||1e-6,r=Math.sqrt(dx*dx+dy*dy),k=(radiuses[i]-r)*strengths[i]*alpha/r;node.vx+=dx*k;node.vy+=dy*k;}}function initialize(){if(!nodes)return;var i,n=nodes.length;strengths=new Array(n);radiuses=new Array(n);for(i=0;i<n;++i){radiuses[i]=+radius(nodes[i],i,nodes);strengths[i]=isNaN(radiuses[i])?0:+strength(nodes[i],i,nodes);}}force.initialize=function(_){nodes=_,initialize();};force.strength=function(_){return arguments.length?(strength=typeof _===\"function\"?_:constant$7(+_),initialize(),force):strength;};force.radius=function(_){return arguments.length?(radius=typeof _===\"function\"?_:constant$7(+_),initialize(),force):radius;};force.x=function(_){return arguments.length?(x=+_,force):x;};force.y=function(_){return arguments.length?(y=+_,force):y;};return force;}function x$2(x){var strength=constant$7(0.1),nodes,strengths,xz;if(typeof x!==\"function\")x=constant$7(x==null?0:+x);function force(alpha){for(var i=0,n=nodes.length,node;i<n;++i){node=nodes[i],node.vx+=(xz[i]-node.x)*strengths[i]*alpha;}}function initialize(){if(!nodes)return;var i,n=nodes.length;strengths=new Array(n);xz=new Array(n);for(i=0;i<n;++i){strengths[i]=isNaN(xz[i]=+x(nodes[i],i,nodes))?0:+strength(nodes[i],i,nodes);}}force.initialize=function(_){nodes=_;initialize();};force.strength=function(_){return arguments.length?(strength=typeof _===\"function\"?_:constant$7(+_),initialize(),force):strength;};force.x=function(_){return arguments.length?(x=typeof _===\"function\"?_:constant$7(+_),initialize(),force):x;};return force;}function y$2(y){var strength=constant$7(0.1),nodes,strengths,yz;if(typeof y!==\"function\")y=constant$7(y==null?0:+y);function force(alpha){for(var i=0,n=nodes.length,node;i<n;++i){node=nodes[i],node.vy+=(yz[i]-node.y)*strengths[i]*alpha;}}function initialize(){if(!nodes)return;var i,n=nodes.length;strengths=new Array(n);yz=new Array(n);for(i=0;i<n;++i){strengths[i]=isNaN(yz[i]=+y(nodes[i],i,nodes))?0:+strength(nodes[i],i,nodes);}}force.initialize=function(_){nodes=_;initialize();};force.strength=function(_){return arguments.length?(strength=typeof _===\"function\"?_:constant$7(+_),initialize(),force):strength;};force.y=function(_){return arguments.length?(y=typeof _===\"function\"?_:constant$7(+_),initialize(),force):y;};return force;}// Computes the decimal coefficient and exponent of the specified number x with\n// significant digits p, where x is positive and p is in [1, 21] or undefined.\n// For example, formatDecimal(1.23) returns [\"123\", 0].\nfunction formatDecimal(x,p){if((i=(x=p?x.toExponential(p-1):x.toExponential()).indexOf(\"e\"))<0)return null;// NaN, ±Infinity\nvar i,coefficient=x.slice(0,i);// The string returned by toExponential either has the form \\d\\.\\d+e[-+]\\d+\n// (e.g., 1.2e+3) or the form \\de[-+]\\d+ (e.g., 1e+3).\nreturn[coefficient.length>1?coefficient[0]+coefficient.slice(2):coefficient,+x.slice(i+1)];}function exponent$1(x){return x=formatDecimal(Math.abs(x)),x?x[1]:NaN;}function formatGroup(grouping,thousands){return function(value,width){var i=value.length,t=[],j=0,g=grouping[0],length=0;while(i>0&&g>0){if(length+g+1>width)g=Math.max(1,width-length);t.push(value.substring(i-=g,i+g));if((length+=g+1)>width)break;g=grouping[j=(j+1)%grouping.length];}return t.reverse().join(thousands);};}function formatNumerals(numerals){return function(value){return value.replace(/[0-9]/g,function(i){return numerals[+i];});};}// [[fill]align][sign][symbol][0][width][,][.precision][~][type]\nvar re=/^(?:(.)?([<>=^]))?([+\\-\\( ])?([$#])?(0)?(\\d+)?(,)?(\\.\\d+)?(~)?([a-z%])?$/i;function formatSpecifier(specifier){return new FormatSpecifier(specifier);}formatSpecifier.prototype=FormatSpecifier.prototype;// instanceof\nfunction FormatSpecifier(specifier){if(!(match=re.exec(specifier)))throw new Error(\"invalid format: \"+specifier);var match;this.fill=match[1]||\" \";this.align=match[2]||\">\";this.sign=match[3]||\"-\";this.symbol=match[4]||\"\";this.zero=!!match[5];this.width=match[6]&&+match[6];this.comma=!!match[7];this.precision=match[8]&&+match[8].slice(1);this.trim=!!match[9];this.type=match[10]||\"\";}FormatSpecifier.prototype.toString=function(){return this.fill+this.align+this.sign+this.symbol+(this.zero?\"0\":\"\")+(this.width==null?\"\":Math.max(1,this.width|0))+(this.comma?\",\":\"\")+(this.precision==null?\"\":\".\"+Math.max(0,this.precision|0))+(this.trim?\"~\":\"\")+this.type;};// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.\nfunction formatTrim(s){out:for(var n=s.length,i=1,i0=-1,i1;i<n;++i){switch(s[i]){case\".\":i0=i1=i;break;case\"0\":if(i0===0)i0=i;i1=i;break;default:if(i0>0){if(!+s[i])break out;i0=0;}break;}}return i0>0?s.slice(0,i0)+s.slice(i1+1):s;}var prefixExponent;function formatPrefixAuto(x,p){var d=formatDecimal(x,p);if(!d)return x+\"\";var coefficient=d[0],exponent=d[1],i=exponent-(prefixExponent=Math.max(-8,Math.min(8,Math.floor(exponent/3)))*3)+1,n=coefficient.length;return i===n?coefficient:i>n?coefficient+new Array(i-n+1).join(\"0\"):i>0?coefficient.slice(0,i)+\".\"+coefficient.slice(i):\"0.\"+new Array(1-i).join(\"0\")+formatDecimal(x,Math.max(0,p+i-1))[0];// less than 1y!\n}function formatRounded(x,p){var d=formatDecimal(x,p);if(!d)return x+\"\";var coefficient=d[0],exponent=d[1];return exponent<0?\"0.\"+new Array(-exponent).join(\"0\")+coefficient:coefficient.length>exponent+1?coefficient.slice(0,exponent+1)+\".\"+coefficient.slice(exponent+1):coefficient+new Array(exponent-coefficient.length+2).join(\"0\");}var formatTypes={\"%\":function _(x,p){return(x*100).toFixed(p);},\"b\":function b(x){return Math.round(x).toString(2);},\"c\":function c(x){return x+\"\";},\"d\":function d(x){return Math.round(x).toString(10);},\"e\":function e(x,p){return x.toExponential(p);},\"f\":function f(x,p){return x.toFixed(p);},\"g\":function g(x,p){return x.toPrecision(p);},\"o\":function o(x){return Math.round(x).toString(8);},\"p\":function p(x,_p){return formatRounded(x*100,_p);},\"r\":formatRounded,\"s\":formatPrefixAuto,\"X\":function X(x){return Math.round(x).toString(16).toUpperCase();},\"x\":function x(_x){return Math.round(_x).toString(16);}};function identity$3(x){return x;}var prefixes=[\"y\",\"z\",\"a\",\"f\",\"p\",\"n\",\"\\xB5\",\"m\",\"\",\"k\",\"M\",\"G\",\"T\",\"P\",\"E\",\"Z\",\"Y\"];function formatLocale(locale){var group=locale.grouping&&locale.thousands?formatGroup(locale.grouping,locale.thousands):identity$3,currency=locale.currency,decimal=locale.decimal,numerals=locale.numerals?formatNumerals(locale.numerals):identity$3,percent=locale.percent||\"%\";function newFormat(specifier){specifier=formatSpecifier(specifier);var fill=specifier.fill,align=specifier.align,sign=specifier.sign,symbol=specifier.symbol,zero=specifier.zero,width=specifier.width,comma=specifier.comma,precision=specifier.precision,trim=specifier.trim,type=specifier.type;// The \"n\" type is an alias for \",g\".\nif(type===\"n\")comma=true,type=\"g\";// The \"\" type, and any invalid type, is an alias for \".12~g\".\nelse if(!formatTypes[type])precision==null&&(precision=12),trim=true,type=\"g\";// If zero fill is specified, padding goes after sign and before digits.\nif(zero||fill===\"0\"&&align===\"=\")zero=true,fill=\"0\",align=\"=\";// Compute the prefix and suffix.\n// For SI-prefix, the suffix is lazily computed.\nvar prefix=symbol===\"$\"?currency[0]:symbol===\"#\"&&/[boxX]/.test(type)?\"0\"+type.toLowerCase():\"\",suffix=symbol===\"$\"?currency[1]:/[%p]/.test(type)?percent:\"\";// What format function should we use?\n// Is this an integer type?\n// Can this type generate exponential notation?\nvar formatType=formatTypes[type],maybeSuffix=/[defgprs%]/.test(type);// Set the default precision if not specified,\n// or clamp the specified precision to the supported range.\n// For significant precision, it must be in [1, 21].\n// For fixed precision, it must be in [0, 20].\nprecision=precision==null?6:/[gprs]/.test(type)?Math.max(1,Math.min(21,precision)):Math.max(0,Math.min(20,precision));function format(value){var valuePrefix=prefix,valueSuffix=suffix,i,n,c;if(type===\"c\"){valueSuffix=formatType(value)+valueSuffix;value=\"\";}else{value=+value;// Perform the initial formatting.\nvar valueNegative=value<0;value=formatType(Math.abs(value),precision);// Trim insignificant zeros.\nif(trim)value=formatTrim(value);// If a negative value rounds to zero during formatting, treat as positive.\nif(valueNegative&&+value===0)valueNegative=false;// Compute the prefix and suffix.\nvaluePrefix=(valueNegative?sign===\"(\"?sign:\"-\":sign===\"-\"||sign===\"(\"?\"\":sign)+valuePrefix;valueSuffix=(type===\"s\"?prefixes[8+prefixExponent/3]:\"\")+valueSuffix+(valueNegative&&sign===\"(\"?\")\":\"\");// Break the formatted value into the integer “value” part that can be\n// grouped, and fractional or exponential “suffix” part that is not.\nif(maybeSuffix){i=-1,n=value.length;while(++i<n){if(c=value.charCodeAt(i),48>c||c>57){valueSuffix=(c===46?decimal+value.slice(i+1):value.slice(i))+valueSuffix;value=value.slice(0,i);break;}}}}// If the fill character is not \"0\", grouping is applied before padding.\nif(comma&&!zero)value=group(value,Infinity);// Compute the padding.\nvar length=valuePrefix.length+value.length+valueSuffix.length,padding=length<width?new Array(width-length+1).join(fill):\"\";// If the fill character is \"0\", grouping is applied after padding.\nif(comma&&zero)value=group(padding+value,padding.length?width-valueSuffix.length:Infinity),padding=\"\";// Reconstruct the final output based on the desired alignment.\nswitch(align){case\"<\":value=valuePrefix+value+valueSuffix+padding;break;case\"=\":value=valuePrefix+padding+value+valueSuffix;break;case\"^\":value=padding.slice(0,length=padding.length>>1)+valuePrefix+value+valueSuffix+padding.slice(length);break;default:value=padding+valuePrefix+value+valueSuffix;break;}return numerals(value);}format.toString=function(){return specifier+\"\";};return format;}function formatPrefix(specifier,value){var f=newFormat((specifier=formatSpecifier(specifier),specifier.type=\"f\",specifier)),e=Math.max(-8,Math.min(8,Math.floor(exponent$1(value)/3)))*3,k=Math.pow(10,-e),prefix=prefixes[8+e/3];return function(value){return f(k*value)+prefix;};}return{format:newFormat,formatPrefix:formatPrefix};}var locale;defaultLocale({decimal:\".\",thousands:\",\",grouping:[3],currency:[\"$\",\"\"]});function defaultLocale(definition){locale=formatLocale(definition);d3.format=locale.format;d3.formatPrefix=locale.formatPrefix;return locale;}function precisionFixed(step){return Math.max(0,-exponent$1(Math.abs(step)));}function precisionPrefix(step,value){return Math.max(0,Math.max(-8,Math.min(8,Math.floor(exponent$1(value)/3)))*3-exponent$1(Math.abs(step)));}function precisionRound(step,max){step=Math.abs(step),max=Math.abs(max)-step;return Math.max(0,exponent$1(max)-exponent$1(step))+1;}// Adds floating point numbers with twice the normal precision.\n// Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and\n// Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)\n// 305–363 (1997).\n// Code adapted from GeographicLib by Charles F. F. Karney,\n// http://geographiclib.sourceforge.net/\nfunction adder(){return new Adder();}function Adder(){this.reset();}Adder.prototype={constructor:Adder,reset:function reset(){this.s=// rounded value\nthis.t=0;// exact error\n},add:function add(y){add$1(temp,y,this.t);add$1(this,temp.s,this.s);if(this.s)this.t+=temp.t;else this.s=temp.t;},valueOf:function valueOf(){return this.s;}};var temp=new Adder();function add$1(adder,a,b){var x=adder.s=a+b,bv=x-a,av=x-bv;adder.t=a-av+(b-bv);}var epsilon$2=1e-6;var epsilon2$1=1e-12;var pi$3=Math.PI;var halfPi$2=pi$3/2;var quarterPi=pi$3/4;var tau$3=pi$3*2;var degrees$1=180/pi$3;var radians=pi$3/180;var abs=Math.abs;var atan=Math.atan;var atan2=Math.atan2;var cos$1=Math.cos;var ceil=Math.ceil;var exp=Math.exp;var log=Math.log;var pow=Math.pow;var sin$1=Math.sin;var sign=Math.sign||function(x){return x>0?1:x<0?-1:0;};var sqrt=Math.sqrt;var tan=Math.tan;function acos(x){return x>1?0:x<-1?pi$3:Math.acos(x);}function asin(x){return x>1?halfPi$2:x<-1?-halfPi$2:Math.asin(x);}function haversin(x){return(x=sin$1(x/2))*x;}function noop$2(){}function streamGeometry(geometry,stream){if(geometry&&streamGeometryType.hasOwnProperty(geometry.type)){streamGeometryType[geometry.type](geometry,stream);}}var streamObjectType={Feature:function Feature(object,stream){streamGeometry(object.geometry,stream);},FeatureCollection:function FeatureCollection(object,stream){var features=object.features,i=-1,n=features.length;while(++i<n){streamGeometry(features[i].geometry,stream);}}};var streamGeometryType={Sphere:function Sphere(object,stream){stream.sphere();},Point:function Point(object,stream){object=object.coordinates;stream.point(object[0],object[1],object[2]);},MultiPoint:function MultiPoint(object,stream){var coordinates=object.coordinates,i=-1,n=coordinates.length;while(++i<n){object=coordinates[i],stream.point(object[0],object[1],object[2]);}},LineString:function LineString(object,stream){streamLine(object.coordinates,stream,0);},MultiLineString:function MultiLineString(object,stream){var coordinates=object.coordinates,i=-1,n=coordinates.length;while(++i<n){streamLine(coordinates[i],stream,0);}},Polygon:function Polygon(object,stream){streamPolygon(object.coordinates,stream);},MultiPolygon:function MultiPolygon(object,stream){var coordinates=object.coordinates,i=-1,n=coordinates.length;while(++i<n){streamPolygon(coordinates[i],stream);}},GeometryCollection:function GeometryCollection(object,stream){var geometries=object.geometries,i=-1,n=geometries.length;while(++i<n){streamGeometry(geometries[i],stream);}}};function streamLine(coordinates,stream,closed){var i=-1,n=coordinates.length-closed,coordinate;stream.lineStart();while(++i<n){coordinate=coordinates[i],stream.point(coordinate[0],coordinate[1],coordinate[2]);}stream.lineEnd();}function streamPolygon(coordinates,stream){var i=-1,n=coordinates.length;stream.polygonStart();while(++i<n){streamLine(coordinates[i],stream,1);}stream.polygonEnd();}function geoStream(object,stream){if(object&&streamObjectType.hasOwnProperty(object.type)){streamObjectType[object.type](object,stream);}else{streamGeometry(object,stream);}}var areaRingSum=adder();var areaSum=adder(),lambda00,phi00,lambda0,cosPhi0,sinPhi0;var areaStream={point:noop$2,lineStart:noop$2,lineEnd:noop$2,polygonStart:function polygonStart(){areaRingSum.reset();areaStream.lineStart=areaRingStart;areaStream.lineEnd=areaRingEnd;},polygonEnd:function polygonEnd(){var areaRing=+areaRingSum;areaSum.add(areaRing<0?tau$3+areaRing:areaRing);this.lineStart=this.lineEnd=this.point=noop$2;},sphere:function sphere(){areaSum.add(tau$3);}};function areaRingStart(){areaStream.point=areaPointFirst;}function areaRingEnd(){areaPoint(lambda00,phi00);}function areaPointFirst(lambda,phi){areaStream.point=areaPoint;lambda00=lambda,phi00=phi;lambda*=radians,phi*=radians;lambda0=lambda,cosPhi0=cos$1(phi=phi/2+quarterPi),sinPhi0=sin$1(phi);}function areaPoint(lambda,phi){lambda*=radians,phi*=radians;phi=phi/2+quarterPi;// half the angular distance from south pole\n// Spherical excess E for a spherical triangle with vertices: south pole,\n// previous point, current point.  Uses a formula derived from Cagnoli’s\n// theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).\nvar dLambda=lambda-lambda0,sdLambda=dLambda>=0?1:-1,adLambda=sdLambda*dLambda,cosPhi=cos$1(phi),sinPhi=sin$1(phi),k=sinPhi0*sinPhi,u=cosPhi0*cosPhi+k*cos$1(adLambda),v=k*sdLambda*sin$1(adLambda);areaRingSum.add(atan2(v,u));// Advance the previous points.\nlambda0=lambda,cosPhi0=cosPhi,sinPhi0=sinPhi;}function area$1(object){areaSum.reset();geoStream(object,areaStream);return areaSum*2;}function spherical(cartesian){return[atan2(cartesian[1],cartesian[0]),asin(cartesian[2])];}function cartesian(spherical){var lambda=spherical[0],phi=spherical[1],cosPhi=cos$1(phi);return[cosPhi*cos$1(lambda),cosPhi*sin$1(lambda),sin$1(phi)];}function cartesianDot(a,b){return a[0]*b[0]+a[1]*b[1]+a[2]*b[2];}function cartesianCross(a,b){return[a[1]*b[2]-a[2]*b[1],a[2]*b[0]-a[0]*b[2],a[0]*b[1]-a[1]*b[0]];}// TODO return a\nfunction cartesianAddInPlace(a,b){a[0]+=b[0],a[1]+=b[1],a[2]+=b[2];}function cartesianScale(vector,k){return[vector[0]*k,vector[1]*k,vector[2]*k];}// TODO return d\nfunction cartesianNormalizeInPlace(d){var l=sqrt(d[0]*d[0]+d[1]*d[1]+d[2]*d[2]);d[0]/=l,d[1]/=l,d[2]/=l;}var lambda0$1,phi0,lambda1,phi1,// bounds\nlambda2,// previous lambda-coordinate\nlambda00$1,phi00$1,// first point\np0,// previous 3D point\ndeltaSum=adder(),ranges,range;var boundsStream={point:boundsPoint,lineStart:boundsLineStart,lineEnd:boundsLineEnd,polygonStart:function polygonStart(){boundsStream.point=boundsRingPoint;boundsStream.lineStart=boundsRingStart;boundsStream.lineEnd=boundsRingEnd;deltaSum.reset();areaStream.polygonStart();},polygonEnd:function polygonEnd(){areaStream.polygonEnd();boundsStream.point=boundsPoint;boundsStream.lineStart=boundsLineStart;boundsStream.lineEnd=boundsLineEnd;if(areaRingSum<0)lambda0$1=-(lambda1=180),phi0=-(phi1=90);else if(deltaSum>epsilon$2)phi1=90;else if(deltaSum<-epsilon$2)phi0=-90;range[0]=lambda0$1,range[1]=lambda1;}};function boundsPoint(lambda,phi){ranges.push(range=[lambda0$1=lambda,lambda1=lambda]);if(phi<phi0)phi0=phi;if(phi>phi1)phi1=phi;}function linePoint(lambda,phi){var p=cartesian([lambda*radians,phi*radians]);if(p0){var normal=cartesianCross(p0,p),equatorial=[normal[1],-normal[0],0],inflection=cartesianCross(equatorial,normal);cartesianNormalizeInPlace(inflection);inflection=spherical(inflection);var delta=lambda-lambda2,sign$$1=delta>0?1:-1,lambdai=inflection[0]*degrees$1*sign$$1,phii,antimeridian=abs(delta)>180;if(antimeridian^(sign$$1*lambda2<lambdai&&lambdai<sign$$1*lambda)){phii=inflection[1]*degrees$1;if(phii>phi1)phi1=phii;}else if(lambdai=(lambdai+360)%360-180,antimeridian^(sign$$1*lambda2<lambdai&&lambdai<sign$$1*lambda)){phii=-inflection[1]*degrees$1;if(phii<phi0)phi0=phii;}else{if(phi<phi0)phi0=phi;if(phi>phi1)phi1=phi;}if(antimeridian){if(lambda<lambda2){if(angle(lambda0$1,lambda)>angle(lambda0$1,lambda1))lambda1=lambda;}else{if(angle(lambda,lambda1)>angle(lambda0$1,lambda1))lambda0$1=lambda;}}else{if(lambda1>=lambda0$1){if(lambda<lambda0$1)lambda0$1=lambda;if(lambda>lambda1)lambda1=lambda;}else{if(lambda>lambda2){if(angle(lambda0$1,lambda)>angle(lambda0$1,lambda1))lambda1=lambda;}else{if(angle(lambda,lambda1)>angle(lambda0$1,lambda1))lambda0$1=lambda;}}}}else{ranges.push(range=[lambda0$1=lambda,lambda1=lambda]);}if(phi<phi0)phi0=phi;if(phi>phi1)phi1=phi;p0=p,lambda2=lambda;}function boundsLineStart(){boundsStream.point=linePoint;}function boundsLineEnd(){range[0]=lambda0$1,range[1]=lambda1;boundsStream.point=boundsPoint;p0=null;}function boundsRingPoint(lambda,phi){if(p0){var delta=lambda-lambda2;deltaSum.add(abs(delta)>180?delta+(delta>0?360:-360):delta);}else{lambda00$1=lambda,phi00$1=phi;}areaStream.point(lambda,phi);linePoint(lambda,phi);}function boundsRingStart(){areaStream.lineStart();}function boundsRingEnd(){boundsRingPoint(lambda00$1,phi00$1);areaStream.lineEnd();if(abs(deltaSum)>epsilon$2)lambda0$1=-(lambda1=180);range[0]=lambda0$1,range[1]=lambda1;p0=null;}// Finds the left-right distance between two longitudes.\n// This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want\n// the distance between ±180° to be 360°.\nfunction angle(lambda0,lambda1){return(lambda1-=lambda0)<0?lambda1+360:lambda1;}function rangeCompare(a,b){return a[0]-b[0];}function rangeContains(range,x){return range[0]<=range[1]?range[0]<=x&&x<=range[1]:x<range[0]||range[1]<x;}function bounds(feature){var i,n,a,b,merged,deltaMax,delta;phi1=lambda1=-(lambda0$1=phi0=Infinity);ranges=[];geoStream(feature,boundsStream);// First, sort ranges by their minimum longitudes.\nif(n=ranges.length){ranges.sort(rangeCompare);// Then, merge any ranges that overlap.\nfor(i=1,a=ranges[0],merged=[a];i<n;++i){b=ranges[i];if(rangeContains(a,b[0])||rangeContains(a,b[1])){if(angle(a[0],b[1])>angle(a[0],a[1]))a[1]=b[1];if(angle(b[0],a[1])>angle(a[0],a[1]))a[0]=b[0];}else{merged.push(a=b);}}// Finally, find the largest gap between the merged ranges.\n// The final bounding box will be the inverse of this gap.\nfor(deltaMax=-Infinity,n=merged.length-1,i=0,a=merged[n];i<=n;a=b,++i){b=merged[i];if((delta=angle(a[1],b[0]))>deltaMax)deltaMax=delta,lambda0$1=b[0],lambda1=a[1];}}ranges=range=null;return lambda0$1===Infinity||phi0===Infinity?[[NaN,NaN],[NaN,NaN]]:[[lambda0$1,phi0],[lambda1,phi1]];}var W0,W1,X0,Y0,Z0,X1,Y1,Z1,X2,Y2,Z2,lambda00$2,phi00$2,// first point\nx0,y0,z0;// previous point\nvar centroidStream={sphere:noop$2,point:centroidPoint,lineStart:centroidLineStart,lineEnd:centroidLineEnd,polygonStart:function polygonStart(){centroidStream.lineStart=centroidRingStart;centroidStream.lineEnd=centroidRingEnd;},polygonEnd:function polygonEnd(){centroidStream.lineStart=centroidLineStart;centroidStream.lineEnd=centroidLineEnd;}};// Arithmetic mean of Cartesian vectors.\nfunction centroidPoint(lambda,phi){lambda*=radians,phi*=radians;var cosPhi=cos$1(phi);centroidPointCartesian(cosPhi*cos$1(lambda),cosPhi*sin$1(lambda),sin$1(phi));}function centroidPointCartesian(x,y,z){++W0;X0+=(x-X0)/W0;Y0+=(y-Y0)/W0;Z0+=(z-Z0)/W0;}function centroidLineStart(){centroidStream.point=centroidLinePointFirst;}function centroidLinePointFirst(lambda,phi){lambda*=radians,phi*=radians;var cosPhi=cos$1(phi);x0=cosPhi*cos$1(lambda);y0=cosPhi*sin$1(lambda);z0=sin$1(phi);centroidStream.point=centroidLinePoint;centroidPointCartesian(x0,y0,z0);}function centroidLinePoint(lambda,phi){lambda*=radians,phi*=radians;var cosPhi=cos$1(phi),x=cosPhi*cos$1(lambda),y=cosPhi*sin$1(lambda),z=sin$1(phi),w=atan2(sqrt((w=y0*z-z0*y)*w+(w=z0*x-x0*z)*w+(w=x0*y-y0*x)*w),x0*x+y0*y+z0*z);W1+=w;X1+=w*(x0+(x0=x));Y1+=w*(y0+(y0=y));Z1+=w*(z0+(z0=z));centroidPointCartesian(x0,y0,z0);}function centroidLineEnd(){centroidStream.point=centroidPoint;}// See J. E. Brock, The Inertia Tensor for a Spherical Triangle,\n// J. Applied Mechanics 42, 239 (1975).\nfunction centroidRingStart(){centroidStream.point=centroidRingPointFirst;}function centroidRingEnd(){centroidRingPoint(lambda00$2,phi00$2);centroidStream.point=centroidPoint;}function centroidRingPointFirst(lambda,phi){lambda00$2=lambda,phi00$2=phi;lambda*=radians,phi*=radians;centroidStream.point=centroidRingPoint;var cosPhi=cos$1(phi);x0=cosPhi*cos$1(lambda);y0=cosPhi*sin$1(lambda);z0=sin$1(phi);centroidPointCartesian(x0,y0,z0);}function centroidRingPoint(lambda,phi){lambda*=radians,phi*=radians;var cosPhi=cos$1(phi),x=cosPhi*cos$1(lambda),y=cosPhi*sin$1(lambda),z=sin$1(phi),cx=y0*z-z0*y,cy=z0*x-x0*z,cz=x0*y-y0*x,m=sqrt(cx*cx+cy*cy+cz*cz),w=asin(m),// line weight = angle\nv=m&&-w/m;// area weight multiplier\nX2+=v*cx;Y2+=v*cy;Z2+=v*cz;W1+=w;X1+=w*(x0+(x0=x));Y1+=w*(y0+(y0=y));Z1+=w*(z0+(z0=z));centroidPointCartesian(x0,y0,z0);}function centroid(object){W0=W1=X0=Y0=Z0=X1=Y1=Z1=X2=Y2=Z2=0;geoStream(object,centroidStream);var x=X2,y=Y2,z=Z2,m=x*x+y*y+z*z;// If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.\nif(m<epsilon2$1){x=X1,y=Y1,z=Z1;// If the feature has zero length, fall back to arithmetic mean of point vectors.\nif(W1<epsilon$2)x=X0,y=Y0,z=Z0;m=x*x+y*y+z*z;// If the feature still has an undefined ccentroid, then return.\nif(m<epsilon2$1)return[NaN,NaN];}return[atan2(y,x)*degrees$1,asin(z/sqrt(m))*degrees$1];}function constant$8(x){return function(){return x;};}function compose(a,b){function compose(x,y){return x=a(x,y),b(x[0],x[1]);}if(a.invert&&b.invert)compose.invert=function(x,y){return x=b.invert(x,y),x&&a.invert(x[0],x[1]);};return compose;}function rotationIdentity(lambda,phi){return[lambda>pi$3?lambda-tau$3:lambda<-pi$3?lambda+tau$3:lambda,phi];}rotationIdentity.invert=rotationIdentity;function rotateRadians(deltaLambda,deltaPhi,deltaGamma){return(deltaLambda%=tau$3)?deltaPhi||deltaGamma?compose(rotationLambda(deltaLambda),rotationPhiGamma(deltaPhi,deltaGamma)):rotationLambda(deltaLambda):deltaPhi||deltaGamma?rotationPhiGamma(deltaPhi,deltaGamma):rotationIdentity;}function forwardRotationLambda(deltaLambda){return function(lambda,phi){return lambda+=deltaLambda,[lambda>pi$3?lambda-tau$3:lambda<-pi$3?lambda+tau$3:lambda,phi];};}function rotationLambda(deltaLambda){var rotation=forwardRotationLambda(deltaLambda);rotation.invert=forwardRotationLambda(-deltaLambda);return rotation;}function rotationPhiGamma(deltaPhi,deltaGamma){var cosDeltaPhi=cos$1(deltaPhi),sinDeltaPhi=sin$1(deltaPhi),cosDeltaGamma=cos$1(deltaGamma),sinDeltaGamma=sin$1(deltaGamma);function rotation(lambda,phi){var cosPhi=cos$1(phi),x=cos$1(lambda)*cosPhi,y=sin$1(lambda)*cosPhi,z=sin$1(phi),k=z*cosDeltaPhi+x*sinDeltaPhi;return[atan2(y*cosDeltaGamma-k*sinDeltaGamma,x*cosDeltaPhi-z*sinDeltaPhi),asin(k*cosDeltaGamma+y*sinDeltaGamma)];}rotation.invert=function(lambda,phi){var cosPhi=cos$1(phi),x=cos$1(lambda)*cosPhi,y=sin$1(lambda)*cosPhi,z=sin$1(phi),k=z*cosDeltaGamma-y*sinDeltaGamma;return[atan2(y*cosDeltaGamma+z*sinDeltaGamma,x*cosDeltaPhi+k*sinDeltaPhi),asin(k*cosDeltaPhi-x*sinDeltaPhi)];};return rotation;}function rotation(rotate){rotate=rotateRadians(rotate[0]*radians,rotate[1]*radians,rotate.length>2?rotate[2]*radians:0);function forward(coordinates){coordinates=rotate(coordinates[0]*radians,coordinates[1]*radians);return coordinates[0]*=degrees$1,coordinates[1]*=degrees$1,coordinates;}forward.invert=function(coordinates){coordinates=rotate.invert(coordinates[0]*radians,coordinates[1]*radians);return coordinates[0]*=degrees$1,coordinates[1]*=degrees$1,coordinates;};return forward;}// Generates a circle centered at [0°, 0°], with a given radius and precision.\nfunction circleStream(stream,radius,delta,direction,t0,t1){if(!delta)return;var cosRadius=cos$1(radius),sinRadius=sin$1(radius),step=direction*delta;if(t0==null){t0=radius+direction*tau$3;t1=radius-step/2;}else{t0=circleRadius(cosRadius,t0);t1=circleRadius(cosRadius,t1);if(direction>0?t0<t1:t0>t1)t0+=direction*tau$3;}for(var point,t=t0;direction>0?t>t1:t<t1;t-=step){point=spherical([cosRadius,-sinRadius*cos$1(t),-sinRadius*sin$1(t)]);stream.point(point[0],point[1]);}}// Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].\nfunction circleRadius(cosRadius,point){point=cartesian(point),point[0]-=cosRadius;cartesianNormalizeInPlace(point);var radius=acos(-point[1]);return((-point[2]<0?-radius:radius)+tau$3-epsilon$2)%tau$3;}function circle(){var center=constant$8([0,0]),radius=constant$8(90),precision=constant$8(6),ring,rotate,stream={point:point};function point(x,y){ring.push(x=rotate(x,y));x[0]*=degrees$1,x[1]*=degrees$1;}function circle(){var c=center.apply(this,arguments),r=radius.apply(this,arguments)*radians,p=precision.apply(this,arguments)*radians;ring=[];rotate=rotateRadians(-c[0]*radians,-c[1]*radians,0).invert;circleStream(stream,r,p,1);c={type:\"Polygon\",coordinates:[ring]};ring=rotate=null;return c;}circle.center=function(_){return arguments.length?(center=typeof _===\"function\"?_:constant$8([+_[0],+_[1]]),circle):center;};circle.radius=function(_){return arguments.length?(radius=typeof _===\"function\"?_:constant$8(+_),circle):radius;};circle.precision=function(_){return arguments.length?(precision=typeof _===\"function\"?_:constant$8(+_),circle):precision;};return circle;}function clipBuffer(){var lines=[],line;return{point:function point(x,y){line.push([x,y]);},lineStart:function lineStart(){lines.push(line=[]);},lineEnd:noop$2,rejoin:function rejoin(){if(lines.length>1)lines.push(lines.pop().concat(lines.shift()));},result:function result(){var result=lines;lines=[];line=null;return result;}};}function pointEqual(a,b){return abs(a[0]-b[0])<epsilon$2&&abs(a[1]-b[1])<epsilon$2;}function Intersection(point,points,other,entry){this.x=point;this.z=points;this.o=other;// another intersection\nthis.e=entry;// is an entry?\nthis.v=false;// visited\nthis.n=this.p=null;// next & previous\n}// A generalized polygon clipping algorithm: given a polygon that has been cut\n// into its visible line segments, and rejoins the segments by interpolating\n// along the clip edge.\nfunction clipRejoin(segments,compareIntersection,startInside,interpolate,stream){var subject=[],clip=[],i,n;segments.forEach(function(segment){if((n=segment.length-1)<=0)return;var n,p0=segment[0],p1=segment[n],x;// If the first and last points of a segment are coincident, then treat as a\n// closed ring. TODO if all rings are closed, then the winding order of the\n// exterior ring should be checked.\nif(pointEqual(p0,p1)){stream.lineStart();for(i=0;i<n;++i){stream.point((p0=segment[i])[0],p0[1]);}stream.lineEnd();return;}subject.push(x=new Intersection(p0,segment,null,true));clip.push(x.o=new Intersection(p0,null,x,false));subject.push(x=new Intersection(p1,segment,null,false));clip.push(x.o=new Intersection(p1,null,x,true));});if(!subject.length)return;clip.sort(compareIntersection);link$1(subject);link$1(clip);for(i=0,n=clip.length;i<n;++i){clip[i].e=startInside=!startInside;}var start=subject[0],points,point;while(1){// Find first unvisited intersection.\nvar current=start,isSubject=true;while(current.v){if((current=current.n)===start)return;}points=current.z;stream.lineStart();do{current.v=current.o.v=true;if(current.e){if(isSubject){for(i=0,n=points.length;i<n;++i){stream.point((point=points[i])[0],point[1]);}}else{interpolate(current.x,current.n.x,1,stream);}current=current.n;}else{if(isSubject){points=current.p.z;for(i=points.length-1;i>=0;--i){stream.point((point=points[i])[0],point[1]);}}else{interpolate(current.x,current.p.x,-1,stream);}current=current.p;}current=current.o;points=current.z;isSubject=!isSubject;}while(!current.v);stream.lineEnd();}}function link$1(array){if(!(n=array.length))return;var n,i=0,a=array[0],b;while(++i<n){a.n=b=array[i];b.p=a;a=b;}a.n=b=array[0];b.p=a;}var sum$1=adder();function polygonContains(polygon,point){var lambda=point[0],phi=point[1],sinPhi=sin$1(phi),normal=[sin$1(lambda),-cos$1(lambda),0],angle=0,winding=0;sum$1.reset();if(sinPhi===1)phi=halfPi$2+epsilon$2;else if(sinPhi===-1)phi=-halfPi$2-epsilon$2;for(var i=0,n=polygon.length;i<n;++i){if(!(m=(ring=polygon[i]).length))continue;var ring,m,point0=ring[m-1],lambda0=point0[0],phi0=point0[1]/2+quarterPi,sinPhi0=sin$1(phi0),cosPhi0=cos$1(phi0);for(var j=0;j<m;++j,lambda0=lambda1,sinPhi0=sinPhi1,cosPhi0=cosPhi1,point0=point1){var point1=ring[j],lambda1=point1[0],phi1=point1[1]/2+quarterPi,sinPhi1=sin$1(phi1),cosPhi1=cos$1(phi1),delta=lambda1-lambda0,sign$$1=delta>=0?1:-1,absDelta=sign$$1*delta,antimeridian=absDelta>pi$3,k=sinPhi0*sinPhi1;sum$1.add(atan2(k*sign$$1*sin$1(absDelta),cosPhi0*cosPhi1+k*cos$1(absDelta)));angle+=antimeridian?delta+sign$$1*tau$3:delta;// Are the longitudes either side of the point’s meridian (lambda),\n// and are the latitudes smaller than the parallel (phi)?\nif(antimeridian^lambda0>=lambda^lambda1>=lambda){var arc=cartesianCross(cartesian(point0),cartesian(point1));cartesianNormalizeInPlace(arc);var intersection=cartesianCross(normal,arc);cartesianNormalizeInPlace(intersection);var phiArc=(antimeridian^delta>=0?-1:1)*asin(intersection[2]);if(phi>phiArc||phi===phiArc&&(arc[0]||arc[1])){winding+=antimeridian^delta>=0?1:-1;}}}}// First, determine whether the South pole is inside or outside:\n//\n// It is inside if:\n// * the polygon winds around it in a clockwise direction.\n// * the polygon does not (cumulatively) wind around it, but has a negative\n//   (counter-clockwise) area.\n//\n// Second, count the (signed) number of times a segment crosses a lambda\n// from the point to the South pole.  If it is zero, then the point is the\n// same side as the South pole.\nreturn(angle<-epsilon$2||angle<epsilon$2&&sum$1<-epsilon$2)^winding&1;}function clip(pointVisible,clipLine,interpolate,start){return function(sink){var line=clipLine(sink),ringBuffer=clipBuffer(),ringSink=clipLine(ringBuffer),polygonStarted=false,polygon,segments,ring;var clip={point:point,lineStart:lineStart,lineEnd:lineEnd,polygonStart:function polygonStart(){clip.point=pointRing;clip.lineStart=ringStart;clip.lineEnd=ringEnd;segments=[];polygon=[];},polygonEnd:function polygonEnd(){clip.point=point;clip.lineStart=lineStart;clip.lineEnd=lineEnd;segments=merge(segments);var startInside=polygonContains(polygon,start);if(segments.length){if(!polygonStarted)sink.polygonStart(),polygonStarted=true;clipRejoin(segments,compareIntersection,startInside,interpolate,sink);}else if(startInside){if(!polygonStarted)sink.polygonStart(),polygonStarted=true;sink.lineStart();interpolate(null,null,1,sink);sink.lineEnd();}if(polygonStarted)sink.polygonEnd(),polygonStarted=false;segments=polygon=null;},sphere:function sphere(){sink.polygonStart();sink.lineStart();interpolate(null,null,1,sink);sink.lineEnd();sink.polygonEnd();}};function point(lambda,phi){if(pointVisible(lambda,phi))sink.point(lambda,phi);}function pointLine(lambda,phi){line.point(lambda,phi);}function lineStart(){clip.point=pointLine;line.lineStart();}function lineEnd(){clip.point=point;line.lineEnd();}function pointRing(lambda,phi){ring.push([lambda,phi]);ringSink.point(lambda,phi);}function ringStart(){ringSink.lineStart();ring=[];}function ringEnd(){pointRing(ring[0][0],ring[0][1]);ringSink.lineEnd();var clean=ringSink.clean(),ringSegments=ringBuffer.result(),i,n=ringSegments.length,m,segment,point;ring.pop();polygon.push(ring);ring=null;if(!n)return;// No intersections.\nif(clean&1){segment=ringSegments[0];if((m=segment.length-1)>0){if(!polygonStarted)sink.polygonStart(),polygonStarted=true;sink.lineStart();for(i=0;i<m;++i){sink.point((point=segment[i])[0],point[1]);}sink.lineEnd();}return;}// Rejoin connected segments.\n// TODO reuse ringBuffer.rejoin()?\nif(n>1&&clean&2)ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));segments.push(ringSegments.filter(validSegment));}return clip;};}function validSegment(segment){return segment.length>1;}// Intersections are sorted along the clip edge. For both antimeridian cutting\n// and circle clipping, the same comparison is used.\nfunction compareIntersection(a,b){return((a=a.x)[0]<0?a[1]-halfPi$2-epsilon$2:halfPi$2-a[1])-((b=b.x)[0]<0?b[1]-halfPi$2-epsilon$2:halfPi$2-b[1]);}var clipAntimeridian=clip(function(){return true;},clipAntimeridianLine,clipAntimeridianInterpolate,[-pi$3,-halfPi$2]);// Takes a line and cuts into visible segments. Return values: 0 - there were\n// intersections or the line was empty; 1 - no intersections; 2 - there were\n// intersections, and the first and last segments should be rejoined.\nfunction clipAntimeridianLine(stream){var lambda0=NaN,phi0=NaN,sign0=NaN,_clean;// no intersections\nreturn{lineStart:function lineStart(){stream.lineStart();_clean=1;},point:function point(lambda1,phi1){var sign1=lambda1>0?pi$3:-pi$3,delta=abs(lambda1-lambda0);if(abs(delta-pi$3)<epsilon$2){// line crosses a pole\nstream.point(lambda0,phi0=(phi0+phi1)/2>0?halfPi$2:-halfPi$2);stream.point(sign0,phi0);stream.lineEnd();stream.lineStart();stream.point(sign1,phi0);stream.point(lambda1,phi0);_clean=0;}else if(sign0!==sign1&&delta>=pi$3){// line crosses antimeridian\nif(abs(lambda0-sign0)<epsilon$2)lambda0-=sign0*epsilon$2;// handle degeneracies\nif(abs(lambda1-sign1)<epsilon$2)lambda1-=sign1*epsilon$2;phi0=clipAntimeridianIntersect(lambda0,phi0,lambda1,phi1);stream.point(sign0,phi0);stream.lineEnd();stream.lineStart();stream.point(sign1,phi0);_clean=0;}stream.point(lambda0=lambda1,phi0=phi1);sign0=sign1;},lineEnd:function lineEnd(){stream.lineEnd();lambda0=phi0=NaN;},clean:function clean(){return 2-_clean;// if intersections, rejoin first and last segments\n}};}function clipAntimeridianIntersect(lambda0,phi0,lambda1,phi1){var cosPhi0,cosPhi1,sinLambda0Lambda1=sin$1(lambda0-lambda1);return abs(sinLambda0Lambda1)>epsilon$2?atan((sin$1(phi0)*(cosPhi1=cos$1(phi1))*sin$1(lambda1)-sin$1(phi1)*(cosPhi0=cos$1(phi0))*sin$1(lambda0))/(cosPhi0*cosPhi1*sinLambda0Lambda1)):(phi0+phi1)/2;}function clipAntimeridianInterpolate(from,to,direction,stream){var phi;if(from==null){phi=direction*halfPi$2;stream.point(-pi$3,phi);stream.point(0,phi);stream.point(pi$3,phi);stream.point(pi$3,0);stream.point(pi$3,-phi);stream.point(0,-phi);stream.point(-pi$3,-phi);stream.point(-pi$3,0);stream.point(-pi$3,phi);}else if(abs(from[0]-to[0])>epsilon$2){var lambda=from[0]<to[0]?pi$3:-pi$3;phi=direction*lambda/2;stream.point(-lambda,phi);stream.point(0,phi);stream.point(lambda,phi);}else{stream.point(to[0],to[1]);}}function clipCircle(radius){var cr=cos$1(radius),delta=6*radians,smallRadius=cr>0,notHemisphere=abs(cr)>epsilon$2;// TODO optimise for this common case\nfunction interpolate(from,to,direction,stream){circleStream(stream,radius,delta,direction,from,to);}function visible(lambda,phi){return cos$1(lambda)*cos$1(phi)>cr;}// Takes a line and cuts into visible segments. Return values used for polygon\n// clipping: 0 - there were intersections or the line was empty; 1 - no\n// intersections 2 - there were intersections, and the first and last segments\n// should be rejoined.\nfunction clipLine(stream){var point0,// previous point\nc0,// code for previous point\nv0,// visibility of previous point\nv00,// visibility of first point\n_clean2;// no intersections\nreturn{lineStart:function lineStart(){v00=v0=false;_clean2=1;},point:function point(lambda,phi){var point1=[lambda,phi],point2,v=visible(lambda,phi),c=smallRadius?v?0:code(lambda,phi):v?code(lambda+(lambda<0?pi$3:-pi$3),phi):0;if(!point0&&(v00=v0=v))stream.lineStart();// Handle degeneracies.\n// TODO ignore if not clipping polygons.\nif(v!==v0){point2=intersect(point0,point1);if(!point2||pointEqual(point0,point2)||pointEqual(point1,point2)){point1[0]+=epsilon$2;point1[1]+=epsilon$2;v=visible(point1[0],point1[1]);}}if(v!==v0){_clean2=0;if(v){// outside going in\nstream.lineStart();point2=intersect(point1,point0);stream.point(point2[0],point2[1]);}else{// inside going out\npoint2=intersect(point0,point1);stream.point(point2[0],point2[1]);stream.lineEnd();}point0=point2;}else if(notHemisphere&&point0&&smallRadius^v){var t;// If the codes for two points are different, or are both zero,\n// and there this segment intersects with the small circle.\nif(!(c&c0)&&(t=intersect(point1,point0,true))){_clean2=0;if(smallRadius){stream.lineStart();stream.point(t[0][0],t[0][1]);stream.point(t[1][0],t[1][1]);stream.lineEnd();}else{stream.point(t[1][0],t[1][1]);stream.lineEnd();stream.lineStart();stream.point(t[0][0],t[0][1]);}}}if(v&&(!point0||!pointEqual(point0,point1))){stream.point(point1[0],point1[1]);}point0=point1,v0=v,c0=c;},lineEnd:function lineEnd(){if(v0)stream.lineEnd();point0=null;},// Rejoin first and last segments if there were intersections and the first\n// and last points were visible.\nclean:function clean(){return _clean2|(v00&&v0)<<1;}};}// Intersects the great circle between a and b with the clip circle.\nfunction intersect(a,b,two){var pa=cartesian(a),pb=cartesian(b);// We have two planes, n1.p = d1 and n2.p = d2.\n// Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).\nvar n1=[1,0,0],// normal\nn2=cartesianCross(pa,pb),n2n2=cartesianDot(n2,n2),n1n2=n2[0],// cartesianDot(n1, n2),\ndeterminant=n2n2-n1n2*n1n2;// Two polar points.\nif(!determinant)return!two&&a;var c1=cr*n2n2/determinant,c2=-cr*n1n2/determinant,n1xn2=cartesianCross(n1,n2),A=cartesianScale(n1,c1),B=cartesianScale(n2,c2);cartesianAddInPlace(A,B);// Solve |p(t)|^2 = 1.\nvar u=n1xn2,w=cartesianDot(A,u),uu=cartesianDot(u,u),t2=w*w-uu*(cartesianDot(A,A)-1);if(t2<0)return;var t=sqrt(t2),q=cartesianScale(u,(-w-t)/uu);cartesianAddInPlace(q,A);q=spherical(q);if(!two)return q;// Two intersection points.\nvar lambda0=a[0],lambda1=b[0],phi0=a[1],phi1=b[1],z;if(lambda1<lambda0)z=lambda0,lambda0=lambda1,lambda1=z;var delta=lambda1-lambda0,polar=abs(delta-pi$3)<epsilon$2,meridian=polar||delta<epsilon$2;if(!polar&&phi1<phi0)z=phi0,phi0=phi1,phi1=z;// Check that the first point is between a and b.\nif(meridian?polar?phi0+phi1>0^q[1]<(abs(q[0]-lambda0)<epsilon$2?phi0:phi1):phi0<=q[1]&&q[1]<=phi1:delta>pi$3^(lambda0<=q[0]&&q[0]<=lambda1)){var q1=cartesianScale(u,(-w+t)/uu);cartesianAddInPlace(q1,A);return[q,spherical(q1)];}}// Generates a 4-bit vector representing the location of a point relative to\n// the small circle's bounding box.\nfunction code(lambda,phi){var r=smallRadius?radius:pi$3-radius,code=0;if(lambda<-r)code|=1;// left\nelse if(lambda>r)code|=2;// right\nif(phi<-r)code|=4;// below\nelse if(phi>r)code|=8;// above\nreturn code;}return clip(visible,clipLine,interpolate,smallRadius?[0,-radius]:[-pi$3,radius-pi$3]);}function clipLine(a,b,x0,y0,x1,y1){var ax=a[0],ay=a[1],bx=b[0],by=b[1],t0=0,t1=1,dx=bx-ax,dy=by-ay,r;r=x0-ax;if(!dx&&r>0)return;r/=dx;if(dx<0){if(r<t0)return;if(r<t1)t1=r;}else if(dx>0){if(r>t1)return;if(r>t0)t0=r;}r=x1-ax;if(!dx&&r<0)return;r/=dx;if(dx<0){if(r>t1)return;if(r>t0)t0=r;}else if(dx>0){if(r<t0)return;if(r<t1)t1=r;}r=y0-ay;if(!dy&&r>0)return;r/=dy;if(dy<0){if(r<t0)return;if(r<t1)t1=r;}else if(dy>0){if(r>t1)return;if(r>t0)t0=r;}r=y1-ay;if(!dy&&r<0)return;r/=dy;if(dy<0){if(r>t1)return;if(r>t0)t0=r;}else if(dy>0){if(r<t0)return;if(r<t1)t1=r;}if(t0>0)a[0]=ax+t0*dx,a[1]=ay+t0*dy;if(t1<1)b[0]=ax+t1*dx,b[1]=ay+t1*dy;return true;}var clipMax=1e9,clipMin=-clipMax;// TODO Use d3-polygon’s polygonContains here for the ring check?\n// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?\nfunction clipRectangle(x0,y0,x1,y1){function visible(x,y){return x0<=x&&x<=x1&&y0<=y&&y<=y1;}function interpolate(from,to,direction,stream){var a=0,a1=0;if(from==null||(a=corner(from,direction))!==(a1=corner(to,direction))||comparePoint(from,to)<0^direction>0){do{stream.point(a===0||a===3?x0:x1,a>1?y1:y0);}while((a=(a+direction+4)%4)!==a1);}else{stream.point(to[0],to[1]);}}function corner(p,direction){return abs(p[0]-x0)<epsilon$2?direction>0?0:3:abs(p[0]-x1)<epsilon$2?direction>0?2:1:abs(p[1]-y0)<epsilon$2?direction>0?1:0:direction>0?3:2;// abs(p[1] - y1) < epsilon\n}function compareIntersection(a,b){return comparePoint(a.x,b.x);}function comparePoint(a,b){var ca=corner(a,1),cb=corner(b,1);return ca!==cb?ca-cb:ca===0?b[1]-a[1]:ca===1?a[0]-b[0]:ca===2?a[1]-b[1]:b[0]-a[0];}return function(stream){var activeStream=stream,bufferStream=clipBuffer(),segments,polygon,ring,x__,y__,v__,// first point\nx_,y_,v_,// previous point\nfirst,clean;var clipStream={point:point,lineStart:lineStart,lineEnd:lineEnd,polygonStart:polygonStart,polygonEnd:polygonEnd};function point(x,y){if(visible(x,y))activeStream.point(x,y);}function polygonInside(){var winding=0;for(var i=0,n=polygon.length;i<n;++i){for(var ring=polygon[i],j=1,m=ring.length,point=ring[0],a0,a1,b0=point[0],b1=point[1];j<m;++j){a0=b0,a1=b1,point=ring[j],b0=point[0],b1=point[1];if(a1<=y1){if(b1>y1&&(b0-a0)*(y1-a1)>(b1-a1)*(x0-a0))++winding;}else{if(b1<=y1&&(b0-a0)*(y1-a1)<(b1-a1)*(x0-a0))--winding;}}}return winding;}// Buffer geometry within a polygon and then clip it en masse.\nfunction polygonStart(){activeStream=bufferStream,segments=[],polygon=[],clean=true;}function polygonEnd(){var startInside=polygonInside(),cleanInside=clean&&startInside,visible=(segments=merge(segments)).length;if(cleanInside||visible){stream.polygonStart();if(cleanInside){stream.lineStart();interpolate(null,null,1,stream);stream.lineEnd();}if(visible){clipRejoin(segments,compareIntersection,startInside,interpolate,stream);}stream.polygonEnd();}activeStream=stream,segments=polygon=ring=null;}function lineStart(){clipStream.point=linePoint;if(polygon)polygon.push(ring=[]);first=true;v_=false;x_=y_=NaN;}// TODO rather than special-case polygons, simply handle them separately.\n// Ideally, coincident intersection points should be jittered to avoid\n// clipping issues.\nfunction lineEnd(){if(segments){linePoint(x__,y__);if(v__&&v_)bufferStream.rejoin();segments.push(bufferStream.result());}clipStream.point=point;if(v_)activeStream.lineEnd();}function linePoint(x,y){var v=visible(x,y);if(polygon)ring.push([x,y]);if(first){x__=x,y__=y,v__=v;first=false;if(v){activeStream.lineStart();activeStream.point(x,y);}}else{if(v&&v_)activeStream.point(x,y);else{var a=[x_=Math.max(clipMin,Math.min(clipMax,x_)),y_=Math.max(clipMin,Math.min(clipMax,y_))],b=[x=Math.max(clipMin,Math.min(clipMax,x)),y=Math.max(clipMin,Math.min(clipMax,y))];if(clipLine(a,b,x0,y0,x1,y1)){if(!v_){activeStream.lineStart();activeStream.point(a[0],a[1]);}activeStream.point(b[0],b[1]);if(!v)activeStream.lineEnd();clean=false;}else if(v){activeStream.lineStart();activeStream.point(x,y);clean=false;}}}x_=x,y_=y,v_=v;}return clipStream;};}function extent$1(){var x0=0,y0=0,x1=960,y1=500,cache,cacheStream,clip;return clip={stream:function stream(_stream){return cache&&cacheStream===_stream?cache:cache=clipRectangle(x0,y0,x1,y1)(cacheStream=_stream);},extent:function extent(_){return arguments.length?(x0=+_[0][0],y0=+_[0][1],x1=+_[1][0],y1=+_[1][1],cache=cacheStream=null,clip):[[x0,y0],[x1,y1]];}};}var lengthSum=adder(),lambda0$2,sinPhi0$1,cosPhi0$1;var lengthStream={sphere:noop$2,point:noop$2,lineStart:lengthLineStart,lineEnd:noop$2,polygonStart:noop$2,polygonEnd:noop$2};function lengthLineStart(){lengthStream.point=lengthPointFirst;lengthStream.lineEnd=lengthLineEnd;}function lengthLineEnd(){lengthStream.point=lengthStream.lineEnd=noop$2;}function lengthPointFirst(lambda,phi){lambda*=radians,phi*=radians;lambda0$2=lambda,sinPhi0$1=sin$1(phi),cosPhi0$1=cos$1(phi);lengthStream.point=lengthPoint;}function lengthPoint(lambda,phi){lambda*=radians,phi*=radians;var sinPhi=sin$1(phi),cosPhi=cos$1(phi),delta=abs(lambda-lambda0$2),cosDelta=cos$1(delta),sinDelta=sin$1(delta),x=cosPhi*sinDelta,y=cosPhi0$1*sinPhi-sinPhi0$1*cosPhi*cosDelta,z=sinPhi0$1*sinPhi+cosPhi0$1*cosPhi*cosDelta;lengthSum.add(atan2(sqrt(x*x+y*y),z));lambda0$2=lambda,sinPhi0$1=sinPhi,cosPhi0$1=cosPhi;}function length$1(object){lengthSum.reset();geoStream(object,lengthStream);return+lengthSum;}var coordinates=[null,null],object$1={type:\"LineString\",coordinates:coordinates};function distance(a,b){coordinates[0]=a;coordinates[1]=b;return length$1(object$1);}var containsObjectType={Feature:function Feature(object,point){return containsGeometry(object.geometry,point);},FeatureCollection:function FeatureCollection(object,point){var features=object.features,i=-1,n=features.length;while(++i<n){if(containsGeometry(features[i].geometry,point))return true;}return false;}};var containsGeometryType={Sphere:function Sphere(){return true;},Point:function Point(object,point){return containsPoint(object.coordinates,point);},MultiPoint:function MultiPoint(object,point){var coordinates=object.coordinates,i=-1,n=coordinates.length;while(++i<n){if(containsPoint(coordinates[i],point))return true;}return false;},LineString:function LineString(object,point){return containsLine(object.coordinates,point);},MultiLineString:function MultiLineString(object,point){var coordinates=object.coordinates,i=-1,n=coordinates.length;while(++i<n){if(containsLine(coordinates[i],point))return true;}return false;},Polygon:function Polygon(object,point){return containsPolygon(object.coordinates,point);},MultiPolygon:function MultiPolygon(object,point){var coordinates=object.coordinates,i=-1,n=coordinates.length;while(++i<n){if(containsPolygon(coordinates[i],point))return true;}return false;},GeometryCollection:function GeometryCollection(object,point){var geometries=object.geometries,i=-1,n=geometries.length;while(++i<n){if(containsGeometry(geometries[i],point))return true;}return false;}};function containsGeometry(geometry,point){return geometry&&containsGeometryType.hasOwnProperty(geometry.type)?containsGeometryType[geometry.type](geometry,point):false;}function containsPoint(coordinates,point){return distance(coordinates,point)===0;}function containsLine(coordinates,point){var ab=distance(coordinates[0],coordinates[1]),ao=distance(coordinates[0],point),ob=distance(point,coordinates[1]);return ao+ob<=ab+epsilon$2;}function containsPolygon(coordinates,point){return!!polygonContains(coordinates.map(ringRadians),pointRadians(point));}function ringRadians(ring){return ring=ring.map(pointRadians),ring.pop(),ring;}function pointRadians(point){return[point[0]*radians,point[1]*radians];}function contains$1(object,point){return(object&&containsObjectType.hasOwnProperty(object.type)?containsObjectType[object.type]:containsGeometry)(object,point);}function graticuleX(y0,y1,dy){var y=sequence(y0,y1-epsilon$2,dy).concat(y1);return function(x){return y.map(function(y){return[x,y];});};}function graticuleY(x0,x1,dx){var x=sequence(x0,x1-epsilon$2,dx).concat(x1);return function(y){return x.map(function(x){return[x,y];});};}function graticule(){var x1,x0,X1,X0,y1,y0,Y1,Y0,dx=10,dy=dx,DX=90,DY=360,x,y,X,Y,precision=2.5;function graticule(){return{type:\"MultiLineString\",coordinates:lines()};}function lines(){return sequence(ceil(X0/DX)*DX,X1,DX).map(X).concat(sequence(ceil(Y0/DY)*DY,Y1,DY).map(Y)).concat(sequence(ceil(x0/dx)*dx,x1,dx).filter(function(x){return abs(x%DX)>epsilon$2;}).map(x)).concat(sequence(ceil(y0/dy)*dy,y1,dy).filter(function(y){return abs(y%DY)>epsilon$2;}).map(y));}graticule.lines=function(){return lines().map(function(coordinates){return{type:\"LineString\",coordinates:coordinates};});};graticule.outline=function(){return{type:\"Polygon\",coordinates:[X(X0).concat(Y(Y1).slice(1),X(X1).reverse().slice(1),Y(Y0).reverse().slice(1))]};};graticule.extent=function(_){if(!arguments.length)return graticule.extentMinor();return graticule.extentMajor(_).extentMinor(_);};graticule.extentMajor=function(_){if(!arguments.length)return[[X0,Y0],[X1,Y1]];X0=+_[0][0],X1=+_[1][0];Y0=+_[0][1],Y1=+_[1][1];if(X0>X1)_=X0,X0=X1,X1=_;if(Y0>Y1)_=Y0,Y0=Y1,Y1=_;return graticule.precision(precision);};graticule.extentMinor=function(_){if(!arguments.length)return[[x0,y0],[x1,y1]];x0=+_[0][0],x1=+_[1][0];y0=+_[0][1],y1=+_[1][1];if(x0>x1)_=x0,x0=x1,x1=_;if(y0>y1)_=y0,y0=y1,y1=_;return graticule.precision(precision);};graticule.step=function(_){if(!arguments.length)return graticule.stepMinor();return graticule.stepMajor(_).stepMinor(_);};graticule.stepMajor=function(_){if(!arguments.length)return[DX,DY];DX=+_[0],DY=+_[1];return graticule;};graticule.stepMinor=function(_){if(!arguments.length)return[dx,dy];dx=+_[0],dy=+_[1];return graticule;};graticule.precision=function(_){if(!arguments.length)return precision;precision=+_;x=graticuleX(y0,y1,90);y=graticuleY(x0,x1,precision);X=graticuleX(Y0,Y1,90);Y=graticuleY(X0,X1,precision);return graticule;};return graticule.extentMajor([[-180,-90+epsilon$2],[180,90-epsilon$2]]).extentMinor([[-180,-80-epsilon$2],[180,80+epsilon$2]]);}function graticule10(){return graticule()();}function interpolate$1(a,b){var x0=a[0]*radians,y0=a[1]*radians,x1=b[0]*radians,y1=b[1]*radians,cy0=cos$1(y0),sy0=sin$1(y0),cy1=cos$1(y1),sy1=sin$1(y1),kx0=cy0*cos$1(x0),ky0=cy0*sin$1(x0),kx1=cy1*cos$1(x1),ky1=cy1*sin$1(x1),d=2*asin(sqrt(haversin(y1-y0)+cy0*cy1*haversin(x1-x0))),k=sin$1(d);var interpolate=d?function(t){var B=sin$1(t*=d)/k,A=sin$1(d-t)/k,x=A*kx0+B*kx1,y=A*ky0+B*ky1,z=A*sy0+B*sy1;return[atan2(y,x)*degrees$1,atan2(z,sqrt(x*x+y*y))*degrees$1];}:function(){return[x0*degrees$1,y0*degrees$1];};interpolate.distance=d;return interpolate;}function identity$4(x){return x;}var areaSum$1=adder(),areaRingSum$1=adder(),x00,y00,x0$1,y0$1;var areaStream$1={point:noop$2,lineStart:noop$2,lineEnd:noop$2,polygonStart:function polygonStart(){areaStream$1.lineStart=areaRingStart$1;areaStream$1.lineEnd=areaRingEnd$1;},polygonEnd:function polygonEnd(){areaStream$1.lineStart=areaStream$1.lineEnd=areaStream$1.point=noop$2;areaSum$1.add(abs(areaRingSum$1));areaRingSum$1.reset();},result:function result(){var area=areaSum$1/2;areaSum$1.reset();return area;}};function areaRingStart$1(){areaStream$1.point=areaPointFirst$1;}function areaPointFirst$1(x,y){areaStream$1.point=areaPoint$1;x00=x0$1=x,y00=y0$1=y;}function areaPoint$1(x,y){areaRingSum$1.add(y0$1*x-x0$1*y);x0$1=x,y0$1=y;}function areaRingEnd$1(){areaPoint$1(x00,y00);}var x0$2=Infinity,y0$2=x0$2,x1=-x0$2,y1=x1;var boundsStream$1={point:boundsPoint$1,lineStart:noop$2,lineEnd:noop$2,polygonStart:noop$2,polygonEnd:noop$2,result:function result(){var bounds=[[x0$2,y0$2],[x1,y1]];x1=y1=-(y0$2=x0$2=Infinity);return bounds;}};function boundsPoint$1(x,y){if(x<x0$2)x0$2=x;if(x>x1)x1=x;if(y<y0$2)y0$2=y;if(y>y1)y1=y;}// TODO Enforce positive area for exterior, negative area for interior?\nvar X0$1=0,Y0$1=0,Z0$1=0,X1$1=0,Y1$1=0,Z1$1=0,X2$1=0,Y2$1=0,Z2$1=0,x00$1,y00$1,x0$3,y0$3;var centroidStream$1={point:centroidPoint$1,lineStart:centroidLineStart$1,lineEnd:centroidLineEnd$1,polygonStart:function polygonStart(){centroidStream$1.lineStart=centroidRingStart$1;centroidStream$1.lineEnd=centroidRingEnd$1;},polygonEnd:function polygonEnd(){centroidStream$1.point=centroidPoint$1;centroidStream$1.lineStart=centroidLineStart$1;centroidStream$1.lineEnd=centroidLineEnd$1;},result:function result(){var centroid=Z2$1?[X2$1/Z2$1,Y2$1/Z2$1]:Z1$1?[X1$1/Z1$1,Y1$1/Z1$1]:Z0$1?[X0$1/Z0$1,Y0$1/Z0$1]:[NaN,NaN];X0$1=Y0$1=Z0$1=X1$1=Y1$1=Z1$1=X2$1=Y2$1=Z2$1=0;return centroid;}};function centroidPoint$1(x,y){X0$1+=x;Y0$1+=y;++Z0$1;}function centroidLineStart$1(){centroidStream$1.point=centroidPointFirstLine;}function centroidPointFirstLine(x,y){centroidStream$1.point=centroidPointLine;centroidPoint$1(x0$3=x,y0$3=y);}function centroidPointLine(x,y){var dx=x-x0$3,dy=y-y0$3,z=sqrt(dx*dx+dy*dy);X1$1+=z*(x0$3+x)/2;Y1$1+=z*(y0$3+y)/2;Z1$1+=z;centroidPoint$1(x0$3=x,y0$3=y);}function centroidLineEnd$1(){centroidStream$1.point=centroidPoint$1;}function centroidRingStart$1(){centroidStream$1.point=centroidPointFirstRing;}function centroidRingEnd$1(){centroidPointRing(x00$1,y00$1);}function centroidPointFirstRing(x,y){centroidStream$1.point=centroidPointRing;centroidPoint$1(x00$1=x0$3=x,y00$1=y0$3=y);}function centroidPointRing(x,y){var dx=x-x0$3,dy=y-y0$3,z=sqrt(dx*dx+dy*dy);X1$1+=z*(x0$3+x)/2;Y1$1+=z*(y0$3+y)/2;Z1$1+=z;z=y0$3*x-x0$3*y;X2$1+=z*(x0$3+x);Y2$1+=z*(y0$3+y);Z2$1+=z*3;centroidPoint$1(x0$3=x,y0$3=y);}function PathContext(context){this._context=context;}PathContext.prototype={_radius:4.5,pointRadius:function pointRadius(_){return this._radius=_,this;},polygonStart:function polygonStart(){this._line=0;},polygonEnd:function polygonEnd(){this._line=NaN;},lineStart:function lineStart(){this._point=0;},lineEnd:function lineEnd(){if(this._line===0)this._context.closePath();this._point=NaN;},point:function point(x,y){switch(this._point){case 0:{this._context.moveTo(x,y);this._point=1;break;}case 1:{this._context.lineTo(x,y);break;}default:{this._context.moveTo(x+this._radius,y);this._context.arc(x,y,this._radius,0,tau$3);break;}}},result:noop$2};var lengthSum$1=adder(),lengthRing,x00$2,y00$2,x0$4,y0$4;var lengthStream$1={point:noop$2,lineStart:function lineStart(){lengthStream$1.point=lengthPointFirst$1;},lineEnd:function lineEnd(){if(lengthRing)lengthPoint$1(x00$2,y00$2);lengthStream$1.point=noop$2;},polygonStart:function polygonStart(){lengthRing=true;},polygonEnd:function polygonEnd(){lengthRing=null;},result:function result(){var length=+lengthSum$1;lengthSum$1.reset();return length;}};function lengthPointFirst$1(x,y){lengthStream$1.point=lengthPoint$1;x00$2=x0$4=x,y00$2=y0$4=y;}function lengthPoint$1(x,y){x0$4-=x,y0$4-=y;lengthSum$1.add(sqrt(x0$4*x0$4+y0$4*y0$4));x0$4=x,y0$4=y;}function PathString(){this._string=[];}PathString.prototype={_radius:4.5,_circle:circle$1(4.5),pointRadius:function pointRadius(_){if((_=+_)!==this._radius)this._radius=_,this._circle=null;return this;},polygonStart:function polygonStart(){this._line=0;},polygonEnd:function polygonEnd(){this._line=NaN;},lineStart:function lineStart(){this._point=0;},lineEnd:function lineEnd(){if(this._line===0)this._string.push(\"Z\");this._point=NaN;},point:function point(x,y){switch(this._point){case 0:{this._string.push(\"M\",x,\",\",y);this._point=1;break;}case 1:{this._string.push(\"L\",x,\",\",y);break;}default:{if(this._circle==null)this._circle=circle$1(this._radius);this._string.push(\"M\",x,\",\",y,this._circle);break;}}},result:function result(){if(this._string.length){var result=this._string.join(\"\");this._string=[];return result;}else{return null;}}};function circle$1(radius){return\"m0,\"+radius+\"a\"+radius+\",\"+radius+\" 0 1,1 0,\"+-2*radius+\"a\"+radius+\",\"+radius+\" 0 1,1 0,\"+2*radius+\"z\";}function index$1(projection,context){var pointRadius=4.5,projectionStream,contextStream;function path(object){if(object){if(typeof pointRadius===\"function\")contextStream.pointRadius(+pointRadius.apply(this,arguments));geoStream(object,projectionStream(contextStream));}return contextStream.result();}path.area=function(object){geoStream(object,projectionStream(areaStream$1));return areaStream$1.result();};path.measure=function(object){geoStream(object,projectionStream(lengthStream$1));return lengthStream$1.result();};path.bounds=function(object){geoStream(object,projectionStream(boundsStream$1));return boundsStream$1.result();};path.centroid=function(object){geoStream(object,projectionStream(centroidStream$1));return centroidStream$1.result();};path.projection=function(_){return arguments.length?(projectionStream=_==null?(projection=null,identity$4):(projection=_).stream,path):projection;};path.context=function(_){if(!arguments.length)return context;contextStream=_==null?(context=null,new PathString()):new PathContext(context=_);if(typeof pointRadius!==\"function\")contextStream.pointRadius(pointRadius);return path;};path.pointRadius=function(_){if(!arguments.length)return pointRadius;pointRadius=typeof _===\"function\"?_:(contextStream.pointRadius(+_),+_);return path;};return path.projection(projection).context(context);}function transform(methods){return{stream:transformer(methods)};}function transformer(methods){return function(stream){var s=new TransformStream();for(var key in methods){s[key]=methods[key];}s.stream=stream;return s;};}function TransformStream(){}TransformStream.prototype={constructor:TransformStream,point:function point(x,y){this.stream.point(x,y);},sphere:function sphere(){this.stream.sphere();},lineStart:function lineStart(){this.stream.lineStart();},lineEnd:function lineEnd(){this.stream.lineEnd();},polygonStart:function polygonStart(){this.stream.polygonStart();},polygonEnd:function polygonEnd(){this.stream.polygonEnd();}};function fit(projection,fitBounds,object){var clip=projection.clipExtent&&projection.clipExtent();projection.scale(150).translate([0,0]);if(clip!=null)projection.clipExtent(null);geoStream(object,projection.stream(boundsStream$1));fitBounds(boundsStream$1.result());if(clip!=null)projection.clipExtent(clip);return projection;}function _fitExtent(projection,extent,object){return fit(projection,function(b){var w=extent[1][0]-extent[0][0],h=extent[1][1]-extent[0][1],k=Math.min(w/(b[1][0]-b[0][0]),h/(b[1][1]-b[0][1])),x=+extent[0][0]+(w-k*(b[1][0]+b[0][0]))/2,y=+extent[0][1]+(h-k*(b[1][1]+b[0][1]))/2;projection.scale(150*k).translate([x,y]);},object);}function _fitSize(projection,size,object){return _fitExtent(projection,[[0,0],size],object);}function _fitWidth(projection,width,object){return fit(projection,function(b){var w=+width,k=w/(b[1][0]-b[0][0]),x=(w-k*(b[1][0]+b[0][0]))/2,y=-k*b[0][1];projection.scale(150*k).translate([x,y]);},object);}function _fitHeight(projection,height,object){return fit(projection,function(b){var h=+height,k=h/(b[1][1]-b[0][1]),x=-k*b[0][0],y=(h-k*(b[1][1]+b[0][1]))/2;projection.scale(150*k).translate([x,y]);},object);}var maxDepth=16,// maximum depth of subdivision\ncosMinDistance=cos$1(30*radians);// cos(minimum angular distance)\nfunction resample(project,delta2){return+delta2?resample$1(project,delta2):resampleNone(project);}function resampleNone(project){return transformer({point:function point(x,y){x=project(x,y);this.stream.point(x[0],x[1]);}});}function resample$1(project,delta2){function resampleLineTo(x0,y0,lambda0,a0,b0,c0,x1,y1,lambda1,a1,b1,c1,depth,stream){var dx=x1-x0,dy=y1-y0,d2=dx*dx+dy*dy;if(d2>4*delta2&&depth--){var a=a0+a1,b=b0+b1,c=c0+c1,m=sqrt(a*a+b*b+c*c),phi2=asin(c/=m),lambda2=abs(abs(c)-1)<epsilon$2||abs(lambda0-lambda1)<epsilon$2?(lambda0+lambda1)/2:atan2(b,a),p=project(lambda2,phi2),x2=p[0],y2=p[1],dx2=x2-x0,dy2=y2-y0,dz=dy*dx2-dx*dy2;if(dz*dz/d2>delta2// perpendicular projected distance\n||abs((dx*dx2+dy*dy2)/d2-0.5)>0.3// midpoint close to an end\n||a0*a1+b0*b1+c0*c1<cosMinDistance){// angular distance\nresampleLineTo(x0,y0,lambda0,a0,b0,c0,x2,y2,lambda2,a/=m,b/=m,c,depth,stream);stream.point(x2,y2);resampleLineTo(x2,y2,lambda2,a,b,c,x1,y1,lambda1,a1,b1,c1,depth,stream);}}}return function(stream){var lambda00,x00,y00,a00,b00,c00,// first point\nlambda0,x0,y0,a0,b0,c0;// previous point\nvar resampleStream={point:point,lineStart:lineStart,lineEnd:lineEnd,polygonStart:function polygonStart(){stream.polygonStart();resampleStream.lineStart=ringStart;},polygonEnd:function polygonEnd(){stream.polygonEnd();resampleStream.lineStart=lineStart;}};function point(x,y){x=project(x,y);stream.point(x[0],x[1]);}function lineStart(){x0=NaN;resampleStream.point=linePoint;stream.lineStart();}function linePoint(lambda,phi){var c=cartesian([lambda,phi]),p=project(lambda,phi);resampleLineTo(x0,y0,lambda0,a0,b0,c0,x0=p[0],y0=p[1],lambda0=lambda,a0=c[0],b0=c[1],c0=c[2],maxDepth,stream);stream.point(x0,y0);}function lineEnd(){resampleStream.point=point;stream.lineEnd();}function ringStart(){lineStart();resampleStream.point=ringPoint;resampleStream.lineEnd=ringEnd;}function ringPoint(lambda,phi){linePoint(lambda00=lambda,phi),x00=x0,y00=y0,a00=a0,b00=b0,c00=c0;resampleStream.point=linePoint;}function ringEnd(){resampleLineTo(x0,y0,lambda0,a0,b0,c0,x00,y00,lambda00,a00,b00,c00,maxDepth,stream);resampleStream.lineEnd=lineEnd;lineEnd();}return resampleStream;};}var transformRadians=transformer({point:function point(x,y){this.stream.point(x*radians,y*radians);}});function transformRotate(rotate){return transformer({point:function point(x,y){var r=rotate(x,y);return this.stream.point(r[0],r[1]);}});}function scaleTranslate(k,dx,dy){function transform$$1(x,y){return[dx+k*x,dy-k*y];}transform$$1.invert=function(x,y){return[(x-dx)/k,(dy-y)/k];};return transform$$1;}function scaleTranslateRotate(k,dx,dy,alpha){var cosAlpha=cos$1(alpha),sinAlpha=sin$1(alpha),a=cosAlpha*k,b=sinAlpha*k,ai=cosAlpha/k,bi=sinAlpha/k,ci=(sinAlpha*dy-cosAlpha*dx)/k,fi=(sinAlpha*dx+cosAlpha*dy)/k;function transform$$1(x,y){return[a*x-b*y+dx,dy-b*x-a*y];}transform$$1.invert=function(x,y){return[ai*x-bi*y+ci,fi-bi*x-ai*y];};return transform$$1;}function projection(project){return projectionMutator(function(){return project;})();}function projectionMutator(projectAt){var project,k=150,// scale\nx=480,y=250,// translate\nlambda=0,phi=0,// center\ndeltaLambda=0,deltaPhi=0,deltaGamma=0,rotate,// pre-rotate\nalpha=0,// post-rotate\ntheta=null,preclip=clipAntimeridian,// pre-clip angle\nx0=null,y0,x1,y1,postclip=identity$4,// post-clip extent\ndelta2=0.5,// precision\nprojectResample,projectTransform,projectRotateTransform,cache,cacheStream;function projection(point){return projectRotateTransform(point[0]*radians,point[1]*radians);}function invert(point){point=projectRotateTransform.invert(point[0],point[1]);return point&&[point[0]*degrees$1,point[1]*degrees$1];}projection.stream=function(stream){return cache&&cacheStream===stream?cache:cache=transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream=stream)))));};projection.preclip=function(_){return arguments.length?(preclip=_,theta=undefined,reset()):preclip;};projection.postclip=function(_){return arguments.length?(postclip=_,x0=y0=x1=y1=null,reset()):postclip;};projection.clipAngle=function(_){return arguments.length?(preclip=+_?clipCircle(theta=_*radians):(theta=null,clipAntimeridian),reset()):theta*degrees$1;};projection.clipExtent=function(_){return arguments.length?(postclip=_==null?(x0=y0=x1=y1=null,identity$4):clipRectangle(x0=+_[0][0],y0=+_[0][1],x1=+_[1][0],y1=+_[1][1]),reset()):x0==null?null:[[x0,y0],[x1,y1]];};projection.scale=function(_){return arguments.length?(k=+_,recenter()):k;};projection.translate=function(_){return arguments.length?(x=+_[0],y=+_[1],recenter()):[x,y];};projection.center=function(_){return arguments.length?(lambda=_[0]%360*radians,phi=_[1]%360*radians,recenter()):[lambda*degrees$1,phi*degrees$1];};projection.rotate=function(_){return arguments.length?(deltaLambda=_[0]%360*radians,deltaPhi=_[1]%360*radians,deltaGamma=_.length>2?_[2]%360*radians:0,recenter()):[deltaLambda*degrees$1,deltaPhi*degrees$1,deltaGamma*degrees$1];};projection.angle=function(_){return arguments.length?(alpha=_%360*radians,recenter()):alpha*degrees$1;};projection.precision=function(_){return arguments.length?(projectResample=resample(projectTransform,delta2=_*_),reset()):sqrt(delta2);};projection.fitExtent=function(extent,object){return _fitExtent(projection,extent,object);};projection.fitSize=function(size,object){return _fitSize(projection,size,object);};projection.fitWidth=function(width,object){return _fitWidth(projection,width,object);};projection.fitHeight=function(height,object){return _fitHeight(projection,height,object);};function recenter(){var center=scaleTranslateRotate(k,0,0,alpha).apply(null,project(lambda,phi)),transform$$1=(alpha?scaleTranslateRotate:scaleTranslate)(k,x-center[0],y-center[1],alpha);rotate=rotateRadians(deltaLambda,deltaPhi,deltaGamma);projectTransform=compose(project,transform$$1);projectRotateTransform=compose(rotate,projectTransform);projectResample=resample(projectTransform,delta2);return reset();}function reset(){cache=cacheStream=null;return projection;}return function(){project=projectAt.apply(this,arguments);projection.invert=project.invert&&invert;return recenter();};}function conicProjection(projectAt){var phi0=0,phi1=pi$3/3,m=projectionMutator(projectAt),p=m(phi0,phi1);p.parallels=function(_){return arguments.length?m(phi0=_[0]*radians,phi1=_[1]*radians):[phi0*degrees$1,phi1*degrees$1];};return p;}function cylindricalEqualAreaRaw(phi0){var cosPhi0=cos$1(phi0);function forward(lambda,phi){return[lambda*cosPhi0,sin$1(phi)/cosPhi0];}forward.invert=function(x,y){return[x/cosPhi0,asin(y*cosPhi0)];};return forward;}function conicEqualAreaRaw(y0,y1){var sy0=sin$1(y0),n=(sy0+sin$1(y1))/2;// Are the parallels symmetrical around the Equator?\nif(abs(n)<epsilon$2)return cylindricalEqualAreaRaw(y0);var c=1+sy0*(2*n-sy0),r0=sqrt(c)/n;function project(x,y){var r=sqrt(c-2*n*sin$1(y))/n;return[r*sin$1(x*=n),r0-r*cos$1(x)];}project.invert=function(x,y){var r0y=r0-y;return[atan2(x,abs(r0y))/n*sign(r0y),asin((c-(x*x+r0y*r0y)*n*n)/(2*n))];};return project;}function conicEqualArea(){return conicProjection(conicEqualAreaRaw).scale(155.424).center([0,33.6442]);}function albers(){return conicEqualArea().parallels([29.5,45.5]).scale(1070).translate([480,250]).rotate([96,0]).center([-0.6,38.7]);}// The projections must have mutually exclusive clip regions on the sphere,\n// as this will avoid emitting interleaving lines and polygons.\nfunction multiplex(streams){var n=streams.length;return{point:function point(x,y){var i=-1;while(++i<n){streams[i].point(x,y);}},sphere:function sphere(){var i=-1;while(++i<n){streams[i].sphere();}},lineStart:function lineStart(){var i=-1;while(++i<n){streams[i].lineStart();}},lineEnd:function lineEnd(){var i=-1;while(++i<n){streams[i].lineEnd();}},polygonStart:function polygonStart(){var i=-1;while(++i<n){streams[i].polygonStart();}},polygonEnd:function polygonEnd(){var i=-1;while(++i<n){streams[i].polygonEnd();}}};}// A composite projection for the United States, configured by default for\n// 960×500. The projection also works quite well at 960×600 if you change the\n// scale to 1285 and adjust the translate accordingly. The set of standard\n// parallels for each region comes from USGS, which is published here:\n// http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers\nfunction albersUsa(){var cache,cacheStream,lower48=albers(),lower48Point,alaska=conicEqualArea().rotate([154,0]).center([-2,58.5]).parallels([55,65]),alaskaPoint,// EPSG:3338\nhawaii=conicEqualArea().rotate([157,0]).center([-3,19.9]).parallels([8,18]),hawaiiPoint,// ESRI:102007\n_point,pointStream={point:function point(x,y){_point=[x,y];}};function albersUsa(coordinates){var x=coordinates[0],y=coordinates[1];return _point=null,(lower48Point.point(x,y),_point)||(alaskaPoint.point(x,y),_point)||(hawaiiPoint.point(x,y),_point);}albersUsa.invert=function(coordinates){var k=lower48.scale(),t=lower48.translate(),x=(coordinates[0]-t[0])/k,y=(coordinates[1]-t[1])/k;return(y>=0.120&&y<0.234&&x>=-0.425&&x<-0.214?alaska:y>=0.166&&y<0.234&&x>=-0.214&&x<-0.115?hawaii:lower48).invert(coordinates);};albersUsa.stream=function(stream){return cache&&cacheStream===stream?cache:cache=multiplex([lower48.stream(cacheStream=stream),alaska.stream(stream),hawaii.stream(stream)]);};albersUsa.precision=function(_){if(!arguments.length)return lower48.precision();lower48.precision(_),alaska.precision(_),hawaii.precision(_);return reset();};albersUsa.scale=function(_){if(!arguments.length)return lower48.scale();lower48.scale(_),alaska.scale(_*0.35),hawaii.scale(_);return albersUsa.translate(lower48.translate());};albersUsa.translate=function(_){if(!arguments.length)return lower48.translate();var k=lower48.scale(),x=+_[0],y=+_[1];lower48Point=lower48.translate(_).clipExtent([[x-0.455*k,y-0.238*k],[x+0.455*k,y+0.238*k]]).stream(pointStream);alaskaPoint=alaska.translate([x-0.307*k,y+0.201*k]).clipExtent([[x-0.425*k+epsilon$2,y+0.120*k+epsilon$2],[x-0.214*k-epsilon$2,y+0.234*k-epsilon$2]]).stream(pointStream);hawaiiPoint=hawaii.translate([x-0.205*k,y+0.212*k]).clipExtent([[x-0.214*k+epsilon$2,y+0.166*k+epsilon$2],[x-0.115*k-epsilon$2,y+0.234*k-epsilon$2]]).stream(pointStream);return reset();};albersUsa.fitExtent=function(extent,object){return _fitExtent(albersUsa,extent,object);};albersUsa.fitSize=function(size,object){return _fitSize(albersUsa,size,object);};albersUsa.fitWidth=function(width,object){return _fitWidth(albersUsa,width,object);};albersUsa.fitHeight=function(height,object){return _fitHeight(albersUsa,height,object);};function reset(){cache=cacheStream=null;return albersUsa;}return albersUsa.scale(1070);}function azimuthalRaw(scale){return function(x,y){var cx=cos$1(x),cy=cos$1(y),k=scale(cx*cy);return[k*cy*sin$1(x),k*sin$1(y)];};}function azimuthalInvert(angle){return function(x,y){var z=sqrt(x*x+y*y),c=angle(z),sc=sin$1(c),cc=cos$1(c);return[atan2(x*sc,z*cc),asin(z&&y*sc/z)];};}var azimuthalEqualAreaRaw=azimuthalRaw(function(cxcy){return sqrt(2/(1+cxcy));});azimuthalEqualAreaRaw.invert=azimuthalInvert(function(z){return 2*asin(z/2);});function azimuthalEqualArea(){return projection(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180-1e-3);}var azimuthalEquidistantRaw=azimuthalRaw(function(c){return(c=acos(c))&&c/sin$1(c);});azimuthalEquidistantRaw.invert=azimuthalInvert(function(z){return z;});function azimuthalEquidistant(){return projection(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180-1e-3);}function mercatorRaw(lambda,phi){return[lambda,log(tan((halfPi$2+phi)/2))];}mercatorRaw.invert=function(x,y){return[x,2*atan(exp(y))-halfPi$2];};function mercator(){return mercatorProjection(mercatorRaw).scale(961/tau$3);}function mercatorProjection(project){var m=projection(project),center=m.center,scale=m.scale,translate=m.translate,clipExtent=m.clipExtent,x0=null,y0,x1,y1;// clip extent\nm.scale=function(_){return arguments.length?(scale(_),reclip()):scale();};m.translate=function(_){return arguments.length?(translate(_),reclip()):translate();};m.center=function(_){return arguments.length?(center(_),reclip()):center();};m.clipExtent=function(_){return arguments.length?(_==null?x0=y0=x1=y1=null:(x0=+_[0][0],y0=+_[0][1],x1=+_[1][0],y1=+_[1][1]),reclip()):x0==null?null:[[x0,y0],[x1,y1]];};function reclip(){var k=pi$3*scale(),t=m(rotation(m.rotate()).invert([0,0]));return clipExtent(x0==null?[[t[0]-k,t[1]-k],[t[0]+k,t[1]+k]]:project===mercatorRaw?[[Math.max(t[0]-k,x0),y0],[Math.min(t[0]+k,x1),y1]]:[[x0,Math.max(t[1]-k,y0)],[x1,Math.min(t[1]+k,y1)]]);}return reclip();}function tany(y){return tan((halfPi$2+y)/2);}function conicConformalRaw(y0,y1){var cy0=cos$1(y0),n=y0===y1?sin$1(y0):log(cy0/cos$1(y1))/log(tany(y1)/tany(y0)),f=cy0*pow(tany(y0),n)/n;if(!n)return mercatorRaw;function project(x,y){if(f>0){if(y<-halfPi$2+epsilon$2)y=-halfPi$2+epsilon$2;}else{if(y>halfPi$2-epsilon$2)y=halfPi$2-epsilon$2;}var r=f/pow(tany(y),n);return[r*sin$1(n*x),f-r*cos$1(n*x)];}project.invert=function(x,y){var fy=f-y,r=sign(n)*sqrt(x*x+fy*fy);return[atan2(x,abs(fy))/n*sign(fy),2*atan(pow(f/r,1/n))-halfPi$2];};return project;}function conicConformal(){return conicProjection(conicConformalRaw).scale(109.5).parallels([30,30]);}function equirectangularRaw(lambda,phi){return[lambda,phi];}equirectangularRaw.invert=equirectangularRaw;function equirectangular(){return projection(equirectangularRaw).scale(152.63);}function conicEquidistantRaw(y0,y1){var cy0=cos$1(y0),n=y0===y1?sin$1(y0):(cy0-cos$1(y1))/(y1-y0),g=cy0/n+y0;if(abs(n)<epsilon$2)return equirectangularRaw;function project(x,y){var gy=g-y,nx=n*x;return[gy*sin$1(nx),g-gy*cos$1(nx)];}project.invert=function(x,y){var gy=g-y;return[atan2(x,abs(gy))/n*sign(gy),g-sign(n)*sqrt(x*x+gy*gy)];};return project;}function conicEquidistant(){return conicProjection(conicEquidistantRaw).scale(131.154).center([0,13.9389]);}function gnomonicRaw(x,y){var cy=cos$1(y),k=cos$1(x)*cy;return[cy*sin$1(x)/k,sin$1(y)/k];}gnomonicRaw.invert=azimuthalInvert(atan);function gnomonic(){return projection(gnomonicRaw).scale(144.049).clipAngle(60);}function scaleTranslate$1(kx,ky,tx,ty){return kx===1&&ky===1&&tx===0&&ty===0?identity$4:transformer({point:function point(x,y){this.stream.point(x*kx+tx,y*ky+ty);}});}function identity$5(){var k=1,tx=0,ty=0,sx=1,sy=1,transform$$1=identity$4,// scale, translate and reflect\nx0=null,y0,x1,y1,// clip extent\n_postclip=identity$4,cache,cacheStream,projection;function reset(){cache=cacheStream=null;return projection;}return projection={stream:function stream(_stream2){return cache&&cacheStream===_stream2?cache:cache=transform$$1(_postclip(cacheStream=_stream2));},postclip:function postclip(_){return arguments.length?(_postclip=_,x0=y0=x1=y1=null,reset()):_postclip;},clipExtent:function clipExtent(_){return arguments.length?(_postclip=_==null?(x0=y0=x1=y1=null,identity$4):clipRectangle(x0=+_[0][0],y0=+_[0][1],x1=+_[1][0],y1=+_[1][1]),reset()):x0==null?null:[[x0,y0],[x1,y1]];},scale:function scale(_){return arguments.length?(transform$$1=scaleTranslate$1((k=+_)*sx,k*sy,tx,ty),reset()):k;},translate:function translate(_){return arguments.length?(transform$$1=scaleTranslate$1(k*sx,k*sy,tx=+_[0],ty=+_[1]),reset()):[tx,ty];},reflectX:function reflectX(_){return arguments.length?(transform$$1=scaleTranslate$1(k*(sx=_?-1:1),k*sy,tx,ty),reset()):sx<0;},reflectY:function reflectY(_){return arguments.length?(transform$$1=scaleTranslate$1(k*sx,k*(sy=_?-1:1),tx,ty),reset()):sy<0;},fitExtent:function fitExtent(extent,object){return _fitExtent(projection,extent,object);},fitSize:function fitSize(size,object){return _fitSize(projection,size,object);},fitWidth:function fitWidth(width,object){return _fitWidth(projection,width,object);},fitHeight:function fitHeight(height,object){return _fitHeight(projection,height,object);}};}function naturalEarth1Raw(lambda,phi){var phi2=phi*phi,phi4=phi2*phi2;return[lambda*(0.8707-0.131979*phi2+phi4*(-0.013791+phi4*(0.003971*phi2-0.001529*phi4))),phi*(1.007226+phi2*(0.015085+phi4*(-0.044475+0.028874*phi2-0.005916*phi4)))];}naturalEarth1Raw.invert=function(x,y){var phi=y,i=25,delta;do{var phi2=phi*phi,phi4=phi2*phi2;phi-=delta=(phi*(1.007226+phi2*(0.015085+phi4*(-0.044475+0.028874*phi2-0.005916*phi4)))-y)/(1.007226+phi2*(0.015085*3+phi4*(-0.044475*7+0.028874*9*phi2-0.005916*11*phi4)));}while(abs(delta)>epsilon$2&&--i>0);return[x/(0.8707+(phi2=phi*phi)*(-0.131979+phi2*(-0.013791+phi2*phi2*phi2*(0.003971-0.001529*phi2)))),phi];};function naturalEarth1(){return projection(naturalEarth1Raw).scale(175.295);}function orthographicRaw(x,y){return[cos$1(y)*sin$1(x),sin$1(y)];}orthographicRaw.invert=azimuthalInvert(asin);function orthographic(){return projection(orthographicRaw).scale(249.5).clipAngle(90+epsilon$2);}function stereographicRaw(x,y){var cy=cos$1(y),k=1+cos$1(x)*cy;return[cy*sin$1(x)/k,sin$1(y)/k];}stereographicRaw.invert=azimuthalInvert(function(z){return 2*atan(z);});function stereographic(){return projection(stereographicRaw).scale(250).clipAngle(142);}function transverseMercatorRaw(lambda,phi){return[log(tan((halfPi$2+phi)/2)),-lambda];}transverseMercatorRaw.invert=function(x,y){return[-y,2*atan(exp(x))-halfPi$2];};function transverseMercator(){var m=mercatorProjection(transverseMercatorRaw),center=m.center,rotate=m.rotate;m.center=function(_){return arguments.length?center([-_[1],_[0]]):(_=center(),[_[1],-_[0]]);};m.rotate=function(_){return arguments.length?rotate([_[0],_[1],_.length>2?_[2]+90:90]):(_=rotate(),[_[0],_[1],_[2]-90]);};return rotate([0,0,90]).scale(159.155);}function defaultSeparation(a,b){return a.parent===b.parent?1:2;}function meanX(children){return children.reduce(meanXReduce,0)/children.length;}function meanXReduce(x,c){return x+c.x;}function maxY(children){return 1+children.reduce(maxYReduce,0);}function maxYReduce(y,c){return Math.max(y,c.y);}function leafLeft(node){var children;while(children=node.children){node=children[0];}return node;}function leafRight(node){var children;while(children=node.children){node=children[children.length-1];}return node;}function cluster(){var separation=defaultSeparation,dx=1,dy=1,nodeSize=false;function cluster(root){var previousNode,x=0;// First walk, computing the initial x & y values.\nroot.eachAfter(function(node){var children=node.children;if(children){node.x=meanX(children);node.y=maxY(children);}else{node.x=previousNode?x+=separation(node,previousNode):0;node.y=0;previousNode=node;}});var left=leafLeft(root),right=leafRight(root),x0=left.x-separation(left,right)/2,x1=right.x+separation(right,left)/2;// Second walk, normalizing x & y to the desired size.\nreturn root.eachAfter(nodeSize?function(node){node.x=(node.x-root.x)*dx;node.y=(root.y-node.y)*dy;}:function(node){node.x=(node.x-x0)/(x1-x0)*dx;node.y=(1-(root.y?node.y/root.y:1))*dy;});}cluster.separation=function(x){return arguments.length?(separation=x,cluster):separation;};cluster.size=function(x){return arguments.length?(nodeSize=false,dx=+x[0],dy=+x[1],cluster):nodeSize?null:[dx,dy];};cluster.nodeSize=function(x){return arguments.length?(nodeSize=true,dx=+x[0],dy=+x[1],cluster):nodeSize?[dx,dy]:null;};return cluster;}function count(node){var sum=0,children=node.children,i=children&&children.length;if(!i)sum=1;else while(--i>=0){sum+=children[i].value;}node.value=sum;}function node_count(){return this.eachAfter(count);}function node_each(callback){var node=this,current,next=[node],children,i,n;do{current=next.reverse(),next=[];while(node=current.pop()){callback(node),children=node.children;if(children)for(i=0,n=children.length;i<n;++i){next.push(children[i]);}}}while(next.length);return this;}function node_eachBefore(callback){var node=this,nodes=[node],children,i;while(node=nodes.pop()){callback(node),children=node.children;if(children)for(i=children.length-1;i>=0;--i){nodes.push(children[i]);}}return this;}function node_eachAfter(callback){var node=this,nodes=[node],next=[],children,i,n;while(node=nodes.pop()){next.push(node),children=node.children;if(children)for(i=0,n=children.length;i<n;++i){nodes.push(children[i]);}}while(node=next.pop()){callback(node);}return this;}function node_sum(value){return this.eachAfter(function(node){var sum=+value(node.data)||0,children=node.children,i=children&&children.length;while(--i>=0){sum+=children[i].value;}node.value=sum;});}function node_sort(compare){return this.eachBefore(function(node){if(node.children){node.children.sort(compare);}});}function node_path(end){var start=this,ancestor=leastCommonAncestor(start,end),nodes=[start];while(start!==ancestor){start=start.parent;nodes.push(start);}var k=nodes.length;while(end!==ancestor){nodes.splice(k,0,end);end=end.parent;}return nodes;}function leastCommonAncestor(a,b){if(a===b)return a;var aNodes=a.ancestors(),bNodes=b.ancestors(),c=null;a=aNodes.pop();b=bNodes.pop();while(a===b){c=a;a=aNodes.pop();b=bNodes.pop();}return c;}function node_ancestors(){var node=this,nodes=[node];while(node=node.parent){nodes.push(node);}return nodes;}function node_descendants(){var nodes=[];this.each(function(node){nodes.push(node);});return nodes;}function node_leaves(){var leaves=[];this.eachBefore(function(node){if(!node.children){leaves.push(node);}});return leaves;}function node_links(){var root=this,links=[];root.each(function(node){if(node!==root){// Don’t include the root’s parent, if any.\nlinks.push({source:node.parent,target:node});}});return links;}function hierarchy(data,children){var root=new Node(data),valued=+data.value&&(root.value=data.value),node,nodes=[root],child,childs,i,n;if(children==null)children=defaultChildren;while(node=nodes.pop()){if(valued)node.value=+node.data.value;if((childs=children(node.data))&&(n=childs.length)){node.children=new Array(n);for(i=n-1;i>=0;--i){nodes.push(child=node.children[i]=new Node(childs[i]));child.parent=node;child.depth=node.depth+1;}}}return root.eachBefore(computeHeight);}function node_copy(){return hierarchy(this).eachBefore(copyData);}function defaultChildren(d){return d.children;}function copyData(node){node.data=node.data.data;}function computeHeight(node){var height=0;do{node.height=height;}while((node=node.parent)&&node.height<++height);}function Node(data){this.data=data;this.depth=this.height=0;this.parent=null;}Node.prototype=hierarchy.prototype={constructor:Node,count:node_count,each:node_each,eachAfter:node_eachAfter,eachBefore:node_eachBefore,sum:node_sum,sort:node_sort,path:node_path,ancestors:node_ancestors,descendants:node_descendants,leaves:node_leaves,links:node_links,copy:node_copy};var slice$4=Array.prototype.slice;function shuffle$1(array){var m=array.length,t,i;while(m){i=Math.random()*m--|0;t=array[m];array[m]=array[i];array[i]=t;}return array;}function enclose(circles){var i=0,n=(circles=shuffle$1(slice$4.call(circles))).length,B=[],p,e;while(i<n){p=circles[i];if(e&&enclosesWeak(e,p))++i;else e=encloseBasis(B=extendBasis(B,p)),i=0;}return e;}function extendBasis(B,p){var i,j;if(enclosesWeakAll(p,B))return[p];// If we get here then B must have at least one element.\nfor(i=0;i<B.length;++i){if(enclosesNot(p,B[i])&&enclosesWeakAll(encloseBasis2(B[i],p),B)){return[B[i],p];}}// If we get here then B must have at least two elements.\nfor(i=0;i<B.length-1;++i){for(j=i+1;j<B.length;++j){if(enclosesNot(encloseBasis2(B[i],B[j]),p)&&enclosesNot(encloseBasis2(B[i],p),B[j])&&enclosesNot(encloseBasis2(B[j],p),B[i])&&enclosesWeakAll(encloseBasis3(B[i],B[j],p),B)){return[B[i],B[j],p];}}}// If we get here then something is very wrong.\nthrow new Error();}function enclosesNot(a,b){var dr=a.r-b.r,dx=b.x-a.x,dy=b.y-a.y;return dr<0||dr*dr<dx*dx+dy*dy;}function enclosesWeak(a,b){var dr=a.r-b.r+1e-6,dx=b.x-a.x,dy=b.y-a.y;return dr>0&&dr*dr>dx*dx+dy*dy;}function enclosesWeakAll(a,B){for(var i=0;i<B.length;++i){if(!enclosesWeak(a,B[i])){return false;}}return true;}function encloseBasis(B){switch(B.length){case 1:return encloseBasis1(B[0]);case 2:return encloseBasis2(B[0],B[1]);case 3:return encloseBasis3(B[0],B[1],B[2]);}}function encloseBasis1(a){return{x:a.x,y:a.y,r:a.r};}function encloseBasis2(a,b){var x1=a.x,y1=a.y,r1=a.r,x2=b.x,y2=b.y,r2=b.r,x21=x2-x1,y21=y2-y1,r21=r2-r1,l=Math.sqrt(x21*x21+y21*y21);return{x:(x1+x2+x21/l*r21)/2,y:(y1+y2+y21/l*r21)/2,r:(l+r1+r2)/2};}function encloseBasis3(a,b,c){var x1=a.x,y1=a.y,r1=a.r,x2=b.x,y2=b.y,r2=b.r,x3=c.x,y3=c.y,r3=c.r,a2=x1-x2,a3=x1-x3,b2=y1-y2,b3=y1-y3,c2=r2-r1,c3=r3-r1,d1=x1*x1+y1*y1-r1*r1,d2=d1-x2*x2-y2*y2+r2*r2,d3=d1-x3*x3-y3*y3+r3*r3,ab=a3*b2-a2*b3,xa=(b2*d3-b3*d2)/(ab*2)-x1,xb=(b3*c2-b2*c3)/ab,ya=(a3*d2-a2*d3)/(ab*2)-y1,yb=(a2*c3-a3*c2)/ab,A=xb*xb+yb*yb-1,B=2*(r1+xa*xb+ya*yb),C=xa*xa+ya*ya-r1*r1,r=-(A?(B+Math.sqrt(B*B-4*A*C))/(2*A):C/B);return{x:x1+xa+xb*r,y:y1+ya+yb*r,r:r};}function place(b,a,c){var dx=b.x-a.x,x,a2,dy=b.y-a.y,y,b2,d2=dx*dx+dy*dy;if(d2){a2=a.r+c.r,a2*=a2;b2=b.r+c.r,b2*=b2;if(a2>b2){x=(d2+b2-a2)/(2*d2);y=Math.sqrt(Math.max(0,b2/d2-x*x));c.x=b.x-x*dx-y*dy;c.y=b.y-x*dy+y*dx;}else{x=(d2+a2-b2)/(2*d2);y=Math.sqrt(Math.max(0,a2/d2-x*x));c.x=a.x+x*dx-y*dy;c.y=a.y+x*dy+y*dx;}}else{c.x=a.x+c.r;c.y=a.y;}}function intersects(a,b){var dr=a.r+b.r-1e-6,dx=b.x-a.x,dy=b.y-a.y;return dr>0&&dr*dr>dx*dx+dy*dy;}function score(node){var a=node._,b=node.next._,ab=a.r+b.r,dx=(a.x*b.r+b.x*a.r)/ab,dy=(a.y*b.r+b.y*a.r)/ab;return dx*dx+dy*dy;}function Node$1(circle){this._=circle;this.next=null;this.previous=null;}function packEnclose(circles){if(!(n=circles.length))return 0;var a,b,c,n,aa,ca,i,j,k,sj,sk;// Place the first circle.\na=circles[0],a.x=0,a.y=0;if(!(n>1))return a.r;// Place the second circle.\nb=circles[1],a.x=-b.r,b.x=a.r,b.y=0;if(!(n>2))return a.r+b.r;// Place the third circle.\nplace(b,a,c=circles[2]);// Initialize the front-chain using the first three circles a, b and c.\na=new Node$1(a),b=new Node$1(b),c=new Node$1(c);a.next=c.previous=b;b.next=a.previous=c;c.next=b.previous=a;// Attempt to place each remaining circle…\npack:for(i=3;i<n;++i){place(a._,b._,c=circles[i]),c=new Node$1(c);// Find the closest intersecting circle on the front-chain, if any.\n// “Closeness” is determined by linear distance along the front-chain.\n// “Ahead” or “behind” is likewise determined by linear distance.\nj=b.next,k=a.previous,sj=b._.r,sk=a._.r;do{if(sj<=sk){if(intersects(j._,c._)){b=j,a.next=b,b.previous=a,--i;continue pack;}sj+=j._.r,j=j.next;}else{if(intersects(k._,c._)){a=k,a.next=b,b.previous=a,--i;continue pack;}sk+=k._.r,k=k.previous;}}while(j!==k.next);// Success! Insert the new circle c between a and b.\nc.previous=a,c.next=b,a.next=b.previous=b=c;// Compute the new closest circle pair to the centroid.\naa=score(a);while((c=c.next)!==b){if((ca=score(c))<aa){a=c,aa=ca;}}b=a.next;}// Compute the enclosing circle of the front chain.\na=[b._],c=b;while((c=c.next)!==b){a.push(c._);}c=enclose(a);// Translate the circles to put the enclosing circle around the origin.\nfor(i=0;i<n;++i){a=circles[i],a.x-=c.x,a.y-=c.y;}return c.r;}function siblings(circles){packEnclose(circles);return circles;}function optional(f){return f==null?null:required(f);}function required(f){if(typeof f!==\"function\")throw new Error();return f;}function constantZero(){return 0;}function constant$9(x){return function(){return x;};}function defaultRadius$1(d){return Math.sqrt(d.value);}function index$2(){var radius=null,dx=1,dy=1,padding=constantZero;function pack(root){root.x=dx/2,root.y=dy/2;if(radius){root.eachBefore(radiusLeaf(radius)).eachAfter(packChildren(padding,0.5)).eachBefore(translateChild(1));}else{root.eachBefore(radiusLeaf(defaultRadius$1)).eachAfter(packChildren(constantZero,1)).eachAfter(packChildren(padding,root.r/Math.min(dx,dy))).eachBefore(translateChild(Math.min(dx,dy)/(2*root.r)));}return root;}pack.radius=function(x){return arguments.length?(radius=optional(x),pack):radius;};pack.size=function(x){return arguments.length?(dx=+x[0],dy=+x[1],pack):[dx,dy];};pack.padding=function(x){return arguments.length?(padding=typeof x===\"function\"?x:constant$9(+x),pack):padding;};return pack;}function radiusLeaf(radius){return function(node){if(!node.children){node.r=Math.max(0,+radius(node)||0);}};}function packChildren(padding,k){return function(node){if(children=node.children){var children,i,n=children.length,r=padding(node)*k||0,e;if(r)for(i=0;i<n;++i){children[i].r+=r;}e=packEnclose(children);if(r)for(i=0;i<n;++i){children[i].r-=r;}node.r=e+r;}};}function translateChild(k){return function(node){var parent=node.parent;node.r*=k;if(parent){node.x=parent.x+k*node.x;node.y=parent.y+k*node.y;}};}function roundNode(node){node.x0=Math.round(node.x0);node.y0=Math.round(node.y0);node.x1=Math.round(node.x1);node.y1=Math.round(node.y1);}function treemapDice(parent,x0,y0,x1,y1){var nodes=parent.children,node,i=-1,n=nodes.length,k=parent.value&&(x1-x0)/parent.value;while(++i<n){node=nodes[i],node.y0=y0,node.y1=y1;node.x0=x0,node.x1=x0+=node.value*k;}}function partition(){var dx=1,dy=1,padding=0,round=false;function partition(root){var n=root.height+1;root.x0=root.y0=padding;root.x1=dx;root.y1=dy/n;root.eachBefore(positionNode(dy,n));if(round)root.eachBefore(roundNode);return root;}function positionNode(dy,n){return function(node){if(node.children){treemapDice(node,node.x0,dy*(node.depth+1)/n,node.x1,dy*(node.depth+2)/n);}var x0=node.x0,y0=node.y0,x1=node.x1-padding,y1=node.y1-padding;if(x1<x0)x0=x1=(x0+x1)/2;if(y1<y0)y0=y1=(y0+y1)/2;node.x0=x0;node.y0=y0;node.x1=x1;node.y1=y1;};}partition.round=function(x){return arguments.length?(round=!!x,partition):round;};partition.size=function(x){return arguments.length?(dx=+x[0],dy=+x[1],partition):[dx,dy];};partition.padding=function(x){return arguments.length?(padding=+x,partition):padding;};return partition;}var keyPrefix$1=\"$\",// Protect against keys like “__proto__”.\npreroot={depth:-1},ambiguous={};function defaultId(d){return d.id;}function defaultParentId(d){return d.parentId;}function stratify(){var id=defaultId,parentId=defaultParentId;function stratify(data){var d,i,n=data.length,root,parent,node,nodes=new Array(n),nodeId,nodeKey,nodeByKey={};for(i=0;i<n;++i){d=data[i],node=nodes[i]=new Node(d);if((nodeId=id(d,i,data))!=null&&(nodeId+=\"\")){nodeKey=keyPrefix$1+(node.id=nodeId);nodeByKey[nodeKey]=nodeKey in nodeByKey?ambiguous:node;}}for(i=0;i<n;++i){node=nodes[i],nodeId=parentId(data[i],i,data);if(nodeId==null||!(nodeId+=\"\")){if(root)throw new Error(\"multiple roots\");root=node;}else{parent=nodeByKey[keyPrefix$1+nodeId];if(!parent)throw new Error(\"missing: \"+nodeId);if(parent===ambiguous)throw new Error(\"ambiguous: \"+nodeId);if(parent.children)parent.children.push(node);else parent.children=[node];node.parent=parent;}}if(!root)throw new Error(\"no root\");root.parent=preroot;root.eachBefore(function(node){node.depth=node.parent.depth+1;--n;}).eachBefore(computeHeight);root.parent=null;if(n>0)throw new Error(\"cycle\");return root;}stratify.id=function(x){return arguments.length?(id=required(x),stratify):id;};stratify.parentId=function(x){return arguments.length?(parentId=required(x),stratify):parentId;};return stratify;}function defaultSeparation$1(a,b){return a.parent===b.parent?1:2;}// function radialSeparation(a, b) {\n//   return (a.parent === b.parent ? 1 : 2) / a.depth;\n// }\n// This function is used to traverse the left contour of a subtree (or\n// subforest). It returns the successor of v on this contour. This successor is\n// either given by the leftmost child of v or by the thread of v. The function\n// returns null if and only if v is on the highest level of its subtree.\nfunction nextLeft(v){var children=v.children;return children?children[0]:v.t;}// This function works analogously to nextLeft.\nfunction nextRight(v){var children=v.children;return children?children[children.length-1]:v.t;}// Shifts the current subtree rooted at w+. This is done by increasing\n// prelim(w+) and mod(w+) by shift.\nfunction moveSubtree(wm,wp,shift){var change=shift/(wp.i-wm.i);wp.c-=change;wp.s+=shift;wm.c+=change;wp.z+=shift;wp.m+=shift;}// All other shifts, applied to the smaller subtrees between w- and w+, are\n// performed by this function. To prepare the shifts, we have to adjust\n// change(w+), shift(w+), and change(w-).\nfunction executeShifts(v){var shift=0,change=0,children=v.children,i=children.length,w;while(--i>=0){w=children[i];w.z+=shift;w.m+=shift;shift+=w.s+(change+=w.c);}}// If vi-’s ancestor is a sibling of v, returns vi-’s ancestor. Otherwise,\n// returns the specified (default) ancestor.\nfunction nextAncestor(vim,v,ancestor){return vim.a.parent===v.parent?vim.a:ancestor;}function TreeNode(node,i){this._=node;this.parent=null;this.children=null;this.A=null;// default ancestor\nthis.a=this;// ancestor\nthis.z=0;// prelim\nthis.m=0;// mod\nthis.c=0;// change\nthis.s=0;// shift\nthis.t=null;// thread\nthis.i=i;// number\n}TreeNode.prototype=Object.create(Node.prototype);function treeRoot(root){var tree=new TreeNode(root,0),node,nodes=[tree],child,children,i,n;while(node=nodes.pop()){if(children=node._.children){node.children=new Array(n=children.length);for(i=n-1;i>=0;--i){nodes.push(child=node.children[i]=new TreeNode(children[i],i));child.parent=node;}}}(tree.parent=new TreeNode(null,0)).children=[tree];return tree;}// Node-link tree diagram using the Reingold-Tilford \"tidy\" algorithm\nfunction tree(){var separation=defaultSeparation$1,dx=1,dy=1,nodeSize=null;function tree(root){var t=treeRoot(root);// Compute the layout using Buchheim et al.’s algorithm.\nt.eachAfter(firstWalk),t.parent.m=-t.z;t.eachBefore(secondWalk);// If a fixed node size is specified, scale x and y.\nif(nodeSize)root.eachBefore(sizeNode);// If a fixed tree size is specified, scale x and y based on the extent.\n// Compute the left-most, right-most, and depth-most nodes for extents.\nelse{var left=root,right=root,bottom=root;root.eachBefore(function(node){if(node.x<left.x)left=node;if(node.x>right.x)right=node;if(node.depth>bottom.depth)bottom=node;});var s=left===right?1:separation(left,right)/2,tx=s-left.x,kx=dx/(right.x+s+tx),ky=dy/(bottom.depth||1);root.eachBefore(function(node){node.x=(node.x+tx)*kx;node.y=node.depth*ky;});}return root;}// Computes a preliminary x-coordinate for v. Before that, FIRST WALK is\n// applied recursively to the children of v, as well as the function\n// APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the\n// node v is placed to the midpoint of its outermost children.\nfunction firstWalk(v){var children=v.children,siblings=v.parent.children,w=v.i?siblings[v.i-1]:null;if(children){executeShifts(v);var midpoint=(children[0].z+children[children.length-1].z)/2;if(w){v.z=w.z+separation(v._,w._);v.m=v.z-midpoint;}else{v.z=midpoint;}}else if(w){v.z=w.z+separation(v._,w._);}v.parent.A=apportion(v,w,v.parent.A||siblings[0]);}// Computes all real x-coordinates by summing up the modifiers recursively.\nfunction secondWalk(v){v._.x=v.z+v.parent.m;v.m+=v.parent.m;}// The core of the algorithm. Here, a new subtree is combined with the\n// previous subtrees. Threads are used to traverse the inside and outside\n// contours of the left and right subtree up to the highest common level. The\n// vertices used for the traversals are vi+, vi-, vo-, and vo+, where the\n// superscript o means outside and i means inside, the subscript - means left\n// subtree and + means right subtree. For summing up the modifiers along the\n// contour, we use respective variables si+, si-, so-, and so+. Whenever two\n// nodes of the inside contours conflict, we compute the left one of the\n// greatest uncommon ancestors using the function ANCESTOR and call MOVE\n// SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.\n// Finally, we add a new thread (if necessary).\nfunction apportion(v,w,ancestor){if(w){var vip=v,vop=v,vim=w,vom=vip.parent.children[0],sip=vip.m,sop=vop.m,sim=vim.m,som=vom.m,shift;while(vim=nextRight(vim),vip=nextLeft(vip),vim&&vip){vom=nextLeft(vom);vop=nextRight(vop);vop.a=v;shift=vim.z+sim-vip.z-sip+separation(vim._,vip._);if(shift>0){moveSubtree(nextAncestor(vim,v,ancestor),v,shift);sip+=shift;sop+=shift;}sim+=vim.m;sip+=vip.m;som+=vom.m;sop+=vop.m;}if(vim&&!nextRight(vop)){vop.t=vim;vop.m+=sim-sop;}if(vip&&!nextLeft(vom)){vom.t=vip;vom.m+=sip-som;ancestor=v;}}return ancestor;}function sizeNode(node){node.x*=dx;node.y=node.depth*dy;}tree.separation=function(x){return arguments.length?(separation=x,tree):separation;};tree.size=function(x){return arguments.length?(nodeSize=false,dx=+x[0],dy=+x[1],tree):nodeSize?null:[dx,dy];};tree.nodeSize=function(x){return arguments.length?(nodeSize=true,dx=+x[0],dy=+x[1],tree):nodeSize?[dx,dy]:null;};return tree;}function treemapSlice(parent,x0,y0,x1,y1){var nodes=parent.children,node,i=-1,n=nodes.length,k=parent.value&&(y1-y0)/parent.value;while(++i<n){node=nodes[i],node.x0=x0,node.x1=x1;node.y0=y0,node.y1=y0+=node.value*k;}}var phi=(1+Math.sqrt(5))/2;function squarifyRatio(ratio,parent,x0,y0,x1,y1){var rows=[],nodes=parent.children,row,nodeValue,i0=0,i1=0,n=nodes.length,dx,dy,value=parent.value,sumValue,minValue,maxValue,newRatio,minRatio,alpha,beta;while(i0<n){dx=x1-x0,dy=y1-y0;// Find the next non-empty node.\ndo{sumValue=nodes[i1++].value;}while(!sumValue&&i1<n);minValue=maxValue=sumValue;alpha=Math.max(dy/dx,dx/dy)/(value*ratio);beta=sumValue*sumValue*alpha;minRatio=Math.max(maxValue/beta,beta/minValue);// Keep adding nodes while the aspect ratio maintains or improves.\nfor(;i1<n;++i1){sumValue+=nodeValue=nodes[i1].value;if(nodeValue<minValue)minValue=nodeValue;if(nodeValue>maxValue)maxValue=nodeValue;beta=sumValue*sumValue*alpha;newRatio=Math.max(maxValue/beta,beta/minValue);if(newRatio>minRatio){sumValue-=nodeValue;break;}minRatio=newRatio;}// Position and record the row orientation.\nrows.push(row={value:sumValue,dice:dx<dy,children:nodes.slice(i0,i1)});if(row.dice)treemapDice(row,x0,y0,x1,value?y0+=dy*sumValue/value:y1);else treemapSlice(row,x0,y0,value?x0+=dx*sumValue/value:x1,y1);value-=sumValue,i0=i1;}return rows;}var squarify=function custom(ratio){function squarify(parent,x0,y0,x1,y1){squarifyRatio(ratio,parent,x0,y0,x1,y1);}squarify.ratio=function(x){return custom((x=+x)>1?x:1);};return squarify;}(phi);function index$3(){var tile=squarify,round=false,dx=1,dy=1,paddingStack=[0],paddingInner=constantZero,paddingTop=constantZero,paddingRight=constantZero,paddingBottom=constantZero,paddingLeft=constantZero;function treemap(root){root.x0=root.y0=0;root.x1=dx;root.y1=dy;root.eachBefore(positionNode);paddingStack=[0];if(round)root.eachBefore(roundNode);return root;}function positionNode(node){var p=paddingStack[node.depth],x0=node.x0+p,y0=node.y0+p,x1=node.x1-p,y1=node.y1-p;if(x1<x0)x0=x1=(x0+x1)/2;if(y1<y0)y0=y1=(y0+y1)/2;node.x0=x0;node.y0=y0;node.x1=x1;node.y1=y1;if(node.children){p=paddingStack[node.depth+1]=paddingInner(node)/2;x0+=paddingLeft(node)-p;y0+=paddingTop(node)-p;x1-=paddingRight(node)-p;y1-=paddingBottom(node)-p;if(x1<x0)x0=x1=(x0+x1)/2;if(y1<y0)y0=y1=(y0+y1)/2;tile(node,x0,y0,x1,y1);}}treemap.round=function(x){return arguments.length?(round=!!x,treemap):round;};treemap.size=function(x){return arguments.length?(dx=+x[0],dy=+x[1],treemap):[dx,dy];};treemap.tile=function(x){return arguments.length?(tile=required(x),treemap):tile;};treemap.padding=function(x){return arguments.length?treemap.paddingInner(x).paddingOuter(x):treemap.paddingInner();};treemap.paddingInner=function(x){return arguments.length?(paddingInner=typeof x===\"function\"?x:constant$9(+x),treemap):paddingInner;};treemap.paddingOuter=function(x){return arguments.length?treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x):treemap.paddingTop();};treemap.paddingTop=function(x){return arguments.length?(paddingTop=typeof x===\"function\"?x:constant$9(+x),treemap):paddingTop;};treemap.paddingRight=function(x){return arguments.length?(paddingRight=typeof x===\"function\"?x:constant$9(+x),treemap):paddingRight;};treemap.paddingBottom=function(x){return arguments.length?(paddingBottom=typeof x===\"function\"?x:constant$9(+x),treemap):paddingBottom;};treemap.paddingLeft=function(x){return arguments.length?(paddingLeft=typeof x===\"function\"?x:constant$9(+x),treemap):paddingLeft;};return treemap;}function binary(parent,x0,y0,x1,y1){var nodes=parent.children,i,n=nodes.length,sum,sums=new Array(n+1);for(sums[0]=sum=i=0;i<n;++i){sums[i+1]=sum+=nodes[i].value;}partition(0,n,parent.value,x0,y0,x1,y1);function partition(i,j,value,x0,y0,x1,y1){if(i>=j-1){var node=nodes[i];node.x0=x0,node.y0=y0;node.x1=x1,node.y1=y1;return;}var valueOffset=sums[i],valueTarget=value/2+valueOffset,k=i+1,hi=j-1;while(k<hi){var mid=k+hi>>>1;if(sums[mid]<valueTarget)k=mid+1;else hi=mid;}if(valueTarget-sums[k-1]<sums[k]-valueTarget&&i+1<k)--k;var valueLeft=sums[k]-valueOffset,valueRight=value-valueLeft;if(x1-x0>y1-y0){var xk=(x0*valueRight+x1*valueLeft)/value;partition(i,k,valueLeft,x0,y0,xk,y1);partition(k,j,valueRight,xk,y0,x1,y1);}else{var yk=(y0*valueRight+y1*valueLeft)/value;partition(i,k,valueLeft,x0,y0,x1,yk);partition(k,j,valueRight,x0,yk,x1,y1);}}}function sliceDice(parent,x0,y0,x1,y1){(parent.depth&1?treemapSlice:treemapDice)(parent,x0,y0,x1,y1);}var resquarify=function custom(ratio){function resquarify(parent,x0,y0,x1,y1){if((rows=parent._squarify)&&rows.ratio===ratio){var rows,row,nodes,i,j=-1,n,m=rows.length,value=parent.value;while(++j<m){row=rows[j],nodes=row.children;for(i=row.value=0,n=nodes.length;i<n;++i){row.value+=nodes[i].value;}if(row.dice)treemapDice(row,x0,y0,x1,y0+=(y1-y0)*row.value/value);else treemapSlice(row,x0,y0,x0+=(x1-x0)*row.value/value,y1);value-=row.value;}}else{parent._squarify=rows=squarifyRatio(ratio,parent,x0,y0,x1,y1);rows.ratio=ratio;}}resquarify.ratio=function(x){return custom((x=+x)>1?x:1);};return resquarify;}(phi);function area$2(polygon){var i=-1,n=polygon.length,a,b=polygon[n-1],area=0;while(++i<n){a=b;b=polygon[i];area+=a[1]*b[0]-a[0]*b[1];}return area/2;}function centroid$1(polygon){var i=-1,n=polygon.length,x=0,y=0,a,b=polygon[n-1],c,k=0;while(++i<n){a=b;b=polygon[i];k+=c=a[0]*b[1]-b[0]*a[1];x+=(a[0]+b[0])*c;y+=(a[1]+b[1])*c;}return k*=3,[x/k,y/k];}// Returns the 2D cross product of AB and AC vectors, i.e., the z-component of\n// the 3D cross product in a quadrant I Cartesian coordinate system (+x is\n// right, +y is up). Returns a positive value if ABC is counter-clockwise,\n// negative if clockwise, and zero if the points are collinear.\nfunction cross$1(a,b,c){return(b[0]-a[0])*(c[1]-a[1])-(b[1]-a[1])*(c[0]-a[0]);}function lexicographicOrder(a,b){return a[0]-b[0]||a[1]-b[1];}// Computes the upper convex hull per the monotone chain algorithm.\n// Assumes points.length >= 3, is sorted by x, unique in y.\n// Returns an array of indices into points in left-to-right order.\nfunction computeUpperHullIndexes(points){var n=points.length,indexes=[0,1],size=2;for(var i=2;i<n;++i){while(size>1&&cross$1(points[indexes[size-2]],points[indexes[size-1]],points[i])<=0){--size;}indexes[size++]=i;}return indexes.slice(0,size);// remove popped points\n}function hull(points){if((n=points.length)<3)return null;var i,n,sortedPoints=new Array(n),flippedPoints=new Array(n);for(i=0;i<n;++i){sortedPoints[i]=[+points[i][0],+points[i][1],i];}sortedPoints.sort(lexicographicOrder);for(i=0;i<n;++i){flippedPoints[i]=[sortedPoints[i][0],-sortedPoints[i][1]];}var upperIndexes=computeUpperHullIndexes(sortedPoints),lowerIndexes=computeUpperHullIndexes(flippedPoints);// Construct the hull polygon, removing possible duplicate endpoints.\nvar skipLeft=lowerIndexes[0]===upperIndexes[0],skipRight=lowerIndexes[lowerIndexes.length-1]===upperIndexes[upperIndexes.length-1],hull=[];// Add upper hull in right-to-l order.\n// Then add lower hull in left-to-right order.\nfor(i=upperIndexes.length-1;i>=0;--i){hull.push(points[sortedPoints[upperIndexes[i]][2]]);}for(i=+skipLeft;i<lowerIndexes.length-skipRight;++i){hull.push(points[sortedPoints[lowerIndexes[i]][2]]);}return hull;}function contains$2(polygon,point){var n=polygon.length,p=polygon[n-1],x=point[0],y=point[1],x0=p[0],y0=p[1],x1,y1,inside=false;for(var i=0;i<n;++i){p=polygon[i],x1=p[0],y1=p[1];if(y1>y!==y0>y&&x<(x0-x1)*(y-y1)/(y0-y1)+x1)inside=!inside;x0=x1,y0=y1;}return inside;}function length$2(polygon){var i=-1,n=polygon.length,b=polygon[n-1],xa,ya,xb=b[0],yb=b[1],perimeter=0;while(++i<n){xa=xb;ya=yb;b=polygon[i];xb=b[0];yb=b[1];xa-=xb;ya-=yb;perimeter+=Math.sqrt(xa*xa+ya*ya);}return perimeter;}function defaultSource$1(){return Math.random();}var uniform=function sourceRandomUniform(source){function randomUniform(min,max){min=min==null?0:+min;max=max==null?1:+max;if(arguments.length===1)max=min,min=0;else max-=min;return function(){return source()*max+min;};}randomUniform.source=sourceRandomUniform;return randomUniform;}(defaultSource$1);var normal=function sourceRandomNormal(source){function randomNormal(mu,sigma){var x,r;mu=mu==null?0:+mu;sigma=sigma==null?1:+sigma;return function(){var y;// If available, use the second previously-generated uniform random.\nif(x!=null)y=x,x=null;// Otherwise, generate a new x and y.\nelse do{x=source()*2-1;y=source()*2-1;r=x*x+y*y;}while(!r||r>1);return mu+sigma*y*Math.sqrt(-2*Math.log(r)/r);};}randomNormal.source=sourceRandomNormal;return randomNormal;}(defaultSource$1);var logNormal=function sourceRandomLogNormal(source){function randomLogNormal(){var randomNormal=normal.source(source).apply(this,arguments);return function(){return Math.exp(randomNormal());};}randomLogNormal.source=sourceRandomLogNormal;return randomLogNormal;}(defaultSource$1);var irwinHall=function sourceRandomIrwinHall(source){function randomIrwinHall(n){return function(){for(var sum=0,i=0;i<n;++i){sum+=source();}return sum;};}randomIrwinHall.source=sourceRandomIrwinHall;return randomIrwinHall;}(defaultSource$1);var bates=function sourceRandomBates(source){function randomBates(n){var randomIrwinHall=irwinHall.source(source)(n);return function(){return randomIrwinHall()/n;};}randomBates.source=sourceRandomBates;return randomBates;}(defaultSource$1);var exponential$1=function sourceRandomExponential(source){function randomExponential(lambda){return function(){return-Math.log(1-source())/lambda;};}randomExponential.source=sourceRandomExponential;return randomExponential;}(defaultSource$1);var array$3=Array.prototype;var map$2=array$3.map;var slice$5=array$3.slice;var implicit={name:\"implicit\"};function ordinal(range){var index=map$1(),domain=[],unknown=implicit;range=range==null?[]:slice$5.call(range);function scale(d){var key=d+\"\",i=index.get(key);if(!i){if(unknown!==implicit)return unknown;index.set(key,i=domain.push(d));}return range[(i-1)%range.length];}scale.domain=function(_){if(!arguments.length)return domain.slice();domain=[],index=map$1();var i=-1,n=_.length,d,key;while(++i<n){if(!index.has(key=(d=_[i])+\"\"))index.set(key,domain.push(d));}return scale;};scale.range=function(_){return arguments.length?(range=slice$5.call(_),scale):range.slice();};scale.unknown=function(_){return arguments.length?(unknown=_,scale):unknown;};scale.copy=function(){return ordinal().domain(domain).range(range).unknown(unknown);};return scale;}function band(){var scale=ordinal().unknown(undefined),domain=scale.domain,ordinalRange=scale.range,range$$1=[0,1],step,bandwidth,round=false,paddingInner=0,paddingOuter=0,align=0.5;delete scale.unknown;function rescale(){var n=domain().length,reverse=range$$1[1]<range$$1[0],start=range$$1[reverse-0],stop=range$$1[1-reverse];step=(stop-start)/Math.max(1,n-paddingInner+paddingOuter*2);if(round)step=Math.floor(step);start+=(stop-start-step*(n-paddingInner))*align;bandwidth=step*(1-paddingInner);if(round)start=Math.round(start),bandwidth=Math.round(bandwidth);var values=sequence(n).map(function(i){return start+step*i;});return ordinalRange(reverse?values.reverse():values);}scale.domain=function(_){return arguments.length?(domain(_),rescale()):domain();};scale.range=function(_){return arguments.length?(range$$1=[+_[0],+_[1]],rescale()):range$$1.slice();};scale.rangeRound=function(_){return range$$1=[+_[0],+_[1]],round=true,rescale();};scale.bandwidth=function(){return bandwidth;};scale.step=function(){return step;};scale.round=function(_){return arguments.length?(round=!!_,rescale()):round;};scale.padding=function(_){return arguments.length?(paddingInner=paddingOuter=Math.max(0,Math.min(1,_)),rescale()):paddingInner;};scale.paddingInner=function(_){return arguments.length?(paddingInner=Math.max(0,Math.min(1,_)),rescale()):paddingInner;};scale.paddingOuter=function(_){return arguments.length?(paddingOuter=Math.max(0,Math.min(1,_)),rescale()):paddingOuter;};scale.align=function(_){return arguments.length?(align=Math.max(0,Math.min(1,_)),rescale()):align;};scale.copy=function(){return band().domain(domain()).range(range$$1).round(round).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);};return rescale();}function pointish(scale){var copy=scale.copy;scale.padding=scale.paddingOuter;delete scale.paddingInner;delete scale.paddingOuter;scale.copy=function(){return pointish(copy());};return scale;}function point$1(){return pointish(band().paddingInner(1));}function constant$10(x){return function(){return x;};}function number$2(x){return+x;}var unit=[0,1];function deinterpolateLinear(a,b){return(b-=a=+a)?function(x){return(x-a)/b;}:constant$10(b);}function deinterpolateClamp(deinterpolate){return function(a,b){var d=deinterpolate(a=+a,b=+b);return function(x){return x<=a?0:x>=b?1:d(x);};};}function reinterpolateClamp(reinterpolate$$1){return function(a,b){var r=reinterpolate$$1(a=+a,b=+b);return function(t){return t<=0?a:t>=1?b:r(t);};};}function bimap(domain,range,deinterpolate,reinterpolate$$1){var d0=domain[0],d1=domain[1],r0=range[0],r1=range[1];if(d1<d0)d0=deinterpolate(d1,d0),r0=reinterpolate$$1(r1,r0);else d0=deinterpolate(d0,d1),r0=reinterpolate$$1(r0,r1);return function(x){return r0(d0(x));};}function polymap(domain,range,deinterpolate,reinterpolate$$1){var j=Math.min(domain.length,range.length)-1,d=new Array(j),r=new Array(j),i=-1;// Reverse descending domains.\nif(domain[j]<domain[0]){domain=domain.slice().reverse();range=range.slice().reverse();}while(++i<j){d[i]=deinterpolate(domain[i],domain[i+1]);r[i]=reinterpolate$$1(range[i],range[i+1]);}return function(x){var i=bisectRight(domain,x,1,j)-1;return r[i](d[i](x));};}function copy(source,target){return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp());}// deinterpolate(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].\n// reinterpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding domain value x in [a,b].\nfunction continuous(deinterpolate,reinterpolate$$1){var domain=unit,range=unit,interpolate$$1=interpolateValue,clamp=false,piecewise$$1,output,input;function rescale(){piecewise$$1=Math.min(domain.length,range.length)>2?polymap:bimap;output=input=null;return scale;}function scale(x){return(output||(output=piecewise$$1(domain,range,clamp?deinterpolateClamp(deinterpolate):deinterpolate,interpolate$$1)))(+x);}scale.invert=function(y){return(input||(input=piecewise$$1(range,domain,deinterpolateLinear,clamp?reinterpolateClamp(reinterpolate$$1):reinterpolate$$1)))(+y);};scale.domain=function(_){return arguments.length?(domain=map$2.call(_,number$2),rescale()):domain.slice();};scale.range=function(_){return arguments.length?(range=slice$5.call(_),rescale()):range.slice();};scale.rangeRound=function(_){return range=slice$5.call(_),interpolate$$1=interpolateRound,rescale();};scale.clamp=function(_){return arguments.length?(clamp=!!_,rescale()):clamp;};scale.interpolate=function(_){return arguments.length?(interpolate$$1=_,rescale()):interpolate$$1;};return rescale();}function tickFormat(domain,count,specifier){var start=domain[0],stop=domain[domain.length-1],step=tickStep(start,stop,count==null?10:count),precision;specifier=formatSpecifier(specifier==null?\",f\":specifier);switch(specifier.type){case\"s\":{var value=Math.max(Math.abs(start),Math.abs(stop));if(specifier.precision==null&&!isNaN(precision=precisionPrefix(step,value)))specifier.precision=precision;return d3.formatPrefix(specifier,value);}case\"\":case\"e\":case\"g\":case\"p\":case\"r\":{if(specifier.precision==null&&!isNaN(precision=precisionRound(step,Math.max(Math.abs(start),Math.abs(stop)))))specifier.precision=precision-(specifier.type===\"e\");break;}case\"f\":case\"%\":{if(specifier.precision==null&&!isNaN(precision=precisionFixed(step)))specifier.precision=precision-(specifier.type===\"%\")*2;break;}}return d3.format(specifier);}function linearish(scale){var domain=scale.domain;scale.ticks=function(count){var d=domain();return ticks(d[0],d[d.length-1],count==null?10:count);};scale.tickFormat=function(count,specifier){return tickFormat(domain(),count,specifier);};scale.nice=function(count){if(count==null)count=10;var d=domain(),i0=0,i1=d.length-1,start=d[i0],stop=d[i1],step;if(stop<start){step=start,start=stop,stop=step;step=i0,i0=i1,i1=step;}step=tickIncrement(start,stop,count);if(step>0){start=Math.floor(start/step)*step;stop=Math.ceil(stop/step)*step;step=tickIncrement(start,stop,count);}else if(step<0){start=Math.ceil(start*step)/step;stop=Math.floor(stop*step)/step;step=tickIncrement(start,stop,count);}if(step>0){d[i0]=Math.floor(start/step)*step;d[i1]=Math.ceil(stop/step)*step;domain(d);}else if(step<0){d[i0]=Math.ceil(start*step)/step;d[i1]=Math.floor(stop*step)/step;domain(d);}return scale;};return scale;}function linear$2(){var scale=continuous(deinterpolateLinear,reinterpolate);scale.copy=function(){return copy(scale,linear$2());};return linearish(scale);}function identity$6(){var domain=[0,1];function scale(x){return+x;}scale.invert=scale;scale.domain=scale.range=function(_){return arguments.length?(domain=map$2.call(_,number$2),scale):domain.slice();};scale.copy=function(){return identity$6().domain(domain);};return linearish(scale);}function nice(domain,interval){domain=domain.slice();var i0=0,i1=domain.length-1,x0=domain[i0],x1=domain[i1],t;if(x1<x0){t=i0,i0=i1,i1=t;t=x0,x0=x1,x1=t;}domain[i0]=interval.floor(x0);domain[i1]=interval.ceil(x1);return domain;}function deinterpolate(a,b){return(b=Math.log(b/a))?function(x){return Math.log(x/a)/b;}:constant$10(b);}function reinterpolate$1(a,b){return a<0?function(t){return-Math.pow(-b,t)*Math.pow(-a,1-t);}:function(t){return Math.pow(b,t)*Math.pow(a,1-t);};}function pow10(x){return isFinite(x)?+(\"1e\"+x):x<0?0:x;}function powp(base){return base===10?pow10:base===Math.E?Math.exp:function(x){return Math.pow(base,x);};}function logp(base){return base===Math.E?Math.log:base===10&&Math.log10||base===2&&Math.log2||(base=Math.log(base),function(x){return Math.log(x)/base;});}function reflect(f){return function(x){return-f(-x);};}function log$1(){var scale=continuous(deinterpolate,reinterpolate$1).domain([1,10]),domain=scale.domain,base=10,logs=logp(10),pows=powp(10);function rescale(){logs=logp(base),pows=powp(base);if(domain()[0]<0)logs=reflect(logs),pows=reflect(pows);return scale;}scale.base=function(_){return arguments.length?(base=+_,rescale()):base;};scale.domain=function(_){return arguments.length?(domain(_),rescale()):domain();};scale.ticks=function(count){var d=domain(),u=d[0],v=d[d.length-1],r;if(r=v<u)i=u,u=v,v=i;var i=logs(u),j=logs(v),p,k,t,n=count==null?10:+count,z=[];if(!(base%1)&&j-i<n){i=Math.round(i)-1,j=Math.round(j)+1;if(u>0)for(;i<j;++i){for(k=1,p=pows(i);k<base;++k){t=p*k;if(t<u)continue;if(t>v)break;z.push(t);}}else for(;i<j;++i){for(k=base-1,p=pows(i);k>=1;--k){t=p*k;if(t<u)continue;if(t>v)break;z.push(t);}}}else{z=ticks(i,j,Math.min(j-i,n)).map(pows);}return r?z.reverse():z;};scale.tickFormat=function(count,specifier){if(specifier==null)specifier=base===10?\".0e\":\",\";if(typeof specifier!==\"function\")specifier=d3.format(specifier);if(count===Infinity)return specifier;if(count==null)count=10;var k=Math.max(1,base*count/scale.ticks().length);// TODO fast estimate?\nreturn function(d){var i=d/pows(Math.round(logs(d)));if(i*base<base-0.5)i*=base;return i<=k?specifier(d):\"\";};};scale.nice=function(){return domain(nice(domain(),{floor:function floor(x){return pows(Math.floor(logs(x)));},ceil:function ceil(x){return pows(Math.ceil(logs(x)));}}));};scale.copy=function(){return copy(scale,log$1().base(base));};return scale;}function raise$1(x,exponent){return x<0?-Math.pow(-x,exponent):Math.pow(x,exponent);}function pow$1(){var exponent=1,scale=continuous(deinterpolate,reinterpolate),domain=scale.domain;function deinterpolate(a,b){return(b=raise$1(b,exponent)-(a=raise$1(a,exponent)))?function(x){return(raise$1(x,exponent)-a)/b;}:constant$10(b);}function reinterpolate(a,b){b=raise$1(b,exponent)-(a=raise$1(a,exponent));return function(t){return raise$1(a+b*t,1/exponent);};}scale.exponent=function(_){return arguments.length?(exponent=+_,domain(domain())):exponent;};scale.copy=function(){return copy(scale,pow$1().exponent(exponent));};return linearish(scale);}function sqrt$1(){return pow$1().exponent(0.5);}function quantile$$1(){var domain=[],range=[],thresholds=[];function rescale(){var i=0,n=Math.max(1,range.length);thresholds=new Array(n-1);while(++i<n){thresholds[i-1]=threshold(domain,i/n);}return scale;}function scale(x){if(!isNaN(x=+x))return range[bisectRight(thresholds,x)];}scale.invertExtent=function(y){var i=range.indexOf(y);return i<0?[NaN,NaN]:[i>0?thresholds[i-1]:domain[0],i<thresholds.length?thresholds[i]:domain[domain.length-1]];};scale.domain=function(_){if(!arguments.length)return domain.slice();domain=[];for(var i=0,n=_.length,d;i<n;++i){if(d=_[i],d!=null&&!isNaN(d=+d))domain.push(d);}domain.sort(ascending);return rescale();};scale.range=function(_){return arguments.length?(range=slice$5.call(_),rescale()):range.slice();};scale.quantiles=function(){return thresholds.slice();};scale.copy=function(){return quantile$$1().domain(domain).range(range);};return scale;}function quantize$1(){var x0=0,x1=1,n=1,domain=[0.5],range=[0,1];function scale(x){if(x<=x)return range[bisectRight(domain,x,0,n)];}function rescale(){var i=-1;domain=new Array(n);while(++i<n){domain[i]=((i+1)*x1-(i-n)*x0)/(n+1);}return scale;}scale.domain=function(_){return arguments.length?(x0=+_[0],x1=+_[1],rescale()):[x0,x1];};scale.range=function(_){return arguments.length?(n=(range=slice$5.call(_)).length-1,rescale()):range.slice();};scale.invertExtent=function(y){var i=range.indexOf(y);return i<0?[NaN,NaN]:i<1?[x0,domain[0]]:i>=n?[domain[n-1],x1]:[domain[i-1],domain[i]];};scale.copy=function(){return quantize$1().domain([x0,x1]).range(range);};return linearish(scale);}function threshold$1(){var domain=[0.5],range=[0,1],n=1;function scale(x){if(x<=x)return range[bisectRight(domain,x,0,n)];}scale.domain=function(_){return arguments.length?(domain=slice$5.call(_),n=Math.min(domain.length,range.length-1),scale):domain.slice();};scale.range=function(_){return arguments.length?(range=slice$5.call(_),n=Math.min(domain.length,range.length-1),scale):range.slice();};scale.invertExtent=function(y){var i=range.indexOf(y);return[domain[i-1],domain[i]];};scale.copy=function(){return threshold$1().domain(domain).range(range);};return scale;}var t0$1=new Date(),t1$1=new Date();function newInterval(floori,offseti,count,field){function interval(date){return floori(date=new Date(+date)),date;}interval.floor=interval;interval.ceil=function(date){return floori(date=new Date(date-1)),offseti(date,1),floori(date),date;};interval.round=function(date){var d0=interval(date),d1=interval.ceil(date);return date-d0<d1-date?d0:d1;};interval.offset=function(date,step){return offseti(date=new Date(+date),step==null?1:Math.floor(step)),date;};interval.range=function(start,stop,step){var range=[],previous;start=interval.ceil(start);step=step==null?1:Math.floor(step);if(!(start<stop)||!(step>0))return range;// also handles Invalid Date\ndo{range.push(previous=new Date(+start)),offseti(start,step),floori(start);}while(previous<start&&start<stop);return range;};interval.filter=function(test){return newInterval(function(date){if(date>=date)while(floori(date),!test(date)){date.setTime(date-1);}},function(date,step){if(date>=date){if(step<0)while(++step<=0){while(offseti(date,-1),!test(date)){}// eslint-disable-line no-empty\n}else while(--step>=0){while(offseti(date,+1),!test(date)){}// eslint-disable-line no-empty\n}}});};if(count){interval.count=function(start,end){t0$1.setTime(+start),t1$1.setTime(+end);floori(t0$1),floori(t1$1);return Math.floor(count(t0$1,t1$1));};interval.every=function(step){step=Math.floor(step);return!isFinite(step)||!(step>0)?null:!(step>1)?interval:interval.filter(field?function(d){return field(d)%step===0;}:function(d){return interval.count(0,d)%step===0;});};}return interval;}var millisecond=newInterval(function(){// noop\n},function(date,step){date.setTime(+date+step);},function(start,end){return end-start;});// An optimized implementation for this simple case.\nmillisecond.every=function(k){k=Math.floor(k);if(!isFinite(k)||!(k>0))return null;if(!(k>1))return millisecond;return newInterval(function(date){date.setTime(Math.floor(date/k)*k);},function(date,step){date.setTime(+date+step*k);},function(start,end){return(end-start)/k;});};var milliseconds=millisecond.range;var durationSecond=1e3;var durationMinute=6e4;var durationHour=36e5;var durationDay=864e5;var durationWeek=6048e5;var second=newInterval(function(date){date.setTime(Math.floor(date/durationSecond)*durationSecond);},function(date,step){date.setTime(+date+step*durationSecond);},function(start,end){return(end-start)/durationSecond;},function(date){return date.getUTCSeconds();});var seconds=second.range;var minute=newInterval(function(date){date.setTime(Math.floor(date/durationMinute)*durationMinute);},function(date,step){date.setTime(+date+step*durationMinute);},function(start,end){return(end-start)/durationMinute;},function(date){return date.getMinutes();});var minutes=minute.range;var hour=newInterval(function(date){var offset=date.getTimezoneOffset()*durationMinute%durationHour;if(offset<0)offset+=durationHour;date.setTime(Math.floor((+date-offset)/durationHour)*durationHour+offset);},function(date,step){date.setTime(+date+step*durationHour);},function(start,end){return(end-start)/durationHour;},function(date){return date.getHours();});var hours=hour.range;var day=newInterval(function(date){date.setHours(0,0,0,0);},function(date,step){date.setDate(date.getDate()+step);},function(start,end){return(end-start-(end.getTimezoneOffset()-start.getTimezoneOffset())*durationMinute)/durationDay;},function(date){return date.getDate()-1;});var days=day.range;function weekday(i){return newInterval(function(date){date.setDate(date.getDate()-(date.getDay()+7-i)%7);date.setHours(0,0,0,0);},function(date,step){date.setDate(date.getDate()+step*7);},function(start,end){return(end-start-(end.getTimezoneOffset()-start.getTimezoneOffset())*durationMinute)/durationWeek;});}var sunday=weekday(0);var monday=weekday(1);var tuesday=weekday(2);var wednesday=weekday(3);var thursday=weekday(4);var friday=weekday(5);var saturday=weekday(6);var sundays=sunday.range;var mondays=monday.range;var tuesdays=tuesday.range;var wednesdays=wednesday.range;var thursdays=thursday.range;var fridays=friday.range;var saturdays=saturday.range;var month=newInterval(function(date){date.setDate(1);date.setHours(0,0,0,0);},function(date,step){date.setMonth(date.getMonth()+step);},function(start,end){return end.getMonth()-start.getMonth()+(end.getFullYear()-start.getFullYear())*12;},function(date){return date.getMonth();});var months=month.range;var year=newInterval(function(date){date.setMonth(0,1);date.setHours(0,0,0,0);},function(date,step){date.setFullYear(date.getFullYear()+step);},function(start,end){return end.getFullYear()-start.getFullYear();},function(date){return date.getFullYear();});// An optimized implementation for this simple case.\nyear.every=function(k){return!isFinite(k=Math.floor(k))||!(k>0)?null:newInterval(function(date){date.setFullYear(Math.floor(date.getFullYear()/k)*k);date.setMonth(0,1);date.setHours(0,0,0,0);},function(date,step){date.setFullYear(date.getFullYear()+step*k);});};var years=year.range;var utcMinute=newInterval(function(date){date.setUTCSeconds(0,0);},function(date,step){date.setTime(+date+step*durationMinute);},function(start,end){return(end-start)/durationMinute;},function(date){return date.getUTCMinutes();});var utcMinutes=utcMinute.range;var utcHour=newInterval(function(date){date.setUTCMinutes(0,0,0);},function(date,step){date.setTime(+date+step*durationHour);},function(start,end){return(end-start)/durationHour;},function(date){return date.getUTCHours();});var utcHours=utcHour.range;var utcDay=newInterval(function(date){date.setUTCHours(0,0,0,0);},function(date,step){date.setUTCDate(date.getUTCDate()+step);},function(start,end){return(end-start)/durationDay;},function(date){return date.getUTCDate()-1;});var utcDays=utcDay.range;function utcWeekday(i){return newInterval(function(date){date.setUTCDate(date.getUTCDate()-(date.getUTCDay()+7-i)%7);date.setUTCHours(0,0,0,0);},function(date,step){date.setUTCDate(date.getUTCDate()+step*7);},function(start,end){return(end-start)/durationWeek;});}var utcSunday=utcWeekday(0);var utcMonday=utcWeekday(1);var utcTuesday=utcWeekday(2);var utcWednesday=utcWeekday(3);var utcThursday=utcWeekday(4);var utcFriday=utcWeekday(5);var utcSaturday=utcWeekday(6);var utcSundays=utcSunday.range;var utcMondays=utcMonday.range;var utcTuesdays=utcTuesday.range;var utcWednesdays=utcWednesday.range;var utcThursdays=utcThursday.range;var utcFridays=utcFriday.range;var utcSaturdays=utcSaturday.range;var utcMonth=newInterval(function(date){date.setUTCDate(1);date.setUTCHours(0,0,0,0);},function(date,step){date.setUTCMonth(date.getUTCMonth()+step);},function(start,end){return end.getUTCMonth()-start.getUTCMonth()+(end.getUTCFullYear()-start.getUTCFullYear())*12;},function(date){return date.getUTCMonth();});var utcMonths=utcMonth.range;var utcYear=newInterval(function(date){date.setUTCMonth(0,1);date.setUTCHours(0,0,0,0);},function(date,step){date.setUTCFullYear(date.getUTCFullYear()+step);},function(start,end){return end.getUTCFullYear()-start.getUTCFullYear();},function(date){return date.getUTCFullYear();});// An optimized implementation for this simple case.\nutcYear.every=function(k){return!isFinite(k=Math.floor(k))||!(k>0)?null:newInterval(function(date){date.setUTCFullYear(Math.floor(date.getUTCFullYear()/k)*k);date.setUTCMonth(0,1);date.setUTCHours(0,0,0,0);},function(date,step){date.setUTCFullYear(date.getUTCFullYear()+step*k);});};var utcYears=utcYear.range;function localDate(d){if(0<=d.y&&d.y<100){var date=new Date(-1,d.m,d.d,d.H,d.M,d.S,d.L);date.setFullYear(d.y);return date;}return new Date(d.y,d.m,d.d,d.H,d.M,d.S,d.L);}function utcDate(d){if(0<=d.y&&d.y<100){var date=new Date(Date.UTC(-1,d.m,d.d,d.H,d.M,d.S,d.L));date.setUTCFullYear(d.y);return date;}return new Date(Date.UTC(d.y,d.m,d.d,d.H,d.M,d.S,d.L));}function newYear(y){return{y:y,m:0,d:1,H:0,M:0,S:0,L:0};}function formatLocale$1(locale){var locale_dateTime=locale.dateTime,locale_date=locale.date,locale_time=locale.time,locale_periods=locale.periods,locale_weekdays=locale.days,locale_shortWeekdays=locale.shortDays,locale_months=locale.months,locale_shortMonths=locale.shortMonths;var periodRe=formatRe(locale_periods),periodLookup=formatLookup(locale_periods),weekdayRe=formatRe(locale_weekdays),weekdayLookup=formatLookup(locale_weekdays),shortWeekdayRe=formatRe(locale_shortWeekdays),shortWeekdayLookup=formatLookup(locale_shortWeekdays),monthRe=formatRe(locale_months),monthLookup=formatLookup(locale_months),shortMonthRe=formatRe(locale_shortMonths),shortMonthLookup=formatLookup(locale_shortMonths);var formats={\"a\":formatShortWeekday,\"A\":formatWeekday,\"b\":formatShortMonth,\"B\":formatMonth,\"c\":null,\"d\":formatDayOfMonth,\"e\":formatDayOfMonth,\"f\":formatMicroseconds,\"H\":formatHour24,\"I\":formatHour12,\"j\":formatDayOfYear,\"L\":formatMilliseconds,\"m\":formatMonthNumber,\"M\":formatMinutes,\"p\":formatPeriod,\"Q\":formatUnixTimestamp,\"s\":formatUnixTimestampSeconds,\"S\":formatSeconds,\"u\":formatWeekdayNumberMonday,\"U\":formatWeekNumberSunday,\"V\":formatWeekNumberISO,\"w\":formatWeekdayNumberSunday,\"W\":formatWeekNumberMonday,\"x\":null,\"X\":null,\"y\":formatYear,\"Y\":formatFullYear,\"Z\":formatZone,\"%\":formatLiteralPercent};var utcFormats={\"a\":formatUTCShortWeekday,\"A\":formatUTCWeekday,\"b\":formatUTCShortMonth,\"B\":formatUTCMonth,\"c\":null,\"d\":formatUTCDayOfMonth,\"e\":formatUTCDayOfMonth,\"f\":formatUTCMicroseconds,\"H\":formatUTCHour24,\"I\":formatUTCHour12,\"j\":formatUTCDayOfYear,\"L\":formatUTCMilliseconds,\"m\":formatUTCMonthNumber,\"M\":formatUTCMinutes,\"p\":formatUTCPeriod,\"Q\":formatUnixTimestamp,\"s\":formatUnixTimestampSeconds,\"S\":formatUTCSeconds,\"u\":formatUTCWeekdayNumberMonday,\"U\":formatUTCWeekNumberSunday,\"V\":formatUTCWeekNumberISO,\"w\":formatUTCWeekdayNumberSunday,\"W\":formatUTCWeekNumberMonday,\"x\":null,\"X\":null,\"y\":formatUTCYear,\"Y\":formatUTCFullYear,\"Z\":formatUTCZone,\"%\":formatLiteralPercent};var parses={\"a\":parseShortWeekday,\"A\":parseWeekday,\"b\":parseShortMonth,\"B\":parseMonth,\"c\":parseLocaleDateTime,\"d\":parseDayOfMonth,\"e\":parseDayOfMonth,\"f\":parseMicroseconds,\"H\":parseHour24,\"I\":parseHour24,\"j\":parseDayOfYear,\"L\":parseMilliseconds,\"m\":parseMonthNumber,\"M\":parseMinutes,\"p\":parsePeriod,\"Q\":parseUnixTimestamp,\"s\":parseUnixTimestampSeconds,\"S\":parseSeconds,\"u\":parseWeekdayNumberMonday,\"U\":parseWeekNumberSunday,\"V\":parseWeekNumberISO,\"w\":parseWeekdayNumberSunday,\"W\":parseWeekNumberMonday,\"x\":parseLocaleDate,\"X\":parseLocaleTime,\"y\":parseYear,\"Y\":parseFullYear,\"Z\":parseZone,\"%\":parseLiteralPercent};// These recursive directive definitions must be deferred.\nformats.x=newFormat(locale_date,formats);formats.X=newFormat(locale_time,formats);formats.c=newFormat(locale_dateTime,formats);utcFormats.x=newFormat(locale_date,utcFormats);utcFormats.X=newFormat(locale_time,utcFormats);utcFormats.c=newFormat(locale_dateTime,utcFormats);function newFormat(specifier,formats){return function(date){var string=[],i=-1,j=0,n=specifier.length,c,pad,format;if(!(date instanceof Date))date=new Date(+date);while(++i<n){if(specifier.charCodeAt(i)===37){string.push(specifier.slice(j,i));if((pad=pads[c=specifier.charAt(++i)])!=null)c=specifier.charAt(++i);else pad=c===\"e\"?\" \":\"0\";if(format=formats[c])c=format(date,pad);string.push(c);j=i+1;}}string.push(specifier.slice(j,i));return string.join(\"\");};}function newParse(specifier,newDate){return function(string){var d=newYear(1900),i=parseSpecifier(d,specifier,string+=\"\",0),week,day$$1;if(i!=string.length)return null;// If a UNIX timestamp is specified, return it.\nif(\"Q\"in d)return new Date(d.Q);// The am-pm flag is 0 for AM, and 1 for PM.\nif(\"p\"in d)d.H=d.H%12+d.p*12;// Convert day-of-week and week-of-year to day-of-year.\nif(\"V\"in d){if(d.V<1||d.V>53)return null;if(!(\"w\"in d))d.w=1;if(\"Z\"in d){week=utcDate(newYear(d.y)),day$$1=week.getUTCDay();week=day$$1>4||day$$1===0?utcMonday.ceil(week):utcMonday(week);week=utcDay.offset(week,(d.V-1)*7);d.y=week.getUTCFullYear();d.m=week.getUTCMonth();d.d=week.getUTCDate()+(d.w+6)%7;}else{week=newDate(newYear(d.y)),day$$1=week.getDay();week=day$$1>4||day$$1===0?monday.ceil(week):monday(week);week=day.offset(week,(d.V-1)*7);d.y=week.getFullYear();d.m=week.getMonth();d.d=week.getDate()+(d.w+6)%7;}}else if(\"W\"in d||\"U\"in d){if(!(\"w\"in d))d.w=\"u\"in d?d.u%7:\"W\"in d?1:0;day$$1=\"Z\"in d?utcDate(newYear(d.y)).getUTCDay():newDate(newYear(d.y)).getDay();d.m=0;d.d=\"W\"in d?(d.w+6)%7+d.W*7-(day$$1+5)%7:d.w+d.U*7-(day$$1+6)%7;}// If a time zone is specified, all fields are interpreted as UTC and then\n// offset according to the specified time zone.\nif(\"Z\"in d){d.H+=d.Z/100|0;d.M+=d.Z%100;return utcDate(d);}// Otherwise, all fields are in local time.\nreturn newDate(d);};}function parseSpecifier(d,specifier,string,j){var i=0,n=specifier.length,m=string.length,c,parse;while(i<n){if(j>=m)return-1;c=specifier.charCodeAt(i++);if(c===37){c=specifier.charAt(i++);parse=parses[c in pads?specifier.charAt(i++):c];if(!parse||(j=parse(d,string,j))<0)return-1;}else if(c!=string.charCodeAt(j++)){return-1;}}return j;}function parsePeriod(d,string,i){var n=periodRe.exec(string.slice(i));return n?(d.p=periodLookup[n[0].toLowerCase()],i+n[0].length):-1;}function parseShortWeekday(d,string,i){var n=shortWeekdayRe.exec(string.slice(i));return n?(d.w=shortWeekdayLookup[n[0].toLowerCase()],i+n[0].length):-1;}function parseWeekday(d,string,i){var n=weekdayRe.exec(string.slice(i));return n?(d.w=weekdayLookup[n[0].toLowerCase()],i+n[0].length):-1;}function parseShortMonth(d,string,i){var n=shortMonthRe.exec(string.slice(i));return n?(d.m=shortMonthLookup[n[0].toLowerCase()],i+n[0].length):-1;}function parseMonth(d,string,i){var n=monthRe.exec(string.slice(i));return n?(d.m=monthLookup[n[0].toLowerCase()],i+n[0].length):-1;}function parseLocaleDateTime(d,string,i){return parseSpecifier(d,locale_dateTime,string,i);}function parseLocaleDate(d,string,i){return parseSpecifier(d,locale_date,string,i);}function parseLocaleTime(d,string,i){return parseSpecifier(d,locale_time,string,i);}function formatShortWeekday(d){return locale_shortWeekdays[d.getDay()];}function formatWeekday(d){return locale_weekdays[d.getDay()];}function formatShortMonth(d){return locale_shortMonths[d.getMonth()];}function formatMonth(d){return locale_months[d.getMonth()];}function formatPeriod(d){return locale_periods[+(d.getHours()>=12)];}function formatUTCShortWeekday(d){return locale_shortWeekdays[d.getUTCDay()];}function formatUTCWeekday(d){return locale_weekdays[d.getUTCDay()];}function formatUTCShortMonth(d){return locale_shortMonths[d.getUTCMonth()];}function formatUTCMonth(d){return locale_months[d.getUTCMonth()];}function formatUTCPeriod(d){return locale_periods[+(d.getUTCHours()>=12)];}return{format:function format(specifier){var f=newFormat(specifier+=\"\",formats);f.toString=function(){return specifier;};return f;},parse:function parse(specifier){var p=newParse(specifier+=\"\",localDate);p.toString=function(){return specifier;};return p;},utcFormat:function utcFormat(specifier){var f=newFormat(specifier+=\"\",utcFormats);f.toString=function(){return specifier;};return f;},utcParse:function utcParse(specifier){var p=newParse(specifier,utcDate);p.toString=function(){return specifier;};return p;}};}var pads={\"-\":\"\",\"_\":\" \",\"0\":\"0\"},numberRe=/^\\s*\\d+/,// note: ignores next directive\npercentRe=/^%/,requoteRe=/[\\\\^$*+?|[\\]().{}]/g;function pad(value,fill,width){var sign=value<0?\"-\":\"\",string=(sign?-value:value)+\"\",length=string.length;return sign+(length<width?new Array(width-length+1).join(fill)+string:string);}function requote(s){return s.replace(requoteRe,\"\\\\$&\");}function formatRe(names){return new RegExp(\"^(?:\"+names.map(requote).join(\"|\")+\")\",\"i\");}function formatLookup(names){var map={},i=-1,n=names.length;while(++i<n){map[names[i].toLowerCase()]=i;}return map;}function parseWeekdayNumberSunday(d,string,i){var n=numberRe.exec(string.slice(i,i+1));return n?(d.w=+n[0],i+n[0].length):-1;}function parseWeekdayNumberMonday(d,string,i){var n=numberRe.exec(string.slice(i,i+1));return n?(d.u=+n[0],i+n[0].length):-1;}function parseWeekNumberSunday(d,string,i){var n=numberRe.exec(string.slice(i,i+2));return n?(d.U=+n[0],i+n[0].length):-1;}function parseWeekNumberISO(d,string,i){var n=numberRe.exec(string.slice(i,i+2));return n?(d.V=+n[0],i+n[0].length):-1;}function parseWeekNumberMonday(d,string,i){var n=numberRe.exec(string.slice(i,i+2));return n?(d.W=+n[0],i+n[0].length):-1;}function parseFullYear(d,string,i){var n=numberRe.exec(string.slice(i,i+4));return n?(d.y=+n[0],i+n[0].length):-1;}function parseYear(d,string,i){var n=numberRe.exec(string.slice(i,i+2));return n?(d.y=+n[0]+(+n[0]>68?1900:2000),i+n[0].length):-1;}function parseZone(d,string,i){var n=/^(Z)|([+-]\\d\\d)(?::?(\\d\\d))?/.exec(string.slice(i,i+6));return n?(d.Z=n[1]?0:-(n[2]+(n[3]||\"00\")),i+n[0].length):-1;}function parseMonthNumber(d,string,i){var n=numberRe.exec(string.slice(i,i+2));return n?(d.m=n[0]-1,i+n[0].length):-1;}function parseDayOfMonth(d,string,i){var n=numberRe.exec(string.slice(i,i+2));return n?(d.d=+n[0],i+n[0].length):-1;}function parseDayOfYear(d,string,i){var n=numberRe.exec(string.slice(i,i+3));return n?(d.m=0,d.d=+n[0],i+n[0].length):-1;}function parseHour24(d,string,i){var n=numberRe.exec(string.slice(i,i+2));return n?(d.H=+n[0],i+n[0].length):-1;}function parseMinutes(d,string,i){var n=numberRe.exec(string.slice(i,i+2));return n?(d.M=+n[0],i+n[0].length):-1;}function parseSeconds(d,string,i){var n=numberRe.exec(string.slice(i,i+2));return n?(d.S=+n[0],i+n[0].length):-1;}function parseMilliseconds(d,string,i){var n=numberRe.exec(string.slice(i,i+3));return n?(d.L=+n[0],i+n[0].length):-1;}function parseMicroseconds(d,string,i){var n=numberRe.exec(string.slice(i,i+6));return n?(d.L=Math.floor(n[0]/1000),i+n[0].length):-1;}function parseLiteralPercent(d,string,i){var n=percentRe.exec(string.slice(i,i+1));return n?i+n[0].length:-1;}function parseUnixTimestamp(d,string,i){var n=numberRe.exec(string.slice(i));return n?(d.Q=+n[0],i+n[0].length):-1;}function parseUnixTimestampSeconds(d,string,i){var n=numberRe.exec(string.slice(i));return n?(d.Q=+n[0]*1000,i+n[0].length):-1;}function formatDayOfMonth(d,p){return pad(d.getDate(),p,2);}function formatHour24(d,p){return pad(d.getHours(),p,2);}function formatHour12(d,p){return pad(d.getHours()%12||12,p,2);}function formatDayOfYear(d,p){return pad(1+day.count(year(d),d),p,3);}function formatMilliseconds(d,p){return pad(d.getMilliseconds(),p,3);}function formatMicroseconds(d,p){return formatMilliseconds(d,p)+\"000\";}function formatMonthNumber(d,p){return pad(d.getMonth()+1,p,2);}function formatMinutes(d,p){return pad(d.getMinutes(),p,2);}function formatSeconds(d,p){return pad(d.getSeconds(),p,2);}function formatWeekdayNumberMonday(d){var day$$1=d.getDay();return day$$1===0?7:day$$1;}function formatWeekNumberSunday(d,p){return pad(sunday.count(year(d),d),p,2);}function formatWeekNumberISO(d,p){var day$$1=d.getDay();d=day$$1>=4||day$$1===0?thursday(d):thursday.ceil(d);return pad(thursday.count(year(d),d)+(year(d).getDay()===4),p,2);}function formatWeekdayNumberSunday(d){return d.getDay();}function formatWeekNumberMonday(d,p){return pad(monday.count(year(d),d),p,2);}function formatYear(d,p){return pad(d.getFullYear()%100,p,2);}function formatFullYear(d,p){return pad(d.getFullYear()%10000,p,4);}function formatZone(d){var z=d.getTimezoneOffset();return(z>0?\"-\":(z*=-1,\"+\"))+pad(z/60|0,\"0\",2)+pad(z%60,\"0\",2);}function formatUTCDayOfMonth(d,p){return pad(d.getUTCDate(),p,2);}function formatUTCHour24(d,p){return pad(d.getUTCHours(),p,2);}function formatUTCHour12(d,p){return pad(d.getUTCHours()%12||12,p,2);}function formatUTCDayOfYear(d,p){return pad(1+utcDay.count(utcYear(d),d),p,3);}function formatUTCMilliseconds(d,p){return pad(d.getUTCMilliseconds(),p,3);}function formatUTCMicroseconds(d,p){return formatUTCMilliseconds(d,p)+\"000\";}function formatUTCMonthNumber(d,p){return pad(d.getUTCMonth()+1,p,2);}function formatUTCMinutes(d,p){return pad(d.getUTCMinutes(),p,2);}function formatUTCSeconds(d,p){return pad(d.getUTCSeconds(),p,2);}function formatUTCWeekdayNumberMonday(d){var dow=d.getUTCDay();return dow===0?7:dow;}function formatUTCWeekNumberSunday(d,p){return pad(utcSunday.count(utcYear(d),d),p,2);}function formatUTCWeekNumberISO(d,p){var day$$1=d.getUTCDay();d=day$$1>=4||day$$1===0?utcThursday(d):utcThursday.ceil(d);return pad(utcThursday.count(utcYear(d),d)+(utcYear(d).getUTCDay()===4),p,2);}function formatUTCWeekdayNumberSunday(d){return d.getUTCDay();}function formatUTCWeekNumberMonday(d,p){return pad(utcMonday.count(utcYear(d),d),p,2);}function formatUTCYear(d,p){return pad(d.getUTCFullYear()%100,p,2);}function formatUTCFullYear(d,p){return pad(d.getUTCFullYear()%10000,p,4);}function formatUTCZone(){return\"+0000\";}function formatLiteralPercent(){return\"%\";}function formatUnixTimestamp(d){return+d;}function formatUnixTimestampSeconds(d){return Math.floor(+d/1000);}var locale$1;defaultLocale$1({dateTime:\"%x, %X\",date:\"%-m/%-d/%Y\",time:\"%-I:%M:%S %p\",periods:[\"AM\",\"PM\"],days:[\"Sunday\",\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\"],shortDays:[\"Sun\",\"Mon\",\"Tue\",\"Wed\",\"Thu\",\"Fri\",\"Sat\"],months:[\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"],shortMonths:[\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"]});function defaultLocale$1(definition){locale$1=formatLocale$1(definition);d3.timeFormat=locale$1.format;d3.timeParse=locale$1.parse;d3.utcFormat=locale$1.utcFormat;d3.utcParse=locale$1.utcParse;return locale$1;}var isoSpecifier=\"%Y-%m-%dT%H:%M:%S.%LZ\";function formatIsoNative(date){return date.toISOString();}var formatIso=Date.prototype.toISOString?formatIsoNative:d3.utcFormat(isoSpecifier);function parseIsoNative(string){var date=new Date(string);return isNaN(date)?null:date;}var parseIso=+new Date(\"2000-01-01T00:00:00.000Z\")?parseIsoNative:d3.utcParse(isoSpecifier);var durationSecond$1=1000,durationMinute$1=durationSecond$1*60,durationHour$1=durationMinute$1*60,durationDay$1=durationHour$1*24,durationWeek$1=durationDay$1*7,durationMonth=durationDay$1*30,durationYear=durationDay$1*365;function date$1(t){return new Date(t);}function number$3(t){return t instanceof Date?+t:+new Date(+t);}function calendar(year$$1,month$$1,week,day$$1,hour$$1,minute$$1,second$$1,millisecond$$1,format){var scale=continuous(deinterpolateLinear,reinterpolate),invert=scale.invert,domain=scale.domain;var formatMillisecond=format(\".%L\"),formatSecond=format(\":%S\"),formatMinute=format(\"%I:%M\"),formatHour=format(\"%I %p\"),formatDay=format(\"%a %d\"),formatWeek=format(\"%b %d\"),formatMonth=format(\"%B\"),formatYear=format(\"%Y\");var tickIntervals=[[second$$1,1,durationSecond$1],[second$$1,5,5*durationSecond$1],[second$$1,15,15*durationSecond$1],[second$$1,30,30*durationSecond$1],[minute$$1,1,durationMinute$1],[minute$$1,5,5*durationMinute$1],[minute$$1,15,15*durationMinute$1],[minute$$1,30,30*durationMinute$1],[hour$$1,1,durationHour$1],[hour$$1,3,3*durationHour$1],[hour$$1,6,6*durationHour$1],[hour$$1,12,12*durationHour$1],[day$$1,1,durationDay$1],[day$$1,2,2*durationDay$1],[week,1,durationWeek$1],[month$$1,1,durationMonth],[month$$1,3,3*durationMonth],[year$$1,1,durationYear]];function tickFormat(date$$1){return(second$$1(date$$1)<date$$1?formatMillisecond:minute$$1(date$$1)<date$$1?formatSecond:hour$$1(date$$1)<date$$1?formatMinute:day$$1(date$$1)<date$$1?formatHour:month$$1(date$$1)<date$$1?week(date$$1)<date$$1?formatDay:formatWeek:year$$1(date$$1)<date$$1?formatMonth:formatYear)(date$$1);}function tickInterval(interval,start,stop,step){if(interval==null)interval=10;// If a desired tick count is specified, pick a reasonable tick interval\n// based on the extent of the domain and a rough estimate of tick size.\n// Otherwise, assume interval is already a time interval and use it.\nif(typeof interval===\"number\"){var target=Math.abs(stop-start)/interval,i=bisector(function(i){return i[2];}).right(tickIntervals,target);if(i===tickIntervals.length){step=tickStep(start/durationYear,stop/durationYear,interval);interval=year$$1;}else if(i){i=tickIntervals[target/tickIntervals[i-1][2]<tickIntervals[i][2]/target?i-1:i];step=i[1];interval=i[0];}else{step=Math.max(tickStep(start,stop,interval),1);interval=millisecond$$1;}}return step==null?interval:interval.every(step);}scale.invert=function(y){return new Date(invert(y));};scale.domain=function(_){return arguments.length?domain(map$2.call(_,number$3)):domain().map(date$1);};scale.ticks=function(interval,step){var d=domain(),t0=d[0],t1=d[d.length-1],r=t1<t0,t;if(r)t=t0,t0=t1,t1=t;t=tickInterval(interval,t0,t1,step);t=t?t.range(t0,t1+1):[];// inclusive stop\nreturn r?t.reverse():t;};scale.tickFormat=function(count,specifier){return specifier==null?tickFormat:format(specifier);};scale.nice=function(interval,step){var d=domain();return(interval=tickInterval(interval,d[0],d[d.length-1],step))?domain(nice(d,interval)):scale;};scale.copy=function(){return copy(scale,calendar(year$$1,month$$1,week,day$$1,hour$$1,minute$$1,second$$1,millisecond$$1,format));};return scale;}function time(){return calendar(year,month,sunday,day,hour,minute,second,millisecond,d3.timeFormat).domain([new Date(2000,0,1),new Date(2000,0,2)]);}function utcTime(){return calendar(utcYear,utcMonth,utcSunday,utcDay,utcHour,utcMinute,second,millisecond,d3.utcFormat).domain([Date.UTC(2000,0,1),Date.UTC(2000,0,2)]);}function sequential(interpolator){var x0=0,x1=1,clamp=false;function scale(x){var t=(x-x0)/(x1-x0);return interpolator(clamp?Math.max(0,Math.min(1,t)):t);}scale.domain=function(_){return arguments.length?(x0=+_[0],x1=+_[1],scale):[x0,x1];};scale.clamp=function(_){return arguments.length?(clamp=!!_,scale):clamp;};scale.interpolator=function(_){return arguments.length?(interpolator=_,scale):interpolator;};scale.copy=function(){return sequential(interpolator).domain([x0,x1]).clamp(clamp);};return linearish(scale);}function colors(specifier){var n=specifier.length/6|0,colors=new Array(n),i=0;while(i<n){colors[i]=\"#\"+specifier.slice(i*6,++i*6);}return colors;}var category10=colors(\"1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf\");var Accent=colors(\"7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666\");var Dark2=colors(\"1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666\");var Paired=colors(\"a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928\");var Pastel1=colors(\"fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2\");var Pastel2=colors(\"b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc\");var Set1=colors(\"e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999\");var Set2=colors(\"66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3\");var Set3=colors(\"8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f\");function ramp(scheme){return rgbBasis(scheme[scheme.length-1]);}var scheme=new Array(3).concat(\"d8b365f5f5f55ab4ac\",\"a6611adfc27d80cdc1018571\",\"a6611adfc27df5f5f580cdc1018571\",\"8c510ad8b365f6e8c3c7eae55ab4ac01665e\",\"8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e\",\"8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e\",\"8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e\",\"5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30\",\"5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30\").map(colors);var BrBG=ramp(scheme);var scheme$1=new Array(3).concat(\"af8dc3f7f7f77fbf7b\",\"7b3294c2a5cfa6dba0008837\",\"7b3294c2a5cff7f7f7a6dba0008837\",\"762a83af8dc3e7d4e8d9f0d37fbf7b1b7837\",\"762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837\",\"762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837\",\"762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837\",\"40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b\",\"40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b\").map(colors);var PRGn=ramp(scheme$1);var scheme$2=new Array(3).concat(\"e9a3c9f7f7f7a1d76a\",\"d01c8bf1b6dab8e1864dac26\",\"d01c8bf1b6daf7f7f7b8e1864dac26\",\"c51b7de9a3c9fde0efe6f5d0a1d76a4d9221\",\"c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221\",\"c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221\",\"c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221\",\"8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419\",\"8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419\").map(colors);var PiYG=ramp(scheme$2);var scheme$3=new Array(3).concat(\"998ec3f7f7f7f1a340\",\"5e3c99b2abd2fdb863e66101\",\"5e3c99b2abd2f7f7f7fdb863e66101\",\"542788998ec3d8daebfee0b6f1a340b35806\",\"542788998ec3d8daebf7f7f7fee0b6f1a340b35806\",\"5427888073acb2abd2d8daebfee0b6fdb863e08214b35806\",\"5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806\",\"2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08\",\"2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08\").map(colors);var PuOr=ramp(scheme$3);var scheme$4=new Array(3).concat(\"ef8a62f7f7f767a9cf\",\"ca0020f4a58292c5de0571b0\",\"ca0020f4a582f7f7f792c5de0571b0\",\"b2182bef8a62fddbc7d1e5f067a9cf2166ac\",\"b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac\",\"b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac\",\"b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac\",\"67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061\",\"67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061\").map(colors);var RdBu=ramp(scheme$4);var scheme$5=new Array(3).concat(\"ef8a62ffffff999999\",\"ca0020f4a582bababa404040\",\"ca0020f4a582ffffffbababa404040\",\"b2182bef8a62fddbc7e0e0e09999994d4d4d\",\"b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d\",\"b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d\",\"b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d\",\"67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a\",\"67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a\").map(colors);var RdGy=ramp(scheme$5);var scheme$6=new Array(3).concat(\"fc8d59ffffbf91bfdb\",\"d7191cfdae61abd9e92c7bb6\",\"d7191cfdae61ffffbfabd9e92c7bb6\",\"d73027fc8d59fee090e0f3f891bfdb4575b4\",\"d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4\",\"d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4\",\"d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4\",\"a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695\",\"a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695\").map(colors);var RdYlBu=ramp(scheme$6);var scheme$7=new Array(3).concat(\"fc8d59ffffbf91cf60\",\"d7191cfdae61a6d96a1a9641\",\"d7191cfdae61ffffbfa6d96a1a9641\",\"d73027fc8d59fee08bd9ef8b91cf601a9850\",\"d73027fc8d59fee08bffffbfd9ef8b91cf601a9850\",\"d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850\",\"d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850\",\"a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837\",\"a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837\").map(colors);var RdYlGn=ramp(scheme$7);var scheme$8=new Array(3).concat(\"fc8d59ffffbf99d594\",\"d7191cfdae61abdda42b83ba\",\"d7191cfdae61ffffbfabdda42b83ba\",\"d53e4ffc8d59fee08be6f59899d5943288bd\",\"d53e4ffc8d59fee08bffffbfe6f59899d5943288bd\",\"d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd\",\"d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd\",\"9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2\",\"9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2\").map(colors);var Spectral=ramp(scheme$8);var scheme$9=new Array(3).concat(\"e5f5f999d8c92ca25f\",\"edf8fbb2e2e266c2a4238b45\",\"edf8fbb2e2e266c2a42ca25f006d2c\",\"edf8fbccece699d8c966c2a42ca25f006d2c\",\"edf8fbccece699d8c966c2a441ae76238b45005824\",\"f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824\",\"f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b\").map(colors);var BuGn=ramp(scheme$9);var scheme$10=new Array(3).concat(\"e0ecf49ebcda8856a7\",\"edf8fbb3cde38c96c688419d\",\"edf8fbb3cde38c96c68856a7810f7c\",\"edf8fbbfd3e69ebcda8c96c68856a7810f7c\",\"edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b\",\"f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b\",\"f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b\").map(colors);var BuPu=ramp(scheme$10);var scheme$11=new Array(3).concat(\"e0f3dba8ddb543a2ca\",\"f0f9e8bae4bc7bccc42b8cbe\",\"f0f9e8bae4bc7bccc443a2ca0868ac\",\"f0f9e8ccebc5a8ddb57bccc443a2ca0868ac\",\"f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e\",\"f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e\",\"f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081\").map(colors);var GnBu=ramp(scheme$11);var scheme$12=new Array(3).concat(\"fee8c8fdbb84e34a33\",\"fef0d9fdcc8afc8d59d7301f\",\"fef0d9fdcc8afc8d59e34a33b30000\",\"fef0d9fdd49efdbb84fc8d59e34a33b30000\",\"fef0d9fdd49efdbb84fc8d59ef6548d7301f990000\",\"fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000\",\"fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000\").map(colors);var OrRd=ramp(scheme$12);var scheme$13=new Array(3).concat(\"ece2f0a6bddb1c9099\",\"f6eff7bdc9e167a9cf02818a\",\"f6eff7bdc9e167a9cf1c9099016c59\",\"f6eff7d0d1e6a6bddb67a9cf1c9099016c59\",\"f6eff7d0d1e6a6bddb67a9cf3690c002818a016450\",\"fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450\",\"fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636\").map(colors);var PuBuGn=ramp(scheme$13);var scheme$14=new Array(3).concat(\"ece7f2a6bddb2b8cbe\",\"f1eef6bdc9e174a9cf0570b0\",\"f1eef6bdc9e174a9cf2b8cbe045a8d\",\"f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d\",\"f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b\",\"fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b\",\"fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858\").map(colors);var PuBu=ramp(scheme$14);var scheme$15=new Array(3).concat(\"e7e1efc994c7dd1c77\",\"f1eef6d7b5d8df65b0ce1256\",\"f1eef6d7b5d8df65b0dd1c77980043\",\"f1eef6d4b9dac994c7df65b0dd1c77980043\",\"f1eef6d4b9dac994c7df65b0e7298ace125691003f\",\"f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f\",\"f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f\").map(colors);var PuRd=ramp(scheme$15);var scheme$16=new Array(3).concat(\"fde0ddfa9fb5c51b8a\",\"feebe2fbb4b9f768a1ae017e\",\"feebe2fbb4b9f768a1c51b8a7a0177\",\"feebe2fcc5c0fa9fb5f768a1c51b8a7a0177\",\"feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177\",\"fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177\",\"fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a\").map(colors);var RdPu=ramp(scheme$16);var scheme$17=new Array(3).concat(\"edf8b17fcdbb2c7fb8\",\"ffffcca1dab441b6c4225ea8\",\"ffffcca1dab441b6c42c7fb8253494\",\"ffffccc7e9b47fcdbb41b6c42c7fb8253494\",\"ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84\",\"ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84\",\"ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58\").map(colors);var YlGnBu=ramp(scheme$17);var scheme$18=new Array(3).concat(\"f7fcb9addd8e31a354\",\"ffffccc2e69978c679238443\",\"ffffccc2e69978c67931a354006837\",\"ffffccd9f0a3addd8e78c67931a354006837\",\"ffffccd9f0a3addd8e78c67941ab5d238443005a32\",\"ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32\",\"ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529\").map(colors);var YlGn=ramp(scheme$18);var scheme$19=new Array(3).concat(\"fff7bcfec44fd95f0e\",\"ffffd4fed98efe9929cc4c02\",\"ffffd4fed98efe9929d95f0e993404\",\"ffffd4fee391fec44ffe9929d95f0e993404\",\"ffffd4fee391fec44ffe9929ec7014cc4c028c2d04\",\"ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04\",\"ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506\").map(colors);var YlOrBr=ramp(scheme$19);var scheme$20=new Array(3).concat(\"ffeda0feb24cf03b20\",\"ffffb2fecc5cfd8d3ce31a1c\",\"ffffb2fecc5cfd8d3cf03b20bd0026\",\"ffffb2fed976feb24cfd8d3cf03b20bd0026\",\"ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026\",\"ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026\",\"ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026\").map(colors);var YlOrRd=ramp(scheme$20);var scheme$21=new Array(3).concat(\"deebf79ecae13182bd\",\"eff3ffbdd7e76baed62171b5\",\"eff3ffbdd7e76baed63182bd08519c\",\"eff3ffc6dbef9ecae16baed63182bd08519c\",\"eff3ffc6dbef9ecae16baed64292c62171b5084594\",\"f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594\",\"f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b\").map(colors);var Blues=ramp(scheme$21);var scheme$22=new Array(3).concat(\"e5f5e0a1d99b31a354\",\"edf8e9bae4b374c476238b45\",\"edf8e9bae4b374c47631a354006d2c\",\"edf8e9c7e9c0a1d99b74c47631a354006d2c\",\"edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32\",\"f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32\",\"f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b\").map(colors);var Greens=ramp(scheme$22);var scheme$23=new Array(3).concat(\"f0f0f0bdbdbd636363\",\"f7f7f7cccccc969696525252\",\"f7f7f7cccccc969696636363252525\",\"f7f7f7d9d9d9bdbdbd969696636363252525\",\"f7f7f7d9d9d9bdbdbd969696737373525252252525\",\"fffffff0f0f0d9d9d9bdbdbd969696737373525252252525\",\"fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000\").map(colors);var Greys=ramp(scheme$23);var scheme$24=new Array(3).concat(\"efedf5bcbddc756bb1\",\"f2f0f7cbc9e29e9ac86a51a3\",\"f2f0f7cbc9e29e9ac8756bb154278f\",\"f2f0f7dadaebbcbddc9e9ac8756bb154278f\",\"f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486\",\"fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486\",\"fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d\").map(colors);var Purples=ramp(scheme$24);var scheme$25=new Array(3).concat(\"fee0d2fc9272de2d26\",\"fee5d9fcae91fb6a4acb181d\",\"fee5d9fcae91fb6a4ade2d26a50f15\",\"fee5d9fcbba1fc9272fb6a4ade2d26a50f15\",\"fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d\",\"fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d\",\"fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d\").map(colors);var Reds=ramp(scheme$25);var scheme$26=new Array(3).concat(\"fee6cefdae6be6550d\",\"feeddefdbe85fd8d3cd94701\",\"feeddefdbe85fd8d3ce6550da63603\",\"feeddefdd0a2fdae6bfd8d3ce6550da63603\",\"feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04\",\"fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04\",\"fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704\").map(colors);var Oranges=ramp(scheme$26);var cubehelix$3=cubehelixLong(cubehelix(300,0.5,0.0),cubehelix(-240,0.5,1.0));var warm=cubehelixLong(cubehelix(-100,0.75,0.35),cubehelix(80,1.50,0.8));var cool=cubehelixLong(cubehelix(260,0.75,0.35),cubehelix(80,1.50,0.8));var c=cubehelix();function rainbow(t){if(t<0||t>1)t-=Math.floor(t);var ts=Math.abs(t-0.5);c.h=360*t-100;c.s=1.5-1.5*ts;c.l=0.8-0.9*ts;return c+\"\";}var c$1=rgb(),pi_1_3=Math.PI/3,pi_2_3=Math.PI*2/3;function sinebow(t){var x;t=(0.5-t)*Math.PI;c$1.r=255*(x=Math.sin(t))*x;c$1.g=255*(x=Math.sin(t+pi_1_3))*x;c$1.b=255*(x=Math.sin(t+pi_2_3))*x;return c$1+\"\";}function ramp$1(range){var n=range.length;return function(t){return range[Math.max(0,Math.min(n-1,Math.floor(t*n)))];};}var viridis=ramp$1(colors(\"44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725\"));var magma=ramp$1(colors(\"00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf\"));var inferno=ramp$1(colors(\"00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4\"));var plasma=ramp$1(colors(\"0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921\"));function constant$11(x){return function constant(){return x;};}var abs$1=Math.abs;var atan2$1=Math.atan2;var cos$2=Math.cos;var max$2=Math.max;var min$1=Math.min;var sin$2=Math.sin;var sqrt$2=Math.sqrt;var epsilon$3=1e-12;var pi$4=Math.PI;var halfPi$3=pi$4/2;var tau$4=2*pi$4;function acos$1(x){return x>1?0:x<-1?pi$4:Math.acos(x);}function asin$1(x){return x>=1?halfPi$3:x<=-1?-halfPi$3:Math.asin(x);}function arcInnerRadius(d){return d.innerRadius;}function arcOuterRadius(d){return d.outerRadius;}function arcStartAngle(d){return d.startAngle;}function arcEndAngle(d){return d.endAngle;}function arcPadAngle(d){return d&&d.padAngle;// Note: optional!\n}function intersect(x0,y0,x1,y1,x2,y2,x3,y3){var x10=x1-x0,y10=y1-y0,x32=x3-x2,y32=y3-y2,t=(x32*(y0-y2)-y32*(x0-x2))/(y32*x10-x32*y10);return[x0+t*x10,y0+t*y10];}// Compute perpendicular offset line of length rc.\n// http://mathworld.wolfram.com/Circle-LineIntersection.html\nfunction cornerTangents(x0,y0,x1,y1,r1,rc,cw){var x01=x0-x1,y01=y0-y1,lo=(cw?rc:-rc)/sqrt$2(x01*x01+y01*y01),ox=lo*y01,oy=-lo*x01,x11=x0+ox,y11=y0+oy,x10=x1+ox,y10=y1+oy,x00=(x11+x10)/2,y00=(y11+y10)/2,dx=x10-x11,dy=y10-y11,d2=dx*dx+dy*dy,r=r1-rc,D=x11*y10-x10*y11,d=(dy<0?-1:1)*sqrt$2(max$2(0,r*r*d2-D*D)),cx0=(D*dy-dx*d)/d2,cy0=(-D*dx-dy*d)/d2,cx1=(D*dy+dx*d)/d2,cy1=(-D*dx+dy*d)/d2,dx0=cx0-x00,dy0=cy0-y00,dx1=cx1-x00,dy1=cy1-y00;// Pick the closer of the two intersection points.\n// TODO Is there a faster way to determine which intersection to use?\nif(dx0*dx0+dy0*dy0>dx1*dx1+dy1*dy1)cx0=cx1,cy0=cy1;return{cx:cx0,cy:cy0,x01:-ox,y01:-oy,x11:cx0*(r1/r-1),y11:cy0*(r1/r-1)};}function arc(){var innerRadius=arcInnerRadius,outerRadius=arcOuterRadius,cornerRadius=constant$11(0),padRadius=null,startAngle=arcStartAngle,endAngle=arcEndAngle,padAngle=arcPadAngle,context=null;function arc(){var buffer,r,r0=+innerRadius.apply(this,arguments),r1=+outerRadius.apply(this,arguments),a0=startAngle.apply(this,arguments)-halfPi$3,a1=endAngle.apply(this,arguments)-halfPi$3,da=abs$1(a1-a0),cw=a1>a0;if(!context)context=buffer=path();// Ensure that the outer radius is always larger than the inner radius.\nif(r1<r0)r=r1,r1=r0,r0=r;// Is it a point?\nif(!(r1>epsilon$3))context.moveTo(0,0);// Or is it a circle or annulus?\nelse if(da>tau$4-epsilon$3){context.moveTo(r1*cos$2(a0),r1*sin$2(a0));context.arc(0,0,r1,a0,a1,!cw);if(r0>epsilon$3){context.moveTo(r0*cos$2(a1),r0*sin$2(a1));context.arc(0,0,r0,a1,a0,cw);}}// Or is it a circular or annular sector?\nelse{var a01=a0,a11=a1,a00=a0,a10=a1,da0=da,da1=da,ap=padAngle.apply(this,arguments)/2,rp=ap>epsilon$3&&(padRadius?+padRadius.apply(this,arguments):sqrt$2(r0*r0+r1*r1)),rc=min$1(abs$1(r1-r0)/2,+cornerRadius.apply(this,arguments)),rc0=rc,rc1=rc,t0,t1;// Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.\nif(rp>epsilon$3){var p0=asin$1(rp/r0*sin$2(ap)),p1=asin$1(rp/r1*sin$2(ap));if((da0-=p0*2)>epsilon$3)p0*=cw?1:-1,a00+=p0,a10-=p0;else da0=0,a00=a10=(a0+a1)/2;if((da1-=p1*2)>epsilon$3)p1*=cw?1:-1,a01+=p1,a11-=p1;else da1=0,a01=a11=(a0+a1)/2;}var x01=r1*cos$2(a01),y01=r1*sin$2(a01),x10=r0*cos$2(a10),y10=r0*sin$2(a10);// Apply rounded corners?\nif(rc>epsilon$3){var x11=r1*cos$2(a11),y11=r1*sin$2(a11),x00=r0*cos$2(a00),y00=r0*sin$2(a00);// Restrict the corner radius according to the sector angle.\nif(da<pi$4){var oc=da0>epsilon$3?intersect(x01,y01,x00,y00,x11,y11,x10,y10):[x10,y10],ax=x01-oc[0],ay=y01-oc[1],bx=x11-oc[0],by=y11-oc[1],kc=1/sin$2(acos$1((ax*bx+ay*by)/(sqrt$2(ax*ax+ay*ay)*sqrt$2(bx*bx+by*by)))/2),lc=sqrt$2(oc[0]*oc[0]+oc[1]*oc[1]);rc0=min$1(rc,(r0-lc)/(kc-1));rc1=min$1(rc,(r1-lc)/(kc+1));}}// Is the sector collapsed to a line?\nif(!(da1>epsilon$3))context.moveTo(x01,y01);// Does the sector’s outer ring have rounded corners?\nelse if(rc1>epsilon$3){t0=cornerTangents(x00,y00,x01,y01,r1,rc1,cw);t1=cornerTangents(x11,y11,x10,y10,r1,rc1,cw);context.moveTo(t0.cx+t0.x01,t0.cy+t0.y01);// Have the corners merged?\nif(rc1<rc)context.arc(t0.cx,t0.cy,rc1,atan2$1(t0.y01,t0.x01),atan2$1(t1.y01,t1.x01),!cw);// Otherwise, draw the two corners and the ring.\nelse{context.arc(t0.cx,t0.cy,rc1,atan2$1(t0.y01,t0.x01),atan2$1(t0.y11,t0.x11),!cw);context.arc(0,0,r1,atan2$1(t0.cy+t0.y11,t0.cx+t0.x11),atan2$1(t1.cy+t1.y11,t1.cx+t1.x11),!cw);context.arc(t1.cx,t1.cy,rc1,atan2$1(t1.y11,t1.x11),atan2$1(t1.y01,t1.x01),!cw);}}// Or is the outer ring just a circular arc?\nelse context.moveTo(x01,y01),context.arc(0,0,r1,a01,a11,!cw);// Is there no inner ring, and it’s a circular sector?\n// Or perhaps it’s an annular sector collapsed due to padding?\nif(!(r0>epsilon$3)||!(da0>epsilon$3))context.lineTo(x10,y10);// Does the sector’s inner ring (or point) have rounded corners?\nelse if(rc0>epsilon$3){t0=cornerTangents(x10,y10,x11,y11,r0,-rc0,cw);t1=cornerTangents(x01,y01,x00,y00,r0,-rc0,cw);context.lineTo(t0.cx+t0.x01,t0.cy+t0.y01);// Have the corners merged?\nif(rc0<rc)context.arc(t0.cx,t0.cy,rc0,atan2$1(t0.y01,t0.x01),atan2$1(t1.y01,t1.x01),!cw);// Otherwise, draw the two corners and the ring.\nelse{context.arc(t0.cx,t0.cy,rc0,atan2$1(t0.y01,t0.x01),atan2$1(t0.y11,t0.x11),!cw);context.arc(0,0,r0,atan2$1(t0.cy+t0.y11,t0.cx+t0.x11),atan2$1(t1.cy+t1.y11,t1.cx+t1.x11),cw);context.arc(t1.cx,t1.cy,rc0,atan2$1(t1.y11,t1.x11),atan2$1(t1.y01,t1.x01),!cw);}}// Or is the inner ring just a circular arc?\nelse context.arc(0,0,r0,a10,a00,cw);}context.closePath();if(buffer)return context=null,buffer+\"\"||null;}arc.centroid=function(){var r=(+innerRadius.apply(this,arguments)+ +outerRadius.apply(this,arguments))/2,a=(+startAngle.apply(this,arguments)+ +endAngle.apply(this,arguments))/2-pi$4/2;return[cos$2(a)*r,sin$2(a)*r];};arc.innerRadius=function(_){return arguments.length?(innerRadius=typeof _===\"function\"?_:constant$11(+_),arc):innerRadius;};arc.outerRadius=function(_){return arguments.length?(outerRadius=typeof _===\"function\"?_:constant$11(+_),arc):outerRadius;};arc.cornerRadius=function(_){return arguments.length?(cornerRadius=typeof _===\"function\"?_:constant$11(+_),arc):cornerRadius;};arc.padRadius=function(_){return arguments.length?(padRadius=_==null?null:typeof _===\"function\"?_:constant$11(+_),arc):padRadius;};arc.startAngle=function(_){return arguments.length?(startAngle=typeof _===\"function\"?_:constant$11(+_),arc):startAngle;};arc.endAngle=function(_){return arguments.length?(endAngle=typeof _===\"function\"?_:constant$11(+_),arc):endAngle;};arc.padAngle=function(_){return arguments.length?(padAngle=typeof _===\"function\"?_:constant$11(+_),arc):padAngle;};arc.context=function(_){return arguments.length?(context=_==null?null:_,arc):context;};return arc;}function Linear(context){this._context=context;}Linear.prototype={areaStart:function areaStart(){this._line=0;},areaEnd:function areaEnd(){this._line=NaN;},lineStart:function lineStart(){this._point=0;},lineEnd:function lineEnd(){if(this._line||this._line!==0&&this._point===1)this._context.closePath();this._line=1-this._line;},point:function point(x,y){x=+x,y=+y;switch(this._point){case 0:this._point=1;this._line?this._context.lineTo(x,y):this._context.moveTo(x,y);break;case 1:this._point=2;// proceed\ndefault:this._context.lineTo(x,y);break;}}};function curveLinear(context){return new Linear(context);}function x$3(p){return p[0];}function y$3(p){return p[1];}function line(){var x$$1=x$3,y$$1=y$3,defined=constant$11(true),context=null,curve=curveLinear,output=null;function line(data){var i,n=data.length,d,defined0=false,buffer;if(context==null)output=curve(buffer=path());for(i=0;i<=n;++i){if(!(i<n&&defined(d=data[i],i,data))===defined0){if(defined0=!defined0)output.lineStart();else output.lineEnd();}if(defined0)output.point(+x$$1(d,i,data),+y$$1(d,i,data));}if(buffer)return output=null,buffer+\"\"||null;}line.x=function(_){return arguments.length?(x$$1=typeof _===\"function\"?_:constant$11(+_),line):x$$1;};line.y=function(_){return arguments.length?(y$$1=typeof _===\"function\"?_:constant$11(+_),line):y$$1;};line.defined=function(_){return arguments.length?(defined=typeof _===\"function\"?_:constant$11(!!_),line):defined;};line.curve=function(_){return arguments.length?(curve=_,context!=null&&(output=curve(context)),line):curve;};line.context=function(_){return arguments.length?(_==null?context=output=null:output=curve(context=_),line):context;};return line;}function area$3(){var x0=x$3,x1=null,y0=constant$11(0),y1=y$3,defined=constant$11(true),context=null,curve=curveLinear,output=null;function area(data){var i,j,k,n=data.length,d,defined0=false,buffer,x0z=new Array(n),y0z=new Array(n);if(context==null)output=curve(buffer=path());for(i=0;i<=n;++i){if(!(i<n&&defined(d=data[i],i,data))===defined0){if(defined0=!defined0){j=i;output.areaStart();output.lineStart();}else{output.lineEnd();output.lineStart();for(k=i-1;k>=j;--k){output.point(x0z[k],y0z[k]);}output.lineEnd();output.areaEnd();}}if(defined0){x0z[i]=+x0(d,i,data),y0z[i]=+y0(d,i,data);output.point(x1?+x1(d,i,data):x0z[i],y1?+y1(d,i,data):y0z[i]);}}if(buffer)return output=null,buffer+\"\"||null;}function arealine(){return line().defined(defined).curve(curve).context(context);}area.x=function(_){return arguments.length?(x0=typeof _===\"function\"?_:constant$11(+_),x1=null,area):x0;};area.x0=function(_){return arguments.length?(x0=typeof _===\"function\"?_:constant$11(+_),area):x0;};area.x1=function(_){return arguments.length?(x1=_==null?null:typeof _===\"function\"?_:constant$11(+_),area):x1;};area.y=function(_){return arguments.length?(y0=typeof _===\"function\"?_:constant$11(+_),y1=null,area):y0;};area.y0=function(_){return arguments.length?(y0=typeof _===\"function\"?_:constant$11(+_),area):y0;};area.y1=function(_){return arguments.length?(y1=_==null?null:typeof _===\"function\"?_:constant$11(+_),area):y1;};area.lineX0=area.lineY0=function(){return arealine().x(x0).y(y0);};area.lineY1=function(){return arealine().x(x0).y(y1);};area.lineX1=function(){return arealine().x(x1).y(y0);};area.defined=function(_){return arguments.length?(defined=typeof _===\"function\"?_:constant$11(!!_),area):defined;};area.curve=function(_){return arguments.length?(curve=_,context!=null&&(output=curve(context)),area):curve;};area.context=function(_){return arguments.length?(_==null?context=output=null:output=curve(context=_),area):context;};return area;}function descending$1(a,b){return b<a?-1:b>a?1:b>=a?0:NaN;}function identity$7(d){return d;}function pie(){var value=identity$7,sortValues=descending$1,sort=null,startAngle=constant$11(0),endAngle=constant$11(tau$4),padAngle=constant$11(0);function pie(data){var i,n=data.length,j,k,sum=0,index=new Array(n),arcs=new Array(n),a0=+startAngle.apply(this,arguments),da=Math.min(tau$4,Math.max(-tau$4,endAngle.apply(this,arguments)-a0)),a1,p=Math.min(Math.abs(da)/n,padAngle.apply(this,arguments)),pa=p*(da<0?-1:1),v;for(i=0;i<n;++i){if((v=arcs[index[i]=i]=+value(data[i],i,data))>0){sum+=v;}}// Optionally sort the arcs by previously-computed values or by data.\nif(sortValues!=null)index.sort(function(i,j){return sortValues(arcs[i],arcs[j]);});else if(sort!=null)index.sort(function(i,j){return sort(data[i],data[j]);});// Compute the arcs! They are stored in the original data's order.\nfor(i=0,k=sum?(da-n*pa)/sum:0;i<n;++i,a0=a1){j=index[i],v=arcs[j],a1=a0+(v>0?v*k:0)+pa,arcs[j]={data:data[j],index:i,value:v,startAngle:a0,endAngle:a1,padAngle:p};}return arcs;}pie.value=function(_){return arguments.length?(value=typeof _===\"function\"?_:constant$11(+_),pie):value;};pie.sortValues=function(_){return arguments.length?(sortValues=_,sort=null,pie):sortValues;};pie.sort=function(_){return arguments.length?(sort=_,sortValues=null,pie):sort;};pie.startAngle=function(_){return arguments.length?(startAngle=typeof _===\"function\"?_:constant$11(+_),pie):startAngle;};pie.endAngle=function(_){return arguments.length?(endAngle=typeof _===\"function\"?_:constant$11(+_),pie):endAngle;};pie.padAngle=function(_){return arguments.length?(padAngle=typeof _===\"function\"?_:constant$11(+_),pie):padAngle;};return pie;}var curveRadialLinear=curveRadial(curveLinear);function Radial(curve){this._curve=curve;}Radial.prototype={areaStart:function areaStart(){this._curve.areaStart();},areaEnd:function areaEnd(){this._curve.areaEnd();},lineStart:function lineStart(){this._curve.lineStart();},lineEnd:function lineEnd(){this._curve.lineEnd();},point:function point(a,r){this._curve.point(r*Math.sin(a),r*-Math.cos(a));}};function curveRadial(curve){function radial(context){return new Radial(curve(context));}radial._curve=curve;return radial;}function lineRadial(l){var c=l.curve;l.angle=l.x,delete l.x;l.radius=l.y,delete l.y;l.curve=function(_){return arguments.length?c(curveRadial(_)):c()._curve;};return l;}function lineRadial$1(){return lineRadial(line().curve(curveRadialLinear));}function areaRadial(){var a=area$3().curve(curveRadialLinear),c=a.curve,x0=a.lineX0,x1=a.lineX1,y0=a.lineY0,y1=a.lineY1;a.angle=a.x,delete a.x;a.startAngle=a.x0,delete a.x0;a.endAngle=a.x1,delete a.x1;a.radius=a.y,delete a.y;a.innerRadius=a.y0,delete a.y0;a.outerRadius=a.y1,delete a.y1;a.lineStartAngle=function(){return lineRadial(x0());},delete a.lineX0;a.lineEndAngle=function(){return lineRadial(x1());},delete a.lineX1;a.lineInnerRadius=function(){return lineRadial(y0());},delete a.lineY0;a.lineOuterRadius=function(){return lineRadial(y1());},delete a.lineY1;a.curve=function(_){return arguments.length?c(curveRadial(_)):c()._curve;};return a;}function pointRadial(x,y){return[(y=+y)*Math.cos(x-=Math.PI/2),y*Math.sin(x)];}var slice$6=Array.prototype.slice;function linkSource(d){return d.source;}function linkTarget(d){return d.target;}function link$2(curve){var source=linkSource,target=linkTarget,x$$1=x$3,y$$1=y$3,context=null;function link(){var buffer,argv=slice$6.call(arguments),s=source.apply(this,argv),t=target.apply(this,argv);if(!context)context=buffer=path();curve(context,+x$$1.apply(this,(argv[0]=s,argv)),+y$$1.apply(this,argv),+x$$1.apply(this,(argv[0]=t,argv)),+y$$1.apply(this,argv));if(buffer)return context=null,buffer+\"\"||null;}link.source=function(_){return arguments.length?(source=_,link):source;};link.target=function(_){return arguments.length?(target=_,link):target;};link.x=function(_){return arguments.length?(x$$1=typeof _===\"function\"?_:constant$11(+_),link):x$$1;};link.y=function(_){return arguments.length?(y$$1=typeof _===\"function\"?_:constant$11(+_),link):y$$1;};link.context=function(_){return arguments.length?(context=_==null?null:_,link):context;};return link;}function curveHorizontal(context,x0,y0,x1,y1){context.moveTo(x0,y0);context.bezierCurveTo(x0=(x0+x1)/2,y0,x0,y1,x1,y1);}function curveVertical(context,x0,y0,x1,y1){context.moveTo(x0,y0);context.bezierCurveTo(x0,y0=(y0+y1)/2,x1,y0,x1,y1);}function curveRadial$1(context,x0,y0,x1,y1){var p0=pointRadial(x0,y0),p1=pointRadial(x0,y0=(y0+y1)/2),p2=pointRadial(x1,y0),p3=pointRadial(x1,y1);context.moveTo(p0[0],p0[1]);context.bezierCurveTo(p1[0],p1[1],p2[0],p2[1],p3[0],p3[1]);}function linkHorizontal(){return link$2(curveHorizontal);}function linkVertical(){return link$2(curveVertical);}function linkRadial(){var l=link$2(curveRadial$1);l.angle=l.x,delete l.x;l.radius=l.y,delete l.y;return l;}var circle$2={draw:function draw(context,size){var r=Math.sqrt(size/pi$4);context.moveTo(r,0);context.arc(0,0,r,0,tau$4);}};var cross$2={draw:function draw(context,size){var r=Math.sqrt(size/5)/2;context.moveTo(-3*r,-r);context.lineTo(-r,-r);context.lineTo(-r,-3*r);context.lineTo(r,-3*r);context.lineTo(r,-r);context.lineTo(3*r,-r);context.lineTo(3*r,r);context.lineTo(r,r);context.lineTo(r,3*r);context.lineTo(-r,3*r);context.lineTo(-r,r);context.lineTo(-3*r,r);context.closePath();}};var tan30=Math.sqrt(1/3),tan30_2=tan30*2;var diamond={draw:function draw(context,size){var y=Math.sqrt(size/tan30_2),x=y*tan30;context.moveTo(0,-y);context.lineTo(x,0);context.lineTo(0,y);context.lineTo(-x,0);context.closePath();}};var ka=0.89081309152928522810,kr=Math.sin(pi$4/10)/Math.sin(7*pi$4/10),kx=Math.sin(tau$4/10)*kr,ky=-Math.cos(tau$4/10)*kr;var star={draw:function draw(context,size){var r=Math.sqrt(size*ka),x=kx*r,y=ky*r;context.moveTo(0,-r);context.lineTo(x,y);for(var i=1;i<5;++i){var a=tau$4*i/5,c=Math.cos(a),s=Math.sin(a);context.lineTo(s*r,-c*r);context.lineTo(c*x-s*y,s*x+c*y);}context.closePath();}};var square={draw:function draw(context,size){var w=Math.sqrt(size),x=-w/2;context.rect(x,x,w,w);}};var sqrt3=Math.sqrt(3);var triangle={draw:function draw(context,size){var y=-Math.sqrt(size/(sqrt3*3));context.moveTo(0,y*2);context.lineTo(-sqrt3*y,-y);context.lineTo(sqrt3*y,-y);context.closePath();}};var c$2=-0.5,s=Math.sqrt(3)/2,k=1/Math.sqrt(12),a=(k/2+1)*3;var wye={draw:function draw(context,size){var r=Math.sqrt(size/a),x0=r/2,y0=r*k,x1=x0,y1=r*k+r,x2=-x1,y2=y1;context.moveTo(x0,y0);context.lineTo(x1,y1);context.lineTo(x2,y2);context.lineTo(c$2*x0-s*y0,s*x0+c$2*y0);context.lineTo(c$2*x1-s*y1,s*x1+c$2*y1);context.lineTo(c$2*x2-s*y2,s*x2+c$2*y2);context.lineTo(c$2*x0+s*y0,c$2*y0-s*x0);context.lineTo(c$2*x1+s*y1,c$2*y1-s*x1);context.lineTo(c$2*x2+s*y2,c$2*y2-s*x2);context.closePath();}};var symbols=[circle$2,cross$2,diamond,square,star,triangle,wye];function symbol(){var type=constant$11(circle$2),size=constant$11(64),context=null;function symbol(){var buffer;if(!context)context=buffer=path();type.apply(this,arguments).draw(context,+size.apply(this,arguments));if(buffer)return context=null,buffer+\"\"||null;}symbol.type=function(_){return arguments.length?(type=typeof _===\"function\"?_:constant$11(_),symbol):type;};symbol.size=function(_){return arguments.length?(size=typeof _===\"function\"?_:constant$11(+_),symbol):size;};symbol.context=function(_){return arguments.length?(context=_==null?null:_,symbol):context;};return symbol;}function noop$3(){}function point$2(that,x,y){that._context.bezierCurveTo((2*that._x0+that._x1)/3,(2*that._y0+that._y1)/3,(that._x0+2*that._x1)/3,(that._y0+2*that._y1)/3,(that._x0+4*that._x1+x)/6,(that._y0+4*that._y1+y)/6);}function Basis(context){this._context=context;}Basis.prototype={areaStart:function areaStart(){this._line=0;},areaEnd:function areaEnd(){this._line=NaN;},lineStart:function lineStart(){this._x0=this._x1=this._y0=this._y1=NaN;this._point=0;},lineEnd:function lineEnd(){switch(this._point){case 3:point$2(this,this._x1,this._y1);// proceed\ncase 2:this._context.lineTo(this._x1,this._y1);break;}if(this._line||this._line!==0&&this._point===1)this._context.closePath();this._line=1-this._line;},point:function point(x,y){x=+x,y=+y;switch(this._point){case 0:this._point=1;this._line?this._context.lineTo(x,y):this._context.moveTo(x,y);break;case 1:this._point=2;break;case 2:this._point=3;this._context.lineTo((5*this._x0+this._x1)/6,(5*this._y0+this._y1)/6);// proceed\ndefault:point$2(this,x,y);break;}this._x0=this._x1,this._x1=x;this._y0=this._y1,this._y1=y;}};function basis$2(context){return new Basis(context);}function BasisClosed(context){this._context=context;}BasisClosed.prototype={areaStart:noop$3,areaEnd:noop$3,lineStart:function lineStart(){this._x0=this._x1=this._x2=this._x3=this._x4=this._y0=this._y1=this._y2=this._y3=this._y4=NaN;this._point=0;},lineEnd:function lineEnd(){switch(this._point){case 1:{this._context.moveTo(this._x2,this._y2);this._context.closePath();break;}case 2:{this._context.moveTo((this._x2+2*this._x3)/3,(this._y2+2*this._y3)/3);this._context.lineTo((this._x3+2*this._x2)/3,(this._y3+2*this._y2)/3);this._context.closePath();break;}case 3:{this.point(this._x2,this._y2);this.point(this._x3,this._y3);this.point(this._x4,this._y4);break;}}},point:function point(x,y){x=+x,y=+y;switch(this._point){case 0:this._point=1;this._x2=x,this._y2=y;break;case 1:this._point=2;this._x3=x,this._y3=y;break;case 2:this._point=3;this._x4=x,this._y4=y;this._context.moveTo((this._x0+4*this._x1+x)/6,(this._y0+4*this._y1+y)/6);break;default:point$2(this,x,y);break;}this._x0=this._x1,this._x1=x;this._y0=this._y1,this._y1=y;}};function basisClosed$1(context){return new BasisClosed(context);}function BasisOpen(context){this._context=context;}BasisOpen.prototype={areaStart:function areaStart(){this._line=0;},areaEnd:function areaEnd(){this._line=NaN;},lineStart:function lineStart(){this._x0=this._x1=this._y0=this._y1=NaN;this._point=0;},lineEnd:function lineEnd(){if(this._line||this._line!==0&&this._point===3)this._context.closePath();this._line=1-this._line;},point:function point(x,y){x=+x,y=+y;switch(this._point){case 0:this._point=1;break;case 1:this._point=2;break;case 2:this._point=3;var x0=(this._x0+4*this._x1+x)/6,y0=(this._y0+4*this._y1+y)/6;this._line?this._context.lineTo(x0,y0):this._context.moveTo(x0,y0);break;case 3:this._point=4;// proceed\ndefault:point$2(this,x,y);break;}this._x0=this._x1,this._x1=x;this._y0=this._y1,this._y1=y;}};function basisOpen(context){return new BasisOpen(context);}function Bundle(context,beta){this._basis=new Basis(context);this._beta=beta;}Bundle.prototype={lineStart:function lineStart(){this._x=[];this._y=[];this._basis.lineStart();},lineEnd:function lineEnd(){var x=this._x,y=this._y,j=x.length-1;if(j>0){var x0=x[0],y0=y[0],dx=x[j]-x0,dy=y[j]-y0,i=-1,t;while(++i<=j){t=i/j;this._basis.point(this._beta*x[i]+(1-this._beta)*(x0+t*dx),this._beta*y[i]+(1-this._beta)*(y0+t*dy));}}this._x=this._y=null;this._basis.lineEnd();},point:function point(x,y){this._x.push(+x);this._y.push(+y);}};var bundle=function custom(beta){function bundle(context){return beta===1?new Basis(context):new Bundle(context,beta);}bundle.beta=function(beta){return custom(+beta);};return bundle;}(0.85);function point$3(that,x,y){that._context.bezierCurveTo(that._x1+that._k*(that._x2-that._x0),that._y1+that._k*(that._y2-that._y0),that._x2+that._k*(that._x1-x),that._y2+that._k*(that._y1-y),that._x2,that._y2);}function Cardinal(context,tension){this._context=context;this._k=(1-tension)/6;}Cardinal.prototype={areaStart:function areaStart(){this._line=0;},areaEnd:function areaEnd(){this._line=NaN;},lineStart:function lineStart(){this._x0=this._x1=this._x2=this._y0=this._y1=this._y2=NaN;this._point=0;},lineEnd:function lineEnd(){switch(this._point){case 2:this._context.lineTo(this._x2,this._y2);break;case 3:point$3(this,this._x1,this._y1);break;}if(this._line||this._line!==0&&this._point===1)this._context.closePath();this._line=1-this._line;},point:function point(x,y){x=+x,y=+y;switch(this._point){case 0:this._point=1;this._line?this._context.lineTo(x,y):this._context.moveTo(x,y);break;case 1:this._point=2;this._x1=x,this._y1=y;break;case 2:this._point=3;// proceed\ndefault:point$3(this,x,y);break;}this._x0=this._x1,this._x1=this._x2,this._x2=x;this._y0=this._y1,this._y1=this._y2,this._y2=y;}};var cardinal=function custom(tension){function cardinal(context){return new Cardinal(context,tension);}cardinal.tension=function(tension){return custom(+tension);};return cardinal;}(0);function CardinalClosed(context,tension){this._context=context;this._k=(1-tension)/6;}CardinalClosed.prototype={areaStart:noop$3,areaEnd:noop$3,lineStart:function lineStart(){this._x0=this._x1=this._x2=this._x3=this._x4=this._x5=this._y0=this._y1=this._y2=this._y3=this._y4=this._y5=NaN;this._point=0;},lineEnd:function lineEnd(){switch(this._point){case 1:{this._context.moveTo(this._x3,this._y3);this._context.closePath();break;}case 2:{this._context.lineTo(this._x3,this._y3);this._context.closePath();break;}case 3:{this.point(this._x3,this._y3);this.point(this._x4,this._y4);this.point(this._x5,this._y5);break;}}},point:function point(x,y){x=+x,y=+y;switch(this._point){case 0:this._point=1;this._x3=x,this._y3=y;break;case 1:this._point=2;this._context.moveTo(this._x4=x,this._y4=y);break;case 2:this._point=3;this._x5=x,this._y5=y;break;default:point$3(this,x,y);break;}this._x0=this._x1,this._x1=this._x2,this._x2=x;this._y0=this._y1,this._y1=this._y2,this._y2=y;}};var cardinalClosed=function custom(tension){function cardinal$$1(context){return new CardinalClosed(context,tension);}cardinal$$1.tension=function(tension){return custom(+tension);};return cardinal$$1;}(0);function CardinalOpen(context,tension){this._context=context;this._k=(1-tension)/6;}CardinalOpen.prototype={areaStart:function areaStart(){this._line=0;},areaEnd:function areaEnd(){this._line=NaN;},lineStart:function lineStart(){this._x0=this._x1=this._x2=this._y0=this._y1=this._y2=NaN;this._point=0;},lineEnd:function lineEnd(){if(this._line||this._line!==0&&this._point===3)this._context.closePath();this._line=1-this._line;},point:function point(x,y){x=+x,y=+y;switch(this._point){case 0:this._point=1;break;case 1:this._point=2;break;case 2:this._point=3;this._line?this._context.lineTo(this._x2,this._y2):this._context.moveTo(this._x2,this._y2);break;case 3:this._point=4;// proceed\ndefault:point$3(this,x,y);break;}this._x0=this._x1,this._x1=this._x2,this._x2=x;this._y0=this._y1,this._y1=this._y2,this._y2=y;}};var cardinalOpen=function custom(tension){function cardinal$$1(context){return new CardinalOpen(context,tension);}cardinal$$1.tension=function(tension){return custom(+tension);};return cardinal$$1;}(0);function point$4(that,x,y){var x1=that._x1,y1=that._y1,x2=that._x2,y2=that._y2;if(that._l01_a>epsilon$3){var a=2*that._l01_2a+3*that._l01_a*that._l12_a+that._l12_2a,n=3*that._l01_a*(that._l01_a+that._l12_a);x1=(x1*a-that._x0*that._l12_2a+that._x2*that._l01_2a)/n;y1=(y1*a-that._y0*that._l12_2a+that._y2*that._l01_2a)/n;}if(that._l23_a>epsilon$3){var b=2*that._l23_2a+3*that._l23_a*that._l12_a+that._l12_2a,m=3*that._l23_a*(that._l23_a+that._l12_a);x2=(x2*b+that._x1*that._l23_2a-x*that._l12_2a)/m;y2=(y2*b+that._y1*that._l23_2a-y*that._l12_2a)/m;}that._context.bezierCurveTo(x1,y1,x2,y2,that._x2,that._y2);}function CatmullRom(context,alpha){this._context=context;this._alpha=alpha;}CatmullRom.prototype={areaStart:function areaStart(){this._line=0;},areaEnd:function areaEnd(){this._line=NaN;},lineStart:function lineStart(){this._x0=this._x1=this._x2=this._y0=this._y1=this._y2=NaN;this._l01_a=this._l12_a=this._l23_a=this._l01_2a=this._l12_2a=this._l23_2a=this._point=0;},lineEnd:function lineEnd(){switch(this._point){case 2:this._context.lineTo(this._x2,this._y2);break;case 3:this.point(this._x2,this._y2);break;}if(this._line||this._line!==0&&this._point===1)this._context.closePath();this._line=1-this._line;},point:function point(x,y){x=+x,y=+y;if(this._point){var x23=this._x2-x,y23=this._y2-y;this._l23_a=Math.sqrt(this._l23_2a=Math.pow(x23*x23+y23*y23,this._alpha));}switch(this._point){case 0:this._point=1;this._line?this._context.lineTo(x,y):this._context.moveTo(x,y);break;case 1:this._point=2;break;case 2:this._point=3;// proceed\ndefault:point$4(this,x,y);break;}this._l01_a=this._l12_a,this._l12_a=this._l23_a;this._l01_2a=this._l12_2a,this._l12_2a=this._l23_2a;this._x0=this._x1,this._x1=this._x2,this._x2=x;this._y0=this._y1,this._y1=this._y2,this._y2=y;}};var catmullRom=function custom(alpha){function catmullRom(context){return alpha?new CatmullRom(context,alpha):new Cardinal(context,0);}catmullRom.alpha=function(alpha){return custom(+alpha);};return catmullRom;}(0.5);function CatmullRomClosed(context,alpha){this._context=context;this._alpha=alpha;}CatmullRomClosed.prototype={areaStart:noop$3,areaEnd:noop$3,lineStart:function lineStart(){this._x0=this._x1=this._x2=this._x3=this._x4=this._x5=this._y0=this._y1=this._y2=this._y3=this._y4=this._y5=NaN;this._l01_a=this._l12_a=this._l23_a=this._l01_2a=this._l12_2a=this._l23_2a=this._point=0;},lineEnd:function lineEnd(){switch(this._point){case 1:{this._context.moveTo(this._x3,this._y3);this._context.closePath();break;}case 2:{this._context.lineTo(this._x3,this._y3);this._context.closePath();break;}case 3:{this.point(this._x3,this._y3);this.point(this._x4,this._y4);this.point(this._x5,this._y5);break;}}},point:function point(x,y){x=+x,y=+y;if(this._point){var x23=this._x2-x,y23=this._y2-y;this._l23_a=Math.sqrt(this._l23_2a=Math.pow(x23*x23+y23*y23,this._alpha));}switch(this._point){case 0:this._point=1;this._x3=x,this._y3=y;break;case 1:this._point=2;this._context.moveTo(this._x4=x,this._y4=y);break;case 2:this._point=3;this._x5=x,this._y5=y;break;default:point$4(this,x,y);break;}this._l01_a=this._l12_a,this._l12_a=this._l23_a;this._l01_2a=this._l12_2a,this._l12_2a=this._l23_2a;this._x0=this._x1,this._x1=this._x2,this._x2=x;this._y0=this._y1,this._y1=this._y2,this._y2=y;}};var catmullRomClosed=function custom(alpha){function catmullRom$$1(context){return alpha?new CatmullRomClosed(context,alpha):new CardinalClosed(context,0);}catmullRom$$1.alpha=function(alpha){return custom(+alpha);};return catmullRom$$1;}(0.5);function CatmullRomOpen(context,alpha){this._context=context;this._alpha=alpha;}CatmullRomOpen.prototype={areaStart:function areaStart(){this._line=0;},areaEnd:function areaEnd(){this._line=NaN;},lineStart:function lineStart(){this._x0=this._x1=this._x2=this._y0=this._y1=this._y2=NaN;this._l01_a=this._l12_a=this._l23_a=this._l01_2a=this._l12_2a=this._l23_2a=this._point=0;},lineEnd:function lineEnd(){if(this._line||this._line!==0&&this._point===3)this._context.closePath();this._line=1-this._line;},point:function point(x,y){x=+x,y=+y;if(this._point){var x23=this._x2-x,y23=this._y2-y;this._l23_a=Math.sqrt(this._l23_2a=Math.pow(x23*x23+y23*y23,this._alpha));}switch(this._point){case 0:this._point=1;break;case 1:this._point=2;break;case 2:this._point=3;this._line?this._context.lineTo(this._x2,this._y2):this._context.moveTo(this._x2,this._y2);break;case 3:this._point=4;// proceed\ndefault:point$4(this,x,y);break;}this._l01_a=this._l12_a,this._l12_a=this._l23_a;this._l01_2a=this._l12_2a,this._l12_2a=this._l23_2a;this._x0=this._x1,this._x1=this._x2,this._x2=x;this._y0=this._y1,this._y1=this._y2,this._y2=y;}};var catmullRomOpen=function custom(alpha){function catmullRom$$1(context){return alpha?new CatmullRomOpen(context,alpha):new CardinalOpen(context,0);}catmullRom$$1.alpha=function(alpha){return custom(+alpha);};return catmullRom$$1;}(0.5);function LinearClosed(context){this._context=context;}LinearClosed.prototype={areaStart:noop$3,areaEnd:noop$3,lineStart:function lineStart(){this._point=0;},lineEnd:function lineEnd(){if(this._point)this._context.closePath();},point:function point(x,y){x=+x,y=+y;if(this._point)this._context.lineTo(x,y);else this._point=1,this._context.moveTo(x,y);}};function linearClosed(context){return new LinearClosed(context);}function sign$1(x){return x<0?-1:1;}// Calculate the slopes of the tangents (Hermite-type interpolation) based on\n// the following paper: Steffen, M. 1990. A Simple Method for Monotonic\n// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.\n// NOV(II), P. 443, 1990.\nfunction slope3(that,x2,y2){var h0=that._x1-that._x0,h1=x2-that._x1,s0=(that._y1-that._y0)/(h0||h1<0&&-0),s1=(y2-that._y1)/(h1||h0<0&&-0),p=(s0*h1+s1*h0)/(h0+h1);return(sign$1(s0)+sign$1(s1))*Math.min(Math.abs(s0),Math.abs(s1),0.5*Math.abs(p))||0;}// Calculate a one-sided slope.\nfunction slope2(that,t){var h=that._x1-that._x0;return h?(3*(that._y1-that._y0)/h-t)/2:t;}// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations\n// \"you can express cubic Hermite interpolation in terms of cubic Bézier curves\n// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1\".\nfunction point$5(that,t0,t1){var x0=that._x0,y0=that._y0,x1=that._x1,y1=that._y1,dx=(x1-x0)/3;that._context.bezierCurveTo(x0+dx,y0+dx*t0,x1-dx,y1-dx*t1,x1,y1);}function MonotoneX(context){this._context=context;}MonotoneX.prototype={areaStart:function areaStart(){this._line=0;},areaEnd:function areaEnd(){this._line=NaN;},lineStart:function lineStart(){this._x0=this._x1=this._y0=this._y1=this._t0=NaN;this._point=0;},lineEnd:function lineEnd(){switch(this._point){case 2:this._context.lineTo(this._x1,this._y1);break;case 3:point$5(this,this._t0,slope2(this,this._t0));break;}if(this._line||this._line!==0&&this._point===1)this._context.closePath();this._line=1-this._line;},point:function point(x,y){var t1=NaN;x=+x,y=+y;if(x===this._x1&&y===this._y1)return;// Ignore coincident points.\nswitch(this._point){case 0:this._point=1;this._line?this._context.lineTo(x,y):this._context.moveTo(x,y);break;case 1:this._point=2;break;case 2:this._point=3;point$5(this,slope2(this,t1=slope3(this,x,y)),t1);break;default:point$5(this,this._t0,t1=slope3(this,x,y));break;}this._x0=this._x1,this._x1=x;this._y0=this._y1,this._y1=y;this._t0=t1;}};function MonotoneY(context){this._context=new ReflectContext(context);}(MonotoneY.prototype=Object.create(MonotoneX.prototype)).point=function(x,y){MonotoneX.prototype.point.call(this,y,x);};function ReflectContext(context){this._context=context;}ReflectContext.prototype={moveTo:function moveTo(x,y){this._context.moveTo(y,x);},closePath:function closePath(){this._context.closePath();},lineTo:function lineTo(x,y){this._context.lineTo(y,x);},bezierCurveTo:function bezierCurveTo(x1,y1,x2,y2,x,y){this._context.bezierCurveTo(y1,x1,y2,x2,y,x);}};function monotoneX(context){return new MonotoneX(context);}function monotoneY(context){return new MonotoneY(context);}function Natural(context){this._context=context;}Natural.prototype={areaStart:function areaStart(){this._line=0;},areaEnd:function areaEnd(){this._line=NaN;},lineStart:function lineStart(){this._x=[];this._y=[];},lineEnd:function lineEnd(){var x=this._x,y=this._y,n=x.length;if(n){this._line?this._context.lineTo(x[0],y[0]):this._context.moveTo(x[0],y[0]);if(n===2){this._context.lineTo(x[1],y[1]);}else{var px=controlPoints(x),py=controlPoints(y);for(var i0=0,i1=1;i1<n;++i0,++i1){this._context.bezierCurveTo(px[0][i0],py[0][i0],px[1][i0],py[1][i0],x[i1],y[i1]);}}}if(this._line||this._line!==0&&n===1)this._context.closePath();this._line=1-this._line;this._x=this._y=null;},point:function point(x,y){this._x.push(+x);this._y.push(+y);}};// See https://www.particleincell.com/2012/bezier-splines/ for derivation.\nfunction controlPoints(x){var i,n=x.length-1,m,a=new Array(n),b=new Array(n),r=new Array(n);a[0]=0,b[0]=2,r[0]=x[0]+2*x[1];for(i=1;i<n-1;++i){a[i]=1,b[i]=4,r[i]=4*x[i]+2*x[i+1];}a[n-1]=2,b[n-1]=7,r[n-1]=8*x[n-1]+x[n];for(i=1;i<n;++i){m=a[i]/b[i-1],b[i]-=m,r[i]-=m*r[i-1];}a[n-1]=r[n-1]/b[n-1];for(i=n-2;i>=0;--i){a[i]=(r[i]-a[i+1])/b[i];}b[n-1]=(x[n]+a[n-1])/2;for(i=0;i<n-1;++i){b[i]=2*x[i+1]-a[i+1];}return[a,b];}function natural(context){return new Natural(context);}function Step(context,t){this._context=context;this._t=t;}Step.prototype={areaStart:function areaStart(){this._line=0;},areaEnd:function areaEnd(){this._line=NaN;},lineStart:function lineStart(){this._x=this._y=NaN;this._point=0;},lineEnd:function lineEnd(){if(0<this._t&&this._t<1&&this._point===2)this._context.lineTo(this._x,this._y);if(this._line||this._line!==0&&this._point===1)this._context.closePath();if(this._line>=0)this._t=1-this._t,this._line=1-this._line;},point:function point(x,y){x=+x,y=+y;switch(this._point){case 0:this._point=1;this._line?this._context.lineTo(x,y):this._context.moveTo(x,y);break;case 1:this._point=2;// proceed\ndefault:{if(this._t<=0){this._context.lineTo(this._x,y);this._context.lineTo(x,y);}else{var x1=this._x*(1-this._t)+x*this._t;this._context.lineTo(x1,this._y);this._context.lineTo(x1,y);}break;}}this._x=x,this._y=y;}};function step(context){return new Step(context,0.5);}function stepBefore(context){return new Step(context,0);}function stepAfter(context){return new Step(context,1);}function none$1(series,order){if(!((n=series.length)>1))return;for(var i=1,j,s0,s1=series[order[0]],n,m=s1.length;i<n;++i){s0=s1,s1=series[order[i]];for(j=0;j<m;++j){s1[j][1]+=s1[j][0]=isNaN(s0[j][1])?s0[j][0]:s0[j][1];}}}function none$2(series){var n=series.length,o=new Array(n);while(--n>=0){o[n]=n;}return o;}function stackValue(d,key){return d[key];}function stack(){var keys=constant$11([]),order=none$2,offset=none$1,value=stackValue;function stack(data){var kz=keys.apply(this,arguments),i,m=data.length,n=kz.length,sz=new Array(n),oz;for(i=0;i<n;++i){for(var ki=kz[i],si=sz[i]=new Array(m),j=0,sij;j<m;++j){si[j]=sij=[0,+value(data[j],ki,j,data)];sij.data=data[j];}si.key=ki;}for(i=0,oz=order(sz);i<n;++i){sz[oz[i]].index=i;}offset(sz,oz);return sz;}stack.keys=function(_){return arguments.length?(keys=typeof _===\"function\"?_:constant$11(slice$6.call(_)),stack):keys;};stack.value=function(_){return arguments.length?(value=typeof _===\"function\"?_:constant$11(+_),stack):value;};stack.order=function(_){return arguments.length?(order=_==null?none$2:typeof _===\"function\"?_:constant$11(slice$6.call(_)),stack):order;};stack.offset=function(_){return arguments.length?(offset=_==null?none$1:_,stack):offset;};return stack;}function expand(series,order){if(!((n=series.length)>0))return;for(var i,n,j=0,m=series[0].length,y;j<m;++j){for(y=i=0;i<n;++i){y+=series[i][j][1]||0;}if(y)for(i=0;i<n;++i){series[i][j][1]/=y;}}none$1(series,order);}function diverging(series,order){if(!((n=series.length)>1))return;for(var i,j=0,d,dy,yp,yn,n,m=series[order[0]].length;j<m;++j){for(yp=yn=0,i=0;i<n;++i){if((dy=(d=series[order[i]][j])[1]-d[0])>=0){d[0]=yp,d[1]=yp+=dy;}else if(dy<0){d[1]=yn,d[0]=yn+=dy;}else{d[0]=yp;}}}}function silhouette(series,order){if(!((n=series.length)>0))return;for(var j=0,s0=series[order[0]],n,m=s0.length;j<m;++j){for(var i=0,y=0;i<n;++i){y+=series[i][j][1]||0;}s0[j][1]+=s0[j][0]=-y/2;}none$1(series,order);}function wiggle(series,order){if(!((n=series.length)>0)||!((m=(s0=series[order[0]]).length)>0))return;for(var y=0,j=1,s0,m,n;j<m;++j){for(var i=0,s1=0,s2=0;i<n;++i){var si=series[order[i]],sij0=si[j][1]||0,sij1=si[j-1][1]||0,s3=(sij0-sij1)/2;for(var k=0;k<i;++k){var sk=series[order[k]],skj0=sk[j][1]||0,skj1=sk[j-1][1]||0;s3+=skj0-skj1;}s1+=sij0,s2+=s3*sij0;}s0[j-1][1]+=s0[j-1][0]=y;if(s1)y-=s2/s1;}s0[j-1][1]+=s0[j-1][0]=y;none$1(series,order);}function ascending$3(series){var sums=series.map(sum$2);return none$2(series).sort(function(a,b){return sums[a]-sums[b];});}function sum$2(series){var s=0,i=-1,n=series.length,v;while(++i<n){if(v=+series[i][1])s+=v;}return s;}function descending$2(series){return ascending$3(series).reverse();}function insideOut(series){var n=series.length,i,j,sums=series.map(sum$2),order=none$2(series).sort(function(a,b){return sums[b]-sums[a];}),top=0,bottom=0,tops=[],bottoms=[];for(i=0;i<n;++i){j=order[i];if(top<bottom){top+=sums[j];tops.push(j);}else{bottom+=sums[j];bottoms.push(j);}}return bottoms.reverse().concat(tops);}function reverse(series){return none$2(series).reverse();}function constant$12(x){return function(){return x;};}function x$4(d){return d[0];}function y$4(d){return d[1];}function RedBlackTree(){this._=null;// root node\n}function RedBlackNode(node){node.U=// parent node\nnode.C=// color - true for red, false for black\nnode.L=// left node\nnode.R=// right node\nnode.P=// previous node\nnode.N=null;// next node\n}RedBlackTree.prototype={constructor:RedBlackTree,insert:function insert(after,node){var parent,grandpa,uncle;if(after){node.P=after;node.N=after.N;if(after.N)after.N.P=node;after.N=node;if(after.R){after=after.R;while(after.L){after=after.L;}after.L=node;}else{after.R=node;}parent=after;}else if(this._){after=RedBlackFirst(this._);node.P=null;node.N=after;after.P=after.L=node;parent=after;}else{node.P=node.N=null;this._=node;parent=null;}node.L=node.R=null;node.U=parent;node.C=true;after=node;while(parent&&parent.C){grandpa=parent.U;if(parent===grandpa.L){uncle=grandpa.R;if(uncle&&uncle.C){parent.C=uncle.C=false;grandpa.C=true;after=grandpa;}else{if(after===parent.R){RedBlackRotateLeft(this,parent);after=parent;parent=after.U;}parent.C=false;grandpa.C=true;RedBlackRotateRight(this,grandpa);}}else{uncle=grandpa.L;if(uncle&&uncle.C){parent.C=uncle.C=false;grandpa.C=true;after=grandpa;}else{if(after===parent.L){RedBlackRotateRight(this,parent);after=parent;parent=after.U;}parent.C=false;grandpa.C=true;RedBlackRotateLeft(this,grandpa);}}parent=after.U;}this._.C=false;},remove:function remove(node){if(node.N)node.N.P=node.P;if(node.P)node.P.N=node.N;node.N=node.P=null;var parent=node.U,sibling,left=node.L,right=node.R,next,red;if(!left)next=right;else if(!right)next=left;else next=RedBlackFirst(right);if(parent){if(parent.L===node)parent.L=next;else parent.R=next;}else{this._=next;}if(left&&right){red=next.C;next.C=node.C;next.L=left;left.U=next;if(next!==right){parent=next.U;next.U=node.U;node=next.R;parent.L=node;next.R=right;right.U=next;}else{next.U=parent;parent=next;node=next.R;}}else{red=node.C;node=next;}if(node)node.U=parent;if(red)return;if(node&&node.C){node.C=false;return;}do{if(node===this._)break;if(node===parent.L){sibling=parent.R;if(sibling.C){sibling.C=false;parent.C=true;RedBlackRotateLeft(this,parent);sibling=parent.R;}if(sibling.L&&sibling.L.C||sibling.R&&sibling.R.C){if(!sibling.R||!sibling.R.C){sibling.L.C=false;sibling.C=true;RedBlackRotateRight(this,sibling);sibling=parent.R;}sibling.C=parent.C;parent.C=sibling.R.C=false;RedBlackRotateLeft(this,parent);node=this._;break;}}else{sibling=parent.L;if(sibling.C){sibling.C=false;parent.C=true;RedBlackRotateRight(this,parent);sibling=parent.L;}if(sibling.L&&sibling.L.C||sibling.R&&sibling.R.C){if(!sibling.L||!sibling.L.C){sibling.R.C=false;sibling.C=true;RedBlackRotateLeft(this,sibling);sibling=parent.L;}sibling.C=parent.C;parent.C=sibling.L.C=false;RedBlackRotateRight(this,parent);node=this._;break;}}sibling.C=true;node=parent;parent=parent.U;}while(!node.C);if(node)node.C=false;}};function RedBlackRotateLeft(tree,node){var p=node,q=node.R,parent=p.U;if(parent){if(parent.L===p)parent.L=q;else parent.R=q;}else{tree._=q;}q.U=parent;p.U=q;p.R=q.L;if(p.R)p.R.U=p;q.L=p;}function RedBlackRotateRight(tree,node){var p=node,q=node.L,parent=p.U;if(parent){if(parent.L===p)parent.L=q;else parent.R=q;}else{tree._=q;}q.U=parent;p.U=q;p.L=q.R;if(p.L)p.L.U=p;q.R=p;}function RedBlackFirst(node){while(node.L){node=node.L;}return node;}function createEdge(left,right,v0,v1){var edge=[null,null],index=edges.push(edge)-1;edge.left=left;edge.right=right;if(v0)setEdgeEnd(edge,left,right,v0);if(v1)setEdgeEnd(edge,right,left,v1);cells[left.index].halfedges.push(index);cells[right.index].halfedges.push(index);return edge;}function createBorderEdge(left,v0,v1){var edge=[v0,v1];edge.left=left;return edge;}function setEdgeEnd(edge,left,right,vertex){if(!edge[0]&&!edge[1]){edge[0]=vertex;edge.left=left;edge.right=right;}else if(edge.left===right){edge[1]=vertex;}else{edge[0]=vertex;}}// Liang–Barsky line clipping.\nfunction clipEdge(edge,x0,y0,x1,y1){var a=edge[0],b=edge[1],ax=a[0],ay=a[1],bx=b[0],by=b[1],t0=0,t1=1,dx=bx-ax,dy=by-ay,r;r=x0-ax;if(!dx&&r>0)return;r/=dx;if(dx<0){if(r<t0)return;if(r<t1)t1=r;}else if(dx>0){if(r>t1)return;if(r>t0)t0=r;}r=x1-ax;if(!dx&&r<0)return;r/=dx;if(dx<0){if(r>t1)return;if(r>t0)t0=r;}else if(dx>0){if(r<t0)return;if(r<t1)t1=r;}r=y0-ay;if(!dy&&r>0)return;r/=dy;if(dy<0){if(r<t0)return;if(r<t1)t1=r;}else if(dy>0){if(r>t1)return;if(r>t0)t0=r;}r=y1-ay;if(!dy&&r<0)return;r/=dy;if(dy<0){if(r>t1)return;if(r>t0)t0=r;}else if(dy>0){if(r<t0)return;if(r<t1)t1=r;}if(!(t0>0)&&!(t1<1))return true;// TODO Better check?\nif(t0>0)edge[0]=[ax+t0*dx,ay+t0*dy];if(t1<1)edge[1]=[ax+t1*dx,ay+t1*dy];return true;}function connectEdge(edge,x0,y0,x1,y1){var v1=edge[1];if(v1)return true;var v0=edge[0],left=edge.left,right=edge.right,lx=left[0],ly=left[1],rx=right[0],ry=right[1],fx=(lx+rx)/2,fy=(ly+ry)/2,fm,fb;if(ry===ly){if(fx<x0||fx>=x1)return;if(lx>rx){if(!v0)v0=[fx,y0];else if(v0[1]>=y1)return;v1=[fx,y1];}else{if(!v0)v0=[fx,y1];else if(v0[1]<y0)return;v1=[fx,y0];}}else{fm=(lx-rx)/(ry-ly);fb=fy-fm*fx;if(fm<-1||fm>1){if(lx>rx){if(!v0)v0=[(y0-fb)/fm,y0];else if(v0[1]>=y1)return;v1=[(y1-fb)/fm,y1];}else{if(!v0)v0=[(y1-fb)/fm,y1];else if(v0[1]<y0)return;v1=[(y0-fb)/fm,y0];}}else{if(ly<ry){if(!v0)v0=[x0,fm*x0+fb];else if(v0[0]>=x1)return;v1=[x1,fm*x1+fb];}else{if(!v0)v0=[x1,fm*x1+fb];else if(v0[0]<x0)return;v1=[x0,fm*x0+fb];}}}edge[0]=v0;edge[1]=v1;return true;}function clipEdges(x0,y0,x1,y1){var i=edges.length,edge;while(i--){if(!connectEdge(edge=edges[i],x0,y0,x1,y1)||!clipEdge(edge,x0,y0,x1,y1)||!(Math.abs(edge[0][0]-edge[1][0])>epsilon$4||Math.abs(edge[0][1]-edge[1][1])>epsilon$4)){delete edges[i];}}}function createCell(site){return cells[site.index]={site:site,halfedges:[]};}function cellHalfedgeAngle(cell,edge){var site=cell.site,va=edge.left,vb=edge.right;if(site===vb)vb=va,va=site;if(vb)return Math.atan2(vb[1]-va[1],vb[0]-va[0]);if(site===va)va=edge[1],vb=edge[0];else va=edge[0],vb=edge[1];return Math.atan2(va[0]-vb[0],vb[1]-va[1]);}function cellHalfedgeStart(cell,edge){return edge[+(edge.left!==cell.site)];}function cellHalfedgeEnd(cell,edge){return edge[+(edge.left===cell.site)];}function sortCellHalfedges(){for(var i=0,n=cells.length,cell,halfedges,j,m;i<n;++i){if((cell=cells[i])&&(m=(halfedges=cell.halfedges).length)){var index=new Array(m),array=new Array(m);for(j=0;j<m;++j){index[j]=j,array[j]=cellHalfedgeAngle(cell,edges[halfedges[j]]);}index.sort(function(i,j){return array[j]-array[i];});for(j=0;j<m;++j){array[j]=halfedges[index[j]];}for(j=0;j<m;++j){halfedges[j]=array[j];}}}}function clipCells(x0,y0,x1,y1){var nCells=cells.length,iCell,cell,site,iHalfedge,halfedges,nHalfedges,start,startX,startY,end,endX,endY,cover=true;for(iCell=0;iCell<nCells;++iCell){if(cell=cells[iCell]){site=cell.site;halfedges=cell.halfedges;iHalfedge=halfedges.length;// Remove any dangling clipped edges.\nwhile(iHalfedge--){if(!edges[halfedges[iHalfedge]]){halfedges.splice(iHalfedge,1);}}// Insert any border edges as necessary.\niHalfedge=0,nHalfedges=halfedges.length;while(iHalfedge<nHalfedges){end=cellHalfedgeEnd(cell,edges[halfedges[iHalfedge]]),endX=end[0],endY=end[1];start=cellHalfedgeStart(cell,edges[halfedges[++iHalfedge%nHalfedges]]),startX=start[0],startY=start[1];if(Math.abs(endX-startX)>epsilon$4||Math.abs(endY-startY)>epsilon$4){halfedges.splice(iHalfedge,0,edges.push(createBorderEdge(site,end,Math.abs(endX-x0)<epsilon$4&&y1-endY>epsilon$4?[x0,Math.abs(startX-x0)<epsilon$4?startY:y1]:Math.abs(endY-y1)<epsilon$4&&x1-endX>epsilon$4?[Math.abs(startY-y1)<epsilon$4?startX:x1,y1]:Math.abs(endX-x1)<epsilon$4&&endY-y0>epsilon$4?[x1,Math.abs(startX-x1)<epsilon$4?startY:y0]:Math.abs(endY-y0)<epsilon$4&&endX-x0>epsilon$4?[Math.abs(startY-y0)<epsilon$4?startX:x0,y0]:null))-1);++nHalfedges;}}if(nHalfedges)cover=false;}}// If there weren’t any edges, have the closest site cover the extent.\n// It doesn’t matter which corner of the extent we measure!\nif(cover){var dx,dy,d2,dc=Infinity;for(iCell=0,cover=null;iCell<nCells;++iCell){if(cell=cells[iCell]){site=cell.site;dx=site[0]-x0;dy=site[1]-y0;d2=dx*dx+dy*dy;if(d2<dc)dc=d2,cover=cell;}}if(cover){var v00=[x0,y0],v01=[x0,y1],v11=[x1,y1],v10=[x1,y0];cover.halfedges.push(edges.push(createBorderEdge(site=cover.site,v00,v01))-1,edges.push(createBorderEdge(site,v01,v11))-1,edges.push(createBorderEdge(site,v11,v10))-1,edges.push(createBorderEdge(site,v10,v00))-1);}}// Lastly delete any cells with no edges; these were entirely clipped.\nfor(iCell=0;iCell<nCells;++iCell){if(cell=cells[iCell]){if(!cell.halfedges.length){delete cells[iCell];}}}}var circlePool=[];var firstCircle;function Circle(){RedBlackNode(this);this.x=this.y=this.arc=this.site=this.cy=null;}function attachCircle(arc){var lArc=arc.P,rArc=arc.N;if(!lArc||!rArc)return;var lSite=lArc.site,cSite=arc.site,rSite=rArc.site;if(lSite===rSite)return;var bx=cSite[0],by=cSite[1],ax=lSite[0]-bx,ay=lSite[1]-by,cx=rSite[0]-bx,cy=rSite[1]-by;var d=2*(ax*cy-ay*cx);if(d>=-epsilon2$2)return;var ha=ax*ax+ay*ay,hc=cx*cx+cy*cy,x=(cy*ha-ay*hc)/d,y=(ax*hc-cx*ha)/d;var circle=circlePool.pop()||new Circle();circle.arc=arc;circle.site=cSite;circle.x=x+bx;circle.y=(circle.cy=y+by)+Math.sqrt(x*x+y*y);// y bottom\narc.circle=circle;var before=null,node=circles._;while(node){if(circle.y<node.y||circle.y===node.y&&circle.x<=node.x){if(node.L)node=node.L;else{before=node.P;break;}}else{if(node.R)node=node.R;else{before=node;break;}}}circles.insert(before,circle);if(!before)firstCircle=circle;}function detachCircle(arc){var circle=arc.circle;if(circle){if(!circle.P)firstCircle=circle.N;circles.remove(circle);circlePool.push(circle);RedBlackNode(circle);arc.circle=null;}}var beachPool=[];function Beach(){RedBlackNode(this);this.edge=this.site=this.circle=null;}function createBeach(site){var beach=beachPool.pop()||new Beach();beach.site=site;return beach;}function detachBeach(beach){detachCircle(beach);beaches.remove(beach);beachPool.push(beach);RedBlackNode(beach);}function removeBeach(beach){var circle=beach.circle,x=circle.x,y=circle.cy,vertex=[x,y],previous=beach.P,next=beach.N,disappearing=[beach];detachBeach(beach);var lArc=previous;while(lArc.circle&&Math.abs(x-lArc.circle.x)<epsilon$4&&Math.abs(y-lArc.circle.cy)<epsilon$4){previous=lArc.P;disappearing.unshift(lArc);detachBeach(lArc);lArc=previous;}disappearing.unshift(lArc);detachCircle(lArc);var rArc=next;while(rArc.circle&&Math.abs(x-rArc.circle.x)<epsilon$4&&Math.abs(y-rArc.circle.cy)<epsilon$4){next=rArc.N;disappearing.push(rArc);detachBeach(rArc);rArc=next;}disappearing.push(rArc);detachCircle(rArc);var nArcs=disappearing.length,iArc;for(iArc=1;iArc<nArcs;++iArc){rArc=disappearing[iArc];lArc=disappearing[iArc-1];setEdgeEnd(rArc.edge,lArc.site,rArc.site,vertex);}lArc=disappearing[0];rArc=disappearing[nArcs-1];rArc.edge=createEdge(lArc.site,rArc.site,null,vertex);attachCircle(lArc);attachCircle(rArc);}function addBeach(site){var x=site[0],directrix=site[1],lArc,rArc,dxl,dxr,node=beaches._;while(node){dxl=leftBreakPoint(node,directrix)-x;if(dxl>epsilon$4)node=node.L;else{dxr=x-rightBreakPoint(node,directrix);if(dxr>epsilon$4){if(!node.R){lArc=node;break;}node=node.R;}else{if(dxl>-epsilon$4){lArc=node.P;rArc=node;}else if(dxr>-epsilon$4){lArc=node;rArc=node.N;}else{lArc=rArc=node;}break;}}}createCell(site);var newArc=createBeach(site);beaches.insert(lArc,newArc);if(!lArc&&!rArc)return;if(lArc===rArc){detachCircle(lArc);rArc=createBeach(lArc.site);beaches.insert(newArc,rArc);newArc.edge=rArc.edge=createEdge(lArc.site,newArc.site);attachCircle(lArc);attachCircle(rArc);return;}if(!rArc){// && lArc\nnewArc.edge=createEdge(lArc.site,newArc.site);return;}// else lArc !== rArc\ndetachCircle(lArc);detachCircle(rArc);var lSite=lArc.site,ax=lSite[0],ay=lSite[1],bx=site[0]-ax,by=site[1]-ay,rSite=rArc.site,cx=rSite[0]-ax,cy=rSite[1]-ay,d=2*(bx*cy-by*cx),hb=bx*bx+by*by,hc=cx*cx+cy*cy,vertex=[(cy*hb-by*hc)/d+ax,(bx*hc-cx*hb)/d+ay];setEdgeEnd(rArc.edge,lSite,rSite,vertex);newArc.edge=createEdge(lSite,site,null,vertex);rArc.edge=createEdge(site,rSite,null,vertex);attachCircle(lArc);attachCircle(rArc);}function leftBreakPoint(arc,directrix){var site=arc.site,rfocx=site[0],rfocy=site[1],pby2=rfocy-directrix;if(!pby2)return rfocx;var lArc=arc.P;if(!lArc)return-Infinity;site=lArc.site;var lfocx=site[0],lfocy=site[1],plby2=lfocy-directrix;if(!plby2)return lfocx;var hl=lfocx-rfocx,aby2=1/pby2-1/plby2,b=hl/plby2;if(aby2)return(-b+Math.sqrt(b*b-2*aby2*(hl*hl/(-2*plby2)-lfocy+plby2/2+rfocy-pby2/2)))/aby2+rfocx;return(rfocx+lfocx)/2;}function rightBreakPoint(arc,directrix){var rArc=arc.N;if(rArc)return leftBreakPoint(rArc,directrix);var site=arc.site;return site[1]===directrix?site[0]:Infinity;}var epsilon$4=1e-6;var epsilon2$2=1e-12;var beaches;var cells;var circles;var edges;function triangleArea(a,b,c){return(a[0]-c[0])*(b[1]-a[1])-(a[0]-b[0])*(c[1]-a[1]);}function lexicographic(a,b){return b[1]-a[1]||b[0]-a[0];}function Diagram(sites,extent){var site=sites.sort(lexicographic).pop(),x,y,circle;edges=[];cells=new Array(sites.length);beaches=new RedBlackTree();circles=new RedBlackTree();while(true){circle=firstCircle;if(site&&(!circle||site[1]<circle.y||site[1]===circle.y&&site[0]<circle.x)){if(site[0]!==x||site[1]!==y){addBeach(site);x=site[0],y=site[1];}site=sites.pop();}else if(circle){removeBeach(circle.arc);}else{break;}}sortCellHalfedges();if(extent){var x0=+extent[0][0],y0=+extent[0][1],x1=+extent[1][0],y1=+extent[1][1];clipEdges(x0,y0,x1,y1);clipCells(x0,y0,x1,y1);}this.edges=edges;this.cells=cells;beaches=circles=edges=cells=null;}Diagram.prototype={constructor:Diagram,polygons:function polygons(){var edges=this.edges;return this.cells.map(function(cell){var polygon=cell.halfedges.map(function(i){return cellHalfedgeStart(cell,edges[i]);});polygon.data=cell.site.data;return polygon;});},triangles:function triangles(){var triangles=[],edges=this.edges;this.cells.forEach(function(cell,i){if(!(m=(halfedges=cell.halfedges).length))return;var site=cell.site,halfedges,j=-1,m,s0,e1=edges[halfedges[m-1]],s1=e1.left===site?e1.right:e1.left;while(++j<m){s0=s1;e1=edges[halfedges[j]];s1=e1.left===site?e1.right:e1.left;if(s0&&s1&&i<s0.index&&i<s1.index&&triangleArea(site,s0,s1)<0){triangles.push([site.data,s0.data,s1.data]);}}});return triangles;},links:function links(){return this.edges.filter(function(edge){return edge.right;}).map(function(edge){return{source:edge.left.data,target:edge.right.data};});},find:function find(x,y,radius){var that=this,i0,i1=that._found||0,n=that.cells.length,cell;// Use the previously-found cell, or start with an arbitrary one.\nwhile(!(cell=that.cells[i1])){if(++i1>=n)return null;}var dx=x-cell.site[0],dy=y-cell.site[1],d2=dx*dx+dy*dy;// Traverse the half-edges to find a closer cell, if any.\ndo{cell=that.cells[i0=i1],i1=null;cell.halfedges.forEach(function(e){var edge=that.edges[e],v=edge.left;if((v===cell.site||!v)&&!(v=edge.right))return;var vx=x-v[0],vy=y-v[1],v2=vx*vx+vy*vy;if(v2<d2)d2=v2,i1=v.index;});}while(i1!==null);that._found=i0;return radius==null||d2<=radius*radius?cell.site:null;}};function voronoi(){var x$$1=x$4,y$$1=y$4,extent=null;function voronoi(data){return new Diagram(data.map(function(d,i){var s=[Math.round(x$$1(d,i,data)/epsilon$4)*epsilon$4,Math.round(y$$1(d,i,data)/epsilon$4)*epsilon$4];s.index=i;s.data=d;return s;}),extent);}voronoi.polygons=function(data){return voronoi(data).polygons();};voronoi.links=function(data){return voronoi(data).links();};voronoi.triangles=function(data){return voronoi(data).triangles();};voronoi.x=function(_){return arguments.length?(x$$1=typeof _===\"function\"?_:constant$12(+_),voronoi):x$$1;};voronoi.y=function(_){return arguments.length?(y$$1=typeof _===\"function\"?_:constant$12(+_),voronoi):y$$1;};voronoi.extent=function(_){return arguments.length?(extent=_==null?null:[[+_[0][0],+_[0][1]],[+_[1][0],+_[1][1]]],voronoi):extent&&[[extent[0][0],extent[0][1]],[extent[1][0],extent[1][1]]];};voronoi.size=function(_){return arguments.length?(extent=_==null?null:[[0,0],[+_[0],+_[1]]],voronoi):extent&&[extent[1][0]-extent[0][0],extent[1][1]-extent[0][1]];};return voronoi;}function constant$13(x){return function(){return x;};}function ZoomEvent(target,type,transform){this.target=target;this.type=type;this.transform=transform;}function Transform(k,x,y){this.k=k;this.x=x;this.y=y;}Transform.prototype={constructor:Transform,scale:function scale(k){return k===1?this:new Transform(this.k*k,this.x,this.y);},translate:function translate(x,y){return x===0&y===0?this:new Transform(this.k,this.x+this.k*x,this.y+this.k*y);},apply:function apply(point){return[point[0]*this.k+this.x,point[1]*this.k+this.y];},applyX:function applyX(x){return x*this.k+this.x;},applyY:function applyY(y){return y*this.k+this.y;},invert:function invert(location){return[(location[0]-this.x)/this.k,(location[1]-this.y)/this.k];},invertX:function invertX(x){return(x-this.x)/this.k;},invertY:function invertY(y){return(y-this.y)/this.k;},rescaleX:function rescaleX(x){return x.copy().domain(x.range().map(this.invertX,this).map(x.invert,x));},rescaleY:function rescaleY(y){return y.copy().domain(y.range().map(this.invertY,this).map(y.invert,y));},toString:function toString(){return\"translate(\"+this.x+\",\"+this.y+\") scale(\"+this.k+\")\";}};var identity$8=new Transform(1,0,0);transform$1.prototype=Transform.prototype;function transform$1(node){return node.__zoom||identity$8;}function nopropagation$2(){d3.event.stopImmediatePropagation();}function noevent$2(){d3.event.preventDefault();d3.event.stopImmediatePropagation();}// Ignore right-click, since that should open the context menu.\nfunction defaultFilter$2(){return!d3.event.button;}function defaultExtent$1(){var e=this,w,h;if(e instanceof SVGElement){e=e.ownerSVGElement||e;w=e.width.baseVal.value;h=e.height.baseVal.value;}else{w=e.clientWidth;h=e.clientHeight;}return[[0,0],[w,h]];}function defaultTransform(){return this.__zoom||identity$8;}function defaultWheelDelta(){return-d3.event.deltaY*(d3.event.deltaMode?120:1)/500;}function defaultTouchable$1(){return\"ontouchstart\"in this;}function defaultConstrain(transform,extent,translateExtent){var dx0=transform.invertX(extent[0][0])-translateExtent[0][0],dx1=transform.invertX(extent[1][0])-translateExtent[1][0],dy0=transform.invertY(extent[0][1])-translateExtent[0][1],dy1=transform.invertY(extent[1][1])-translateExtent[1][1];return transform.translate(dx1>dx0?(dx0+dx1)/2:Math.min(0,dx0)||Math.max(0,dx1),dy1>dy0?(dy0+dy1)/2:Math.min(0,dy0)||Math.max(0,dy1));}function zoom(){var filter=defaultFilter$2,extent=defaultExtent$1,constrain=defaultConstrain,wheelDelta=defaultWheelDelta,touchable=defaultTouchable$1,scaleExtent=[0,Infinity],translateExtent=[[-Infinity,-Infinity],[Infinity,Infinity]],duration=250,interpolate=interpolateZoom,gestures=[],listeners=dispatch(\"start\",\"zoom\",\"end\"),touchstarting,touchending,touchDelay=500,wheelDelay=150,clickDistance2=0;function zoom(selection$$1){selection$$1.property(\"__zoom\",defaultTransform).on(\"wheel.zoom\",wheeled).on(\"mousedown.zoom\",mousedowned).on(\"dblclick.zoom\",dblclicked).filter(touchable).on(\"touchstart.zoom\",touchstarted).on(\"touchmove.zoom\",touchmoved).on(\"touchend.zoom touchcancel.zoom\",touchended).style(\"touch-action\",\"none\").style(\"-webkit-tap-highlight-color\",\"rgba(0,0,0,0)\");}zoom.transform=function(collection,transform){var selection$$1=collection.selection?collection.selection():collection;selection$$1.property(\"__zoom\",defaultTransform);if(collection!==selection$$1){schedule(collection,transform);}else{selection$$1.interrupt().each(function(){gesture(this,arguments).start().zoom(null,typeof transform===\"function\"?transform.apply(this,arguments):transform).end();});}};zoom.scaleBy=function(selection$$1,k){zoom.scaleTo(selection$$1,function(){var k0=this.__zoom.k,k1=typeof k===\"function\"?k.apply(this,arguments):k;return k0*k1;});};zoom.scaleTo=function(selection$$1,k){zoom.transform(selection$$1,function(){var e=extent.apply(this,arguments),t0=this.__zoom,p0=centroid(e),p1=t0.invert(p0),k1=typeof k===\"function\"?k.apply(this,arguments):k;return constrain(translate(scale(t0,k1),p0,p1),e,translateExtent);});};zoom.translateBy=function(selection$$1,x,y){zoom.transform(selection$$1,function(){return constrain(this.__zoom.translate(typeof x===\"function\"?x.apply(this,arguments):x,typeof y===\"function\"?y.apply(this,arguments):y),extent.apply(this,arguments),translateExtent);});};zoom.translateTo=function(selection$$1,x,y){zoom.transform(selection$$1,function(){var e=extent.apply(this,arguments),t=this.__zoom,p=centroid(e);return constrain(identity$8.translate(p[0],p[1]).scale(t.k).translate(typeof x===\"function\"?-x.apply(this,arguments):-x,typeof y===\"function\"?-y.apply(this,arguments):-y),e,translateExtent);});};function scale(transform,k){k=Math.max(scaleExtent[0],Math.min(scaleExtent[1],k));return k===transform.k?transform:new Transform(k,transform.x,transform.y);}function translate(transform,p0,p1){var x=p0[0]-p1[0]*transform.k,y=p0[1]-p1[1]*transform.k;return x===transform.x&&y===transform.y?transform:new Transform(transform.k,x,y);}function centroid(extent){return[(+extent[0][0]+ +extent[1][0])/2,(+extent[0][1]+ +extent[1][1])/2];}function schedule(transition$$1,transform,center){transition$$1.on(\"start.zoom\",function(){gesture(this,arguments).start();}).on(\"interrupt.zoom end.zoom\",function(){gesture(this,arguments).end();}).tween(\"zoom\",function(){var that=this,args=arguments,g=gesture(that,args),e=extent.apply(that,args),p=center||centroid(e),w=Math.max(e[1][0]-e[0][0],e[1][1]-e[0][1]),a=that.__zoom,b=typeof transform===\"function\"?transform.apply(that,args):transform,i=interpolate(a.invert(p).concat(w/a.k),b.invert(p).concat(w/b.k));return function(t){if(t===1)t=b;// Avoid rounding error on end.\nelse{var l=i(t),k=w/l[2];t=new Transform(k,p[0]-l[0]*k,p[1]-l[1]*k);}g.zoom(null,t);};});}function gesture(that,args){for(var i=0,n=gestures.length,g;i<n;++i){if((g=gestures[i]).that===that){return g;}}return new Gesture(that,args);}function Gesture(that,args){this.that=that;this.args=args;this.index=-1;this.active=0;this.extent=extent.apply(that,args);}Gesture.prototype={start:function start(){if(++this.active===1){this.index=gestures.push(this)-1;this.emit(\"start\");}return this;},zoom:function zoom(key,transform){if(this.mouse&&key!==\"mouse\")this.mouse[1]=transform.invert(this.mouse[0]);if(this.touch0&&key!==\"touch\")this.touch0[1]=transform.invert(this.touch0[0]);if(this.touch1&&key!==\"touch\")this.touch1[1]=transform.invert(this.touch1[0]);this.that.__zoom=transform;this.emit(\"zoom\");return this;},end:function end(){if(--this.active===0){gestures.splice(this.index,1);this.index=-1;this.emit(\"end\");}return this;},emit:function emit(type){customEvent(new ZoomEvent(zoom,type,this.that.__zoom),listeners.apply,listeners,[type,this.that,this.args]);}};function wheeled(){if(!filter.apply(this,arguments))return;var g=gesture(this,arguments),t=this.__zoom,k=Math.max(scaleExtent[0],Math.min(scaleExtent[1],t.k*Math.pow(2,wheelDelta.apply(this,arguments)))),p=mouse(this);// If the mouse is in the same location as before, reuse it.\n// If there were recent wheel events, reset the wheel idle timeout.\nif(g.wheel){if(g.mouse[0][0]!==p[0]||g.mouse[0][1]!==p[1]){g.mouse[1]=t.invert(g.mouse[0]=p);}clearTimeout(g.wheel);}// If this wheel event won’t trigger a transform change, ignore it.\nelse if(t.k===k)return;// Otherwise, capture the mouse point and location at the start.\nelse{g.mouse=[p,t.invert(p)];interrupt(this);g.start();}noevent$2();g.wheel=setTimeout(wheelidled,wheelDelay);g.zoom(\"mouse\",constrain(translate(scale(t,k),g.mouse[0],g.mouse[1]),g.extent,translateExtent));function wheelidled(){g.wheel=null;g.end();}}function mousedowned(){if(touchending||!filter.apply(this,arguments))return;var g=gesture(this,arguments),v=select(d3.event.view).on(\"mousemove.zoom\",mousemoved,true).on(\"mouseup.zoom\",mouseupped,true),p=mouse(this),x0=d3.event.clientX,y0=d3.event.clientY;dragDisable(d3.event.view);nopropagation$2();g.mouse=[p,this.__zoom.invert(p)];interrupt(this);g.start();function mousemoved(){noevent$2();if(!g.moved){var dx=d3.event.clientX-x0,dy=d3.event.clientY-y0;g.moved=dx*dx+dy*dy>clickDistance2;}g.zoom(\"mouse\",constrain(translate(g.that.__zoom,g.mouse[0]=mouse(g.that),g.mouse[1]),g.extent,translateExtent));}function mouseupped(){v.on(\"mousemove.zoom mouseup.zoom\",null);yesdrag(d3.event.view,g.moved);noevent$2();g.end();}}function dblclicked(){if(!filter.apply(this,arguments))return;var t0=this.__zoom,p0=mouse(this),p1=t0.invert(p0),k1=t0.k*(d3.event.shiftKey?0.5:2),t1=constrain(translate(scale(t0,k1),p0,p1),extent.apply(this,arguments),translateExtent);noevent$2();if(duration>0)select(this).transition().duration(duration).call(schedule,t1,p0);else select(this).call(zoom.transform,t1);}function touchstarted(){if(!filter.apply(this,arguments))return;var g=gesture(this,arguments),touches$$1=d3.event.changedTouches,started,n=touches$$1.length,i,t,p;nopropagation$2();for(i=0;i<n;++i){t=touches$$1[i],p=touch(this,touches$$1,t.identifier);p=[p,this.__zoom.invert(p),t.identifier];if(!g.touch0)g.touch0=p,started=true;else if(!g.touch1)g.touch1=p;}// If this is a dbltap, reroute to the (optional) dblclick.zoom handler.\nif(touchstarting){touchstarting=clearTimeout(touchstarting);if(!g.touch1){g.end();p=select(this).on(\"dblclick.zoom\");if(p)p.apply(this,arguments);return;}}if(started){touchstarting=setTimeout(function(){touchstarting=null;},touchDelay);interrupt(this);g.start();}}function touchmoved(){var g=gesture(this,arguments),touches$$1=d3.event.changedTouches,n=touches$$1.length,i,t,p,l;noevent$2();if(touchstarting)touchstarting=clearTimeout(touchstarting);for(i=0;i<n;++i){t=touches$$1[i],p=touch(this,touches$$1,t.identifier);if(g.touch0&&g.touch0[2]===t.identifier)g.touch0[0]=p;else if(g.touch1&&g.touch1[2]===t.identifier)g.touch1[0]=p;}t=g.that.__zoom;if(g.touch1){var p0=g.touch0[0],l0=g.touch0[1],p1=g.touch1[0],l1=g.touch1[1],dp=(dp=p1[0]-p0[0])*dp+(dp=p1[1]-p0[1])*dp,dl=(dl=l1[0]-l0[0])*dl+(dl=l1[1]-l0[1])*dl;t=scale(t,Math.sqrt(dp/dl));p=[(p0[0]+p1[0])/2,(p0[1]+p1[1])/2];l=[(l0[0]+l1[0])/2,(l0[1]+l1[1])/2];}else if(g.touch0)p=g.touch0[0],l=g.touch0[1];else return;g.zoom(\"touch\",constrain(translate(t,p,l),g.extent,translateExtent));}function touchended(){var g=gesture(this,arguments),touches$$1=d3.event.changedTouches,n=touches$$1.length,i,t;nopropagation$2();if(touchending)clearTimeout(touchending);touchending=setTimeout(function(){touchending=null;},touchDelay);for(i=0;i<n;++i){t=touches$$1[i];if(g.touch0&&g.touch0[2]===t.identifier)delete g.touch0;else if(g.touch1&&g.touch1[2]===t.identifier)delete g.touch1;}if(g.touch1&&!g.touch0)g.touch0=g.touch1,delete g.touch1;if(g.touch0)g.touch0[1]=this.__zoom.invert(g.touch0[0]);else g.end();}zoom.wheelDelta=function(_){return arguments.length?(wheelDelta=typeof _===\"function\"?_:constant$13(+_),zoom):wheelDelta;};zoom.filter=function(_){return arguments.length?(filter=typeof _===\"function\"?_:constant$13(!!_),zoom):filter;};zoom.touchable=function(_){return arguments.length?(touchable=typeof _===\"function\"?_:constant$13(!!_),zoom):touchable;};zoom.extent=function(_){return arguments.length?(extent=typeof _===\"function\"?_:constant$13([[+_[0][0],+_[0][1]],[+_[1][0],+_[1][1]]]),zoom):extent;};zoom.scaleExtent=function(_){return arguments.length?(scaleExtent[0]=+_[0],scaleExtent[1]=+_[1],zoom):[scaleExtent[0],scaleExtent[1]];};zoom.translateExtent=function(_){return arguments.length?(translateExtent[0][0]=+_[0][0],translateExtent[1][0]=+_[1][0],translateExtent[0][1]=+_[0][1],translateExtent[1][1]=+_[1][1],zoom):[[translateExtent[0][0],translateExtent[0][1]],[translateExtent[1][0],translateExtent[1][1]]];};zoom.constrain=function(_){return arguments.length?(constrain=_,zoom):constrain;};zoom.duration=function(_){return arguments.length?(duration=+_,zoom):duration;};zoom.interpolate=function(_){return arguments.length?(interpolate=_,zoom):interpolate;};zoom.on=function(){var value=listeners.on.apply(listeners,arguments);return value===listeners?zoom:value;};zoom.clickDistance=function(_){return arguments.length?(clickDistance2=(_=+_)*_,zoom):Math.sqrt(clickDistance2);};return zoom;}d3.version=version;d3.bisect=bisectRight;d3.bisectRight=bisectRight;d3.bisectLeft=bisectLeft;d3.ascending=ascending;d3.bisector=bisector;d3.cross=cross;d3.descending=descending;d3.deviation=deviation;d3.extent=extent;d3.histogram=histogram;d3.thresholdFreedmanDiaconis=freedmanDiaconis;d3.thresholdScott=scott;d3.thresholdSturges=thresholdSturges;d3.max=max;d3.mean=mean;d3.median=median;d3.merge=merge;d3.min=min;d3.pairs=pairs;d3.permute=permute;d3.quantile=threshold;d3.range=sequence;d3.scan=scan;d3.shuffle=shuffle;d3.sum=sum;d3.ticks=ticks;d3.tickIncrement=tickIncrement;d3.tickStep=tickStep;d3.transpose=transpose;d3.variance=variance;d3.zip=zip;d3.axisTop=axisTop;d3.axisRight=axisRight;d3.axisBottom=axisBottom;d3.axisLeft=axisLeft;d3.brush=brush;d3.brushX=brushX;d3.brushY=brushY;d3.brushSelection=brushSelection;d3.chord=chord;d3.ribbon=ribbon;d3.nest=nest;d3.set=set$2;d3.map=map$1;d3.keys=keys;d3.values=values;d3.entries=entries;d3.color=color;d3.rgb=rgb;d3.hsl=hsl;d3.lab=lab;d3.hcl=hcl;d3.lch=lch;d3.gray=gray;d3.cubehelix=cubehelix;d3.contours=contours;d3.contourDensity=density;d3.dispatch=dispatch;d3.drag=drag;d3.dragDisable=dragDisable;d3.dragEnable=yesdrag;d3.dsvFormat=dsvFormat;d3.csvParse=csvParse;d3.csvParseRows=csvParseRows;d3.csvFormat=csvFormat;d3.csvFormatRows=csvFormatRows;d3.tsvParse=tsvParse;d3.tsvParseRows=tsvParseRows;d3.tsvFormat=tsvFormat;d3.tsvFormatRows=tsvFormatRows;d3.easeLinear=linear$1;d3.easeQuad=quadInOut;d3.easeQuadIn=quadIn;d3.easeQuadOut=quadOut;d3.easeQuadInOut=quadInOut;d3.easeCubic=cubicInOut;d3.easeCubicIn=cubicIn;d3.easeCubicOut=cubicOut;d3.easeCubicInOut=cubicInOut;d3.easePoly=polyInOut;d3.easePolyIn=polyIn;d3.easePolyOut=polyOut;d3.easePolyInOut=polyInOut;d3.easeSin=sinInOut;d3.easeSinIn=sinIn;d3.easeSinOut=sinOut;d3.easeSinInOut=sinInOut;d3.easeExp=expInOut;d3.easeExpIn=expIn;d3.easeExpOut=expOut;d3.easeExpInOut=expInOut;d3.easeCircle=circleInOut;d3.easeCircleIn=circleIn;d3.easeCircleOut=circleOut;d3.easeCircleInOut=circleInOut;d3.easeBounce=bounceOut;d3.easeBounceIn=bounceIn;d3.easeBounceOut=bounceOut;d3.easeBounceInOut=bounceInOut;d3.easeBack=backInOut;d3.easeBackIn=backIn;d3.easeBackOut=backOut;d3.easeBackInOut=backInOut;d3.easeElastic=elasticOut;d3.easeElasticIn=elasticIn;d3.easeElasticOut=elasticOut;d3.easeElasticInOut=elasticInOut;d3.blob=blob;d3.buffer=buffer;d3.dsv=dsv;d3.csv=csv$1;d3.tsv=tsv$1;d3.image=image;d3.json=json;d3.text=text;d3.xml=xml;d3.html=html;d3.svg=svg;d3.forceCenter=center$1;d3.forceCollide=collide;d3.forceLink=link;d3.forceManyBody=manyBody;d3.forceRadial=radial;d3.forceSimulation=simulation;d3.forceX=x$2;d3.forceY=y$2;d3.formatDefaultLocale=defaultLocale;d3.formatLocale=formatLocale;d3.formatSpecifier=formatSpecifier;d3.precisionFixed=precisionFixed;d3.precisionPrefix=precisionPrefix;d3.precisionRound=precisionRound;d3.geoArea=area$1;d3.geoBounds=bounds;d3.geoCentroid=centroid;d3.geoCircle=circle;d3.geoClipAntimeridian=clipAntimeridian;d3.geoClipCircle=clipCircle;d3.geoClipExtent=extent$1;d3.geoClipRectangle=clipRectangle;d3.geoContains=contains$1;d3.geoDistance=distance;d3.geoGraticule=graticule;d3.geoGraticule10=graticule10;d3.geoInterpolate=interpolate$1;d3.geoLength=length$1;d3.geoPath=index$1;d3.geoAlbers=albers;d3.geoAlbersUsa=albersUsa;d3.geoAzimuthalEqualArea=azimuthalEqualArea;d3.geoAzimuthalEqualAreaRaw=azimuthalEqualAreaRaw;d3.geoAzimuthalEquidistant=azimuthalEquidistant;d3.geoAzimuthalEquidistantRaw=azimuthalEquidistantRaw;d3.geoConicConformal=conicConformal;d3.geoConicConformalRaw=conicConformalRaw;d3.geoConicEqualArea=conicEqualArea;d3.geoConicEqualAreaRaw=conicEqualAreaRaw;d3.geoConicEquidistant=conicEquidistant;d3.geoConicEquidistantRaw=conicEquidistantRaw;d3.geoEquirectangular=equirectangular;d3.geoEquirectangularRaw=equirectangularRaw;d3.geoGnomonic=gnomonic;d3.geoGnomonicRaw=gnomonicRaw;d3.geoIdentity=identity$5;d3.geoProjection=projection;d3.geoProjectionMutator=projectionMutator;d3.geoMercator=mercator;d3.geoMercatorRaw=mercatorRaw;d3.geoNaturalEarth1=naturalEarth1;d3.geoNaturalEarth1Raw=naturalEarth1Raw;d3.geoOrthographic=orthographic;d3.geoOrthographicRaw=orthographicRaw;d3.geoStereographic=stereographic;d3.geoStereographicRaw=stereographicRaw;d3.geoTransverseMercator=transverseMercator;d3.geoTransverseMercatorRaw=transverseMercatorRaw;d3.geoRotation=rotation;d3.geoStream=geoStream;d3.geoTransform=transform;d3.cluster=cluster;d3.hierarchy=hierarchy;d3.pack=index$2;d3.packSiblings=siblings;d3.packEnclose=enclose;d3.partition=partition;d3.stratify=stratify;d3.tree=tree;d3.treemap=index$3;d3.treemapBinary=binary;d3.treemapDice=treemapDice;d3.treemapSlice=treemapSlice;d3.treemapSliceDice=sliceDice;d3.treemapSquarify=squarify;d3.treemapResquarify=resquarify;d3.interpolate=interpolateValue;d3.interpolateArray=array$1;d3.interpolateBasis=basis$1;d3.interpolateBasisClosed=basisClosed;d3.interpolateDate=date;d3.interpolateNumber=reinterpolate;d3.interpolateObject=object;d3.interpolateRound=interpolateRound;d3.interpolateString=interpolateString;d3.interpolateTransformCss=interpolateTransformCss;d3.interpolateTransformSvg=interpolateTransformSvg;d3.interpolateZoom=interpolateZoom;d3.interpolateRgb=interpolateRgb;d3.interpolateRgbBasis=rgbBasis;d3.interpolateRgbBasisClosed=rgbBasisClosed;d3.interpolateHsl=hsl$2;d3.interpolateHslLong=hslLong;d3.interpolateLab=lab$1;d3.interpolateHcl=hcl$2;d3.interpolateHclLong=hclLong;d3.interpolateCubehelix=cubehelix$2;d3.interpolateCubehelixLong=cubehelixLong;d3.piecewise=piecewise;d3.quantize=quantize;d3.path=path;d3.polygonArea=area$2;d3.polygonCentroid=centroid$1;d3.polygonHull=hull;d3.polygonContains=contains$2;d3.polygonLength=length$2;d3.quadtree=quadtree;d3.randomUniform=uniform;d3.randomNormal=normal;d3.randomLogNormal=logNormal;d3.randomBates=bates;d3.randomIrwinHall=irwinHall;d3.randomExponential=exponential$1;d3.scaleBand=band;d3.scalePoint=point$1;d3.scaleIdentity=identity$6;d3.scaleLinear=linear$2;d3.scaleLog=log$1;d3.scaleOrdinal=ordinal;d3.scaleImplicit=implicit;d3.scalePow=pow$1;d3.scaleSqrt=sqrt$1;d3.scaleQuantile=quantile$$1;d3.scaleQuantize=quantize$1;d3.scaleThreshold=threshold$1;d3.scaleTime=time;d3.scaleUtc=utcTime;d3.scaleSequential=sequential;d3.schemeCategory10=category10;d3.schemeAccent=Accent;d3.schemeDark2=Dark2;d3.schemePaired=Paired;d3.schemePastel1=Pastel1;d3.schemePastel2=Pastel2;d3.schemeSet1=Set1;d3.schemeSet2=Set2;d3.schemeSet3=Set3;d3.interpolateBrBG=BrBG;d3.schemeBrBG=scheme;d3.interpolatePRGn=PRGn;d3.schemePRGn=scheme$1;d3.interpolatePiYG=PiYG;d3.schemePiYG=scheme$2;d3.interpolatePuOr=PuOr;d3.schemePuOr=scheme$3;d3.interpolateRdBu=RdBu;d3.schemeRdBu=scheme$4;d3.interpolateRdGy=RdGy;d3.schemeRdGy=scheme$5;d3.interpolateRdYlBu=RdYlBu;d3.schemeRdYlBu=scheme$6;d3.interpolateRdYlGn=RdYlGn;d3.schemeRdYlGn=scheme$7;d3.interpolateSpectral=Spectral;d3.schemeSpectral=scheme$8;d3.interpolateBuGn=BuGn;d3.schemeBuGn=scheme$9;d3.interpolateBuPu=BuPu;d3.schemeBuPu=scheme$10;d3.interpolateGnBu=GnBu;d3.schemeGnBu=scheme$11;d3.interpolateOrRd=OrRd;d3.schemeOrRd=scheme$12;d3.interpolatePuBuGn=PuBuGn;d3.schemePuBuGn=scheme$13;d3.interpolatePuBu=PuBu;d3.schemePuBu=scheme$14;d3.interpolatePuRd=PuRd;d3.schemePuRd=scheme$15;d3.interpolateRdPu=RdPu;d3.schemeRdPu=scheme$16;d3.interpolateYlGnBu=YlGnBu;d3.schemeYlGnBu=scheme$17;d3.interpolateYlGn=YlGn;d3.schemeYlGn=scheme$18;d3.interpolateYlOrBr=YlOrBr;d3.schemeYlOrBr=scheme$19;d3.interpolateYlOrRd=YlOrRd;d3.schemeYlOrRd=scheme$20;d3.interpolateBlues=Blues;d3.schemeBlues=scheme$21;d3.interpolateGreens=Greens;d3.schemeGreens=scheme$22;d3.interpolateGreys=Greys;d3.schemeGreys=scheme$23;d3.interpolatePurples=Purples;d3.schemePurples=scheme$24;d3.interpolateReds=Reds;d3.schemeReds=scheme$25;d3.interpolateOranges=Oranges;d3.schemeOranges=scheme$26;d3.interpolateCubehelixDefault=cubehelix$3;d3.interpolateRainbow=rainbow;d3.interpolateWarm=warm;d3.interpolateCool=cool;d3.interpolateSinebow=sinebow;d3.interpolateViridis=viridis;d3.interpolateMagma=magma;d3.interpolateInferno=inferno;d3.interpolatePlasma=plasma;d3.create=create;d3.creator=creator;d3.local=local;d3.matcher=matcher$1;d3.mouse=mouse;d3.namespace=namespace;d3.namespaces=namespaces;d3.clientPoint=point;d3.select=select;d3.selectAll=selectAll;d3.selection=selection;d3.selector=selector;d3.selectorAll=selectorAll;d3.style=styleValue;d3.touch=touch;d3.touches=touches;d3.window=defaultView;d3.customEvent=customEvent;d3.arc=arc;d3.area=area$3;d3.line=line;d3.pie=pie;d3.areaRadial=areaRadial;d3.radialArea=areaRadial;d3.lineRadial=lineRadial$1;d3.radialLine=lineRadial$1;d3.pointRadial=pointRadial;d3.linkHorizontal=linkHorizontal;d3.linkVertical=linkVertical;d3.linkRadial=linkRadial;d3.symbol=symbol;d3.symbols=symbols;d3.symbolCircle=circle$2;d3.symbolCross=cross$2;d3.symbolDiamond=diamond;d3.symbolSquare=square;d3.symbolStar=star;d3.symbolTriangle=triangle;d3.symbolWye=wye;d3.curveBasisClosed=basisClosed$1;d3.curveBasisOpen=basisOpen;d3.curveBasis=basis$2;d3.curveBundle=bundle;d3.curveCardinalClosed=cardinalClosed;d3.curveCardinalOpen=cardinalOpen;d3.curveCardinal=cardinal;d3.curveCatmullRomClosed=catmullRomClosed;d3.curveCatmullRomOpen=catmullRomOpen;d3.curveCatmullRom=catmullRom;d3.curveLinearClosed=linearClosed;d3.curveLinear=curveLinear;d3.curveMonotoneX=monotoneX;d3.curveMonotoneY=monotoneY;d3.curveNatural=natural;d3.curveStep=step;d3.curveStepAfter=stepAfter;d3.curveStepBefore=stepBefore;d3.stack=stack;d3.stackOffsetExpand=expand;d3.stackOffsetDiverging=diverging;d3.stackOffsetNone=none$1;d3.stackOffsetSilhouette=silhouette;d3.stackOffsetWiggle=wiggle;d3.stackOrderAscending=ascending$3;d3.stackOrderDescending=descending$2;d3.stackOrderInsideOut=insideOut;d3.stackOrderNone=none$2;d3.stackOrderReverse=reverse;d3.timeInterval=newInterval;d3.timeMillisecond=millisecond;d3.timeMilliseconds=milliseconds;d3.utcMillisecond=millisecond;d3.utcMilliseconds=milliseconds;d3.timeSecond=second;d3.timeSeconds=seconds;d3.utcSecond=second;d3.utcSeconds=seconds;d3.timeMinute=minute;d3.timeMinutes=minutes;d3.timeHour=hour;d3.timeHours=hours;d3.timeDay=day;d3.timeDays=days;d3.timeWeek=sunday;d3.timeWeeks=sundays;d3.timeSunday=sunday;d3.timeSundays=sundays;d3.timeMonday=monday;d3.timeMondays=mondays;d3.timeTuesday=tuesday;d3.timeTuesdays=tuesdays;d3.timeWednesday=wednesday;d3.timeWednesdays=wednesdays;d3.timeThursday=thursday;d3.timeThursdays=thursdays;d3.timeFriday=friday;d3.timeFridays=fridays;d3.timeSaturday=saturday;d3.timeSaturdays=saturdays;d3.timeMonth=month;d3.timeMonths=months;d3.timeYear=year;d3.timeYears=years;d3.utcMinute=utcMinute;d3.utcMinutes=utcMinutes;d3.utcHour=utcHour;d3.utcHours=utcHours;d3.utcDay=utcDay;d3.utcDays=utcDays;d3.utcWeek=utcSunday;d3.utcWeeks=utcSundays;d3.utcSunday=utcSunday;d3.utcSundays=utcSundays;d3.utcMonday=utcMonday;d3.utcMondays=utcMondays;d3.utcTuesday=utcTuesday;d3.utcTuesdays=utcTuesdays;d3.utcWednesday=utcWednesday;d3.utcWednesdays=utcWednesdays;d3.utcThursday=utcThursday;d3.utcThursdays=utcThursdays;d3.utcFriday=utcFriday;d3.utcFridays=utcFridays;d3.utcSaturday=utcSaturday;d3.utcSaturdays=utcSaturdays;d3.utcMonth=utcMonth;d3.utcMonths=utcMonths;d3.utcYear=utcYear;d3.utcYears=utcYears;d3.timeFormatDefaultLocale=defaultLocale$1;d3.timeFormatLocale=formatLocale$1;d3.isoFormat=formatIso;d3.isoParse=parseIso;d3.now=now;d3.timer=timer;d3.timerFlush=timerFlush;d3.timeout=timeout$1;d3.interval=interval$1;d3.transition=transition;d3.active=active;d3.interrupt=interrupt;d3.voronoi=voronoi;d3.zoom=zoom;d3.zoomTransform=transform$1;d3.zoomIdentity=identity$8;exports.d3=d3;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdmVuZG9yL2QzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3NyYy92ZW5kb3IvZDMuanM/ZDIwZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcbnZhciBkMz17fTtcclxudmFyIHZlcnNpb24gPSBcIjUuNC4wXCI7XHJcblxyXG5mdW5jdGlvbiBhc2NlbmRpbmcoYSwgYikge1xyXG4gIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogYSA+PSBiID8gMCA6IE5hTjtcclxufVxyXG5cclxuZnVuY3Rpb24gYmlzZWN0b3IoY29tcGFyZSkge1xyXG4gIGlmIChjb21wYXJlLmxlbmd0aCA9PT0gMSkgY29tcGFyZSA9IGFzY2VuZGluZ0NvbXBhcmF0b3IoY29tcGFyZSk7XHJcbiAgcmV0dXJuIHtcclxuICAgIGxlZnQ6IGZ1bmN0aW9uKGEsIHgsIGxvLCBoaSkge1xyXG4gICAgICBpZiAobG8gPT0gbnVsbCkgbG8gPSAwO1xyXG4gICAgICBpZiAoaGkgPT0gbnVsbCkgaGkgPSBhLmxlbmd0aDtcclxuICAgICAgd2hpbGUgKGxvIDwgaGkpIHtcclxuICAgICAgICB2YXIgbWlkID0gbG8gKyBoaSA+Pj4gMTtcclxuICAgICAgICBpZiAoY29tcGFyZShhW21pZF0sIHgpIDwgMCkgbG8gPSBtaWQgKyAxO1xyXG4gICAgICAgIGVsc2UgaGkgPSBtaWQ7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGxvO1xyXG4gICAgfSxcclxuICAgIHJpZ2h0OiBmdW5jdGlvbihhLCB4LCBsbywgaGkpIHtcclxuICAgICAgaWYgKGxvID09IG51bGwpIGxvID0gMDtcclxuICAgICAgaWYgKGhpID09IG51bGwpIGhpID0gYS5sZW5ndGg7XHJcbiAgICAgIHdoaWxlIChsbyA8IGhpKSB7XHJcbiAgICAgICAgdmFyIG1pZCA9IGxvICsgaGkgPj4+IDE7XHJcbiAgICAgICAgaWYgKGNvbXBhcmUoYVttaWRdLCB4KSA+IDApIGhpID0gbWlkO1xyXG4gICAgICAgIGVsc2UgbG8gPSBtaWQgKyAxO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBsbztcclxuICAgIH1cclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBhc2NlbmRpbmdDb21wYXJhdG9yKGYpIHtcclxuICByZXR1cm4gZnVuY3Rpb24oZCwgeCkge1xyXG4gICAgcmV0dXJuIGFzY2VuZGluZyhmKGQpLCB4KTtcclxuICB9O1xyXG59XHJcblxyXG52YXIgYXNjZW5kaW5nQmlzZWN0ID0gYmlzZWN0b3IoYXNjZW5kaW5nKTtcclxudmFyIGJpc2VjdFJpZ2h0ID0gYXNjZW5kaW5nQmlzZWN0LnJpZ2h0O1xyXG52YXIgYmlzZWN0TGVmdCA9IGFzY2VuZGluZ0Jpc2VjdC5sZWZ0O1xyXG5cclxuZnVuY3Rpb24gcGFpcnMoYXJyYXksIGYpIHtcclxuICBpZiAoZiA9PSBudWxsKSBmID0gcGFpcjtcclxuICB2YXIgaSA9IDAsIG4gPSBhcnJheS5sZW5ndGggLSAxLCBwID0gYXJyYXlbMF0sIHBhaXJzID0gbmV3IEFycmF5KG4gPCAwID8gMCA6IG4pO1xyXG4gIHdoaWxlIChpIDwgbikgcGFpcnNbaV0gPSBmKHAsIHAgPSBhcnJheVsrK2ldKTtcclxuICByZXR1cm4gcGFpcnM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhaXIoYSwgYikge1xyXG4gIHJldHVybiBbYSwgYl07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyb3NzKHZhbHVlczAsIHZhbHVlczEsIHJlZHVjZSkge1xyXG4gIHZhciBuMCA9IHZhbHVlczAubGVuZ3RoLFxyXG4gICAgICBuMSA9IHZhbHVlczEubGVuZ3RoLFxyXG4gICAgICB2YWx1ZXMgPSBuZXcgQXJyYXkobjAgKiBuMSksXHJcbiAgICAgIGkwLFxyXG4gICAgICBpMSxcclxuICAgICAgaSxcclxuICAgICAgdmFsdWUwO1xyXG5cclxuICBpZiAocmVkdWNlID09IG51bGwpIHJlZHVjZSA9IHBhaXI7XHJcblxyXG4gIGZvciAoaTAgPSBpID0gMDsgaTAgPCBuMDsgKytpMCkge1xyXG4gICAgZm9yICh2YWx1ZTAgPSB2YWx1ZXMwW2kwXSwgaTEgPSAwOyBpMSA8IG4xOyArK2kxLCArK2kpIHtcclxuICAgICAgdmFsdWVzW2ldID0gcmVkdWNlKHZhbHVlMCwgdmFsdWVzMVtpMV0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHZhbHVlcztcclxufVxyXG5cclxuZnVuY3Rpb24gZGVzY2VuZGluZyhhLCBiKSB7XHJcbiAgcmV0dXJuIGIgPCBhID8gLTEgOiBiID4gYSA/IDEgOiBiID49IGEgPyAwIDogTmFOO1xyXG59XHJcblxyXG5mdW5jdGlvbiBudW1iZXIoeCkge1xyXG4gIHJldHVybiB4ID09PSBudWxsID8gTmFOIDogK3g7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHZhcmlhbmNlKHZhbHVlcywgdmFsdWVvZikge1xyXG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aCxcclxuICAgICAgbSA9IDAsXHJcbiAgICAgIGkgPSAtMSxcclxuICAgICAgbWVhbiA9IDAsXHJcbiAgICAgIHZhbHVlLFxyXG4gICAgICBkZWx0YSxcclxuICAgICAgc3VtID0gMDtcclxuXHJcbiAgaWYgKHZhbHVlb2YgPT0gbnVsbCkge1xyXG4gICAgd2hpbGUgKCsraSA8IG4pIHtcclxuICAgICAgaWYgKCFpc05hTih2YWx1ZSA9IG51bWJlcih2YWx1ZXNbaV0pKSkge1xyXG4gICAgICAgIGRlbHRhID0gdmFsdWUgLSBtZWFuO1xyXG4gICAgICAgIG1lYW4gKz0gZGVsdGEgLyArK207XHJcbiAgICAgICAgc3VtICs9IGRlbHRhICogKHZhbHVlIC0gbWVhbik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGVsc2Uge1xyXG4gICAgd2hpbGUgKCsraSA8IG4pIHtcclxuICAgICAgaWYgKCFpc05hTih2YWx1ZSA9IG51bWJlcih2YWx1ZW9mKHZhbHVlc1tpXSwgaSwgdmFsdWVzKSkpKSB7XHJcbiAgICAgICAgZGVsdGEgPSB2YWx1ZSAtIG1lYW47XHJcbiAgICAgICAgbWVhbiArPSBkZWx0YSAvICsrbTtcclxuICAgICAgICBzdW0gKz0gZGVsdGEgKiAodmFsdWUgLSBtZWFuKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKG0gPiAxKSByZXR1cm4gc3VtIC8gKG0gLSAxKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZGV2aWF0aW9uKGFycmF5LCBmKSB7XHJcbiAgdmFyIHYgPSB2YXJpYW5jZShhcnJheSwgZik7XHJcbiAgcmV0dXJuIHYgPyBNYXRoLnNxcnQodikgOiB2O1xyXG59XHJcblxyXG5mdW5jdGlvbiBleHRlbnQodmFsdWVzLCB2YWx1ZW9mKSB7XHJcbiAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoLFxyXG4gICAgICBpID0gLTEsXHJcbiAgICAgIHZhbHVlLFxyXG4gICAgICBtaW4sXHJcbiAgICAgIG1heDtcclxuXHJcbiAgaWYgKHZhbHVlb2YgPT0gbnVsbCkge1xyXG4gICAgd2hpbGUgKCsraSA8IG4pIHsgLy8gRmluZCB0aGUgZmlyc3QgY29tcGFyYWJsZSB2YWx1ZS5cclxuICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlc1tpXSkgIT0gbnVsbCAmJiB2YWx1ZSA+PSB2YWx1ZSkge1xyXG4gICAgICAgIG1pbiA9IG1heCA9IHZhbHVlO1xyXG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIENvbXBhcmUgdGhlIHJlbWFpbmluZyB2YWx1ZXMuXHJcbiAgICAgICAgICBpZiAoKHZhbHVlID0gdmFsdWVzW2ldKSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChtaW4gPiB2YWx1ZSkgbWluID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGlmIChtYXggPCB2YWx1ZSkgbWF4ID0gdmFsdWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBlbHNlIHtcclxuICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIEZpbmQgdGhlIGZpcnN0IGNvbXBhcmFibGUgdmFsdWUuXHJcbiAgICAgIGlmICgodmFsdWUgPSB2YWx1ZW9mKHZhbHVlc1tpXSwgaSwgdmFsdWVzKSkgIT0gbnVsbCAmJiB2YWx1ZSA+PSB2YWx1ZSkge1xyXG4gICAgICAgIG1pbiA9IG1heCA9IHZhbHVlO1xyXG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIENvbXBhcmUgdGhlIHJlbWFpbmluZyB2YWx1ZXMuXHJcbiAgICAgICAgICBpZiAoKHZhbHVlID0gdmFsdWVvZih2YWx1ZXNbaV0sIGksIHZhbHVlcykpICE9IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKG1pbiA+IHZhbHVlKSBtaW4gPSB2YWx1ZTtcclxuICAgICAgICAgICAgaWYgKG1heCA8IHZhbHVlKSBtYXggPSB2YWx1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBbbWluLCBtYXhdO1xyXG59XHJcblxyXG52YXIgYXJyYXkgPSBBcnJheS5wcm90b3R5cGU7XHJcblxyXG52YXIgc2xpY2UgPSBhcnJheS5zbGljZTtcclxudmFyIG1hcCA9IGFycmF5Lm1hcDtcclxuXHJcbmZ1bmN0aW9uIGNvbnN0YW50KHgpIHtcclxuICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4geDtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBpZGVudGl0eSh4KSB7XHJcbiAgcmV0dXJuIHg7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNlcXVlbmNlKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XHJcbiAgc3RhcnQgPSArc3RhcnQsIHN0b3AgPSArc3RvcCwgc3RlcCA9IChuID0gYXJndW1lbnRzLmxlbmd0aCkgPCAyID8gKHN0b3AgPSBzdGFydCwgc3RhcnQgPSAwLCAxKSA6IG4gPCAzID8gMSA6ICtzdGVwO1xyXG5cclxuICB2YXIgaSA9IC0xLFxyXG4gICAgICBuID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCkpIHwgMCxcclxuICAgICAgcmFuZ2UgPSBuZXcgQXJyYXkobik7XHJcblxyXG4gIHdoaWxlICgrK2kgPCBuKSB7XHJcbiAgICByYW5nZVtpXSA9IHN0YXJ0ICsgaSAqIHN0ZXA7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmFuZ2U7XHJcbn1cclxuXHJcbnZhciBlMTAgPSBNYXRoLnNxcnQoNTApLFxyXG4gICAgZTUgPSBNYXRoLnNxcnQoMTApLFxyXG4gICAgZTIgPSBNYXRoLnNxcnQoMik7XHJcblxyXG5mdW5jdGlvbiB0aWNrcyhzdGFydCwgc3RvcCwgY291bnQpIHtcclxuICB2YXIgcmV2ZXJzZSxcclxuICAgICAgaSA9IC0xLFxyXG4gICAgICBuLFxyXG4gICAgICB0aWNrcyxcclxuICAgICAgc3RlcDtcclxuXHJcbiAgc3RvcCA9ICtzdG9wLCBzdGFydCA9ICtzdGFydCwgY291bnQgPSArY291bnQ7XHJcbiAgaWYgKHN0YXJ0ID09PSBzdG9wICYmIGNvdW50ID4gMCkgcmV0dXJuIFtzdGFydF07XHJcbiAgaWYgKHJldmVyc2UgPSBzdG9wIDwgc3RhcnQpIG4gPSBzdGFydCwgc3RhcnQgPSBzdG9wLCBzdG9wID0gbjtcclxuICBpZiAoKHN0ZXAgPSB0aWNrSW5jcmVtZW50KHN0YXJ0LCBzdG9wLCBjb3VudCkpID09PSAwIHx8ICFpc0Zpbml0ZShzdGVwKSkgcmV0dXJuIFtdO1xyXG5cclxuICBpZiAoc3RlcCA+IDApIHtcclxuICAgIHN0YXJ0ID0gTWF0aC5jZWlsKHN0YXJ0IC8gc3RlcCk7XHJcbiAgICBzdG9wID0gTWF0aC5mbG9vcihzdG9wIC8gc3RlcCk7XHJcbiAgICB0aWNrcyA9IG5ldyBBcnJheShuID0gTWF0aC5jZWlsKHN0b3AgLSBzdGFydCArIDEpKTtcclxuICAgIHdoaWxlICgrK2kgPCBuKSB0aWNrc1tpXSA9IChzdGFydCArIGkpICogc3RlcDtcclxuICB9IGVsc2Uge1xyXG4gICAgc3RhcnQgPSBNYXRoLmZsb29yKHN0YXJ0ICogc3RlcCk7XHJcbiAgICBzdG9wID0gTWF0aC5jZWlsKHN0b3AgKiBzdGVwKTtcclxuICAgIHRpY2tzID0gbmV3IEFycmF5KG4gPSBNYXRoLmNlaWwoc3RhcnQgLSBzdG9wICsgMSkpO1xyXG4gICAgd2hpbGUgKCsraSA8IG4pIHRpY2tzW2ldID0gKHN0YXJ0IC0gaSkgLyBzdGVwO1xyXG4gIH1cclxuXHJcbiAgaWYgKHJldmVyc2UpIHRpY2tzLnJldmVyc2UoKTtcclxuXHJcbiAgcmV0dXJuIHRpY2tzO1xyXG59XHJcblxyXG5mdW5jdGlvbiB0aWNrSW5jcmVtZW50KHN0YXJ0LCBzdG9wLCBjb3VudCkge1xyXG4gIHZhciBzdGVwID0gKHN0b3AgLSBzdGFydCkgLyBNYXRoLm1heCgwLCBjb3VudCksXHJcbiAgICAgIHBvd2VyID0gTWF0aC5mbG9vcihNYXRoLmxvZyhzdGVwKSAvIE1hdGguTE4xMCksXHJcbiAgICAgIGVycm9yID0gc3RlcCAvIE1hdGgucG93KDEwLCBwb3dlcik7XHJcbiAgcmV0dXJuIHBvd2VyID49IDBcclxuICAgICAgPyAoZXJyb3IgPj0gZTEwID8gMTAgOiBlcnJvciA+PSBlNSA/IDUgOiBlcnJvciA+PSBlMiA/IDIgOiAxKSAqIE1hdGgucG93KDEwLCBwb3dlcilcclxuICAgICAgOiAtTWF0aC5wb3coMTAsIC1wb3dlcikgLyAoZXJyb3IgPj0gZTEwID8gMTAgOiBlcnJvciA+PSBlNSA/IDUgOiBlcnJvciA+PSBlMiA/IDIgOiAxKTtcclxufVxyXG5cclxuZnVuY3Rpb24gdGlja1N0ZXAoc3RhcnQsIHN0b3AsIGNvdW50KSB7XHJcbiAgdmFyIHN0ZXAwID0gTWF0aC5hYnMoc3RvcCAtIHN0YXJ0KSAvIE1hdGgubWF4KDAsIGNvdW50KSxcclxuICAgICAgc3RlcDEgPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihNYXRoLmxvZyhzdGVwMCkgLyBNYXRoLkxOMTApKSxcclxuICAgICAgZXJyb3IgPSBzdGVwMCAvIHN0ZXAxO1xyXG4gIGlmIChlcnJvciA+PSBlMTApIHN0ZXAxICo9IDEwO1xyXG4gIGVsc2UgaWYgKGVycm9yID49IGU1KSBzdGVwMSAqPSA1O1xyXG4gIGVsc2UgaWYgKGVycm9yID49IGUyKSBzdGVwMSAqPSAyO1xyXG4gIHJldHVybiBzdG9wIDwgc3RhcnQgPyAtc3RlcDEgOiBzdGVwMTtcclxufVxyXG5cclxuZnVuY3Rpb24gdGhyZXNob2xkU3R1cmdlcyh2YWx1ZXMpIHtcclxuICByZXR1cm4gTWF0aC5jZWlsKE1hdGgubG9nKHZhbHVlcy5sZW5ndGgpIC8gTWF0aC5MTjIpICsgMTtcclxufVxyXG5cclxuZnVuY3Rpb24gaGlzdG9ncmFtKCkge1xyXG4gIHZhciB2YWx1ZSA9IGlkZW50aXR5LFxyXG4gICAgICBkb21haW4gPSBleHRlbnQsXHJcbiAgICAgIHRocmVzaG9sZCA9IHRocmVzaG9sZFN0dXJnZXM7XHJcblxyXG4gIGZ1bmN0aW9uIGhpc3RvZ3JhbShkYXRhKSB7XHJcbiAgICB2YXIgaSxcclxuICAgICAgICBuID0gZGF0YS5sZW5ndGgsXHJcbiAgICAgICAgeCxcclxuICAgICAgICB2YWx1ZXMgPSBuZXcgQXJyYXkobik7XHJcblxyXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xyXG4gICAgICB2YWx1ZXNbaV0gPSB2YWx1ZShkYXRhW2ldLCBpLCBkYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgeHogPSBkb21haW4odmFsdWVzKSxcclxuICAgICAgICB4MCA9IHh6WzBdLFxyXG4gICAgICAgIHgxID0geHpbMV0sXHJcbiAgICAgICAgdHogPSB0aHJlc2hvbGQodmFsdWVzLCB4MCwgeDEpO1xyXG5cclxuICAgIC8vIENvbnZlcnQgbnVtYmVyIG9mIHRocmVzaG9sZHMgaW50byB1bmlmb3JtIHRocmVzaG9sZHMuXHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodHopKSB7XHJcbiAgICAgIHR6ID0gdGlja1N0ZXAoeDAsIHgxLCB0eik7XHJcbiAgICAgIHR6ID0gc2VxdWVuY2UoTWF0aC5jZWlsKHgwIC8gdHopICogdHosIE1hdGguZmxvb3IoeDEgLyB0eikgKiB0eiwgdHopOyAvLyBleGNsdXNpdmVcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZW1vdmUgYW55IHRocmVzaG9sZHMgb3V0c2lkZSB0aGUgZG9tYWluLlxyXG4gICAgdmFyIG0gPSB0ei5sZW5ndGg7XHJcbiAgICB3aGlsZSAodHpbMF0gPD0geDApIHR6LnNoaWZ0KCksIC0tbTtcclxuICAgIHdoaWxlICh0elttIC0gMV0gPiB4MSkgdHoucG9wKCksIC0tbTtcclxuXHJcbiAgICB2YXIgYmlucyA9IG5ldyBBcnJheShtICsgMSksXHJcbiAgICAgICAgYmluO1xyXG5cclxuICAgIC8vIEluaXRpYWxpemUgYmlucy5cclxuICAgIGZvciAoaSA9IDA7IGkgPD0gbTsgKytpKSB7XHJcbiAgICAgIGJpbiA9IGJpbnNbaV0gPSBbXTtcclxuICAgICAgYmluLngwID0gaSA+IDAgPyB0eltpIC0gMV0gOiB4MDtcclxuICAgICAgYmluLngxID0gaSA8IG0gPyB0eltpXSA6IHgxO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFzc2lnbiBkYXRhIHRvIGJpbnMgYnkgdmFsdWUsIGlnbm9yaW5nIGFueSBvdXRzaWRlIHRoZSBkb21haW4uXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgIHggPSB2YWx1ZXNbaV07XHJcbiAgICAgIGlmICh4MCA8PSB4ICYmIHggPD0geDEpIHtcclxuICAgICAgICBiaW5zW2Jpc2VjdFJpZ2h0KHR6LCB4LCAwLCBtKV0ucHVzaChkYXRhW2ldKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBiaW5zO1xyXG4gIH1cclxuXHJcbiAgaGlzdG9ncmFtLnZhbHVlID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodmFsdWUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KF8pLCBoaXN0b2dyYW0pIDogdmFsdWU7XHJcbiAgfTtcclxuXHJcbiAgaGlzdG9ncmFtLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRvbWFpbiA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoW19bMF0sIF9bMV1dKSwgaGlzdG9ncmFtKSA6IGRvbWFpbjtcclxuICB9O1xyXG5cclxuICBoaXN0b2dyYW0udGhyZXNob2xkcyA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRocmVzaG9sZCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogQXJyYXkuaXNBcnJheShfKSA/IGNvbnN0YW50KHNsaWNlLmNhbGwoXykpIDogY29uc3RhbnQoXyksIGhpc3RvZ3JhbSkgOiB0aHJlc2hvbGQ7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIGhpc3RvZ3JhbTtcclxufVxyXG5cclxuZnVuY3Rpb24gdGhyZXNob2xkKHZhbHVlcywgcCwgdmFsdWVvZikge1xyXG4gIGlmICh2YWx1ZW9mID09IG51bGwpIHZhbHVlb2YgPSBudW1iZXI7XHJcbiAgaWYgKCEobiA9IHZhbHVlcy5sZW5ndGgpKSByZXR1cm47XHJcbiAgaWYgKChwID0gK3ApIDw9IDAgfHwgbiA8IDIpIHJldHVybiArdmFsdWVvZih2YWx1ZXNbMF0sIDAsIHZhbHVlcyk7XHJcbiAgaWYgKHAgPj0gMSkgcmV0dXJuICt2YWx1ZW9mKHZhbHVlc1tuIC0gMV0sIG4gLSAxLCB2YWx1ZXMpO1xyXG4gIHZhciBuLFxyXG4gICAgICBpID0gKG4gLSAxKSAqIHAsXHJcbiAgICAgIGkwID0gTWF0aC5mbG9vcihpKSxcclxuICAgICAgdmFsdWUwID0gK3ZhbHVlb2YodmFsdWVzW2kwXSwgaTAsIHZhbHVlcyksXHJcbiAgICAgIHZhbHVlMSA9ICt2YWx1ZW9mKHZhbHVlc1tpMCArIDFdLCBpMCArIDEsIHZhbHVlcyk7XHJcbiAgcmV0dXJuIHZhbHVlMCArICh2YWx1ZTEgLSB2YWx1ZTApICogKGkgLSBpMCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZyZWVkbWFuRGlhY29uaXModmFsdWVzLCBtaW4sIG1heCkge1xyXG4gIHZhbHVlcyA9IG1hcC5jYWxsKHZhbHVlcywgbnVtYmVyKS5zb3J0KGFzY2VuZGluZyk7XHJcbiAgcmV0dXJuIE1hdGguY2VpbCgobWF4IC0gbWluKSAvICgyICogKHRocmVzaG9sZCh2YWx1ZXMsIDAuNzUpIC0gdGhyZXNob2xkKHZhbHVlcywgMC4yNSkpICogTWF0aC5wb3codmFsdWVzLmxlbmd0aCwgLTEgLyAzKSkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzY290dCh2YWx1ZXMsIG1pbiwgbWF4KSB7XHJcbiAgcmV0dXJuIE1hdGguY2VpbCgobWF4IC0gbWluKSAvICgzLjUgKiBkZXZpYXRpb24odmFsdWVzKSAqIE1hdGgucG93KHZhbHVlcy5sZW5ndGgsIC0xIC8gMykpKTtcclxufVxyXG5cclxuZnVuY3Rpb24gbWF4KHZhbHVlcywgdmFsdWVvZikge1xyXG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aCxcclxuICAgICAgaSA9IC0xLFxyXG4gICAgICB2YWx1ZSxcclxuICAgICAgbWF4O1xyXG5cclxuICBpZiAodmFsdWVvZiA9PSBudWxsKSB7XHJcbiAgICB3aGlsZSAoKytpIDwgbikgeyAvLyBGaW5kIHRoZSBmaXJzdCBjb21wYXJhYmxlIHZhbHVlLlxyXG4gICAgICBpZiAoKHZhbHVlID0gdmFsdWVzW2ldKSAhPSBudWxsICYmIHZhbHVlID49IHZhbHVlKSB7XHJcbiAgICAgICAgbWF4ID0gdmFsdWU7XHJcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIHsgLy8gQ29tcGFyZSB0aGUgcmVtYWluaW5nIHZhbHVlcy5cclxuICAgICAgICAgIGlmICgodmFsdWUgPSB2YWx1ZXNbaV0pICE9IG51bGwgJiYgdmFsdWUgPiBtYXgpIHtcclxuICAgICAgICAgICAgbWF4ID0gdmFsdWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBlbHNlIHtcclxuICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIEZpbmQgdGhlIGZpcnN0IGNvbXBhcmFibGUgdmFsdWUuXHJcbiAgICAgIGlmICgodmFsdWUgPSB2YWx1ZW9mKHZhbHVlc1tpXSwgaSwgdmFsdWVzKSkgIT0gbnVsbCAmJiB2YWx1ZSA+PSB2YWx1ZSkge1xyXG4gICAgICAgIG1heCA9IHZhbHVlO1xyXG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIENvbXBhcmUgdGhlIHJlbWFpbmluZyB2YWx1ZXMuXHJcbiAgICAgICAgICBpZiAoKHZhbHVlID0gdmFsdWVvZih2YWx1ZXNbaV0sIGksIHZhbHVlcykpICE9IG51bGwgJiYgdmFsdWUgPiBtYXgpIHtcclxuICAgICAgICAgICAgbWF4ID0gdmFsdWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbWF4O1xyXG59XHJcblxyXG5mdW5jdGlvbiBtZWFuKHZhbHVlcywgdmFsdWVvZikge1xyXG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aCxcclxuICAgICAgbSA9IG4sXHJcbiAgICAgIGkgPSAtMSxcclxuICAgICAgdmFsdWUsXHJcbiAgICAgIHN1bSA9IDA7XHJcblxyXG4gIGlmICh2YWx1ZW9mID09IG51bGwpIHtcclxuICAgIHdoaWxlICgrK2kgPCBuKSB7XHJcbiAgICAgIGlmICghaXNOYU4odmFsdWUgPSBudW1iZXIodmFsdWVzW2ldKSkpIHN1bSArPSB2YWx1ZTtcclxuICAgICAgZWxzZSAtLW07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBlbHNlIHtcclxuICAgIHdoaWxlICgrK2kgPCBuKSB7XHJcbiAgICAgIGlmICghaXNOYU4odmFsdWUgPSBudW1iZXIodmFsdWVvZih2YWx1ZXNbaV0sIGksIHZhbHVlcykpKSkgc3VtICs9IHZhbHVlO1xyXG4gICAgICBlbHNlIC0tbTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChtKSByZXR1cm4gc3VtIC8gbTtcclxufVxyXG5cclxuZnVuY3Rpb24gbWVkaWFuKHZhbHVlcywgdmFsdWVvZikge1xyXG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aCxcclxuICAgICAgaSA9IC0xLFxyXG4gICAgICB2YWx1ZSxcclxuICAgICAgbnVtYmVycyA9IFtdO1xyXG5cclxuICBpZiAodmFsdWVvZiA9PSBudWxsKSB7XHJcbiAgICB3aGlsZSAoKytpIDwgbikge1xyXG4gICAgICBpZiAoIWlzTmFOKHZhbHVlID0gbnVtYmVyKHZhbHVlc1tpXSkpKSB7XHJcbiAgICAgICAgbnVtYmVycy5wdXNoKHZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZWxzZSB7XHJcbiAgICB3aGlsZSAoKytpIDwgbikge1xyXG4gICAgICBpZiAoIWlzTmFOKHZhbHVlID0gbnVtYmVyKHZhbHVlb2YodmFsdWVzW2ldLCBpLCB2YWx1ZXMpKSkpIHtcclxuICAgICAgICBudW1iZXJzLnB1c2godmFsdWUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhyZXNob2xkKG51bWJlcnMuc29ydChhc2NlbmRpbmcpLCAwLjUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBtZXJnZShhcnJheXMpIHtcclxuICB2YXIgbiA9IGFycmF5cy5sZW5ndGgsXHJcbiAgICAgIG0sXHJcbiAgICAgIGkgPSAtMSxcclxuICAgICAgaiA9IDAsXHJcbiAgICAgIG1lcmdlZCxcclxuICAgICAgYXJyYXk7XHJcblxyXG4gIHdoaWxlICgrK2kgPCBuKSBqICs9IGFycmF5c1tpXS5sZW5ndGg7XHJcbiAgbWVyZ2VkID0gbmV3IEFycmF5KGopO1xyXG5cclxuICB3aGlsZSAoLS1uID49IDApIHtcclxuICAgIGFycmF5ID0gYXJyYXlzW25dO1xyXG4gICAgbSA9IGFycmF5Lmxlbmd0aDtcclxuICAgIHdoaWxlICgtLW0gPj0gMCkge1xyXG4gICAgICBtZXJnZWRbLS1qXSA9IGFycmF5W21dO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG1lcmdlZDtcclxufVxyXG5cclxuZnVuY3Rpb24gbWluKHZhbHVlcywgdmFsdWVvZikge1xyXG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aCxcclxuICAgICAgaSA9IC0xLFxyXG4gICAgICB2YWx1ZSxcclxuICAgICAgbWluO1xyXG5cclxuICBpZiAodmFsdWVvZiA9PSBudWxsKSB7XHJcbiAgICB3aGlsZSAoKytpIDwgbikgeyAvLyBGaW5kIHRoZSBmaXJzdCBjb21wYXJhYmxlIHZhbHVlLlxyXG4gICAgICBpZiAoKHZhbHVlID0gdmFsdWVzW2ldKSAhPSBudWxsICYmIHZhbHVlID49IHZhbHVlKSB7XHJcbiAgICAgICAgbWluID0gdmFsdWU7XHJcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIHsgLy8gQ29tcGFyZSB0aGUgcmVtYWluaW5nIHZhbHVlcy5cclxuICAgICAgICAgIGlmICgodmFsdWUgPSB2YWx1ZXNbaV0pICE9IG51bGwgJiYgbWluID4gdmFsdWUpIHtcclxuICAgICAgICAgICAgbWluID0gdmFsdWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBlbHNlIHtcclxuICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIEZpbmQgdGhlIGZpcnN0IGNvbXBhcmFibGUgdmFsdWUuXHJcbiAgICAgIGlmICgodmFsdWUgPSB2YWx1ZW9mKHZhbHVlc1tpXSwgaSwgdmFsdWVzKSkgIT0gbnVsbCAmJiB2YWx1ZSA+PSB2YWx1ZSkge1xyXG4gICAgICAgIG1pbiA9IHZhbHVlO1xyXG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIENvbXBhcmUgdGhlIHJlbWFpbmluZyB2YWx1ZXMuXHJcbiAgICAgICAgICBpZiAoKHZhbHVlID0gdmFsdWVvZih2YWx1ZXNbaV0sIGksIHZhbHVlcykpICE9IG51bGwgJiYgbWluID4gdmFsdWUpIHtcclxuICAgICAgICAgICAgbWluID0gdmFsdWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbWluO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwZXJtdXRlKGFycmF5LCBpbmRleGVzKSB7XHJcbiAgdmFyIGkgPSBpbmRleGVzLmxlbmd0aCwgcGVybXV0ZXMgPSBuZXcgQXJyYXkoaSk7XHJcbiAgd2hpbGUgKGktLSkgcGVybXV0ZXNbaV0gPSBhcnJheVtpbmRleGVzW2ldXTtcclxuICByZXR1cm4gcGVybXV0ZXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNjYW4odmFsdWVzLCBjb21wYXJlKSB7XHJcbiAgaWYgKCEobiA9IHZhbHVlcy5sZW5ndGgpKSByZXR1cm47XHJcbiAgdmFyIG4sXHJcbiAgICAgIGkgPSAwLFxyXG4gICAgICBqID0gMCxcclxuICAgICAgeGksXHJcbiAgICAgIHhqID0gdmFsdWVzW2pdO1xyXG5cclxuICBpZiAoY29tcGFyZSA9PSBudWxsKSBjb21wYXJlID0gYXNjZW5kaW5nO1xyXG5cclxuICB3aGlsZSAoKytpIDwgbikge1xyXG4gICAgaWYgKGNvbXBhcmUoeGkgPSB2YWx1ZXNbaV0sIHhqKSA8IDAgfHwgY29tcGFyZSh4aiwgeGopICE9PSAwKSB7XHJcbiAgICAgIHhqID0geGksIGogPSBpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKGNvbXBhcmUoeGosIHhqKSA9PT0gMCkgcmV0dXJuIGo7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNodWZmbGUoYXJyYXksIGkwLCBpMSkge1xyXG4gIHZhciBtID0gKGkxID09IG51bGwgPyBhcnJheS5sZW5ndGggOiBpMSkgLSAoaTAgPSBpMCA9PSBudWxsID8gMCA6ICtpMCksXHJcbiAgICAgIHQsXHJcbiAgICAgIGk7XHJcblxyXG4gIHdoaWxlIChtKSB7XHJcbiAgICBpID0gTWF0aC5yYW5kb20oKSAqIG0tLSB8IDA7XHJcbiAgICB0ID0gYXJyYXlbbSArIGkwXTtcclxuICAgIGFycmF5W20gKyBpMF0gPSBhcnJheVtpICsgaTBdO1xyXG4gICAgYXJyYXlbaSArIGkwXSA9IHQ7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gYXJyYXk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN1bSh2YWx1ZXMsIHZhbHVlb2YpIHtcclxuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGgsXHJcbiAgICAgIGkgPSAtMSxcclxuICAgICAgdmFsdWUsXHJcbiAgICAgIHN1bSA9IDA7XHJcblxyXG4gIGlmICh2YWx1ZW9mID09IG51bGwpIHtcclxuICAgIHdoaWxlICgrK2kgPCBuKSB7XHJcbiAgICAgIGlmICh2YWx1ZSA9ICt2YWx1ZXNbaV0pIHN1bSArPSB2YWx1ZTsgLy8gTm90ZTogemVybyBhbmQgbnVsbCBhcmUgZXF1aXZhbGVudC5cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGVsc2Uge1xyXG4gICAgd2hpbGUgKCsraSA8IG4pIHtcclxuICAgICAgaWYgKHZhbHVlID0gK3ZhbHVlb2YodmFsdWVzW2ldLCBpLCB2YWx1ZXMpKSBzdW0gKz0gdmFsdWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3VtO1xyXG59XHJcblxyXG5mdW5jdGlvbiB0cmFuc3Bvc2UobWF0cml4KSB7XHJcbiAgaWYgKCEobiA9IG1hdHJpeC5sZW5ndGgpKSByZXR1cm4gW107XHJcbiAgZm9yICh2YXIgaSA9IC0xLCBtID0gbWluKG1hdHJpeCwgbGVuZ3RoKSwgdHJhbnNwb3NlID0gbmV3IEFycmF5KG0pOyArK2kgPCBtOykge1xyXG4gICAgZm9yICh2YXIgaiA9IC0xLCBuLCByb3cgPSB0cmFuc3Bvc2VbaV0gPSBuZXcgQXJyYXkobik7ICsraiA8IG47KSB7XHJcbiAgICAgIHJvd1tqXSA9IG1hdHJpeFtqXVtpXTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHRyYW5zcG9zZTtcclxufVxyXG5cclxuZnVuY3Rpb24gbGVuZ3RoKGQpIHtcclxuICByZXR1cm4gZC5sZW5ndGg7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHppcCgpIHtcclxuICByZXR1cm4gdHJhbnNwb3NlKGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbnZhciBzbGljZSQxID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xyXG5cclxuZnVuY3Rpb24gaWRlbnRpdHkkMSh4KSB7XHJcbiAgcmV0dXJuIHg7XHJcbn1cclxuXHJcbnZhciB0b3AgPSAxLFxyXG4gICAgcmlnaHQgPSAyLFxyXG4gICAgYm90dG9tID0gMyxcclxuICAgIGxlZnQgPSA0LFxyXG4gICAgZXBzaWxvbiA9IDFlLTY7XHJcblxyXG5mdW5jdGlvbiB0cmFuc2xhdGVYKHgpIHtcclxuICByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyAoeCArIDAuNSkgKyBcIiwwKVwiO1xyXG59XHJcblxyXG5mdW5jdGlvbiB0cmFuc2xhdGVZKHkpIHtcclxuICByZXR1cm4gXCJ0cmFuc2xhdGUoMCxcIiArICh5ICsgMC41KSArIFwiKVwiO1xyXG59XHJcblxyXG5mdW5jdGlvbiBudW1iZXIkMShzY2FsZSkge1xyXG4gIHJldHVybiBmdW5jdGlvbihkKSB7XHJcbiAgICByZXR1cm4gK3NjYWxlKGQpO1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNlbnRlcihzY2FsZSkge1xyXG4gIHZhciBvZmZzZXQgPSBNYXRoLm1heCgwLCBzY2FsZS5iYW5kd2lkdGgoKSAtIDEpIC8gMjsgLy8gQWRqdXN0IGZvciAwLjVweCBvZmZzZXQuXHJcbiAgaWYgKHNjYWxlLnJvdW5kKCkpIG9mZnNldCA9IE1hdGgucm91bmQob2Zmc2V0KTtcclxuICByZXR1cm4gZnVuY3Rpb24oZCkge1xyXG4gICAgcmV0dXJuICtzY2FsZShkKSArIG9mZnNldDtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBlbnRlcmluZygpIHtcclxuICByZXR1cm4gIXRoaXMuX19heGlzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBheGlzKG9yaWVudCwgc2NhbGUpIHtcclxuICB2YXIgdGlja0FyZ3VtZW50cyA9IFtdLFxyXG4gICAgICB0aWNrVmFsdWVzID0gbnVsbCxcclxuICAgICAgdGlja0Zvcm1hdCA9IG51bGwsXHJcbiAgICAgIHRpY2tTaXplSW5uZXIgPSA2LFxyXG4gICAgICB0aWNrU2l6ZU91dGVyID0gNixcclxuICAgICAgdGlja1BhZGRpbmcgPSAzLFxyXG4gICAgICBrID0gb3JpZW50ID09PSB0b3AgfHwgb3JpZW50ID09PSBsZWZ0ID8gLTEgOiAxLFxyXG4gICAgICB4ID0gb3JpZW50ID09PSBsZWZ0IHx8IG9yaWVudCA9PT0gcmlnaHQgPyBcInhcIiA6IFwieVwiLFxyXG4gICAgICB0cmFuc2Zvcm0gPSBvcmllbnQgPT09IHRvcCB8fCBvcmllbnQgPT09IGJvdHRvbSA/IHRyYW5zbGF0ZVggOiB0cmFuc2xhdGVZO1xyXG5cclxuICBmdW5jdGlvbiBheGlzKGNvbnRleHQpIHtcclxuICAgIHZhciB2YWx1ZXMgPSB0aWNrVmFsdWVzID09IG51bGwgPyAoc2NhbGUudGlja3MgPyBzY2FsZS50aWNrcy5hcHBseShzY2FsZSwgdGlja0FyZ3VtZW50cykgOiBzY2FsZS5kb21haW4oKSkgOiB0aWNrVmFsdWVzLFxyXG4gICAgICAgIGZvcm1hdCA9IHRpY2tGb3JtYXQgPT0gbnVsbCA/IChzY2FsZS50aWNrRm9ybWF0ID8gc2NhbGUudGlja0Zvcm1hdC5hcHBseShzY2FsZSwgdGlja0FyZ3VtZW50cykgOiBpZGVudGl0eSQxKSA6IHRpY2tGb3JtYXQsXHJcbiAgICAgICAgc3BhY2luZyA9IE1hdGgubWF4KHRpY2tTaXplSW5uZXIsIDApICsgdGlja1BhZGRpbmcsXHJcbiAgICAgICAgcmFuZ2UgPSBzY2FsZS5yYW5nZSgpLFxyXG4gICAgICAgIHJhbmdlMCA9ICtyYW5nZVswXSArIDAuNSxcclxuICAgICAgICByYW5nZTEgPSArcmFuZ2VbcmFuZ2UubGVuZ3RoIC0gMV0gKyAwLjUsXHJcbiAgICAgICAgcG9zaXRpb24gPSAoc2NhbGUuYmFuZHdpZHRoID8gY2VudGVyIDogbnVtYmVyJDEpKHNjYWxlLmNvcHkoKSksXHJcbiAgICAgICAgc2VsZWN0aW9uID0gY29udGV4dC5zZWxlY3Rpb24gPyBjb250ZXh0LnNlbGVjdGlvbigpIDogY29udGV4dCxcclxuICAgICAgICBwYXRoID0gc2VsZWN0aW9uLnNlbGVjdEFsbChcIi5kb21haW5cIikuZGF0YShbbnVsbF0pLFxyXG4gICAgICAgIHRpY2sgPSBzZWxlY3Rpb24uc2VsZWN0QWxsKFwiLnRpY2tcIikuZGF0YSh2YWx1ZXMsIHNjYWxlKS5vcmRlcigpLFxyXG4gICAgICAgIHRpY2tFeGl0ID0gdGljay5leGl0KCksXHJcbiAgICAgICAgdGlja0VudGVyID0gdGljay5lbnRlcigpLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIFwidGlja1wiKSxcclxuICAgICAgICBsaW5lID0gdGljay5zZWxlY3QoXCJsaW5lXCIpLFxyXG4gICAgICAgIHRleHQgPSB0aWNrLnNlbGVjdChcInRleHRcIik7XHJcblxyXG4gICAgcGF0aCA9IHBhdGgubWVyZ2UocGF0aC5lbnRlcigpLmluc2VydChcInBhdGhcIiwgXCIudGlja1wiKVxyXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJkb21haW5cIilcclxuICAgICAgICAuYXR0cihcInN0cm9rZVwiLCBcIiMwMDBcIikpO1xyXG5cclxuICAgIHRpY2sgPSB0aWNrLm1lcmdlKHRpY2tFbnRlcik7XHJcblxyXG4gICAgbGluZSA9IGxpbmUubWVyZ2UodGlja0VudGVyLmFwcGVuZChcImxpbmVcIilcclxuICAgICAgICAuYXR0cihcInN0cm9rZVwiLCBcIiMwMDBcIilcclxuICAgICAgICAuYXR0cih4ICsgXCIyXCIsIGsgKiB0aWNrU2l6ZUlubmVyKSk7XHJcblxyXG4gICAgdGV4dCA9IHRleHQubWVyZ2UodGlja0VudGVyLmFwcGVuZChcInRleHRcIilcclxuICAgICAgICAuYXR0cihcImZpbGxcIiwgXCIjMDAwXCIpXHJcbiAgICAgICAgLmF0dHIoeCwgayAqIHNwYWNpbmcpXHJcbiAgICAgICAgLmF0dHIoXCJkeVwiLCBvcmllbnQgPT09IHRvcCA/IFwiMGVtXCIgOiBvcmllbnQgPT09IGJvdHRvbSA/IFwiMC43MWVtXCIgOiBcIjAuMzJlbVwiKSk7XHJcblxyXG4gICAgaWYgKGNvbnRleHQgIT09IHNlbGVjdGlvbikge1xyXG4gICAgICBwYXRoID0gcGF0aC50cmFuc2l0aW9uKGNvbnRleHQpO1xyXG4gICAgICB0aWNrID0gdGljay50cmFuc2l0aW9uKGNvbnRleHQpO1xyXG4gICAgICBsaW5lID0gbGluZS50cmFuc2l0aW9uKGNvbnRleHQpO1xyXG4gICAgICB0ZXh0ID0gdGV4dC50cmFuc2l0aW9uKGNvbnRleHQpO1xyXG5cclxuICAgICAgdGlja0V4aXQgPSB0aWNrRXhpdC50cmFuc2l0aW9uKGNvbnRleHQpXHJcbiAgICAgICAgICAuYXR0cihcIm9wYWNpdHlcIiwgZXBzaWxvbilcclxuICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGlzRmluaXRlKGQgPSBwb3NpdGlvbihkKSkgPyB0cmFuc2Zvcm0oZCkgOiB0aGlzLmdldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKTsgfSk7XHJcblxyXG4gICAgICB0aWNrRW50ZXJcclxuICAgICAgICAgIC5hdHRyKFwib3BhY2l0eVwiLCBlcHNpbG9uKVxyXG4gICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24oZCkgeyB2YXIgcCA9IHRoaXMucGFyZW50Tm9kZS5fX2F4aXM7IHJldHVybiB0cmFuc2Zvcm0ocCAmJiBpc0Zpbml0ZShwID0gcChkKSkgPyBwIDogcG9zaXRpb24oZCkpOyB9KTtcclxuICAgIH1cclxuXHJcbiAgICB0aWNrRXhpdC5yZW1vdmUoKTtcclxuXHJcbiAgICBwYXRoXHJcbiAgICAgICAgLmF0dHIoXCJkXCIsIG9yaWVudCA9PT0gbGVmdCB8fCBvcmllbnQgPT0gcmlnaHRcclxuICAgICAgICAgICAgPyBcIk1cIiArIGsgKiB0aWNrU2l6ZU91dGVyICsgXCIsXCIgKyByYW5nZTAgKyBcIkgwLjVWXCIgKyByYW5nZTEgKyBcIkhcIiArIGsgKiB0aWNrU2l6ZU91dGVyXHJcbiAgICAgICAgICAgIDogXCJNXCIgKyByYW5nZTAgKyBcIixcIiArIGsgKiB0aWNrU2l6ZU91dGVyICsgXCJWMC41SFwiICsgcmFuZ2UxICsgXCJWXCIgKyBrICogdGlja1NpemVPdXRlcik7XHJcblxyXG4gICAgdGlja1xyXG4gICAgICAgIC5hdHRyKFwib3BhY2l0eVwiLCAxKVxyXG4gICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIHRyYW5zZm9ybShwb3NpdGlvbihkKSk7IH0pO1xyXG5cclxuICAgIGxpbmVcclxuICAgICAgICAuYXR0cih4ICsgXCIyXCIsIGsgKiB0aWNrU2l6ZUlubmVyKTtcclxuXHJcbiAgICB0ZXh0XHJcbiAgICAgICAgLmF0dHIoeCwgayAqIHNwYWNpbmcpXHJcbiAgICAgICAgLnRleHQoZm9ybWF0KTtcclxuXHJcbiAgICBzZWxlY3Rpb24uZmlsdGVyKGVudGVyaW5nKVxyXG4gICAgICAgIC5hdHRyKFwiZmlsbFwiLCBcIm5vbmVcIilcclxuICAgICAgICAuYXR0cihcImZvbnQtc2l6ZVwiLCAxMClcclxuICAgICAgICAuYXR0cihcImZvbnQtZmFtaWx5XCIsIFwic2Fucy1zZXJpZlwiKVxyXG4gICAgICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgb3JpZW50ID09PSByaWdodCA/IFwic3RhcnRcIiA6IG9yaWVudCA9PT0gbGVmdCA/IFwiZW5kXCIgOiBcIm1pZGRsZVwiKTtcclxuXHJcbiAgICBzZWxlY3Rpb25cclxuICAgICAgICAuZWFjaChmdW5jdGlvbigpIHsgdGhpcy5fX2F4aXMgPSBwb3NpdGlvbjsgfSk7XHJcbiAgfVxyXG5cclxuICBheGlzLnNjYWxlID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc2NhbGUgPSBfLCBheGlzKSA6IHNjYWxlO1xyXG4gIH07XHJcblxyXG4gIGF4aXMudGlja3MgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aWNrQXJndW1lbnRzID0gc2xpY2UkMS5jYWxsKGFyZ3VtZW50cyksIGF4aXM7XHJcbiAgfTtcclxuXHJcbiAgYXhpcy50aWNrQXJndW1lbnRzID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGlja0FyZ3VtZW50cyA9IF8gPT0gbnVsbCA/IFtdIDogc2xpY2UkMS5jYWxsKF8pLCBheGlzKSA6IHRpY2tBcmd1bWVudHMuc2xpY2UoKTtcclxuICB9O1xyXG5cclxuICBheGlzLnRpY2tWYWx1ZXMgPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aWNrVmFsdWVzID0gXyA9PSBudWxsID8gbnVsbCA6IHNsaWNlJDEuY2FsbChfKSwgYXhpcykgOiB0aWNrVmFsdWVzICYmIHRpY2tWYWx1ZXMuc2xpY2UoKTtcclxuICB9O1xyXG5cclxuICBheGlzLnRpY2tGb3JtYXQgPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aWNrRm9ybWF0ID0gXywgYXhpcykgOiB0aWNrRm9ybWF0O1xyXG4gIH07XHJcblxyXG4gIGF4aXMudGlja1NpemUgPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aWNrU2l6ZUlubmVyID0gdGlja1NpemVPdXRlciA9ICtfLCBheGlzKSA6IHRpY2tTaXplSW5uZXI7XHJcbiAgfTtcclxuXHJcbiAgYXhpcy50aWNrU2l6ZUlubmVyID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGlja1NpemVJbm5lciA9ICtfLCBheGlzKSA6IHRpY2tTaXplSW5uZXI7XHJcbiAgfTtcclxuXHJcbiAgYXhpcy50aWNrU2l6ZU91dGVyID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGlja1NpemVPdXRlciA9ICtfLCBheGlzKSA6IHRpY2tTaXplT3V0ZXI7XHJcbiAgfTtcclxuXHJcbiAgYXhpcy50aWNrUGFkZGluZyA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRpY2tQYWRkaW5nID0gK18sIGF4aXMpIDogdGlja1BhZGRpbmc7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIGF4aXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGF4aXNUb3Aoc2NhbGUpIHtcclxuICByZXR1cm4gYXhpcyh0b3AsIHNjYWxlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gYXhpc1JpZ2h0KHNjYWxlKSB7XHJcbiAgcmV0dXJuIGF4aXMocmlnaHQsIHNjYWxlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gYXhpc0JvdHRvbShzY2FsZSkge1xyXG4gIHJldHVybiBheGlzKGJvdHRvbSwgc2NhbGUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBheGlzTGVmdChzY2FsZSkge1xyXG4gIHJldHVybiBheGlzKGxlZnQsIHNjYWxlKTtcclxufVxyXG5cclxudmFyIG5vb3AgPSB7dmFsdWU6IGZ1bmN0aW9uKCkge319O1xyXG5cclxuZnVuY3Rpb24gZGlzcGF0Y2goKSB7XHJcbiAgZm9yICh2YXIgaSA9IDAsIG4gPSBhcmd1bWVudHMubGVuZ3RoLCBfID0ge30sIHQ7IGkgPCBuOyArK2kpIHtcclxuICAgIGlmICghKHQgPSBhcmd1bWVudHNbaV0gKyBcIlwiKSB8fCAodCBpbiBfKSkgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCB0eXBlOiBcIiArIHQpO1xyXG4gICAgX1t0XSA9IFtdO1xyXG4gIH1cclxuICByZXR1cm4gbmV3IERpc3BhdGNoKF8pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBEaXNwYXRjaChfKSB7XHJcbiAgdGhpcy5fID0gXztcclxufVxyXG5cclxuZnVuY3Rpb24gcGFyc2VUeXBlbmFtZXModHlwZW5hbWVzLCB0eXBlcykge1xyXG4gIHJldHVybiB0eXBlbmFtZXMudHJpbSgpLnNwbGl0KC9efFxccysvKS5tYXAoZnVuY3Rpb24odCkge1xyXG4gICAgdmFyIG5hbWUgPSBcIlwiLCBpID0gdC5pbmRleE9mKFwiLlwiKTtcclxuICAgIGlmIChpID49IDApIG5hbWUgPSB0LnNsaWNlKGkgKyAxKSwgdCA9IHQuc2xpY2UoMCwgaSk7XHJcbiAgICBpZiAodCAmJiAhdHlwZXMuaGFzT3duUHJvcGVydHkodCkpIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIgKyB0KTtcclxuICAgIHJldHVybiB7dHlwZTogdCwgbmFtZTogbmFtZX07XHJcbiAgfSk7XHJcbn1cclxuXHJcbkRpc3BhdGNoLnByb3RvdHlwZSA9IGRpc3BhdGNoLnByb3RvdHlwZSA9IHtcclxuICBjb25zdHJ1Y3RvcjogRGlzcGF0Y2gsXHJcbiAgb246IGZ1bmN0aW9uKHR5cGVuYW1lLCBjYWxsYmFjaykge1xyXG4gICAgdmFyIF8gPSB0aGlzLl8sXHJcbiAgICAgICAgVCA9IHBhcnNlVHlwZW5hbWVzKHR5cGVuYW1lICsgXCJcIiwgXyksXHJcbiAgICAgICAgdCxcclxuICAgICAgICBpID0gLTEsXHJcbiAgICAgICAgbiA9IFQubGVuZ3RoO1xyXG5cclxuICAgIC8vIElmIG5vIGNhbGxiYWNrIHdhcyBzcGVjaWZpZWQsIHJldHVybiB0aGUgY2FsbGJhY2sgb2YgdGhlIGdpdmVuIHR5cGUgYW5kIG5hbWUuXHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcclxuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgodCA9ICh0eXBlbmFtZSA9IFRbaV0pLnR5cGUpICYmICh0ID0gZ2V0KF9bdF0sIHR5cGVuYW1lLm5hbWUpKSkgcmV0dXJuIHQ7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJZiBhIHR5cGUgd2FzIHNwZWNpZmllZCwgc2V0IHRoZSBjYWxsYmFjayBmb3IgdGhlIGdpdmVuIHR5cGUgYW5kIG5hbWUuXHJcbiAgICAvLyBPdGhlcndpc2UsIGlmIGEgbnVsbCBjYWxsYmFjayB3YXMgc3BlY2lmaWVkLCByZW1vdmUgY2FsbGJhY2tzIG9mIHRoZSBnaXZlbiBuYW1lLlxyXG4gICAgaWYgKGNhbGxiYWNrICE9IG51bGwgJiYgdHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgY2FsbGJhY2s6IFwiICsgY2FsbGJhY2spO1xyXG4gICAgd2hpbGUgKCsraSA8IG4pIHtcclxuICAgICAgaWYgKHQgPSAodHlwZW5hbWUgPSBUW2ldKS50eXBlKSBfW3RdID0gc2V0KF9bdF0sIHR5cGVuYW1lLm5hbWUsIGNhbGxiYWNrKTtcclxuICAgICAgZWxzZSBpZiAoY2FsbGJhY2sgPT0gbnVsbCkgZm9yICh0IGluIF8pIF9bdF0gPSBzZXQoX1t0XSwgdHlwZW5hbWUubmFtZSwgbnVsbCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSxcclxuICBjb3B5OiBmdW5jdGlvbigpIHtcclxuICAgIHZhciBjb3B5ID0ge30sIF8gPSB0aGlzLl87XHJcbiAgICBmb3IgKHZhciB0IGluIF8pIGNvcHlbdF0gPSBfW3RdLnNsaWNlKCk7XHJcbiAgICByZXR1cm4gbmV3IERpc3BhdGNoKGNvcHkpO1xyXG4gIH0sXHJcbiAgY2FsbDogZnVuY3Rpb24odHlwZSwgdGhhdCkge1xyXG4gICAgaWYgKChuID0gYXJndW1lbnRzLmxlbmd0aCAtIDIpID4gMCkgZm9yICh2YXIgYXJncyA9IG5ldyBBcnJheShuKSwgaSA9IDAsIG4sIHQ7IGkgPCBuOyArK2kpIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xyXG4gICAgaWYgKCF0aGlzLl8uaGFzT3duUHJvcGVydHkodHlwZSkpIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIgKyB0eXBlKTtcclxuICAgIGZvciAodCA9IHRoaXMuX1t0eXBlXSwgaSA9IDAsIG4gPSB0Lmxlbmd0aDsgaSA8IG47ICsraSkgdFtpXS52YWx1ZS5hcHBseSh0aGF0LCBhcmdzKTtcclxuICB9LFxyXG4gIGFwcGx5OiBmdW5jdGlvbih0eXBlLCB0aGF0LCBhcmdzKSB7XHJcbiAgICBpZiAoIXRoaXMuXy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIiArIHR5cGUpO1xyXG4gICAgZm9yICh2YXIgdCA9IHRoaXMuX1t0eXBlXSwgaSA9IDAsIG4gPSB0Lmxlbmd0aDsgaSA8IG47ICsraSkgdFtpXS52YWx1ZS5hcHBseSh0aGF0LCBhcmdzKTtcclxuICB9XHJcbn07XHJcblxyXG5mdW5jdGlvbiBnZXQodHlwZSwgbmFtZSkge1xyXG4gIGZvciAodmFyIGkgPSAwLCBuID0gdHlwZS5sZW5ndGgsIGM7IGkgPCBuOyArK2kpIHtcclxuICAgIGlmICgoYyA9IHR5cGVbaV0pLm5hbWUgPT09IG5hbWUpIHtcclxuICAgICAgcmV0dXJuIGMudmFsdWU7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBzZXQodHlwZSwgbmFtZSwgY2FsbGJhY2spIHtcclxuICBmb3IgKHZhciBpID0gMCwgbiA9IHR5cGUubGVuZ3RoOyBpIDwgbjsgKytpKSB7XHJcbiAgICBpZiAodHlwZVtpXS5uYW1lID09PSBuYW1lKSB7XHJcbiAgICAgIHR5cGVbaV0gPSBub29wLCB0eXBlID0gdHlwZS5zbGljZSgwLCBpKS5jb25jYXQodHlwZS5zbGljZShpICsgMSkpO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcbiAgaWYgKGNhbGxiYWNrICE9IG51bGwpIHR5cGUucHVzaCh7bmFtZTogbmFtZSwgdmFsdWU6IGNhbGxiYWNrfSk7XHJcbiAgcmV0dXJuIHR5cGU7XHJcbn1cclxuXHJcbnZhciB4aHRtbCA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiO1xyXG5cclxudmFyIG5hbWVzcGFjZXMgPSB7XHJcbiAgc3ZnOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXHJcbiAgeGh0bWw6IHhodG1sLFxyXG4gIHhsaW5rOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIixcclxuICB4bWw6IFwiaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlXCIsXHJcbiAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy9cIlxyXG59O1xyXG5cclxuZnVuY3Rpb24gbmFtZXNwYWNlKG5hbWUpIHtcclxuICB2YXIgcHJlZml4ID0gbmFtZSArPSBcIlwiLCBpID0gcHJlZml4LmluZGV4T2YoXCI6XCIpO1xyXG4gIGlmIChpID49IDAgJiYgKHByZWZpeCA9IG5hbWUuc2xpY2UoMCwgaSkpICE9PSBcInhtbG5zXCIpIG5hbWUgPSBuYW1lLnNsaWNlKGkgKyAxKTtcclxuICByZXR1cm4gbmFtZXNwYWNlcy5oYXNPd25Qcm9wZXJ0eShwcmVmaXgpID8ge3NwYWNlOiBuYW1lc3BhY2VzW3ByZWZpeF0sIGxvY2FsOiBuYW1lfSA6IG5hbWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0b3JJbmhlcml0KG5hbWUpIHtcclxuICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgZG9jdW1lbnQgPSB0aGlzLm93bmVyRG9jdW1lbnQsXHJcbiAgICAgICAgdXJpID0gdGhpcy5uYW1lc3BhY2VVUkk7XHJcbiAgICByZXR1cm4gdXJpID09PSB4aHRtbCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubmFtZXNwYWNlVVJJID09PSB4aHRtbFxyXG4gICAgICAgID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lKVxyXG4gICAgICAgIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHVyaSwgbmFtZSk7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRvckZpeGVkKGZ1bGxuYW1lKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdG9yKG5hbWUpIHtcclxuICB2YXIgZnVsbG5hbWUgPSBuYW1lc3BhY2UobmFtZSk7XHJcbiAgcmV0dXJuIChmdWxsbmFtZS5sb2NhbFxyXG4gICAgICA/IGNyZWF0b3JGaXhlZFxyXG4gICAgICA6IGNyZWF0b3JJbmhlcml0KShmdWxsbmFtZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5vbmUoKSB7fVxyXG5cclxuZnVuY3Rpb24gc2VsZWN0b3Ioc2VsZWN0b3IpIHtcclxuICByZXR1cm4gc2VsZWN0b3IgPT0gbnVsbCA/IG5vbmUgOiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNlbGVjdGlvbl9zZWxlY3Qoc2VsZWN0KSB7XHJcbiAgaWYgKHR5cGVvZiBzZWxlY3QgIT09IFwiZnVuY3Rpb25cIikgc2VsZWN0ID0gc2VsZWN0b3Ioc2VsZWN0KTtcclxuXHJcbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xyXG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIHN1Ymdyb3VwID0gc3ViZ3JvdXBzW2pdID0gbmV3IEFycmF5KG4pLCBub2RlLCBzdWJub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xyXG4gICAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgKHN1Ym5vZGUgPSBzZWxlY3QuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCkpKSB7XHJcbiAgICAgICAgaWYgKFwiX19kYXRhX19cIiBpbiBub2RlKSBzdWJub2RlLl9fZGF0YV9fID0gbm9kZS5fX2RhdGFfXztcclxuICAgICAgICBzdWJncm91cFtpXSA9IHN1Ym5vZGU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHN1Ymdyb3VwcywgdGhpcy5fcGFyZW50cyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVtcHR5KCkge1xyXG4gIHJldHVybiBbXTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2VsZWN0b3JBbGwoc2VsZWN0b3IpIHtcclxuICByZXR1cm4gc2VsZWN0b3IgPT0gbnVsbCA/IGVtcHR5IDogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZWxlY3Rpb25fc2VsZWN0QWxsKHNlbGVjdCkge1xyXG4gIGlmICh0eXBlb2Ygc2VsZWN0ICE9PSBcImZ1bmN0aW9uXCIpIHNlbGVjdCA9IHNlbGVjdG9yQWxsKHNlbGVjdCk7XHJcblxyXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IFtdLCBwYXJlbnRzID0gW10sIGogPSAwOyBqIDwgbTsgKytqKSB7XHJcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcclxuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xyXG4gICAgICAgIHN1Ymdyb3Vwcy5wdXNoKHNlbGVjdC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSk7XHJcbiAgICAgICAgcGFyZW50cy5wdXNoKG5vZGUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihzdWJncm91cHMsIHBhcmVudHMpO1xyXG59XHJcblxyXG52YXIgbWF0Y2hlciA9IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubWF0Y2hlcyhzZWxlY3Rvcik7XHJcbiAgfTtcclxufTtcclxuXHJcbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcclxuICBpZiAoIWVsZW1lbnQubWF0Y2hlcykge1xyXG4gICAgdmFyIHZlbmRvck1hdGNoZXMgPSBlbGVtZW50LndlYmtpdE1hdGNoZXNTZWxlY3RvclxyXG4gICAgICAgIHx8IGVsZW1lbnQubXNNYXRjaGVzU2VsZWN0b3JcclxuICAgICAgICB8fCBlbGVtZW50Lm1vek1hdGNoZXNTZWxlY3RvclxyXG4gICAgICAgIHx8IGVsZW1lbnQub01hdGNoZXNTZWxlY3RvcjtcclxuICAgIG1hdGNoZXIgPSBmdW5jdGlvbihzZWxlY3Rvcikge1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHZlbmRvck1hdGNoZXMuY2FsbCh0aGlzLCBzZWxlY3Rvcik7XHJcbiAgICAgIH07XHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG5cclxudmFyIG1hdGNoZXIkMSA9IG1hdGNoZXI7XHJcblxyXG5mdW5jdGlvbiBzZWxlY3Rpb25fZmlsdGVyKG1hdGNoKSB7XHJcbiAgaWYgKHR5cGVvZiBtYXRjaCAhPT0gXCJmdW5jdGlvblwiKSBtYXRjaCA9IG1hdGNoZXIkMShtYXRjaCk7XHJcblxyXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcclxuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBzdWJncm91cCA9IHN1Ymdyb3Vwc1tqXSA9IFtdLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xyXG4gICAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgbWF0Y2guY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCkpIHtcclxuICAgICAgICBzdWJncm91cC5wdXNoKG5vZGUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihzdWJncm91cHMsIHRoaXMuX3BhcmVudHMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzcGFyc2UodXBkYXRlKSB7XHJcbiAgcmV0dXJuIG5ldyBBcnJheSh1cGRhdGUubGVuZ3RoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2VsZWN0aW9uX2VudGVyKCkge1xyXG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHRoaXMuX2VudGVyIHx8IHRoaXMuX2dyb3Vwcy5tYXAoc3BhcnNlKSwgdGhpcy5fcGFyZW50cyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEVudGVyTm9kZShwYXJlbnQsIGRhdHVtKSB7XHJcbiAgdGhpcy5vd25lckRvY3VtZW50ID0gcGFyZW50Lm93bmVyRG9jdW1lbnQ7XHJcbiAgdGhpcy5uYW1lc3BhY2VVUkkgPSBwYXJlbnQubmFtZXNwYWNlVVJJO1xyXG4gIHRoaXMuX25leHQgPSBudWxsO1xyXG4gIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcclxuICB0aGlzLl9fZGF0YV9fID0gZGF0dW07XHJcbn1cclxuXHJcbkVudGVyTm9kZS5wcm90b3R5cGUgPSB7XHJcbiAgY29uc3RydWN0b3I6IEVudGVyTm9kZSxcclxuICBhcHBlbmRDaGlsZDogZnVuY3Rpb24oY2hpbGQpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIHRoaXMuX25leHQpOyB9LFxyXG4gIGluc2VydEJlZm9yZTogZnVuY3Rpb24oY2hpbGQsIG5leHQpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIG5leHQpOyB9LFxyXG4gIHF1ZXJ5U2VsZWN0b3I6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7IHJldHVybiB0aGlzLl9wYXJlbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7IH0sXHJcbiAgcXVlcnlTZWxlY3RvckFsbDogZnVuY3Rpb24oc2VsZWN0b3IpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTsgfVxyXG59O1xyXG5cclxuZnVuY3Rpb24gY29uc3RhbnQkMSh4KSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHg7XHJcbiAgfTtcclxufVxyXG5cclxudmFyIGtleVByZWZpeCA9IFwiJFwiOyAvLyBQcm90ZWN0IGFnYWluc3Qga2V5cyBsaWtlIOKAnF9fcHJvdG9fX+KAnS5cclxuXHJcbmZ1bmN0aW9uIGJpbmRJbmRleChwYXJlbnQsIGdyb3VwLCBlbnRlciwgdXBkYXRlLCBleGl0LCBkYXRhKSB7XHJcbiAgdmFyIGkgPSAwLFxyXG4gICAgICBub2RlLFxyXG4gICAgICBncm91cExlbmd0aCA9IGdyb3VwLmxlbmd0aCxcclxuICAgICAgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xyXG5cclxuICAvLyBQdXQgYW55IG5vbi1udWxsIG5vZGVzIHRoYXQgZml0IGludG8gdXBkYXRlLlxyXG4gIC8vIFB1dCBhbnkgbnVsbCBub2RlcyBpbnRvIGVudGVyLlxyXG4gIC8vIFB1dCBhbnkgcmVtYWluaW5nIGRhdGEgaW50byBlbnRlci5cclxuICBmb3IgKDsgaSA8IGRhdGFMZW5ndGg7ICsraSkge1xyXG4gICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xyXG4gICAgICBub2RlLl9fZGF0YV9fID0gZGF0YVtpXTtcclxuICAgICAgdXBkYXRlW2ldID0gbm9kZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGVudGVyW2ldID0gbmV3IEVudGVyTm9kZShwYXJlbnQsIGRhdGFbaV0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gUHV0IGFueSBub24tbnVsbCBub2RlcyB0aGF0IGRvbuKAmXQgZml0IGludG8gZXhpdC5cclxuICBmb3IgKDsgaSA8IGdyb3VwTGVuZ3RoOyArK2kpIHtcclxuICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcclxuICAgICAgZXhpdFtpXSA9IG5vZGU7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBiaW5kS2V5KHBhcmVudCwgZ3JvdXAsIGVudGVyLCB1cGRhdGUsIGV4aXQsIGRhdGEsIGtleSkge1xyXG4gIHZhciBpLFxyXG4gICAgICBub2RlLFxyXG4gICAgICBub2RlQnlLZXlWYWx1ZSA9IHt9LFxyXG4gICAgICBncm91cExlbmd0aCA9IGdyb3VwLmxlbmd0aCxcclxuICAgICAgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoLFxyXG4gICAgICBrZXlWYWx1ZXMgPSBuZXcgQXJyYXkoZ3JvdXBMZW5ndGgpLFxyXG4gICAgICBrZXlWYWx1ZTtcclxuXHJcbiAgLy8gQ29tcHV0ZSB0aGUga2V5IGZvciBlYWNoIG5vZGUuXHJcbiAgLy8gSWYgbXVsdGlwbGUgbm9kZXMgaGF2ZSB0aGUgc2FtZSBrZXksIHRoZSBkdXBsaWNhdGVzIGFyZSBhZGRlZCB0byBleGl0LlxyXG4gIGZvciAoaSA9IDA7IGkgPCBncm91cExlbmd0aDsgKytpKSB7XHJcbiAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XHJcbiAgICAgIGtleVZhbHVlc1tpXSA9IGtleVZhbHVlID0ga2V5UHJlZml4ICsga2V5LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApO1xyXG4gICAgICBpZiAoa2V5VmFsdWUgaW4gbm9kZUJ5S2V5VmFsdWUpIHtcclxuICAgICAgICBleGl0W2ldID0gbm9kZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBub2RlQnlLZXlWYWx1ZVtrZXlWYWx1ZV0gPSBub2RlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBDb21wdXRlIHRoZSBrZXkgZm9yIGVhY2ggZGF0dW0uXHJcbiAgLy8gSWYgdGhlcmUgYSBub2RlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGtleSwgam9pbiBhbmQgYWRkIGl0IHRvIHVwZGF0ZS5cclxuICAvLyBJZiB0aGVyZSBpcyBub3QgKG9yIHRoZSBrZXkgaXMgYSBkdXBsaWNhdGUpLCBhZGQgaXQgdG8gZW50ZXIuXHJcbiAgZm9yIChpID0gMDsgaSA8IGRhdGFMZW5ndGg7ICsraSkge1xyXG4gICAga2V5VmFsdWUgPSBrZXlQcmVmaXggKyBrZXkuY2FsbChwYXJlbnQsIGRhdGFbaV0sIGksIGRhdGEpO1xyXG4gICAgaWYgKG5vZGUgPSBub2RlQnlLZXlWYWx1ZVtrZXlWYWx1ZV0pIHtcclxuICAgICAgdXBkYXRlW2ldID0gbm9kZTtcclxuICAgICAgbm9kZS5fX2RhdGFfXyA9IGRhdGFbaV07XHJcbiAgICAgIG5vZGVCeUtleVZhbHVlW2tleVZhbHVlXSA9IG51bGw7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBlbnRlcltpXSA9IG5ldyBFbnRlck5vZGUocGFyZW50LCBkYXRhW2ldKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEFkZCBhbnkgcmVtYWluaW5nIG5vZGVzIHRoYXQgd2VyZSBub3QgYm91bmQgdG8gZGF0YSB0byBleGl0LlxyXG4gIGZvciAoaSA9IDA7IGkgPCBncm91cExlbmd0aDsgKytpKSB7XHJcbiAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgKG5vZGVCeUtleVZhbHVlW2tleVZhbHVlc1tpXV0gPT09IG5vZGUpKSB7XHJcbiAgICAgIGV4aXRbaV0gPSBub2RlO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gc2VsZWN0aW9uX2RhdGEodmFsdWUsIGtleSkge1xyXG4gIGlmICghdmFsdWUpIHtcclxuICAgIGRhdGEgPSBuZXcgQXJyYXkodGhpcy5zaXplKCkpLCBqID0gLTE7XHJcbiAgICB0aGlzLmVhY2goZnVuY3Rpb24oZCkgeyBkYXRhWysral0gPSBkOyB9KTtcclxuICAgIHJldHVybiBkYXRhO1xyXG4gIH1cclxuXHJcbiAgdmFyIGJpbmQgPSBrZXkgPyBiaW5kS2V5IDogYmluZEluZGV4LFxyXG4gICAgICBwYXJlbnRzID0gdGhpcy5fcGFyZW50cyxcclxuICAgICAgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzO1xyXG5cclxuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHZhbHVlID0gY29uc3RhbnQkMSh2YWx1ZSk7XHJcblxyXG4gIGZvciAodmFyIG0gPSBncm91cHMubGVuZ3RoLCB1cGRhdGUgPSBuZXcgQXJyYXkobSksIGVudGVyID0gbmV3IEFycmF5KG0pLCBleGl0ID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xyXG4gICAgdmFyIHBhcmVudCA9IHBhcmVudHNbal0sXHJcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbal0sXHJcbiAgICAgICAgZ3JvdXBMZW5ndGggPSBncm91cC5sZW5ndGgsXHJcbiAgICAgICAgZGF0YSA9IHZhbHVlLmNhbGwocGFyZW50LCBwYXJlbnQgJiYgcGFyZW50Ll9fZGF0YV9fLCBqLCBwYXJlbnRzKSxcclxuICAgICAgICBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGgsXHJcbiAgICAgICAgZW50ZXJHcm91cCA9IGVudGVyW2pdID0gbmV3IEFycmF5KGRhdGFMZW5ndGgpLFxyXG4gICAgICAgIHVwZGF0ZUdyb3VwID0gdXBkYXRlW2pdID0gbmV3IEFycmF5KGRhdGFMZW5ndGgpLFxyXG4gICAgICAgIGV4aXRHcm91cCA9IGV4aXRbal0gPSBuZXcgQXJyYXkoZ3JvdXBMZW5ndGgpO1xyXG5cclxuICAgIGJpbmQocGFyZW50LCBncm91cCwgZW50ZXJHcm91cCwgdXBkYXRlR3JvdXAsIGV4aXRHcm91cCwgZGF0YSwga2V5KTtcclxuXHJcbiAgICAvLyBOb3cgY29ubmVjdCB0aGUgZW50ZXIgbm9kZXMgdG8gdGhlaXIgZm9sbG93aW5nIHVwZGF0ZSBub2RlLCBzdWNoIHRoYXRcclxuICAgIC8vIGFwcGVuZENoaWxkIGNhbiBpbnNlcnQgdGhlIG1hdGVyaWFsaXplZCBlbnRlciBub2RlIGJlZm9yZSB0aGlzIG5vZGUsXHJcbiAgICAvLyByYXRoZXIgdGhhbiBhdCB0aGUgZW5kIG9mIHRoZSBwYXJlbnQgbm9kZS5cclxuICAgIGZvciAodmFyIGkwID0gMCwgaTEgPSAwLCBwcmV2aW91cywgbmV4dDsgaTAgPCBkYXRhTGVuZ3RoOyArK2kwKSB7XHJcbiAgICAgIGlmIChwcmV2aW91cyA9IGVudGVyR3JvdXBbaTBdKSB7XHJcbiAgICAgICAgaWYgKGkwID49IGkxKSBpMSA9IGkwICsgMTtcclxuICAgICAgICB3aGlsZSAoIShuZXh0ID0gdXBkYXRlR3JvdXBbaTFdKSAmJiArK2kxIDwgZGF0YUxlbmd0aCk7XHJcbiAgICAgICAgcHJldmlvdXMuX25leHQgPSBuZXh0IHx8IG51bGw7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHVwZGF0ZSA9IG5ldyBTZWxlY3Rpb24odXBkYXRlLCBwYXJlbnRzKTtcclxuICB1cGRhdGUuX2VudGVyID0gZW50ZXI7XHJcbiAgdXBkYXRlLl9leGl0ID0gZXhpdDtcclxuICByZXR1cm4gdXBkYXRlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZWxlY3Rpb25fZXhpdCgpIHtcclxuICByZXR1cm4gbmV3IFNlbGVjdGlvbih0aGlzLl9leGl0IHx8IHRoaXMuX2dyb3Vwcy5tYXAoc3BhcnNlKSwgdGhpcy5fcGFyZW50cyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNlbGVjdGlvbl9tZXJnZShzZWxlY3Rpb24kJDEpIHtcclxuXHJcbiAgZm9yICh2YXIgZ3JvdXBzMCA9IHRoaXMuX2dyb3VwcywgZ3JvdXBzMSA9IHNlbGVjdGlvbiQkMS5fZ3JvdXBzLCBtMCA9IGdyb3VwczAubGVuZ3RoLCBtMSA9IGdyb3VwczEubGVuZ3RoLCBtID0gTWF0aC5taW4obTAsIG0xKSwgbWVyZ2VzID0gbmV3IEFycmF5KG0wKSwgaiA9IDA7IGogPCBtOyArK2opIHtcclxuICAgIGZvciAodmFyIGdyb3VwMCA9IGdyb3VwczBbal0sIGdyb3VwMSA9IGdyb3VwczFbal0sIG4gPSBncm91cDAubGVuZ3RoLCBtZXJnZSA9IG1lcmdlc1tqXSA9IG5ldyBBcnJheShuKSwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcclxuICAgICAgaWYgKG5vZGUgPSBncm91cDBbaV0gfHwgZ3JvdXAxW2ldKSB7XHJcbiAgICAgICAgbWVyZ2VbaV0gPSBub2RlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmb3IgKDsgaiA8IG0wOyArK2opIHtcclxuICAgIG1lcmdlc1tqXSA9IGdyb3VwczBbal07XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihtZXJnZXMsIHRoaXMuX3BhcmVudHMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZWxlY3Rpb25fb3JkZXIoKSB7XHJcblxyXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgaiA9IC0xLCBtID0gZ3JvdXBzLmxlbmd0aDsgKytqIDwgbTspIHtcclxuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBpID0gZ3JvdXAubGVuZ3RoIC0gMSwgbmV4dCA9IGdyb3VwW2ldLCBub2RlOyAtLWkgPj0gMDspIHtcclxuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xyXG4gICAgICAgIGlmIChuZXh0ICYmIG5leHQgIT09IG5vZGUubmV4dFNpYmxpbmcpIG5leHQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm9kZSwgbmV4dCk7XHJcbiAgICAgICAgbmV4dCA9IG5vZGU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZWxlY3Rpb25fc29ydChjb21wYXJlKSB7XHJcbiAgaWYgKCFjb21wYXJlKSBjb21wYXJlID0gYXNjZW5kaW5nJDE7XHJcblxyXG4gIGZ1bmN0aW9uIGNvbXBhcmVOb2RlKGEsIGIpIHtcclxuICAgIHJldHVybiBhICYmIGIgPyBjb21wYXJlKGEuX19kYXRhX18sIGIuX19kYXRhX18pIDogIWEgLSAhYjtcclxuICB9XHJcblxyXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHNvcnRncm91cHMgPSBuZXcgQXJyYXkobSksIGogPSAwOyBqIDwgbTsgKytqKSB7XHJcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc29ydGdyb3VwID0gc29ydGdyb3Vwc1tqXSA9IG5ldyBBcnJheShuKSwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcclxuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xyXG4gICAgICAgIHNvcnRncm91cFtpXSA9IG5vZGU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHNvcnRncm91cC5zb3J0KGNvbXBhcmVOb2RlKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHNvcnRncm91cHMsIHRoaXMuX3BhcmVudHMpLm9yZGVyKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFzY2VuZGluZyQxKGEsIGIpIHtcclxuICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IGEgPj0gYiA/IDAgOiBOYU47XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNlbGVjdGlvbl9jYWxsKCkge1xyXG4gIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1swXTtcclxuICBhcmd1bWVudHNbMF0gPSB0aGlzO1xyXG4gIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNlbGVjdGlvbl9ub2RlcygpIHtcclxuICB2YXIgbm9kZXMgPSBuZXcgQXJyYXkodGhpcy5zaXplKCkpLCBpID0gLTE7XHJcbiAgdGhpcy5lYWNoKGZ1bmN0aW9uKCkgeyBub2Rlc1srK2ldID0gdGhpczsgfSk7XHJcbiAgcmV0dXJuIG5vZGVzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZWxlY3Rpb25fbm9kZSgpIHtcclxuXHJcbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBqID0gMCwgbSA9IGdyb3Vwcy5sZW5ndGg7IGogPCBtOyArK2opIHtcclxuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBpID0gMCwgbiA9IGdyb3VwLmxlbmd0aDsgaSA8IG47ICsraSkge1xyXG4gICAgICB2YXIgbm9kZSA9IGdyb3VwW2ldO1xyXG4gICAgICBpZiAobm9kZSkgcmV0dXJuIG5vZGU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbnVsbDtcclxufVxyXG5cclxuZnVuY3Rpb24gc2VsZWN0aW9uX3NpemUoKSB7XHJcbiAgdmFyIHNpemUgPSAwO1xyXG4gIHRoaXMuZWFjaChmdW5jdGlvbigpIHsgKytzaXplOyB9KTtcclxuICByZXR1cm4gc2l6ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2VsZWN0aW9uX2VtcHR5KCkge1xyXG4gIHJldHVybiAhdGhpcy5ub2RlKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNlbGVjdGlvbl9lYWNoKGNhbGxiYWNrKSB7XHJcblxyXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgaiA9IDAsIG0gPSBncm91cHMubGVuZ3RoOyBqIDwgbTsgKytqKSB7XHJcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgaSA9IDAsIG4gPSBncm91cC5sZW5ndGgsIG5vZGU7IGkgPCBuOyArK2kpIHtcclxuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkgY2FsbGJhY2suY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuZnVuY3Rpb24gYXR0clJlbW92ZShuYW1lKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gYXR0clJlbW92ZU5TKGZ1bGxuYW1lKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGF0dHJDb25zdGFudChuYW1lLCB2YWx1ZSkge1xyXG4gIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBhdHRyQ29uc3RhbnROUyhmdWxsbmFtZSwgdmFsdWUpIHtcclxuICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLnNldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCwgdmFsdWUpO1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGF0dHJGdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xyXG4gIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIGlmICh2ID09IG51bGwpIHRoaXMucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xyXG4gICAgZWxzZSB0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCB2KTtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBhdHRyRnVuY3Rpb25OUyhmdWxsbmFtZSwgdmFsdWUpIHtcclxuICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICBpZiAodiA9PSBudWxsKSB0aGlzLnJlbW92ZUF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XHJcbiAgICBlbHNlIHRoaXMuc2V0QXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsLCB2KTtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZWxlY3Rpb25fYXR0cihuYW1lLCB2YWx1ZSkge1xyXG4gIHZhciBmdWxsbmFtZSA9IG5hbWVzcGFjZShuYW1lKTtcclxuXHJcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XHJcbiAgICB2YXIgbm9kZSA9IHRoaXMubm9kZSgpO1xyXG4gICAgcmV0dXJuIGZ1bGxuYW1lLmxvY2FsXHJcbiAgICAgICAgPyBub2RlLmdldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbClcclxuICAgICAgICA6IG5vZGUuZ2V0QXR0cmlidXRlKGZ1bGxuYW1lKTtcclxuICB9XHJcblxyXG4gIHJldHVybiB0aGlzLmVhY2goKHZhbHVlID09IG51bGxcclxuICAgICAgPyAoZnVsbG5hbWUubG9jYWwgPyBhdHRyUmVtb3ZlTlMgOiBhdHRyUmVtb3ZlKSA6ICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxyXG4gICAgICA/IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJGdW5jdGlvbk5TIDogYXR0ckZ1bmN0aW9uKVxyXG4gICAgICA6IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJDb25zdGFudE5TIDogYXR0ckNvbnN0YW50KSkpKGZ1bGxuYW1lLCB2YWx1ZSkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkZWZhdWx0Vmlldyhub2RlKSB7XHJcbiAgcmV0dXJuIChub2RlLm93bmVyRG9jdW1lbnQgJiYgbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KSAvLyBub2RlIGlzIGEgTm9kZVxyXG4gICAgICB8fCAobm9kZS5kb2N1bWVudCAmJiBub2RlKSAvLyBub2RlIGlzIGEgV2luZG93XHJcbiAgICAgIHx8IG5vZGUuZGVmYXVsdFZpZXc7IC8vIG5vZGUgaXMgYSBEb2N1bWVudFxyXG59XHJcblxyXG5mdW5jdGlvbiBzdHlsZVJlbW92ZShuYW1lKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKTtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBzdHlsZUNvbnN0YW50KG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xyXG4gIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsdWUsIHByaW9yaXR5KTtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBzdHlsZUZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xyXG4gIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIGlmICh2ID09IG51bGwpIHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSk7XHJcbiAgICBlbHNlIHRoaXMuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdiwgcHJpb3JpdHkpO1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNlbGVjdGlvbl9zdHlsZShuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcclxuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDFcclxuICAgICAgPyB0aGlzLmVhY2goKHZhbHVlID09IG51bGxcclxuICAgICAgICAgICAgPyBzdHlsZVJlbW92ZSA6IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXHJcbiAgICAgICAgICAgID8gc3R5bGVGdW5jdGlvblxyXG4gICAgICAgICAgICA6IHN0eWxlQ29uc3RhbnQpKG5hbWUsIHZhbHVlLCBwcmlvcml0eSA9PSBudWxsID8gXCJcIiA6IHByaW9yaXR5KSlcclxuICAgICAgOiBzdHlsZVZhbHVlKHRoaXMubm9kZSgpLCBuYW1lKTtcclxufVxyXG5cclxuZnVuY3Rpb24gc3R5bGVWYWx1ZShub2RlLCBuYW1lKSB7XHJcbiAgcmV0dXJuIG5vZGUuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKVxyXG4gICAgICB8fCBkZWZhdWx0Vmlldyhub2RlKS5nZXRDb21wdXRlZFN0eWxlKG5vZGUsIG51bGwpLmdldFByb3BlcnR5VmFsdWUobmFtZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHByb3BlcnR5UmVtb3ZlKG5hbWUpIHtcclxuICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICBkZWxldGUgdGhpc1tuYW1lXTtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBwcm9wZXJ0eUNvbnN0YW50KG5hbWUsIHZhbHVlKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpc1tuYW1lXSA9IHZhbHVlO1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHByb3BlcnR5RnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcclxuICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICBpZiAodiA9PSBudWxsKSBkZWxldGUgdGhpc1tuYW1lXTtcclxuICAgIGVsc2UgdGhpc1tuYW1lXSA9IHY7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2VsZWN0aW9uX3Byb3BlcnR5KG5hbWUsIHZhbHVlKSB7XHJcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAxXHJcbiAgICAgID8gdGhpcy5lYWNoKCh2YWx1ZSA9PSBudWxsXHJcbiAgICAgICAgICA/IHByb3BlcnR5UmVtb3ZlIDogdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcclxuICAgICAgICAgID8gcHJvcGVydHlGdW5jdGlvblxyXG4gICAgICAgICAgOiBwcm9wZXJ0eUNvbnN0YW50KShuYW1lLCB2YWx1ZSkpXHJcbiAgICAgIDogdGhpcy5ub2RlKClbbmFtZV07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNsYXNzQXJyYXkoc3RyaW5nKSB7XHJcbiAgcmV0dXJuIHN0cmluZy50cmltKCkuc3BsaXQoL158XFxzKy8pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjbGFzc0xpc3Qobm9kZSkge1xyXG4gIHJldHVybiBub2RlLmNsYXNzTGlzdCB8fCBuZXcgQ2xhc3NMaXN0KG5vZGUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBDbGFzc0xpc3Qobm9kZSkge1xyXG4gIHRoaXMuX25vZGUgPSBub2RlO1xyXG4gIHRoaXMuX25hbWVzID0gY2xhc3NBcnJheShub2RlLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIpO1xyXG59XHJcblxyXG5DbGFzc0xpc3QucHJvdG90eXBlID0ge1xyXG4gIGFkZDogZnVuY3Rpb24obmFtZSkge1xyXG4gICAgdmFyIGkgPSB0aGlzLl9uYW1lcy5pbmRleE9mKG5hbWUpO1xyXG4gICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgIHRoaXMuX25hbWVzLnB1c2gobmFtZSk7XHJcbiAgICAgIHRoaXMuX25vZGUuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgdGhpcy5fbmFtZXMuam9pbihcIiBcIikpO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgcmVtb3ZlOiBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICB2YXIgaSA9IHRoaXMuX25hbWVzLmluZGV4T2YobmFtZSk7XHJcbiAgICBpZiAoaSA+PSAwKSB7XHJcbiAgICAgIHRoaXMuX25hbWVzLnNwbGljZShpLCAxKTtcclxuICAgICAgdGhpcy5fbm9kZS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCB0aGlzLl9uYW1lcy5qb2luKFwiIFwiKSk7XHJcbiAgICB9XHJcbiAgfSxcclxuICBjb250YWluczogZnVuY3Rpb24obmFtZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuX25hbWVzLmluZGV4T2YobmFtZSkgPj0gMDtcclxuICB9XHJcbn07XHJcblxyXG5mdW5jdGlvbiBjbGFzc2VkQWRkKG5vZGUsIG5hbWVzKSB7XHJcbiAgdmFyIGxpc3QgPSBjbGFzc0xpc3Qobm9kZSksIGkgPSAtMSwgbiA9IG5hbWVzLmxlbmd0aDtcclxuICB3aGlsZSAoKytpIDwgbikgbGlzdC5hZGQobmFtZXNbaV0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjbGFzc2VkUmVtb3ZlKG5vZGUsIG5hbWVzKSB7XHJcbiAgdmFyIGxpc3QgPSBjbGFzc0xpc3Qobm9kZSksIGkgPSAtMSwgbiA9IG5hbWVzLmxlbmd0aDtcclxuICB3aGlsZSAoKytpIDwgbikgbGlzdC5yZW1vdmUobmFtZXNbaV0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjbGFzc2VkVHJ1ZShuYW1lcykge1xyXG4gIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgIGNsYXNzZWRBZGQodGhpcywgbmFtZXMpO1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNsYXNzZWRGYWxzZShuYW1lcykge1xyXG4gIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgIGNsYXNzZWRSZW1vdmUodGhpcywgbmFtZXMpO1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNsYXNzZWRGdW5jdGlvbihuYW1lcywgdmFsdWUpIHtcclxuICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAodmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKSA/IGNsYXNzZWRBZGQgOiBjbGFzc2VkUmVtb3ZlKSh0aGlzLCBuYW1lcyk7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2VsZWN0aW9uX2NsYXNzZWQobmFtZSwgdmFsdWUpIHtcclxuICB2YXIgbmFtZXMgPSBjbGFzc0FycmF5KG5hbWUgKyBcIlwiKTtcclxuXHJcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XHJcbiAgICB2YXIgbGlzdCA9IGNsYXNzTGlzdCh0aGlzLm5vZGUoKSksIGkgPSAtMSwgbiA9IG5hbWVzLmxlbmd0aDtcclxuICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoIWxpc3QuY29udGFpbnMobmFtZXNbaV0pKSByZXR1cm4gZmFsc2U7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIHJldHVybiB0aGlzLmVhY2goKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXHJcbiAgICAgID8gY2xhc3NlZEZ1bmN0aW9uIDogdmFsdWVcclxuICAgICAgPyBjbGFzc2VkVHJ1ZVxyXG4gICAgICA6IGNsYXNzZWRGYWxzZSkobmFtZXMsIHZhbHVlKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRleHRSZW1vdmUoKSB7XHJcbiAgdGhpcy50ZXh0Q29udGVudCA9IFwiXCI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRleHRDb25zdGFudCh2YWx1ZSkge1xyXG4gIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiB0ZXh0RnVuY3Rpb24odmFsdWUpIHtcclxuICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB0aGlzLnRleHRDb250ZW50ID0gdiA9PSBudWxsID8gXCJcIiA6IHY7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2VsZWN0aW9uX3RleHQodmFsdWUpIHtcclxuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxyXG4gICAgICA/IHRoaXMuZWFjaCh2YWx1ZSA9PSBudWxsXHJcbiAgICAgICAgICA/IHRleHRSZW1vdmUgOiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcclxuICAgICAgICAgID8gdGV4dEZ1bmN0aW9uXHJcbiAgICAgICAgICA6IHRleHRDb25zdGFudCkodmFsdWUpKVxyXG4gICAgICA6IHRoaXMubm9kZSgpLnRleHRDb250ZW50O1xyXG59XHJcblxyXG5mdW5jdGlvbiBodG1sUmVtb3ZlKCkge1xyXG4gIHRoaXMuaW5uZXJIVE1MID0gXCJcIjtcclxufVxyXG5cclxuZnVuY3Rpb24gaHRtbENvbnN0YW50KHZhbHVlKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5pbm5lckhUTUwgPSB2YWx1ZTtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBodG1sRnVuY3Rpb24odmFsdWUpIHtcclxuICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB0aGlzLmlubmVySFRNTCA9IHYgPT0gbnVsbCA/IFwiXCIgOiB2O1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNlbGVjdGlvbl9odG1sKHZhbHVlKSB7XHJcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcclxuICAgICAgPyB0aGlzLmVhY2godmFsdWUgPT0gbnVsbFxyXG4gICAgICAgICAgPyBodG1sUmVtb3ZlIDogKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXHJcbiAgICAgICAgICA/IGh0bWxGdW5jdGlvblxyXG4gICAgICAgICAgOiBodG1sQ29uc3RhbnQpKHZhbHVlKSlcclxuICAgICAgOiB0aGlzLm5vZGUoKS5pbm5lckhUTUw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJhaXNlKCkge1xyXG4gIGlmICh0aGlzLm5leHRTaWJsaW5nKSB0aGlzLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNlbGVjdGlvbl9yYWlzZSgpIHtcclxuICByZXR1cm4gdGhpcy5lYWNoKHJhaXNlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gbG93ZXIoKSB7XHJcbiAgaWYgKHRoaXMucHJldmlvdXNTaWJsaW5nKSB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMsIHRoaXMucGFyZW50Tm9kZS5maXJzdENoaWxkKTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2VsZWN0aW9uX2xvd2VyKCkge1xyXG4gIHJldHVybiB0aGlzLmVhY2gobG93ZXIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZWxlY3Rpb25fYXBwZW5kKG5hbWUpIHtcclxuICB2YXIgY3JlYXRlID0gdHlwZW9mIG5hbWUgPT09IFwiZnVuY3Rpb25cIiA/IG5hbWUgOiBjcmVhdG9yKG5hbWUpO1xyXG4gIHJldHVybiB0aGlzLnNlbGVjdChmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmFwcGVuZENoaWxkKGNyZWF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gY29uc3RhbnROdWxsKCkge1xyXG4gIHJldHVybiBudWxsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZWxlY3Rpb25faW5zZXJ0KG5hbWUsIGJlZm9yZSkge1xyXG4gIHZhciBjcmVhdGUgPSB0eXBlb2YgbmFtZSA9PT0gXCJmdW5jdGlvblwiID8gbmFtZSA6IGNyZWF0b3IobmFtZSksXHJcbiAgICAgIHNlbGVjdCA9IGJlZm9yZSA9PSBudWxsID8gY29uc3RhbnROdWxsIDogdHlwZW9mIGJlZm9yZSA9PT0gXCJmdW5jdGlvblwiID8gYmVmb3JlIDogc2VsZWN0b3IoYmVmb3JlKTtcclxuICByZXR1cm4gdGhpcy5zZWxlY3QoZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5pbnNlcnRCZWZvcmUoY3JlYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHNlbGVjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IG51bGwpO1xyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZW1vdmUoKSB7XHJcbiAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcclxuICBpZiAocGFyZW50KSBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNlbGVjdGlvbl9yZW1vdmUoKSB7XHJcbiAgcmV0dXJuIHRoaXMuZWFjaChyZW1vdmUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZWxlY3Rpb25fY2xvbmVTaGFsbG93KCkge1xyXG4gIHJldHVybiB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuY2xvbmVOb2RlKGZhbHNlKSwgdGhpcy5uZXh0U2libGluZyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNlbGVjdGlvbl9jbG9uZURlZXAoKSB7XHJcbiAgcmV0dXJuIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5jbG9uZU5vZGUodHJ1ZSksIHRoaXMubmV4dFNpYmxpbmcpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZWxlY3Rpb25fY2xvbmUoZGVlcCkge1xyXG4gIHJldHVybiB0aGlzLnNlbGVjdChkZWVwID8gc2VsZWN0aW9uX2Nsb25lRGVlcCA6IHNlbGVjdGlvbl9jbG9uZVNoYWxsb3cpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZWxlY3Rpb25fZGF0dW0odmFsdWUpIHtcclxuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxyXG4gICAgICA/IHRoaXMucHJvcGVydHkoXCJfX2RhdGFfX1wiLCB2YWx1ZSlcclxuICAgICAgOiB0aGlzLm5vZGUoKS5fX2RhdGFfXztcclxufVxyXG5cclxudmFyIGZpbHRlckV2ZW50cyA9IHt9O1xyXG5cclxuZDMuZXZlbnQgPSBudWxsO1xyXG5cclxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gIHZhciBlbGVtZW50JDEgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XHJcbiAgaWYgKCEoXCJvbm1vdXNlZW50ZXJcIiBpbiBlbGVtZW50JDEpKSB7XHJcbiAgICBmaWx0ZXJFdmVudHMgPSB7bW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIiwgbW91c2VsZWF2ZTogXCJtb3VzZW91dFwifTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZpbHRlckNvbnRleHRMaXN0ZW5lcihsaXN0ZW5lciwgaW5kZXgsIGdyb3VwKSB7XHJcbiAgbGlzdGVuZXIgPSBjb250ZXh0TGlzdGVuZXIobGlzdGVuZXIsIGluZGV4LCBncm91cCk7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICB2YXIgcmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XHJcbiAgICBpZiAoIXJlbGF0ZWQgfHwgKHJlbGF0ZWQgIT09IHRoaXMgJiYgIShyZWxhdGVkLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHRoaXMpICYgOCkpKSB7XHJcbiAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgZXZlbnQpO1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbnRleHRMaXN0ZW5lcihsaXN0ZW5lciwgaW5kZXgsIGdyb3VwKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKGV2ZW50MSkge1xyXG4gICAgdmFyIGV2ZW50MCA9IGQzLmV2ZW50OyAvLyBFdmVudHMgY2FuIGJlIHJlZW50cmFudCAoZS5nLiwgZm9jdXMpLlxyXG4gICAgZDMuZXZlbnQgPSBldmVudDE7XHJcbiAgICB0cnkge1xyXG4gICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIHRoaXMuX19kYXRhX18sIGluZGV4LCBncm91cCk7XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICBkMy5ldmVudCA9IGV2ZW50MDtcclxuICAgIH1cclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYXJzZVR5cGVuYW1lcyQxKHR5cGVuYW1lcykge1xyXG4gIHJldHVybiB0eXBlbmFtZXMudHJpbSgpLnNwbGl0KC9efFxccysvKS5tYXAoZnVuY3Rpb24odCkge1xyXG4gICAgdmFyIG5hbWUgPSBcIlwiLCBpID0gdC5pbmRleE9mKFwiLlwiKTtcclxuICAgIGlmIChpID49IDApIG5hbWUgPSB0LnNsaWNlKGkgKyAxKSwgdCA9IHQuc2xpY2UoMCwgaSk7XHJcbiAgICByZXR1cm4ge3R5cGU6IHQsIG5hbWU6IG5hbWV9O1xyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBvblJlbW92ZSh0eXBlbmFtZSkge1xyXG4gIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgIHZhciBvbiA9IHRoaXMuX19vbjtcclxuICAgIGlmICghb24pIHJldHVybjtcclxuICAgIGZvciAodmFyIGogPSAwLCBpID0gLTEsIG0gPSBvbi5sZW5ndGgsIG87IGogPCBtOyArK2opIHtcclxuICAgICAgaWYgKG8gPSBvbltqXSwgKCF0eXBlbmFtZS50eXBlIHx8IG8udHlwZSA9PT0gdHlwZW5hbWUudHlwZSkgJiYgby5uYW1lID09PSB0eXBlbmFtZS5uYW1lKSB7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKG8udHlwZSwgby5saXN0ZW5lciwgby5jYXB0dXJlKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBvblsrK2ldID0gbztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCsraSkgb24ubGVuZ3RoID0gaTtcclxuICAgIGVsc2UgZGVsZXRlIHRoaXMuX19vbjtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBvbkFkZCh0eXBlbmFtZSwgdmFsdWUsIGNhcHR1cmUpIHtcclxuICB2YXIgd3JhcCA9IGZpbHRlckV2ZW50cy5oYXNPd25Qcm9wZXJ0eSh0eXBlbmFtZS50eXBlKSA/IGZpbHRlckNvbnRleHRMaXN0ZW5lciA6IGNvbnRleHRMaXN0ZW5lcjtcclxuICByZXR1cm4gZnVuY3Rpb24oZCwgaSwgZ3JvdXApIHtcclxuICAgIHZhciBvbiA9IHRoaXMuX19vbiwgbywgbGlzdGVuZXIgPSB3cmFwKHZhbHVlLCBpLCBncm91cCk7XHJcbiAgICBpZiAob24pIGZvciAodmFyIGogPSAwLCBtID0gb24ubGVuZ3RoOyBqIDwgbTsgKytqKSB7XHJcbiAgICAgIGlmICgobyA9IG9uW2pdKS50eXBlID09PSB0eXBlbmFtZS50eXBlICYmIG8ubmFtZSA9PT0gdHlwZW5hbWUubmFtZSkge1xyXG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihvLnR5cGUsIG8ubGlzdGVuZXIsIG8uY2FwdHVyZSk7XHJcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKG8udHlwZSwgby5saXN0ZW5lciA9IGxpc3RlbmVyLCBvLmNhcHR1cmUgPSBjYXB0dXJlKTtcclxuICAgICAgICBvLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIodHlwZW5hbWUudHlwZSwgbGlzdGVuZXIsIGNhcHR1cmUpO1xyXG4gICAgbyA9IHt0eXBlOiB0eXBlbmFtZS50eXBlLCBuYW1lOiB0eXBlbmFtZS5uYW1lLCB2YWx1ZTogdmFsdWUsIGxpc3RlbmVyOiBsaXN0ZW5lciwgY2FwdHVyZTogY2FwdHVyZX07XHJcbiAgICBpZiAoIW9uKSB0aGlzLl9fb24gPSBbb107XHJcbiAgICBlbHNlIG9uLnB1c2gobyk7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2VsZWN0aW9uX29uKHR5cGVuYW1lLCB2YWx1ZSwgY2FwdHVyZSkge1xyXG4gIHZhciB0eXBlbmFtZXMgPSBwYXJzZVR5cGVuYW1lcyQxKHR5cGVuYW1lICsgXCJcIiksIGksIG4gPSB0eXBlbmFtZXMubGVuZ3RoLCB0O1xyXG5cclxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcclxuICAgIHZhciBvbiA9IHRoaXMubm9kZSgpLl9fb247XHJcbiAgICBpZiAob24pIGZvciAodmFyIGogPSAwLCBtID0gb24ubGVuZ3RoLCBvOyBqIDwgbTsgKytqKSB7XHJcbiAgICAgIGZvciAoaSA9IDAsIG8gPSBvbltqXTsgaSA8IG47ICsraSkge1xyXG4gICAgICAgIGlmICgodCA9IHR5cGVuYW1lc1tpXSkudHlwZSA9PT0gby50eXBlICYmIHQubmFtZSA9PT0gby5uYW1lKSB7XHJcbiAgICAgICAgICByZXR1cm4gby52YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIG9uID0gdmFsdWUgPyBvbkFkZCA6IG9uUmVtb3ZlO1xyXG4gIGlmIChjYXB0dXJlID09IG51bGwpIGNhcHR1cmUgPSBmYWxzZTtcclxuICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB0aGlzLmVhY2gob24odHlwZW5hbWVzW2ldLCB2YWx1ZSwgY2FwdHVyZSkpO1xyXG4gIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjdXN0b21FdmVudChldmVudDEsIGxpc3RlbmVyLCB0aGF0LCBhcmdzKSB7XHJcbiAgdmFyIGV2ZW50MCA9IGQzLmV2ZW50O1xyXG4gIGV2ZW50MS5zb3VyY2VFdmVudCA9IGQzLmV2ZW50O1xyXG4gIGQzLmV2ZW50ID0gZXZlbnQxO1xyXG4gIHRyeSB7XHJcbiAgICByZXR1cm4gbGlzdGVuZXIuYXBwbHkodGhhdCwgYXJncyk7XHJcbiAgfSBmaW5hbGx5IHtcclxuICAgIGQzLmV2ZW50ID0gZXZlbnQwO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZGlzcGF0Y2hFdmVudChub2RlLCB0eXBlLCBwYXJhbXMpIHtcclxuICB2YXIgd2luZG93ID0gZGVmYXVsdFZpZXcobm9kZSksXHJcbiAgICAgIGV2ZW50ID0gd2luZG93LkN1c3RvbUV2ZW50O1xyXG5cclxuICBpZiAodHlwZW9mIGV2ZW50ID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgIGV2ZW50ID0gbmV3IGV2ZW50KHR5cGUsIHBhcmFtcyk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGV2ZW50ID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRXZlbnRcIik7XHJcbiAgICBpZiAocGFyYW1zKSBldmVudC5pbml0RXZlbnQodHlwZSwgcGFyYW1zLmJ1YmJsZXMsIHBhcmFtcy5jYW5jZWxhYmxlKSwgZXZlbnQuZGV0YWlsID0gcGFyYW1zLmRldGFpbDtcclxuICAgIGVsc2UgZXZlbnQuaW5pdEV2ZW50KHR5cGUsIGZhbHNlLCBmYWxzZSk7XHJcbiAgfVxyXG5cclxuICBub2RlLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkaXNwYXRjaENvbnN0YW50KHR5cGUsIHBhcmFtcykge1xyXG4gIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBkaXNwYXRjaEV2ZW50KHRoaXMsIHR5cGUsIHBhcmFtcyk7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gZGlzcGF0Y2hGdW5jdGlvbih0eXBlLCBwYXJhbXMpIHtcclxuICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gZGlzcGF0Y2hFdmVudCh0aGlzLCB0eXBlLCBwYXJhbXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2VsZWN0aW9uX2Rpc3BhdGNoKHR5cGUsIHBhcmFtcykge1xyXG4gIHJldHVybiB0aGlzLmVhY2goKHR5cGVvZiBwYXJhbXMgPT09IFwiZnVuY3Rpb25cIlxyXG4gICAgICA/IGRpc3BhdGNoRnVuY3Rpb25cclxuICAgICAgOiBkaXNwYXRjaENvbnN0YW50KSh0eXBlLCBwYXJhbXMpKTtcclxufVxyXG5cclxudmFyIHJvb3QgPSBbbnVsbF07XHJcblxyXG5mdW5jdGlvbiBTZWxlY3Rpb24oZ3JvdXBzLCBwYXJlbnRzKSB7XHJcbiAgdGhpcy5fZ3JvdXBzID0gZ3JvdXBzO1xyXG4gIHRoaXMuX3BhcmVudHMgPSBwYXJlbnRzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZWxlY3Rpb24oKSB7XHJcbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oW1tkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRdXSwgcm9vdCk7XHJcbn1cclxuXHJcblNlbGVjdGlvbi5wcm90b3R5cGUgPSBzZWxlY3Rpb24ucHJvdG90eXBlID0ge1xyXG4gIGNvbnN0cnVjdG9yOiBTZWxlY3Rpb24sXHJcbiAgc2VsZWN0OiBzZWxlY3Rpb25fc2VsZWN0LFxyXG4gIHNlbGVjdEFsbDogc2VsZWN0aW9uX3NlbGVjdEFsbCxcclxuICBmaWx0ZXI6IHNlbGVjdGlvbl9maWx0ZXIsXHJcbiAgZGF0YTogc2VsZWN0aW9uX2RhdGEsXHJcbiAgZW50ZXI6IHNlbGVjdGlvbl9lbnRlcixcclxuICBleGl0OiBzZWxlY3Rpb25fZXhpdCxcclxuICBtZXJnZTogc2VsZWN0aW9uX21lcmdlLFxyXG4gIG9yZGVyOiBzZWxlY3Rpb25fb3JkZXIsXHJcbiAgc29ydDogc2VsZWN0aW9uX3NvcnQsXHJcbiAgY2FsbDogc2VsZWN0aW9uX2NhbGwsXHJcbiAgbm9kZXM6IHNlbGVjdGlvbl9ub2RlcyxcclxuICBub2RlOiBzZWxlY3Rpb25fbm9kZSxcclxuICBzaXplOiBzZWxlY3Rpb25fc2l6ZSxcclxuICBlbXB0eTogc2VsZWN0aW9uX2VtcHR5LFxyXG4gIGVhY2g6IHNlbGVjdGlvbl9lYWNoLFxyXG4gIGF0dHI6IHNlbGVjdGlvbl9hdHRyLFxyXG4gIHN0eWxlOiBzZWxlY3Rpb25fc3R5bGUsXHJcbiAgcHJvcGVydHk6IHNlbGVjdGlvbl9wcm9wZXJ0eSxcclxuICBjbGFzc2VkOiBzZWxlY3Rpb25fY2xhc3NlZCxcclxuICB0ZXh0OiBzZWxlY3Rpb25fdGV4dCxcclxuICBodG1sOiBzZWxlY3Rpb25faHRtbCxcclxuICByYWlzZTogc2VsZWN0aW9uX3JhaXNlLFxyXG4gIGxvd2VyOiBzZWxlY3Rpb25fbG93ZXIsXHJcbiAgYXBwZW5kOiBzZWxlY3Rpb25fYXBwZW5kLFxyXG4gIGluc2VydDogc2VsZWN0aW9uX2luc2VydCxcclxuICByZW1vdmU6IHNlbGVjdGlvbl9yZW1vdmUsXHJcbiAgY2xvbmU6IHNlbGVjdGlvbl9jbG9uZSxcclxuICBkYXR1bTogc2VsZWN0aW9uX2RhdHVtLFxyXG4gIG9uOiBzZWxlY3Rpb25fb24sXHJcbiAgZGlzcGF0Y2g6IHNlbGVjdGlvbl9kaXNwYXRjaFxyXG59O1xyXG5cclxuZnVuY3Rpb24gc2VsZWN0KHNlbGVjdG9yKSB7XHJcbiAgcmV0dXJuIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIlxyXG4gICAgICA/IG5ldyBTZWxlY3Rpb24oW1tkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKV1dLCBbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XSlcclxuICAgICAgOiBuZXcgU2VsZWN0aW9uKFtbc2VsZWN0b3JdXSwgcm9vdCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZShuYW1lKSB7XHJcbiAgcmV0dXJuIHNlbGVjdChjcmVhdG9yKG5hbWUpLmNhbGwoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSk7XHJcbn1cclxuXHJcbnZhciBuZXh0SWQgPSAwO1xyXG5cclxuZnVuY3Rpb24gbG9jYWwoKSB7XHJcbiAgcmV0dXJuIG5ldyBMb2NhbDtcclxufVxyXG5cclxuZnVuY3Rpb24gTG9jYWwoKSB7XHJcbiAgdGhpcy5fID0gXCJAXCIgKyAoKytuZXh0SWQpLnRvU3RyaW5nKDM2KTtcclxufVxyXG5cclxuTG9jYWwucHJvdG90eXBlID0gbG9jYWwucHJvdG90eXBlID0ge1xyXG4gIGNvbnN0cnVjdG9yOiBMb2NhbCxcclxuICBnZXQ6IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgIHZhciBpZCA9IHRoaXMuXztcclxuICAgIHdoaWxlICghKGlkIGluIG5vZGUpKSBpZiAoIShub2RlID0gbm9kZS5wYXJlbnROb2RlKSkgcmV0dXJuO1xyXG4gICAgcmV0dXJuIG5vZGVbaWRdO1xyXG4gIH0sXHJcbiAgc2V0OiBmdW5jdGlvbihub2RlLCB2YWx1ZSkge1xyXG4gICAgcmV0dXJuIG5vZGVbdGhpcy5fXSA9IHZhbHVlO1xyXG4gIH0sXHJcbiAgcmVtb3ZlOiBmdW5jdGlvbihub2RlKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fIGluIG5vZGUgJiYgZGVsZXRlIG5vZGVbdGhpcy5fXTtcclxuICB9LFxyXG4gIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLl87XHJcbiAgfVxyXG59O1xyXG5cclxuZnVuY3Rpb24gc291cmNlRXZlbnQoKSB7XHJcbiAgdmFyIGN1cnJlbnQgPSBkMy5ldmVudCwgc291cmNlO1xyXG4gIHdoaWxlIChzb3VyY2UgPSBjdXJyZW50LnNvdXJjZUV2ZW50KSBjdXJyZW50ID0gc291cmNlO1xyXG4gIHJldHVybiBjdXJyZW50O1xyXG59XHJcblxyXG5mdW5jdGlvbiBwb2ludChub2RlLCBldmVudCkge1xyXG4gIHZhciBzdmcgPSBub2RlLm93bmVyU1ZHRWxlbWVudCB8fCBub2RlO1xyXG5cclxuICBpZiAoc3ZnLmNyZWF0ZVNWR1BvaW50KSB7XHJcbiAgICB2YXIgcG9pbnQgPSBzdmcuY3JlYXRlU1ZHUG9pbnQoKTtcclxuICAgIHBvaW50LnggPSBldmVudC5jbGllbnRYLCBwb2ludC55ID0gZXZlbnQuY2xpZW50WTtcclxuICAgIHBvaW50ID0gcG9pbnQubWF0cml4VHJhbnNmb3JtKG5vZGUuZ2V0U2NyZWVuQ1RNKCkuaW52ZXJzZSgpKTtcclxuICAgIHJldHVybiBbcG9pbnQueCwgcG9pbnQueV07XHJcbiAgfVxyXG5cclxuICB2YXIgcmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgcmV0dXJuIFtldmVudC5jbGllbnRYIC0gcmVjdC5sZWZ0IC0gbm9kZS5jbGllbnRMZWZ0LCBldmVudC5jbGllbnRZIC0gcmVjdC50b3AgLSBub2RlLmNsaWVudFRvcF07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1vdXNlKG5vZGUpIHtcclxuICB2YXIgZXZlbnQgPSBzb3VyY2VFdmVudCgpO1xyXG4gIGlmIChldmVudC5jaGFuZ2VkVG91Y2hlcykgZXZlbnQgPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcclxuICByZXR1cm4gcG9pbnQobm9kZSwgZXZlbnQpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZWxlY3RBbGwoc2VsZWN0b3IpIHtcclxuICByZXR1cm4gdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiXHJcbiAgICAgID8gbmV3IFNlbGVjdGlvbihbZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcildLCBbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XSlcclxuICAgICAgOiBuZXcgU2VsZWN0aW9uKFtzZWxlY3RvciA9PSBudWxsID8gW10gOiBzZWxlY3Rvcl0sIHJvb3QpO1xyXG59XHJcblxyXG5mdW5jdGlvbiB0b3VjaChub2RlLCB0b3VjaGVzLCBpZGVudGlmaWVyKSB7XHJcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSBpZGVudGlmaWVyID0gdG91Y2hlcywgdG91Y2hlcyA9IHNvdXJjZUV2ZW50KCkuY2hhbmdlZFRvdWNoZXM7XHJcblxyXG4gIGZvciAodmFyIGkgPSAwLCBuID0gdG91Y2hlcyA/IHRvdWNoZXMubGVuZ3RoIDogMCwgdG91Y2g7IGkgPCBuOyArK2kpIHtcclxuICAgIGlmICgodG91Y2ggPSB0b3VjaGVzW2ldKS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XHJcbiAgICAgIHJldHVybiBwb2ludChub2RlLCB0b3VjaCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbnVsbDtcclxufVxyXG5cclxuZnVuY3Rpb24gdG91Y2hlcyhub2RlLCB0b3VjaGVzKSB7XHJcbiAgaWYgKHRvdWNoZXMgPT0gbnVsbCkgdG91Y2hlcyA9IHNvdXJjZUV2ZW50KCkudG91Y2hlcztcclxuXHJcbiAgZm9yICh2YXIgaSA9IDAsIG4gPSB0b3VjaGVzID8gdG91Y2hlcy5sZW5ndGggOiAwLCBwb2ludHMgPSBuZXcgQXJyYXkobik7IGkgPCBuOyArK2kpIHtcclxuICAgIHBvaW50c1tpXSA9IHBvaW50KG5vZGUsIHRvdWNoZXNbaV0pO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHBvaW50cztcclxufVxyXG5cclxuZnVuY3Rpb24gbm9wcm9wYWdhdGlvbigpIHtcclxuICBkMy5ldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcclxufVxyXG5cclxuZnVuY3Rpb24gbm9ldmVudCgpIHtcclxuICBkMy5ldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gIGQzLmV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkcmFnRGlzYWJsZSh2aWV3KSB7XHJcbiAgdmFyIHJvb3QgPSB2aWV3LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcclxuICAgICAgc2VsZWN0aW9uJCQxID0gc2VsZWN0KHZpZXcpLm9uKFwiZHJhZ3N0YXJ0LmRyYWdcIiwgbm9ldmVudCwgdHJ1ZSk7XHJcbiAgaWYgKFwib25zZWxlY3RzdGFydFwiIGluIHJvb3QpIHtcclxuICAgIHNlbGVjdGlvbiQkMS5vbihcInNlbGVjdHN0YXJ0LmRyYWdcIiwgbm9ldmVudCwgdHJ1ZSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJvb3QuX19ub3NlbGVjdCA9IHJvb3Quc3R5bGUuTW96VXNlclNlbGVjdDtcclxuICAgIHJvb3Quc3R5bGUuTW96VXNlclNlbGVjdCA9IFwibm9uZVwiO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24geWVzZHJhZyh2aWV3LCBub2NsaWNrKSB7XHJcbiAgdmFyIHJvb3QgPSB2aWV3LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcclxuICAgICAgc2VsZWN0aW9uJCQxID0gc2VsZWN0KHZpZXcpLm9uKFwiZHJhZ3N0YXJ0LmRyYWdcIiwgbnVsbCk7XHJcbiAgaWYgKG5vY2xpY2spIHtcclxuICAgIHNlbGVjdGlvbiQkMS5vbihcImNsaWNrLmRyYWdcIiwgbm9ldmVudCwgdHJ1ZSk7XHJcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBzZWxlY3Rpb24kJDEub24oXCJjbGljay5kcmFnXCIsIG51bGwpOyB9LCAwKTtcclxuICB9XHJcbiAgaWYgKFwib25zZWxlY3RzdGFydFwiIGluIHJvb3QpIHtcclxuICAgIHNlbGVjdGlvbiQkMS5vbihcInNlbGVjdHN0YXJ0LmRyYWdcIiwgbnVsbCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJvb3Quc3R5bGUuTW96VXNlclNlbGVjdCA9IHJvb3QuX19ub3NlbGVjdDtcclxuICAgIGRlbGV0ZSByb290Ll9fbm9zZWxlY3Q7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBjb25zdGFudCQyKHgpIHtcclxuICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4geDtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBEcmFnRXZlbnQodGFyZ2V0LCB0eXBlLCBzdWJqZWN0LCBpZCwgYWN0aXZlLCB4LCB5LCBkeCwgZHksIGRpc3BhdGNoKSB7XHJcbiAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgdGhpcy50eXBlID0gdHlwZTtcclxuICB0aGlzLnN1YmplY3QgPSBzdWJqZWN0O1xyXG4gIHRoaXMuaWRlbnRpZmllciA9IGlkO1xyXG4gIHRoaXMuYWN0aXZlID0gYWN0aXZlO1xyXG4gIHRoaXMueCA9IHg7XHJcbiAgdGhpcy55ID0geTtcclxuICB0aGlzLmR4ID0gZHg7XHJcbiAgdGhpcy5keSA9IGR5O1xyXG4gIHRoaXMuXyA9IGRpc3BhdGNoO1xyXG59XHJcblxyXG5EcmFnRXZlbnQucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oKSB7XHJcbiAgdmFyIHZhbHVlID0gdGhpcy5fLm9uLmFwcGx5KHRoaXMuXywgYXJndW1lbnRzKTtcclxuICByZXR1cm4gdmFsdWUgPT09IHRoaXMuXyA/IHRoaXMgOiB2YWx1ZTtcclxufTtcclxuXHJcbi8vIElnbm9yZSByaWdodC1jbGljaywgc2luY2UgdGhhdCBzaG91bGQgb3BlbiB0aGUgY29udGV4dCBtZW51LlxyXG5mdW5jdGlvbiBkZWZhdWx0RmlsdGVyKCkge1xyXG4gIHJldHVybiAhZDMuZXZlbnQuYnV0dG9uO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkZWZhdWx0Q29udGFpbmVyKCkge1xyXG4gIHJldHVybiB0aGlzLnBhcmVudE5vZGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlZmF1bHRTdWJqZWN0KGQpIHtcclxuICByZXR1cm4gZCA9PSBudWxsID8ge3g6IGQzLmV2ZW50LngsIHk6IGQzLmV2ZW50Lnl9IDogZDtcclxufVxyXG5cclxuZnVuY3Rpb24gZGVmYXVsdFRvdWNoYWJsZSgpIHtcclxuICByZXR1cm4gXCJvbnRvdWNoc3RhcnRcIiBpbiB0aGlzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkcmFnKCkge1xyXG4gIHZhciBmaWx0ZXIgPSBkZWZhdWx0RmlsdGVyLFxyXG4gICAgICBjb250YWluZXIgPSBkZWZhdWx0Q29udGFpbmVyLFxyXG4gICAgICBzdWJqZWN0ID0gZGVmYXVsdFN1YmplY3QsXHJcbiAgICAgIHRvdWNoYWJsZSA9IGRlZmF1bHRUb3VjaGFibGUsXHJcbiAgICAgIGdlc3R1cmVzID0ge30sXHJcbiAgICAgIGxpc3RlbmVycyA9IGRpc3BhdGNoKFwic3RhcnRcIiwgXCJkcmFnXCIsIFwiZW5kXCIpLFxyXG4gICAgICBhY3RpdmUgPSAwLFxyXG4gICAgICBtb3VzZWRvd254LFxyXG4gICAgICBtb3VzZWRvd255LFxyXG4gICAgICBtb3VzZW1vdmluZyxcclxuICAgICAgdG91Y2hlbmRpbmcsXHJcbiAgICAgIGNsaWNrRGlzdGFuY2UyID0gMDtcclxuXHJcbiAgZnVuY3Rpb24gZHJhZyhzZWxlY3Rpb24kJDEpIHtcclxuICAgIHNlbGVjdGlvbiQkMVxyXG4gICAgICAgIC5vbihcIm1vdXNlZG93bi5kcmFnXCIsIG1vdXNlZG93bmVkKVxyXG4gICAgICAuZmlsdGVyKHRvdWNoYWJsZSlcclxuICAgICAgICAub24oXCJ0b3VjaHN0YXJ0LmRyYWdcIiwgdG91Y2hzdGFydGVkKVxyXG4gICAgICAgIC5vbihcInRvdWNobW92ZS5kcmFnXCIsIHRvdWNobW92ZWQpXHJcbiAgICAgICAgLm9uKFwidG91Y2hlbmQuZHJhZyB0b3VjaGNhbmNlbC5kcmFnXCIsIHRvdWNoZW5kZWQpXHJcbiAgICAgICAgLnN0eWxlKFwidG91Y2gtYWN0aW9uXCIsIFwibm9uZVwiKVxyXG4gICAgICAgIC5zdHlsZShcIi13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvclwiLCBcInJnYmEoMCwwLDAsMClcIik7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBtb3VzZWRvd25lZCgpIHtcclxuICAgIGlmICh0b3VjaGVuZGluZyB8fCAhZmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHJldHVybjtcclxuICAgIHZhciBnZXN0dXJlID0gYmVmb3Jlc3RhcnQoXCJtb3VzZVwiLCBjb250YWluZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgbW91c2UsIHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICBpZiAoIWdlc3R1cmUpIHJldHVybjtcclxuICAgIHNlbGVjdChkMy5ldmVudC52aWV3KS5vbihcIm1vdXNlbW92ZS5kcmFnXCIsIG1vdXNlbW92ZWQsIHRydWUpLm9uKFwibW91c2V1cC5kcmFnXCIsIG1vdXNldXBwZWQsIHRydWUpO1xyXG4gICAgZHJhZ0Rpc2FibGUoZDMuZXZlbnQudmlldyk7XHJcbiAgICBub3Byb3BhZ2F0aW9uKCk7XHJcbiAgICBtb3VzZW1vdmluZyA9IGZhbHNlO1xyXG4gICAgbW91c2Vkb3dueCA9IGQzLmV2ZW50LmNsaWVudFg7XHJcbiAgICBtb3VzZWRvd255ID0gZDMuZXZlbnQuY2xpZW50WTtcclxuICAgIGdlc3R1cmUoXCJzdGFydFwiKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIG1vdXNlbW92ZWQoKSB7XHJcbiAgICBub2V2ZW50KCk7XHJcbiAgICBpZiAoIW1vdXNlbW92aW5nKSB7XHJcbiAgICAgIHZhciBkeCA9IGQzLmV2ZW50LmNsaWVudFggLSBtb3VzZWRvd254LCBkeSA9IGQzLmV2ZW50LmNsaWVudFkgLSBtb3VzZWRvd255O1xyXG4gICAgICBtb3VzZW1vdmluZyA9IGR4ICogZHggKyBkeSAqIGR5ID4gY2xpY2tEaXN0YW5jZTI7XHJcbiAgICB9XHJcbiAgICBnZXN0dXJlcy5tb3VzZShcImRyYWdcIik7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBtb3VzZXVwcGVkKCkge1xyXG4gICAgc2VsZWN0KGQzLmV2ZW50LnZpZXcpLm9uKFwibW91c2Vtb3ZlLmRyYWcgbW91c2V1cC5kcmFnXCIsIG51bGwpO1xyXG4gICAgeWVzZHJhZyhkMy5ldmVudC52aWV3LCBtb3VzZW1vdmluZyk7XHJcbiAgICBub2V2ZW50KCk7XHJcbiAgICBnZXN0dXJlcy5tb3VzZShcImVuZFwiKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHRvdWNoc3RhcnRlZCgpIHtcclxuICAgIGlmICghZmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHJldHVybjtcclxuICAgIHZhciB0b3VjaGVzJCQxID0gZDMuZXZlbnQuY2hhbmdlZFRvdWNoZXMsXHJcbiAgICAgICAgYyA9IGNvbnRhaW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxyXG4gICAgICAgIG4gPSB0b3VjaGVzJCQxLmxlbmd0aCwgaSwgZ2VzdHVyZTtcclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgIGlmIChnZXN0dXJlID0gYmVmb3Jlc3RhcnQodG91Y2hlcyQkMVtpXS5pZGVudGlmaWVyLCBjLCB0b3VjaCwgdGhpcywgYXJndW1lbnRzKSkge1xyXG4gICAgICAgIG5vcHJvcGFnYXRpb24oKTtcclxuICAgICAgICBnZXN0dXJlKFwic3RhcnRcIik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHRvdWNobW92ZWQoKSB7XHJcbiAgICB2YXIgdG91Y2hlcyQkMSA9IGQzLmV2ZW50LmNoYW5nZWRUb3VjaGVzLFxyXG4gICAgICAgIG4gPSB0b3VjaGVzJCQxLmxlbmd0aCwgaSwgZ2VzdHVyZTtcclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgIGlmIChnZXN0dXJlID0gZ2VzdHVyZXNbdG91Y2hlcyQkMVtpXS5pZGVudGlmaWVyXSkge1xyXG4gICAgICAgIG5vZXZlbnQoKTtcclxuICAgICAgICBnZXN0dXJlKFwiZHJhZ1wiKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdG91Y2hlbmRlZCgpIHtcclxuICAgIHZhciB0b3VjaGVzJCQxID0gZDMuZXZlbnQuY2hhbmdlZFRvdWNoZXMsXHJcbiAgICAgICAgbiA9IHRvdWNoZXMkJDEubGVuZ3RoLCBpLCBnZXN0dXJlO1xyXG5cclxuICAgIGlmICh0b3VjaGVuZGluZykgY2xlYXJUaW1lb3V0KHRvdWNoZW5kaW5nKTtcclxuICAgIHRvdWNoZW5kaW5nID0gc2V0VGltZW91dChmdW5jdGlvbigpIHsgdG91Y2hlbmRpbmcgPSBudWxsOyB9LCA1MDApOyAvLyBHaG9zdCBjbGlja3MgYXJlIGRlbGF5ZWQhXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgIGlmIChnZXN0dXJlID0gZ2VzdHVyZXNbdG91Y2hlcyQkMVtpXS5pZGVudGlmaWVyXSkge1xyXG4gICAgICAgIG5vcHJvcGFnYXRpb24oKTtcclxuICAgICAgICBnZXN0dXJlKFwiZW5kXCIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBiZWZvcmVzdGFydChpZCwgY29udGFpbmVyLCBwb2ludCQkMSwgdGhhdCwgYXJncykge1xyXG4gICAgdmFyIHAgPSBwb2ludCQkMShjb250YWluZXIsIGlkKSwgcywgZHgsIGR5LFxyXG4gICAgICAgIHN1Ymxpc3RlbmVycyA9IGxpc3RlbmVycy5jb3B5KCk7XHJcblxyXG4gICAgaWYgKCFjdXN0b21FdmVudChuZXcgRHJhZ0V2ZW50KGRyYWcsIFwiYmVmb3Jlc3RhcnRcIiwgcywgaWQsIGFjdGl2ZSwgcFswXSwgcFsxXSwgMCwgMCwgc3VibGlzdGVuZXJzKSwgZnVuY3Rpb24oKSB7XHJcbiAgICAgIGlmICgoZDMuZXZlbnQuc3ViamVjdCA9IHMgPSBzdWJqZWN0LmFwcGx5KHRoYXQsIGFyZ3MpKSA9PSBudWxsKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIGR4ID0gcy54IC0gcFswXSB8fCAwO1xyXG4gICAgICBkeSA9IHMueSAtIHBbMV0gfHwgMDtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9KSkgcmV0dXJuO1xyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiBnZXN0dXJlKHR5cGUpIHtcclxuICAgICAgdmFyIHAwID0gcCwgbjtcclxuICAgICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgY2FzZSBcInN0YXJ0XCI6IGdlc3R1cmVzW2lkXSA9IGdlc3R1cmUsIG4gPSBhY3RpdmUrKzsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcImVuZFwiOiBkZWxldGUgZ2VzdHVyZXNbaWRdLCAtLWFjdGl2ZTsgLy8gbm9icmVha1xyXG4gICAgICAgIGNhc2UgXCJkcmFnXCI6IHAgPSBwb2ludCQkMShjb250YWluZXIsIGlkKSwgbiA9IGFjdGl2ZTsgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgY3VzdG9tRXZlbnQobmV3IERyYWdFdmVudChkcmFnLCB0eXBlLCBzLCBpZCwgbiwgcFswXSArIGR4LCBwWzFdICsgZHksIHBbMF0gLSBwMFswXSwgcFsxXSAtIHAwWzFdLCBzdWJsaXN0ZW5lcnMpLCBzdWJsaXN0ZW5lcnMuYXBwbHksIHN1Ymxpc3RlbmVycywgW3R5cGUsIHRoYXQsIGFyZ3NdKTtcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBkcmFnLmZpbHRlciA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGZpbHRlciA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQkMighIV8pLCBkcmFnKSA6IGZpbHRlcjtcclxuICB9O1xyXG5cclxuICBkcmFnLmNvbnRhaW5lciA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNvbnRhaW5lciA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQkMihfKSwgZHJhZykgOiBjb250YWluZXI7XHJcbiAgfTtcclxuXHJcbiAgZHJhZy5zdWJqZWN0ID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3ViamVjdCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQkMihfKSwgZHJhZykgOiBzdWJqZWN0O1xyXG4gIH07XHJcblxyXG4gIGRyYWcudG91Y2hhYmxlID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodG91Y2hhYmxlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCQyKCEhXyksIGRyYWcpIDogdG91Y2hhYmxlO1xyXG4gIH07XHJcblxyXG4gIGRyYWcub24gPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciB2YWx1ZSA9IGxpc3RlbmVycy5vbi5hcHBseShsaXN0ZW5lcnMsIGFyZ3VtZW50cyk7XHJcbiAgICByZXR1cm4gdmFsdWUgPT09IGxpc3RlbmVycyA/IGRyYWcgOiB2YWx1ZTtcclxuICB9O1xyXG5cclxuICBkcmFnLmNsaWNrRGlzdGFuY2UgPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjbGlja0Rpc3RhbmNlMiA9IChfID0gK18pICogXywgZHJhZykgOiBNYXRoLnNxcnQoY2xpY2tEaXN0YW5jZTIpO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBkcmFnO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkZWZpbmUoY29uc3RydWN0b3IsIGZhY3RvcnksIHByb3RvdHlwZSkge1xyXG4gIGNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGZhY3RvcnkucHJvdG90eXBlID0gcHJvdG90eXBlO1xyXG4gIHByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yO1xyXG59XHJcblxyXG5mdW5jdGlvbiBleHRlbmQocGFyZW50LCBkZWZpbml0aW9uKSB7XHJcbiAgdmFyIHByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUocGFyZW50LnByb3RvdHlwZSk7XHJcbiAgZm9yICh2YXIga2V5IGluIGRlZmluaXRpb24pIHByb3RvdHlwZVtrZXldID0gZGVmaW5pdGlvbltrZXldO1xyXG4gIHJldHVybiBwcm90b3R5cGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIENvbG9yKCkge31cclxuXHJcbnZhciBkYXJrZXIgPSAwLjc7XHJcbnZhciBicmlnaHRlciA9IDEgLyBkYXJrZXI7XHJcblxyXG52YXIgcmVJID0gXCJcXFxccyooWystXT9cXFxcZCspXFxcXHMqXCIsXHJcbiAgICByZU4gPSBcIlxcXFxzKihbKy1dP1xcXFxkKlxcXFwuP1xcXFxkKyg/OltlRV1bKy1dP1xcXFxkKyk/KVxcXFxzKlwiLFxyXG4gICAgcmVQID0gXCJcXFxccyooWystXT9cXFxcZCpcXFxcLj9cXFxcZCsoPzpbZUVdWystXT9cXFxcZCspPyklXFxcXHMqXCIsXHJcbiAgICByZUhleDMgPSAvXiMoWzAtOWEtZl17M30pJC8sXHJcbiAgICByZUhleDYgPSAvXiMoWzAtOWEtZl17Nn0pJC8sXHJcbiAgICByZVJnYkludGVnZXIgPSBuZXcgUmVnRXhwKFwiXnJnYlxcXFwoXCIgKyBbcmVJLCByZUksIHJlSV0gKyBcIlxcXFwpJFwiKSxcclxuICAgIHJlUmdiUGVyY2VudCA9IG5ldyBSZWdFeHAoXCJecmdiXFxcXChcIiArIFtyZVAsIHJlUCwgcmVQXSArIFwiXFxcXCkkXCIpLFxyXG4gICAgcmVSZ2JhSW50ZWdlciA9IG5ldyBSZWdFeHAoXCJecmdiYVxcXFwoXCIgKyBbcmVJLCByZUksIHJlSSwgcmVOXSArIFwiXFxcXCkkXCIpLFxyXG4gICAgcmVSZ2JhUGVyY2VudCA9IG5ldyBSZWdFeHAoXCJecmdiYVxcXFwoXCIgKyBbcmVQLCByZVAsIHJlUCwgcmVOXSArIFwiXFxcXCkkXCIpLFxyXG4gICAgcmVIc2xQZXJjZW50ID0gbmV3IFJlZ0V4cChcIl5oc2xcXFxcKFwiICsgW3JlTiwgcmVQLCByZVBdICsgXCJcXFxcKSRcIiksXHJcbiAgICByZUhzbGFQZXJjZW50ID0gbmV3IFJlZ0V4cChcIl5oc2xhXFxcXChcIiArIFtyZU4sIHJlUCwgcmVQLCByZU5dICsgXCJcXFxcKSRcIik7XHJcblxyXG52YXIgbmFtZWQgPSB7XHJcbiAgYWxpY2VibHVlOiAweGYwZjhmZixcclxuICBhbnRpcXVld2hpdGU6IDB4ZmFlYmQ3LFxyXG4gIGFxdWE6IDB4MDBmZmZmLFxyXG4gIGFxdWFtYXJpbmU6IDB4N2ZmZmQ0LFxyXG4gIGF6dXJlOiAweGYwZmZmZixcclxuICBiZWlnZTogMHhmNWY1ZGMsXHJcbiAgYmlzcXVlOiAweGZmZTRjNCxcclxuICBibGFjazogMHgwMDAwMDAsXHJcbiAgYmxhbmNoZWRhbG1vbmQ6IDB4ZmZlYmNkLFxyXG4gIGJsdWU6IDB4MDAwMGZmLFxyXG4gIGJsdWV2aW9sZXQ6IDB4OGEyYmUyLFxyXG4gIGJyb3duOiAweGE1MmEyYSxcclxuICBidXJseXdvb2Q6IDB4ZGViODg3LFxyXG4gIGNhZGV0Ymx1ZTogMHg1ZjllYTAsXHJcbiAgY2hhcnRyZXVzZTogMHg3ZmZmMDAsXHJcbiAgY2hvY29sYXRlOiAweGQyNjkxZSxcclxuICBjb3JhbDogMHhmZjdmNTAsXHJcbiAgY29ybmZsb3dlcmJsdWU6IDB4NjQ5NWVkLFxyXG4gIGNvcm5zaWxrOiAweGZmZjhkYyxcclxuICBjcmltc29uOiAweGRjMTQzYyxcclxuICBjeWFuOiAweDAwZmZmZixcclxuICBkYXJrYmx1ZTogMHgwMDAwOGIsXHJcbiAgZGFya2N5YW46IDB4MDA4YjhiLFxyXG4gIGRhcmtnb2xkZW5yb2Q6IDB4Yjg4NjBiLFxyXG4gIGRhcmtncmF5OiAweGE5YTlhOSxcclxuICBkYXJrZ3JlZW46IDB4MDA2NDAwLFxyXG4gIGRhcmtncmV5OiAweGE5YTlhOSxcclxuICBkYXJra2hha2k6IDB4YmRiNzZiLFxyXG4gIGRhcmttYWdlbnRhOiAweDhiMDA4YixcclxuICBkYXJrb2xpdmVncmVlbjogMHg1NTZiMmYsXHJcbiAgZGFya29yYW5nZTogMHhmZjhjMDAsXHJcbiAgZGFya29yY2hpZDogMHg5OTMyY2MsXHJcbiAgZGFya3JlZDogMHg4YjAwMDAsXHJcbiAgZGFya3NhbG1vbjogMHhlOTk2N2EsXHJcbiAgZGFya3NlYWdyZWVuOiAweDhmYmM4ZixcclxuICBkYXJrc2xhdGVibHVlOiAweDQ4M2Q4YixcclxuICBkYXJrc2xhdGVncmF5OiAweDJmNGY0ZixcclxuICBkYXJrc2xhdGVncmV5OiAweDJmNGY0ZixcclxuICBkYXJrdHVycXVvaXNlOiAweDAwY2VkMSxcclxuICBkYXJrdmlvbGV0OiAweDk0MDBkMyxcclxuICBkZWVwcGluazogMHhmZjE0OTMsXHJcbiAgZGVlcHNreWJsdWU6IDB4MDBiZmZmLFxyXG4gIGRpbWdyYXk6IDB4Njk2OTY5LFxyXG4gIGRpbWdyZXk6IDB4Njk2OTY5LFxyXG4gIGRvZGdlcmJsdWU6IDB4MWU5MGZmLFxyXG4gIGZpcmVicmljazogMHhiMjIyMjIsXHJcbiAgZmxvcmFsd2hpdGU6IDB4ZmZmYWYwLFxyXG4gIGZvcmVzdGdyZWVuOiAweDIyOGIyMixcclxuICBmdWNoc2lhOiAweGZmMDBmZixcclxuICBnYWluc2Jvcm86IDB4ZGNkY2RjLFxyXG4gIGdob3N0d2hpdGU6IDB4ZjhmOGZmLFxyXG4gIGdvbGQ6IDB4ZmZkNzAwLFxyXG4gIGdvbGRlbnJvZDogMHhkYWE1MjAsXHJcbiAgZ3JheTogMHg4MDgwODAsXHJcbiAgZ3JlZW46IDB4MDA4MDAwLFxyXG4gIGdyZWVueWVsbG93OiAweGFkZmYyZixcclxuICBncmV5OiAweDgwODA4MCxcclxuICBob25leWRldzogMHhmMGZmZjAsXHJcbiAgaG90cGluazogMHhmZjY5YjQsXHJcbiAgaW5kaWFucmVkOiAweGNkNWM1YyxcclxuICBpbmRpZ286IDB4NGIwMDgyLFxyXG4gIGl2b3J5OiAweGZmZmZmMCxcclxuICBraGFraTogMHhmMGU2OGMsXHJcbiAgbGF2ZW5kZXI6IDB4ZTZlNmZhLFxyXG4gIGxhdmVuZGVyYmx1c2g6IDB4ZmZmMGY1LFxyXG4gIGxhd25ncmVlbjogMHg3Y2ZjMDAsXHJcbiAgbGVtb25jaGlmZm9uOiAweGZmZmFjZCxcclxuICBsaWdodGJsdWU6IDB4YWRkOGU2LFxyXG4gIGxpZ2h0Y29yYWw6IDB4ZjA4MDgwLFxyXG4gIGxpZ2h0Y3lhbjogMHhlMGZmZmYsXHJcbiAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IDB4ZmFmYWQyLFxyXG4gIGxpZ2h0Z3JheTogMHhkM2QzZDMsXHJcbiAgbGlnaHRncmVlbjogMHg5MGVlOTAsXHJcbiAgbGlnaHRncmV5OiAweGQzZDNkMyxcclxuICBsaWdodHBpbms6IDB4ZmZiNmMxLFxyXG4gIGxpZ2h0c2FsbW9uOiAweGZmYTA3YSxcclxuICBsaWdodHNlYWdyZWVuOiAweDIwYjJhYSxcclxuICBsaWdodHNreWJsdWU6IDB4ODdjZWZhLFxyXG4gIGxpZ2h0c2xhdGVncmF5OiAweDc3ODg5OSxcclxuICBsaWdodHNsYXRlZ3JleTogMHg3Nzg4OTksXHJcbiAgbGlnaHRzdGVlbGJsdWU6IDB4YjBjNGRlLFxyXG4gIGxpZ2h0eWVsbG93OiAweGZmZmZlMCxcclxuICBsaW1lOiAweDAwZmYwMCxcclxuICBsaW1lZ3JlZW46IDB4MzJjZDMyLFxyXG4gIGxpbmVuOiAweGZhZjBlNixcclxuICBtYWdlbnRhOiAweGZmMDBmZixcclxuICBtYXJvb246IDB4ODAwMDAwLFxyXG4gIG1lZGl1bWFxdWFtYXJpbmU6IDB4NjZjZGFhLFxyXG4gIG1lZGl1bWJsdWU6IDB4MDAwMGNkLFxyXG4gIG1lZGl1bW9yY2hpZDogMHhiYTU1ZDMsXHJcbiAgbWVkaXVtcHVycGxlOiAweDkzNzBkYixcclxuICBtZWRpdW1zZWFncmVlbjogMHgzY2IzNzEsXHJcbiAgbWVkaXVtc2xhdGVibHVlOiAweDdiNjhlZSxcclxuICBtZWRpdW1zcHJpbmdncmVlbjogMHgwMGZhOWEsXHJcbiAgbWVkaXVtdHVycXVvaXNlOiAweDQ4ZDFjYyxcclxuICBtZWRpdW12aW9sZXRyZWQ6IDB4YzcxNTg1LFxyXG4gIG1pZG5pZ2h0Ymx1ZTogMHgxOTE5NzAsXHJcbiAgbWludGNyZWFtOiAweGY1ZmZmYSxcclxuICBtaXN0eXJvc2U6IDB4ZmZlNGUxLFxyXG4gIG1vY2Nhc2luOiAweGZmZTRiNSxcclxuICBuYXZham93aGl0ZTogMHhmZmRlYWQsXHJcbiAgbmF2eTogMHgwMDAwODAsXHJcbiAgb2xkbGFjZTogMHhmZGY1ZTYsXHJcbiAgb2xpdmU6IDB4ODA4MDAwLFxyXG4gIG9saXZlZHJhYjogMHg2YjhlMjMsXHJcbiAgb3JhbmdlOiAweGZmYTUwMCxcclxuICBvcmFuZ2VyZWQ6IDB4ZmY0NTAwLFxyXG4gIG9yY2hpZDogMHhkYTcwZDYsXHJcbiAgcGFsZWdvbGRlbnJvZDogMHhlZWU4YWEsXHJcbiAgcGFsZWdyZWVuOiAweDk4ZmI5OCxcclxuICBwYWxldHVycXVvaXNlOiAweGFmZWVlZSxcclxuICBwYWxldmlvbGV0cmVkOiAweGRiNzA5MyxcclxuICBwYXBheWF3aGlwOiAweGZmZWZkNSxcclxuICBwZWFjaHB1ZmY6IDB4ZmZkYWI5LFxyXG4gIHBlcnU6IDB4Y2Q4NTNmLFxyXG4gIHBpbms6IDB4ZmZjMGNiLFxyXG4gIHBsdW06IDB4ZGRhMGRkLFxyXG4gIHBvd2RlcmJsdWU6IDB4YjBlMGU2LFxyXG4gIHB1cnBsZTogMHg4MDAwODAsXHJcbiAgcmViZWNjYXB1cnBsZTogMHg2NjMzOTksXHJcbiAgcmVkOiAweGZmMDAwMCxcclxuICByb3N5YnJvd246IDB4YmM4ZjhmLFxyXG4gIHJveWFsYmx1ZTogMHg0MTY5ZTEsXHJcbiAgc2FkZGxlYnJvd246IDB4OGI0NTEzLFxyXG4gIHNhbG1vbjogMHhmYTgwNzIsXHJcbiAgc2FuZHlicm93bjogMHhmNGE0NjAsXHJcbiAgc2VhZ3JlZW46IDB4MmU4YjU3LFxyXG4gIHNlYXNoZWxsOiAweGZmZjVlZSxcclxuICBzaWVubmE6IDB4YTA1MjJkLFxyXG4gIHNpbHZlcjogMHhjMGMwYzAsXHJcbiAgc2t5Ymx1ZTogMHg4N2NlZWIsXHJcbiAgc2xhdGVibHVlOiAweDZhNWFjZCxcclxuICBzbGF0ZWdyYXk6IDB4NzA4MDkwLFxyXG4gIHNsYXRlZ3JleTogMHg3MDgwOTAsXHJcbiAgc25vdzogMHhmZmZhZmEsXHJcbiAgc3ByaW5nZ3JlZW46IDB4MDBmZjdmLFxyXG4gIHN0ZWVsYmx1ZTogMHg0NjgyYjQsXHJcbiAgdGFuOiAweGQyYjQ4YyxcclxuICB0ZWFsOiAweDAwODA4MCxcclxuICB0aGlzdGxlOiAweGQ4YmZkOCxcclxuICB0b21hdG86IDB4ZmY2MzQ3LFxyXG4gIHR1cnF1b2lzZTogMHg0MGUwZDAsXHJcbiAgdmlvbGV0OiAweGVlODJlZSxcclxuICB3aGVhdDogMHhmNWRlYjMsXHJcbiAgd2hpdGU6IDB4ZmZmZmZmLFxyXG4gIHdoaXRlc21va2U6IDB4ZjVmNWY1LFxyXG4gIHllbGxvdzogMHhmZmZmMDAsXHJcbiAgeWVsbG93Z3JlZW46IDB4OWFjZDMyXHJcbn07XHJcblxyXG5kZWZpbmUoQ29sb3IsIGNvbG9yLCB7XHJcbiAgZGlzcGxheWFibGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucmdiKCkuZGlzcGxheWFibGUoKTtcclxuICB9LFxyXG4gIGhleDogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5yZ2IoKS5oZXgoKTtcclxuICB9LFxyXG4gIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLnJnYigpICsgXCJcIjtcclxuICB9XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gY29sb3IoZm9ybWF0KSB7XHJcbiAgdmFyIG07XHJcbiAgZm9ybWF0ID0gKGZvcm1hdCArIFwiXCIpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xyXG4gIHJldHVybiAobSA9IHJlSGV4My5leGVjKGZvcm1hdCkpID8gKG0gPSBwYXJzZUludChtWzFdLCAxNiksIG5ldyBSZ2IoKG0gPj4gOCAmIDB4ZikgfCAobSA+PiA0ICYgMHgwZjApLCAobSA+PiA0ICYgMHhmKSB8IChtICYgMHhmMCksICgobSAmIDB4ZikgPDwgNCkgfCAobSAmIDB4ZiksIDEpKSAvLyAjZjAwXHJcbiAgICAgIDogKG0gPSByZUhleDYuZXhlYyhmb3JtYXQpKSA/IHJnYm4ocGFyc2VJbnQobVsxXSwgMTYpKSAvLyAjZmYwMDAwXHJcbiAgICAgIDogKG0gPSByZVJnYkludGVnZXIuZXhlYyhmb3JtYXQpKSA/IG5ldyBSZ2IobVsxXSwgbVsyXSwgbVszXSwgMSkgLy8gcmdiKDI1NSwgMCwgMClcclxuICAgICAgOiAobSA9IHJlUmdiUGVyY2VudC5leGVjKGZvcm1hdCkpID8gbmV3IFJnYihtWzFdICogMjU1IC8gMTAwLCBtWzJdICogMjU1IC8gMTAwLCBtWzNdICogMjU1IC8gMTAwLCAxKSAvLyByZ2IoMTAwJSwgMCUsIDAlKVxyXG4gICAgICA6IChtID0gcmVSZ2JhSW50ZWdlci5leGVjKGZvcm1hdCkpID8gcmdiYShtWzFdLCBtWzJdLCBtWzNdLCBtWzRdKSAvLyByZ2JhKDI1NSwgMCwgMCwgMSlcclxuICAgICAgOiAobSA9IHJlUmdiYVBlcmNlbnQuZXhlYyhmb3JtYXQpKSA/IHJnYmEobVsxXSAqIDI1NSAvIDEwMCwgbVsyXSAqIDI1NSAvIDEwMCwgbVszXSAqIDI1NSAvIDEwMCwgbVs0XSkgLy8gcmdiKDEwMCUsIDAlLCAwJSwgMSlcclxuICAgICAgOiAobSA9IHJlSHNsUGVyY2VudC5leGVjKGZvcm1hdCkpID8gaHNsYShtWzFdLCBtWzJdIC8gMTAwLCBtWzNdIC8gMTAwLCAxKSAvLyBoc2woMTIwLCA1MCUsIDUwJSlcclxuICAgICAgOiAobSA9IHJlSHNsYVBlcmNlbnQuZXhlYyhmb3JtYXQpKSA/IGhzbGEobVsxXSwgbVsyXSAvIDEwMCwgbVszXSAvIDEwMCwgbVs0XSkgLy8gaHNsYSgxMjAsIDUwJSwgNTAlLCAxKVxyXG4gICAgICA6IG5hbWVkLmhhc093blByb3BlcnR5KGZvcm1hdCkgPyByZ2JuKG5hbWVkW2Zvcm1hdF0pXHJcbiAgICAgIDogZm9ybWF0ID09PSBcInRyYW5zcGFyZW50XCIgPyBuZXcgUmdiKE5hTiwgTmFOLCBOYU4sIDApXHJcbiAgICAgIDogbnVsbDtcclxufVxyXG5cclxuZnVuY3Rpb24gcmdibihuKSB7XHJcbiAgcmV0dXJuIG5ldyBSZ2IobiA+PiAxNiAmIDB4ZmYsIG4gPj4gOCAmIDB4ZmYsIG4gJiAweGZmLCAxKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmdiYShyLCBnLCBiLCBhKSB7XHJcbiAgaWYgKGEgPD0gMCkgciA9IGcgPSBiID0gTmFOO1xyXG4gIHJldHVybiBuZXcgUmdiKHIsIGcsIGIsIGEpO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZ2JDb252ZXJ0KG8pIHtcclxuICBpZiAoIShvIGluc3RhbmNlb2YgQ29sb3IpKSBvID0gY29sb3Iobyk7XHJcbiAgaWYgKCFvKSByZXR1cm4gbmV3IFJnYjtcclxuICBvID0gby5yZ2IoKTtcclxuICByZXR1cm4gbmV3IFJnYihvLnIsIG8uZywgby5iLCBvLm9wYWNpdHkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZ2IociwgZywgYiwgb3BhY2l0eSkge1xyXG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gcmdiQ29udmVydChyKSA6IG5ldyBSZ2IociwgZywgYiwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBSZ2IociwgZywgYiwgb3BhY2l0eSkge1xyXG4gIHRoaXMuciA9ICtyO1xyXG4gIHRoaXMuZyA9ICtnO1xyXG4gIHRoaXMuYiA9ICtiO1xyXG4gIHRoaXMub3BhY2l0eSA9ICtvcGFjaXR5O1xyXG59XHJcblxyXG5kZWZpbmUoUmdiLCByZ2IsIGV4dGVuZChDb2xvciwge1xyXG4gIGJyaWdodGVyOiBmdW5jdGlvbihrKSB7XHJcbiAgICBrID0gayA9PSBudWxsID8gYnJpZ2h0ZXIgOiBNYXRoLnBvdyhicmlnaHRlciwgayk7XHJcbiAgICByZXR1cm4gbmV3IFJnYih0aGlzLnIgKiBrLCB0aGlzLmcgKiBrLCB0aGlzLmIgKiBrLCB0aGlzLm9wYWNpdHkpO1xyXG4gIH0sXHJcbiAgZGFya2VyOiBmdW5jdGlvbihrKSB7XHJcbiAgICBrID0gayA9PSBudWxsID8gZGFya2VyIDogTWF0aC5wb3coZGFya2VyLCBrKTtcclxuICAgIHJldHVybiBuZXcgUmdiKHRoaXMuciAqIGssIHRoaXMuZyAqIGssIHRoaXMuYiAqIGssIHRoaXMub3BhY2l0eSk7XHJcbiAgfSxcclxuICByZ2I6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSxcclxuICBkaXNwbGF5YWJsZTogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gKDAgPD0gdGhpcy5yICYmIHRoaXMuciA8PSAyNTUpXHJcbiAgICAgICAgJiYgKDAgPD0gdGhpcy5nICYmIHRoaXMuZyA8PSAyNTUpXHJcbiAgICAgICAgJiYgKDAgPD0gdGhpcy5iICYmIHRoaXMuYiA8PSAyNTUpXHJcbiAgICAgICAgJiYgKDAgPD0gdGhpcy5vcGFjaXR5ICYmIHRoaXMub3BhY2l0eSA8PSAxKTtcclxuICB9LFxyXG4gIGhleDogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gXCIjXCIgKyBoZXgodGhpcy5yKSArIGhleCh0aGlzLmcpICsgaGV4KHRoaXMuYik7XHJcbiAgfSxcclxuICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgYSA9IHRoaXMub3BhY2l0eTsgYSA9IGlzTmFOKGEpID8gMSA6IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIGEpKTtcclxuICAgIHJldHVybiAoYSA9PT0gMSA/IFwicmdiKFwiIDogXCJyZ2JhKFwiKVxyXG4gICAgICAgICsgTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKHRoaXMucikgfHwgMCkpICsgXCIsIFwiXHJcbiAgICAgICAgKyBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIE1hdGgucm91bmQodGhpcy5nKSB8fCAwKSkgKyBcIiwgXCJcclxuICAgICAgICArIE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgTWF0aC5yb3VuZCh0aGlzLmIpIHx8IDApKVxyXG4gICAgICAgICsgKGEgPT09IDEgPyBcIilcIiA6IFwiLCBcIiArIGEgKyBcIilcIik7XHJcbiAgfVxyXG59KSk7XHJcblxyXG5mdW5jdGlvbiBoZXgodmFsdWUpIHtcclxuICB2YWx1ZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgTWF0aC5yb3VuZCh2YWx1ZSkgfHwgMCkpO1xyXG4gIHJldHVybiAodmFsdWUgPCAxNiA/IFwiMFwiIDogXCJcIikgKyB2YWx1ZS50b1N0cmluZygxNik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhzbGEoaCwgcywgbCwgYSkge1xyXG4gIGlmIChhIDw9IDApIGggPSBzID0gbCA9IE5hTjtcclxuICBlbHNlIGlmIChsIDw9IDAgfHwgbCA+PSAxKSBoID0gcyA9IE5hTjtcclxuICBlbHNlIGlmIChzIDw9IDApIGggPSBOYU47XHJcbiAgcmV0dXJuIG5ldyBIc2woaCwgcywgbCwgYSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhzbENvbnZlcnQobykge1xyXG4gIGlmIChvIGluc3RhbmNlb2YgSHNsKSByZXR1cm4gbmV3IEhzbChvLmgsIG8ucywgby5sLCBvLm9wYWNpdHkpO1xyXG4gIGlmICghKG8gaW5zdGFuY2VvZiBDb2xvcikpIG8gPSBjb2xvcihvKTtcclxuICBpZiAoIW8pIHJldHVybiBuZXcgSHNsO1xyXG4gIGlmIChvIGluc3RhbmNlb2YgSHNsKSByZXR1cm4gbztcclxuICBvID0gby5yZ2IoKTtcclxuICB2YXIgciA9IG8uciAvIDI1NSxcclxuICAgICAgZyA9IG8uZyAvIDI1NSxcclxuICAgICAgYiA9IG8uYiAvIDI1NSxcclxuICAgICAgbWluID0gTWF0aC5taW4ociwgZywgYiksXHJcbiAgICAgIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLFxyXG4gICAgICBoID0gTmFOLFxyXG4gICAgICBzID0gbWF4IC0gbWluLFxyXG4gICAgICBsID0gKG1heCArIG1pbikgLyAyO1xyXG4gIGlmIChzKSB7XHJcbiAgICBpZiAociA9PT0gbWF4KSBoID0gKGcgLSBiKSAvIHMgKyAoZyA8IGIpICogNjtcclxuICAgIGVsc2UgaWYgKGcgPT09IG1heCkgaCA9IChiIC0gcikgLyBzICsgMjtcclxuICAgIGVsc2UgaCA9IChyIC0gZykgLyBzICsgNDtcclxuICAgIHMgLz0gbCA8IDAuNSA/IG1heCArIG1pbiA6IDIgLSBtYXggLSBtaW47XHJcbiAgICBoICo9IDYwO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBzID0gbCA+IDAgJiYgbCA8IDEgPyAwIDogaDtcclxuICB9XHJcbiAgcmV0dXJuIG5ldyBIc2woaCwgcywgbCwgby5vcGFjaXR5KTtcclxufVxyXG5cclxuZnVuY3Rpb24gaHNsKGgsIHMsIGwsIG9wYWNpdHkpIHtcclxuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IGhzbENvbnZlcnQoaCkgOiBuZXcgSHNsKGgsIHMsIGwsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcclxufVxyXG5cclxuZnVuY3Rpb24gSHNsKGgsIHMsIGwsIG9wYWNpdHkpIHtcclxuICB0aGlzLmggPSAraDtcclxuICB0aGlzLnMgPSArcztcclxuICB0aGlzLmwgPSArbDtcclxuICB0aGlzLm9wYWNpdHkgPSArb3BhY2l0eTtcclxufVxyXG5cclxuZGVmaW5lKEhzbCwgaHNsLCBleHRlbmQoQ29sb3IsIHtcclxuICBicmlnaHRlcjogZnVuY3Rpb24oaykge1xyXG4gICAgayA9IGsgPT0gbnVsbCA/IGJyaWdodGVyIDogTWF0aC5wb3coYnJpZ2h0ZXIsIGspO1xyXG4gICAgcmV0dXJuIG5ldyBIc2wodGhpcy5oLCB0aGlzLnMsIHRoaXMubCAqIGssIHRoaXMub3BhY2l0eSk7XHJcbiAgfSxcclxuICBkYXJrZXI6IGZ1bmN0aW9uKGspIHtcclxuICAgIGsgPSBrID09IG51bGwgPyBkYXJrZXIgOiBNYXRoLnBvdyhkYXJrZXIsIGspO1xyXG4gICAgcmV0dXJuIG5ldyBIc2wodGhpcy5oLCB0aGlzLnMsIHRoaXMubCAqIGssIHRoaXMub3BhY2l0eSk7XHJcbiAgfSxcclxuICByZ2I6IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGggPSB0aGlzLmggJSAzNjAgKyAodGhpcy5oIDwgMCkgKiAzNjAsXHJcbiAgICAgICAgcyA9IGlzTmFOKGgpIHx8IGlzTmFOKHRoaXMucykgPyAwIDogdGhpcy5zLFxyXG4gICAgICAgIGwgPSB0aGlzLmwsXHJcbiAgICAgICAgbTIgPSBsICsgKGwgPCAwLjUgPyBsIDogMSAtIGwpICogcyxcclxuICAgICAgICBtMSA9IDIgKiBsIC0gbTI7XHJcbiAgICByZXR1cm4gbmV3IFJnYihcclxuICAgICAgaHNsMnJnYihoID49IDI0MCA/IGggLSAyNDAgOiBoICsgMTIwLCBtMSwgbTIpLFxyXG4gICAgICBoc2wycmdiKGgsIG0xLCBtMiksXHJcbiAgICAgIGhzbDJyZ2IoaCA8IDEyMCA/IGggKyAyNDAgOiBoIC0gMTIwLCBtMSwgbTIpLFxyXG4gICAgICB0aGlzLm9wYWNpdHlcclxuICAgICk7XHJcbiAgfSxcclxuICBkaXNwbGF5YWJsZTogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gKDAgPD0gdGhpcy5zICYmIHRoaXMucyA8PSAxIHx8IGlzTmFOKHRoaXMucykpXHJcbiAgICAgICAgJiYgKDAgPD0gdGhpcy5sICYmIHRoaXMubCA8PSAxKVxyXG4gICAgICAgICYmICgwIDw9IHRoaXMub3BhY2l0eSAmJiB0aGlzLm9wYWNpdHkgPD0gMSk7XHJcbiAgfVxyXG59KSk7XHJcblxyXG4vKiBGcm9tIEZ2RCAxMy4zNywgQ1NTIENvbG9yIE1vZHVsZSBMZXZlbCAzICovXHJcbmZ1bmN0aW9uIGhzbDJyZ2IoaCwgbTEsIG0yKSB7XHJcbiAgcmV0dXJuIChoIDwgNjAgPyBtMSArIChtMiAtIG0xKSAqIGggLyA2MFxyXG4gICAgICA6IGggPCAxODAgPyBtMlxyXG4gICAgICA6IGggPCAyNDAgPyBtMSArIChtMiAtIG0xKSAqICgyNDAgLSBoKSAvIDYwXHJcbiAgICAgIDogbTEpICogMjU1O1xyXG59XHJcblxyXG52YXIgZGVnMnJhZCA9IE1hdGguUEkgLyAxODA7XHJcbnZhciByYWQyZGVnID0gMTgwIC8gTWF0aC5QSTtcclxuXHJcbi8vIGh0dHBzOi8vYmV0YS5vYnNlcnZhYmxlaHEuY29tL0BtYm9zdG9jay9sYWItYW5kLXJnYlxyXG52YXIgSyA9IDE4LFxyXG4gICAgWG4gPSAwLjk2NDIyLFxyXG4gICAgWW4gPSAxLFxyXG4gICAgWm4gPSAwLjgyNTIxLFxyXG4gICAgdDAgPSA0IC8gMjksXHJcbiAgICB0MSA9IDYgLyAyOSxcclxuICAgIHQyID0gMyAqIHQxICogdDEsXHJcbiAgICB0MyA9IHQxICogdDEgKiB0MTtcclxuXHJcbmZ1bmN0aW9uIGxhYkNvbnZlcnQobykge1xyXG4gIGlmIChvIGluc3RhbmNlb2YgTGFiKSByZXR1cm4gbmV3IExhYihvLmwsIG8uYSwgby5iLCBvLm9wYWNpdHkpO1xyXG4gIGlmIChvIGluc3RhbmNlb2YgSGNsKSB7XHJcbiAgICBpZiAoaXNOYU4oby5oKSkgcmV0dXJuIG5ldyBMYWIoby5sLCAwLCAwLCBvLm9wYWNpdHkpO1xyXG4gICAgdmFyIGggPSBvLmggKiBkZWcycmFkO1xyXG4gICAgcmV0dXJuIG5ldyBMYWIoby5sLCBNYXRoLmNvcyhoKSAqIG8uYywgTWF0aC5zaW4oaCkgKiBvLmMsIG8ub3BhY2l0eSk7XHJcbiAgfVxyXG4gIGlmICghKG8gaW5zdGFuY2VvZiBSZ2IpKSBvID0gcmdiQ29udmVydChvKTtcclxuICB2YXIgciA9IHJnYjJscmdiKG8uciksXHJcbiAgICAgIGcgPSByZ2IybHJnYihvLmcpLFxyXG4gICAgICBiID0gcmdiMmxyZ2Ioby5iKSxcclxuICAgICAgeSA9IHh5ejJsYWIoKDAuMjIyNTA0NSAqIHIgKyAwLjcxNjg3ODYgKiBnICsgMC4wNjA2MTY5ICogYikgLyBZbiksIHgsIHo7XHJcbiAgaWYgKHIgPT09IGcgJiYgZyA9PT0gYikgeCA9IHogPSB5OyBlbHNlIHtcclxuICAgIHggPSB4eXoybGFiKCgwLjQzNjA3NDcgKiByICsgMC4zODUwNjQ5ICogZyArIDAuMTQzMDgwNCAqIGIpIC8gWG4pO1xyXG4gICAgeiA9IHh5ejJsYWIoKDAuMDEzOTMyMiAqIHIgKyAwLjA5NzEwNDUgKiBnICsgMC43MTQxNzMzICogYikgLyBabik7XHJcbiAgfVxyXG4gIHJldHVybiBuZXcgTGFiKDExNiAqIHkgLSAxNiwgNTAwICogKHggLSB5KSwgMjAwICogKHkgLSB6KSwgby5vcGFjaXR5KTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ3JheShsLCBvcGFjaXR5KSB7XHJcbiAgcmV0dXJuIG5ldyBMYWIobCwgMCwgMCwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBsYWIobCwgYSwgYiwgb3BhY2l0eSkge1xyXG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gbGFiQ29udmVydChsKSA6IG5ldyBMYWIobCwgYSwgYiwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBMYWIobCwgYSwgYiwgb3BhY2l0eSkge1xyXG4gIHRoaXMubCA9ICtsO1xyXG4gIHRoaXMuYSA9ICthO1xyXG4gIHRoaXMuYiA9ICtiO1xyXG4gIHRoaXMub3BhY2l0eSA9ICtvcGFjaXR5O1xyXG59XHJcblxyXG5kZWZpbmUoTGFiLCBsYWIsIGV4dGVuZChDb2xvciwge1xyXG4gIGJyaWdodGVyOiBmdW5jdGlvbihrKSB7XHJcbiAgICByZXR1cm4gbmV3IExhYih0aGlzLmwgKyBLICogKGsgPT0gbnVsbCA/IDEgOiBrKSwgdGhpcy5hLCB0aGlzLmIsIHRoaXMub3BhY2l0eSk7XHJcbiAgfSxcclxuICBkYXJrZXI6IGZ1bmN0aW9uKGspIHtcclxuICAgIHJldHVybiBuZXcgTGFiKHRoaXMubCAtIEsgKiAoayA9PSBudWxsID8gMSA6IGspLCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5vcGFjaXR5KTtcclxuICB9LFxyXG4gIHJnYjogZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgeSA9ICh0aGlzLmwgKyAxNikgLyAxMTYsXHJcbiAgICAgICAgeCA9IGlzTmFOKHRoaXMuYSkgPyB5IDogeSArIHRoaXMuYSAvIDUwMCxcclxuICAgICAgICB6ID0gaXNOYU4odGhpcy5iKSA/IHkgOiB5IC0gdGhpcy5iIC8gMjAwO1xyXG4gICAgeCA9IFhuICogbGFiMnh5eih4KTtcclxuICAgIHkgPSBZbiAqIGxhYjJ4eXooeSk7XHJcbiAgICB6ID0gWm4gKiBsYWIyeHl6KHopO1xyXG4gICAgcmV0dXJuIG5ldyBSZ2IoXHJcbiAgICAgIGxyZ2IycmdiKCAzLjEzMzg1NjEgKiB4IC0gMS42MTY4NjY3ICogeSAtIDAuNDkwNjE0NiAqIHopLFxyXG4gICAgICBscmdiMnJnYigtMC45Nzg3Njg0ICogeCArIDEuOTE2MTQxNSAqIHkgKyAwLjAzMzQ1NDAgKiB6KSxcclxuICAgICAgbHJnYjJyZ2IoIDAuMDcxOTQ1MyAqIHggLSAwLjIyODk5MTQgKiB5ICsgMS40MDUyNDI3ICogeiksXHJcbiAgICAgIHRoaXMub3BhY2l0eVxyXG4gICAgKTtcclxuICB9XHJcbn0pKTtcclxuXHJcbmZ1bmN0aW9uIHh5ejJsYWIodCkge1xyXG4gIHJldHVybiB0ID4gdDMgPyBNYXRoLnBvdyh0LCAxIC8gMykgOiB0IC8gdDIgKyB0MDtcclxufVxyXG5cclxuZnVuY3Rpb24gbGFiMnh5eih0KSB7XHJcbiAgcmV0dXJuIHQgPiB0MSA/IHQgKiB0ICogdCA6IHQyICogKHQgLSB0MCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxyZ2IycmdiKHgpIHtcclxuICByZXR1cm4gMjU1ICogKHggPD0gMC4wMDMxMzA4ID8gMTIuOTIgKiB4IDogMS4wNTUgKiBNYXRoLnBvdyh4LCAxIC8gMi40KSAtIDAuMDU1KTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmdiMmxyZ2IoeCkge1xyXG4gIHJldHVybiAoeCAvPSAyNTUpIDw9IDAuMDQwNDUgPyB4IC8gMTIuOTIgOiBNYXRoLnBvdygoeCArIDAuMDU1KSAvIDEuMDU1LCAyLjQpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBoY2xDb252ZXJ0KG8pIHtcclxuICBpZiAobyBpbnN0YW5jZW9mIEhjbCkgcmV0dXJuIG5ldyBIY2woby5oLCBvLmMsIG8ubCwgby5vcGFjaXR5KTtcclxuICBpZiAoIShvIGluc3RhbmNlb2YgTGFiKSkgbyA9IGxhYkNvbnZlcnQobyk7XHJcbiAgaWYgKG8uYSA9PT0gMCAmJiBvLmIgPT09IDApIHJldHVybiBuZXcgSGNsKE5hTiwgMCwgby5sLCBvLm9wYWNpdHkpO1xyXG4gIHZhciBoID0gTWF0aC5hdGFuMihvLmIsIG8uYSkgKiByYWQyZGVnO1xyXG4gIHJldHVybiBuZXcgSGNsKGggPCAwID8gaCArIDM2MCA6IGgsIE1hdGguc3FydChvLmEgKiBvLmEgKyBvLmIgKiBvLmIpLCBvLmwsIG8ub3BhY2l0eSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxjaChsLCBjLCBoLCBvcGFjaXR5KSB7XHJcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBoY2xDb252ZXJ0KGwpIDogbmV3IEhjbChoLCBjLCBsLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhjbChoLCBjLCBsLCBvcGFjaXR5KSB7XHJcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBoY2xDb252ZXJ0KGgpIDogbmV3IEhjbChoLCBjLCBsLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEhjbChoLCBjLCBsLCBvcGFjaXR5KSB7XHJcbiAgdGhpcy5oID0gK2g7XHJcbiAgdGhpcy5jID0gK2M7XHJcbiAgdGhpcy5sID0gK2w7XHJcbiAgdGhpcy5vcGFjaXR5ID0gK29wYWNpdHk7XHJcbn1cclxuXHJcbmRlZmluZShIY2wsIGhjbCwgZXh0ZW5kKENvbG9yLCB7XHJcbiAgYnJpZ2h0ZXI6IGZ1bmN0aW9uKGspIHtcclxuICAgIHJldHVybiBuZXcgSGNsKHRoaXMuaCwgdGhpcy5jLCB0aGlzLmwgKyBLICogKGsgPT0gbnVsbCA/IDEgOiBrKSwgdGhpcy5vcGFjaXR5KTtcclxuICB9LFxyXG4gIGRhcmtlcjogZnVuY3Rpb24oaykge1xyXG4gICAgcmV0dXJuIG5ldyBIY2wodGhpcy5oLCB0aGlzLmMsIHRoaXMubCAtIEsgKiAoayA9PSBudWxsID8gMSA6IGspLCB0aGlzLm9wYWNpdHkpO1xyXG4gIH0sXHJcbiAgcmdiOiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBsYWJDb252ZXJ0KHRoaXMpLnJnYigpO1xyXG4gIH1cclxufSkpO1xyXG5cclxudmFyIEEgPSAtMC4xNDg2MSxcclxuICAgIEIgPSArMS43ODI3NyxcclxuICAgIEMgPSAtMC4yOTIyNyxcclxuICAgIEQgPSAtMC45MDY0OSxcclxuICAgIEUgPSArMS45NzI5NCxcclxuICAgIEVEID0gRSAqIEQsXHJcbiAgICBFQiA9IEUgKiBCLFxyXG4gICAgQkNfREEgPSBCICogQyAtIEQgKiBBO1xyXG5cclxuZnVuY3Rpb24gY3ViZWhlbGl4Q29udmVydChvKSB7XHJcbiAgaWYgKG8gaW5zdGFuY2VvZiBDdWJlaGVsaXgpIHJldHVybiBuZXcgQ3ViZWhlbGl4KG8uaCwgby5zLCBvLmwsIG8ub3BhY2l0eSk7XHJcbiAgaWYgKCEobyBpbnN0YW5jZW9mIFJnYikpIG8gPSByZ2JDb252ZXJ0KG8pO1xyXG4gIHZhciByID0gby5yIC8gMjU1LFxyXG4gICAgICBnID0gby5nIC8gMjU1LFxyXG4gICAgICBiID0gby5iIC8gMjU1LFxyXG4gICAgICBsID0gKEJDX0RBICogYiArIEVEICogciAtIEVCICogZykgLyAoQkNfREEgKyBFRCAtIEVCKSxcclxuICAgICAgYmwgPSBiIC0gbCxcclxuICAgICAgayA9IChFICogKGcgLSBsKSAtIEMgKiBibCkgLyBELFxyXG4gICAgICBzID0gTWF0aC5zcXJ0KGsgKiBrICsgYmwgKiBibCkgLyAoRSAqIGwgKiAoMSAtIGwpKSwgLy8gTmFOIGlmIGw9MCBvciBsPTFcclxuICAgICAgaCA9IHMgPyBNYXRoLmF0YW4yKGssIGJsKSAqIHJhZDJkZWcgLSAxMjAgOiBOYU47XHJcbiAgcmV0dXJuIG5ldyBDdWJlaGVsaXgoaCA8IDAgPyBoICsgMzYwIDogaCwgcywgbCwgby5vcGFjaXR5KTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3ViZWhlbGl4KGgsIHMsIGwsIG9wYWNpdHkpIHtcclxuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IGN1YmVoZWxpeENvbnZlcnQoaCkgOiBuZXcgQ3ViZWhlbGl4KGgsIHMsIGwsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcclxufVxyXG5cclxuZnVuY3Rpb24gQ3ViZWhlbGl4KGgsIHMsIGwsIG9wYWNpdHkpIHtcclxuICB0aGlzLmggPSAraDtcclxuICB0aGlzLnMgPSArcztcclxuICB0aGlzLmwgPSArbDtcclxuICB0aGlzLm9wYWNpdHkgPSArb3BhY2l0eTtcclxufVxyXG5cclxuZGVmaW5lKEN1YmVoZWxpeCwgY3ViZWhlbGl4LCBleHRlbmQoQ29sb3IsIHtcclxuICBicmlnaHRlcjogZnVuY3Rpb24oaykge1xyXG4gICAgayA9IGsgPT0gbnVsbCA/IGJyaWdodGVyIDogTWF0aC5wb3coYnJpZ2h0ZXIsIGspO1xyXG4gICAgcmV0dXJuIG5ldyBDdWJlaGVsaXgodGhpcy5oLCB0aGlzLnMsIHRoaXMubCAqIGssIHRoaXMub3BhY2l0eSk7XHJcbiAgfSxcclxuICBkYXJrZXI6IGZ1bmN0aW9uKGspIHtcclxuICAgIGsgPSBrID09IG51bGwgPyBkYXJrZXIgOiBNYXRoLnBvdyhkYXJrZXIsIGspO1xyXG4gICAgcmV0dXJuIG5ldyBDdWJlaGVsaXgodGhpcy5oLCB0aGlzLnMsIHRoaXMubCAqIGssIHRoaXMub3BhY2l0eSk7XHJcbiAgfSxcclxuICByZ2I6IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGggPSBpc05hTih0aGlzLmgpID8gMCA6ICh0aGlzLmggKyAxMjApICogZGVnMnJhZCxcclxuICAgICAgICBsID0gK3RoaXMubCxcclxuICAgICAgICBhID0gaXNOYU4odGhpcy5zKSA/IDAgOiB0aGlzLnMgKiBsICogKDEgLSBsKSxcclxuICAgICAgICBjb3NoID0gTWF0aC5jb3MoaCksXHJcbiAgICAgICAgc2luaCA9IE1hdGguc2luKGgpO1xyXG4gICAgcmV0dXJuIG5ldyBSZ2IoXHJcbiAgICAgIDI1NSAqIChsICsgYSAqIChBICogY29zaCArIEIgKiBzaW5oKSksXHJcbiAgICAgIDI1NSAqIChsICsgYSAqIChDICogY29zaCArIEQgKiBzaW5oKSksXHJcbiAgICAgIDI1NSAqIChsICsgYSAqIChFICogY29zaCkpLFxyXG4gICAgICB0aGlzLm9wYWNpdHlcclxuICAgICk7XHJcbiAgfVxyXG59KSk7XHJcblxyXG5mdW5jdGlvbiBiYXNpcyh0MSwgdjAsIHYxLCB2MiwgdjMpIHtcclxuICB2YXIgdDIgPSB0MSAqIHQxLCB0MyA9IHQyICogdDE7XHJcbiAgcmV0dXJuICgoMSAtIDMgKiB0MSArIDMgKiB0MiAtIHQzKSAqIHYwXHJcbiAgICAgICsgKDQgLSA2ICogdDIgKyAzICogdDMpICogdjFcclxuICAgICAgKyAoMSArIDMgKiB0MSArIDMgKiB0MiAtIDMgKiB0MykgKiB2MlxyXG4gICAgICArIHQzICogdjMpIC8gNjtcclxufVxyXG5cclxuZnVuY3Rpb24gYmFzaXMkMSh2YWx1ZXMpIHtcclxuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGggLSAxO1xyXG4gIHJldHVybiBmdW5jdGlvbih0KSB7XHJcbiAgICB2YXIgaSA9IHQgPD0gMCA/ICh0ID0gMCkgOiB0ID49IDEgPyAodCA9IDEsIG4gLSAxKSA6IE1hdGguZmxvb3IodCAqIG4pLFxyXG4gICAgICAgIHYxID0gdmFsdWVzW2ldLFxyXG4gICAgICAgIHYyID0gdmFsdWVzW2kgKyAxXSxcclxuICAgICAgICB2MCA9IGkgPiAwID8gdmFsdWVzW2kgLSAxXSA6IDIgKiB2MSAtIHYyLFxyXG4gICAgICAgIHYzID0gaSA8IG4gLSAxID8gdmFsdWVzW2kgKyAyXSA6IDIgKiB2MiAtIHYxO1xyXG4gICAgcmV0dXJuIGJhc2lzKCh0IC0gaSAvIG4pICogbiwgdjAsIHYxLCB2MiwgdjMpO1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGJhc2lzQ2xvc2VkKHZhbHVlcykge1xyXG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aDtcclxuICByZXR1cm4gZnVuY3Rpb24odCkge1xyXG4gICAgdmFyIGkgPSBNYXRoLmZsb29yKCgodCAlPSAxKSA8IDAgPyArK3QgOiB0KSAqIG4pLFxyXG4gICAgICAgIHYwID0gdmFsdWVzWyhpICsgbiAtIDEpICUgbl0sXHJcbiAgICAgICAgdjEgPSB2YWx1ZXNbaSAlIG5dLFxyXG4gICAgICAgIHYyID0gdmFsdWVzWyhpICsgMSkgJSBuXSxcclxuICAgICAgICB2MyA9IHZhbHVlc1soaSArIDIpICUgbl07XHJcbiAgICByZXR1cm4gYmFzaXMoKHQgLSBpIC8gbikgKiBuLCB2MCwgdjEsIHYyLCB2Myk7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gY29uc3RhbnQkMyh4KSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHg7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gbGluZWFyKGEsIGQpIHtcclxuICByZXR1cm4gZnVuY3Rpb24odCkge1xyXG4gICAgcmV0dXJuIGEgKyB0ICogZDtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBleHBvbmVudGlhbChhLCBiLCB5KSB7XHJcbiAgcmV0dXJuIGEgPSBNYXRoLnBvdyhhLCB5KSwgYiA9IE1hdGgucG93KGIsIHkpIC0gYSwgeSA9IDEgLyB5LCBmdW5jdGlvbih0KSB7XHJcbiAgICByZXR1cm4gTWF0aC5wb3coYSArIHQgKiBiLCB5KTtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBodWUoYSwgYikge1xyXG4gIHZhciBkID0gYiAtIGE7XHJcbiAgcmV0dXJuIGQgPyBsaW5lYXIoYSwgZCA+IDE4MCB8fCBkIDwgLTE4MCA/IGQgLSAzNjAgKiBNYXRoLnJvdW5kKGQgLyAzNjApIDogZCkgOiBjb25zdGFudCQzKGlzTmFOKGEpID8gYiA6IGEpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnYW1tYSh5KSB7XHJcbiAgcmV0dXJuICh5ID0gK3kpID09PSAxID8gbm9nYW1tYSA6IGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgIHJldHVybiBiIC0gYSA/IGV4cG9uZW50aWFsKGEsIGIsIHkpIDogY29uc3RhbnQkMyhpc05hTihhKSA/IGIgOiBhKTtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBub2dhbW1hKGEsIGIpIHtcclxuICB2YXIgZCA9IGIgLSBhO1xyXG4gIHJldHVybiBkID8gbGluZWFyKGEsIGQpIDogY29uc3RhbnQkMyhpc05hTihhKSA/IGIgOiBhKTtcclxufVxyXG5cclxudmFyIGludGVycG9sYXRlUmdiID0gKGZ1bmN0aW9uIHJnYkdhbW1hKHkpIHtcclxuICB2YXIgY29sb3IkJDEgPSBnYW1tYSh5KTtcclxuXHJcbiAgZnVuY3Rpb24gcmdiJCQxKHN0YXJ0LCBlbmQpIHtcclxuICAgIHZhciByID0gY29sb3IkJDEoKHN0YXJ0ID0gcmdiKHN0YXJ0KSkuciwgKGVuZCA9IHJnYihlbmQpKS5yKSxcclxuICAgICAgICBnID0gY29sb3IkJDEoc3RhcnQuZywgZW5kLmcpLFxyXG4gICAgICAgIGIgPSBjb2xvciQkMShzdGFydC5iLCBlbmQuYiksXHJcbiAgICAgICAgb3BhY2l0eSA9IG5vZ2FtbWEoc3RhcnQub3BhY2l0eSwgZW5kLm9wYWNpdHkpO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcclxuICAgICAgc3RhcnQuciA9IHIodCk7XHJcbiAgICAgIHN0YXJ0LmcgPSBnKHQpO1xyXG4gICAgICBzdGFydC5iID0gYih0KTtcclxuICAgICAgc3RhcnQub3BhY2l0eSA9IG9wYWNpdHkodCk7XHJcbiAgICAgIHJldHVybiBzdGFydCArIFwiXCI7XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgcmdiJCQxLmdhbW1hID0gcmdiR2FtbWE7XHJcblxyXG4gIHJldHVybiByZ2IkJDE7XHJcbn0pKDEpO1xyXG5cclxuZnVuY3Rpb24gcmdiU3BsaW5lKHNwbGluZSkge1xyXG4gIHJldHVybiBmdW5jdGlvbihjb2xvcnMpIHtcclxuICAgIHZhciBuID0gY29sb3JzLmxlbmd0aCxcclxuICAgICAgICByID0gbmV3IEFycmF5KG4pLFxyXG4gICAgICAgIGcgPSBuZXcgQXJyYXkobiksXHJcbiAgICAgICAgYiA9IG5ldyBBcnJheShuKSxcclxuICAgICAgICBpLCBjb2xvciQkMTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcclxuICAgICAgY29sb3IkJDEgPSByZ2IoY29sb3JzW2ldKTtcclxuICAgICAgcltpXSA9IGNvbG9yJCQxLnIgfHwgMDtcclxuICAgICAgZ1tpXSA9IGNvbG9yJCQxLmcgfHwgMDtcclxuICAgICAgYltpXSA9IGNvbG9yJCQxLmIgfHwgMDtcclxuICAgIH1cclxuICAgIHIgPSBzcGxpbmUocik7XHJcbiAgICBnID0gc3BsaW5lKGcpO1xyXG4gICAgYiA9IHNwbGluZShiKTtcclxuICAgIGNvbG9yJCQxLm9wYWNpdHkgPSAxO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcclxuICAgICAgY29sb3IkJDEuciA9IHIodCk7XHJcbiAgICAgIGNvbG9yJCQxLmcgPSBnKHQpO1xyXG4gICAgICBjb2xvciQkMS5iID0gYih0KTtcclxuICAgICAgcmV0dXJuIGNvbG9yJCQxICsgXCJcIjtcclxuICAgIH07XHJcbiAgfTtcclxufVxyXG5cclxudmFyIHJnYkJhc2lzID0gcmdiU3BsaW5lKGJhc2lzJDEpO1xyXG52YXIgcmdiQmFzaXNDbG9zZWQgPSByZ2JTcGxpbmUoYmFzaXNDbG9zZWQpO1xyXG5cclxuZnVuY3Rpb24gYXJyYXkkMShhLCBiKSB7XHJcbiAgdmFyIG5iID0gYiA/IGIubGVuZ3RoIDogMCxcclxuICAgICAgbmEgPSBhID8gTWF0aC5taW4obmIsIGEubGVuZ3RoKSA6IDAsXHJcbiAgICAgIHggPSBuZXcgQXJyYXkobmEpLFxyXG4gICAgICBjID0gbmV3IEFycmF5KG5iKSxcclxuICAgICAgaTtcclxuXHJcbiAgZm9yIChpID0gMDsgaSA8IG5hOyArK2kpIHhbaV0gPSBpbnRlcnBvbGF0ZVZhbHVlKGFbaV0sIGJbaV0pO1xyXG4gIGZvciAoOyBpIDwgbmI7ICsraSkgY1tpXSA9IGJbaV07XHJcblxyXG4gIHJldHVybiBmdW5jdGlvbih0KSB7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbmE7ICsraSkgY1tpXSA9IHhbaV0odCk7XHJcbiAgICByZXR1cm4gYztcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBkYXRlKGEsIGIpIHtcclxuICB2YXIgZCA9IG5ldyBEYXRlO1xyXG4gIHJldHVybiBhID0gK2EsIGIgLT0gYSwgZnVuY3Rpb24odCkge1xyXG4gICAgcmV0dXJuIGQuc2V0VGltZShhICsgYiAqIHQpLCBkO1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlaW50ZXJwb2xhdGUoYSwgYikge1xyXG4gIHJldHVybiBhID0gK2EsIGIgLT0gYSwgZnVuY3Rpb24odCkge1xyXG4gICAgcmV0dXJuIGEgKyBiICogdDtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBvYmplY3QoYSwgYikge1xyXG4gIHZhciBpID0ge30sXHJcbiAgICAgIGMgPSB7fSxcclxuICAgICAgaztcclxuXHJcbiAgaWYgKGEgPT09IG51bGwgfHwgdHlwZW9mIGEgIT09IFwib2JqZWN0XCIpIGEgPSB7fTtcclxuICBpZiAoYiA9PT0gbnVsbCB8fCB0eXBlb2YgYiAhPT0gXCJvYmplY3RcIikgYiA9IHt9O1xyXG5cclxuICBmb3IgKGsgaW4gYikge1xyXG4gICAgaWYgKGsgaW4gYSkge1xyXG4gICAgICBpW2tdID0gaW50ZXJwb2xhdGVWYWx1ZShhW2tdLCBiW2tdKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNba10gPSBiW2tdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcclxuICAgIGZvciAoayBpbiBpKSBjW2tdID0gaVtrXSh0KTtcclxuICAgIHJldHVybiBjO1xyXG4gIH07XHJcbn1cclxuXHJcbnZhciByZUEgPSAvWy0rXT8oPzpcXGQrXFwuP1xcZCp8XFwuP1xcZCspKD86W2VFXVstK10/XFxkKyk/L2csXHJcbiAgICByZUIgPSBuZXcgUmVnRXhwKHJlQS5zb3VyY2UsIFwiZ1wiKTtcclxuXHJcbmZ1bmN0aW9uIHplcm8oYikge1xyXG4gIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBiO1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG9uZShiKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcclxuICAgIHJldHVybiBiKHQpICsgXCJcIjtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZVN0cmluZyhhLCBiKSB7XHJcbiAgdmFyIGJpID0gcmVBLmxhc3RJbmRleCA9IHJlQi5sYXN0SW5kZXggPSAwLCAvLyBzY2FuIGluZGV4IGZvciBuZXh0IG51bWJlciBpbiBiXHJcbiAgICAgIGFtLCAvLyBjdXJyZW50IG1hdGNoIGluIGFcclxuICAgICAgYm0sIC8vIGN1cnJlbnQgbWF0Y2ggaW4gYlxyXG4gICAgICBicywgLy8gc3RyaW5nIHByZWNlZGluZyBjdXJyZW50IG51bWJlciBpbiBiLCBpZiBhbnlcclxuICAgICAgaSA9IC0xLCAvLyBpbmRleCBpbiBzXHJcbiAgICAgIHMgPSBbXSwgLy8gc3RyaW5nIGNvbnN0YW50cyBhbmQgcGxhY2Vob2xkZXJzXHJcbiAgICAgIHEgPSBbXTsgLy8gbnVtYmVyIGludGVycG9sYXRvcnNcclxuXHJcbiAgLy8gQ29lcmNlIGlucHV0cyB0byBzdHJpbmdzLlxyXG4gIGEgPSBhICsgXCJcIiwgYiA9IGIgKyBcIlwiO1xyXG5cclxuICAvLyBJbnRlcnBvbGF0ZSBwYWlycyBvZiBudW1iZXJzIGluIGEgJiBiLlxyXG4gIHdoaWxlICgoYW0gPSByZUEuZXhlYyhhKSlcclxuICAgICAgJiYgKGJtID0gcmVCLmV4ZWMoYikpKSB7XHJcbiAgICBpZiAoKGJzID0gYm0uaW5kZXgpID4gYmkpIHsgLy8gYSBzdHJpbmcgcHJlY2VkZXMgdGhlIG5leHQgbnVtYmVyIGluIGJcclxuICAgICAgYnMgPSBiLnNsaWNlKGJpLCBicyk7XHJcbiAgICAgIGlmIChzW2ldKSBzW2ldICs9IGJzOyAvLyBjb2FsZXNjZSB3aXRoIHByZXZpb3VzIHN0cmluZ1xyXG4gICAgICBlbHNlIHNbKytpXSA9IGJzO1xyXG4gICAgfVxyXG4gICAgaWYgKChhbSA9IGFtWzBdKSA9PT0gKGJtID0gYm1bMF0pKSB7IC8vIG51bWJlcnMgaW4gYSAmIGIgbWF0Y2hcclxuICAgICAgaWYgKHNbaV0pIHNbaV0gKz0gYm07IC8vIGNvYWxlc2NlIHdpdGggcHJldmlvdXMgc3RyaW5nXHJcbiAgICAgIGVsc2Ugc1srK2ldID0gYm07XHJcbiAgICB9IGVsc2UgeyAvLyBpbnRlcnBvbGF0ZSBub24tbWF0Y2hpbmcgbnVtYmVyc1xyXG4gICAgICBzWysraV0gPSBudWxsO1xyXG4gICAgICBxLnB1c2goe2k6IGksIHg6IHJlaW50ZXJwb2xhdGUoYW0sIGJtKX0pO1xyXG4gICAgfVxyXG4gICAgYmkgPSByZUIubGFzdEluZGV4O1xyXG4gIH1cclxuXHJcbiAgLy8gQWRkIHJlbWFpbnMgb2YgYi5cclxuICBpZiAoYmkgPCBiLmxlbmd0aCkge1xyXG4gICAgYnMgPSBiLnNsaWNlKGJpKTtcclxuICAgIGlmIChzW2ldKSBzW2ldICs9IGJzOyAvLyBjb2FsZXNjZSB3aXRoIHByZXZpb3VzIHN0cmluZ1xyXG4gICAgZWxzZSBzWysraV0gPSBicztcclxuICB9XHJcblxyXG4gIC8vIFNwZWNpYWwgb3B0aW1pemF0aW9uIGZvciBvbmx5IGEgc2luZ2xlIG1hdGNoLlxyXG4gIC8vIE90aGVyd2lzZSwgaW50ZXJwb2xhdGUgZWFjaCBvZiB0aGUgbnVtYmVycyBhbmQgcmVqb2luIHRoZSBzdHJpbmcuXHJcbiAgcmV0dXJuIHMubGVuZ3RoIDwgMiA/IChxWzBdXHJcbiAgICAgID8gb25lKHFbMF0ueClcclxuICAgICAgOiB6ZXJvKGIpKVxyXG4gICAgICA6IChiID0gcS5sZW5ndGgsIGZ1bmN0aW9uKHQpIHtcclxuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBvOyBpIDwgYjsgKytpKSBzWyhvID0gcVtpXSkuaV0gPSBvLngodCk7XHJcbiAgICAgICAgICByZXR1cm4gcy5qb2luKFwiXCIpO1xyXG4gICAgICAgIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZVZhbHVlKGEsIGIpIHtcclxuICB2YXIgdCA9IHR5cGVvZiBiLCBjO1xyXG4gIHJldHVybiBiID09IG51bGwgfHwgdCA9PT0gXCJib29sZWFuXCIgPyBjb25zdGFudCQzKGIpXHJcbiAgICAgIDogKHQgPT09IFwibnVtYmVyXCIgPyByZWludGVycG9sYXRlXHJcbiAgICAgIDogdCA9PT0gXCJzdHJpbmdcIiA/ICgoYyA9IGNvbG9yKGIpKSA/IChiID0gYywgaW50ZXJwb2xhdGVSZ2IpIDogaW50ZXJwb2xhdGVTdHJpbmcpXHJcbiAgICAgIDogYiBpbnN0YW5jZW9mIGNvbG9yID8gaW50ZXJwb2xhdGVSZ2JcclxuICAgICAgOiBiIGluc3RhbmNlb2YgRGF0ZSA/IGRhdGVcclxuICAgICAgOiBBcnJheS5pc0FycmF5KGIpID8gYXJyYXkkMVxyXG4gICAgICA6IHR5cGVvZiBiLnZhbHVlT2YgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgYi50b1N0cmluZyAhPT0gXCJmdW5jdGlvblwiIHx8IGlzTmFOKGIpID8gb2JqZWN0XHJcbiAgICAgIDogcmVpbnRlcnBvbGF0ZSkoYSwgYik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGludGVycG9sYXRlUm91bmQoYSwgYikge1xyXG4gIHJldHVybiBhID0gK2EsIGIgLT0gYSwgZnVuY3Rpb24odCkge1xyXG4gICAgcmV0dXJuIE1hdGgucm91bmQoYSArIGIgKiB0KTtcclxuICB9O1xyXG59XHJcblxyXG52YXIgZGVncmVlcyA9IDE4MCAvIE1hdGguUEk7XHJcblxyXG52YXIgaWRlbnRpdHkkMiA9IHtcclxuICB0cmFuc2xhdGVYOiAwLFxyXG4gIHRyYW5zbGF0ZVk6IDAsXHJcbiAgcm90YXRlOiAwLFxyXG4gIHNrZXdYOiAwLFxyXG4gIHNjYWxlWDogMSxcclxuICBzY2FsZVk6IDFcclxufTtcclxuXHJcbmZ1bmN0aW9uIGRlY29tcG9zZShhLCBiLCBjLCBkLCBlLCBmKSB7XHJcbiAgdmFyIHNjYWxlWCwgc2NhbGVZLCBza2V3WDtcclxuICBpZiAoc2NhbGVYID0gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpKSBhIC89IHNjYWxlWCwgYiAvPSBzY2FsZVg7XHJcbiAgaWYgKHNrZXdYID0gYSAqIGMgKyBiICogZCkgYyAtPSBhICogc2tld1gsIGQgLT0gYiAqIHNrZXdYO1xyXG4gIGlmIChzY2FsZVkgPSBNYXRoLnNxcnQoYyAqIGMgKyBkICogZCkpIGMgLz0gc2NhbGVZLCBkIC89IHNjYWxlWSwgc2tld1ggLz0gc2NhbGVZO1xyXG4gIGlmIChhICogZCA8IGIgKiBjKSBhID0gLWEsIGIgPSAtYiwgc2tld1ggPSAtc2tld1gsIHNjYWxlWCA9IC1zY2FsZVg7XHJcbiAgcmV0dXJuIHtcclxuICAgIHRyYW5zbGF0ZVg6IGUsXHJcbiAgICB0cmFuc2xhdGVZOiBmLFxyXG4gICAgcm90YXRlOiBNYXRoLmF0YW4yKGIsIGEpICogZGVncmVlcyxcclxuICAgIHNrZXdYOiBNYXRoLmF0YW4oc2tld1gpICogZGVncmVlcyxcclxuICAgIHNjYWxlWDogc2NhbGVYLFxyXG4gICAgc2NhbGVZOiBzY2FsZVlcclxuICB9O1xyXG59XHJcblxyXG52YXIgY3NzTm9kZSxcclxuICAgIGNzc1Jvb3QsXHJcbiAgICBjc3NWaWV3LFxyXG4gICAgc3ZnTm9kZTtcclxuXHJcbmZ1bmN0aW9uIHBhcnNlQ3NzKHZhbHVlKSB7XHJcbiAgaWYgKHZhbHVlID09PSBcIm5vbmVcIikgcmV0dXJuIGlkZW50aXR5JDI7XHJcbiAgaWYgKCFjc3NOb2RlKSBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkRJVlwiKSwgY3NzUm9vdCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgY3NzVmlldyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3O1xyXG4gIGNzc05vZGUuc3R5bGUudHJhbnNmb3JtID0gdmFsdWU7XHJcbiAgdmFsdWUgPSBjc3NWaWV3LmdldENvbXB1dGVkU3R5bGUoY3NzUm9vdC5hcHBlbmRDaGlsZChjc3NOb2RlKSwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShcInRyYW5zZm9ybVwiKTtcclxuICBjc3NSb290LnJlbW92ZUNoaWxkKGNzc05vZGUpO1xyXG4gIHZhbHVlID0gdmFsdWUuc2xpY2UoNywgLTEpLnNwbGl0KFwiLFwiKTtcclxuICByZXR1cm4gZGVjb21wb3NlKCt2YWx1ZVswXSwgK3ZhbHVlWzFdLCArdmFsdWVbMl0sICt2YWx1ZVszXSwgK3ZhbHVlWzRdLCArdmFsdWVbNV0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYXJzZVN2Zyh2YWx1ZSkge1xyXG4gIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gaWRlbnRpdHkkMjtcclxuICBpZiAoIXN2Z05vZGUpIHN2Z05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcImdcIik7XHJcbiAgc3ZnTm9kZS5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgdmFsdWUpO1xyXG4gIGlmICghKHZhbHVlID0gc3ZnTm9kZS50cmFuc2Zvcm0uYmFzZVZhbC5jb25zb2xpZGF0ZSgpKSkgcmV0dXJuIGlkZW50aXR5JDI7XHJcbiAgdmFsdWUgPSB2YWx1ZS5tYXRyaXg7XHJcbiAgcmV0dXJuIGRlY29tcG9zZSh2YWx1ZS5hLCB2YWx1ZS5iLCB2YWx1ZS5jLCB2YWx1ZS5kLCB2YWx1ZS5lLCB2YWx1ZS5mKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaW50ZXJwb2xhdGVUcmFuc2Zvcm0ocGFyc2UsIHB4Q29tbWEsIHB4UGFyZW4sIGRlZ1BhcmVuKSB7XHJcblxyXG4gIGZ1bmN0aW9uIHBvcChzKSB7XHJcbiAgICByZXR1cm4gcy5sZW5ndGggPyBzLnBvcCgpICsgXCIgXCIgOiBcIlwiO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdHJhbnNsYXRlKHhhLCB5YSwgeGIsIHliLCBzLCBxKSB7XHJcbiAgICBpZiAoeGEgIT09IHhiIHx8IHlhICE9PSB5Yikge1xyXG4gICAgICB2YXIgaSA9IHMucHVzaChcInRyYW5zbGF0ZShcIiwgbnVsbCwgcHhDb21tYSwgbnVsbCwgcHhQYXJlbik7XHJcbiAgICAgIHEucHVzaCh7aTogaSAtIDQsIHg6IHJlaW50ZXJwb2xhdGUoeGEsIHhiKX0sIHtpOiBpIC0gMiwgeDogcmVpbnRlcnBvbGF0ZSh5YSwgeWIpfSk7XHJcbiAgICB9IGVsc2UgaWYgKHhiIHx8IHliKSB7XHJcbiAgICAgIHMucHVzaChcInRyYW5zbGF0ZShcIiArIHhiICsgcHhDb21tYSArIHliICsgcHhQYXJlbik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByb3RhdGUoYSwgYiwgcywgcSkge1xyXG4gICAgaWYgKGEgIT09IGIpIHtcclxuICAgICAgaWYgKGEgLSBiID4gMTgwKSBiICs9IDM2MDsgZWxzZSBpZiAoYiAtIGEgPiAxODApIGEgKz0gMzYwOyAvLyBzaG9ydGVzdCBwYXRoXHJcbiAgICAgIHEucHVzaCh7aTogcy5wdXNoKHBvcChzKSArIFwicm90YXRlKFwiLCBudWxsLCBkZWdQYXJlbikgLSAyLCB4OiByZWludGVycG9sYXRlKGEsIGIpfSk7XHJcbiAgICB9IGVsc2UgaWYgKGIpIHtcclxuICAgICAgcy5wdXNoKHBvcChzKSArIFwicm90YXRlKFwiICsgYiArIGRlZ1BhcmVuKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHNrZXdYKGEsIGIsIHMsIHEpIHtcclxuICAgIGlmIChhICE9PSBiKSB7XHJcbiAgICAgIHEucHVzaCh7aTogcy5wdXNoKHBvcChzKSArIFwic2tld1goXCIsIG51bGwsIGRlZ1BhcmVuKSAtIDIsIHg6IHJlaW50ZXJwb2xhdGUoYSwgYil9KTtcclxuICAgIH0gZWxzZSBpZiAoYikge1xyXG4gICAgICBzLnB1c2gocG9wKHMpICsgXCJza2V3WChcIiArIGIgKyBkZWdQYXJlbik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzY2FsZSh4YSwgeWEsIHhiLCB5YiwgcywgcSkge1xyXG4gICAgaWYgKHhhICE9PSB4YiB8fCB5YSAhPT0geWIpIHtcclxuICAgICAgdmFyIGkgPSBzLnB1c2gocG9wKHMpICsgXCJzY2FsZShcIiwgbnVsbCwgXCIsXCIsIG51bGwsIFwiKVwiKTtcclxuICAgICAgcS5wdXNoKHtpOiBpIC0gNCwgeDogcmVpbnRlcnBvbGF0ZSh4YSwgeGIpfSwge2k6IGkgLSAyLCB4OiByZWludGVycG9sYXRlKHlhLCB5Yil9KTtcclxuICAgIH0gZWxzZSBpZiAoeGIgIT09IDEgfHwgeWIgIT09IDEpIHtcclxuICAgICAgcy5wdXNoKHBvcChzKSArIFwic2NhbGUoXCIgKyB4YiArIFwiLFwiICsgeWIgKyBcIilcIik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZnVuY3Rpb24oYSwgYikge1xyXG4gICAgdmFyIHMgPSBbXSwgLy8gc3RyaW5nIGNvbnN0YW50cyBhbmQgcGxhY2Vob2xkZXJzXHJcbiAgICAgICAgcSA9IFtdOyAvLyBudW1iZXIgaW50ZXJwb2xhdG9yc1xyXG4gICAgYSA9IHBhcnNlKGEpLCBiID0gcGFyc2UoYik7XHJcbiAgICB0cmFuc2xhdGUoYS50cmFuc2xhdGVYLCBhLnRyYW5zbGF0ZVksIGIudHJhbnNsYXRlWCwgYi50cmFuc2xhdGVZLCBzLCBxKTtcclxuICAgIHJvdGF0ZShhLnJvdGF0ZSwgYi5yb3RhdGUsIHMsIHEpO1xyXG4gICAgc2tld1goYS5za2V3WCwgYi5za2V3WCwgcywgcSk7XHJcbiAgICBzY2FsZShhLnNjYWxlWCwgYS5zY2FsZVksIGIuc2NhbGVYLCBiLnNjYWxlWSwgcywgcSk7XHJcbiAgICBhID0gYiA9IG51bGw7IC8vIGdjXHJcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xyXG4gICAgICB2YXIgaSA9IC0xLCBuID0gcS5sZW5ndGgsIG87XHJcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBzWyhvID0gcVtpXSkuaV0gPSBvLngodCk7XHJcbiAgICAgIHJldHVybiBzLmpvaW4oXCJcIik7XHJcbiAgICB9O1xyXG4gIH07XHJcbn1cclxuXHJcbnZhciBpbnRlcnBvbGF0ZVRyYW5zZm9ybUNzcyA9IGludGVycG9sYXRlVHJhbnNmb3JtKHBhcnNlQ3NzLCBcInB4LCBcIiwgXCJweClcIiwgXCJkZWcpXCIpO1xyXG52YXIgaW50ZXJwb2xhdGVUcmFuc2Zvcm1TdmcgPSBpbnRlcnBvbGF0ZVRyYW5zZm9ybShwYXJzZVN2ZywgXCIsIFwiLCBcIilcIiwgXCIpXCIpO1xyXG5cclxudmFyIHJobyA9IE1hdGguU1FSVDIsXHJcbiAgICByaG8yID0gMixcclxuICAgIHJobzQgPSA0LFxyXG4gICAgZXBzaWxvbjIgPSAxZS0xMjtcclxuXHJcbmZ1bmN0aW9uIGNvc2goeCkge1xyXG4gIHJldHVybiAoKHggPSBNYXRoLmV4cCh4KSkgKyAxIC8geCkgLyAyO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzaW5oKHgpIHtcclxuICByZXR1cm4gKCh4ID0gTWF0aC5leHAoeCkpIC0gMSAvIHgpIC8gMjtcclxufVxyXG5cclxuZnVuY3Rpb24gdGFuaCh4KSB7XHJcbiAgcmV0dXJuICgoeCA9IE1hdGguZXhwKDIgKiB4KSkgLSAxKSAvICh4ICsgMSk7XHJcbn1cclxuXHJcbi8vIHAwID0gW3V4MCwgdXkwLCB3MF1cclxuLy8gcDEgPSBbdXgxLCB1eTEsIHcxXVxyXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZVpvb20ocDAsIHAxKSB7XHJcbiAgdmFyIHV4MCA9IHAwWzBdLCB1eTAgPSBwMFsxXSwgdzAgPSBwMFsyXSxcclxuICAgICAgdXgxID0gcDFbMF0sIHV5MSA9IHAxWzFdLCB3MSA9IHAxWzJdLFxyXG4gICAgICBkeCA9IHV4MSAtIHV4MCxcclxuICAgICAgZHkgPSB1eTEgLSB1eTAsXHJcbiAgICAgIGQyID0gZHggKiBkeCArIGR5ICogZHksXHJcbiAgICAgIGksXHJcbiAgICAgIFM7XHJcblxyXG4gIC8vIFNwZWNpYWwgY2FzZSBmb3IgdTAg4omFIHUxLlxyXG4gIGlmIChkMiA8IGVwc2lsb24yKSB7XHJcbiAgICBTID0gTWF0aC5sb2codzEgLyB3MCkgLyByaG87XHJcbiAgICBpID0gZnVuY3Rpb24odCkge1xyXG4gICAgICByZXR1cm4gW1xyXG4gICAgICAgIHV4MCArIHQgKiBkeCxcclxuICAgICAgICB1eTAgKyB0ICogZHksXHJcbiAgICAgICAgdzAgKiBNYXRoLmV4cChyaG8gKiB0ICogUylcclxuICAgICAgXTtcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBHZW5lcmFsIGNhc2UuXHJcbiAgZWxzZSB7XHJcbiAgICB2YXIgZDEgPSBNYXRoLnNxcnQoZDIpLFxyXG4gICAgICAgIGIwID0gKHcxICogdzEgLSB3MCAqIHcwICsgcmhvNCAqIGQyKSAvICgyICogdzAgKiByaG8yICogZDEpLFxyXG4gICAgICAgIGIxID0gKHcxICogdzEgLSB3MCAqIHcwIC0gcmhvNCAqIGQyKSAvICgyICogdzEgKiByaG8yICogZDEpLFxyXG4gICAgICAgIHIwID0gTWF0aC5sb2coTWF0aC5zcXJ0KGIwICogYjAgKyAxKSAtIGIwKSxcclxuICAgICAgICByMSA9IE1hdGgubG9nKE1hdGguc3FydChiMSAqIGIxICsgMSkgLSBiMSk7XHJcbiAgICBTID0gKHIxIC0gcjApIC8gcmhvO1xyXG4gICAgaSA9IGZ1bmN0aW9uKHQpIHtcclxuICAgICAgdmFyIHMgPSB0ICogUyxcclxuICAgICAgICAgIGNvc2hyMCA9IGNvc2gocjApLFxyXG4gICAgICAgICAgdSA9IHcwIC8gKHJobzIgKiBkMSkgKiAoY29zaHIwICogdGFuaChyaG8gKiBzICsgcjApIC0gc2luaChyMCkpO1xyXG4gICAgICByZXR1cm4gW1xyXG4gICAgICAgIHV4MCArIHUgKiBkeCxcclxuICAgICAgICB1eTAgKyB1ICogZHksXHJcbiAgICAgICAgdzAgKiBjb3NocjAgLyBjb3NoKHJobyAqIHMgKyByMClcclxuICAgICAgXTtcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBpLmR1cmF0aW9uID0gUyAqIDEwMDA7XHJcblxyXG4gIHJldHVybiBpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBoc2wkMShodWUkJDEpIHtcclxuICByZXR1cm4gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xyXG4gICAgdmFyIGggPSBodWUkJDEoKHN0YXJ0ID0gaHNsKHN0YXJ0KSkuaCwgKGVuZCA9IGhzbChlbmQpKS5oKSxcclxuICAgICAgICBzID0gbm9nYW1tYShzdGFydC5zLCBlbmQucyksXHJcbiAgICAgICAgbCA9IG5vZ2FtbWEoc3RhcnQubCwgZW5kLmwpLFxyXG4gICAgICAgIG9wYWNpdHkgPSBub2dhbW1hKHN0YXJ0Lm9wYWNpdHksIGVuZC5vcGFjaXR5KTtcclxuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XHJcbiAgICAgIHN0YXJ0LmggPSBoKHQpO1xyXG4gICAgICBzdGFydC5zID0gcyh0KTtcclxuICAgICAgc3RhcnQubCA9IGwodCk7XHJcbiAgICAgIHN0YXJ0Lm9wYWNpdHkgPSBvcGFjaXR5KHQpO1xyXG4gICAgICByZXR1cm4gc3RhcnQgKyBcIlwiO1xyXG4gICAgfTtcclxuICB9XHJcbn1cclxuXHJcbnZhciBoc2wkMiA9IGhzbCQxKGh1ZSk7XHJcbnZhciBoc2xMb25nID0gaHNsJDEobm9nYW1tYSk7XHJcblxyXG5mdW5jdGlvbiBsYWIkMShzdGFydCwgZW5kKSB7XHJcbiAgdmFyIGwgPSBub2dhbW1hKChzdGFydCA9IGxhYihzdGFydCkpLmwsIChlbmQgPSBsYWIoZW5kKSkubCksXHJcbiAgICAgIGEgPSBub2dhbW1hKHN0YXJ0LmEsIGVuZC5hKSxcclxuICAgICAgYiA9IG5vZ2FtbWEoc3RhcnQuYiwgZW5kLmIpLFxyXG4gICAgICBvcGFjaXR5ID0gbm9nYW1tYShzdGFydC5vcGFjaXR5LCBlbmQub3BhY2l0eSk7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcclxuICAgIHN0YXJ0LmwgPSBsKHQpO1xyXG4gICAgc3RhcnQuYSA9IGEodCk7XHJcbiAgICBzdGFydC5iID0gYih0KTtcclxuICAgIHN0YXJ0Lm9wYWNpdHkgPSBvcGFjaXR5KHQpO1xyXG4gICAgcmV0dXJuIHN0YXJ0ICsgXCJcIjtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBoY2wkMShodWUkJDEpIHtcclxuICByZXR1cm4gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xyXG4gICAgdmFyIGggPSBodWUkJDEoKHN0YXJ0ID0gaGNsKHN0YXJ0KSkuaCwgKGVuZCA9IGhjbChlbmQpKS5oKSxcclxuICAgICAgICBjID0gbm9nYW1tYShzdGFydC5jLCBlbmQuYyksXHJcbiAgICAgICAgbCA9IG5vZ2FtbWEoc3RhcnQubCwgZW5kLmwpLFxyXG4gICAgICAgIG9wYWNpdHkgPSBub2dhbW1hKHN0YXJ0Lm9wYWNpdHksIGVuZC5vcGFjaXR5KTtcclxuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XHJcbiAgICAgIHN0YXJ0LmggPSBoKHQpO1xyXG4gICAgICBzdGFydC5jID0gYyh0KTtcclxuICAgICAgc3RhcnQubCA9IGwodCk7XHJcbiAgICAgIHN0YXJ0Lm9wYWNpdHkgPSBvcGFjaXR5KHQpO1xyXG4gICAgICByZXR1cm4gc3RhcnQgKyBcIlwiO1xyXG4gICAgfTtcclxuICB9XHJcbn1cclxuXHJcbnZhciBoY2wkMiA9IGhjbCQxKGh1ZSk7XHJcbnZhciBoY2xMb25nID0gaGNsJDEobm9nYW1tYSk7XHJcblxyXG5mdW5jdGlvbiBjdWJlaGVsaXgkMShodWUkJDEpIHtcclxuICByZXR1cm4gKGZ1bmN0aW9uIGN1YmVoZWxpeEdhbW1hKHkpIHtcclxuICAgIHkgPSAreTtcclxuXHJcbiAgICBmdW5jdGlvbiBjdWJlaGVsaXgkJDEoc3RhcnQsIGVuZCkge1xyXG4gICAgICB2YXIgaCA9IGh1ZSQkMSgoc3RhcnQgPSBjdWJlaGVsaXgoc3RhcnQpKS5oLCAoZW5kID0gY3ViZWhlbGl4KGVuZCkpLmgpLFxyXG4gICAgICAgICAgcyA9IG5vZ2FtbWEoc3RhcnQucywgZW5kLnMpLFxyXG4gICAgICAgICAgbCA9IG5vZ2FtbWEoc3RhcnQubCwgZW5kLmwpLFxyXG4gICAgICAgICAgb3BhY2l0eSA9IG5vZ2FtbWEoc3RhcnQub3BhY2l0eSwgZW5kLm9wYWNpdHkpO1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24odCkge1xyXG4gICAgICAgIHN0YXJ0LmggPSBoKHQpO1xyXG4gICAgICAgIHN0YXJ0LnMgPSBzKHQpO1xyXG4gICAgICAgIHN0YXJ0LmwgPSBsKE1hdGgucG93KHQsIHkpKTtcclxuICAgICAgICBzdGFydC5vcGFjaXR5ID0gb3BhY2l0eSh0KTtcclxuICAgICAgICByZXR1cm4gc3RhcnQgKyBcIlwiO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGN1YmVoZWxpeCQkMS5nYW1tYSA9IGN1YmVoZWxpeEdhbW1hO1xyXG5cclxuICAgIHJldHVybiBjdWJlaGVsaXgkJDE7XHJcbiAgfSkoMSk7XHJcbn1cclxuXHJcbnZhciBjdWJlaGVsaXgkMiA9IGN1YmVoZWxpeCQxKGh1ZSk7XHJcbnZhciBjdWJlaGVsaXhMb25nID0gY3ViZWhlbGl4JDEobm9nYW1tYSk7XHJcblxyXG5mdW5jdGlvbiBwaWVjZXdpc2UoaW50ZXJwb2xhdGUsIHZhbHVlcykge1xyXG4gIHZhciBpID0gMCwgbiA9IHZhbHVlcy5sZW5ndGggLSAxLCB2ID0gdmFsdWVzWzBdLCBJID0gbmV3IEFycmF5KG4gPCAwID8gMCA6IG4pO1xyXG4gIHdoaWxlIChpIDwgbikgSVtpXSA9IGludGVycG9sYXRlKHYsIHYgPSB2YWx1ZXNbKytpXSk7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcclxuICAgIHZhciBpID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obiAtIDEsIE1hdGguZmxvb3IodCAqPSBuKSkpO1xyXG4gICAgcmV0dXJuIElbaV0odCAtIGkpO1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHF1YW50aXplKGludGVycG9sYXRvciwgbikge1xyXG4gIHZhciBzYW1wbGVzID0gbmV3IEFycmF5KG4pO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSBzYW1wbGVzW2ldID0gaW50ZXJwb2xhdG9yKGkgLyAobiAtIDEpKTtcclxuICByZXR1cm4gc2FtcGxlcztcclxufVxyXG5cclxudmFyIGZyYW1lID0gMCwgLy8gaXMgYW4gYW5pbWF0aW9uIGZyYW1lIHBlbmRpbmc/XHJcbiAgICB0aW1lb3V0ID0gMCwgLy8gaXMgYSB0aW1lb3V0IHBlbmRpbmc/XHJcbiAgICBpbnRlcnZhbCA9IDAsIC8vIGFyZSBhbnkgdGltZXJzIGFjdGl2ZT9cclxuICAgIHBva2VEZWxheSA9IDEwMDAsIC8vIGhvdyBmcmVxdWVudGx5IHdlIGNoZWNrIGZvciBjbG9jayBza2V3XHJcbiAgICB0YXNrSGVhZCxcclxuICAgIHRhc2tUYWlsLFxyXG4gICAgY2xvY2tMYXN0ID0gMCxcclxuICAgIGNsb2NrTm93ID0gMCxcclxuICAgIGNsb2NrU2tldyA9IDAsXHJcbiAgICBjbG9jayA9IHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gXCJvYmplY3RcIiAmJiBwZXJmb3JtYW5jZS5ub3cgPyBwZXJmb3JtYW5jZSA6IERhdGUsXHJcbiAgICBzZXRGcmFtZSA9IHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpIDogZnVuY3Rpb24oZikgeyBzZXRUaW1lb3V0KGYsIDE3KTsgfTtcclxuXHJcbmZ1bmN0aW9uIG5vdygpIHtcclxuICByZXR1cm4gY2xvY2tOb3cgfHwgKHNldEZyYW1lKGNsZWFyTm93KSwgY2xvY2tOb3cgPSBjbG9jay5ub3coKSArIGNsb2NrU2tldyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNsZWFyTm93KCkge1xyXG4gIGNsb2NrTm93ID0gMDtcclxufVxyXG5cclxuZnVuY3Rpb24gVGltZXIoKSB7XHJcbiAgdGhpcy5fY2FsbCA9XHJcbiAgdGhpcy5fdGltZSA9XHJcbiAgdGhpcy5fbmV4dCA9IG51bGw7XHJcbn1cclxuXHJcblRpbWVyLnByb3RvdHlwZSA9IHRpbWVyLnByb3RvdHlwZSA9IHtcclxuICBjb25zdHJ1Y3RvcjogVGltZXIsXHJcbiAgcmVzdGFydDogZnVuY3Rpb24oY2FsbGJhY2ssIGRlbGF5LCB0aW1lKSB7XHJcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYWxsYmFjayBpcyBub3QgYSBmdW5jdGlvblwiKTtcclxuICAgIHRpbWUgPSAodGltZSA9PSBudWxsID8gbm93KCkgOiArdGltZSkgKyAoZGVsYXkgPT0gbnVsbCA/IDAgOiArZGVsYXkpO1xyXG4gICAgaWYgKCF0aGlzLl9uZXh0ICYmIHRhc2tUYWlsICE9PSB0aGlzKSB7XHJcbiAgICAgIGlmICh0YXNrVGFpbCkgdGFza1RhaWwuX25leHQgPSB0aGlzO1xyXG4gICAgICBlbHNlIHRhc2tIZWFkID0gdGhpcztcclxuICAgICAgdGFza1RhaWwgPSB0aGlzO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fY2FsbCA9IGNhbGxiYWNrO1xyXG4gICAgdGhpcy5fdGltZSA9IHRpbWU7XHJcbiAgICBzbGVlcCgpO1xyXG4gIH0sXHJcbiAgc3RvcDogZnVuY3Rpb24oKSB7XHJcbiAgICBpZiAodGhpcy5fY2FsbCkge1xyXG4gICAgICB0aGlzLl9jYWxsID0gbnVsbDtcclxuICAgICAgdGhpcy5fdGltZSA9IEluZmluaXR5O1xyXG4gICAgICBzbGVlcCgpO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIHRpbWVyKGNhbGxiYWNrLCBkZWxheSwgdGltZSkge1xyXG4gIHZhciB0ID0gbmV3IFRpbWVyO1xyXG4gIHQucmVzdGFydChjYWxsYmFjaywgZGVsYXksIHRpbWUpO1xyXG4gIHJldHVybiB0O1xyXG59XHJcblxyXG5mdW5jdGlvbiB0aW1lckZsdXNoKCkge1xyXG4gIG5vdygpOyAvLyBHZXQgdGhlIGN1cnJlbnQgdGltZSwgaWYgbm90IGFscmVhZHkgc2V0LlxyXG4gICsrZnJhbWU7IC8vIFByZXRlbmQgd2XigJl2ZSBzZXQgYW4gYWxhcm0sIGlmIHdlIGhhdmVu4oCZdCBhbHJlYWR5LlxyXG4gIHZhciB0ID0gdGFza0hlYWQsIGU7XHJcbiAgd2hpbGUgKHQpIHtcclxuICAgIGlmICgoZSA9IGNsb2NrTm93IC0gdC5fdGltZSkgPj0gMCkgdC5fY2FsbC5jYWxsKG51bGwsIGUpO1xyXG4gICAgdCA9IHQuX25leHQ7XHJcbiAgfVxyXG4gIC0tZnJhbWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHdha2UoKSB7XHJcbiAgY2xvY2tOb3cgPSAoY2xvY2tMYXN0ID0gY2xvY2subm93KCkpICsgY2xvY2tTa2V3O1xyXG4gIGZyYW1lID0gdGltZW91dCA9IDA7XHJcbiAgdHJ5IHtcclxuICAgIHRpbWVyRmx1c2goKTtcclxuICB9IGZpbmFsbHkge1xyXG4gICAgZnJhbWUgPSAwO1xyXG4gICAgbmFwKCk7XHJcbiAgICBjbG9ja05vdyA9IDA7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBwb2tlKCkge1xyXG4gIHZhciBub3cgPSBjbG9jay5ub3coKSwgZGVsYXkgPSBub3cgLSBjbG9ja0xhc3Q7XHJcbiAgaWYgKGRlbGF5ID4gcG9rZURlbGF5KSBjbG9ja1NrZXcgLT0gZGVsYXksIGNsb2NrTGFzdCA9IG5vdztcclxufVxyXG5cclxuZnVuY3Rpb24gbmFwKCkge1xyXG4gIHZhciB0MCwgdDEgPSB0YXNrSGVhZCwgdDIsIHRpbWUgPSBJbmZpbml0eTtcclxuICB3aGlsZSAodDEpIHtcclxuICAgIGlmICh0MS5fY2FsbCkge1xyXG4gICAgICBpZiAodGltZSA+IHQxLl90aW1lKSB0aW1lID0gdDEuX3RpbWU7XHJcbiAgICAgIHQwID0gdDEsIHQxID0gdDEuX25leHQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0MiA9IHQxLl9uZXh0LCB0MS5fbmV4dCA9IG51bGw7XHJcbiAgICAgIHQxID0gdDAgPyB0MC5fbmV4dCA9IHQyIDogdGFza0hlYWQgPSB0MjtcclxuICAgIH1cclxuICB9XHJcbiAgdGFza1RhaWwgPSB0MDtcclxuICBzbGVlcCh0aW1lKTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2xlZXAodGltZSkge1xyXG4gIGlmIChmcmFtZSkgcmV0dXJuOyAvLyBTb29uZXN0IGFsYXJtIGFscmVhZHkgc2V0LCBvciB3aWxsIGJlLlxyXG4gIGlmICh0aW1lb3V0KSB0aW1lb3V0ID0gY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xyXG4gIHZhciBkZWxheSA9IHRpbWUgLSBjbG9ja05vdzsgLy8gU3RyaWN0bHkgbGVzcyB0aGFuIGlmIHdlIHJlY29tcHV0ZWQgY2xvY2tOb3cuXHJcbiAgaWYgKGRlbGF5ID4gMjQpIHtcclxuICAgIGlmICh0aW1lIDwgSW5maW5pdHkpIHRpbWVvdXQgPSBzZXRUaW1lb3V0KHdha2UsIHRpbWUgLSBjbG9jay5ub3coKSAtIGNsb2NrU2tldyk7XHJcbiAgICBpZiAoaW50ZXJ2YWwpIGludGVydmFsID0gY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGlmICghaW50ZXJ2YWwpIGNsb2NrTGFzdCA9IGNsb2NrLm5vdygpLCBpbnRlcnZhbCA9IHNldEludGVydmFsKHBva2UsIHBva2VEZWxheSk7XHJcbiAgICBmcmFtZSA9IDEsIHNldEZyYW1lKHdha2UpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gdGltZW91dCQxKGNhbGxiYWNrLCBkZWxheSwgdGltZSkge1xyXG4gIHZhciB0ID0gbmV3IFRpbWVyO1xyXG4gIGRlbGF5ID0gZGVsYXkgPT0gbnVsbCA/IDAgOiArZGVsYXk7XHJcbiAgdC5yZXN0YXJ0KGZ1bmN0aW9uKGVsYXBzZWQpIHtcclxuICAgIHQuc3RvcCgpO1xyXG4gICAgY2FsbGJhY2soZWxhcHNlZCArIGRlbGF5KTtcclxuICB9LCBkZWxheSwgdGltZSk7XHJcbiAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGludGVydmFsJDEoY2FsbGJhY2ssIGRlbGF5LCB0aW1lKSB7XHJcbiAgdmFyIHQgPSBuZXcgVGltZXIsIHRvdGFsID0gZGVsYXk7XHJcbiAgaWYgKGRlbGF5ID09IG51bGwpIHJldHVybiB0LnJlc3RhcnQoY2FsbGJhY2ssIGRlbGF5LCB0aW1lKSwgdDtcclxuICBkZWxheSA9ICtkZWxheSwgdGltZSA9IHRpbWUgPT0gbnVsbCA/IG5vdygpIDogK3RpbWU7XHJcbiAgdC5yZXN0YXJ0KGZ1bmN0aW9uIHRpY2soZWxhcHNlZCkge1xyXG4gICAgZWxhcHNlZCArPSB0b3RhbDtcclxuICAgIHQucmVzdGFydCh0aWNrLCB0b3RhbCArPSBkZWxheSwgdGltZSk7XHJcbiAgICBjYWxsYmFjayhlbGFwc2VkKTtcclxuICB9LCBkZWxheSwgdGltZSk7XHJcbiAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbnZhciBlbXB0eU9uID0gZGlzcGF0Y2goXCJzdGFydFwiLCBcImVuZFwiLCBcImludGVycnVwdFwiKTtcclxudmFyIGVtcHR5VHdlZW4gPSBbXTtcclxuXHJcbnZhciBDUkVBVEVEID0gMDtcclxudmFyIFNDSEVEVUxFRCA9IDE7XHJcbnZhciBTVEFSVElORyA9IDI7XHJcbnZhciBTVEFSVEVEID0gMztcclxudmFyIFJVTk5JTkcgPSA0O1xyXG52YXIgRU5ESU5HID0gNTtcclxudmFyIEVOREVEID0gNjtcclxuXHJcbmZ1bmN0aW9uIHNjaGVkdWxlKG5vZGUsIG5hbWUsIGlkLCBpbmRleCwgZ3JvdXAsIHRpbWluZykge1xyXG4gIHZhciBzY2hlZHVsZXMgPSBub2RlLl9fdHJhbnNpdGlvbjtcclxuICBpZiAoIXNjaGVkdWxlcykgbm9kZS5fX3RyYW5zaXRpb24gPSB7fTtcclxuICBlbHNlIGlmIChpZCBpbiBzY2hlZHVsZXMpIHJldHVybjtcclxuICBjcmVhdGUkMShub2RlLCBpZCwge1xyXG4gICAgbmFtZTogbmFtZSxcclxuICAgIGluZGV4OiBpbmRleCwgLy8gRm9yIGNvbnRleHQgZHVyaW5nIGNhbGxiYWNrLlxyXG4gICAgZ3JvdXA6IGdyb3VwLCAvLyBGb3IgY29udGV4dCBkdXJpbmcgY2FsbGJhY2suXHJcbiAgICBvbjogZW1wdHlPbixcclxuICAgIHR3ZWVuOiBlbXB0eVR3ZWVuLFxyXG4gICAgdGltZTogdGltaW5nLnRpbWUsXHJcbiAgICBkZWxheTogdGltaW5nLmRlbGF5LFxyXG4gICAgZHVyYXRpb246IHRpbWluZy5kdXJhdGlvbixcclxuICAgIGVhc2U6IHRpbWluZy5lYXNlLFxyXG4gICAgdGltZXI6IG51bGwsXHJcbiAgICBzdGF0ZTogQ1JFQVRFRFxyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpbml0KG5vZGUsIGlkKSB7XHJcbiAgdmFyIHNjaGVkdWxlID0gZ2V0JDEobm9kZSwgaWQpO1xyXG4gIGlmIChzY2hlZHVsZS5zdGF0ZSA+IENSRUFURUQpIHRocm93IG5ldyBFcnJvcihcInRvbyBsYXRlOyBhbHJlYWR5IHNjaGVkdWxlZFwiKTtcclxuICByZXR1cm4gc2NoZWR1bGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldCQxKG5vZGUsIGlkKSB7XHJcbiAgdmFyIHNjaGVkdWxlID0gZ2V0JDEobm9kZSwgaWQpO1xyXG4gIGlmIChzY2hlZHVsZS5zdGF0ZSA+IFNUQVJUSU5HKSB0aHJvdyBuZXcgRXJyb3IoXCJ0b28gbGF0ZTsgYWxyZWFkeSBzdGFydGVkXCIpO1xyXG4gIHJldHVybiBzY2hlZHVsZTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0JDEobm9kZSwgaWQpIHtcclxuICB2YXIgc2NoZWR1bGUgPSBub2RlLl9fdHJhbnNpdGlvbjtcclxuICBpZiAoIXNjaGVkdWxlIHx8ICEoc2NoZWR1bGUgPSBzY2hlZHVsZVtpZF0pKSB0aHJvdyBuZXcgRXJyb3IoXCJ0cmFuc2l0aW9uIG5vdCBmb3VuZFwiKTtcclxuICByZXR1cm4gc2NoZWR1bGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZSQxKG5vZGUsIGlkLCBzZWxmKSB7XHJcbiAgdmFyIHNjaGVkdWxlcyA9IG5vZGUuX190cmFuc2l0aW9uLFxyXG4gICAgICB0d2VlbjtcclxuXHJcbiAgLy8gSW5pdGlhbGl6ZSB0aGUgc2VsZiB0aW1lciB3aGVuIHRoZSB0cmFuc2l0aW9uIGlzIGNyZWF0ZWQuXHJcbiAgLy8gTm90ZSB0aGUgYWN0dWFsIGRlbGF5IGlzIG5vdCBrbm93biB1bnRpbCB0aGUgZmlyc3QgY2FsbGJhY2shXHJcbiAgc2NoZWR1bGVzW2lkXSA9IHNlbGY7XHJcbiAgc2VsZi50aW1lciA9IHRpbWVyKHNjaGVkdWxlLCAwLCBzZWxmLnRpbWUpO1xyXG5cclxuICBmdW5jdGlvbiBzY2hlZHVsZShlbGFwc2VkKSB7XHJcbiAgICBzZWxmLnN0YXRlID0gU0NIRURVTEVEO1xyXG4gICAgc2VsZi50aW1lci5yZXN0YXJ0KHN0YXJ0LCBzZWxmLmRlbGF5LCBzZWxmLnRpbWUpO1xyXG5cclxuICAgIC8vIElmIHRoZSBlbGFwc2VkIGRlbGF5IGlzIGxlc3MgdGhhbiBvdXIgZmlyc3Qgc2xlZXAsIHN0YXJ0IGltbWVkaWF0ZWx5LlxyXG4gICAgaWYgKHNlbGYuZGVsYXkgPD0gZWxhcHNlZCkgc3RhcnQoZWxhcHNlZCAtIHNlbGYuZGVsYXkpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc3RhcnQoZWxhcHNlZCkge1xyXG4gICAgdmFyIGksIGosIG4sIG87XHJcblxyXG4gICAgLy8gSWYgdGhlIHN0YXRlIGlzIG5vdCBTQ0hFRFVMRUQsIHRoZW4gd2UgcHJldmlvdXNseSBlcnJvcmVkIG9uIHN0YXJ0LlxyXG4gICAgaWYgKHNlbGYuc3RhdGUgIT09IFNDSEVEVUxFRCkgcmV0dXJuIHN0b3AoKTtcclxuXHJcbiAgICBmb3IgKGkgaW4gc2NoZWR1bGVzKSB7XHJcbiAgICAgIG8gPSBzY2hlZHVsZXNbaV07XHJcbiAgICAgIGlmIChvLm5hbWUgIT09IHNlbGYubmFtZSkgY29udGludWU7XHJcblxyXG4gICAgICAvLyBXaGlsZSB0aGlzIGVsZW1lbnQgYWxyZWFkeSBoYXMgYSBzdGFydGluZyB0cmFuc2l0aW9uIGR1cmluZyB0aGlzIGZyYW1lLFxyXG4gICAgICAvLyBkZWZlciBzdGFydGluZyBhbiBpbnRlcnJ1cHRpbmcgdHJhbnNpdGlvbiB1bnRpbCB0aGF0IHRyYW5zaXRpb24gaGFzIGFcclxuICAgICAgLy8gY2hhbmNlIHRvIHRpY2sgKGFuZCBwb3NzaWJseSBlbmQpOyBzZWUgZDMvZDMtdHJhbnNpdGlvbiM1NCFcclxuICAgICAgaWYgKG8uc3RhdGUgPT09IFNUQVJURUQpIHJldHVybiB0aW1lb3V0JDEoc3RhcnQpO1xyXG5cclxuICAgICAgLy8gSW50ZXJydXB0IHRoZSBhY3RpdmUgdHJhbnNpdGlvbiwgaWYgYW55LlxyXG4gICAgICAvLyBEaXNwYXRjaCB0aGUgaW50ZXJydXB0IGV2ZW50LlxyXG4gICAgICBpZiAoby5zdGF0ZSA9PT0gUlVOTklORykge1xyXG4gICAgICAgIG8uc3RhdGUgPSBFTkRFRDtcclxuICAgICAgICBvLnRpbWVyLnN0b3AoKTtcclxuICAgICAgICBvLm9uLmNhbGwoXCJpbnRlcnJ1cHRcIiwgbm9kZSwgbm9kZS5fX2RhdGFfXywgby5pbmRleCwgby5ncm91cCk7XHJcbiAgICAgICAgZGVsZXRlIHNjaGVkdWxlc1tpXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2FuY2VsIGFueSBwcmUtZW1wdGVkIHRyYW5zaXRpb25zLiBObyBpbnRlcnJ1cHQgZXZlbnQgaXMgZGlzcGF0Y2hlZFxyXG4gICAgICAvLyBiZWNhdXNlIHRoZSBjYW5jZWxsZWQgdHJhbnNpdGlvbnMgbmV2ZXIgc3RhcnRlZC4gTm90ZSB0aGF0IHRoaXMgYWxzb1xyXG4gICAgICAvLyByZW1vdmVzIHRoaXMgdHJhbnNpdGlvbiBmcm9tIHRoZSBwZW5kaW5nIGxpc3QhXHJcbiAgICAgIGVsc2UgaWYgKCtpIDwgaWQpIHtcclxuICAgICAgICBvLnN0YXRlID0gRU5ERUQ7XHJcbiAgICAgICAgby50aW1lci5zdG9wKCk7XHJcbiAgICAgICAgZGVsZXRlIHNjaGVkdWxlc1tpXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIERlZmVyIHRoZSBmaXJzdCB0aWNrIHRvIGVuZCBvZiB0aGUgY3VycmVudCBmcmFtZTsgc2VlIGQzL2QzIzE1NzYuXHJcbiAgICAvLyBOb3RlIHRoZSB0cmFuc2l0aW9uIG1heSBiZSBjYW5jZWxlZCBhZnRlciBzdGFydCBhbmQgYmVmb3JlIHRoZSBmaXJzdCB0aWNrIVxyXG4gICAgLy8gTm90ZSB0aGlzIG11c3QgYmUgc2NoZWR1bGVkIGJlZm9yZSB0aGUgc3RhcnQgZXZlbnQ7IHNlZSBkMy9kMy10cmFuc2l0aW9uIzE2IVxyXG4gICAgLy8gQXNzdW1pbmcgdGhpcyBpcyBzdWNjZXNzZnVsLCBzdWJzZXF1ZW50IGNhbGxiYWNrcyBnbyBzdHJhaWdodCB0byB0aWNrLlxyXG4gICAgdGltZW91dCQxKGZ1bmN0aW9uKCkge1xyXG4gICAgICBpZiAoc2VsZi5zdGF0ZSA9PT0gU1RBUlRFRCkge1xyXG4gICAgICAgIHNlbGYuc3RhdGUgPSBSVU5OSU5HO1xyXG4gICAgICAgIHNlbGYudGltZXIucmVzdGFydCh0aWNrLCBzZWxmLmRlbGF5LCBzZWxmLnRpbWUpO1xyXG4gICAgICAgIHRpY2soZWxhcHNlZCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIERpc3BhdGNoIHRoZSBzdGFydCBldmVudC5cclxuICAgIC8vIE5vdGUgdGhpcyBtdXN0IGJlIGRvbmUgYmVmb3JlIHRoZSB0d2VlbiBhcmUgaW5pdGlhbGl6ZWQuXHJcbiAgICBzZWxmLnN0YXRlID0gU1RBUlRJTkc7XHJcbiAgICBzZWxmLm9uLmNhbGwoXCJzdGFydFwiLCBub2RlLCBub2RlLl9fZGF0YV9fLCBzZWxmLmluZGV4LCBzZWxmLmdyb3VwKTtcclxuICAgIGlmIChzZWxmLnN0YXRlICE9PSBTVEFSVElORykgcmV0dXJuOyAvLyBpbnRlcnJ1cHRlZFxyXG4gICAgc2VsZi5zdGF0ZSA9IFNUQVJURUQ7XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgdHdlZW4sIGRlbGV0aW5nIG51bGwgdHdlZW4uXHJcbiAgICB0d2VlbiA9IG5ldyBBcnJheShuID0gc2VsZi50d2Vlbi5sZW5ndGgpO1xyXG4gICAgZm9yIChpID0gMCwgaiA9IC0xOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgIGlmIChvID0gc2VsZi50d2VlbltpXS52YWx1ZS5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIHNlbGYuaW5kZXgsIHNlbGYuZ3JvdXApKSB7XHJcbiAgICAgICAgdHdlZW5bKytqXSA9IG87XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHR3ZWVuLmxlbmd0aCA9IGogKyAxO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdGljayhlbGFwc2VkKSB7XHJcbiAgICB2YXIgdCA9IGVsYXBzZWQgPCBzZWxmLmR1cmF0aW9uID8gc2VsZi5lYXNlLmNhbGwobnVsbCwgZWxhcHNlZCAvIHNlbGYuZHVyYXRpb24pIDogKHNlbGYudGltZXIucmVzdGFydChzdG9wKSwgc2VsZi5zdGF0ZSA9IEVORElORywgMSksXHJcbiAgICAgICAgaSA9IC0xLFxyXG4gICAgICAgIG4gPSB0d2Vlbi5sZW5ndGg7XHJcblxyXG4gICAgd2hpbGUgKCsraSA8IG4pIHtcclxuICAgICAgdHdlZW5baV0uY2FsbChudWxsLCB0KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEaXNwYXRjaCB0aGUgZW5kIGV2ZW50LlxyXG4gICAgaWYgKHNlbGYuc3RhdGUgPT09IEVORElORykge1xyXG4gICAgICBzZWxmLm9uLmNhbGwoXCJlbmRcIiwgbm9kZSwgbm9kZS5fX2RhdGFfXywgc2VsZi5pbmRleCwgc2VsZi5ncm91cCk7XHJcbiAgICAgIHN0b3AoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHN0b3AoKSB7XHJcbiAgICBzZWxmLnN0YXRlID0gRU5ERUQ7XHJcbiAgICBzZWxmLnRpbWVyLnN0b3AoKTtcclxuICAgIGRlbGV0ZSBzY2hlZHVsZXNbaWRdO1xyXG4gICAgZm9yICh2YXIgaSBpbiBzY2hlZHVsZXMpIHJldHVybjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG4gICAgZGVsZXRlIG5vZGUuX190cmFuc2l0aW9uO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gaW50ZXJydXB0KG5vZGUsIG5hbWUpIHtcclxuICB2YXIgc2NoZWR1bGVzID0gbm9kZS5fX3RyYW5zaXRpb24sXHJcbiAgICAgIHNjaGVkdWxlJCQxLFxyXG4gICAgICBhY3RpdmUsXHJcbiAgICAgIGVtcHR5ID0gdHJ1ZSxcclxuICAgICAgaTtcclxuXHJcbiAgaWYgKCFzY2hlZHVsZXMpIHJldHVybjtcclxuXHJcbiAgbmFtZSA9IG5hbWUgPT0gbnVsbCA/IG51bGwgOiBuYW1lICsgXCJcIjtcclxuXHJcbiAgZm9yIChpIGluIHNjaGVkdWxlcykge1xyXG4gICAgaWYgKChzY2hlZHVsZSQkMSA9IHNjaGVkdWxlc1tpXSkubmFtZSAhPT0gbmFtZSkgeyBlbXB0eSA9IGZhbHNlOyBjb250aW51ZTsgfVxyXG4gICAgYWN0aXZlID0gc2NoZWR1bGUkJDEuc3RhdGUgPiBTVEFSVElORyAmJiBzY2hlZHVsZSQkMS5zdGF0ZSA8IEVORElORztcclxuICAgIHNjaGVkdWxlJCQxLnN0YXRlID0gRU5ERUQ7XHJcbiAgICBzY2hlZHVsZSQkMS50aW1lci5zdG9wKCk7XHJcbiAgICBpZiAoYWN0aXZlKSBzY2hlZHVsZSQkMS5vbi5jYWxsKFwiaW50ZXJydXB0XCIsIG5vZGUsIG5vZGUuX19kYXRhX18sIHNjaGVkdWxlJCQxLmluZGV4LCBzY2hlZHVsZSQkMS5ncm91cCk7XHJcbiAgICBkZWxldGUgc2NoZWR1bGVzW2ldO1xyXG4gIH1cclxuXHJcbiAgaWYgKGVtcHR5KSBkZWxldGUgbm9kZS5fX3RyYW5zaXRpb247XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNlbGVjdGlvbl9pbnRlcnJ1cHQobmFtZSkge1xyXG4gIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICBpbnRlcnJ1cHQodGhpcywgbmFtZSk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHR3ZWVuUmVtb3ZlKGlkLCBuYW1lKSB7XHJcbiAgdmFyIHR3ZWVuMCwgdHdlZW4xO1xyXG4gIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgIHZhciBzY2hlZHVsZSQkMSA9IHNldCQxKHRoaXMsIGlkKSxcclxuICAgICAgICB0d2VlbiA9IHNjaGVkdWxlJCQxLnR3ZWVuO1xyXG5cclxuICAgIC8vIElmIHRoaXMgbm9kZSBzaGFyZWQgdHdlZW4gd2l0aCB0aGUgcHJldmlvdXMgbm9kZSxcclxuICAgIC8vIGp1c3QgYXNzaWduIHRoZSB1cGRhdGVkIHNoYXJlZCB0d2VlbiBhbmQgd2XigJlyZSBkb25lIVxyXG4gICAgLy8gT3RoZXJ3aXNlLCBjb3B5LW9uLXdyaXRlLlxyXG4gICAgaWYgKHR3ZWVuICE9PSB0d2VlbjApIHtcclxuICAgICAgdHdlZW4xID0gdHdlZW4wID0gdHdlZW47XHJcbiAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdHdlZW4xLmxlbmd0aDsgaSA8IG47ICsraSkge1xyXG4gICAgICAgIGlmICh0d2VlbjFbaV0ubmFtZSA9PT0gbmFtZSkge1xyXG4gICAgICAgICAgdHdlZW4xID0gdHdlZW4xLnNsaWNlKCk7XHJcbiAgICAgICAgICB0d2VlbjEuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc2NoZWR1bGUkJDEudHdlZW4gPSB0d2VlbjE7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gdHdlZW5GdW5jdGlvbihpZCwgbmFtZSwgdmFsdWUpIHtcclxuICB2YXIgdHdlZW4wLCB0d2VlbjE7XHJcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3I7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHNjaGVkdWxlJCQxID0gc2V0JDEodGhpcywgaWQpLFxyXG4gICAgICAgIHR3ZWVuID0gc2NoZWR1bGUkJDEudHdlZW47XHJcblxyXG4gICAgLy8gSWYgdGhpcyBub2RlIHNoYXJlZCB0d2VlbiB3aXRoIHRoZSBwcmV2aW91cyBub2RlLFxyXG4gICAgLy8ganVzdCBhc3NpZ24gdGhlIHVwZGF0ZWQgc2hhcmVkIHR3ZWVuIGFuZCB3ZeKAmXJlIGRvbmUhXHJcbiAgICAvLyBPdGhlcndpc2UsIGNvcHktb24td3JpdGUuXHJcbiAgICBpZiAodHdlZW4gIT09IHR3ZWVuMCkge1xyXG4gICAgICB0d2VlbjEgPSAodHdlZW4wID0gdHdlZW4pLnNsaWNlKCk7XHJcbiAgICAgIGZvciAodmFyIHQgPSB7bmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlfSwgaSA9IDAsIG4gPSB0d2VlbjEubGVuZ3RoOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgICAgaWYgKHR3ZWVuMVtpXS5uYW1lID09PSBuYW1lKSB7XHJcbiAgICAgICAgICB0d2VlbjFbaV0gPSB0O1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChpID09PSBuKSB0d2VlbjEucHVzaCh0KTtcclxuICAgIH1cclxuXHJcbiAgICBzY2hlZHVsZSQkMS50d2VlbiA9IHR3ZWVuMTtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiB0cmFuc2l0aW9uX3R3ZWVuKG5hbWUsIHZhbHVlKSB7XHJcbiAgdmFyIGlkID0gdGhpcy5faWQ7XHJcblxyXG4gIG5hbWUgKz0gXCJcIjtcclxuXHJcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XHJcbiAgICB2YXIgdHdlZW4gPSBnZXQkMSh0aGlzLm5vZGUoKSwgaWQpLnR3ZWVuO1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0d2Vlbi5sZW5ndGgsIHQ7IGkgPCBuOyArK2kpIHtcclxuICAgICAgaWYgKCh0ID0gdHdlZW5baV0pLm5hbWUgPT09IG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gdC52YWx1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcy5lYWNoKCh2YWx1ZSA9PSBudWxsID8gdHdlZW5SZW1vdmUgOiB0d2VlbkZ1bmN0aW9uKShpZCwgbmFtZSwgdmFsdWUpKTtcclxufVxyXG5cclxuZnVuY3Rpb24gdHdlZW5WYWx1ZSh0cmFuc2l0aW9uLCBuYW1lLCB2YWx1ZSkge1xyXG4gIHZhciBpZCA9IHRyYW5zaXRpb24uX2lkO1xyXG5cclxuICB0cmFuc2l0aW9uLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgc2NoZWR1bGUkJDEgPSBzZXQkMSh0aGlzLCBpZCk7XHJcbiAgICAoc2NoZWR1bGUkJDEudmFsdWUgfHwgKHNjaGVkdWxlJCQxLnZhbHVlID0ge30pKVtuYW1lXSA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiBmdW5jdGlvbihub2RlKSB7XHJcbiAgICByZXR1cm4gZ2V0JDEobm9kZSwgaWQpLnZhbHVlW25hbWVdO1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGludGVycG9sYXRlKGEsIGIpIHtcclxuICB2YXIgYztcclxuICByZXR1cm4gKHR5cGVvZiBiID09PSBcIm51bWJlclwiID8gcmVpbnRlcnBvbGF0ZVxyXG4gICAgICA6IGIgaW5zdGFuY2VvZiBjb2xvciA/IGludGVycG9sYXRlUmdiXHJcbiAgICAgIDogKGMgPSBjb2xvcihiKSkgPyAoYiA9IGMsIGludGVycG9sYXRlUmdiKVxyXG4gICAgICA6IGludGVycG9sYXRlU3RyaW5nKShhLCBiKTtcclxufVxyXG5cclxuZnVuY3Rpb24gYXR0clJlbW92ZSQxKG5hbWUpIHtcclxuICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBhdHRyUmVtb3ZlTlMkMShmdWxsbmFtZSkge1xyXG4gIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBhdHRyQ29uc3RhbnQkMShuYW1lLCBpbnRlcnBvbGF0ZSQkMSwgdmFsdWUxKSB7XHJcbiAgdmFyIHZhbHVlMDAsXHJcbiAgICAgIGludGVycG9sYXRlMDtcclxuICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgdmFsdWUwID0gdGhpcy5nZXRBdHRyaWJ1dGUobmFtZSk7XHJcbiAgICByZXR1cm4gdmFsdWUwID09PSB2YWx1ZTEgPyBudWxsXHJcbiAgICAgICAgOiB2YWx1ZTAgPT09IHZhbHVlMDAgPyBpbnRlcnBvbGF0ZTBcclxuICAgICAgICA6IGludGVycG9sYXRlMCA9IGludGVycG9sYXRlJCQxKHZhbHVlMDAgPSB2YWx1ZTAsIHZhbHVlMSk7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gYXR0ckNvbnN0YW50TlMkMShmdWxsbmFtZSwgaW50ZXJwb2xhdGUkJDEsIHZhbHVlMSkge1xyXG4gIHZhciB2YWx1ZTAwLFxyXG4gICAgICBpbnRlcnBvbGF0ZTA7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHZhbHVlMCA9IHRoaXMuZ2V0QXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcclxuICAgIHJldHVybiB2YWx1ZTAgPT09IHZhbHVlMSA/IG51bGxcclxuICAgICAgICA6IHZhbHVlMCA9PT0gdmFsdWUwMCA/IGludGVycG9sYXRlMFxyXG4gICAgICAgIDogaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUkJDEodmFsdWUwMCA9IHZhbHVlMCwgdmFsdWUxKTtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBhdHRyRnVuY3Rpb24kMShuYW1lLCBpbnRlcnBvbGF0ZSQkMSwgdmFsdWUpIHtcclxuICB2YXIgdmFsdWUwMCxcclxuICAgICAgdmFsdWUxMCxcclxuICAgICAgaW50ZXJwb2xhdGUwO1xyXG4gIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgIHZhciB2YWx1ZTAsIHZhbHVlMSA9IHZhbHVlKHRoaXMpO1xyXG4gICAgaWYgKHZhbHVlMSA9PSBudWxsKSByZXR1cm4gdm9pZCB0aGlzLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcclxuICAgIHZhbHVlMCA9IHRoaXMuZ2V0QXR0cmlidXRlKG5hbWUpO1xyXG4gICAgcmV0dXJuIHZhbHVlMCA9PT0gdmFsdWUxID8gbnVsbFxyXG4gICAgICAgIDogdmFsdWUwID09PSB2YWx1ZTAwICYmIHZhbHVlMSA9PT0gdmFsdWUxMCA/IGludGVycG9sYXRlMFxyXG4gICAgICAgIDogaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUkJDEodmFsdWUwMCA9IHZhbHVlMCwgdmFsdWUxMCA9IHZhbHVlMSk7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gYXR0ckZ1bmN0aW9uTlMkMShmdWxsbmFtZSwgaW50ZXJwb2xhdGUkJDEsIHZhbHVlKSB7XHJcbiAgdmFyIHZhbHVlMDAsXHJcbiAgICAgIHZhbHVlMTAsXHJcbiAgICAgIGludGVycG9sYXRlMDtcclxuICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgdmFsdWUwLCB2YWx1ZTEgPSB2YWx1ZSh0aGlzKTtcclxuICAgIGlmICh2YWx1ZTEgPT0gbnVsbCkgcmV0dXJuIHZvaWQgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xyXG4gICAgdmFsdWUwID0gdGhpcy5nZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xyXG4gICAgcmV0dXJuIHZhbHVlMCA9PT0gdmFsdWUxID8gbnVsbFxyXG4gICAgICAgIDogdmFsdWUwID09PSB2YWx1ZTAwICYmIHZhbHVlMSA9PT0gdmFsdWUxMCA/IGludGVycG9sYXRlMFxyXG4gICAgICAgIDogaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUkJDEodmFsdWUwMCA9IHZhbHVlMCwgdmFsdWUxMCA9IHZhbHVlMSk7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gdHJhbnNpdGlvbl9hdHRyKG5hbWUsIHZhbHVlKSB7XHJcbiAgdmFyIGZ1bGxuYW1lID0gbmFtZXNwYWNlKG5hbWUpLCBpID0gZnVsbG5hbWUgPT09IFwidHJhbnNmb3JtXCIgPyBpbnRlcnBvbGF0ZVRyYW5zZm9ybVN2ZyA6IGludGVycG9sYXRlO1xyXG4gIHJldHVybiB0aGlzLmF0dHJUd2VlbihuYW1lLCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxyXG4gICAgICA/IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJGdW5jdGlvbk5TJDEgOiBhdHRyRnVuY3Rpb24kMSkoZnVsbG5hbWUsIGksIHR3ZWVuVmFsdWUodGhpcywgXCJhdHRyLlwiICsgbmFtZSwgdmFsdWUpKVxyXG4gICAgICA6IHZhbHVlID09IG51bGwgPyAoZnVsbG5hbWUubG9jYWwgPyBhdHRyUmVtb3ZlTlMkMSA6IGF0dHJSZW1vdmUkMSkoZnVsbG5hbWUpXHJcbiAgICAgIDogKGZ1bGxuYW1lLmxvY2FsID8gYXR0ckNvbnN0YW50TlMkMSA6IGF0dHJDb25zdGFudCQxKShmdWxsbmFtZSwgaSwgdmFsdWUgKyBcIlwiKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGF0dHJUd2Vlbk5TKGZ1bGxuYW1lLCB2YWx1ZSkge1xyXG4gIGZ1bmN0aW9uIHR3ZWVuKCkge1xyXG4gICAgdmFyIG5vZGUgPSB0aGlzLCBpID0gdmFsdWUuYXBwbHkobm9kZSwgYXJndW1lbnRzKTtcclxuICAgIHJldHVybiBpICYmIGZ1bmN0aW9uKHQpIHtcclxuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwsIGkodCkpO1xyXG4gICAgfTtcclxuICB9XHJcbiAgdHdlZW4uX3ZhbHVlID0gdmFsdWU7XHJcbiAgcmV0dXJuIHR3ZWVuO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhdHRyVHdlZW4obmFtZSwgdmFsdWUpIHtcclxuICBmdW5jdGlvbiB0d2VlbigpIHtcclxuICAgIHZhciBub2RlID0gdGhpcywgaSA9IHZhbHVlLmFwcGx5KG5vZGUsIGFyZ3VtZW50cyk7XHJcbiAgICByZXR1cm4gaSAmJiBmdW5jdGlvbih0KSB7XHJcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsIGkodCkpO1xyXG4gICAgfTtcclxuICB9XHJcbiAgdHdlZW4uX3ZhbHVlID0gdmFsdWU7XHJcbiAgcmV0dXJuIHR3ZWVuO1xyXG59XHJcblxyXG5mdW5jdGlvbiB0cmFuc2l0aW9uX2F0dHJUd2VlbihuYW1lLCB2YWx1ZSkge1xyXG4gIHZhciBrZXkgPSBcImF0dHIuXCIgKyBuYW1lO1xyXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgcmV0dXJuIChrZXkgPSB0aGlzLnR3ZWVuKGtleSkpICYmIGtleS5fdmFsdWU7XHJcbiAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiB0aGlzLnR3ZWVuKGtleSwgbnVsbCk7XHJcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3I7XHJcbiAgdmFyIGZ1bGxuYW1lID0gbmFtZXNwYWNlKG5hbWUpO1xyXG4gIHJldHVybiB0aGlzLnR3ZWVuKGtleSwgKGZ1bGxuYW1lLmxvY2FsID8gYXR0clR3ZWVuTlMgOiBhdHRyVHdlZW4pKGZ1bGxuYW1lLCB2YWx1ZSkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkZWxheUZ1bmN0aW9uKGlkLCB2YWx1ZSkge1xyXG4gIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgIGluaXQodGhpcywgaWQpLmRlbGF5ID0gK3ZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gZGVsYXlDb25zdGFudChpZCwgdmFsdWUpIHtcclxuICByZXR1cm4gdmFsdWUgPSArdmFsdWUsIGZ1bmN0aW9uKCkge1xyXG4gICAgaW5pdCh0aGlzLCBpZCkuZGVsYXkgPSB2YWx1ZTtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiB0cmFuc2l0aW9uX2RlbGF5KHZhbHVlKSB7XHJcbiAgdmFyIGlkID0gdGhpcy5faWQ7XHJcblxyXG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXHJcbiAgICAgID8gdGhpcy5lYWNoKCh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxyXG4gICAgICAgICAgPyBkZWxheUZ1bmN0aW9uXHJcbiAgICAgICAgICA6IGRlbGF5Q29uc3RhbnQpKGlkLCB2YWx1ZSkpXHJcbiAgICAgIDogZ2V0JDEodGhpcy5ub2RlKCksIGlkKS5kZWxheTtcclxufVxyXG5cclxuZnVuY3Rpb24gZHVyYXRpb25GdW5jdGlvbihpZCwgdmFsdWUpIHtcclxuICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICBzZXQkMSh0aGlzLCBpZCkuZHVyYXRpb24gPSArdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBkdXJhdGlvbkNvbnN0YW50KGlkLCB2YWx1ZSkge1xyXG4gIHJldHVybiB2YWx1ZSA9ICt2YWx1ZSwgZnVuY3Rpb24oKSB7XHJcbiAgICBzZXQkMSh0aGlzLCBpZCkuZHVyYXRpb24gPSB2YWx1ZTtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiB0cmFuc2l0aW9uX2R1cmF0aW9uKHZhbHVlKSB7XHJcbiAgdmFyIGlkID0gdGhpcy5faWQ7XHJcblxyXG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXHJcbiAgICAgID8gdGhpcy5lYWNoKCh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxyXG4gICAgICAgICAgPyBkdXJhdGlvbkZ1bmN0aW9uXHJcbiAgICAgICAgICA6IGR1cmF0aW9uQ29uc3RhbnQpKGlkLCB2YWx1ZSkpXHJcbiAgICAgIDogZ2V0JDEodGhpcy5ub2RlKCksIGlkKS5kdXJhdGlvbjtcclxufVxyXG5cclxuZnVuY3Rpb24gZWFzZUNvbnN0YW50KGlkLCB2YWx1ZSkge1xyXG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xyXG4gIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgIHNldCQxKHRoaXMsIGlkKS5lYXNlID0gdmFsdWU7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gdHJhbnNpdGlvbl9lYXNlKHZhbHVlKSB7XHJcbiAgdmFyIGlkID0gdGhpcy5faWQ7XHJcblxyXG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXHJcbiAgICAgID8gdGhpcy5lYWNoKGVhc2VDb25zdGFudChpZCwgdmFsdWUpKVxyXG4gICAgICA6IGdldCQxKHRoaXMubm9kZSgpLCBpZCkuZWFzZTtcclxufVxyXG5cclxuZnVuY3Rpb24gdHJhbnNpdGlvbl9maWx0ZXIobWF0Y2gpIHtcclxuICBpZiAodHlwZW9mIG1hdGNoICE9PSBcImZ1bmN0aW9uXCIpIG1hdGNoID0gbWF0Y2hlciQxKG1hdGNoKTtcclxuXHJcbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xyXG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIHN1Ymdyb3VwID0gc3ViZ3JvdXBzW2pdID0gW10sIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiBtYXRjaC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSkge1xyXG4gICAgICAgIHN1Ymdyb3VwLnB1c2gobm9kZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBuZXcgVHJhbnNpdGlvbihzdWJncm91cHMsIHRoaXMuX3BhcmVudHMsIHRoaXMuX25hbWUsIHRoaXMuX2lkKTtcclxufVxyXG5cclxuZnVuY3Rpb24gdHJhbnNpdGlvbl9tZXJnZSh0cmFuc2l0aW9uJCQxKSB7XHJcbiAgaWYgKHRyYW5zaXRpb24kJDEuX2lkICE9PSB0aGlzLl9pZCkgdGhyb3cgbmV3IEVycm9yO1xyXG5cclxuICBmb3IgKHZhciBncm91cHMwID0gdGhpcy5fZ3JvdXBzLCBncm91cHMxID0gdHJhbnNpdGlvbiQkMS5fZ3JvdXBzLCBtMCA9IGdyb3VwczAubGVuZ3RoLCBtMSA9IGdyb3VwczEubGVuZ3RoLCBtID0gTWF0aC5taW4obTAsIG0xKSwgbWVyZ2VzID0gbmV3IEFycmF5KG0wKSwgaiA9IDA7IGogPCBtOyArK2opIHtcclxuICAgIGZvciAodmFyIGdyb3VwMCA9IGdyb3VwczBbal0sIGdyb3VwMSA9IGdyb3VwczFbal0sIG4gPSBncm91cDAubGVuZ3RoLCBtZXJnZSA9IG1lcmdlc1tqXSA9IG5ldyBBcnJheShuKSwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcclxuICAgICAgaWYgKG5vZGUgPSBncm91cDBbaV0gfHwgZ3JvdXAxW2ldKSB7XHJcbiAgICAgICAgbWVyZ2VbaV0gPSBub2RlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmb3IgKDsgaiA8IG0wOyArK2opIHtcclxuICAgIG1lcmdlc1tqXSA9IGdyb3VwczBbal07XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbmV3IFRyYW5zaXRpb24obWVyZ2VzLCB0aGlzLl9wYXJlbnRzLCB0aGlzLl9uYW1lLCB0aGlzLl9pZCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN0YXJ0KG5hbWUpIHtcclxuICByZXR1cm4gKG5hbWUgKyBcIlwiKS50cmltKCkuc3BsaXQoL158XFxzKy8pLmV2ZXJ5KGZ1bmN0aW9uKHQpIHtcclxuICAgIHZhciBpID0gdC5pbmRleE9mKFwiLlwiKTtcclxuICAgIGlmIChpID49IDApIHQgPSB0LnNsaWNlKDAsIGkpO1xyXG4gICAgcmV0dXJuICF0IHx8IHQgPT09IFwic3RhcnRcIjtcclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gb25GdW5jdGlvbihpZCwgbmFtZSwgbGlzdGVuZXIpIHtcclxuICB2YXIgb24wLCBvbjEsIHNpdCA9IHN0YXJ0KG5hbWUpID8gaW5pdCA6IHNldCQxO1xyXG4gIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgIHZhciBzY2hlZHVsZSQkMSA9IHNpdCh0aGlzLCBpZCksXHJcbiAgICAgICAgb24gPSBzY2hlZHVsZSQkMS5vbjtcclxuXHJcbiAgICAvLyBJZiB0aGlzIG5vZGUgc2hhcmVkIGEgZGlzcGF0Y2ggd2l0aCB0aGUgcHJldmlvdXMgbm9kZSxcclxuICAgIC8vIGp1c3QgYXNzaWduIHRoZSB1cGRhdGVkIHNoYXJlZCBkaXNwYXRjaCBhbmQgd2XigJlyZSBkb25lIVxyXG4gICAgLy8gT3RoZXJ3aXNlLCBjb3B5LW9uLXdyaXRlLlxyXG4gICAgaWYgKG9uICE9PSBvbjApIChvbjEgPSAob24wID0gb24pLmNvcHkoKSkub24obmFtZSwgbGlzdGVuZXIpO1xyXG5cclxuICAgIHNjaGVkdWxlJCQxLm9uID0gb24xO1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRyYW5zaXRpb25fb24obmFtZSwgbGlzdGVuZXIpIHtcclxuICB2YXIgaWQgPSB0aGlzLl9pZDtcclxuXHJcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAyXHJcbiAgICAgID8gZ2V0JDEodGhpcy5ub2RlKCksIGlkKS5vbi5vbihuYW1lKVxyXG4gICAgICA6IHRoaXMuZWFjaChvbkZ1bmN0aW9uKGlkLCBuYW1lLCBsaXN0ZW5lcikpO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZW1vdmVGdW5jdGlvbihpZCkge1xyXG4gIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XHJcbiAgICBmb3IgKHZhciBpIGluIHRoaXMuX190cmFuc2l0aW9uKSBpZiAoK2kgIT09IGlkKSByZXR1cm47XHJcbiAgICBpZiAocGFyZW50KSBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gdHJhbnNpdGlvbl9yZW1vdmUoKSB7XHJcbiAgcmV0dXJuIHRoaXMub24oXCJlbmQucmVtb3ZlXCIsIHJlbW92ZUZ1bmN0aW9uKHRoaXMuX2lkKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRyYW5zaXRpb25fc2VsZWN0KHNlbGVjdCQkMSkge1xyXG4gIHZhciBuYW1lID0gdGhpcy5fbmFtZSxcclxuICAgICAgaWQgPSB0aGlzLl9pZDtcclxuXHJcbiAgaWYgKHR5cGVvZiBzZWxlY3QkJDEgIT09IFwiZnVuY3Rpb25cIikgc2VsZWN0JCQxID0gc2VsZWN0b3Ioc2VsZWN0JCQxKTtcclxuXHJcbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xyXG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIHN1Ymdyb3VwID0gc3ViZ3JvdXBzW2pdID0gbmV3IEFycmF5KG4pLCBub2RlLCBzdWJub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xyXG4gICAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgKHN1Ym5vZGUgPSBzZWxlY3QkJDEuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCkpKSB7XHJcbiAgICAgICAgaWYgKFwiX19kYXRhX19cIiBpbiBub2RlKSBzdWJub2RlLl9fZGF0YV9fID0gbm9kZS5fX2RhdGFfXztcclxuICAgICAgICBzdWJncm91cFtpXSA9IHN1Ym5vZGU7XHJcbiAgICAgICAgc2NoZWR1bGUoc3ViZ3JvdXBbaV0sIG5hbWUsIGlkLCBpLCBzdWJncm91cCwgZ2V0JDEobm9kZSwgaWQpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uKHN1Ymdyb3VwcywgdGhpcy5fcGFyZW50cywgbmFtZSwgaWQpO1xyXG59XHJcblxyXG5mdW5jdGlvbiB0cmFuc2l0aW9uX3NlbGVjdEFsbChzZWxlY3QkJDEpIHtcclxuICB2YXIgbmFtZSA9IHRoaXMuX25hbWUsXHJcbiAgICAgIGlkID0gdGhpcy5faWQ7XHJcblxyXG4gIGlmICh0eXBlb2Ygc2VsZWN0JCQxICE9PSBcImZ1bmN0aW9uXCIpIHNlbGVjdCQkMSA9IHNlbGVjdG9yQWxsKHNlbGVjdCQkMSk7XHJcblxyXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IFtdLCBwYXJlbnRzID0gW10sIGogPSAwOyBqIDwgbTsgKytqKSB7XHJcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcclxuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xyXG4gICAgICAgIGZvciAodmFyIGNoaWxkcmVuID0gc2VsZWN0JCQxLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApLCBjaGlsZCwgaW5oZXJpdCA9IGdldCQxKG5vZGUsIGlkKSwgayA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGsgPCBsOyArK2spIHtcclxuICAgICAgICAgIGlmIChjaGlsZCA9IGNoaWxkcmVuW2tdKSB7XHJcbiAgICAgICAgICAgIHNjaGVkdWxlKGNoaWxkLCBuYW1lLCBpZCwgaywgY2hpbGRyZW4sIGluaGVyaXQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBzdWJncm91cHMucHVzaChjaGlsZHJlbik7XHJcbiAgICAgICAgcGFyZW50cy5wdXNoKG5vZGUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbmV3IFRyYW5zaXRpb24oc3ViZ3JvdXBzLCBwYXJlbnRzLCBuYW1lLCBpZCk7XHJcbn1cclxuXHJcbnZhciBTZWxlY3Rpb24kMSA9IHNlbGVjdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3I7XHJcblxyXG5mdW5jdGlvbiB0cmFuc2l0aW9uX3NlbGVjdGlvbigpIHtcclxuICByZXR1cm4gbmV3IFNlbGVjdGlvbiQxKHRoaXMuX2dyb3VwcywgdGhpcy5fcGFyZW50cyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN0eWxlUmVtb3ZlJDEobmFtZSwgaW50ZXJwb2xhdGUkJDEpIHtcclxuICB2YXIgdmFsdWUwMCxcclxuICAgICAgdmFsdWUxMCxcclxuICAgICAgaW50ZXJwb2xhdGUwO1xyXG4gIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgIHZhciB2YWx1ZTAgPSBzdHlsZVZhbHVlKHRoaXMsIG5hbWUpLFxyXG4gICAgICAgIHZhbHVlMSA9ICh0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpLCBzdHlsZVZhbHVlKHRoaXMsIG5hbWUpKTtcclxuICAgIHJldHVybiB2YWx1ZTAgPT09IHZhbHVlMSA/IG51bGxcclxuICAgICAgICA6IHZhbHVlMCA9PT0gdmFsdWUwMCAmJiB2YWx1ZTEgPT09IHZhbHVlMTAgPyBpbnRlcnBvbGF0ZTBcclxuICAgICAgICA6IGludGVycG9sYXRlMCA9IGludGVycG9sYXRlJCQxKHZhbHVlMDAgPSB2YWx1ZTAsIHZhbHVlMTAgPSB2YWx1ZTEpO1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN0eWxlUmVtb3ZlRW5kKG5hbWUpIHtcclxuICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpO1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN0eWxlQ29uc3RhbnQkMShuYW1lLCBpbnRlcnBvbGF0ZSQkMSwgdmFsdWUxKSB7XHJcbiAgdmFyIHZhbHVlMDAsXHJcbiAgICAgIGludGVycG9sYXRlMDtcclxuICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgdmFsdWUwID0gc3R5bGVWYWx1ZSh0aGlzLCBuYW1lKTtcclxuICAgIHJldHVybiB2YWx1ZTAgPT09IHZhbHVlMSA/IG51bGxcclxuICAgICAgICA6IHZhbHVlMCA9PT0gdmFsdWUwMCA/IGludGVycG9sYXRlMFxyXG4gICAgICAgIDogaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUkJDEodmFsdWUwMCA9IHZhbHVlMCwgdmFsdWUxKTtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBzdHlsZUZ1bmN0aW9uJDEobmFtZSwgaW50ZXJwb2xhdGUkJDEsIHZhbHVlKSB7XHJcbiAgdmFyIHZhbHVlMDAsXHJcbiAgICAgIHZhbHVlMTAsXHJcbiAgICAgIGludGVycG9sYXRlMDtcclxuICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgdmFsdWUwID0gc3R5bGVWYWx1ZSh0aGlzLCBuYW1lKSxcclxuICAgICAgICB2YWx1ZTEgPSB2YWx1ZSh0aGlzKTtcclxuICAgIGlmICh2YWx1ZTEgPT0gbnVsbCkgdmFsdWUxID0gKHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSksIHN0eWxlVmFsdWUodGhpcywgbmFtZSkpO1xyXG4gICAgcmV0dXJuIHZhbHVlMCA9PT0gdmFsdWUxID8gbnVsbFxyXG4gICAgICAgIDogdmFsdWUwID09PSB2YWx1ZTAwICYmIHZhbHVlMSA9PT0gdmFsdWUxMCA/IGludGVycG9sYXRlMFxyXG4gICAgICAgIDogaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUkJDEodmFsdWUwMCA9IHZhbHVlMCwgdmFsdWUxMCA9IHZhbHVlMSk7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gdHJhbnNpdGlvbl9zdHlsZShuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcclxuICB2YXIgaSA9IChuYW1lICs9IFwiXCIpID09PSBcInRyYW5zZm9ybVwiID8gaW50ZXJwb2xhdGVUcmFuc2Zvcm1Dc3MgOiBpbnRlcnBvbGF0ZTtcclxuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IHRoaXNcclxuICAgICAgICAgIC5zdHlsZVR3ZWVuKG5hbWUsIHN0eWxlUmVtb3ZlJDEobmFtZSwgaSkpXHJcbiAgICAgICAgICAub24oXCJlbmQuc3R5bGUuXCIgKyBuYW1lLCBzdHlsZVJlbW92ZUVuZChuYW1lKSlcclxuICAgICAgOiB0aGlzLnN0eWxlVHdlZW4obmFtZSwgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcclxuICAgICAgICAgID8gc3R5bGVGdW5jdGlvbiQxKG5hbWUsIGksIHR3ZWVuVmFsdWUodGhpcywgXCJzdHlsZS5cIiArIG5hbWUsIHZhbHVlKSlcclxuICAgICAgICAgIDogc3R5bGVDb25zdGFudCQxKG5hbWUsIGksIHZhbHVlICsgXCJcIiksIHByaW9yaXR5KTtcclxufVxyXG5cclxuZnVuY3Rpb24gc3R5bGVUd2VlbihuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcclxuICBmdW5jdGlvbiB0d2VlbigpIHtcclxuICAgIHZhciBub2RlID0gdGhpcywgaSA9IHZhbHVlLmFwcGx5KG5vZGUsIGFyZ3VtZW50cyk7XHJcbiAgICByZXR1cm4gaSAmJiBmdW5jdGlvbih0KSB7XHJcbiAgICAgIG5vZGUuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgaSh0KSwgcHJpb3JpdHkpO1xyXG4gICAgfTtcclxuICB9XHJcbiAgdHdlZW4uX3ZhbHVlID0gdmFsdWU7XHJcbiAgcmV0dXJuIHR3ZWVuO1xyXG59XHJcblxyXG5mdW5jdGlvbiB0cmFuc2l0aW9uX3N0eWxlVHdlZW4obmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XHJcbiAgdmFyIGtleSA9IFwic3R5bGUuXCIgKyAobmFtZSArPSBcIlwiKTtcclxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHJldHVybiAoa2V5ID0gdGhpcy50d2VlbihrZXkpKSAmJiBrZXkuX3ZhbHVlO1xyXG4gIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gdGhpcy50d2VlbihrZXksIG51bGwpO1xyXG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xyXG4gIHJldHVybiB0aGlzLnR3ZWVuKGtleSwgc3R5bGVUd2VlbihuYW1lLCB2YWx1ZSwgcHJpb3JpdHkgPT0gbnVsbCA/IFwiXCIgOiBwcmlvcml0eSkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiB0ZXh0Q29uc3RhbnQkMSh2YWx1ZSkge1xyXG4gIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiB0ZXh0RnVuY3Rpb24kMSh2YWx1ZSkge1xyXG4gIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgIHZhciB2YWx1ZTEgPSB2YWx1ZSh0aGlzKTtcclxuICAgIHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTEgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZTE7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gdHJhbnNpdGlvbl90ZXh0KHZhbHVlKSB7XHJcbiAgcmV0dXJuIHRoaXMudHdlZW4oXCJ0ZXh0XCIsIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXHJcbiAgICAgID8gdGV4dEZ1bmN0aW9uJDEodHdlZW5WYWx1ZSh0aGlzLCBcInRleHRcIiwgdmFsdWUpKVxyXG4gICAgICA6IHRleHRDb25zdGFudCQxKHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKyBcIlwiKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRyYW5zaXRpb25fdHJhbnNpdGlvbigpIHtcclxuICB2YXIgbmFtZSA9IHRoaXMuX25hbWUsXHJcbiAgICAgIGlkMCA9IHRoaXMuX2lkLFxyXG4gICAgICBpZDEgPSBuZXdJZCgpO1xyXG5cclxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBqID0gMDsgaiA8IG07ICsraikge1xyXG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcclxuICAgICAgICB2YXIgaW5oZXJpdCA9IGdldCQxKG5vZGUsIGlkMCk7XHJcbiAgICAgICAgc2NoZWR1bGUobm9kZSwgbmFtZSwgaWQxLCBpLCBncm91cCwge1xyXG4gICAgICAgICAgdGltZTogaW5oZXJpdC50aW1lICsgaW5oZXJpdC5kZWxheSArIGluaGVyaXQuZHVyYXRpb24sXHJcbiAgICAgICAgICBkZWxheTogMCxcclxuICAgICAgICAgIGR1cmF0aW9uOiBpbmhlcml0LmR1cmF0aW9uLFxyXG4gICAgICAgICAgZWFzZTogaW5oZXJpdC5lYXNlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBuZXcgVHJhbnNpdGlvbihncm91cHMsIHRoaXMuX3BhcmVudHMsIG5hbWUsIGlkMSk7XHJcbn1cclxuXHJcbnZhciBpZCA9IDA7XHJcblxyXG5mdW5jdGlvbiBUcmFuc2l0aW9uKGdyb3VwcywgcGFyZW50cywgbmFtZSwgaWQpIHtcclxuICB0aGlzLl9ncm91cHMgPSBncm91cHM7XHJcbiAgdGhpcy5fcGFyZW50cyA9IHBhcmVudHM7XHJcbiAgdGhpcy5fbmFtZSA9IG5hbWU7XHJcbiAgdGhpcy5faWQgPSBpZDtcclxufVxyXG5cclxuZnVuY3Rpb24gdHJhbnNpdGlvbihuYW1lKSB7XHJcbiAgcmV0dXJuIHNlbGVjdGlvbigpLnRyYW5zaXRpb24obmFtZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5ld0lkKCkge1xyXG4gIHJldHVybiArK2lkO1xyXG59XHJcblxyXG52YXIgc2VsZWN0aW9uX3Byb3RvdHlwZSA9IHNlbGVjdGlvbi5wcm90b3R5cGU7XHJcblxyXG5UcmFuc2l0aW9uLnByb3RvdHlwZSA9IHRyYW5zaXRpb24ucHJvdG90eXBlID0ge1xyXG4gIGNvbnN0cnVjdG9yOiBUcmFuc2l0aW9uLFxyXG4gIHNlbGVjdDogdHJhbnNpdGlvbl9zZWxlY3QsXHJcbiAgc2VsZWN0QWxsOiB0cmFuc2l0aW9uX3NlbGVjdEFsbCxcclxuICBmaWx0ZXI6IHRyYW5zaXRpb25fZmlsdGVyLFxyXG4gIG1lcmdlOiB0cmFuc2l0aW9uX21lcmdlLFxyXG4gIHNlbGVjdGlvbjogdHJhbnNpdGlvbl9zZWxlY3Rpb24sXHJcbiAgdHJhbnNpdGlvbjogdHJhbnNpdGlvbl90cmFuc2l0aW9uLFxyXG4gIGNhbGw6IHNlbGVjdGlvbl9wcm90b3R5cGUuY2FsbCxcclxuICBub2Rlczogc2VsZWN0aW9uX3Byb3RvdHlwZS5ub2RlcyxcclxuICBub2RlOiBzZWxlY3Rpb25fcHJvdG90eXBlLm5vZGUsXHJcbiAgc2l6ZTogc2VsZWN0aW9uX3Byb3RvdHlwZS5zaXplLFxyXG4gIGVtcHR5OiBzZWxlY3Rpb25fcHJvdG90eXBlLmVtcHR5LFxyXG4gIGVhY2g6IHNlbGVjdGlvbl9wcm90b3R5cGUuZWFjaCxcclxuICBvbjogdHJhbnNpdGlvbl9vbixcclxuICBhdHRyOiB0cmFuc2l0aW9uX2F0dHIsXHJcbiAgYXR0clR3ZWVuOiB0cmFuc2l0aW9uX2F0dHJUd2VlbixcclxuICBzdHlsZTogdHJhbnNpdGlvbl9zdHlsZSxcclxuICBzdHlsZVR3ZWVuOiB0cmFuc2l0aW9uX3N0eWxlVHdlZW4sXHJcbiAgdGV4dDogdHJhbnNpdGlvbl90ZXh0LFxyXG4gIHJlbW92ZTogdHJhbnNpdGlvbl9yZW1vdmUsXHJcbiAgdHdlZW46IHRyYW5zaXRpb25fdHdlZW4sXHJcbiAgZGVsYXk6IHRyYW5zaXRpb25fZGVsYXksXHJcbiAgZHVyYXRpb246IHRyYW5zaXRpb25fZHVyYXRpb24sXHJcbiAgZWFzZTogdHJhbnNpdGlvbl9lYXNlXHJcbn07XHJcblxyXG5mdW5jdGlvbiBsaW5lYXIkMSh0KSB7XHJcbiAgcmV0dXJuICt0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBxdWFkSW4odCkge1xyXG4gIHJldHVybiB0ICogdDtcclxufVxyXG5cclxuZnVuY3Rpb24gcXVhZE91dCh0KSB7XHJcbiAgcmV0dXJuIHQgKiAoMiAtIHQpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBxdWFkSW5PdXQodCkge1xyXG4gIHJldHVybiAoKHQgKj0gMikgPD0gMSA/IHQgKiB0IDogLS10ICogKDIgLSB0KSArIDEpIC8gMjtcclxufVxyXG5cclxuZnVuY3Rpb24gY3ViaWNJbih0KSB7XHJcbiAgcmV0dXJuIHQgKiB0ICogdDtcclxufVxyXG5cclxuZnVuY3Rpb24gY3ViaWNPdXQodCkge1xyXG4gIHJldHVybiAtLXQgKiB0ICogdCArIDE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGN1YmljSW5PdXQodCkge1xyXG4gIHJldHVybiAoKHQgKj0gMikgPD0gMSA/IHQgKiB0ICogdCA6ICh0IC09IDIpICogdCAqIHQgKyAyKSAvIDI7XHJcbn1cclxuXHJcbnZhciBleHBvbmVudCA9IDM7XHJcblxyXG52YXIgcG9seUluID0gKGZ1bmN0aW9uIGN1c3RvbShlKSB7XHJcbiAgZSA9ICtlO1xyXG5cclxuICBmdW5jdGlvbiBwb2x5SW4odCkge1xyXG4gICAgcmV0dXJuIE1hdGgucG93KHQsIGUpO1xyXG4gIH1cclxuXHJcbiAgcG9seUluLmV4cG9uZW50ID0gY3VzdG9tO1xyXG5cclxuICByZXR1cm4gcG9seUluO1xyXG59KShleHBvbmVudCk7XHJcblxyXG52YXIgcG9seU91dCA9IChmdW5jdGlvbiBjdXN0b20oZSkge1xyXG4gIGUgPSArZTtcclxuXHJcbiAgZnVuY3Rpb24gcG9seU91dCh0KSB7XHJcbiAgICByZXR1cm4gMSAtIE1hdGgucG93KDEgLSB0LCBlKTtcclxuICB9XHJcblxyXG4gIHBvbHlPdXQuZXhwb25lbnQgPSBjdXN0b207XHJcblxyXG4gIHJldHVybiBwb2x5T3V0O1xyXG59KShleHBvbmVudCk7XHJcblxyXG52YXIgcG9seUluT3V0ID0gKGZ1bmN0aW9uIGN1c3RvbShlKSB7XHJcbiAgZSA9ICtlO1xyXG5cclxuICBmdW5jdGlvbiBwb2x5SW5PdXQodCkge1xyXG4gICAgcmV0dXJuICgodCAqPSAyKSA8PSAxID8gTWF0aC5wb3codCwgZSkgOiAyIC0gTWF0aC5wb3coMiAtIHQsIGUpKSAvIDI7XHJcbiAgfVxyXG5cclxuICBwb2x5SW5PdXQuZXhwb25lbnQgPSBjdXN0b207XHJcblxyXG4gIHJldHVybiBwb2x5SW5PdXQ7XHJcbn0pKGV4cG9uZW50KTtcclxuXHJcbnZhciBwaSA9IE1hdGguUEksXHJcbiAgICBoYWxmUGkgPSBwaSAvIDI7XHJcblxyXG5mdW5jdGlvbiBzaW5Jbih0KSB7XHJcbiAgcmV0dXJuIDEgLSBNYXRoLmNvcyh0ICogaGFsZlBpKTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2luT3V0KHQpIHtcclxuICByZXR1cm4gTWF0aC5zaW4odCAqIGhhbGZQaSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNpbkluT3V0KHQpIHtcclxuICByZXR1cm4gKDEgLSBNYXRoLmNvcyhwaSAqIHQpKSAvIDI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGV4cEluKHQpIHtcclxuICByZXR1cm4gTWF0aC5wb3coMiwgMTAgKiB0IC0gMTApO1xyXG59XHJcblxyXG5mdW5jdGlvbiBleHBPdXQodCkge1xyXG4gIHJldHVybiAxIC0gTWF0aC5wb3coMiwgLTEwICogdCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGV4cEluT3V0KHQpIHtcclxuICByZXR1cm4gKCh0ICo9IDIpIDw9IDEgPyBNYXRoLnBvdygyLCAxMCAqIHQgLSAxMCkgOiAyIC0gTWF0aC5wb3coMiwgMTAgLSAxMCAqIHQpKSAvIDI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNpcmNsZUluKHQpIHtcclxuICByZXR1cm4gMSAtIE1hdGguc3FydCgxIC0gdCAqIHQpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjaXJjbGVPdXQodCkge1xyXG4gIHJldHVybiBNYXRoLnNxcnQoMSAtIC0tdCAqIHQpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjaXJjbGVJbk91dCh0KSB7XHJcbiAgcmV0dXJuICgodCAqPSAyKSA8PSAxID8gMSAtIE1hdGguc3FydCgxIC0gdCAqIHQpIDogTWF0aC5zcXJ0KDEgLSAodCAtPSAyKSAqIHQpICsgMSkgLyAyO1xyXG59XHJcblxyXG52YXIgYjEgPSA0IC8gMTEsXHJcbiAgICBiMiA9IDYgLyAxMSxcclxuICAgIGIzID0gOCAvIDExLFxyXG4gICAgYjQgPSAzIC8gNCxcclxuICAgIGI1ID0gOSAvIDExLFxyXG4gICAgYjYgPSAxMCAvIDExLFxyXG4gICAgYjcgPSAxNSAvIDE2LFxyXG4gICAgYjggPSAyMSAvIDIyLFxyXG4gICAgYjkgPSA2MyAvIDY0LFxyXG4gICAgYjAgPSAxIC8gYjEgLyBiMTtcclxuXHJcbmZ1bmN0aW9uIGJvdW5jZUluKHQpIHtcclxuICByZXR1cm4gMSAtIGJvdW5jZU91dCgxIC0gdCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGJvdW5jZU91dCh0KSB7XHJcbiAgcmV0dXJuICh0ID0gK3QpIDwgYjEgPyBiMCAqIHQgKiB0IDogdCA8IGIzID8gYjAgKiAodCAtPSBiMikgKiB0ICsgYjQgOiB0IDwgYjYgPyBiMCAqICh0IC09IGI1KSAqIHQgKyBiNyA6IGIwICogKHQgLT0gYjgpICogdCArIGI5O1xyXG59XHJcblxyXG5mdW5jdGlvbiBib3VuY2VJbk91dCh0KSB7XHJcbiAgcmV0dXJuICgodCAqPSAyKSA8PSAxID8gMSAtIGJvdW5jZU91dCgxIC0gdCkgOiBib3VuY2VPdXQodCAtIDEpICsgMSkgLyAyO1xyXG59XHJcblxyXG52YXIgb3ZlcnNob290ID0gMS43MDE1ODtcclxuXHJcbnZhciBiYWNrSW4gPSAoZnVuY3Rpb24gY3VzdG9tKHMpIHtcclxuICBzID0gK3M7XHJcblxyXG4gIGZ1bmN0aW9uIGJhY2tJbih0KSB7XHJcbiAgICByZXR1cm4gdCAqIHQgKiAoKHMgKyAxKSAqIHQgLSBzKTtcclxuICB9XHJcblxyXG4gIGJhY2tJbi5vdmVyc2hvb3QgPSBjdXN0b207XHJcblxyXG4gIHJldHVybiBiYWNrSW47XHJcbn0pKG92ZXJzaG9vdCk7XHJcblxyXG52YXIgYmFja091dCA9IChmdW5jdGlvbiBjdXN0b20ocykge1xyXG4gIHMgPSArcztcclxuXHJcbiAgZnVuY3Rpb24gYmFja091dCh0KSB7XHJcbiAgICByZXR1cm4gLS10ICogdCAqICgocyArIDEpICogdCArIHMpICsgMTtcclxuICB9XHJcblxyXG4gIGJhY2tPdXQub3ZlcnNob290ID0gY3VzdG9tO1xyXG5cclxuICByZXR1cm4gYmFja091dDtcclxufSkob3ZlcnNob290KTtcclxuXHJcbnZhciBiYWNrSW5PdXQgPSAoZnVuY3Rpb24gY3VzdG9tKHMpIHtcclxuICBzID0gK3M7XHJcblxyXG4gIGZ1bmN0aW9uIGJhY2tJbk91dCh0KSB7XHJcbiAgICByZXR1cm4gKCh0ICo9IDIpIDwgMSA/IHQgKiB0ICogKChzICsgMSkgKiB0IC0gcykgOiAodCAtPSAyKSAqIHQgKiAoKHMgKyAxKSAqIHQgKyBzKSArIDIpIC8gMjtcclxuICB9XHJcblxyXG4gIGJhY2tJbk91dC5vdmVyc2hvb3QgPSBjdXN0b207XHJcblxyXG4gIHJldHVybiBiYWNrSW5PdXQ7XHJcbn0pKG92ZXJzaG9vdCk7XHJcblxyXG52YXIgdGF1ID0gMiAqIE1hdGguUEksXHJcbiAgICBhbXBsaXR1ZGUgPSAxLFxyXG4gICAgcGVyaW9kID0gMC4zO1xyXG5cclxudmFyIGVsYXN0aWNJbiA9IChmdW5jdGlvbiBjdXN0b20oYSwgcCkge1xyXG4gIHZhciBzID0gTWF0aC5hc2luKDEgLyAoYSA9IE1hdGgubWF4KDEsIGEpKSkgKiAocCAvPSB0YXUpO1xyXG5cclxuICBmdW5jdGlvbiBlbGFzdGljSW4odCkge1xyXG4gICAgcmV0dXJuIGEgKiBNYXRoLnBvdygyLCAxMCAqIC0tdCkgKiBNYXRoLnNpbigocyAtIHQpIC8gcCk7XHJcbiAgfVxyXG5cclxuICBlbGFzdGljSW4uYW1wbGl0dWRlID0gZnVuY3Rpb24oYSkgeyByZXR1cm4gY3VzdG9tKGEsIHAgKiB0YXUpOyB9O1xyXG4gIGVsYXN0aWNJbi5wZXJpb2QgPSBmdW5jdGlvbihwKSB7IHJldHVybiBjdXN0b20oYSwgcCk7IH07XHJcblxyXG4gIHJldHVybiBlbGFzdGljSW47XHJcbn0pKGFtcGxpdHVkZSwgcGVyaW9kKTtcclxuXHJcbnZhciBlbGFzdGljT3V0ID0gKGZ1bmN0aW9uIGN1c3RvbShhLCBwKSB7XHJcbiAgdmFyIHMgPSBNYXRoLmFzaW4oMSAvIChhID0gTWF0aC5tYXgoMSwgYSkpKSAqIChwIC89IHRhdSk7XHJcblxyXG4gIGZ1bmN0aW9uIGVsYXN0aWNPdXQodCkge1xyXG4gICAgcmV0dXJuIDEgLSBhICogTWF0aC5wb3coMiwgLTEwICogKHQgPSArdCkpICogTWF0aC5zaW4oKHQgKyBzKSAvIHApO1xyXG4gIH1cclxuXHJcbiAgZWxhc3RpY091dC5hbXBsaXR1ZGUgPSBmdW5jdGlvbihhKSB7IHJldHVybiBjdXN0b20oYSwgcCAqIHRhdSk7IH07XHJcbiAgZWxhc3RpY091dC5wZXJpb2QgPSBmdW5jdGlvbihwKSB7IHJldHVybiBjdXN0b20oYSwgcCk7IH07XHJcblxyXG4gIHJldHVybiBlbGFzdGljT3V0O1xyXG59KShhbXBsaXR1ZGUsIHBlcmlvZCk7XHJcblxyXG52YXIgZWxhc3RpY0luT3V0ID0gKGZ1bmN0aW9uIGN1c3RvbShhLCBwKSB7XHJcbiAgdmFyIHMgPSBNYXRoLmFzaW4oMSAvIChhID0gTWF0aC5tYXgoMSwgYSkpKSAqIChwIC89IHRhdSk7XHJcblxyXG4gIGZ1bmN0aW9uIGVsYXN0aWNJbk91dCh0KSB7XHJcbiAgICByZXR1cm4gKCh0ID0gdCAqIDIgLSAxKSA8IDBcclxuICAgICAgICA/IGEgKiBNYXRoLnBvdygyLCAxMCAqIHQpICogTWF0aC5zaW4oKHMgLSB0KSAvIHApXHJcbiAgICAgICAgOiAyIC0gYSAqIE1hdGgucG93KDIsIC0xMCAqIHQpICogTWF0aC5zaW4oKHMgKyB0KSAvIHApKSAvIDI7XHJcbiAgfVxyXG5cclxuICBlbGFzdGljSW5PdXQuYW1wbGl0dWRlID0gZnVuY3Rpb24oYSkgeyByZXR1cm4gY3VzdG9tKGEsIHAgKiB0YXUpOyB9O1xyXG4gIGVsYXN0aWNJbk91dC5wZXJpb2QgPSBmdW5jdGlvbihwKSB7IHJldHVybiBjdXN0b20oYSwgcCk7IH07XHJcblxyXG4gIHJldHVybiBlbGFzdGljSW5PdXQ7XHJcbn0pKGFtcGxpdHVkZSwgcGVyaW9kKTtcclxuXHJcbnZhciBkZWZhdWx0VGltaW5nID0ge1xyXG4gIHRpbWU6IG51bGwsIC8vIFNldCBvbiB1c2UuXHJcbiAgZGVsYXk6IDAsXHJcbiAgZHVyYXRpb246IDI1MCxcclxuICBlYXNlOiBjdWJpY0luT3V0XHJcbn07XHJcblxyXG5mdW5jdGlvbiBpbmhlcml0KG5vZGUsIGlkKSB7XHJcbiAgdmFyIHRpbWluZztcclxuICB3aGlsZSAoISh0aW1pbmcgPSBub2RlLl9fdHJhbnNpdGlvbikgfHwgISh0aW1pbmcgPSB0aW1pbmdbaWRdKSkge1xyXG4gICAgaWYgKCEobm9kZSA9IG5vZGUucGFyZW50Tm9kZSkpIHtcclxuICAgICAgcmV0dXJuIGRlZmF1bHRUaW1pbmcudGltZSA9IG5vdygpLCBkZWZhdWx0VGltaW5nO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdGltaW5nO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZWxlY3Rpb25fdHJhbnNpdGlvbihuYW1lKSB7XHJcbiAgdmFyIGlkLFxyXG4gICAgICB0aW1pbmc7XHJcblxyXG4gIGlmIChuYW1lIGluc3RhbmNlb2YgVHJhbnNpdGlvbikge1xyXG4gICAgaWQgPSBuYW1lLl9pZCwgbmFtZSA9IG5hbWUuX25hbWU7XHJcbiAgfSBlbHNlIHtcclxuICAgIGlkID0gbmV3SWQoKSwgKHRpbWluZyA9IGRlZmF1bHRUaW1pbmcpLnRpbWUgPSBub3coKSwgbmFtZSA9IG5hbWUgPT0gbnVsbCA/IG51bGwgOiBuYW1lICsgXCJcIjtcclxuICB9XHJcblxyXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIGogPSAwOyBqIDwgbTsgKytqKSB7XHJcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcclxuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xyXG4gICAgICAgIHNjaGVkdWxlKG5vZGUsIG5hbWUsIGlkLCBpLCBncm91cCwgdGltaW5nIHx8IGluaGVyaXQobm9kZSwgaWQpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uKGdyb3VwcywgdGhpcy5fcGFyZW50cywgbmFtZSwgaWQpO1xyXG59XHJcblxyXG5zZWxlY3Rpb24ucHJvdG90eXBlLmludGVycnVwdCA9IHNlbGVjdGlvbl9pbnRlcnJ1cHQ7XHJcbnNlbGVjdGlvbi5wcm90b3R5cGUudHJhbnNpdGlvbiA9IHNlbGVjdGlvbl90cmFuc2l0aW9uO1xyXG5cclxudmFyIHJvb3QkMSA9IFtudWxsXTtcclxuXHJcbmZ1bmN0aW9uIGFjdGl2ZShub2RlLCBuYW1lKSB7XHJcbiAgdmFyIHNjaGVkdWxlcyA9IG5vZGUuX190cmFuc2l0aW9uLFxyXG4gICAgICBzY2hlZHVsZSQkMSxcclxuICAgICAgaTtcclxuXHJcbiAgaWYgKHNjaGVkdWxlcykge1xyXG4gICAgbmFtZSA9IG5hbWUgPT0gbnVsbCA/IG51bGwgOiBuYW1lICsgXCJcIjtcclxuICAgIGZvciAoaSBpbiBzY2hlZHVsZXMpIHtcclxuICAgICAgaWYgKChzY2hlZHVsZSQkMSA9IHNjaGVkdWxlc1tpXSkuc3RhdGUgPiBTQ0hFRFVMRUQgJiYgc2NoZWR1bGUkJDEubmFtZSA9PT0gbmFtZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVHJhbnNpdGlvbihbW25vZGVdXSwgcm9vdCQxLCBuYW1lLCAraSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBudWxsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb25zdGFudCQ0KHgpIHtcclxuICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4geDtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBCcnVzaEV2ZW50KHRhcmdldCwgdHlwZSwgc2VsZWN0aW9uKSB7XHJcbiAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgdGhpcy50eXBlID0gdHlwZTtcclxuICB0aGlzLnNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcclxufVxyXG5cclxuZnVuY3Rpb24gbm9wcm9wYWdhdGlvbiQxKCkge1xyXG4gIGQzLmV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBub2V2ZW50JDEoKSB7XHJcbiAgZDMuZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICBkMy5ldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcclxufVxyXG5cclxudmFyIE1PREVfRFJBRyA9IHtuYW1lOiBcImRyYWdcIn0sXHJcbiAgICBNT0RFX1NQQUNFID0ge25hbWU6IFwic3BhY2VcIn0sXHJcbiAgICBNT0RFX0hBTkRMRSA9IHtuYW1lOiBcImhhbmRsZVwifSxcclxuICAgIE1PREVfQ0VOVEVSID0ge25hbWU6IFwiY2VudGVyXCJ9O1xyXG5cclxudmFyIFggPSB7XHJcbiAgbmFtZTogXCJ4XCIsXHJcbiAgaGFuZGxlczogW1wiZVwiLCBcIndcIl0ubWFwKHR5cGUpLFxyXG4gIGlucHV0OiBmdW5jdGlvbih4LCBlKSB7IHJldHVybiB4ICYmIFtbeFswXSwgZVswXVsxXV0sIFt4WzFdLCBlWzFdWzFdXV07IH0sXHJcbiAgb3V0cHV0OiBmdW5jdGlvbih4eSkgeyByZXR1cm4geHkgJiYgW3h5WzBdWzBdLCB4eVsxXVswXV07IH1cclxufTtcclxuXHJcbnZhciBZID0ge1xyXG4gIG5hbWU6IFwieVwiLFxyXG4gIGhhbmRsZXM6IFtcIm5cIiwgXCJzXCJdLm1hcCh0eXBlKSxcclxuICBpbnB1dDogZnVuY3Rpb24oeSwgZSkgeyByZXR1cm4geSAmJiBbW2VbMF1bMF0sIHlbMF1dLCBbZVsxXVswXSwgeVsxXV1dOyB9LFxyXG4gIG91dHB1dDogZnVuY3Rpb24oeHkpIHsgcmV0dXJuIHh5ICYmIFt4eVswXVsxXSwgeHlbMV1bMV1dOyB9XHJcbn07XHJcblxyXG52YXIgWFkgPSB7XHJcbiAgbmFtZTogXCJ4eVwiLFxyXG4gIGhhbmRsZXM6IFtcIm5cIiwgXCJlXCIsIFwic1wiLCBcIndcIiwgXCJud1wiLCBcIm5lXCIsIFwic2VcIiwgXCJzd1wiXS5tYXAodHlwZSksXHJcbiAgaW5wdXQ6IGZ1bmN0aW9uKHh5KSB7IHJldHVybiB4eTsgfSxcclxuICBvdXRwdXQ6IGZ1bmN0aW9uKHh5KSB7IHJldHVybiB4eTsgfVxyXG59O1xyXG5cclxudmFyIGN1cnNvcnMgPSB7XHJcbiAgb3ZlcmxheTogXCJjcm9zc2hhaXJcIixcclxuICBzZWxlY3Rpb246IFwibW92ZVwiLFxyXG4gIG46IFwibnMtcmVzaXplXCIsXHJcbiAgZTogXCJldy1yZXNpemVcIixcclxuICBzOiBcIm5zLXJlc2l6ZVwiLFxyXG4gIHc6IFwiZXctcmVzaXplXCIsXHJcbiAgbnc6IFwibndzZS1yZXNpemVcIixcclxuICBuZTogXCJuZXN3LXJlc2l6ZVwiLFxyXG4gIHNlOiBcIm53c2UtcmVzaXplXCIsXHJcbiAgc3c6IFwibmVzdy1yZXNpemVcIlxyXG59O1xyXG5cclxudmFyIGZsaXBYID0ge1xyXG4gIGU6IFwid1wiLFxyXG4gIHc6IFwiZVwiLFxyXG4gIG53OiBcIm5lXCIsXHJcbiAgbmU6IFwibndcIixcclxuICBzZTogXCJzd1wiLFxyXG4gIHN3OiBcInNlXCJcclxufTtcclxuXHJcbnZhciBmbGlwWSA9IHtcclxuICBuOiBcInNcIixcclxuICBzOiBcIm5cIixcclxuICBudzogXCJzd1wiLFxyXG4gIG5lOiBcInNlXCIsXHJcbiAgc2U6IFwibmVcIixcclxuICBzdzogXCJud1wiXHJcbn07XHJcblxyXG52YXIgc2lnbnNYID0ge1xyXG4gIG92ZXJsYXk6ICsxLFxyXG4gIHNlbGVjdGlvbjogKzEsXHJcbiAgbjogbnVsbCxcclxuICBlOiArMSxcclxuICBzOiBudWxsLFxyXG4gIHc6IC0xLFxyXG4gIG53OiAtMSxcclxuICBuZTogKzEsXHJcbiAgc2U6ICsxLFxyXG4gIHN3OiAtMVxyXG59O1xyXG5cclxudmFyIHNpZ25zWSA9IHtcclxuICBvdmVybGF5OiArMSxcclxuICBzZWxlY3Rpb246ICsxLFxyXG4gIG46IC0xLFxyXG4gIGU6IG51bGwsXHJcbiAgczogKzEsXHJcbiAgdzogbnVsbCxcclxuICBudzogLTEsXHJcbiAgbmU6IC0xLFxyXG4gIHNlOiArMSxcclxuICBzdzogKzFcclxufTtcclxuXHJcbmZ1bmN0aW9uIHR5cGUodCkge1xyXG4gIHJldHVybiB7dHlwZTogdH07XHJcbn1cclxuXHJcbi8vIElnbm9yZSByaWdodC1jbGljaywgc2luY2UgdGhhdCBzaG91bGQgb3BlbiB0aGUgY29udGV4dCBtZW51LlxyXG5mdW5jdGlvbiBkZWZhdWx0RmlsdGVyJDEoKSB7XHJcbiAgcmV0dXJuICFkMy5ldmVudC5idXR0b247XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlZmF1bHRFeHRlbnQoKSB7XHJcbiAgdmFyIHN2ZyA9IHRoaXMub3duZXJTVkdFbGVtZW50IHx8IHRoaXM7XHJcbiAgcmV0dXJuIFtbMCwgMF0sIFtzdmcud2lkdGguYmFzZVZhbC52YWx1ZSwgc3ZnLmhlaWdodC5iYXNlVmFsLnZhbHVlXV07XHJcbn1cclxuXHJcbi8vIExpa2UgZDMubG9jYWwsIGJ1dCB3aXRoIHRoZSBuYW1lIOKAnF9fYnJ1c2jigJ0gcmF0aGVyIHRoYW4gYXV0by1nZW5lcmF0ZWQuXHJcbmZ1bmN0aW9uIGxvY2FsJDEobm9kZSkge1xyXG4gIHdoaWxlICghbm9kZS5fX2JydXNoKSBpZiAoIShub2RlID0gbm9kZS5wYXJlbnROb2RlKSkgcmV0dXJuO1xyXG4gIHJldHVybiBub2RlLl9fYnJ1c2g7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVtcHR5JDEoZXh0ZW50KSB7XHJcbiAgcmV0dXJuIGV4dGVudFswXVswXSA9PT0gZXh0ZW50WzFdWzBdXHJcbiAgICAgIHx8IGV4dGVudFswXVsxXSA9PT0gZXh0ZW50WzFdWzFdO1xyXG59XHJcblxyXG5mdW5jdGlvbiBicnVzaFNlbGVjdGlvbihub2RlKSB7XHJcbiAgdmFyIHN0YXRlID0gbm9kZS5fX2JydXNoO1xyXG4gIHJldHVybiBzdGF0ZSA/IHN0YXRlLmRpbS5vdXRwdXQoc3RhdGUuc2VsZWN0aW9uKSA6IG51bGw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGJydXNoWCgpIHtcclxuICByZXR1cm4gYnJ1c2gkMShYKTtcclxufVxyXG5cclxuZnVuY3Rpb24gYnJ1c2hZKCkge1xyXG4gIHJldHVybiBicnVzaCQxKFkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBicnVzaCgpIHtcclxuICByZXR1cm4gYnJ1c2gkMShYWSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGJydXNoJDEoZGltKSB7XHJcbiAgdmFyIGV4dGVudCA9IGRlZmF1bHRFeHRlbnQsXHJcbiAgICAgIGZpbHRlciA9IGRlZmF1bHRGaWx0ZXIkMSxcclxuICAgICAgbGlzdGVuZXJzID0gZGlzcGF0Y2goYnJ1c2gsIFwic3RhcnRcIiwgXCJicnVzaFwiLCBcImVuZFwiKSxcclxuICAgICAgaGFuZGxlU2l6ZSA9IDYsXHJcbiAgICAgIHRvdWNoZW5kaW5nO1xyXG5cclxuICBmdW5jdGlvbiBicnVzaChncm91cCkge1xyXG4gICAgdmFyIG92ZXJsYXkgPSBncm91cFxyXG4gICAgICAgIC5wcm9wZXJ0eShcIl9fYnJ1c2hcIiwgaW5pdGlhbGl6ZSlcclxuICAgICAgLnNlbGVjdEFsbChcIi5vdmVybGF5XCIpXHJcbiAgICAgIC5kYXRhKFt0eXBlKFwib3ZlcmxheVwiKV0pO1xyXG5cclxuICAgIG92ZXJsYXkuZW50ZXIoKS5hcHBlbmQoXCJyZWN0XCIpXHJcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcIm92ZXJsYXlcIilcclxuICAgICAgICAuYXR0cihcInBvaW50ZXItZXZlbnRzXCIsIFwiYWxsXCIpXHJcbiAgICAgICAgLmF0dHIoXCJjdXJzb3JcIiwgY3Vyc29ycy5vdmVybGF5KVxyXG4gICAgICAubWVyZ2Uob3ZlcmxheSlcclxuICAgICAgICAuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHZhciBleHRlbnQgPSBsb2NhbCQxKHRoaXMpLmV4dGVudDtcclxuICAgICAgICAgIHNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAgIC5hdHRyKFwieFwiLCBleHRlbnRbMF1bMF0pXHJcbiAgICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIGV4dGVudFswXVsxXSlcclxuICAgICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIGV4dGVudFsxXVswXSAtIGV4dGVudFswXVswXSlcclxuICAgICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBleHRlbnRbMV1bMV0gLSBleHRlbnRbMF1bMV0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIGdyb3VwLnNlbGVjdEFsbChcIi5zZWxlY3Rpb25cIilcclxuICAgICAgLmRhdGEoW3R5cGUoXCJzZWxlY3Rpb25cIildKVxyXG4gICAgICAuZW50ZXIoKS5hcHBlbmQoXCJyZWN0XCIpXHJcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInNlbGVjdGlvblwiKVxyXG4gICAgICAgIC5hdHRyKFwiY3Vyc29yXCIsIGN1cnNvcnMuc2VsZWN0aW9uKVxyXG4gICAgICAgIC5hdHRyKFwiZmlsbFwiLCBcIiM3NzdcIilcclxuICAgICAgICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwLjMpXHJcbiAgICAgICAgLmF0dHIoXCJzdHJva2VcIiwgXCIjZmZmXCIpXHJcbiAgICAgICAgLmF0dHIoXCJzaGFwZS1yZW5kZXJpbmdcIiwgXCJjcmlzcEVkZ2VzXCIpO1xyXG5cclxuICAgIHZhciBoYW5kbGUgPSBncm91cC5zZWxlY3RBbGwoXCIuaGFuZGxlXCIpXHJcbiAgICAgIC5kYXRhKGRpbS5oYW5kbGVzLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLnR5cGU7IH0pO1xyXG5cclxuICAgIGhhbmRsZS5leGl0KCkucmVtb3ZlKCk7XHJcblxyXG4gICAgaGFuZGxlLmVudGVyKCkuYXBwZW5kKFwicmVjdFwiKVxyXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gXCJoYW5kbGUgaGFuZGxlLS1cIiArIGQudHlwZTsgfSlcclxuICAgICAgICAuYXR0cihcImN1cnNvclwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBjdXJzb3JzW2QudHlwZV07IH0pO1xyXG5cclxuICAgIGdyb3VwXHJcbiAgICAgICAgLmVhY2gocmVkcmF3KVxyXG4gICAgICAgIC5hdHRyKFwiZmlsbFwiLCBcIm5vbmVcIilcclxuICAgICAgICAuYXR0cihcInBvaW50ZXItZXZlbnRzXCIsIFwiYWxsXCIpXHJcbiAgICAgICAgLnN0eWxlKFwiLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yXCIsIFwicmdiYSgwLDAsMCwwKVwiKVxyXG4gICAgICAgIC5vbihcIm1vdXNlZG93bi5icnVzaCB0b3VjaHN0YXJ0LmJydXNoXCIsIHN0YXJ0ZWQpO1xyXG4gIH1cclxuXHJcbiAgYnJ1c2gubW92ZSA9IGZ1bmN0aW9uKGdyb3VwLCBzZWxlY3Rpb24kJDEpIHtcclxuICAgIGlmIChncm91cC5zZWxlY3Rpb24pIHtcclxuICAgICAgZ3JvdXBcclxuICAgICAgICAgIC5vbihcInN0YXJ0LmJydXNoXCIsIGZ1bmN0aW9uKCkgeyBlbWl0dGVyKHRoaXMsIGFyZ3VtZW50cykuYmVmb3Jlc3RhcnQoKS5zdGFydCgpOyB9KVxyXG4gICAgICAgICAgLm9uKFwiaW50ZXJydXB0LmJydXNoIGVuZC5icnVzaFwiLCBmdW5jdGlvbigpIHsgZW1pdHRlcih0aGlzLCBhcmd1bWVudHMpLmVuZCgpOyB9KVxyXG4gICAgICAgICAgLnR3ZWVuKFwiYnJ1c2hcIiwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcclxuICAgICAgICAgICAgICAgIHN0YXRlID0gdGhhdC5fX2JydXNoLFxyXG4gICAgICAgICAgICAgICAgZW1pdCA9IGVtaXR0ZXIodGhhdCwgYXJndW1lbnRzKSxcclxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbjAgPSBzdGF0ZS5zZWxlY3Rpb24sXHJcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24xID0gZGltLmlucHV0KHR5cGVvZiBzZWxlY3Rpb24kJDEgPT09IFwiZnVuY3Rpb25cIiA/IHNlbGVjdGlvbiQkMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogc2VsZWN0aW9uJCQxLCBzdGF0ZS5leHRlbnQpLFxyXG4gICAgICAgICAgICAgICAgaSA9IGludGVycG9sYXRlVmFsdWUoc2VsZWN0aW9uMCwgc2VsZWN0aW9uMSk7XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiB0d2Vlbih0KSB7XHJcbiAgICAgICAgICAgICAgc3RhdGUuc2VsZWN0aW9uID0gdCA9PT0gMSAmJiBlbXB0eSQxKHNlbGVjdGlvbjEpID8gbnVsbCA6IGkodCk7XHJcbiAgICAgICAgICAgICAgcmVkcmF3LmNhbGwodGhhdCk7XHJcbiAgICAgICAgICAgICAgZW1pdC5icnVzaCgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0aW9uMCAmJiBzZWxlY3Rpb24xID8gdHdlZW4gOiB0d2VlbigxKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZ3JvdXBcclxuICAgICAgICAgIC5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXHJcbiAgICAgICAgICAgICAgICBhcmdzID0gYXJndW1lbnRzLFxyXG4gICAgICAgICAgICAgICAgc3RhdGUgPSB0aGF0Ll9fYnJ1c2gsXHJcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24xID0gZGltLmlucHV0KHR5cGVvZiBzZWxlY3Rpb24kJDEgPT09IFwiZnVuY3Rpb25cIiA/IHNlbGVjdGlvbiQkMS5hcHBseSh0aGF0LCBhcmdzKSA6IHNlbGVjdGlvbiQkMSwgc3RhdGUuZXh0ZW50KSxcclxuICAgICAgICAgICAgICAgIGVtaXQgPSBlbWl0dGVyKHRoYXQsIGFyZ3MpLmJlZm9yZXN0YXJ0KCk7XHJcblxyXG4gICAgICAgICAgICBpbnRlcnJ1cHQodGhhdCk7XHJcbiAgICAgICAgICAgIHN0YXRlLnNlbGVjdGlvbiA9IHNlbGVjdGlvbjEgPT0gbnVsbCB8fCBlbXB0eSQxKHNlbGVjdGlvbjEpID8gbnVsbCA6IHNlbGVjdGlvbjE7XHJcbiAgICAgICAgICAgIHJlZHJhdy5jYWxsKHRoYXQpO1xyXG4gICAgICAgICAgICBlbWl0LnN0YXJ0KCkuYnJ1c2goKS5lbmQoKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIHJlZHJhdygpIHtcclxuICAgIHZhciBncm91cCA9IHNlbGVjdCh0aGlzKSxcclxuICAgICAgICBzZWxlY3Rpb24kJDEgPSBsb2NhbCQxKHRoaXMpLnNlbGVjdGlvbjtcclxuXHJcbiAgICBpZiAoc2VsZWN0aW9uJCQxKSB7XHJcbiAgICAgIGdyb3VwLnNlbGVjdEFsbChcIi5zZWxlY3Rpb25cIilcclxuICAgICAgICAgIC5zdHlsZShcImRpc3BsYXlcIiwgbnVsbClcclxuICAgICAgICAgIC5hdHRyKFwieFwiLCBzZWxlY3Rpb24kJDFbMF1bMF0pXHJcbiAgICAgICAgICAuYXR0cihcInlcIiwgc2VsZWN0aW9uJCQxWzBdWzFdKVxyXG4gICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCBzZWxlY3Rpb24kJDFbMV1bMF0gLSBzZWxlY3Rpb24kJDFbMF1bMF0pXHJcbiAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBzZWxlY3Rpb24kJDFbMV1bMV0gLSBzZWxlY3Rpb24kJDFbMF1bMV0pO1xyXG5cclxuICAgICAgZ3JvdXAuc2VsZWN0QWxsKFwiLmhhbmRsZVwiKVxyXG4gICAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBudWxsKVxyXG4gICAgICAgICAgLmF0dHIoXCJ4XCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQudHlwZVtkLnR5cGUubGVuZ3RoIC0gMV0gPT09IFwiZVwiID8gc2VsZWN0aW9uJCQxWzFdWzBdIC0gaGFuZGxlU2l6ZSAvIDIgOiBzZWxlY3Rpb24kJDFbMF1bMF0gLSBoYW5kbGVTaXplIC8gMjsgfSlcclxuICAgICAgICAgIC5hdHRyKFwieVwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLnR5cGVbMF0gPT09IFwic1wiID8gc2VsZWN0aW9uJCQxWzFdWzFdIC0gaGFuZGxlU2l6ZSAvIDIgOiBzZWxlY3Rpb24kJDFbMF1bMV0gLSBoYW5kbGVTaXplIC8gMjsgfSlcclxuICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC50eXBlID09PSBcIm5cIiB8fCBkLnR5cGUgPT09IFwic1wiID8gc2VsZWN0aW9uJCQxWzFdWzBdIC0gc2VsZWN0aW9uJCQxWzBdWzBdICsgaGFuZGxlU2l6ZSA6IGhhbmRsZVNpemU7IH0pXHJcbiAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLnR5cGUgPT09IFwiZVwiIHx8IGQudHlwZSA9PT0gXCJ3XCIgPyBzZWxlY3Rpb24kJDFbMV1bMV0gLSBzZWxlY3Rpb24kJDFbMF1bMV0gKyBoYW5kbGVTaXplIDogaGFuZGxlU2l6ZTsgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZWxzZSB7XHJcbiAgICAgIGdyb3VwLnNlbGVjdEFsbChcIi5zZWxlY3Rpb24sLmhhbmRsZVwiKVxyXG4gICAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBcIm5vbmVcIilcclxuICAgICAgICAgIC5hdHRyKFwieFwiLCBudWxsKVxyXG4gICAgICAgICAgLmF0dHIoXCJ5XCIsIG51bGwpXHJcbiAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIG51bGwpXHJcbiAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBudWxsKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGVtaXR0ZXIodGhhdCwgYXJncykge1xyXG4gICAgcmV0dXJuIHRoYXQuX19icnVzaC5lbWl0dGVyIHx8IG5ldyBFbWl0dGVyKHRoYXQsIGFyZ3MpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gRW1pdHRlcih0aGF0LCBhcmdzKSB7XHJcbiAgICB0aGlzLnRoYXQgPSB0aGF0O1xyXG4gICAgdGhpcy5hcmdzID0gYXJncztcclxuICAgIHRoaXMuc3RhdGUgPSB0aGF0Ll9fYnJ1c2g7XHJcbiAgICB0aGlzLmFjdGl2ZSA9IDA7XHJcbiAgfVxyXG5cclxuICBFbWl0dGVyLnByb3RvdHlwZSA9IHtcclxuICAgIGJlZm9yZXN0YXJ0OiBmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKCsrdGhpcy5hY3RpdmUgPT09IDEpIHRoaXMuc3RhdGUuZW1pdHRlciA9IHRoaXMsIHRoaXMuc3RhcnRpbmcgPSB0cnVlO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcbiAgICBzdGFydDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIGlmICh0aGlzLnN0YXJ0aW5nKSB0aGlzLnN0YXJ0aW5nID0gZmFsc2UsIHRoaXMuZW1pdChcInN0YXJ0XCIpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcbiAgICBicnVzaDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHRoaXMuZW1pdChcImJydXNoXCIpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcbiAgICBlbmQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICBpZiAoLS10aGlzLmFjdGl2ZSA9PT0gMCkgZGVsZXRlIHRoaXMuc3RhdGUuZW1pdHRlciwgdGhpcy5lbWl0KFwiZW5kXCIpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcbiAgICBlbWl0OiBmdW5jdGlvbih0eXBlKSB7XHJcbiAgICAgIGN1c3RvbUV2ZW50KG5ldyBCcnVzaEV2ZW50KGJydXNoLCB0eXBlLCBkaW0ub3V0cHV0KHRoaXMuc3RhdGUuc2VsZWN0aW9uKSksIGxpc3RlbmVycy5hcHBseSwgbGlzdGVuZXJzLCBbdHlwZSwgdGhpcy50aGF0LCB0aGlzLmFyZ3NdKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBzdGFydGVkKCkge1xyXG4gICAgaWYgKGQzLmV2ZW50LnRvdWNoZXMpIHsgaWYgKGQzLmV2ZW50LmNoYW5nZWRUb3VjaGVzLmxlbmd0aCA8IGQzLmV2ZW50LnRvdWNoZXMubGVuZ3RoKSByZXR1cm4gbm9ldmVudCQxKCk7IH1cclxuICAgIGVsc2UgaWYgKHRvdWNoZW5kaW5nKSByZXR1cm47XHJcbiAgICBpZiAoIWZpbHRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSByZXR1cm47XHJcblxyXG4gICAgdmFyIHRoYXQgPSB0aGlzLFxyXG4gICAgICAgIHR5cGUgPSBkMy5ldmVudC50YXJnZXQuX19kYXRhX18udHlwZSxcclxuICAgICAgICBtb2RlID0gKGQzLmV2ZW50Lm1ldGFLZXkgPyB0eXBlID0gXCJvdmVybGF5XCIgOiB0eXBlKSA9PT0gXCJzZWxlY3Rpb25cIiA/IE1PREVfRFJBRyA6IChkMy5ldmVudC5hbHRLZXkgPyBNT0RFX0NFTlRFUiA6IE1PREVfSEFORExFKSxcclxuICAgICAgICBzaWduWCA9IGRpbSA9PT0gWSA/IG51bGwgOiBzaWduc1hbdHlwZV0sXHJcbiAgICAgICAgc2lnblkgPSBkaW0gPT09IFggPyBudWxsIDogc2lnbnNZW3R5cGVdLFxyXG4gICAgICAgIHN0YXRlID0gbG9jYWwkMSh0aGF0KSxcclxuICAgICAgICBleHRlbnQgPSBzdGF0ZS5leHRlbnQsXHJcbiAgICAgICAgc2VsZWN0aW9uJCQxID0gc3RhdGUuc2VsZWN0aW9uLFxyXG4gICAgICAgIFcgPSBleHRlbnRbMF1bMF0sIHcwLCB3MSxcclxuICAgICAgICBOID0gZXh0ZW50WzBdWzFdLCBuMCwgbjEsXHJcbiAgICAgICAgRSA9IGV4dGVudFsxXVswXSwgZTAsIGUxLFxyXG4gICAgICAgIFMgPSBleHRlbnRbMV1bMV0sIHMwLCBzMSxcclxuICAgICAgICBkeCxcclxuICAgICAgICBkeSxcclxuICAgICAgICBtb3ZpbmcsXHJcbiAgICAgICAgc2hpZnRpbmcgPSBzaWduWCAmJiBzaWduWSAmJiBkMy5ldmVudC5zaGlmdEtleSxcclxuICAgICAgICBsb2NrWCxcclxuICAgICAgICBsb2NrWSxcclxuICAgICAgICBwb2ludDAgPSBtb3VzZSh0aGF0KSxcclxuICAgICAgICBwb2ludCQkMSA9IHBvaW50MCxcclxuICAgICAgICBlbWl0ID0gZW1pdHRlcih0aGF0LCBhcmd1bWVudHMpLmJlZm9yZXN0YXJ0KCk7XHJcblxyXG4gICAgaWYgKHR5cGUgPT09IFwib3ZlcmxheVwiKSB7XHJcbiAgICAgIHN0YXRlLnNlbGVjdGlvbiA9IHNlbGVjdGlvbiQkMSA9IFtcclxuICAgICAgICBbdzAgPSBkaW0gPT09IFkgPyBXIDogcG9pbnQwWzBdLCBuMCA9IGRpbSA9PT0gWCA/IE4gOiBwb2ludDBbMV1dLFxyXG4gICAgICAgIFtlMCA9IGRpbSA9PT0gWSA/IEUgOiB3MCwgczAgPSBkaW0gPT09IFggPyBTIDogbjBdXHJcbiAgICAgIF07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB3MCA9IHNlbGVjdGlvbiQkMVswXVswXTtcclxuICAgICAgbjAgPSBzZWxlY3Rpb24kJDFbMF1bMV07XHJcbiAgICAgIGUwID0gc2VsZWN0aW9uJCQxWzFdWzBdO1xyXG4gICAgICBzMCA9IHNlbGVjdGlvbiQkMVsxXVsxXTtcclxuICAgIH1cclxuXHJcbiAgICB3MSA9IHcwO1xyXG4gICAgbjEgPSBuMDtcclxuICAgIGUxID0gZTA7XHJcbiAgICBzMSA9IHMwO1xyXG5cclxuICAgIHZhciBncm91cCA9IHNlbGVjdCh0aGF0KVxyXG4gICAgICAgIC5hdHRyKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpO1xyXG5cclxuICAgIHZhciBvdmVybGF5ID0gZ3JvdXAuc2VsZWN0QWxsKFwiLm92ZXJsYXlcIilcclxuICAgICAgICAuYXR0cihcImN1cnNvclwiLCBjdXJzb3JzW3R5cGVdKTtcclxuXHJcbiAgICBpZiAoZDMuZXZlbnQudG91Y2hlcykge1xyXG4gICAgICBncm91cFxyXG4gICAgICAgICAgLm9uKFwidG91Y2htb3ZlLmJydXNoXCIsIG1vdmVkLCB0cnVlKVxyXG4gICAgICAgICAgLm9uKFwidG91Y2hlbmQuYnJ1c2ggdG91Y2hjYW5jZWwuYnJ1c2hcIiwgZW5kZWQsIHRydWUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFyIHZpZXcgPSBzZWxlY3QoZDMuZXZlbnQudmlldylcclxuICAgICAgICAgIC5vbihcImtleWRvd24uYnJ1c2hcIiwga2V5ZG93bmVkLCB0cnVlKVxyXG4gICAgICAgICAgLm9uKFwia2V5dXAuYnJ1c2hcIiwga2V5dXBwZWQsIHRydWUpXHJcbiAgICAgICAgICAub24oXCJtb3VzZW1vdmUuYnJ1c2hcIiwgbW92ZWQsIHRydWUpXHJcbiAgICAgICAgICAub24oXCJtb3VzZXVwLmJydXNoXCIsIGVuZGVkLCB0cnVlKTtcclxuXHJcbiAgICAgIGRyYWdEaXNhYmxlKGQzLmV2ZW50LnZpZXcpO1xyXG4gICAgfVxyXG5cclxuICAgIG5vcHJvcGFnYXRpb24kMSgpO1xyXG4gICAgaW50ZXJydXB0KHRoYXQpO1xyXG4gICAgcmVkcmF3LmNhbGwodGhhdCk7XHJcbiAgICBlbWl0LnN0YXJ0KCk7XHJcblxyXG4gICAgZnVuY3Rpb24gbW92ZWQoKSB7XHJcbiAgICAgIHZhciBwb2ludDEgPSBtb3VzZSh0aGF0KTtcclxuICAgICAgaWYgKHNoaWZ0aW5nICYmICFsb2NrWCAmJiAhbG9ja1kpIHtcclxuICAgICAgICBpZiAoTWF0aC5hYnMocG9pbnQxWzBdIC0gcG9pbnQkJDFbMF0pID4gTWF0aC5hYnMocG9pbnQxWzFdIC0gcG9pbnQkJDFbMV0pKSBsb2NrWSA9IHRydWU7XHJcbiAgICAgICAgZWxzZSBsb2NrWCA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgcG9pbnQkJDEgPSBwb2ludDE7XHJcbiAgICAgIG1vdmluZyA9IHRydWU7XHJcbiAgICAgIG5vZXZlbnQkMSgpO1xyXG4gICAgICBtb3ZlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbW92ZSgpIHtcclxuICAgICAgdmFyIHQ7XHJcblxyXG4gICAgICBkeCA9IHBvaW50JCQxWzBdIC0gcG9pbnQwWzBdO1xyXG4gICAgICBkeSA9IHBvaW50JCQxWzFdIC0gcG9pbnQwWzFdO1xyXG5cclxuICAgICAgc3dpdGNoIChtb2RlKSB7XHJcbiAgICAgICAgY2FzZSBNT0RFX1NQQUNFOlxyXG4gICAgICAgIGNhc2UgTU9ERV9EUkFHOiB7XHJcbiAgICAgICAgICBpZiAoc2lnblgpIGR4ID0gTWF0aC5tYXgoVyAtIHcwLCBNYXRoLm1pbihFIC0gZTAsIGR4KSksIHcxID0gdzAgKyBkeCwgZTEgPSBlMCArIGR4O1xyXG4gICAgICAgICAgaWYgKHNpZ25ZKSBkeSA9IE1hdGgubWF4KE4gLSBuMCwgTWF0aC5taW4oUyAtIHMwLCBkeSkpLCBuMSA9IG4wICsgZHksIHMxID0gczAgKyBkeTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIE1PREVfSEFORExFOiB7XHJcbiAgICAgICAgICBpZiAoc2lnblggPCAwKSBkeCA9IE1hdGgubWF4KFcgLSB3MCwgTWF0aC5taW4oRSAtIHcwLCBkeCkpLCB3MSA9IHcwICsgZHgsIGUxID0gZTA7XHJcbiAgICAgICAgICBlbHNlIGlmIChzaWduWCA+IDApIGR4ID0gTWF0aC5tYXgoVyAtIGUwLCBNYXRoLm1pbihFIC0gZTAsIGR4KSksIHcxID0gdzAsIGUxID0gZTAgKyBkeDtcclxuICAgICAgICAgIGlmIChzaWduWSA8IDApIGR5ID0gTWF0aC5tYXgoTiAtIG4wLCBNYXRoLm1pbihTIC0gbjAsIGR5KSksIG4xID0gbjAgKyBkeSwgczEgPSBzMDtcclxuICAgICAgICAgIGVsc2UgaWYgKHNpZ25ZID4gMCkgZHkgPSBNYXRoLm1heChOIC0gczAsIE1hdGgubWluKFMgLSBzMCwgZHkpKSwgbjEgPSBuMCwgczEgPSBzMCArIGR5O1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgTU9ERV9DRU5URVI6IHtcclxuICAgICAgICAgIGlmIChzaWduWCkgdzEgPSBNYXRoLm1heChXLCBNYXRoLm1pbihFLCB3MCAtIGR4ICogc2lnblgpKSwgZTEgPSBNYXRoLm1heChXLCBNYXRoLm1pbihFLCBlMCArIGR4ICogc2lnblgpKTtcclxuICAgICAgICAgIGlmIChzaWduWSkgbjEgPSBNYXRoLm1heChOLCBNYXRoLm1pbihTLCBuMCAtIGR5ICogc2lnblkpKSwgczEgPSBNYXRoLm1heChOLCBNYXRoLm1pbihTLCBzMCArIGR5ICogc2lnblkpKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGUxIDwgdzEpIHtcclxuICAgICAgICBzaWduWCAqPSAtMTtcclxuICAgICAgICB0ID0gdzAsIHcwID0gZTAsIGUwID0gdDtcclxuICAgICAgICB0ID0gdzEsIHcxID0gZTEsIGUxID0gdDtcclxuICAgICAgICBpZiAodHlwZSBpbiBmbGlwWCkgb3ZlcmxheS5hdHRyKFwiY3Vyc29yXCIsIGN1cnNvcnNbdHlwZSA9IGZsaXBYW3R5cGVdXSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChzMSA8IG4xKSB7XHJcbiAgICAgICAgc2lnblkgKj0gLTE7XHJcbiAgICAgICAgdCA9IG4wLCBuMCA9IHMwLCBzMCA9IHQ7XHJcbiAgICAgICAgdCA9IG4xLCBuMSA9IHMxLCBzMSA9IHQ7XHJcbiAgICAgICAgaWYgKHR5cGUgaW4gZmxpcFkpIG92ZXJsYXkuYXR0cihcImN1cnNvclwiLCBjdXJzb3JzW3R5cGUgPSBmbGlwWVt0eXBlXV0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoc3RhdGUuc2VsZWN0aW9uKSBzZWxlY3Rpb24kJDEgPSBzdGF0ZS5zZWxlY3Rpb247IC8vIE1heSBiZSBzZXQgYnkgYnJ1c2gubW92ZSFcclxuICAgICAgaWYgKGxvY2tYKSB3MSA9IHNlbGVjdGlvbiQkMVswXVswXSwgZTEgPSBzZWxlY3Rpb24kJDFbMV1bMF07XHJcbiAgICAgIGlmIChsb2NrWSkgbjEgPSBzZWxlY3Rpb24kJDFbMF1bMV0sIHMxID0gc2VsZWN0aW9uJCQxWzFdWzFdO1xyXG5cclxuICAgICAgaWYgKHNlbGVjdGlvbiQkMVswXVswXSAhPT0gdzFcclxuICAgICAgICAgIHx8IHNlbGVjdGlvbiQkMVswXVsxXSAhPT0gbjFcclxuICAgICAgICAgIHx8IHNlbGVjdGlvbiQkMVsxXVswXSAhPT0gZTFcclxuICAgICAgICAgIHx8IHNlbGVjdGlvbiQkMVsxXVsxXSAhPT0gczEpIHtcclxuICAgICAgICBzdGF0ZS5zZWxlY3Rpb24gPSBbW3cxLCBuMV0sIFtlMSwgczFdXTtcclxuICAgICAgICByZWRyYXcuY2FsbCh0aGF0KTtcclxuICAgICAgICBlbWl0LmJydXNoKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBlbmRlZCgpIHtcclxuICAgICAgbm9wcm9wYWdhdGlvbiQxKCk7XHJcbiAgICAgIGlmIChkMy5ldmVudC50b3VjaGVzKSB7XHJcbiAgICAgICAgaWYgKGQzLmV2ZW50LnRvdWNoZXMubGVuZ3RoKSByZXR1cm47XHJcbiAgICAgICAgaWYgKHRvdWNoZW5kaW5nKSBjbGVhclRpbWVvdXQodG91Y2hlbmRpbmcpO1xyXG4gICAgICAgIHRvdWNoZW5kaW5nID0gc2V0VGltZW91dChmdW5jdGlvbigpIHsgdG91Y2hlbmRpbmcgPSBudWxsOyB9LCA1MDApOyAvLyBHaG9zdCBjbGlja3MgYXJlIGRlbGF5ZWQhXHJcbiAgICAgICAgZ3JvdXAub24oXCJ0b3VjaG1vdmUuYnJ1c2ggdG91Y2hlbmQuYnJ1c2ggdG91Y2hjYW5jZWwuYnJ1c2hcIiwgbnVsbCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgeWVzZHJhZyhkMy5ldmVudC52aWV3LCBtb3ZpbmcpO1xyXG4gICAgICAgIHZpZXcub24oXCJrZXlkb3duLmJydXNoIGtleXVwLmJydXNoIG1vdXNlbW92ZS5icnVzaCBtb3VzZXVwLmJydXNoXCIsIG51bGwpO1xyXG4gICAgICB9XHJcbiAgICAgIGdyb3VwLmF0dHIoXCJwb2ludGVyLWV2ZW50c1wiLCBcImFsbFwiKTtcclxuICAgICAgb3ZlcmxheS5hdHRyKFwiY3Vyc29yXCIsIGN1cnNvcnMub3ZlcmxheSk7XHJcbiAgICAgIGlmIChzdGF0ZS5zZWxlY3Rpb24pIHNlbGVjdGlvbiQkMSA9IHN0YXRlLnNlbGVjdGlvbjsgLy8gTWF5IGJlIHNldCBieSBicnVzaC5tb3ZlIChvbiBzdGFydCkhXHJcbiAgICAgIGlmIChlbXB0eSQxKHNlbGVjdGlvbiQkMSkpIHN0YXRlLnNlbGVjdGlvbiA9IG51bGwsIHJlZHJhdy5jYWxsKHRoYXQpO1xyXG4gICAgICBlbWl0LmVuZCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGtleWRvd25lZCgpIHtcclxuICAgICAgc3dpdGNoIChkMy5ldmVudC5rZXlDb2RlKSB7XHJcbiAgICAgICAgY2FzZSAxNjogeyAvLyBTSElGVFxyXG4gICAgICAgICAgc2hpZnRpbmcgPSBzaWduWCAmJiBzaWduWTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIDE4OiB7IC8vIEFMVFxyXG4gICAgICAgICAgaWYgKG1vZGUgPT09IE1PREVfSEFORExFKSB7XHJcbiAgICAgICAgICAgIGlmIChzaWduWCkgZTAgPSBlMSAtIGR4ICogc2lnblgsIHcwID0gdzEgKyBkeCAqIHNpZ25YO1xyXG4gICAgICAgICAgICBpZiAoc2lnblkpIHMwID0gczEgLSBkeSAqIHNpZ25ZLCBuMCA9IG4xICsgZHkgKiBzaWduWTtcclxuICAgICAgICAgICAgbW9kZSA9IE1PREVfQ0VOVEVSO1xyXG4gICAgICAgICAgICBtb3ZlKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSAzMjogeyAvLyBTUEFDRTsgdGFrZXMgcHJpb3JpdHkgb3ZlciBBTFRcclxuICAgICAgICAgIGlmIChtb2RlID09PSBNT0RFX0hBTkRMRSB8fCBtb2RlID09PSBNT0RFX0NFTlRFUikge1xyXG4gICAgICAgICAgICBpZiAoc2lnblggPCAwKSBlMCA9IGUxIC0gZHg7IGVsc2UgaWYgKHNpZ25YID4gMCkgdzAgPSB3MSAtIGR4O1xyXG4gICAgICAgICAgICBpZiAoc2lnblkgPCAwKSBzMCA9IHMxIC0gZHk7IGVsc2UgaWYgKHNpZ25ZID4gMCkgbjAgPSBuMSAtIGR5O1xyXG4gICAgICAgICAgICBtb2RlID0gTU9ERV9TUEFDRTtcclxuICAgICAgICAgICAgb3ZlcmxheS5hdHRyKFwiY3Vyc29yXCIsIGN1cnNvcnMuc2VsZWN0aW9uKTtcclxuICAgICAgICAgICAgbW92ZSgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlZmF1bHQ6IHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBub2V2ZW50JDEoKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBrZXl1cHBlZCgpIHtcclxuICAgICAgc3dpdGNoIChkMy5ldmVudC5rZXlDb2RlKSB7XHJcbiAgICAgICAgY2FzZSAxNjogeyAvLyBTSElGVFxyXG4gICAgICAgICAgaWYgKHNoaWZ0aW5nKSB7XHJcbiAgICAgICAgICAgIGxvY2tYID0gbG9ja1kgPSBzaGlmdGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICBtb3ZlKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSAxODogeyAvLyBBTFRcclxuICAgICAgICAgIGlmIChtb2RlID09PSBNT0RFX0NFTlRFUikge1xyXG4gICAgICAgICAgICBpZiAoc2lnblggPCAwKSBlMCA9IGUxOyBlbHNlIGlmIChzaWduWCA+IDApIHcwID0gdzE7XHJcbiAgICAgICAgICAgIGlmIChzaWduWSA8IDApIHMwID0gczE7IGVsc2UgaWYgKHNpZ25ZID4gMCkgbjAgPSBuMTtcclxuICAgICAgICAgICAgbW9kZSA9IE1PREVfSEFORExFO1xyXG4gICAgICAgICAgICBtb3ZlKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSAzMjogeyAvLyBTUEFDRVxyXG4gICAgICAgICAgaWYgKG1vZGUgPT09IE1PREVfU1BBQ0UpIHtcclxuICAgICAgICAgICAgaWYgKGQzLmV2ZW50LmFsdEtleSkge1xyXG4gICAgICAgICAgICAgIGlmIChzaWduWCkgZTAgPSBlMSAtIGR4ICogc2lnblgsIHcwID0gdzEgKyBkeCAqIHNpZ25YO1xyXG4gICAgICAgICAgICAgIGlmIChzaWduWSkgczAgPSBzMSAtIGR5ICogc2lnblksIG4wID0gbjEgKyBkeSAqIHNpZ25ZO1xyXG4gICAgICAgICAgICAgIG1vZGUgPSBNT0RFX0NFTlRFUjtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBpZiAoc2lnblggPCAwKSBlMCA9IGUxOyBlbHNlIGlmIChzaWduWCA+IDApIHcwID0gdzE7XHJcbiAgICAgICAgICAgICAgaWYgKHNpZ25ZIDwgMCkgczAgPSBzMTsgZWxzZSBpZiAoc2lnblkgPiAwKSBuMCA9IG4xO1xyXG4gICAgICAgICAgICAgIG1vZGUgPSBNT0RFX0hBTkRMRTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvdmVybGF5LmF0dHIoXCJjdXJzb3JcIiwgY3Vyc29yc1t0eXBlXSk7XHJcbiAgICAgICAgICAgIG1vdmUoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWZhdWx0OiByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgbm9ldmVudCQxKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xyXG4gICAgdmFyIHN0YXRlID0gdGhpcy5fX2JydXNoIHx8IHtzZWxlY3Rpb246IG51bGx9O1xyXG4gICAgc3RhdGUuZXh0ZW50ID0gZXh0ZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICBzdGF0ZS5kaW0gPSBkaW07XHJcbiAgICByZXR1cm4gc3RhdGU7XHJcbiAgfVxyXG5cclxuICBicnVzaC5leHRlbnQgPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChleHRlbnQgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50JDQoW1srX1swXVswXSwgK19bMF1bMV1dLCBbK19bMV1bMF0sICtfWzFdWzFdXV0pLCBicnVzaCkgOiBleHRlbnQ7XHJcbiAgfTtcclxuXHJcbiAgYnJ1c2guZmlsdGVyID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZmlsdGVyID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCQ0KCEhXyksIGJydXNoKSA6IGZpbHRlcjtcclxuICB9O1xyXG5cclxuICBicnVzaC5oYW5kbGVTaXplID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaGFuZGxlU2l6ZSA9ICtfLCBicnVzaCkgOiBoYW5kbGVTaXplO1xyXG4gIH07XHJcblxyXG4gIGJydXNoLm9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgdmFsdWUgPSBsaXN0ZW5lcnMub24uYXBwbHkobGlzdGVuZXJzLCBhcmd1bWVudHMpO1xyXG4gICAgcmV0dXJuIHZhbHVlID09PSBsaXN0ZW5lcnMgPyBicnVzaCA6IHZhbHVlO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBicnVzaDtcclxufVxyXG5cclxudmFyIGNvcyA9IE1hdGguY29zO1xyXG52YXIgc2luID0gTWF0aC5zaW47XHJcbnZhciBwaSQxID0gTWF0aC5QSTtcclxudmFyIGhhbGZQaSQxID0gcGkkMSAvIDI7XHJcbnZhciB0YXUkMSA9IHBpJDEgKiAyO1xyXG52YXIgbWF4JDEgPSBNYXRoLm1heDtcclxuXHJcbmZ1bmN0aW9uIGNvbXBhcmVWYWx1ZShjb21wYXJlKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgIHJldHVybiBjb21wYXJlKFxyXG4gICAgICBhLnNvdXJjZS52YWx1ZSArIGEudGFyZ2V0LnZhbHVlLFxyXG4gICAgICBiLnNvdXJjZS52YWx1ZSArIGIudGFyZ2V0LnZhbHVlXHJcbiAgICApO1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNob3JkKCkge1xyXG4gIHZhciBwYWRBbmdsZSA9IDAsXHJcbiAgICAgIHNvcnRHcm91cHMgPSBudWxsLFxyXG4gICAgICBzb3J0U3ViZ3JvdXBzID0gbnVsbCxcclxuICAgICAgc29ydENob3JkcyA9IG51bGw7XHJcblxyXG4gIGZ1bmN0aW9uIGNob3JkKG1hdHJpeCkge1xyXG4gICAgdmFyIG4gPSBtYXRyaXgubGVuZ3RoLFxyXG4gICAgICAgIGdyb3VwU3VtcyA9IFtdLFxyXG4gICAgICAgIGdyb3VwSW5kZXggPSBzZXF1ZW5jZShuKSxcclxuICAgICAgICBzdWJncm91cEluZGV4ID0gW10sXHJcbiAgICAgICAgY2hvcmRzID0gW10sXHJcbiAgICAgICAgZ3JvdXBzID0gY2hvcmRzLmdyb3VwcyA9IG5ldyBBcnJheShuKSxcclxuICAgICAgICBzdWJncm91cHMgPSBuZXcgQXJyYXkobiAqIG4pLFxyXG4gICAgICAgIGssXHJcbiAgICAgICAgeCxcclxuICAgICAgICB4MCxcclxuICAgICAgICBkeCxcclxuICAgICAgICBpLFxyXG4gICAgICAgIGo7XHJcblxyXG4gICAgLy8gQ29tcHV0ZSB0aGUgc3VtLlxyXG4gICAgayA9IDAsIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHtcclxuICAgICAgeCA9IDAsIGogPSAtMTsgd2hpbGUgKCsraiA8IG4pIHtcclxuICAgICAgICB4ICs9IG1hdHJpeFtpXVtqXTtcclxuICAgICAgfVxyXG4gICAgICBncm91cFN1bXMucHVzaCh4KTtcclxuICAgICAgc3ViZ3JvdXBJbmRleC5wdXNoKHNlcXVlbmNlKG4pKTtcclxuICAgICAgayArPSB4O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNvcnQgZ3JvdXBz4oCmXHJcbiAgICBpZiAoc29ydEdyb3VwcykgZ3JvdXBJbmRleC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgICAgcmV0dXJuIHNvcnRHcm91cHMoZ3JvdXBTdW1zW2FdLCBncm91cFN1bXNbYl0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gU29ydCBzdWJncm91cHPigKZcclxuICAgIGlmIChzb3J0U3ViZ3JvdXBzKSBzdWJncm91cEluZGV4LmZvckVhY2goZnVuY3Rpb24oZCwgaSkge1xyXG4gICAgICBkLnNvcnQoZnVuY3Rpb24oYSwgYikge1xyXG4gICAgICAgIHJldHVybiBzb3J0U3ViZ3JvdXBzKG1hdHJpeFtpXVthXSwgbWF0cml4W2ldW2JdKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBDb252ZXJ0IHRoZSBzdW0gdG8gc2NhbGluZyBmYWN0b3IgZm9yIFswLCAycGldLlxyXG4gICAgLy8gVE9ETyBBbGxvdyBzdGFydCBhbmQgZW5kIGFuZ2xlIHRvIGJlIHNwZWNpZmllZD9cclxuICAgIC8vIFRPRE8gQWxsb3cgcGFkZGluZyB0byBiZSBzcGVjaWZpZWQgYXMgcGVyY2VudGFnZT9cclxuICAgIGsgPSBtYXgkMSgwLCB0YXUkMSAtIHBhZEFuZ2xlICogbikgLyBrO1xyXG4gICAgZHggPSBrID8gcGFkQW5nbGUgOiB0YXUkMSAvIG47XHJcblxyXG4gICAgLy8gQ29tcHV0ZSB0aGUgc3RhcnQgYW5kIGVuZCBhbmdsZSBmb3IgZWFjaCBncm91cCBhbmQgc3ViZ3JvdXAuXHJcbiAgICAvLyBOb3RlOiBPcGVyYSBoYXMgYSBidWcgcmVvcmRlcmluZyBvYmplY3QgbGl0ZXJhbCBwcm9wZXJ0aWVzIVxyXG4gICAgeCA9IDAsIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHtcclxuICAgICAgeDAgPSB4LCBqID0gLTE7IHdoaWxlICgrK2ogPCBuKSB7XHJcbiAgICAgICAgdmFyIGRpID0gZ3JvdXBJbmRleFtpXSxcclxuICAgICAgICAgICAgZGogPSBzdWJncm91cEluZGV4W2RpXVtqXSxcclxuICAgICAgICAgICAgdiA9IG1hdHJpeFtkaV1bZGpdLFxyXG4gICAgICAgICAgICBhMCA9IHgsXHJcbiAgICAgICAgICAgIGExID0geCArPSB2ICogaztcclxuICAgICAgICBzdWJncm91cHNbZGogKiBuICsgZGldID0ge1xyXG4gICAgICAgICAgaW5kZXg6IGRpLFxyXG4gICAgICAgICAgc3ViaW5kZXg6IGRqLFxyXG4gICAgICAgICAgc3RhcnRBbmdsZTogYTAsXHJcbiAgICAgICAgICBlbmRBbmdsZTogYTEsXHJcbiAgICAgICAgICB2YWx1ZTogdlxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgICAgZ3JvdXBzW2RpXSA9IHtcclxuICAgICAgICBpbmRleDogZGksXHJcbiAgICAgICAgc3RhcnRBbmdsZTogeDAsXHJcbiAgICAgICAgZW5kQW5nbGU6IHgsXHJcbiAgICAgICAgdmFsdWU6IGdyb3VwU3Vtc1tkaV1cclxuICAgICAgfTtcclxuICAgICAgeCArPSBkeDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBHZW5lcmF0ZSBjaG9yZHMgZm9yIGVhY2ggKG5vbi1lbXB0eSkgc3ViZ3JvdXAtc3ViZ3JvdXAgbGluay5cclxuICAgIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHtcclxuICAgICAgaiA9IGkgLSAxOyB3aGlsZSAoKytqIDwgbikge1xyXG4gICAgICAgIHZhciBzb3VyY2UgPSBzdWJncm91cHNbaiAqIG4gKyBpXSxcclxuICAgICAgICAgICAgdGFyZ2V0ID0gc3ViZ3JvdXBzW2kgKiBuICsgal07XHJcbiAgICAgICAgaWYgKHNvdXJjZS52YWx1ZSB8fCB0YXJnZXQudmFsdWUpIHtcclxuICAgICAgICAgIGNob3Jkcy5wdXNoKHNvdXJjZS52YWx1ZSA8IHRhcmdldC52YWx1ZVxyXG4gICAgICAgICAgICAgID8ge3NvdXJjZTogdGFyZ2V0LCB0YXJnZXQ6IHNvdXJjZX1cclxuICAgICAgICAgICAgICA6IHtzb3VyY2U6IHNvdXJjZSwgdGFyZ2V0OiB0YXJnZXR9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc29ydENob3JkcyA/IGNob3Jkcy5zb3J0KHNvcnRDaG9yZHMpIDogY2hvcmRzO1xyXG4gIH1cclxuXHJcbiAgY2hvcmQucGFkQW5nbGUgPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRBbmdsZSA9IG1heCQxKDAsIF8pLCBjaG9yZCkgOiBwYWRBbmdsZTtcclxuICB9O1xyXG5cclxuICBjaG9yZC5zb3J0R3JvdXBzID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc29ydEdyb3VwcyA9IF8sIGNob3JkKSA6IHNvcnRHcm91cHM7XHJcbiAgfTtcclxuXHJcbiAgY2hvcmQuc29ydFN1Ymdyb3VwcyA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNvcnRTdWJncm91cHMgPSBfLCBjaG9yZCkgOiBzb3J0U3ViZ3JvdXBzO1xyXG4gIH07XHJcblxyXG4gIGNob3JkLnNvcnRDaG9yZHMgPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChfID09IG51bGwgPyBzb3J0Q2hvcmRzID0gbnVsbCA6IChzb3J0Q2hvcmRzID0gY29tcGFyZVZhbHVlKF8pKS5fID0gXywgY2hvcmQpIDogc29ydENob3JkcyAmJiBzb3J0Q2hvcmRzLl87XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIGNob3JkO1xyXG59XHJcblxyXG52YXIgc2xpY2UkMiA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcclxuXHJcbmZ1bmN0aW9uIGNvbnN0YW50JDUoeCkge1xyXG4gIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB4O1xyXG4gIH07XHJcbn1cclxuXHJcbnZhciBwaSQyID0gTWF0aC5QSSxcclxuICAgIHRhdSQyID0gMiAqIHBpJDIsXHJcbiAgICBlcHNpbG9uJDEgPSAxZS02LFxyXG4gICAgdGF1RXBzaWxvbiA9IHRhdSQyIC0gZXBzaWxvbiQxO1xyXG5cclxuZnVuY3Rpb24gUGF0aCgpIHtcclxuICB0aGlzLl94MCA9IHRoaXMuX3kwID0gLy8gc3RhcnQgb2YgY3VycmVudCBzdWJwYXRoXHJcbiAgdGhpcy5feDEgPSB0aGlzLl95MSA9IG51bGw7IC8vIGVuZCBvZiBjdXJyZW50IHN1YnBhdGhcclxuICB0aGlzLl8gPSBcIlwiO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYXRoKCkge1xyXG4gIHJldHVybiBuZXcgUGF0aDtcclxufVxyXG5cclxuUGF0aC5wcm90b3R5cGUgPSBwYXRoLnByb3RvdHlwZSA9IHtcclxuICBjb25zdHJ1Y3RvcjogUGF0aCxcclxuICBtb3ZlVG86IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgIHRoaXMuXyArPSBcIk1cIiArICh0aGlzLl94MCA9IHRoaXMuX3gxID0gK3gpICsgXCIsXCIgKyAodGhpcy5feTAgPSB0aGlzLl95MSA9ICt5KTtcclxuICB9LFxyXG4gIGNsb3NlUGF0aDogZnVuY3Rpb24oKSB7XHJcbiAgICBpZiAodGhpcy5feDEgIT09IG51bGwpIHtcclxuICAgICAgdGhpcy5feDEgPSB0aGlzLl94MCwgdGhpcy5feTEgPSB0aGlzLl95MDtcclxuICAgICAgdGhpcy5fICs9IFwiWlwiO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgbGluZVRvOiBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICB0aGlzLl8gKz0gXCJMXCIgKyAodGhpcy5feDEgPSAreCkgKyBcIixcIiArICh0aGlzLl95MSA9ICt5KTtcclxuICB9LFxyXG4gIHF1YWRyYXRpY0N1cnZlVG86IGZ1bmN0aW9uKHgxLCB5MSwgeCwgeSkge1xyXG4gICAgdGhpcy5fICs9IFwiUVwiICsgKCt4MSkgKyBcIixcIiArICgreTEpICsgXCIsXCIgKyAodGhpcy5feDEgPSAreCkgKyBcIixcIiArICh0aGlzLl95MSA9ICt5KTtcclxuICB9LFxyXG4gIGJlemllckN1cnZlVG86IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCB4LCB5KSB7XHJcbiAgICB0aGlzLl8gKz0gXCJDXCIgKyAoK3gxKSArIFwiLFwiICsgKCt5MSkgKyBcIixcIiArICgreDIpICsgXCIsXCIgKyAoK3kyKSArIFwiLFwiICsgKHRoaXMuX3gxID0gK3gpICsgXCIsXCIgKyAodGhpcy5feTEgPSAreSk7XHJcbiAgfSxcclxuICBhcmNUbzogZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIsIHIpIHtcclxuICAgIHgxID0gK3gxLCB5MSA9ICt5MSwgeDIgPSAreDIsIHkyID0gK3kyLCByID0gK3I7XHJcbiAgICB2YXIgeDAgPSB0aGlzLl94MSxcclxuICAgICAgICB5MCA9IHRoaXMuX3kxLFxyXG4gICAgICAgIHgyMSA9IHgyIC0geDEsXHJcbiAgICAgICAgeTIxID0geTIgLSB5MSxcclxuICAgICAgICB4MDEgPSB4MCAtIHgxLFxyXG4gICAgICAgIHkwMSA9IHkwIC0geTEsXHJcbiAgICAgICAgbDAxXzIgPSB4MDEgKiB4MDEgKyB5MDEgKiB5MDE7XHJcblxyXG4gICAgLy8gSXMgdGhlIHJhZGl1cyBuZWdhdGl2ZT8gRXJyb3IuXHJcbiAgICBpZiAociA8IDApIHRocm93IG5ldyBFcnJvcihcIm5lZ2F0aXZlIHJhZGl1czogXCIgKyByKTtcclxuXHJcbiAgICAvLyBJcyB0aGlzIHBhdGggZW1wdHk/IE1vdmUgdG8gKHgxLHkxKS5cclxuICAgIGlmICh0aGlzLl94MSA9PT0gbnVsbCkge1xyXG4gICAgICB0aGlzLl8gKz0gXCJNXCIgKyAodGhpcy5feDEgPSB4MSkgKyBcIixcIiArICh0aGlzLl95MSA9IHkxKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBPciwgaXMgKHgxLHkxKSBjb2luY2lkZW50IHdpdGggKHgwLHkwKT8gRG8gbm90aGluZy5cclxuICAgIGVsc2UgaWYgKCEobDAxXzIgPiBlcHNpbG9uJDEpKSB7fVxyXG5cclxuICAgIC8vIE9yLCBhcmUgKHgwLHkwKSwgKHgxLHkxKSBhbmQgKHgyLHkyKSBjb2xsaW5lYXI/XHJcbiAgICAvLyBFcXVpdmFsZW50bHksIGlzICh4MSx5MSkgY29pbmNpZGVudCB3aXRoICh4Mix5Mik/XHJcbiAgICAvLyBPciwgaXMgdGhlIHJhZGl1cyB6ZXJvPyBMaW5lIHRvICh4MSx5MSkuXHJcbiAgICBlbHNlIGlmICghKE1hdGguYWJzKHkwMSAqIHgyMSAtIHkyMSAqIHgwMSkgPiBlcHNpbG9uJDEpIHx8ICFyKSB7XHJcbiAgICAgIHRoaXMuXyArPSBcIkxcIiArICh0aGlzLl94MSA9IHgxKSArIFwiLFwiICsgKHRoaXMuX3kxID0geTEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE90aGVyd2lzZSwgZHJhdyBhbiBhcmMhXHJcbiAgICBlbHNlIHtcclxuICAgICAgdmFyIHgyMCA9IHgyIC0geDAsXHJcbiAgICAgICAgICB5MjAgPSB5MiAtIHkwLFxyXG4gICAgICAgICAgbDIxXzIgPSB4MjEgKiB4MjEgKyB5MjEgKiB5MjEsXHJcbiAgICAgICAgICBsMjBfMiA9IHgyMCAqIHgyMCArIHkyMCAqIHkyMCxcclxuICAgICAgICAgIGwyMSA9IE1hdGguc3FydChsMjFfMiksXHJcbiAgICAgICAgICBsMDEgPSBNYXRoLnNxcnQobDAxXzIpLFxyXG4gICAgICAgICAgbCA9IHIgKiBNYXRoLnRhbigocGkkMiAtIE1hdGguYWNvcygobDIxXzIgKyBsMDFfMiAtIGwyMF8yKSAvICgyICogbDIxICogbDAxKSkpIC8gMiksXHJcbiAgICAgICAgICB0MDEgPSBsIC8gbDAxLFxyXG4gICAgICAgICAgdDIxID0gbCAvIGwyMTtcclxuXHJcbiAgICAgIC8vIElmIHRoZSBzdGFydCB0YW5nZW50IGlzIG5vdCBjb2luY2lkZW50IHdpdGggKHgwLHkwKSwgbGluZSB0by5cclxuICAgICAgaWYgKE1hdGguYWJzKHQwMSAtIDEpID4gZXBzaWxvbiQxKSB7XHJcbiAgICAgICAgdGhpcy5fICs9IFwiTFwiICsgKHgxICsgdDAxICogeDAxKSArIFwiLFwiICsgKHkxICsgdDAxICogeTAxKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5fICs9IFwiQVwiICsgciArIFwiLFwiICsgciArIFwiLDAsMCxcIiArICgrKHkwMSAqIHgyMCA+IHgwMSAqIHkyMCkpICsgXCIsXCIgKyAodGhpcy5feDEgPSB4MSArIHQyMSAqIHgyMSkgKyBcIixcIiArICh0aGlzLl95MSA9IHkxICsgdDIxICogeTIxKTtcclxuICAgIH1cclxuICB9LFxyXG4gIGFyYzogZnVuY3Rpb24oeCwgeSwgciwgYTAsIGExLCBjY3cpIHtcclxuICAgIHggPSAreCwgeSA9ICt5LCByID0gK3I7XHJcbiAgICB2YXIgZHggPSByICogTWF0aC5jb3MoYTApLFxyXG4gICAgICAgIGR5ID0gciAqIE1hdGguc2luKGEwKSxcclxuICAgICAgICB4MCA9IHggKyBkeCxcclxuICAgICAgICB5MCA9IHkgKyBkeSxcclxuICAgICAgICBjdyA9IDEgXiBjY3csXHJcbiAgICAgICAgZGEgPSBjY3cgPyBhMCAtIGExIDogYTEgLSBhMDtcclxuXHJcbiAgICAvLyBJcyB0aGUgcmFkaXVzIG5lZ2F0aXZlPyBFcnJvci5cclxuICAgIGlmIChyIDwgMCkgdGhyb3cgbmV3IEVycm9yKFwibmVnYXRpdmUgcmFkaXVzOiBcIiArIHIpO1xyXG5cclxuICAgIC8vIElzIHRoaXMgcGF0aCBlbXB0eT8gTW92ZSB0byAoeDAseTApLlxyXG4gICAgaWYgKHRoaXMuX3gxID09PSBudWxsKSB7XHJcbiAgICAgIHRoaXMuXyArPSBcIk1cIiArIHgwICsgXCIsXCIgKyB5MDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBPciwgaXMgKHgwLHkwKSBub3QgY29pbmNpZGVudCB3aXRoIHRoZSBwcmV2aW91cyBwb2ludD8gTGluZSB0byAoeDAseTApLlxyXG4gICAgZWxzZSBpZiAoTWF0aC5hYnModGhpcy5feDEgLSB4MCkgPiBlcHNpbG9uJDEgfHwgTWF0aC5hYnModGhpcy5feTEgLSB5MCkgPiBlcHNpbG9uJDEpIHtcclxuICAgICAgdGhpcy5fICs9IFwiTFwiICsgeDAgKyBcIixcIiArIHkwO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIElzIHRoaXMgYXJjIGVtcHR5PyBXZeKAmXJlIGRvbmUuXHJcbiAgICBpZiAoIXIpIHJldHVybjtcclxuXHJcbiAgICAvLyBEb2VzIHRoZSBhbmdsZSBnbyB0aGUgd3Jvbmcgd2F5PyBGbGlwIHRoZSBkaXJlY3Rpb24uXHJcbiAgICBpZiAoZGEgPCAwKSBkYSA9IGRhICUgdGF1JDIgKyB0YXUkMjtcclxuXHJcbiAgICAvLyBJcyB0aGlzIGEgY29tcGxldGUgY2lyY2xlPyBEcmF3IHR3byBhcmNzIHRvIGNvbXBsZXRlIHRoZSBjaXJjbGUuXHJcbiAgICBpZiAoZGEgPiB0YXVFcHNpbG9uKSB7XHJcbiAgICAgIHRoaXMuXyArPSBcIkFcIiArIHIgKyBcIixcIiArIHIgKyBcIiwwLDEsXCIgKyBjdyArIFwiLFwiICsgKHggLSBkeCkgKyBcIixcIiArICh5IC0gZHkpICsgXCJBXCIgKyByICsgXCIsXCIgKyByICsgXCIsMCwxLFwiICsgY3cgKyBcIixcIiArICh0aGlzLl94MSA9IHgwKSArIFwiLFwiICsgKHRoaXMuX3kxID0geTApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIElzIHRoaXMgYXJjIG5vbi1lbXB0eT8gRHJhdyBhbiBhcmMhXHJcbiAgICBlbHNlIGlmIChkYSA+IGVwc2lsb24kMSkge1xyXG4gICAgICB0aGlzLl8gKz0gXCJBXCIgKyByICsgXCIsXCIgKyByICsgXCIsMCxcIiArICgrKGRhID49IHBpJDIpKSArIFwiLFwiICsgY3cgKyBcIixcIiArICh0aGlzLl94MSA9IHggKyByICogTWF0aC5jb3MoYTEpKSArIFwiLFwiICsgKHRoaXMuX3kxID0geSArIHIgKiBNYXRoLnNpbihhMSkpO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgcmVjdDogZnVuY3Rpb24oeCwgeSwgdywgaCkge1xyXG4gICAgdGhpcy5fICs9IFwiTVwiICsgKHRoaXMuX3gwID0gdGhpcy5feDEgPSAreCkgKyBcIixcIiArICh0aGlzLl95MCA9IHRoaXMuX3kxID0gK3kpICsgXCJoXCIgKyAoK3cpICsgXCJ2XCIgKyAoK2gpICsgXCJoXCIgKyAoLXcpICsgXCJaXCI7XHJcbiAgfSxcclxuICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fO1xyXG4gIH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIGRlZmF1bHRTb3VyY2UoZCkge1xyXG4gIHJldHVybiBkLnNvdXJjZTtcclxufVxyXG5cclxuZnVuY3Rpb24gZGVmYXVsdFRhcmdldChkKSB7XHJcbiAgcmV0dXJuIGQudGFyZ2V0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBkZWZhdWx0UmFkaXVzKGQpIHtcclxuICByZXR1cm4gZC5yYWRpdXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlZmF1bHRTdGFydEFuZ2xlKGQpIHtcclxuICByZXR1cm4gZC5zdGFydEFuZ2xlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkZWZhdWx0RW5kQW5nbGUoZCkge1xyXG4gIHJldHVybiBkLmVuZEFuZ2xlO1xyXG59XHJcblxyXG5mdW5jdGlvbiByaWJib24oKSB7XHJcbiAgdmFyIHNvdXJjZSA9IGRlZmF1bHRTb3VyY2UsXHJcbiAgICAgIHRhcmdldCA9IGRlZmF1bHRUYXJnZXQsXHJcbiAgICAgIHJhZGl1cyA9IGRlZmF1bHRSYWRpdXMsXHJcbiAgICAgIHN0YXJ0QW5nbGUgPSBkZWZhdWx0U3RhcnRBbmdsZSxcclxuICAgICAgZW5kQW5nbGUgPSBkZWZhdWx0RW5kQW5nbGUsXHJcbiAgICAgIGNvbnRleHQgPSBudWxsO1xyXG5cclxuICBmdW5jdGlvbiByaWJib24oKSB7XHJcbiAgICB2YXIgYnVmZmVyLFxyXG4gICAgICAgIGFyZ3YgPSBzbGljZSQyLmNhbGwoYXJndW1lbnRzKSxcclxuICAgICAgICBzID0gc291cmNlLmFwcGx5KHRoaXMsIGFyZ3YpLFxyXG4gICAgICAgIHQgPSB0YXJnZXQuYXBwbHkodGhpcywgYXJndiksXHJcbiAgICAgICAgc3IgPSArcmFkaXVzLmFwcGx5KHRoaXMsIChhcmd2WzBdID0gcywgYXJndikpLFxyXG4gICAgICAgIHNhMCA9IHN0YXJ0QW5nbGUuYXBwbHkodGhpcywgYXJndikgLSBoYWxmUGkkMSxcclxuICAgICAgICBzYTEgPSBlbmRBbmdsZS5hcHBseSh0aGlzLCBhcmd2KSAtIGhhbGZQaSQxLFxyXG4gICAgICAgIHN4MCA9IHNyICogY29zKHNhMCksXHJcbiAgICAgICAgc3kwID0gc3IgKiBzaW4oc2EwKSxcclxuICAgICAgICB0ciA9ICtyYWRpdXMuYXBwbHkodGhpcywgKGFyZ3ZbMF0gPSB0LCBhcmd2KSksXHJcbiAgICAgICAgdGEwID0gc3RhcnRBbmdsZS5hcHBseSh0aGlzLCBhcmd2KSAtIGhhbGZQaSQxLFxyXG4gICAgICAgIHRhMSA9IGVuZEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3YpIC0gaGFsZlBpJDE7XHJcblxyXG4gICAgaWYgKCFjb250ZXh0KSBjb250ZXh0ID0gYnVmZmVyID0gcGF0aCgpO1xyXG5cclxuICAgIGNvbnRleHQubW92ZVRvKHN4MCwgc3kwKTtcclxuICAgIGNvbnRleHQuYXJjKDAsIDAsIHNyLCBzYTAsIHNhMSk7XHJcbiAgICBpZiAoc2EwICE9PSB0YTAgfHwgc2ExICE9PSB0YTEpIHsgLy8gVE9ETyBzciAhPT0gdHI/XHJcbiAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbygwLCAwLCB0ciAqIGNvcyh0YTApLCB0ciAqIHNpbih0YTApKTtcclxuICAgICAgY29udGV4dC5hcmMoMCwgMCwgdHIsIHRhMCwgdGExKTtcclxuICAgIH1cclxuICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbygwLCAwLCBzeDAsIHN5MCk7XHJcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xyXG5cclxuICAgIGlmIChidWZmZXIpIHJldHVybiBjb250ZXh0ID0gbnVsbCwgYnVmZmVyICsgXCJcIiB8fCBudWxsO1xyXG4gIH1cclxuXHJcbiAgcmliYm9uLnJhZGl1cyA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQkNSgrXyksIHJpYmJvbikgOiByYWRpdXM7XHJcbiAgfTtcclxuXHJcbiAgcmliYm9uLnN0YXJ0QW5nbGUgPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzdGFydEFuZ2xlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCQ1KCtfKSwgcmliYm9uKSA6IHN0YXJ0QW5nbGU7XHJcbiAgfTtcclxuXHJcbiAgcmliYm9uLmVuZEFuZ2xlID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZW5kQW5nbGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50JDUoK18pLCByaWJib24pIDogZW5kQW5nbGU7XHJcbiAgfTtcclxuXHJcbiAgcmliYm9uLnNvdXJjZSA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNvdXJjZSA9IF8sIHJpYmJvbikgOiBzb3VyY2U7XHJcbiAgfTtcclxuXHJcbiAgcmliYm9uLnRhcmdldCA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRhcmdldCA9IF8sIHJpYmJvbikgOiB0YXJnZXQ7XHJcbiAgfTtcclxuXHJcbiAgcmliYm9uLmNvbnRleHQgPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjb250ZXh0ID0gXyA9PSBudWxsID8gbnVsbCA6IF8sIHJpYmJvbikgOiBjb250ZXh0O1xyXG4gIH07XHJcblxyXG4gIHJldHVybiByaWJib247XHJcbn1cclxuXHJcbnZhciBwcmVmaXggPSBcIiRcIjtcclxuXHJcbmZ1bmN0aW9uIE1hcCgpIHt9XHJcblxyXG5NYXAucHJvdG90eXBlID0gbWFwJDEucHJvdG90eXBlID0ge1xyXG4gIGNvbnN0cnVjdG9yOiBNYXAsXHJcbiAgaGFzOiBmdW5jdGlvbihrZXkpIHtcclxuICAgIHJldHVybiAocHJlZml4ICsga2V5KSBpbiB0aGlzO1xyXG4gIH0sXHJcbiAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcclxuICAgIHJldHVybiB0aGlzW3ByZWZpeCArIGtleV07XHJcbiAgfSxcclxuICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcclxuICAgIHRoaXNbcHJlZml4ICsga2V5XSA9IHZhbHVlO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSxcclxuICByZW1vdmU6IGZ1bmN0aW9uKGtleSkge1xyXG4gICAgdmFyIHByb3BlcnR5ID0gcHJlZml4ICsga2V5O1xyXG4gICAgcmV0dXJuIHByb3BlcnR5IGluIHRoaXMgJiYgZGVsZXRlIHRoaXNbcHJvcGVydHldO1xyXG4gIH0sXHJcbiAgY2xlYXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gdGhpcykgaWYgKHByb3BlcnR5WzBdID09PSBwcmVmaXgpIGRlbGV0ZSB0aGlzW3Byb3BlcnR5XTtcclxuICB9LFxyXG4gIGtleXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGtleXMgPSBbXTtcclxuICAgIGZvciAodmFyIHByb3BlcnR5IGluIHRoaXMpIGlmIChwcm9wZXJ0eVswXSA9PT0gcHJlZml4KSBrZXlzLnB1c2gocHJvcGVydHkuc2xpY2UoMSkpO1xyXG4gICAgcmV0dXJuIGtleXM7XHJcbiAgfSxcclxuICB2YWx1ZXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHZhbHVlcyA9IFtdO1xyXG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gdGhpcykgaWYgKHByb3BlcnR5WzBdID09PSBwcmVmaXgpIHZhbHVlcy5wdXNoKHRoaXNbcHJvcGVydHldKTtcclxuICAgIHJldHVybiB2YWx1ZXM7XHJcbiAgfSxcclxuICBlbnRyaWVzOiBmdW5jdGlvbigpIHtcclxuICAgIHZhciBlbnRyaWVzID0gW107XHJcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiB0aGlzKSBpZiAocHJvcGVydHlbMF0gPT09IHByZWZpeCkgZW50cmllcy5wdXNoKHtrZXk6IHByb3BlcnR5LnNsaWNlKDEpLCB2YWx1ZTogdGhpc1twcm9wZXJ0eV19KTtcclxuICAgIHJldHVybiBlbnRyaWVzO1xyXG4gIH0sXHJcbiAgc2l6ZTogZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgc2l6ZSA9IDA7XHJcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiB0aGlzKSBpZiAocHJvcGVydHlbMF0gPT09IHByZWZpeCkgKytzaXplO1xyXG4gICAgcmV0dXJuIHNpemU7XHJcbiAgfSxcclxuICBlbXB0eTogZnVuY3Rpb24oKSB7XHJcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiB0aGlzKSBpZiAocHJvcGVydHlbMF0gPT09IHByZWZpeCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSxcclxuICBlYWNoOiBmdW5jdGlvbihmKSB7XHJcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiB0aGlzKSBpZiAocHJvcGVydHlbMF0gPT09IHByZWZpeCkgZih0aGlzW3Byb3BlcnR5XSwgcHJvcGVydHkuc2xpY2UoMSksIHRoaXMpO1xyXG4gIH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIG1hcCQxKG9iamVjdCwgZikge1xyXG4gIHZhciBtYXAgPSBuZXcgTWFwO1xyXG5cclxuICAvLyBDb3B5IGNvbnN0cnVjdG9yLlxyXG4gIGlmIChvYmplY3QgaW5zdGFuY2VvZiBNYXApIG9iamVjdC5lYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHsgbWFwLnNldChrZXksIHZhbHVlKTsgfSk7XHJcblxyXG4gIC8vIEluZGV4IGFycmF5IGJ5IG51bWVyaWMgaW5kZXggb3Igc3BlY2lmaWVkIGtleSBmdW5jdGlvbi5cclxuICBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcclxuICAgIHZhciBpID0gLTEsXHJcbiAgICAgICAgbiA9IG9iamVjdC5sZW5ndGgsXHJcbiAgICAgICAgbztcclxuXHJcbiAgICBpZiAoZiA9PSBudWxsKSB3aGlsZSAoKytpIDwgbikgbWFwLnNldChpLCBvYmplY3RbaV0pO1xyXG4gICAgZWxzZSB3aGlsZSAoKytpIDwgbikgbWFwLnNldChmKG8gPSBvYmplY3RbaV0sIGksIG9iamVjdCksIG8pO1xyXG4gIH1cclxuXHJcbiAgLy8gQ29udmVydCBvYmplY3QgdG8gbWFwLlxyXG4gIGVsc2UgaWYgKG9iamVjdCkgZm9yICh2YXIga2V5IGluIG9iamVjdCkgbWFwLnNldChrZXksIG9iamVjdFtrZXldKTtcclxuXHJcbiAgcmV0dXJuIG1hcDtcclxufVxyXG5cclxuZnVuY3Rpb24gbmVzdCgpIHtcclxuICB2YXIga2V5cyA9IFtdLFxyXG4gICAgICBzb3J0S2V5cyA9IFtdLFxyXG4gICAgICBzb3J0VmFsdWVzLFxyXG4gICAgICByb2xsdXAsXHJcbiAgICAgIG5lc3Q7XHJcblxyXG4gIGZ1bmN0aW9uIGFwcGx5KGFycmF5LCBkZXB0aCwgY3JlYXRlUmVzdWx0LCBzZXRSZXN1bHQpIHtcclxuICAgIGlmIChkZXB0aCA+PSBrZXlzLmxlbmd0aCkge1xyXG4gICAgICBpZiAoc29ydFZhbHVlcyAhPSBudWxsKSBhcnJheS5zb3J0KHNvcnRWYWx1ZXMpO1xyXG4gICAgICByZXR1cm4gcm9sbHVwICE9IG51bGwgPyByb2xsdXAoYXJyYXkpIDogYXJyYXk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGkgPSAtMSxcclxuICAgICAgICBuID0gYXJyYXkubGVuZ3RoLFxyXG4gICAgICAgIGtleSA9IGtleXNbZGVwdGgrK10sXHJcbiAgICAgICAga2V5VmFsdWUsXHJcbiAgICAgICAgdmFsdWUsXHJcbiAgICAgICAgdmFsdWVzQnlLZXkgPSBtYXAkMSgpLFxyXG4gICAgICAgIHZhbHVlcyxcclxuICAgICAgICByZXN1bHQgPSBjcmVhdGVSZXN1bHQoKTtcclxuXHJcbiAgICB3aGlsZSAoKytpIDwgbikge1xyXG4gICAgICBpZiAodmFsdWVzID0gdmFsdWVzQnlLZXkuZ2V0KGtleVZhbHVlID0ga2V5KHZhbHVlID0gYXJyYXlbaV0pICsgXCJcIikpIHtcclxuICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFsdWVzQnlLZXkuc2V0KGtleVZhbHVlLCBbdmFsdWVdKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhbHVlc0J5S2V5LmVhY2goZnVuY3Rpb24odmFsdWVzLCBrZXkpIHtcclxuICAgICAgc2V0UmVzdWx0KHJlc3VsdCwga2V5LCBhcHBseSh2YWx1ZXMsIGRlcHRoLCBjcmVhdGVSZXN1bHQsIHNldFJlc3VsdCkpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGVudHJpZXMobWFwLCBkZXB0aCkge1xyXG4gICAgaWYgKCsrZGVwdGggPiBrZXlzLmxlbmd0aCkgcmV0dXJuIG1hcDtcclxuICAgIHZhciBhcnJheSwgc29ydEtleSA9IHNvcnRLZXlzW2RlcHRoIC0gMV07XHJcbiAgICBpZiAocm9sbHVwICE9IG51bGwgJiYgZGVwdGggPj0ga2V5cy5sZW5ndGgpIGFycmF5ID0gbWFwLmVudHJpZXMoKTtcclxuICAgIGVsc2UgYXJyYXkgPSBbXSwgbWFwLmVhY2goZnVuY3Rpb24odiwgaykgeyBhcnJheS5wdXNoKHtrZXk6IGssIHZhbHVlczogZW50cmllcyh2LCBkZXB0aCl9KTsgfSk7XHJcbiAgICByZXR1cm4gc29ydEtleSAhPSBudWxsID8gYXJyYXkuc29ydChmdW5jdGlvbihhLCBiKSB7IHJldHVybiBzb3J0S2V5KGEua2V5LCBiLmtleSk7IH0pIDogYXJyYXk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbmVzdCA9IHtcclxuICAgIG9iamVjdDogZnVuY3Rpb24oYXJyYXkpIHsgcmV0dXJuIGFwcGx5KGFycmF5LCAwLCBjcmVhdGVPYmplY3QsIHNldE9iamVjdCk7IH0sXHJcbiAgICBtYXA6IGZ1bmN0aW9uKGFycmF5KSB7IHJldHVybiBhcHBseShhcnJheSwgMCwgY3JlYXRlTWFwLCBzZXRNYXApOyB9LFxyXG4gICAgZW50cmllczogZnVuY3Rpb24oYXJyYXkpIHsgcmV0dXJuIGVudHJpZXMoYXBwbHkoYXJyYXksIDAsIGNyZWF0ZU1hcCwgc2V0TWFwKSwgMCk7IH0sXHJcbiAgICBrZXk6IGZ1bmN0aW9uKGQpIHsga2V5cy5wdXNoKGQpOyByZXR1cm4gbmVzdDsgfSxcclxuICAgIHNvcnRLZXlzOiBmdW5jdGlvbihvcmRlcikgeyBzb3J0S2V5c1trZXlzLmxlbmd0aCAtIDFdID0gb3JkZXI7IHJldHVybiBuZXN0OyB9LFxyXG4gICAgc29ydFZhbHVlczogZnVuY3Rpb24ob3JkZXIpIHsgc29ydFZhbHVlcyA9IG9yZGVyOyByZXR1cm4gbmVzdDsgfSxcclxuICAgIHJvbGx1cDogZnVuY3Rpb24oZikgeyByb2xsdXAgPSBmOyByZXR1cm4gbmVzdDsgfVxyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZU9iamVjdCgpIHtcclxuICByZXR1cm4ge307XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldE9iamVjdChvYmplY3QsIGtleSwgdmFsdWUpIHtcclxuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVNYXAoKSB7XHJcbiAgcmV0dXJuIG1hcCQxKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldE1hcChtYXAsIGtleSwgdmFsdWUpIHtcclxuICBtYXAuc2V0KGtleSwgdmFsdWUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBTZXQoKSB7fVxyXG5cclxudmFyIHByb3RvID0gbWFwJDEucHJvdG90eXBlO1xyXG5cclxuU2V0LnByb3RvdHlwZSA9IHNldCQyLnByb3RvdHlwZSA9IHtcclxuICBjb25zdHJ1Y3RvcjogU2V0LFxyXG4gIGhhczogcHJvdG8uaGFzLFxyXG4gIGFkZDogZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIHZhbHVlICs9IFwiXCI7XHJcbiAgICB0aGlzW3ByZWZpeCArIHZhbHVlXSA9IHZhbHVlO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSxcclxuICByZW1vdmU6IHByb3RvLnJlbW92ZSxcclxuICBjbGVhcjogcHJvdG8uY2xlYXIsXHJcbiAgdmFsdWVzOiBwcm90by5rZXlzLFxyXG4gIHNpemU6IHByb3RvLnNpemUsXHJcbiAgZW1wdHk6IHByb3RvLmVtcHR5LFxyXG4gIGVhY2g6IHByb3RvLmVhY2hcclxufTtcclxuXHJcbmZ1bmN0aW9uIHNldCQyKG9iamVjdCwgZikge1xyXG4gIHZhciBzZXQgPSBuZXcgU2V0O1xyXG5cclxuICAvLyBDb3B5IGNvbnN0cnVjdG9yLlxyXG4gIGlmIChvYmplY3QgaW5zdGFuY2VvZiBTZXQpIG9iamVjdC5lYWNoKGZ1bmN0aW9uKHZhbHVlKSB7IHNldC5hZGQodmFsdWUpOyB9KTtcclxuXHJcbiAgLy8gT3RoZXJ3aXNlLCBhc3N1bWUgaXTigJlzIGFuIGFycmF5LlxyXG4gIGVsc2UgaWYgKG9iamVjdCkge1xyXG4gICAgdmFyIGkgPSAtMSwgbiA9IG9iamVjdC5sZW5ndGg7XHJcbiAgICBpZiAoZiA9PSBudWxsKSB3aGlsZSAoKytpIDwgbikgc2V0LmFkZChvYmplY3RbaV0pO1xyXG4gICAgZWxzZSB3aGlsZSAoKytpIDwgbikgc2V0LmFkZChmKG9iamVjdFtpXSwgaSwgb2JqZWN0KSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc2V0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBrZXlzKG1hcCkge1xyXG4gIHZhciBrZXlzID0gW107XHJcbiAgZm9yICh2YXIga2V5IGluIG1hcCkga2V5cy5wdXNoKGtleSk7XHJcbiAgcmV0dXJuIGtleXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHZhbHVlcyhtYXApIHtcclxuICB2YXIgdmFsdWVzID0gW107XHJcbiAgZm9yICh2YXIga2V5IGluIG1hcCkgdmFsdWVzLnB1c2gobWFwW2tleV0pO1xyXG4gIHJldHVybiB2YWx1ZXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVudHJpZXMobWFwKSB7XHJcbiAgdmFyIGVudHJpZXMgPSBbXTtcclxuICBmb3IgKHZhciBrZXkgaW4gbWFwKSBlbnRyaWVzLnB1c2goe2tleToga2V5LCB2YWx1ZTogbWFwW2tleV19KTtcclxuICByZXR1cm4gZW50cmllcztcclxufVxyXG5cclxudmFyIGFycmF5JDIgPSBBcnJheS5wcm90b3R5cGU7XHJcblxyXG52YXIgc2xpY2UkMyA9IGFycmF5JDIuc2xpY2U7XHJcblxyXG5mdW5jdGlvbiBhc2NlbmRpbmckMihhLCBiKSB7XHJcbiAgcmV0dXJuIGEgLSBiO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhcmVhKHJpbmcpIHtcclxuICB2YXIgaSA9IDAsIG4gPSByaW5nLmxlbmd0aCwgYXJlYSA9IHJpbmdbbiAtIDFdWzFdICogcmluZ1swXVswXSAtIHJpbmdbbiAtIDFdWzBdICogcmluZ1swXVsxXTtcclxuICB3aGlsZSAoKytpIDwgbikgYXJlYSArPSByaW5nW2kgLSAxXVsxXSAqIHJpbmdbaV1bMF0gLSByaW5nW2kgLSAxXVswXSAqIHJpbmdbaV1bMV07XHJcbiAgcmV0dXJuIGFyZWE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbnN0YW50JDYoeCkge1xyXG4gIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB4O1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbnRhaW5zKHJpbmcsIGhvbGUpIHtcclxuICB2YXIgaSA9IC0xLCBuID0gaG9sZS5sZW5ndGgsIGM7XHJcbiAgd2hpbGUgKCsraSA8IG4pIGlmIChjID0gcmluZ0NvbnRhaW5zKHJpbmcsIGhvbGVbaV0pKSByZXR1cm4gYztcclxuICByZXR1cm4gMDtcclxufVxyXG5cclxuZnVuY3Rpb24gcmluZ0NvbnRhaW5zKHJpbmcsIHBvaW50KSB7XHJcbiAgdmFyIHggPSBwb2ludFswXSwgeSA9IHBvaW50WzFdLCBjb250YWlucyA9IC0xO1xyXG4gIGZvciAodmFyIGkgPSAwLCBuID0gcmluZy5sZW5ndGgsIGogPSBuIC0gMTsgaSA8IG47IGogPSBpKyspIHtcclxuICAgIHZhciBwaSA9IHJpbmdbaV0sIHhpID0gcGlbMF0sIHlpID0gcGlbMV0sIHBqID0gcmluZ1tqXSwgeGogPSBwalswXSwgeWogPSBwalsxXTtcclxuICAgIGlmIChzZWdtZW50Q29udGFpbnMocGksIHBqLCBwb2ludCkpIHJldHVybiAwO1xyXG4gICAgaWYgKCgoeWkgPiB5KSAhPT0gKHlqID4geSkpICYmICgoeCA8ICh4aiAtIHhpKSAqICh5IC0geWkpIC8gKHlqIC0geWkpICsgeGkpKSkgY29udGFpbnMgPSAtY29udGFpbnM7XHJcbiAgfVxyXG4gIHJldHVybiBjb250YWlucztcclxufVxyXG5cclxuZnVuY3Rpb24gc2VnbWVudENvbnRhaW5zKGEsIGIsIGMpIHtcclxuICB2YXIgaTsgcmV0dXJuIGNvbGxpbmVhcihhLCBiLCBjKSAmJiB3aXRoaW4oYVtpID0gKyhhWzBdID09PSBiWzBdKV0sIGNbaV0sIGJbaV0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb2xsaW5lYXIoYSwgYiwgYykge1xyXG4gIHJldHVybiAoYlswXSAtIGFbMF0pICogKGNbMV0gLSBhWzFdKSA9PT0gKGNbMF0gLSBhWzBdKSAqIChiWzFdIC0gYVsxXSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHdpdGhpbihwLCBxLCByKSB7XHJcbiAgcmV0dXJuIHAgPD0gcSAmJiBxIDw9IHIgfHwgciA8PSBxICYmIHEgPD0gcDtcclxufVxyXG5cclxuZnVuY3Rpb24gbm9vcCQxKCkge31cclxuXHJcbnZhciBjYXNlcyA9IFtcclxuICBbXSxcclxuICBbW1sxLjAsIDEuNV0sIFswLjUsIDEuMF1dXSxcclxuICBbW1sxLjUsIDEuMF0sIFsxLjAsIDEuNV1dXSxcclxuICBbW1sxLjUsIDEuMF0sIFswLjUsIDEuMF1dXSxcclxuICBbW1sxLjAsIDAuNV0sIFsxLjUsIDEuMF1dXSxcclxuICBbW1sxLjAsIDEuNV0sIFswLjUsIDEuMF1dLCBbWzEuMCwgMC41XSwgWzEuNSwgMS4wXV1dLFxyXG4gIFtbWzEuMCwgMC41XSwgWzEuMCwgMS41XV1dLFxyXG4gIFtbWzEuMCwgMC41XSwgWzAuNSwgMS4wXV1dLFxyXG4gIFtbWzAuNSwgMS4wXSwgWzEuMCwgMC41XV1dLFxyXG4gIFtbWzEuMCwgMS41XSwgWzEuMCwgMC41XV1dLFxyXG4gIFtbWzAuNSwgMS4wXSwgWzEuMCwgMC41XV0sIFtbMS41LCAxLjBdLCBbMS4wLCAxLjVdXV0sXHJcbiAgW1tbMS41LCAxLjBdLCBbMS4wLCAwLjVdXV0sXHJcbiAgW1tbMC41LCAxLjBdLCBbMS41LCAxLjBdXV0sXHJcbiAgW1tbMS4wLCAxLjVdLCBbMS41LCAxLjBdXV0sXHJcbiAgW1tbMC41LCAxLjBdLCBbMS4wLCAxLjVdXV0sXHJcbiAgW11cclxuXTtcclxuXHJcbmZ1bmN0aW9uIGNvbnRvdXJzKCkge1xyXG4gIHZhciBkeCA9IDEsXHJcbiAgICAgIGR5ID0gMSxcclxuICAgICAgdGhyZXNob2xkJCQxID0gdGhyZXNob2xkU3R1cmdlcyxcclxuICAgICAgc21vb3RoID0gc21vb3RoTGluZWFyO1xyXG5cclxuICBmdW5jdGlvbiBjb250b3Vycyh2YWx1ZXMpIHtcclxuICAgIHZhciB0eiA9IHRocmVzaG9sZCQkMSh2YWx1ZXMpO1xyXG5cclxuICAgIC8vIENvbnZlcnQgbnVtYmVyIG9mIHRocmVzaG9sZHMgaW50byB1bmlmb3JtIHRocmVzaG9sZHMuXHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodHopKSB7XHJcbiAgICAgIHZhciBkb21haW4gPSBleHRlbnQodmFsdWVzKSwgc3RhcnQgPSBkb21haW5bMF0sIHN0b3AgPSBkb21haW5bMV07XHJcbiAgICAgIHR6ID0gdGlja1N0ZXAoc3RhcnQsIHN0b3AsIHR6KTtcclxuICAgICAgdHogPSBzZXF1ZW5jZShNYXRoLmZsb29yKHN0YXJ0IC8gdHopICogdHosIE1hdGguZmxvb3Ioc3RvcCAvIHR6KSAqIHR6LCB0eik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0eiA9IHR6LnNsaWNlKCkuc29ydChhc2NlbmRpbmckMik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHR6Lm1hcChmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICByZXR1cm4gY29udG91cih2YWx1ZXMsIHZhbHVlKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLy8gQWNjdW11bGF0ZSwgc21vb3RoIGNvbnRvdXIgcmluZ3MsIGFzc2lnbiBob2xlcyB0byBleHRlcmlvciByaW5ncy5cclxuICAvLyBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vbWJvc3RvY2svc2hhcGVmaWxlL2Jsb2IvdjAuNi4yL3NocC9wb2x5Z29uLmpzXHJcbiAgZnVuY3Rpb24gY29udG91cih2YWx1ZXMsIHZhbHVlKSB7XHJcbiAgICB2YXIgcG9seWdvbnMgPSBbXSxcclxuICAgICAgICBob2xlcyA9IFtdO1xyXG5cclxuICAgIGlzb3JpbmdzKHZhbHVlcywgdmFsdWUsIGZ1bmN0aW9uKHJpbmcpIHtcclxuICAgICAgc21vb3RoKHJpbmcsIHZhbHVlcywgdmFsdWUpO1xyXG4gICAgICBpZiAoYXJlYShyaW5nKSA+IDApIHBvbHlnb25zLnB1c2goW3JpbmddKTtcclxuICAgICAgZWxzZSBob2xlcy5wdXNoKHJpbmcpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaG9sZXMuZm9yRWFjaChmdW5jdGlvbihob2xlKSB7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gcG9seWdvbnMubGVuZ3RoLCBwb2x5Z29uOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgICAgaWYgKGNvbnRhaW5zKChwb2x5Z29uID0gcG9seWdvbnNbaV0pWzBdLCBob2xlKSAhPT0gLTEpIHtcclxuICAgICAgICAgIHBvbHlnb24ucHVzaChob2xlKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHR5cGU6IFwiTXVsdGlQb2x5Z29uXCIsXHJcbiAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgY29vcmRpbmF0ZXM6IHBvbHlnb25zXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gTWFyY2hpbmcgc3F1YXJlcyB3aXRoIGlzb2xpbmVzIHN0aXRjaGVkIGludG8gcmluZ3MuXHJcbiAgLy8gQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL3RvcG9qc29uL3RvcG9qc29uLWNsaWVudC9ibG9iL3YzLjAuMC9zcmMvc3RpdGNoLmpzXHJcbiAgZnVuY3Rpb24gaXNvcmluZ3ModmFsdWVzLCB2YWx1ZSwgY2FsbGJhY2spIHtcclxuICAgIHZhciBmcmFnbWVudEJ5U3RhcnQgPSBuZXcgQXJyYXksXHJcbiAgICAgICAgZnJhZ21lbnRCeUVuZCA9IG5ldyBBcnJheSxcclxuICAgICAgICB4LCB5LCB0MCwgdDEsIHQyLCB0MztcclxuXHJcbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIHRoZSBmaXJzdCByb3cgKHkgPSAtMSwgdDIgPSB0MyA9IDApLlxyXG4gICAgeCA9IHkgPSAtMTtcclxuICAgIHQxID0gdmFsdWVzWzBdID49IHZhbHVlO1xyXG4gICAgY2FzZXNbdDEgPDwgMV0uZm9yRWFjaChzdGl0Y2gpO1xyXG4gICAgd2hpbGUgKCsreCA8IGR4IC0gMSkge1xyXG4gICAgICB0MCA9IHQxLCB0MSA9IHZhbHVlc1t4ICsgMV0gPj0gdmFsdWU7XHJcbiAgICAgIGNhc2VzW3QwIHwgdDEgPDwgMV0uZm9yRWFjaChzdGl0Y2gpO1xyXG4gICAgfVxyXG4gICAgY2FzZXNbdDEgPDwgMF0uZm9yRWFjaChzdGl0Y2gpO1xyXG5cclxuICAgIC8vIEdlbmVyYWwgY2FzZSBmb3IgdGhlIGludGVybWVkaWF0ZSByb3dzLlxyXG4gICAgd2hpbGUgKCsreSA8IGR5IC0gMSkge1xyXG4gICAgICB4ID0gLTE7XHJcbiAgICAgIHQxID0gdmFsdWVzW3kgKiBkeCArIGR4XSA+PSB2YWx1ZTtcclxuICAgICAgdDIgPSB2YWx1ZXNbeSAqIGR4XSA+PSB2YWx1ZTtcclxuICAgICAgY2FzZXNbdDEgPDwgMSB8IHQyIDw8IDJdLmZvckVhY2goc3RpdGNoKTtcclxuICAgICAgd2hpbGUgKCsreCA8IGR4IC0gMSkge1xyXG4gICAgICAgIHQwID0gdDEsIHQxID0gdmFsdWVzW3kgKiBkeCArIGR4ICsgeCArIDFdID49IHZhbHVlO1xyXG4gICAgICAgIHQzID0gdDIsIHQyID0gdmFsdWVzW3kgKiBkeCArIHggKyAxXSA+PSB2YWx1ZTtcclxuICAgICAgICBjYXNlc1t0MCB8IHQxIDw8IDEgfCB0MiA8PCAyIHwgdDMgPDwgM10uZm9yRWFjaChzdGl0Y2gpO1xyXG4gICAgICB9XHJcbiAgICAgIGNhc2VzW3QxIHwgdDIgPDwgM10uZm9yRWFjaChzdGl0Y2gpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgdGhlIGxhc3Qgcm93ICh5ID0gZHkgLSAxLCB0MCA9IHQxID0gMCkuXHJcbiAgICB4ID0gLTE7XHJcbiAgICB0MiA9IHZhbHVlc1t5ICogZHhdID49IHZhbHVlO1xyXG4gICAgY2FzZXNbdDIgPDwgMl0uZm9yRWFjaChzdGl0Y2gpO1xyXG4gICAgd2hpbGUgKCsreCA8IGR4IC0gMSkge1xyXG4gICAgICB0MyA9IHQyLCB0MiA9IHZhbHVlc1t5ICogZHggKyB4ICsgMV0gPj0gdmFsdWU7XHJcbiAgICAgIGNhc2VzW3QyIDw8IDIgfCB0MyA8PCAzXS5mb3JFYWNoKHN0aXRjaCk7XHJcbiAgICB9XHJcbiAgICBjYXNlc1t0MiA8PCAzXS5mb3JFYWNoKHN0aXRjaCk7XHJcblxyXG4gICAgZnVuY3Rpb24gc3RpdGNoKGxpbmUpIHtcclxuICAgICAgdmFyIHN0YXJ0ID0gW2xpbmVbMF1bMF0gKyB4LCBsaW5lWzBdWzFdICsgeV0sXHJcbiAgICAgICAgICBlbmQgPSBbbGluZVsxXVswXSArIHgsIGxpbmVbMV1bMV0gKyB5XSxcclxuICAgICAgICAgIHN0YXJ0SW5kZXggPSBpbmRleChzdGFydCksXHJcbiAgICAgICAgICBlbmRJbmRleCA9IGluZGV4KGVuZCksXHJcbiAgICAgICAgICBmLCBnO1xyXG4gICAgICBpZiAoZiA9IGZyYWdtZW50QnlFbmRbc3RhcnRJbmRleF0pIHtcclxuICAgICAgICBpZiAoZyA9IGZyYWdtZW50QnlTdGFydFtlbmRJbmRleF0pIHtcclxuICAgICAgICAgIGRlbGV0ZSBmcmFnbWVudEJ5RW5kW2YuZW5kXTtcclxuICAgICAgICAgIGRlbGV0ZSBmcmFnbWVudEJ5U3RhcnRbZy5zdGFydF07XHJcbiAgICAgICAgICBpZiAoZiA9PT0gZykge1xyXG4gICAgICAgICAgICBmLnJpbmcucHVzaChlbmQpO1xyXG4gICAgICAgICAgICBjYWxsYmFjayhmLnJpbmcpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZnJhZ21lbnRCeVN0YXJ0W2Yuc3RhcnRdID0gZnJhZ21lbnRCeUVuZFtnLmVuZF0gPSB7c3RhcnQ6IGYuc3RhcnQsIGVuZDogZy5lbmQsIHJpbmc6IGYucmluZy5jb25jYXQoZy5yaW5nKX07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGRlbGV0ZSBmcmFnbWVudEJ5RW5kW2YuZW5kXTtcclxuICAgICAgICAgIGYucmluZy5wdXNoKGVuZCk7XHJcbiAgICAgICAgICBmcmFnbWVudEJ5RW5kW2YuZW5kID0gZW5kSW5kZXhdID0gZjtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAoZiA9IGZyYWdtZW50QnlTdGFydFtlbmRJbmRleF0pIHtcclxuICAgICAgICBpZiAoZyA9IGZyYWdtZW50QnlFbmRbc3RhcnRJbmRleF0pIHtcclxuICAgICAgICAgIGRlbGV0ZSBmcmFnbWVudEJ5U3RhcnRbZi5zdGFydF07XHJcbiAgICAgICAgICBkZWxldGUgZnJhZ21lbnRCeUVuZFtnLmVuZF07XHJcbiAgICAgICAgICBpZiAoZiA9PT0gZykge1xyXG4gICAgICAgICAgICBmLnJpbmcucHVzaChlbmQpO1xyXG4gICAgICAgICAgICBjYWxsYmFjayhmLnJpbmcpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZnJhZ21lbnRCeVN0YXJ0W2cuc3RhcnRdID0gZnJhZ21lbnRCeUVuZFtmLmVuZF0gPSB7c3RhcnQ6IGcuc3RhcnQsIGVuZDogZi5lbmQsIHJpbmc6IGcucmluZy5jb25jYXQoZi5yaW5nKX07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGRlbGV0ZSBmcmFnbWVudEJ5U3RhcnRbZi5zdGFydF07XHJcbiAgICAgICAgICBmLnJpbmcudW5zaGlmdChzdGFydCk7XHJcbiAgICAgICAgICBmcmFnbWVudEJ5U3RhcnRbZi5zdGFydCA9IHN0YXJ0SW5kZXhdID0gZjtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZnJhZ21lbnRCeVN0YXJ0W3N0YXJ0SW5kZXhdID0gZnJhZ21lbnRCeUVuZFtlbmRJbmRleF0gPSB7c3RhcnQ6IHN0YXJ0SW5kZXgsIGVuZDogZW5kSW5kZXgsIHJpbmc6IFtzdGFydCwgZW5kXX07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGluZGV4KHBvaW50KSB7XHJcbiAgICByZXR1cm4gcG9pbnRbMF0gKiAyICsgcG9pbnRbMV0gKiAoZHggKyAxKSAqIDQ7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzbW9vdGhMaW5lYXIocmluZywgdmFsdWVzLCB2YWx1ZSkge1xyXG4gICAgcmluZy5mb3JFYWNoKGZ1bmN0aW9uKHBvaW50KSB7XHJcbiAgICAgIHZhciB4ID0gcG9pbnRbMF0sXHJcbiAgICAgICAgICB5ID0gcG9pbnRbMV0sXHJcbiAgICAgICAgICB4dCA9IHggfCAwLFxyXG4gICAgICAgICAgeXQgPSB5IHwgMCxcclxuICAgICAgICAgIHYwLFxyXG4gICAgICAgICAgdjEgPSB2YWx1ZXNbeXQgKiBkeCArIHh0XTtcclxuICAgICAgaWYgKHggPiAwICYmIHggPCBkeCAmJiB4dCA9PT0geCkge1xyXG4gICAgICAgIHYwID0gdmFsdWVzW3l0ICogZHggKyB4dCAtIDFdO1xyXG4gICAgICAgIHBvaW50WzBdID0geCArICh2YWx1ZSAtIHYwKSAvICh2MSAtIHYwKSAtIDAuNTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoeSA+IDAgJiYgeSA8IGR5ICYmIHl0ID09PSB5KSB7XHJcbiAgICAgICAgdjAgPSB2YWx1ZXNbKHl0IC0gMSkgKiBkeCArIHh0XTtcclxuICAgICAgICBwb2ludFsxXSA9IHkgKyAodmFsdWUgLSB2MCkgLyAodjEgLSB2MCkgLSAwLjU7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgY29udG91cnMuY29udG91ciA9IGNvbnRvdXI7XHJcblxyXG4gIGNvbnRvdXJzLnNpemUgPSBmdW5jdGlvbihfKSB7XHJcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbZHgsIGR5XTtcclxuICAgIHZhciBfMCA9IE1hdGguY2VpbChfWzBdKSwgXzEgPSBNYXRoLmNlaWwoX1sxXSk7XHJcbiAgICBpZiAoIShfMCA+IDApIHx8ICEoXzEgPiAwKSkgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzaXplXCIpO1xyXG4gICAgcmV0dXJuIGR4ID0gXzAsIGR5ID0gXzEsIGNvbnRvdXJzO1xyXG4gIH07XHJcblxyXG4gIGNvbnRvdXJzLnRocmVzaG9sZHMgPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aHJlc2hvbGQkJDEgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IEFycmF5LmlzQXJyYXkoXykgPyBjb25zdGFudCQ2KHNsaWNlJDMuY2FsbChfKSkgOiBjb25zdGFudCQ2KF8pLCBjb250b3VycykgOiB0aHJlc2hvbGQkJDE7XHJcbiAgfTtcclxuXHJcbiAgY29udG91cnMuc21vb3RoID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc21vb3RoID0gXyA/IHNtb290aExpbmVhciA6IG5vb3AkMSwgY29udG91cnMpIDogc21vb3RoID09PSBzbW9vdGhMaW5lYXI7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIGNvbnRvdXJzO1xyXG59XHJcblxyXG4vLyBUT0RPIE9wdGltaXplIGVkZ2UgY2FzZXMuXHJcbi8vIFRPRE8gT3B0aW1pemUgaW5kZXggY2FsY3VsYXRpb24uXHJcbi8vIFRPRE8gT3B0aW1pemUgYXJndW1lbnRzLlxyXG5mdW5jdGlvbiBibHVyWChzb3VyY2UsIHRhcmdldCwgcikge1xyXG4gIHZhciBuID0gc291cmNlLndpZHRoLFxyXG4gICAgICBtID0gc291cmNlLmhlaWdodCxcclxuICAgICAgdyA9IChyIDw8IDEpICsgMTtcclxuICBmb3IgKHZhciBqID0gMDsgaiA8IG07ICsraikge1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIHNyID0gMDsgaSA8IG4gKyByOyArK2kpIHtcclxuICAgICAgaWYgKGkgPCBuKSB7XHJcbiAgICAgICAgc3IgKz0gc291cmNlLmRhdGFbaSArIGogKiBuXTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoaSA+PSByKSB7XHJcbiAgICAgICAgaWYgKGkgPj0gdykge1xyXG4gICAgICAgICAgc3IgLT0gc291cmNlLmRhdGFbaSAtIHcgKyBqICogbl07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRhcmdldC5kYXRhW2kgLSByICsgaiAqIG5dID0gc3IgLyBNYXRoLm1pbihpICsgMSwgbiAtIDEgKyB3IC0gaSwgdyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8vIFRPRE8gT3B0aW1pemUgZWRnZSBjYXNlcy5cclxuLy8gVE9ETyBPcHRpbWl6ZSBpbmRleCBjYWxjdWxhdGlvbi5cclxuLy8gVE9ETyBPcHRpbWl6ZSBhcmd1bWVudHMuXHJcbmZ1bmN0aW9uIGJsdXJZKHNvdXJjZSwgdGFyZ2V0LCByKSB7XHJcbiAgdmFyIG4gPSBzb3VyY2Uud2lkdGgsXHJcbiAgICAgIG0gPSBzb3VyY2UuaGVpZ2h0LFxyXG4gICAgICB3ID0gKHIgPDwgMSkgKyAxO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcbiAgICBmb3IgKHZhciBqID0gMCwgc3IgPSAwOyBqIDwgbSArIHI7ICsraikge1xyXG4gICAgICBpZiAoaiA8IG0pIHtcclxuICAgICAgICBzciArPSBzb3VyY2UuZGF0YVtpICsgaiAqIG5dO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChqID49IHIpIHtcclxuICAgICAgICBpZiAoaiA+PSB3KSB7XHJcbiAgICAgICAgICBzciAtPSBzb3VyY2UuZGF0YVtpICsgKGogLSB3KSAqIG5dO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0YXJnZXQuZGF0YVtpICsgKGogLSByKSAqIG5dID0gc3IgLyBNYXRoLm1pbihqICsgMSwgbSAtIDEgKyB3IC0gaiwgdyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlZmF1bHRYKGQpIHtcclxuICByZXR1cm4gZFswXTtcclxufVxyXG5cclxuZnVuY3Rpb24gZGVmYXVsdFkoZCkge1xyXG4gIHJldHVybiBkWzFdO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkZW5zaXR5KCkge1xyXG4gIHZhciB4ID0gZGVmYXVsdFgsXHJcbiAgICAgIHkgPSBkZWZhdWx0WSxcclxuICAgICAgZHggPSA5NjAsXHJcbiAgICAgIGR5ID0gNTAwLFxyXG4gICAgICByID0gMjAsIC8vIGJsdXIgcmFkaXVzXHJcbiAgICAgIGsgPSAyLCAvLyBsb2cyKGdyaWQgY2VsbCBzaXplKVxyXG4gICAgICBvID0gciAqIDMsIC8vIGdyaWQgb2Zmc2V0LCB0byBwYWQgZm9yIGJsdXJcclxuICAgICAgbiA9IChkeCArIG8gKiAyKSA+PiBrLCAvLyBncmlkIHdpZHRoXHJcbiAgICAgIG0gPSAoZHkgKyBvICogMikgPj4gaywgLy8gZ3JpZCBoZWlnaHRcclxuICAgICAgdGhyZXNob2xkJCQxID0gY29uc3RhbnQkNigyMCk7XHJcblxyXG4gIGZ1bmN0aW9uIGRlbnNpdHkoZGF0YSkge1xyXG4gICAgdmFyIHZhbHVlczAgPSBuZXcgRmxvYXQzMkFycmF5KG4gKiBtKSxcclxuICAgICAgICB2YWx1ZXMxID0gbmV3IEZsb2F0MzJBcnJheShuICogbSk7XHJcblxyXG4gICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKGQsIGksIGRhdGEpIHtcclxuICAgICAgdmFyIHhpID0gKHgoZCwgaSwgZGF0YSkgKyBvKSA+PiBrLFxyXG4gICAgICAgICAgeWkgPSAoeShkLCBpLCBkYXRhKSArIG8pID4+IGs7XHJcbiAgICAgIGlmICh4aSA+PSAwICYmIHhpIDwgbiAmJiB5aSA+PSAwICYmIHlpIDwgbSkge1xyXG4gICAgICAgICsrdmFsdWVzMFt4aSArIHlpICogbl07XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFRPRE8gT3B0aW1pemUuXHJcbiAgICBibHVyWCh7d2lkdGg6IG4sIGhlaWdodDogbSwgZGF0YTogdmFsdWVzMH0sIHt3aWR0aDogbiwgaGVpZ2h0OiBtLCBkYXRhOiB2YWx1ZXMxfSwgciA+PiBrKTtcclxuICAgIGJsdXJZKHt3aWR0aDogbiwgaGVpZ2h0OiBtLCBkYXRhOiB2YWx1ZXMxfSwge3dpZHRoOiBuLCBoZWlnaHQ6IG0sIGRhdGE6IHZhbHVlczB9LCByID4+IGspO1xyXG4gICAgYmx1clgoe3dpZHRoOiBuLCBoZWlnaHQ6IG0sIGRhdGE6IHZhbHVlczB9LCB7d2lkdGg6IG4sIGhlaWdodDogbSwgZGF0YTogdmFsdWVzMX0sIHIgPj4gayk7XHJcbiAgICBibHVyWSh7d2lkdGg6IG4sIGhlaWdodDogbSwgZGF0YTogdmFsdWVzMX0sIHt3aWR0aDogbiwgaGVpZ2h0OiBtLCBkYXRhOiB2YWx1ZXMwfSwgciA+PiBrKTtcclxuICAgIGJsdXJYKHt3aWR0aDogbiwgaGVpZ2h0OiBtLCBkYXRhOiB2YWx1ZXMwfSwge3dpZHRoOiBuLCBoZWlnaHQ6IG0sIGRhdGE6IHZhbHVlczF9LCByID4+IGspO1xyXG4gICAgYmx1clkoe3dpZHRoOiBuLCBoZWlnaHQ6IG0sIGRhdGE6IHZhbHVlczF9LCB7d2lkdGg6IG4sIGhlaWdodDogbSwgZGF0YTogdmFsdWVzMH0sIHIgPj4gayk7XHJcblxyXG4gICAgdmFyIHR6ID0gdGhyZXNob2xkJCQxKHZhbHVlczApO1xyXG5cclxuICAgIC8vIENvbnZlcnQgbnVtYmVyIG9mIHRocmVzaG9sZHMgaW50byB1bmlmb3JtIHRocmVzaG9sZHMuXHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodHopKSB7XHJcbiAgICAgIHZhciBzdG9wID0gbWF4KHZhbHVlczApO1xyXG4gICAgICB0eiA9IHRpY2tTdGVwKDAsIHN0b3AsIHR6KTtcclxuICAgICAgdHogPSBzZXF1ZW5jZSgwLCBNYXRoLmZsb29yKHN0b3AgLyB0eikgKiB0eiwgdHopO1xyXG4gICAgICB0ei5zaGlmdCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjb250b3VycygpXHJcbiAgICAgICAgLnRocmVzaG9sZHModHopXHJcbiAgICAgICAgLnNpemUoW24sIG1dKVxyXG4gICAgICAodmFsdWVzMClcclxuICAgICAgICAubWFwKHRyYW5zZm9ybSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB0cmFuc2Zvcm0oZ2VvbWV0cnkpIHtcclxuICAgIGdlb21ldHJ5LnZhbHVlICo9IE1hdGgucG93KDIsIC0yICogayk7IC8vIERlbnNpdHkgaW4gcG9pbnRzIHBlciBzcXVhcmUgcGl4ZWwuXHJcbiAgICBnZW9tZXRyeS5jb29yZGluYXRlcy5mb3JFYWNoKHRyYW5zZm9ybVBvbHlnb24pO1xyXG4gICAgcmV0dXJuIGdlb21ldHJ5O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdHJhbnNmb3JtUG9seWdvbihjb29yZGluYXRlcykge1xyXG4gICAgY29vcmRpbmF0ZXMuZm9yRWFjaCh0cmFuc2Zvcm1SaW5nKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHRyYW5zZm9ybVJpbmcoY29vcmRpbmF0ZXMpIHtcclxuICAgIGNvb3JkaW5hdGVzLmZvckVhY2godHJhbnNmb3JtUG9pbnQpO1xyXG4gIH1cclxuXHJcbiAgLy8gVE9ETyBPcHRpbWl6ZS5cclxuICBmdW5jdGlvbiB0cmFuc2Zvcm1Qb2ludChjb29yZGluYXRlcykge1xyXG4gICAgY29vcmRpbmF0ZXNbMF0gPSBjb29yZGluYXRlc1swXSAqIE1hdGgucG93KDIsIGspIC0gbztcclxuICAgIGNvb3JkaW5hdGVzWzFdID0gY29vcmRpbmF0ZXNbMV0gKiBNYXRoLnBvdygyLCBrKSAtIG87XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByZXNpemUoKSB7XHJcbiAgICBvID0gciAqIDM7XHJcbiAgICBuID0gKGR4ICsgbyAqIDIpID4+IGs7XHJcbiAgICBtID0gKGR5ICsgbyAqIDIpID4+IGs7XHJcbiAgICByZXR1cm4gZGVuc2l0eTtcclxuICB9XHJcblxyXG4gIGRlbnNpdHkueCA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHggPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50JDYoK18pLCBkZW5zaXR5KSA6IHg7XHJcbiAgfTtcclxuXHJcbiAgZGVuc2l0eS55ID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQkNigrXyksIGRlbnNpdHkpIDogeTtcclxuICB9O1xyXG5cclxuICBkZW5zaXR5LnNpemUgPSBmdW5jdGlvbihfKSB7XHJcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbZHgsIGR5XTtcclxuICAgIHZhciBfMCA9IE1hdGguY2VpbChfWzBdKSwgXzEgPSBNYXRoLmNlaWwoX1sxXSk7XHJcbiAgICBpZiAoIShfMCA+PSAwKSAmJiAhKF8wID49IDApKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNpemVcIik7XHJcbiAgICByZXR1cm4gZHggPSBfMCwgZHkgPSBfMSwgcmVzaXplKCk7XHJcbiAgfTtcclxuXHJcbiAgZGVuc2l0eS5jZWxsU2l6ZSA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIDEgPDwgaztcclxuICAgIGlmICghKChfID0gK18pID49IDEpKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGNlbGwgc2l6ZVwiKTtcclxuICAgIHJldHVybiBrID0gTWF0aC5mbG9vcihNYXRoLmxvZyhfKSAvIE1hdGguTE4yKSwgcmVzaXplKCk7XHJcbiAgfTtcclxuXHJcbiAgZGVuc2l0eS50aHJlc2hvbGRzID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGhyZXNob2xkJCQxID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBBcnJheS5pc0FycmF5KF8pID8gY29uc3RhbnQkNihzbGljZSQzLmNhbGwoXykpIDogY29uc3RhbnQkNihfKSwgZGVuc2l0eSkgOiB0aHJlc2hvbGQkJDE7XHJcbiAgfTtcclxuXHJcbiAgZGVuc2l0eS5iYW5kd2lkdGggPSBmdW5jdGlvbihfKSB7XHJcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBNYXRoLnNxcnQociAqIChyICsgMSkpO1xyXG4gICAgaWYgKCEoKF8gPSArXykgPj0gMCkpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYmFuZHdpZHRoXCIpO1xyXG4gICAgcmV0dXJuIHIgPSBNYXRoLnJvdW5kKChNYXRoLnNxcnQoNCAqIF8gKiBfICsgMSkgLSAxKSAvIDIpLCByZXNpemUoKTtcclxuICB9O1xyXG5cclxuICByZXR1cm4gZGVuc2l0eTtcclxufVxyXG5cclxudmFyIEVPTCA9IHt9LFxyXG4gICAgRU9GID0ge30sXHJcbiAgICBRVU9URSA9IDM0LFxyXG4gICAgTkVXTElORSA9IDEwLFxyXG4gICAgUkVUVVJOID0gMTM7XHJcblxyXG5mdW5jdGlvbiBvYmplY3RDb252ZXJ0ZXIoY29sdW1ucykge1xyXG4gIHJldHVybiBuZXcgRnVuY3Rpb24oXCJkXCIsIFwicmV0dXJuIHtcIiArIGNvbHVtbnMubWFwKGZ1bmN0aW9uKG5hbWUsIGkpIHtcclxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShuYW1lKSArIFwiOiBkW1wiICsgaSArIFwiXVwiO1xyXG4gIH0pLmpvaW4oXCIsXCIpICsgXCJ9XCIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjdXN0b21Db252ZXJ0ZXIoY29sdW1ucywgZikge1xyXG4gIHZhciBvYmplY3QgPSBvYmplY3RDb252ZXJ0ZXIoY29sdW1ucyk7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKHJvdywgaSkge1xyXG4gICAgcmV0dXJuIGYob2JqZWN0KHJvdyksIGksIGNvbHVtbnMpO1xyXG4gIH07XHJcbn1cclxuXHJcbi8vIENvbXB1dGUgdW5pcXVlIGNvbHVtbnMgaW4gb3JkZXIgb2YgZGlzY292ZXJ5LlxyXG5mdW5jdGlvbiBpbmZlckNvbHVtbnMocm93cykge1xyXG4gIHZhciBjb2x1bW5TZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxyXG4gICAgICBjb2x1bW5zID0gW107XHJcblxyXG4gIHJvd3MuZm9yRWFjaChmdW5jdGlvbihyb3cpIHtcclxuICAgIGZvciAodmFyIGNvbHVtbiBpbiByb3cpIHtcclxuICAgICAgaWYgKCEoY29sdW1uIGluIGNvbHVtblNldCkpIHtcclxuICAgICAgICBjb2x1bW5zLnB1c2goY29sdW1uU2V0W2NvbHVtbl0gPSBjb2x1bW4pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiBjb2x1bW5zO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkc3ZGb3JtYXQoZGVsaW1pdGVyKSB7XHJcbiAgdmFyIHJlRm9ybWF0ID0gbmV3IFJlZ0V4cChcIltcXFwiXCIgKyBkZWxpbWl0ZXIgKyBcIlxcblxccl1cIiksXHJcbiAgICAgIERFTElNSVRFUiA9IGRlbGltaXRlci5jaGFyQ29kZUF0KDApO1xyXG5cclxuICBmdW5jdGlvbiBwYXJzZSh0ZXh0LCBmKSB7XHJcbiAgICB2YXIgY29udmVydCwgY29sdW1ucywgcm93cyA9IHBhcnNlUm93cyh0ZXh0LCBmdW5jdGlvbihyb3csIGkpIHtcclxuICAgICAgaWYgKGNvbnZlcnQpIHJldHVybiBjb252ZXJ0KHJvdywgaSAtIDEpO1xyXG4gICAgICBjb2x1bW5zID0gcm93LCBjb252ZXJ0ID0gZiA/IGN1c3RvbUNvbnZlcnRlcihyb3csIGYpIDogb2JqZWN0Q29udmVydGVyKHJvdyk7XHJcbiAgICB9KTtcclxuICAgIHJvd3MuY29sdW1ucyA9IGNvbHVtbnMgfHwgW107XHJcbiAgICByZXR1cm4gcm93cztcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHBhcnNlUm93cyh0ZXh0LCBmKSB7XHJcbiAgICB2YXIgcm93cyA9IFtdLCAvLyBvdXRwdXQgcm93c1xyXG4gICAgICAgIE4gPSB0ZXh0Lmxlbmd0aCxcclxuICAgICAgICBJID0gMCwgLy8gY3VycmVudCBjaGFyYWN0ZXIgaW5kZXhcclxuICAgICAgICBuID0gMCwgLy8gY3VycmVudCBsaW5lIG51bWJlclxyXG4gICAgICAgIHQsIC8vIGN1cnJlbnQgdG9rZW5cclxuICAgICAgICBlb2YgPSBOIDw9IDAsIC8vIGN1cnJlbnQgdG9rZW4gZm9sbG93ZWQgYnkgRU9GP1xyXG4gICAgICAgIGVvbCA9IGZhbHNlOyAvLyBjdXJyZW50IHRva2VuIGZvbGxvd2VkIGJ5IEVPTD9cclxuXHJcbiAgICAvLyBTdHJpcCB0aGUgdHJhaWxpbmcgbmV3bGluZS5cclxuICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoTiAtIDEpID09PSBORVdMSU5FKSAtLU47XHJcbiAgICBpZiAodGV4dC5jaGFyQ29kZUF0KE4gLSAxKSA9PT0gUkVUVVJOKSAtLU47XHJcblxyXG4gICAgZnVuY3Rpb24gdG9rZW4oKSB7XHJcbiAgICAgIGlmIChlb2YpIHJldHVybiBFT0Y7XHJcbiAgICAgIGlmIChlb2wpIHJldHVybiBlb2wgPSBmYWxzZSwgRU9MO1xyXG5cclxuICAgICAgLy8gVW5lc2NhcGUgcXVvdGVzLlxyXG4gICAgICB2YXIgaSwgaiA9IEksIGM7XHJcbiAgICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoaikgPT09IFFVT1RFKSB7XHJcbiAgICAgICAgd2hpbGUgKEkrKyA8IE4gJiYgdGV4dC5jaGFyQ29kZUF0KEkpICE9PSBRVU9URSB8fCB0ZXh0LmNoYXJDb2RlQXQoKytJKSA9PT0gUVVPVEUpO1xyXG4gICAgICAgIGlmICgoaSA9IEkpID49IE4pIGVvZiA9IHRydWU7XHJcbiAgICAgICAgZWxzZSBpZiAoKGMgPSB0ZXh0LmNoYXJDb2RlQXQoSSsrKSkgPT09IE5FV0xJTkUpIGVvbCA9IHRydWU7XHJcbiAgICAgICAgZWxzZSBpZiAoYyA9PT0gUkVUVVJOKSB7IGVvbCA9IHRydWU7IGlmICh0ZXh0LmNoYXJDb2RlQXQoSSkgPT09IE5FV0xJTkUpICsrSTsgfVxyXG4gICAgICAgIHJldHVybiB0ZXh0LnNsaWNlKGogKyAxLCBpIC0gMSkucmVwbGFjZSgvXCJcIi9nLCBcIlxcXCJcIik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEZpbmQgbmV4dCBkZWxpbWl0ZXIgb3IgbmV3bGluZS5cclxuICAgICAgd2hpbGUgKEkgPCBOKSB7XHJcbiAgICAgICAgaWYgKChjID0gdGV4dC5jaGFyQ29kZUF0KGkgPSBJKyspKSA9PT0gTkVXTElORSkgZW9sID0gdHJ1ZTtcclxuICAgICAgICBlbHNlIGlmIChjID09PSBSRVRVUk4pIHsgZW9sID0gdHJ1ZTsgaWYgKHRleHQuY2hhckNvZGVBdChJKSA9PT0gTkVXTElORSkgKytJOyB9XHJcbiAgICAgICAgZWxzZSBpZiAoYyAhPT0gREVMSU1JVEVSKSBjb250aW51ZTtcclxuICAgICAgICByZXR1cm4gdGV4dC5zbGljZShqLCBpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUmV0dXJuIGxhc3QgdG9rZW4gYmVmb3JlIEVPRi5cclxuICAgICAgcmV0dXJuIGVvZiA9IHRydWUsIHRleHQuc2xpY2UoaiwgTik7XHJcbiAgICB9XHJcblxyXG4gICAgd2hpbGUgKCh0ID0gdG9rZW4oKSkgIT09IEVPRikge1xyXG4gICAgICB2YXIgcm93ID0gW107XHJcbiAgICAgIHdoaWxlICh0ICE9PSBFT0wgJiYgdCAhPT0gRU9GKSByb3cucHVzaCh0KSwgdCA9IHRva2VuKCk7XHJcbiAgICAgIGlmIChmICYmIChyb3cgPSBmKHJvdywgbisrKSkgPT0gbnVsbCkgY29udGludWU7XHJcbiAgICAgIHJvd3MucHVzaChyb3cpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByb3dzO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZm9ybWF0KHJvd3MsIGNvbHVtbnMpIHtcclxuICAgIGlmIChjb2x1bW5zID09IG51bGwpIGNvbHVtbnMgPSBpbmZlckNvbHVtbnMocm93cyk7XHJcbiAgICByZXR1cm4gW2NvbHVtbnMubWFwKGZvcm1hdFZhbHVlKS5qb2luKGRlbGltaXRlcildLmNvbmNhdChyb3dzLm1hcChmdW5jdGlvbihyb3cpIHtcclxuICAgICAgcmV0dXJuIGNvbHVtbnMubWFwKGZ1bmN0aW9uKGNvbHVtbikge1xyXG4gICAgICAgIHJldHVybiBmb3JtYXRWYWx1ZShyb3dbY29sdW1uXSk7XHJcbiAgICAgIH0pLmpvaW4oZGVsaW1pdGVyKTtcclxuICAgIH0pKS5qb2luKFwiXFxuXCIpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZm9ybWF0Um93cyhyb3dzKSB7XHJcbiAgICByZXR1cm4gcm93cy5tYXAoZm9ybWF0Um93KS5qb2luKFwiXFxuXCIpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZm9ybWF0Um93KHJvdykge1xyXG4gICAgcmV0dXJuIHJvdy5tYXAoZm9ybWF0VmFsdWUpLmpvaW4oZGVsaW1pdGVyKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGZvcm1hdFZhbHVlKHRleHQpIHtcclxuICAgIHJldHVybiB0ZXh0ID09IG51bGwgPyBcIlwiXHJcbiAgICAgICAgOiByZUZvcm1hdC50ZXN0KHRleHQgKz0gXCJcIikgPyBcIlxcXCJcIiArIHRleHQucmVwbGFjZSgvXCIvZywgXCJcXFwiXFxcIlwiKSArIFwiXFxcIlwiXHJcbiAgICAgICAgOiB0ZXh0O1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHBhcnNlOiBwYXJzZSxcclxuICAgIHBhcnNlUm93czogcGFyc2VSb3dzLFxyXG4gICAgZm9ybWF0OiBmb3JtYXQsXHJcbiAgICBmb3JtYXRSb3dzOiBmb3JtYXRSb3dzXHJcbiAgfTtcclxufVxyXG5cclxudmFyIGNzdiA9IGRzdkZvcm1hdChcIixcIik7XHJcblxyXG52YXIgY3N2UGFyc2UgPSBjc3YucGFyc2U7XHJcbnZhciBjc3ZQYXJzZVJvd3MgPSBjc3YucGFyc2VSb3dzO1xyXG52YXIgY3N2Rm9ybWF0ID0gY3N2LmZvcm1hdDtcclxudmFyIGNzdkZvcm1hdFJvd3MgPSBjc3YuZm9ybWF0Um93cztcclxuXHJcbnZhciB0c3YgPSBkc3ZGb3JtYXQoXCJcXHRcIik7XHJcblxyXG52YXIgdHN2UGFyc2UgPSB0c3YucGFyc2U7XHJcbnZhciB0c3ZQYXJzZVJvd3MgPSB0c3YucGFyc2VSb3dzO1xyXG52YXIgdHN2Rm9ybWF0ID0gdHN2LmZvcm1hdDtcclxudmFyIHRzdkZvcm1hdFJvd3MgPSB0c3YuZm9ybWF0Um93cztcclxuXHJcbmZ1bmN0aW9uIHJlc3BvbnNlQmxvYihyZXNwb25zZSkge1xyXG4gIGlmICghcmVzcG9uc2Uub2spIHRocm93IG5ldyBFcnJvcihyZXNwb25zZS5zdGF0dXMgKyBcIiBcIiArIHJlc3BvbnNlLnN0YXR1c1RleHQpO1xyXG4gIHJldHVybiByZXNwb25zZS5ibG9iKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGJsb2IoaW5wdXQsIGluaXQpIHtcclxuICByZXR1cm4gZmV0Y2goaW5wdXQsIGluaXQpLnRoZW4ocmVzcG9uc2VCbG9iKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVzcG9uc2VBcnJheUJ1ZmZlcihyZXNwb25zZSkge1xyXG4gIGlmICghcmVzcG9uc2Uub2spIHRocm93IG5ldyBFcnJvcihyZXNwb25zZS5zdGF0dXMgKyBcIiBcIiArIHJlc3BvbnNlLnN0YXR1c1RleHQpO1xyXG4gIHJldHVybiByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBidWZmZXIoaW5wdXQsIGluaXQpIHtcclxuICByZXR1cm4gZmV0Y2goaW5wdXQsIGluaXQpLnRoZW4ocmVzcG9uc2VBcnJheUJ1ZmZlcik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlc3BvbnNlVGV4dChyZXNwb25zZSkge1xyXG4gIGlmICghcmVzcG9uc2Uub2spIHRocm93IG5ldyBFcnJvcihyZXNwb25zZS5zdGF0dXMgKyBcIiBcIiArIHJlc3BvbnNlLnN0YXR1c1RleHQpO1xyXG4gIHJldHVybiByZXNwb25zZS50ZXh0KCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRleHQoaW5wdXQsIGluaXQpIHtcclxuICByZXR1cm4gZmV0Y2goaW5wdXQsIGluaXQpLnRoZW4ocmVzcG9uc2VUZXh0KTtcclxufVxyXG5cclxuZnVuY3Rpb24gZHN2UGFyc2UocGFyc2UpIHtcclxuICByZXR1cm4gZnVuY3Rpb24oaW5wdXQsIGluaXQsIHJvdykge1xyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgdHlwZW9mIGluaXQgPT09IFwiZnVuY3Rpb25cIikgcm93ID0gaW5pdCwgaW5pdCA9IHVuZGVmaW5lZDtcclxuICAgIHJldHVybiB0ZXh0KGlucHV0LCBpbml0KS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XHJcbiAgICAgIHJldHVybiBwYXJzZShyZXNwb25zZSwgcm93KTtcclxuICAgIH0pO1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRzdihkZWxpbWl0ZXIsIGlucHV0LCBpbml0LCByb3cpIHtcclxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMyAmJiB0eXBlb2YgaW5pdCA9PT0gXCJmdW5jdGlvblwiKSByb3cgPSBpbml0LCBpbml0ID0gdW5kZWZpbmVkO1xyXG4gIHZhciBmb3JtYXQgPSBkc3ZGb3JtYXQoZGVsaW1pdGVyKTtcclxuICByZXR1cm4gdGV4dChpbnB1dCwgaW5pdCkudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xyXG4gICAgcmV0dXJuIGZvcm1hdC5wYXJzZShyZXNwb25zZSwgcm93KTtcclxuICB9KTtcclxufVxyXG5cclxudmFyIGNzdiQxID0gZHN2UGFyc2UoY3N2UGFyc2UpO1xyXG52YXIgdHN2JDEgPSBkc3ZQYXJzZSh0c3ZQYXJzZSk7XHJcblxyXG5mdW5jdGlvbiBpbWFnZShpbnB1dCwgaW5pdCkge1xyXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcclxuICAgIHZhciBpbWFnZSA9IG5ldyBJbWFnZTtcclxuICAgIGZvciAodmFyIGtleSBpbiBpbml0KSBpbWFnZVtrZXldID0gaW5pdFtrZXldO1xyXG4gICAgaW1hZ2Uub25lcnJvciA9IHJlamVjdDtcclxuICAgIGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uKCkgeyByZXNvbHZlKGltYWdlKTsgfTtcclxuICAgIGltYWdlLnNyYyA9IGlucHV0O1xyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZXNwb25zZUpzb24ocmVzcG9uc2UpIHtcclxuICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IocmVzcG9uc2Uuc3RhdHVzICsgXCIgXCIgKyByZXNwb25zZS5zdGF0dXNUZXh0KTtcclxuICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBqc29uKGlucHV0LCBpbml0KSB7XHJcbiAgcmV0dXJuIGZldGNoKGlucHV0LCBpbml0KS50aGVuKHJlc3BvbnNlSnNvbik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnNlcih0eXBlKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKGlucHV0LCBpbml0KSAge1xyXG4gICAgcmV0dXJuIHRleHQoaW5wdXQsIGluaXQpLnRoZW4oZnVuY3Rpb24odGV4dCQkMSkge1xyXG4gICAgICByZXR1cm4gKG5ldyBET01QYXJzZXIpLnBhcnNlRnJvbVN0cmluZyh0ZXh0JCQxLCB0eXBlKTtcclxuICAgIH0pO1xyXG4gIH07XHJcbn1cclxuXHJcbnZhciB4bWwgPSBwYXJzZXIoXCJhcHBsaWNhdGlvbi94bWxcIik7XHJcblxyXG52YXIgaHRtbCA9IHBhcnNlcihcInRleHQvaHRtbFwiKTtcclxuXHJcbnZhciBzdmcgPSBwYXJzZXIoXCJpbWFnZS9zdmcreG1sXCIpO1xyXG5cclxuZnVuY3Rpb24gY2VudGVyJDEoeCwgeSkge1xyXG4gIHZhciBub2RlcztcclxuXHJcbiAgaWYgKHggPT0gbnVsbCkgeCA9IDA7XHJcbiAgaWYgKHkgPT0gbnVsbCkgeSA9IDA7XHJcblxyXG4gIGZ1bmN0aW9uIGZvcmNlKCkge1xyXG4gICAgdmFyIGksXHJcbiAgICAgICAgbiA9IG5vZGVzLmxlbmd0aCxcclxuICAgICAgICBub2RlLFxyXG4gICAgICAgIHN4ID0gMCxcclxuICAgICAgICBzeSA9IDA7XHJcblxyXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xyXG4gICAgICBub2RlID0gbm9kZXNbaV0sIHN4ICs9IG5vZGUueCwgc3kgKz0gbm9kZS55O1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAoc3ggPSBzeCAvIG4gLSB4LCBzeSA9IHN5IC8gbiAtIHksIGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgIG5vZGUgPSBub2Rlc1tpXSwgbm9kZS54IC09IHN4LCBub2RlLnkgLT0gc3k7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmb3JjZS5pbml0aWFsaXplID0gZnVuY3Rpb24oXykge1xyXG4gICAgbm9kZXMgPSBfO1xyXG4gIH07XHJcblxyXG4gIGZvcmNlLnggPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4ID0gK18sIGZvcmNlKSA6IHg7XHJcbiAgfTtcclxuXHJcbiAgZm9yY2UueSA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkgPSArXywgZm9yY2UpIDogeTtcclxuICB9O1xyXG5cclxuICByZXR1cm4gZm9yY2U7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbnN0YW50JDcoeCkge1xyXG4gIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB4O1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGppZ2dsZSgpIHtcclxuICByZXR1cm4gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMWUtNjtcclxufVxyXG5cclxuZnVuY3Rpb24gdHJlZV9hZGQoZCkge1xyXG4gIHZhciB4ID0gK3RoaXMuX3guY2FsbChudWxsLCBkKSxcclxuICAgICAgeSA9ICt0aGlzLl95LmNhbGwobnVsbCwgZCk7XHJcbiAgcmV0dXJuIGFkZCh0aGlzLmNvdmVyKHgsIHkpLCB4LCB5LCBkKTtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkKHRyZWUsIHgsIHksIGQpIHtcclxuICBpZiAoaXNOYU4oeCkgfHwgaXNOYU4oeSkpIHJldHVybiB0cmVlOyAvLyBpZ25vcmUgaW52YWxpZCBwb2ludHNcclxuXHJcbiAgdmFyIHBhcmVudCxcclxuICAgICAgbm9kZSA9IHRyZWUuX3Jvb3QsXHJcbiAgICAgIGxlYWYgPSB7ZGF0YTogZH0sXHJcbiAgICAgIHgwID0gdHJlZS5feDAsXHJcbiAgICAgIHkwID0gdHJlZS5feTAsXHJcbiAgICAgIHgxID0gdHJlZS5feDEsXHJcbiAgICAgIHkxID0gdHJlZS5feTEsXHJcbiAgICAgIHhtLFxyXG4gICAgICB5bSxcclxuICAgICAgeHAsXHJcbiAgICAgIHlwLFxyXG4gICAgICByaWdodCxcclxuICAgICAgYm90dG9tLFxyXG4gICAgICBpLFxyXG4gICAgICBqO1xyXG5cclxuICAvLyBJZiB0aGUgdHJlZSBpcyBlbXB0eSwgaW5pdGlhbGl6ZSB0aGUgcm9vdCBhcyBhIGxlYWYuXHJcbiAgaWYgKCFub2RlKSByZXR1cm4gdHJlZS5fcm9vdCA9IGxlYWYsIHRyZWU7XHJcblxyXG4gIC8vIEZpbmQgdGhlIGV4aXN0aW5nIGxlYWYgZm9yIHRoZSBuZXcgcG9pbnQsIG9yIGFkZCBpdC5cclxuICB3aGlsZSAobm9kZS5sZW5ndGgpIHtcclxuICAgIGlmIChyaWdodCA9IHggPj0gKHhtID0gKHgwICsgeDEpIC8gMikpIHgwID0geG07IGVsc2UgeDEgPSB4bTtcclxuICAgIGlmIChib3R0b20gPSB5ID49ICh5bSA9ICh5MCArIHkxKSAvIDIpKSB5MCA9IHltOyBlbHNlIHkxID0geW07XHJcbiAgICBpZiAocGFyZW50ID0gbm9kZSwgIShub2RlID0gbm9kZVtpID0gYm90dG9tIDw8IDEgfCByaWdodF0pKSByZXR1cm4gcGFyZW50W2ldID0gbGVhZiwgdHJlZTtcclxuICB9XHJcblxyXG4gIC8vIElzIHRoZSBuZXcgcG9pbnQgaXMgZXhhY3RseSBjb2luY2lkZW50IHdpdGggdGhlIGV4aXN0aW5nIHBvaW50P1xyXG4gIHhwID0gK3RyZWUuX3guY2FsbChudWxsLCBub2RlLmRhdGEpO1xyXG4gIHlwID0gK3RyZWUuX3kuY2FsbChudWxsLCBub2RlLmRhdGEpO1xyXG4gIGlmICh4ID09PSB4cCAmJiB5ID09PSB5cCkgcmV0dXJuIGxlYWYubmV4dCA9IG5vZGUsIHBhcmVudCA/IHBhcmVudFtpXSA9IGxlYWYgOiB0cmVlLl9yb290ID0gbGVhZiwgdHJlZTtcclxuXHJcbiAgLy8gT3RoZXJ3aXNlLCBzcGxpdCB0aGUgbGVhZiBub2RlIHVudGlsIHRoZSBvbGQgYW5kIG5ldyBwb2ludCBhcmUgc2VwYXJhdGVkLlxyXG4gIGRvIHtcclxuICAgIHBhcmVudCA9IHBhcmVudCA/IHBhcmVudFtpXSA9IG5ldyBBcnJheSg0KSA6IHRyZWUuX3Jvb3QgPSBuZXcgQXJyYXkoNCk7XHJcbiAgICBpZiAocmlnaHQgPSB4ID49ICh4bSA9ICh4MCArIHgxKSAvIDIpKSB4MCA9IHhtOyBlbHNlIHgxID0geG07XHJcbiAgICBpZiAoYm90dG9tID0geSA+PSAoeW0gPSAoeTAgKyB5MSkgLyAyKSkgeTAgPSB5bTsgZWxzZSB5MSA9IHltO1xyXG4gIH0gd2hpbGUgKChpID0gYm90dG9tIDw8IDEgfCByaWdodCkgPT09IChqID0gKHlwID49IHltKSA8PCAxIHwgKHhwID49IHhtKSkpO1xyXG4gIHJldHVybiBwYXJlbnRbal0gPSBub2RlLCBwYXJlbnRbaV0gPSBsZWFmLCB0cmVlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRBbGwoZGF0YSkge1xyXG4gIHZhciBkLCBpLCBuID0gZGF0YS5sZW5ndGgsXHJcbiAgICAgIHgsXHJcbiAgICAgIHksXHJcbiAgICAgIHh6ID0gbmV3IEFycmF5KG4pLFxyXG4gICAgICB5eiA9IG5ldyBBcnJheShuKSxcclxuICAgICAgeDAgPSBJbmZpbml0eSxcclxuICAgICAgeTAgPSBJbmZpbml0eSxcclxuICAgICAgeDEgPSAtSW5maW5pdHksXHJcbiAgICAgIHkxID0gLUluZmluaXR5O1xyXG5cclxuICAvLyBDb21wdXRlIHRoZSBwb2ludHMgYW5kIHRoZWlyIGV4dGVudC5cclxuICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcbiAgICBpZiAoaXNOYU4oeCA9ICt0aGlzLl94LmNhbGwobnVsbCwgZCA9IGRhdGFbaV0pKSB8fCBpc05hTih5ID0gK3RoaXMuX3kuY2FsbChudWxsLCBkKSkpIGNvbnRpbnVlO1xyXG4gICAgeHpbaV0gPSB4O1xyXG4gICAgeXpbaV0gPSB5O1xyXG4gICAgaWYgKHggPCB4MCkgeDAgPSB4O1xyXG4gICAgaWYgKHggPiB4MSkgeDEgPSB4O1xyXG4gICAgaWYgKHkgPCB5MCkgeTAgPSB5O1xyXG4gICAgaWYgKHkgPiB5MSkgeTEgPSB5O1xyXG4gIH1cclxuXHJcbiAgLy8gSWYgdGhlcmUgd2VyZSBubyAodmFsaWQpIHBvaW50cywgaW5oZXJpdCB0aGUgZXhpc3RpbmcgZXh0ZW50LlxyXG4gIGlmICh4MSA8IHgwKSB4MCA9IHRoaXMuX3gwLCB4MSA9IHRoaXMuX3gxO1xyXG4gIGlmICh5MSA8IHkwKSB5MCA9IHRoaXMuX3kwLCB5MSA9IHRoaXMuX3kxO1xyXG5cclxuICAvLyBFeHBhbmQgdGhlIHRyZWUgdG8gY292ZXIgdGhlIG5ldyBwb2ludHMuXHJcbiAgdGhpcy5jb3Zlcih4MCwgeTApLmNvdmVyKHgxLCB5MSk7XHJcblxyXG4gIC8vIEFkZCB0aGUgbmV3IHBvaW50cy5cclxuICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcbiAgICBhZGQodGhpcywgeHpbaV0sIHl6W2ldLCBkYXRhW2ldKTtcclxuICB9XHJcblxyXG4gIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5mdW5jdGlvbiB0cmVlX2NvdmVyKHgsIHkpIHtcclxuICBpZiAoaXNOYU4oeCA9ICt4KSB8fCBpc05hTih5ID0gK3kpKSByZXR1cm4gdGhpczsgLy8gaWdub3JlIGludmFsaWQgcG9pbnRzXHJcblxyXG4gIHZhciB4MCA9IHRoaXMuX3gwLFxyXG4gICAgICB5MCA9IHRoaXMuX3kwLFxyXG4gICAgICB4MSA9IHRoaXMuX3gxLFxyXG4gICAgICB5MSA9IHRoaXMuX3kxO1xyXG5cclxuICAvLyBJZiB0aGUgcXVhZHRyZWUgaGFzIG5vIGV4dGVudCwgaW5pdGlhbGl6ZSB0aGVtLlxyXG4gIC8vIEludGVnZXIgZXh0ZW50IGFyZSBuZWNlc3Nhcnkgc28gdGhhdCBpZiB3ZSBsYXRlciBkb3VibGUgdGhlIGV4dGVudCxcclxuICAvLyB0aGUgZXhpc3RpbmcgcXVhZHJhbnQgYm91bmRhcmllcyBkb27igJl0IGNoYW5nZSBkdWUgdG8gZmxvYXRpbmcgcG9pbnQgZXJyb3IhXHJcbiAgaWYgKGlzTmFOKHgwKSkge1xyXG4gICAgeDEgPSAoeDAgPSBNYXRoLmZsb29yKHgpKSArIDE7XHJcbiAgICB5MSA9ICh5MCA9IE1hdGguZmxvb3IoeSkpICsgMTtcclxuICB9XHJcblxyXG4gIC8vIE90aGVyd2lzZSwgZG91YmxlIHJlcGVhdGVkbHkgdG8gY292ZXIuXHJcbiAgZWxzZSBpZiAoeDAgPiB4IHx8IHggPiB4MSB8fCB5MCA+IHkgfHwgeSA+IHkxKSB7XHJcbiAgICB2YXIgeiA9IHgxIC0geDAsXHJcbiAgICAgICAgbm9kZSA9IHRoaXMuX3Jvb3QsXHJcbiAgICAgICAgcGFyZW50LFxyXG4gICAgICAgIGk7XHJcblxyXG4gICAgc3dpdGNoIChpID0gKHkgPCAoeTAgKyB5MSkgLyAyKSA8PCAxIHwgKHggPCAoeDAgKyB4MSkgLyAyKSkge1xyXG4gICAgICBjYXNlIDA6IHtcclxuICAgICAgICBkbyBwYXJlbnQgPSBuZXcgQXJyYXkoNCksIHBhcmVudFtpXSA9IG5vZGUsIG5vZGUgPSBwYXJlbnQ7XHJcbiAgICAgICAgd2hpbGUgKHogKj0gMiwgeDEgPSB4MCArIHosIHkxID0geTAgKyB6LCB4ID4geDEgfHwgeSA+IHkxKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBjYXNlIDE6IHtcclxuICAgICAgICBkbyBwYXJlbnQgPSBuZXcgQXJyYXkoNCksIHBhcmVudFtpXSA9IG5vZGUsIG5vZGUgPSBwYXJlbnQ7XHJcbiAgICAgICAgd2hpbGUgKHogKj0gMiwgeDAgPSB4MSAtIHosIHkxID0geTAgKyB6LCB4MCA+IHggfHwgeSA+IHkxKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBjYXNlIDI6IHtcclxuICAgICAgICBkbyBwYXJlbnQgPSBuZXcgQXJyYXkoNCksIHBhcmVudFtpXSA9IG5vZGUsIG5vZGUgPSBwYXJlbnQ7XHJcbiAgICAgICAgd2hpbGUgKHogKj0gMiwgeDEgPSB4MCArIHosIHkwID0geTEgLSB6LCB4ID4geDEgfHwgeTAgPiB5KTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBjYXNlIDM6IHtcclxuICAgICAgICBkbyBwYXJlbnQgPSBuZXcgQXJyYXkoNCksIHBhcmVudFtpXSA9IG5vZGUsIG5vZGUgPSBwYXJlbnQ7XHJcbiAgICAgICAgd2hpbGUgKHogKj0gMiwgeDAgPSB4MSAtIHosIHkwID0geTEgLSB6LCB4MCA+IHggfHwgeTAgPiB5KTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9yb290ICYmIHRoaXMuX3Jvb3QubGVuZ3RoKSB0aGlzLl9yb290ID0gbm9kZTtcclxuICB9XHJcblxyXG4gIC8vIElmIHRoZSBxdWFkdHJlZSBjb3ZlcnMgdGhlIHBvaW50IGFscmVhZHksIGp1c3QgcmV0dXJuLlxyXG4gIGVsc2UgcmV0dXJuIHRoaXM7XHJcblxyXG4gIHRoaXMuX3gwID0geDA7XHJcbiAgdGhpcy5feTAgPSB5MDtcclxuICB0aGlzLl94MSA9IHgxO1xyXG4gIHRoaXMuX3kxID0geTE7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRyZWVfZGF0YSgpIHtcclxuICB2YXIgZGF0YSA9IFtdO1xyXG4gIHRoaXMudmlzaXQoZnVuY3Rpb24obm9kZSkge1xyXG4gICAgaWYgKCFub2RlLmxlbmd0aCkgZG8gZGF0YS5wdXNoKG5vZGUuZGF0YSk7IHdoaWxlIChub2RlID0gbm9kZS5uZXh0KVxyXG4gIH0pO1xyXG4gIHJldHVybiBkYXRhO1xyXG59XHJcblxyXG5mdW5jdGlvbiB0cmVlX2V4dGVudChfKSB7XHJcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcclxuICAgICAgPyB0aGlzLmNvdmVyKCtfWzBdWzBdLCArX1swXVsxXSkuY292ZXIoK19bMV1bMF0sICtfWzFdWzFdKVxyXG4gICAgICA6IGlzTmFOKHRoaXMuX3gwKSA/IHVuZGVmaW5lZCA6IFtbdGhpcy5feDAsIHRoaXMuX3kwXSwgW3RoaXMuX3gxLCB0aGlzLl95MV1dO1xyXG59XHJcblxyXG5mdW5jdGlvbiBRdWFkKG5vZGUsIHgwLCB5MCwgeDEsIHkxKSB7XHJcbiAgdGhpcy5ub2RlID0gbm9kZTtcclxuICB0aGlzLngwID0geDA7XHJcbiAgdGhpcy55MCA9IHkwO1xyXG4gIHRoaXMueDEgPSB4MTtcclxuICB0aGlzLnkxID0geTE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRyZWVfZmluZCh4LCB5LCByYWRpdXMpIHtcclxuICB2YXIgZGF0YSxcclxuICAgICAgeDAgPSB0aGlzLl94MCxcclxuICAgICAgeTAgPSB0aGlzLl95MCxcclxuICAgICAgeDEsXHJcbiAgICAgIHkxLFxyXG4gICAgICB4MixcclxuICAgICAgeTIsXHJcbiAgICAgIHgzID0gdGhpcy5feDEsXHJcbiAgICAgIHkzID0gdGhpcy5feTEsXHJcbiAgICAgIHF1YWRzID0gW10sXHJcbiAgICAgIG5vZGUgPSB0aGlzLl9yb290LFxyXG4gICAgICBxLFxyXG4gICAgICBpO1xyXG5cclxuICBpZiAobm9kZSkgcXVhZHMucHVzaChuZXcgUXVhZChub2RlLCB4MCwgeTAsIHgzLCB5MykpO1xyXG4gIGlmIChyYWRpdXMgPT0gbnVsbCkgcmFkaXVzID0gSW5maW5pdHk7XHJcbiAgZWxzZSB7XHJcbiAgICB4MCA9IHggLSByYWRpdXMsIHkwID0geSAtIHJhZGl1cztcclxuICAgIHgzID0geCArIHJhZGl1cywgeTMgPSB5ICsgcmFkaXVzO1xyXG4gICAgcmFkaXVzICo9IHJhZGl1cztcclxuICB9XHJcblxyXG4gIHdoaWxlIChxID0gcXVhZHMucG9wKCkpIHtcclxuXHJcbiAgICAvLyBTdG9wIHNlYXJjaGluZyBpZiB0aGlzIHF1YWRyYW50IGNhbuKAmXQgY29udGFpbiBhIGNsb3NlciBub2RlLlxyXG4gICAgaWYgKCEobm9kZSA9IHEubm9kZSlcclxuICAgICAgICB8fCAoeDEgPSBxLngwKSA+IHgzXHJcbiAgICAgICAgfHwgKHkxID0gcS55MCkgPiB5M1xyXG4gICAgICAgIHx8ICh4MiA9IHEueDEpIDwgeDBcclxuICAgICAgICB8fCAoeTIgPSBxLnkxKSA8IHkwKSBjb250aW51ZTtcclxuXHJcbiAgICAvLyBCaXNlY3QgdGhlIGN1cnJlbnQgcXVhZHJhbnQuXHJcbiAgICBpZiAobm9kZS5sZW5ndGgpIHtcclxuICAgICAgdmFyIHhtID0gKHgxICsgeDIpIC8gMixcclxuICAgICAgICAgIHltID0gKHkxICsgeTIpIC8gMjtcclxuXHJcbiAgICAgIHF1YWRzLnB1c2goXHJcbiAgICAgICAgbmV3IFF1YWQobm9kZVszXSwgeG0sIHltLCB4MiwgeTIpLFxyXG4gICAgICAgIG5ldyBRdWFkKG5vZGVbMl0sIHgxLCB5bSwgeG0sIHkyKSxcclxuICAgICAgICBuZXcgUXVhZChub2RlWzFdLCB4bSwgeTEsIHgyLCB5bSksXHJcbiAgICAgICAgbmV3IFF1YWQobm9kZVswXSwgeDEsIHkxLCB4bSwgeW0pXHJcbiAgICAgICk7XHJcblxyXG4gICAgICAvLyBWaXNpdCB0aGUgY2xvc2VzdCBxdWFkcmFudCBmaXJzdC5cclxuICAgICAgaWYgKGkgPSAoeSA+PSB5bSkgPDwgMSB8ICh4ID49IHhtKSkge1xyXG4gICAgICAgIHEgPSBxdWFkc1txdWFkcy5sZW5ndGggLSAxXTtcclxuICAgICAgICBxdWFkc1txdWFkcy5sZW5ndGggLSAxXSA9IHF1YWRzW3F1YWRzLmxlbmd0aCAtIDEgLSBpXTtcclxuICAgICAgICBxdWFkc1txdWFkcy5sZW5ndGggLSAxIC0gaV0gPSBxO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVmlzaXQgdGhpcyBwb2ludC4gKFZpc2l0aW5nIGNvaW5jaWRlbnQgcG9pbnRzIGlzbuKAmXQgbmVjZXNzYXJ5ISlcclxuICAgIGVsc2Uge1xyXG4gICAgICB2YXIgZHggPSB4IC0gK3RoaXMuX3guY2FsbChudWxsLCBub2RlLmRhdGEpLFxyXG4gICAgICAgICAgZHkgPSB5IC0gK3RoaXMuX3kuY2FsbChudWxsLCBub2RlLmRhdGEpLFxyXG4gICAgICAgICAgZDIgPSBkeCAqIGR4ICsgZHkgKiBkeTtcclxuICAgICAgaWYgKGQyIDwgcmFkaXVzKSB7XHJcbiAgICAgICAgdmFyIGQgPSBNYXRoLnNxcnQocmFkaXVzID0gZDIpO1xyXG4gICAgICAgIHgwID0geCAtIGQsIHkwID0geSAtIGQ7XHJcbiAgICAgICAgeDMgPSB4ICsgZCwgeTMgPSB5ICsgZDtcclxuICAgICAgICBkYXRhID0gbm9kZS5kYXRhO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZGF0YTtcclxufVxyXG5cclxuZnVuY3Rpb24gdHJlZV9yZW1vdmUoZCkge1xyXG4gIGlmIChpc05hTih4ID0gK3RoaXMuX3guY2FsbChudWxsLCBkKSkgfHwgaXNOYU4oeSA9ICt0aGlzLl95LmNhbGwobnVsbCwgZCkpKSByZXR1cm4gdGhpczsgLy8gaWdub3JlIGludmFsaWQgcG9pbnRzXHJcblxyXG4gIHZhciBwYXJlbnQsXHJcbiAgICAgIG5vZGUgPSB0aGlzLl9yb290LFxyXG4gICAgICByZXRhaW5lcixcclxuICAgICAgcHJldmlvdXMsXHJcbiAgICAgIG5leHQsXHJcbiAgICAgIHgwID0gdGhpcy5feDAsXHJcbiAgICAgIHkwID0gdGhpcy5feTAsXHJcbiAgICAgIHgxID0gdGhpcy5feDEsXHJcbiAgICAgIHkxID0gdGhpcy5feTEsXHJcbiAgICAgIHgsXHJcbiAgICAgIHksXHJcbiAgICAgIHhtLFxyXG4gICAgICB5bSxcclxuICAgICAgcmlnaHQsXHJcbiAgICAgIGJvdHRvbSxcclxuICAgICAgaSxcclxuICAgICAgajtcclxuXHJcbiAgLy8gSWYgdGhlIHRyZWUgaXMgZW1wdHksIGluaXRpYWxpemUgdGhlIHJvb3QgYXMgYSBsZWFmLlxyXG4gIGlmICghbm9kZSkgcmV0dXJuIHRoaXM7XHJcblxyXG4gIC8vIEZpbmQgdGhlIGxlYWYgbm9kZSBmb3IgdGhlIHBvaW50LlxyXG4gIC8vIFdoaWxlIGRlc2NlbmRpbmcsIGFsc28gcmV0YWluIHRoZSBkZWVwZXN0IHBhcmVudCB3aXRoIGEgbm9uLXJlbW92ZWQgc2libGluZy5cclxuICBpZiAobm9kZS5sZW5ndGgpIHdoaWxlICh0cnVlKSB7XHJcbiAgICBpZiAocmlnaHQgPSB4ID49ICh4bSA9ICh4MCArIHgxKSAvIDIpKSB4MCA9IHhtOyBlbHNlIHgxID0geG07XHJcbiAgICBpZiAoYm90dG9tID0geSA+PSAoeW0gPSAoeTAgKyB5MSkgLyAyKSkgeTAgPSB5bTsgZWxzZSB5MSA9IHltO1xyXG4gICAgaWYgKCEocGFyZW50ID0gbm9kZSwgbm9kZSA9IG5vZGVbaSA9IGJvdHRvbSA8PCAxIHwgcmlnaHRdKSkgcmV0dXJuIHRoaXM7XHJcbiAgICBpZiAoIW5vZGUubGVuZ3RoKSBicmVhaztcclxuICAgIGlmIChwYXJlbnRbKGkgKyAxKSAmIDNdIHx8IHBhcmVudFsoaSArIDIpICYgM10gfHwgcGFyZW50WyhpICsgMykgJiAzXSkgcmV0YWluZXIgPSBwYXJlbnQsIGogPSBpO1xyXG4gIH1cclxuXHJcbiAgLy8gRmluZCB0aGUgcG9pbnQgdG8gcmVtb3ZlLlxyXG4gIHdoaWxlIChub2RlLmRhdGEgIT09IGQpIGlmICghKHByZXZpb3VzID0gbm9kZSwgbm9kZSA9IG5vZGUubmV4dCkpIHJldHVybiB0aGlzO1xyXG4gIGlmIChuZXh0ID0gbm9kZS5uZXh0KSBkZWxldGUgbm9kZS5uZXh0O1xyXG5cclxuICAvLyBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgY29pbmNpZGVudCBwb2ludHMsIHJlbW92ZSBqdXN0IHRoZSBwb2ludC5cclxuICBpZiAocHJldmlvdXMpIHJldHVybiBuZXh0ID8gcHJldmlvdXMubmV4dCA9IG5leHQgOiBkZWxldGUgcHJldmlvdXMubmV4dCwgdGhpcztcclxuXHJcbiAgLy8gSWYgdGhpcyBpcyB0aGUgcm9vdCBwb2ludCwgcmVtb3ZlIGl0LlxyXG4gIGlmICghcGFyZW50KSByZXR1cm4gdGhpcy5fcm9vdCA9IG5leHQsIHRoaXM7XHJcblxyXG4gIC8vIFJlbW92ZSB0aGlzIGxlYWYuXHJcbiAgbmV4dCA/IHBhcmVudFtpXSA9IG5leHQgOiBkZWxldGUgcGFyZW50W2ldO1xyXG5cclxuICAvLyBJZiB0aGUgcGFyZW50IG5vdyBjb250YWlucyBleGFjdGx5IG9uZSBsZWFmLCBjb2xsYXBzZSBzdXBlcmZsdW91cyBwYXJlbnRzLlxyXG4gIGlmICgobm9kZSA9IHBhcmVudFswXSB8fCBwYXJlbnRbMV0gfHwgcGFyZW50WzJdIHx8IHBhcmVudFszXSlcclxuICAgICAgJiYgbm9kZSA9PT0gKHBhcmVudFszXSB8fCBwYXJlbnRbMl0gfHwgcGFyZW50WzFdIHx8IHBhcmVudFswXSlcclxuICAgICAgJiYgIW5vZGUubGVuZ3RoKSB7XHJcbiAgICBpZiAocmV0YWluZXIpIHJldGFpbmVyW2pdID0gbm9kZTtcclxuICAgIGVsc2UgdGhpcy5fcm9vdCA9IG5vZGU7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuZnVuY3Rpb24gcmVtb3ZlQWxsKGRhdGEpIHtcclxuICBmb3IgKHZhciBpID0gMCwgbiA9IGRhdGEubGVuZ3RoOyBpIDwgbjsgKytpKSB0aGlzLnJlbW92ZShkYXRhW2ldKTtcclxuICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuZnVuY3Rpb24gdHJlZV9yb290KCkge1xyXG4gIHJldHVybiB0aGlzLl9yb290O1xyXG59XHJcblxyXG5mdW5jdGlvbiB0cmVlX3NpemUoKSB7XHJcbiAgdmFyIHNpemUgPSAwO1xyXG4gIHRoaXMudmlzaXQoZnVuY3Rpb24obm9kZSkge1xyXG4gICAgaWYgKCFub2RlLmxlbmd0aCkgZG8gKytzaXplOyB3aGlsZSAobm9kZSA9IG5vZGUubmV4dClcclxuICB9KTtcclxuICByZXR1cm4gc2l6ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gdHJlZV92aXNpdChjYWxsYmFjaykge1xyXG4gIHZhciBxdWFkcyA9IFtdLCBxLCBub2RlID0gdGhpcy5fcm9vdCwgY2hpbGQsIHgwLCB5MCwgeDEsIHkxO1xyXG4gIGlmIChub2RlKSBxdWFkcy5wdXNoKG5ldyBRdWFkKG5vZGUsIHRoaXMuX3gwLCB0aGlzLl95MCwgdGhpcy5feDEsIHRoaXMuX3kxKSk7XHJcbiAgd2hpbGUgKHEgPSBxdWFkcy5wb3AoKSkge1xyXG4gICAgaWYgKCFjYWxsYmFjayhub2RlID0gcS5ub2RlLCB4MCA9IHEueDAsIHkwID0gcS55MCwgeDEgPSBxLngxLCB5MSA9IHEueTEpICYmIG5vZGUubGVuZ3RoKSB7XHJcbiAgICAgIHZhciB4bSA9ICh4MCArIHgxKSAvIDIsIHltID0gKHkwICsgeTEpIC8gMjtcclxuICAgICAgaWYgKGNoaWxkID0gbm9kZVszXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeG0sIHltLCB4MSwgeTEpKTtcclxuICAgICAgaWYgKGNoaWxkID0gbm9kZVsyXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeDAsIHltLCB4bSwgeTEpKTtcclxuICAgICAgaWYgKGNoaWxkID0gbm9kZVsxXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeG0sIHkwLCB4MSwgeW0pKTtcclxuICAgICAgaWYgKGNoaWxkID0gbm9kZVswXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeDAsIHkwLCB4bSwgeW0pKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRyZWVfdmlzaXRBZnRlcihjYWxsYmFjaykge1xyXG4gIHZhciBxdWFkcyA9IFtdLCBuZXh0ID0gW10sIHE7XHJcbiAgaWYgKHRoaXMuX3Jvb3QpIHF1YWRzLnB1c2gobmV3IFF1YWQodGhpcy5fcm9vdCwgdGhpcy5feDAsIHRoaXMuX3kwLCB0aGlzLl94MSwgdGhpcy5feTEpKTtcclxuICB3aGlsZSAocSA9IHF1YWRzLnBvcCgpKSB7XHJcbiAgICB2YXIgbm9kZSA9IHEubm9kZTtcclxuICAgIGlmIChub2RlLmxlbmd0aCkge1xyXG4gICAgICB2YXIgY2hpbGQsIHgwID0gcS54MCwgeTAgPSBxLnkwLCB4MSA9IHEueDEsIHkxID0gcS55MSwgeG0gPSAoeDAgKyB4MSkgLyAyLCB5bSA9ICh5MCArIHkxKSAvIDI7XHJcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbMF0pIHF1YWRzLnB1c2gobmV3IFF1YWQoY2hpbGQsIHgwLCB5MCwgeG0sIHltKSk7XHJcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbMV0pIHF1YWRzLnB1c2gobmV3IFF1YWQoY2hpbGQsIHhtLCB5MCwgeDEsIHltKSk7XHJcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbMl0pIHF1YWRzLnB1c2gobmV3IFF1YWQoY2hpbGQsIHgwLCB5bSwgeG0sIHkxKSk7XHJcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbM10pIHF1YWRzLnB1c2gobmV3IFF1YWQoY2hpbGQsIHhtLCB5bSwgeDEsIHkxKSk7XHJcbiAgICB9XHJcbiAgICBuZXh0LnB1c2gocSk7XHJcbiAgfVxyXG4gIHdoaWxlIChxID0gbmV4dC5wb3AoKSkge1xyXG4gICAgY2FsbGJhY2socS5ub2RlLCBxLngwLCBxLnkwLCBxLngxLCBxLnkxKTtcclxuICB9XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlZmF1bHRYJDEoZCkge1xyXG4gIHJldHVybiBkWzBdO1xyXG59XHJcblxyXG5mdW5jdGlvbiB0cmVlX3goXykge1xyXG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRoaXMuX3ggPSBfLCB0aGlzKSA6IHRoaXMuX3g7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlZmF1bHRZJDEoZCkge1xyXG4gIHJldHVybiBkWzFdO1xyXG59XHJcblxyXG5mdW5jdGlvbiB0cmVlX3koXykge1xyXG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRoaXMuX3kgPSBfLCB0aGlzKSA6IHRoaXMuX3k7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHF1YWR0cmVlKG5vZGVzLCB4LCB5KSB7XHJcbiAgdmFyIHRyZWUgPSBuZXcgUXVhZHRyZWUoeCA9PSBudWxsID8gZGVmYXVsdFgkMSA6IHgsIHkgPT0gbnVsbCA/IGRlZmF1bHRZJDEgOiB5LCBOYU4sIE5hTiwgTmFOLCBOYU4pO1xyXG4gIHJldHVybiBub2RlcyA9PSBudWxsID8gdHJlZSA6IHRyZWUuYWRkQWxsKG5vZGVzKTtcclxufVxyXG5cclxuZnVuY3Rpb24gUXVhZHRyZWUoeCwgeSwgeDAsIHkwLCB4MSwgeTEpIHtcclxuICB0aGlzLl94ID0geDtcclxuICB0aGlzLl95ID0geTtcclxuICB0aGlzLl94MCA9IHgwO1xyXG4gIHRoaXMuX3kwID0geTA7XHJcbiAgdGhpcy5feDEgPSB4MTtcclxuICB0aGlzLl95MSA9IHkxO1xyXG4gIHRoaXMuX3Jvb3QgPSB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxlYWZfY29weShsZWFmKSB7XHJcbiAgdmFyIGNvcHkgPSB7ZGF0YTogbGVhZi5kYXRhfSwgbmV4dCA9IGNvcHk7XHJcbiAgd2hpbGUgKGxlYWYgPSBsZWFmLm5leHQpIG5leHQgPSBuZXh0Lm5leHQgPSB7ZGF0YTogbGVhZi5kYXRhfTtcclxuICByZXR1cm4gY29weTtcclxufVxyXG5cclxudmFyIHRyZWVQcm90byA9IHF1YWR0cmVlLnByb3RvdHlwZSA9IFF1YWR0cmVlLnByb3RvdHlwZTtcclxuXHJcbnRyZWVQcm90by5jb3B5ID0gZnVuY3Rpb24oKSB7XHJcbiAgdmFyIGNvcHkgPSBuZXcgUXVhZHRyZWUodGhpcy5feCwgdGhpcy5feSwgdGhpcy5feDAsIHRoaXMuX3kwLCB0aGlzLl94MSwgdGhpcy5feTEpLFxyXG4gICAgICBub2RlID0gdGhpcy5fcm9vdCxcclxuICAgICAgbm9kZXMsXHJcbiAgICAgIGNoaWxkO1xyXG5cclxuICBpZiAoIW5vZGUpIHJldHVybiBjb3B5O1xyXG5cclxuICBpZiAoIW5vZGUubGVuZ3RoKSByZXR1cm4gY29weS5fcm9vdCA9IGxlYWZfY29weShub2RlKSwgY29weTtcclxuXHJcbiAgbm9kZXMgPSBbe3NvdXJjZTogbm9kZSwgdGFyZ2V0OiBjb3B5Ll9yb290ID0gbmV3IEFycmF5KDQpfV07XHJcbiAgd2hpbGUgKG5vZGUgPSBub2Rlcy5wb3AoKSkge1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyArK2kpIHtcclxuICAgICAgaWYgKGNoaWxkID0gbm9kZS5zb3VyY2VbaV0pIHtcclxuICAgICAgICBpZiAoY2hpbGQubGVuZ3RoKSBub2Rlcy5wdXNoKHtzb3VyY2U6IGNoaWxkLCB0YXJnZXQ6IG5vZGUudGFyZ2V0W2ldID0gbmV3IEFycmF5KDQpfSk7XHJcbiAgICAgICAgZWxzZSBub2RlLnRhcmdldFtpXSA9IGxlYWZfY29weShjaGlsZCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBjb3B5O1xyXG59O1xyXG5cclxudHJlZVByb3RvLmFkZCA9IHRyZWVfYWRkO1xyXG50cmVlUHJvdG8uYWRkQWxsID0gYWRkQWxsO1xyXG50cmVlUHJvdG8uY292ZXIgPSB0cmVlX2NvdmVyO1xyXG50cmVlUHJvdG8uZGF0YSA9IHRyZWVfZGF0YTtcclxudHJlZVByb3RvLmV4dGVudCA9IHRyZWVfZXh0ZW50O1xyXG50cmVlUHJvdG8uZmluZCA9IHRyZWVfZmluZDtcclxudHJlZVByb3RvLnJlbW92ZSA9IHRyZWVfcmVtb3ZlO1xyXG50cmVlUHJvdG8ucmVtb3ZlQWxsID0gcmVtb3ZlQWxsO1xyXG50cmVlUHJvdG8ucm9vdCA9IHRyZWVfcm9vdDtcclxudHJlZVByb3RvLnNpemUgPSB0cmVlX3NpemU7XHJcbnRyZWVQcm90by52aXNpdCA9IHRyZWVfdmlzaXQ7XHJcbnRyZWVQcm90by52aXNpdEFmdGVyID0gdHJlZV92aXNpdEFmdGVyO1xyXG50cmVlUHJvdG8ueCA9IHRyZWVfeDtcclxudHJlZVByb3RvLnkgPSB0cmVlX3k7XHJcblxyXG5mdW5jdGlvbiB4KGQpIHtcclxuICByZXR1cm4gZC54ICsgZC52eDtcclxufVxyXG5cclxuZnVuY3Rpb24geShkKSB7XHJcbiAgcmV0dXJuIGQueSArIGQudnk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbGxpZGUocmFkaXVzKSB7XHJcbiAgdmFyIG5vZGVzLFxyXG4gICAgICByYWRpaSxcclxuICAgICAgc3RyZW5ndGggPSAxLFxyXG4gICAgICBpdGVyYXRpb25zID0gMTtcclxuXHJcbiAgaWYgKHR5cGVvZiByYWRpdXMgIT09IFwiZnVuY3Rpb25cIikgcmFkaXVzID0gY29uc3RhbnQkNyhyYWRpdXMgPT0gbnVsbCA/IDEgOiArcmFkaXVzKTtcclxuXHJcbiAgZnVuY3Rpb24gZm9yY2UoKSB7XHJcbiAgICB2YXIgaSwgbiA9IG5vZGVzLmxlbmd0aCxcclxuICAgICAgICB0cmVlLFxyXG4gICAgICAgIG5vZGUsXHJcbiAgICAgICAgeGksXHJcbiAgICAgICAgeWksXHJcbiAgICAgICAgcmksXHJcbiAgICAgICAgcmkyO1xyXG5cclxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgaXRlcmF0aW9uczsgKytrKSB7XHJcbiAgICAgIHRyZWUgPSBxdWFkdHJlZShub2RlcywgeCwgeSkudmlzaXRBZnRlcihwcmVwYXJlKTtcclxuICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xyXG4gICAgICAgIG5vZGUgPSBub2Rlc1tpXTtcclxuICAgICAgICByaSA9IHJhZGlpW25vZGUuaW5kZXhdLCByaTIgPSByaSAqIHJpO1xyXG4gICAgICAgIHhpID0gbm9kZS54ICsgbm9kZS52eDtcclxuICAgICAgICB5aSA9IG5vZGUueSArIG5vZGUudnk7XHJcbiAgICAgICAgdHJlZS52aXNpdChhcHBseSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhcHBseShxdWFkLCB4MCwgeTAsIHgxLCB5MSkge1xyXG4gICAgICB2YXIgZGF0YSA9IHF1YWQuZGF0YSwgcmogPSBxdWFkLnIsIHIgPSByaSArIHJqO1xyXG4gICAgICBpZiAoZGF0YSkge1xyXG4gICAgICAgIGlmIChkYXRhLmluZGV4ID4gbm9kZS5pbmRleCkge1xyXG4gICAgICAgICAgdmFyIHggPSB4aSAtIGRhdGEueCAtIGRhdGEudngsXHJcbiAgICAgICAgICAgICAgeSA9IHlpIC0gZGF0YS55IC0gZGF0YS52eSxcclxuICAgICAgICAgICAgICBsID0geCAqIHggKyB5ICogeTtcclxuICAgICAgICAgIGlmIChsIDwgciAqIHIpIHtcclxuICAgICAgICAgICAgaWYgKHggPT09IDApIHggPSBqaWdnbGUoKSwgbCArPSB4ICogeDtcclxuICAgICAgICAgICAgaWYgKHkgPT09IDApIHkgPSBqaWdnbGUoKSwgbCArPSB5ICogeTtcclxuICAgICAgICAgICAgbCA9IChyIC0gKGwgPSBNYXRoLnNxcnQobCkpKSAvIGwgKiBzdHJlbmd0aDtcclxuICAgICAgICAgICAgbm9kZS52eCArPSAoeCAqPSBsKSAqIChyID0gKHJqICo9IHJqKSAvIChyaTIgKyByaikpO1xyXG4gICAgICAgICAgICBub2RlLnZ5ICs9ICh5ICo9IGwpICogcjtcclxuICAgICAgICAgICAgZGF0YS52eCAtPSB4ICogKHIgPSAxIC0gcik7XHJcbiAgICAgICAgICAgIGRhdGEudnkgLT0geSAqIHI7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4geDAgPiB4aSArIHIgfHwgeDEgPCB4aSAtIHIgfHwgeTAgPiB5aSArIHIgfHwgeTEgPCB5aSAtIHI7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBwcmVwYXJlKHF1YWQpIHtcclxuICAgIGlmIChxdWFkLmRhdGEpIHJldHVybiBxdWFkLnIgPSByYWRpaVtxdWFkLmRhdGEuaW5kZXhdO1xyXG4gICAgZm9yICh2YXIgaSA9IHF1YWQuciA9IDA7IGkgPCA0OyArK2kpIHtcclxuICAgICAgaWYgKHF1YWRbaV0gJiYgcXVhZFtpXS5yID4gcXVhZC5yKSB7XHJcbiAgICAgICAgcXVhZC5yID0gcXVhZFtpXS5yO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xyXG4gICAgaWYgKCFub2RlcykgcmV0dXJuO1xyXG4gICAgdmFyIGksIG4gPSBub2Rlcy5sZW5ndGgsIG5vZGU7XHJcbiAgICByYWRpaSA9IG5ldyBBcnJheShuKTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIG5vZGUgPSBub2Rlc1tpXSwgcmFkaWlbbm9kZS5pbmRleF0gPSArcmFkaXVzKG5vZGUsIGksIG5vZGVzKTtcclxuICB9XHJcblxyXG4gIGZvcmNlLmluaXRpYWxpemUgPSBmdW5jdGlvbihfKSB7XHJcbiAgICBub2RlcyA9IF87XHJcbiAgICBpbml0aWFsaXplKCk7XHJcbiAgfTtcclxuXHJcbiAgZm9yY2UuaXRlcmF0aW9ucyA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGl0ZXJhdGlvbnMgPSArXywgZm9yY2UpIDogaXRlcmF0aW9ucztcclxuICB9O1xyXG5cclxuICBmb3JjZS5zdHJlbmd0aCA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN0cmVuZ3RoID0gK18sIGZvcmNlKSA6IHN0cmVuZ3RoO1xyXG4gIH07XHJcblxyXG4gIGZvcmNlLnJhZGl1cyA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQkNygrXyksIGluaXRpYWxpemUoKSwgZm9yY2UpIDogcmFkaXVzO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBmb3JjZTtcclxufVxyXG5cclxuZnVuY3Rpb24gaW5kZXgoZCkge1xyXG4gIHJldHVybiBkLmluZGV4O1xyXG59XHJcblxyXG5mdW5jdGlvbiBmaW5kKG5vZGVCeUlkLCBub2RlSWQpIHtcclxuICB2YXIgbm9kZSA9IG5vZGVCeUlkLmdldChub2RlSWQpO1xyXG4gIGlmICghbm9kZSkgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZzogXCIgKyBub2RlSWQpO1xyXG4gIHJldHVybiBub2RlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBsaW5rKGxpbmtzKSB7XHJcbiAgdmFyIGlkID0gaW5kZXgsXHJcbiAgICAgIHN0cmVuZ3RoID0gZGVmYXVsdFN0cmVuZ3RoLFxyXG4gICAgICBzdHJlbmd0aHMsXHJcbiAgICAgIGRpc3RhbmNlID0gY29uc3RhbnQkNygzMCksXHJcbiAgICAgIGRpc3RhbmNlcyxcclxuICAgICAgbm9kZXMsXHJcbiAgICAgIGNvdW50LFxyXG4gICAgICBiaWFzLFxyXG4gICAgICBpdGVyYXRpb25zID0gMTtcclxuXHJcbiAgaWYgKGxpbmtzID09IG51bGwpIGxpbmtzID0gW107XHJcblxyXG4gIGZ1bmN0aW9uIGRlZmF1bHRTdHJlbmd0aChsaW5rKSB7XHJcbiAgICByZXR1cm4gMSAvIE1hdGgubWluKGNvdW50W2xpbmsuc291cmNlLmluZGV4XSwgY291bnRbbGluay50YXJnZXQuaW5kZXhdKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGZvcmNlKGFscGhhKSB7XHJcbiAgICBmb3IgKHZhciBrID0gMCwgbiA9IGxpbmtzLmxlbmd0aDsgayA8IGl0ZXJhdGlvbnM7ICsraykge1xyXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGluaywgc291cmNlLCB0YXJnZXQsIHgsIHksIGwsIGI7IGkgPCBuOyArK2kpIHtcclxuICAgICAgICBsaW5rID0gbGlua3NbaV0sIHNvdXJjZSA9IGxpbmsuc291cmNlLCB0YXJnZXQgPSBsaW5rLnRhcmdldDtcclxuICAgICAgICB4ID0gdGFyZ2V0LnggKyB0YXJnZXQudnggLSBzb3VyY2UueCAtIHNvdXJjZS52eCB8fCBqaWdnbGUoKTtcclxuICAgICAgICB5ID0gdGFyZ2V0LnkgKyB0YXJnZXQudnkgLSBzb3VyY2UueSAtIHNvdXJjZS52eSB8fCBqaWdnbGUoKTtcclxuICAgICAgICBsID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xyXG4gICAgICAgIGwgPSAobCAtIGRpc3RhbmNlc1tpXSkgLyBsICogYWxwaGEgKiBzdHJlbmd0aHNbaV07XHJcbiAgICAgICAgeCAqPSBsLCB5ICo9IGw7XHJcbiAgICAgICAgdGFyZ2V0LnZ4IC09IHggKiAoYiA9IGJpYXNbaV0pO1xyXG4gICAgICAgIHRhcmdldC52eSAtPSB5ICogYjtcclxuICAgICAgICBzb3VyY2UudnggKz0geCAqIChiID0gMSAtIGIpO1xyXG4gICAgICAgIHNvdXJjZS52eSArPSB5ICogYjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcclxuICAgIGlmICghbm9kZXMpIHJldHVybjtcclxuXHJcbiAgICB2YXIgaSxcclxuICAgICAgICBuID0gbm9kZXMubGVuZ3RoLFxyXG4gICAgICAgIG0gPSBsaW5rcy5sZW5ndGgsXHJcbiAgICAgICAgbm9kZUJ5SWQgPSBtYXAkMShub2RlcywgaWQpLFxyXG4gICAgICAgIGxpbms7XHJcblxyXG4gICAgZm9yIChpID0gMCwgY291bnQgPSBuZXcgQXJyYXkobik7IGkgPCBtOyArK2kpIHtcclxuICAgICAgbGluayA9IGxpbmtzW2ldLCBsaW5rLmluZGV4ID0gaTtcclxuICAgICAgaWYgKHR5cGVvZiBsaW5rLnNvdXJjZSAhPT0gXCJvYmplY3RcIikgbGluay5zb3VyY2UgPSBmaW5kKG5vZGVCeUlkLCBsaW5rLnNvdXJjZSk7XHJcbiAgICAgIGlmICh0eXBlb2YgbGluay50YXJnZXQgIT09IFwib2JqZWN0XCIpIGxpbmsudGFyZ2V0ID0gZmluZChub2RlQnlJZCwgbGluay50YXJnZXQpO1xyXG4gICAgICBjb3VudFtsaW5rLnNvdXJjZS5pbmRleF0gPSAoY291bnRbbGluay5zb3VyY2UuaW5kZXhdIHx8IDApICsgMTtcclxuICAgICAgY291bnRbbGluay50YXJnZXQuaW5kZXhdID0gKGNvdW50W2xpbmsudGFyZ2V0LmluZGV4XSB8fCAwKSArIDE7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChpID0gMCwgYmlhcyA9IG5ldyBBcnJheShtKTsgaSA8IG07ICsraSkge1xyXG4gICAgICBsaW5rID0gbGlua3NbaV0sIGJpYXNbaV0gPSBjb3VudFtsaW5rLnNvdXJjZS5pbmRleF0gLyAoY291bnRbbGluay5zb3VyY2UuaW5kZXhdICsgY291bnRbbGluay50YXJnZXQuaW5kZXhdKTtcclxuICAgIH1cclxuXHJcbiAgICBzdHJlbmd0aHMgPSBuZXcgQXJyYXkobSksIGluaXRpYWxpemVTdHJlbmd0aCgpO1xyXG4gICAgZGlzdGFuY2VzID0gbmV3IEFycmF5KG0pLCBpbml0aWFsaXplRGlzdGFuY2UoKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGluaXRpYWxpemVTdHJlbmd0aCgpIHtcclxuICAgIGlmICghbm9kZXMpIHJldHVybjtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IGxpbmtzLmxlbmd0aDsgaSA8IG47ICsraSkge1xyXG4gICAgICBzdHJlbmd0aHNbaV0gPSArc3RyZW5ndGgobGlua3NbaV0sIGksIGxpbmtzKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGluaXRpYWxpemVEaXN0YW5jZSgpIHtcclxuICAgIGlmICghbm9kZXMpIHJldHVybjtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IGxpbmtzLmxlbmd0aDsgaSA8IG47ICsraSkge1xyXG4gICAgICBkaXN0YW5jZXNbaV0gPSArZGlzdGFuY2UobGlua3NbaV0sIGksIGxpbmtzKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZvcmNlLmluaXRpYWxpemUgPSBmdW5jdGlvbihfKSB7XHJcbiAgICBub2RlcyA9IF87XHJcbiAgICBpbml0aWFsaXplKCk7XHJcbiAgfTtcclxuXHJcbiAgZm9yY2UubGlua3MgPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChsaW5rcyA9IF8sIGluaXRpYWxpemUoKSwgZm9yY2UpIDogbGlua3M7XHJcbiAgfTtcclxuXHJcbiAgZm9yY2UuaWQgPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpZCA9IF8sIGZvcmNlKSA6IGlkO1xyXG4gIH07XHJcblxyXG4gIGZvcmNlLml0ZXJhdGlvbnMgPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpdGVyYXRpb25zID0gK18sIGZvcmNlKSA6IGl0ZXJhdGlvbnM7XHJcbiAgfTtcclxuXHJcbiAgZm9yY2Uuc3RyZW5ndGggPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzdHJlbmd0aCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQkNygrXyksIGluaXRpYWxpemVTdHJlbmd0aCgpLCBmb3JjZSkgOiBzdHJlbmd0aDtcclxuICB9O1xyXG5cclxuICBmb3JjZS5kaXN0YW5jZSA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRpc3RhbmNlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCQ3KCtfKSwgaW5pdGlhbGl6ZURpc3RhbmNlKCksIGZvcmNlKSA6IGRpc3RhbmNlO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBmb3JjZTtcclxufVxyXG5cclxuZnVuY3Rpb24geCQxKGQpIHtcclxuICByZXR1cm4gZC54O1xyXG59XHJcblxyXG5mdW5jdGlvbiB5JDEoZCkge1xyXG4gIHJldHVybiBkLnk7XHJcbn1cclxuXHJcbnZhciBpbml0aWFsUmFkaXVzID0gMTAsXHJcbiAgICBpbml0aWFsQW5nbGUgPSBNYXRoLlBJICogKDMgLSBNYXRoLnNxcnQoNSkpO1xyXG5cclxuZnVuY3Rpb24gc2ltdWxhdGlvbihub2Rlcykge1xyXG4gIHZhciBzaW11bGF0aW9uLFxyXG4gICAgICBhbHBoYSA9IDEsXHJcbiAgICAgIGFscGhhTWluID0gMC4wMDEsXHJcbiAgICAgIGFscGhhRGVjYXkgPSAxIC0gTWF0aC5wb3coYWxwaGFNaW4sIDEgLyAzMDApLFxyXG4gICAgICBhbHBoYVRhcmdldCA9IDAsXHJcbiAgICAgIHZlbG9jaXR5RGVjYXkgPSAwLjYsXHJcbiAgICAgIGZvcmNlcyA9IG1hcCQxKCksXHJcbiAgICAgIHN0ZXBwZXIgPSB0aW1lcihzdGVwKSxcclxuICAgICAgZXZlbnQgPSBkaXNwYXRjaChcInRpY2tcIiwgXCJlbmRcIik7XHJcblxyXG4gIGlmIChub2RlcyA9PSBudWxsKSBub2RlcyA9IFtdO1xyXG5cclxuICBmdW5jdGlvbiBzdGVwKCkge1xyXG4gICAgdGljaygpO1xyXG4gICAgZXZlbnQuY2FsbChcInRpY2tcIiwgc2ltdWxhdGlvbik7XHJcbiAgICBpZiAoYWxwaGEgPCBhbHBoYU1pbikge1xyXG4gICAgICBzdGVwcGVyLnN0b3AoKTtcclxuICAgICAgZXZlbnQuY2FsbChcImVuZFwiLCBzaW11bGF0aW9uKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHRpY2soKSB7XHJcbiAgICB2YXIgaSwgbiA9IG5vZGVzLmxlbmd0aCwgbm9kZTtcclxuXHJcbiAgICBhbHBoYSArPSAoYWxwaGFUYXJnZXQgLSBhbHBoYSkgKiBhbHBoYURlY2F5O1xyXG5cclxuICAgIGZvcmNlcy5lYWNoKGZ1bmN0aW9uKGZvcmNlKSB7XHJcbiAgICAgIGZvcmNlKGFscGhhKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcclxuICAgICAgbm9kZSA9IG5vZGVzW2ldO1xyXG4gICAgICBpZiAobm9kZS5meCA9PSBudWxsKSBub2RlLnggKz0gbm9kZS52eCAqPSB2ZWxvY2l0eURlY2F5O1xyXG4gICAgICBlbHNlIG5vZGUueCA9IG5vZGUuZngsIG5vZGUudnggPSAwO1xyXG4gICAgICBpZiAobm9kZS5meSA9PSBudWxsKSBub2RlLnkgKz0gbm9kZS52eSAqPSB2ZWxvY2l0eURlY2F5O1xyXG4gICAgICBlbHNlIG5vZGUueSA9IG5vZGUuZnksIG5vZGUudnkgPSAwO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZU5vZGVzKCkge1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBub2Rlcy5sZW5ndGgsIG5vZGU7IGkgPCBuOyArK2kpIHtcclxuICAgICAgbm9kZSA9IG5vZGVzW2ldLCBub2RlLmluZGV4ID0gaTtcclxuICAgICAgaWYgKGlzTmFOKG5vZGUueCkgfHwgaXNOYU4obm9kZS55KSkge1xyXG4gICAgICAgIHZhciByYWRpdXMgPSBpbml0aWFsUmFkaXVzICogTWF0aC5zcXJ0KGkpLCBhbmdsZSA9IGkgKiBpbml0aWFsQW5nbGU7XHJcbiAgICAgICAgbm9kZS54ID0gcmFkaXVzICogTWF0aC5jb3MoYW5nbGUpO1xyXG4gICAgICAgIG5vZGUueSA9IHJhZGl1cyAqIE1hdGguc2luKGFuZ2xlKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoaXNOYU4obm9kZS52eCkgfHwgaXNOYU4obm9kZS52eSkpIHtcclxuICAgICAgICBub2RlLnZ4ID0gbm9kZS52eSA9IDA7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGluaXRpYWxpemVGb3JjZShmb3JjZSkge1xyXG4gICAgaWYgKGZvcmNlLmluaXRpYWxpemUpIGZvcmNlLmluaXRpYWxpemUobm9kZXMpO1xyXG4gICAgcmV0dXJuIGZvcmNlO1xyXG4gIH1cclxuXHJcbiAgaW5pdGlhbGl6ZU5vZGVzKCk7XHJcblxyXG4gIHJldHVybiBzaW11bGF0aW9uID0ge1xyXG4gICAgdGljazogdGljayxcclxuXHJcbiAgICByZXN0YXJ0OiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIHN0ZXBwZXIucmVzdGFydChzdGVwKSwgc2ltdWxhdGlvbjtcclxuICAgIH0sXHJcblxyXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiBzdGVwcGVyLnN0b3AoKSwgc2ltdWxhdGlvbjtcclxuICAgIH0sXHJcblxyXG4gICAgbm9kZXM6IGZ1bmN0aW9uKF8pIHtcclxuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobm9kZXMgPSBfLCBpbml0aWFsaXplTm9kZXMoKSwgZm9yY2VzLmVhY2goaW5pdGlhbGl6ZUZvcmNlKSwgc2ltdWxhdGlvbikgOiBub2RlcztcclxuICAgIH0sXHJcblxyXG4gICAgYWxwaGE6IGZ1bmN0aW9uKF8pIHtcclxuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYWxwaGEgPSArXywgc2ltdWxhdGlvbikgOiBhbHBoYTtcclxuICAgIH0sXHJcblxyXG4gICAgYWxwaGFNaW46IGZ1bmN0aW9uKF8pIHtcclxuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYWxwaGFNaW4gPSArXywgc2ltdWxhdGlvbikgOiBhbHBoYU1pbjtcclxuICAgIH0sXHJcblxyXG4gICAgYWxwaGFEZWNheTogZnVuY3Rpb24oXykge1xyXG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChhbHBoYURlY2F5ID0gK18sIHNpbXVsYXRpb24pIDogK2FscGhhRGVjYXk7XHJcbiAgICB9LFxyXG5cclxuICAgIGFscGhhVGFyZ2V0OiBmdW5jdGlvbihfKSB7XHJcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGFscGhhVGFyZ2V0ID0gK18sIHNpbXVsYXRpb24pIDogYWxwaGFUYXJnZXQ7XHJcbiAgICB9LFxyXG5cclxuICAgIHZlbG9jaXR5RGVjYXk6IGZ1bmN0aW9uKF8pIHtcclxuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodmVsb2NpdHlEZWNheSA9IDEgLSBfLCBzaW11bGF0aW9uKSA6IDEgLSB2ZWxvY2l0eURlY2F5O1xyXG4gICAgfSxcclxuXHJcbiAgICBmb3JjZTogZnVuY3Rpb24obmFtZSwgXykge1xyXG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyAoXyA9PSBudWxsID8gZm9yY2VzLnJlbW92ZShuYW1lKSA6IGZvcmNlcy5zZXQobmFtZSwgaW5pdGlhbGl6ZUZvcmNlKF8pKSwgc2ltdWxhdGlvbikgOiBmb3JjZXMuZ2V0KG5hbWUpO1xyXG4gICAgfSxcclxuXHJcbiAgICBmaW5kOiBmdW5jdGlvbih4LCB5LCByYWRpdXMpIHtcclxuICAgICAgdmFyIGkgPSAwLFxyXG4gICAgICAgICAgbiA9IG5vZGVzLmxlbmd0aCxcclxuICAgICAgICAgIGR4LFxyXG4gICAgICAgICAgZHksXHJcbiAgICAgICAgICBkMixcclxuICAgICAgICAgIG5vZGUsXHJcbiAgICAgICAgICBjbG9zZXN0O1xyXG5cclxuICAgICAgaWYgKHJhZGl1cyA9PSBudWxsKSByYWRpdXMgPSBJbmZpbml0eTtcclxuICAgICAgZWxzZSByYWRpdXMgKj0gcmFkaXVzO1xyXG5cclxuICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xyXG4gICAgICAgIG5vZGUgPSBub2Rlc1tpXTtcclxuICAgICAgICBkeCA9IHggLSBub2RlLng7XHJcbiAgICAgICAgZHkgPSB5IC0gbm9kZS55O1xyXG4gICAgICAgIGQyID0gZHggKiBkeCArIGR5ICogZHk7XHJcbiAgICAgICAgaWYgKGQyIDwgcmFkaXVzKSBjbG9zZXN0ID0gbm9kZSwgcmFkaXVzID0gZDI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBjbG9zZXN0O1xyXG4gICAgfSxcclxuXHJcbiAgICBvbjogZnVuY3Rpb24obmFtZSwgXykge1xyXG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyAoZXZlbnQub24obmFtZSwgXyksIHNpbXVsYXRpb24pIDogZXZlbnQub24obmFtZSk7XHJcbiAgICB9XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gbWFueUJvZHkoKSB7XHJcbiAgdmFyIG5vZGVzLFxyXG4gICAgICBub2RlLFxyXG4gICAgICBhbHBoYSxcclxuICAgICAgc3RyZW5ndGggPSBjb25zdGFudCQ3KC0zMCksXHJcbiAgICAgIHN0cmVuZ3RocyxcclxuICAgICAgZGlzdGFuY2VNaW4yID0gMSxcclxuICAgICAgZGlzdGFuY2VNYXgyID0gSW5maW5pdHksXHJcbiAgICAgIHRoZXRhMiA9IDAuODE7XHJcblxyXG4gIGZ1bmN0aW9uIGZvcmNlKF8pIHtcclxuICAgIHZhciBpLCBuID0gbm9kZXMubGVuZ3RoLCB0cmVlID0gcXVhZHRyZWUobm9kZXMsIHgkMSwgeSQxKS52aXNpdEFmdGVyKGFjY3VtdWxhdGUpO1xyXG4gICAgZm9yIChhbHBoYSA9IF8sIGkgPSAwOyBpIDwgbjsgKytpKSBub2RlID0gbm9kZXNbaV0sIHRyZWUudmlzaXQoYXBwbHkpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcclxuICAgIGlmICghbm9kZXMpIHJldHVybjtcclxuICAgIHZhciBpLCBuID0gbm9kZXMubGVuZ3RoLCBub2RlO1xyXG4gICAgc3RyZW5ndGhzID0gbmV3IEFycmF5KG4pO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkgbm9kZSA9IG5vZGVzW2ldLCBzdHJlbmd0aHNbbm9kZS5pbmRleF0gPSArc3RyZW5ndGgobm9kZSwgaSwgbm9kZXMpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gYWNjdW11bGF0ZShxdWFkKSB7XHJcbiAgICB2YXIgc3RyZW5ndGggPSAwLCBxLCBjLCB3ZWlnaHQgPSAwLCB4LCB5LCBpO1xyXG5cclxuICAgIC8vIEZvciBpbnRlcm5hbCBub2RlcywgYWNjdW11bGF0ZSBmb3JjZXMgZnJvbSBjaGlsZCBxdWFkcmFudHMuXHJcbiAgICBpZiAocXVhZC5sZW5ndGgpIHtcclxuICAgICAgZm9yICh4ID0geSA9IGkgPSAwOyBpIDwgNDsgKytpKSB7XHJcbiAgICAgICAgaWYgKChxID0gcXVhZFtpXSkgJiYgKGMgPSBNYXRoLmFicyhxLnZhbHVlKSkpIHtcclxuICAgICAgICAgIHN0cmVuZ3RoICs9IHEudmFsdWUsIHdlaWdodCArPSBjLCB4ICs9IGMgKiBxLngsIHkgKz0gYyAqIHEueTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcXVhZC54ID0geCAvIHdlaWdodDtcclxuICAgICAgcXVhZC55ID0geSAvIHdlaWdodDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBGb3IgbGVhZiBub2RlcywgYWNjdW11bGF0ZSBmb3JjZXMgZnJvbSBjb2luY2lkZW50IHF1YWRyYW50cy5cclxuICAgIGVsc2Uge1xyXG4gICAgICBxID0gcXVhZDtcclxuICAgICAgcS54ID0gcS5kYXRhLng7XHJcbiAgICAgIHEueSA9IHEuZGF0YS55O1xyXG4gICAgICBkbyBzdHJlbmd0aCArPSBzdHJlbmd0aHNbcS5kYXRhLmluZGV4XTtcclxuICAgICAgd2hpbGUgKHEgPSBxLm5leHQpO1xyXG4gICAgfVxyXG5cclxuICAgIHF1YWQudmFsdWUgPSBzdHJlbmd0aDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGFwcGx5KHF1YWQsIHgxLCBfLCB4Mikge1xyXG4gICAgaWYgKCFxdWFkLnZhbHVlKSByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICB2YXIgeCA9IHF1YWQueCAtIG5vZGUueCxcclxuICAgICAgICB5ID0gcXVhZC55IC0gbm9kZS55LFxyXG4gICAgICAgIHcgPSB4MiAtIHgxLFxyXG4gICAgICAgIGwgPSB4ICogeCArIHkgKiB5O1xyXG5cclxuICAgIC8vIEFwcGx5IHRoZSBCYXJuZXMtSHV0IGFwcHJveGltYXRpb24gaWYgcG9zc2libGUuXHJcbiAgICAvLyBMaW1pdCBmb3JjZXMgZm9yIHZlcnkgY2xvc2Ugbm9kZXM7IHJhbmRvbWl6ZSBkaXJlY3Rpb24gaWYgY29pbmNpZGVudC5cclxuICAgIGlmICh3ICogdyAvIHRoZXRhMiA8IGwpIHtcclxuICAgICAgaWYgKGwgPCBkaXN0YW5jZU1heDIpIHtcclxuICAgICAgICBpZiAoeCA9PT0gMCkgeCA9IGppZ2dsZSgpLCBsICs9IHggKiB4O1xyXG4gICAgICAgIGlmICh5ID09PSAwKSB5ID0gamlnZ2xlKCksIGwgKz0geSAqIHk7XHJcbiAgICAgICAgaWYgKGwgPCBkaXN0YW5jZU1pbjIpIGwgPSBNYXRoLnNxcnQoZGlzdGFuY2VNaW4yICogbCk7XHJcbiAgICAgICAgbm9kZS52eCArPSB4ICogcXVhZC52YWx1ZSAqIGFscGhhIC8gbDtcclxuICAgICAgICBub2RlLnZ5ICs9IHkgKiBxdWFkLnZhbHVlICogYWxwaGEgLyBsO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE90aGVyd2lzZSwgcHJvY2VzcyBwb2ludHMgZGlyZWN0bHkuXHJcbiAgICBlbHNlIGlmIChxdWFkLmxlbmd0aCB8fCBsID49IGRpc3RhbmNlTWF4MikgcmV0dXJuO1xyXG5cclxuICAgIC8vIExpbWl0IGZvcmNlcyBmb3IgdmVyeSBjbG9zZSBub2RlczsgcmFuZG9taXplIGRpcmVjdGlvbiBpZiBjb2luY2lkZW50LlxyXG4gICAgaWYgKHF1YWQuZGF0YSAhPT0gbm9kZSB8fCBxdWFkLm5leHQpIHtcclxuICAgICAgaWYgKHggPT09IDApIHggPSBqaWdnbGUoKSwgbCArPSB4ICogeDtcclxuICAgICAgaWYgKHkgPT09IDApIHkgPSBqaWdnbGUoKSwgbCArPSB5ICogeTtcclxuICAgICAgaWYgKGwgPCBkaXN0YW5jZU1pbjIpIGwgPSBNYXRoLnNxcnQoZGlzdGFuY2VNaW4yICogbCk7XHJcbiAgICB9XHJcblxyXG4gICAgZG8gaWYgKHF1YWQuZGF0YSAhPT0gbm9kZSkge1xyXG4gICAgICB3ID0gc3RyZW5ndGhzW3F1YWQuZGF0YS5pbmRleF0gKiBhbHBoYSAvIGw7XHJcbiAgICAgIG5vZGUudnggKz0geCAqIHc7XHJcbiAgICAgIG5vZGUudnkgKz0geSAqIHc7XHJcbiAgICB9IHdoaWxlIChxdWFkID0gcXVhZC5uZXh0KTtcclxuICB9XHJcblxyXG4gIGZvcmNlLmluaXRpYWxpemUgPSBmdW5jdGlvbihfKSB7XHJcbiAgICBub2RlcyA9IF87XHJcbiAgICBpbml0aWFsaXplKCk7XHJcbiAgfTtcclxuXHJcbiAgZm9yY2Uuc3RyZW5ndGggPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzdHJlbmd0aCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQkNygrXyksIGluaXRpYWxpemUoKSwgZm9yY2UpIDogc3RyZW5ndGg7XHJcbiAgfTtcclxuXHJcbiAgZm9yY2UuZGlzdGFuY2VNaW4gPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkaXN0YW5jZU1pbjIgPSBfICogXywgZm9yY2UpIDogTWF0aC5zcXJ0KGRpc3RhbmNlTWluMik7XHJcbiAgfTtcclxuXHJcbiAgZm9yY2UuZGlzdGFuY2VNYXggPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkaXN0YW5jZU1heDIgPSBfICogXywgZm9yY2UpIDogTWF0aC5zcXJ0KGRpc3RhbmNlTWF4Mik7XHJcbiAgfTtcclxuXHJcbiAgZm9yY2UudGhldGEgPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aGV0YTIgPSBfICogXywgZm9yY2UpIDogTWF0aC5zcXJ0KHRoZXRhMik7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIGZvcmNlO1xyXG59XHJcblxyXG5mdW5jdGlvbiByYWRpYWwocmFkaXVzLCB4LCB5KSB7XHJcbiAgdmFyIG5vZGVzLFxyXG4gICAgICBzdHJlbmd0aCA9IGNvbnN0YW50JDcoMC4xKSxcclxuICAgICAgc3RyZW5ndGhzLFxyXG4gICAgICByYWRpdXNlcztcclxuXHJcbiAgaWYgKHR5cGVvZiByYWRpdXMgIT09IFwiZnVuY3Rpb25cIikgcmFkaXVzID0gY29uc3RhbnQkNygrcmFkaXVzKTtcclxuICBpZiAoeCA9PSBudWxsKSB4ID0gMDtcclxuICBpZiAoeSA9PSBudWxsKSB5ID0gMDtcclxuXHJcbiAgZnVuY3Rpb24gZm9yY2UoYWxwaGEpIHtcclxuICAgIGZvciAodmFyIGkgPSAwLCBuID0gbm9kZXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgIHZhciBub2RlID0gbm9kZXNbaV0sXHJcbiAgICAgICAgICBkeCA9IG5vZGUueCAtIHggfHwgMWUtNixcclxuICAgICAgICAgIGR5ID0gbm9kZS55IC0geSB8fCAxZS02LFxyXG4gICAgICAgICAgciA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSksXHJcbiAgICAgICAgICBrID0gKHJhZGl1c2VzW2ldIC0gcikgKiBzdHJlbmd0aHNbaV0gKiBhbHBoYSAvIHI7XHJcbiAgICAgIG5vZGUudnggKz0gZHggKiBrO1xyXG4gICAgICBub2RlLnZ5ICs9IGR5ICogaztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XHJcbiAgICBpZiAoIW5vZGVzKSByZXR1cm47XHJcbiAgICB2YXIgaSwgbiA9IG5vZGVzLmxlbmd0aDtcclxuICAgIHN0cmVuZ3RocyA9IG5ldyBBcnJheShuKTtcclxuICAgIHJhZGl1c2VzID0gbmV3IEFycmF5KG4pO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xyXG4gICAgICByYWRpdXNlc1tpXSA9ICtyYWRpdXMobm9kZXNbaV0sIGksIG5vZGVzKTtcclxuICAgICAgc3RyZW5ndGhzW2ldID0gaXNOYU4ocmFkaXVzZXNbaV0pID8gMCA6ICtzdHJlbmd0aChub2Rlc1tpXSwgaSwgbm9kZXMpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZm9yY2UuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIG5vZGVzID0gXywgaW5pdGlhbGl6ZSgpO1xyXG4gIH07XHJcblxyXG4gIGZvcmNlLnN0cmVuZ3RoID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3RyZW5ndGggPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50JDcoK18pLCBpbml0aWFsaXplKCksIGZvcmNlKSA6IHN0cmVuZ3RoO1xyXG4gIH07XHJcblxyXG4gIGZvcmNlLnJhZGl1cyA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQkNygrXyksIGluaXRpYWxpemUoKSwgZm9yY2UpIDogcmFkaXVzO1xyXG4gIH07XHJcblxyXG4gIGZvcmNlLnggPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4ID0gK18sIGZvcmNlKSA6IHg7XHJcbiAgfTtcclxuXHJcbiAgZm9yY2UueSA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkgPSArXywgZm9yY2UpIDogeTtcclxuICB9O1xyXG5cclxuICByZXR1cm4gZm9yY2U7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHgkMih4KSB7XHJcbiAgdmFyIHN0cmVuZ3RoID0gY29uc3RhbnQkNygwLjEpLFxyXG4gICAgICBub2RlcyxcclxuICAgICAgc3RyZW5ndGhzLFxyXG4gICAgICB4ejtcclxuXHJcbiAgaWYgKHR5cGVvZiB4ICE9PSBcImZ1bmN0aW9uXCIpIHggPSBjb25zdGFudCQ3KHggPT0gbnVsbCA/IDAgOiAreCk7XHJcblxyXG4gIGZ1bmN0aW9uIGZvcmNlKGFscGhhKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IG5vZGVzLmxlbmd0aCwgbm9kZTsgaSA8IG47ICsraSkge1xyXG4gICAgICBub2RlID0gbm9kZXNbaV0sIG5vZGUudnggKz0gKHh6W2ldIC0gbm9kZS54KSAqIHN0cmVuZ3Roc1tpXSAqIGFscGhhO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcclxuICAgIGlmICghbm9kZXMpIHJldHVybjtcclxuICAgIHZhciBpLCBuID0gbm9kZXMubGVuZ3RoO1xyXG4gICAgc3RyZW5ndGhzID0gbmV3IEFycmF5KG4pO1xyXG4gICAgeHogPSBuZXcgQXJyYXkobik7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgIHN0cmVuZ3Roc1tpXSA9IGlzTmFOKHh6W2ldID0gK3gobm9kZXNbaV0sIGksIG5vZGVzKSkgPyAwIDogK3N0cmVuZ3RoKG5vZGVzW2ldLCBpLCBub2Rlcyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmb3JjZS5pbml0aWFsaXplID0gZnVuY3Rpb24oXykge1xyXG4gICAgbm9kZXMgPSBfO1xyXG4gICAgaW5pdGlhbGl6ZSgpO1xyXG4gIH07XHJcblxyXG4gIGZvcmNlLnN0cmVuZ3RoID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3RyZW5ndGggPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50JDcoK18pLCBpbml0aWFsaXplKCksIGZvcmNlKSA6IHN0cmVuZ3RoO1xyXG4gIH07XHJcblxyXG4gIGZvcmNlLnggPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4ID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCQ3KCtfKSwgaW5pdGlhbGl6ZSgpLCBmb3JjZSkgOiB4O1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBmb3JjZTtcclxufVxyXG5cclxuZnVuY3Rpb24geSQyKHkpIHtcclxuICB2YXIgc3RyZW5ndGggPSBjb25zdGFudCQ3KDAuMSksXHJcbiAgICAgIG5vZGVzLFxyXG4gICAgICBzdHJlbmd0aHMsXHJcbiAgICAgIHl6O1xyXG5cclxuICBpZiAodHlwZW9mIHkgIT09IFwiZnVuY3Rpb25cIikgeSA9IGNvbnN0YW50JDcoeSA9PSBudWxsID8gMCA6ICt5KTtcclxuXHJcbiAgZnVuY3Rpb24gZm9yY2UoYWxwaGEpIHtcclxuICAgIGZvciAodmFyIGkgPSAwLCBuID0gbm9kZXMubGVuZ3RoLCBub2RlOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgIG5vZGUgPSBub2Rlc1tpXSwgbm9kZS52eSArPSAoeXpbaV0gLSBub2RlLnkpICogc3RyZW5ndGhzW2ldICogYWxwaGE7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xyXG4gICAgaWYgKCFub2RlcykgcmV0dXJuO1xyXG4gICAgdmFyIGksIG4gPSBub2Rlcy5sZW5ndGg7XHJcbiAgICBzdHJlbmd0aHMgPSBuZXcgQXJyYXkobik7XHJcbiAgICB5eiA9IG5ldyBBcnJheShuKTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcclxuICAgICAgc3RyZW5ndGhzW2ldID0gaXNOYU4oeXpbaV0gPSAreShub2Rlc1tpXSwgaSwgbm9kZXMpKSA/IDAgOiArc3RyZW5ndGgobm9kZXNbaV0sIGksIG5vZGVzKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZvcmNlLmluaXRpYWxpemUgPSBmdW5jdGlvbihfKSB7XHJcbiAgICBub2RlcyA9IF87XHJcbiAgICBpbml0aWFsaXplKCk7XHJcbiAgfTtcclxuXHJcbiAgZm9yY2Uuc3RyZW5ndGggPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzdHJlbmd0aCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQkNygrXyksIGluaXRpYWxpemUoKSwgZm9yY2UpIDogc3RyZW5ndGg7XHJcbiAgfTtcclxuXHJcbiAgZm9yY2UueSA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50JDcoK18pLCBpbml0aWFsaXplKCksIGZvcmNlKSA6IHk7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIGZvcmNlO1xyXG59XHJcblxyXG4vLyBDb21wdXRlcyB0aGUgZGVjaW1hbCBjb2VmZmljaWVudCBhbmQgZXhwb25lbnQgb2YgdGhlIHNwZWNpZmllZCBudW1iZXIgeCB3aXRoXHJcbi8vIHNpZ25pZmljYW50IGRpZ2l0cyBwLCB3aGVyZSB4IGlzIHBvc2l0aXZlIGFuZCBwIGlzIGluIFsxLCAyMV0gb3IgdW5kZWZpbmVkLlxyXG4vLyBGb3IgZXhhbXBsZSwgZm9ybWF0RGVjaW1hbCgxLjIzKSByZXR1cm5zIFtcIjEyM1wiLCAwXS5cclxuZnVuY3Rpb24gZm9ybWF0RGVjaW1hbCh4LCBwKSB7XHJcbiAgaWYgKChpID0gKHggPSBwID8geC50b0V4cG9uZW50aWFsKHAgLSAxKSA6IHgudG9FeHBvbmVudGlhbCgpKS5pbmRleE9mKFwiZVwiKSkgPCAwKSByZXR1cm4gbnVsbDsgLy8gTmFOLCDCsUluZmluaXR5XHJcbiAgdmFyIGksIGNvZWZmaWNpZW50ID0geC5zbGljZSgwLCBpKTtcclxuXHJcbiAgLy8gVGhlIHN0cmluZyByZXR1cm5lZCBieSB0b0V4cG9uZW50aWFsIGVpdGhlciBoYXMgdGhlIGZvcm0gXFxkXFwuXFxkK2VbLStdXFxkK1xyXG4gIC8vIChlLmcuLCAxLjJlKzMpIG9yIHRoZSBmb3JtIFxcZGVbLStdXFxkKyAoZS5nLiwgMWUrMykuXHJcbiAgcmV0dXJuIFtcclxuICAgIGNvZWZmaWNpZW50Lmxlbmd0aCA+IDEgPyBjb2VmZmljaWVudFswXSArIGNvZWZmaWNpZW50LnNsaWNlKDIpIDogY29lZmZpY2llbnQsXHJcbiAgICAreC5zbGljZShpICsgMSlcclxuICBdO1xyXG59XHJcblxyXG5mdW5jdGlvbiBleHBvbmVudCQxKHgpIHtcclxuICByZXR1cm4geCA9IGZvcm1hdERlY2ltYWwoTWF0aC5hYnMoeCkpLCB4ID8geFsxXSA6IE5hTjtcclxufVxyXG5cclxuZnVuY3Rpb24gZm9ybWF0R3JvdXAoZ3JvdXBpbmcsIHRob3VzYW5kcykge1xyXG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgd2lkdGgpIHtcclxuICAgIHZhciBpID0gdmFsdWUubGVuZ3RoLFxyXG4gICAgICAgIHQgPSBbXSxcclxuICAgICAgICBqID0gMCxcclxuICAgICAgICBnID0gZ3JvdXBpbmdbMF0sXHJcbiAgICAgICAgbGVuZ3RoID0gMDtcclxuXHJcbiAgICB3aGlsZSAoaSA+IDAgJiYgZyA+IDApIHtcclxuICAgICAgaWYgKGxlbmd0aCArIGcgKyAxID4gd2lkdGgpIGcgPSBNYXRoLm1heCgxLCB3aWR0aCAtIGxlbmd0aCk7XHJcbiAgICAgIHQucHVzaCh2YWx1ZS5zdWJzdHJpbmcoaSAtPSBnLCBpICsgZykpO1xyXG4gICAgICBpZiAoKGxlbmd0aCArPSBnICsgMSkgPiB3aWR0aCkgYnJlYWs7XHJcbiAgICAgIGcgPSBncm91cGluZ1tqID0gKGogKyAxKSAlIGdyb3VwaW5nLmxlbmd0aF07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHQucmV2ZXJzZSgpLmpvaW4odGhvdXNhbmRzKTtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBmb3JtYXROdW1lcmFscyhudW1lcmFscykge1xyXG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL1swLTldL2csIGZ1bmN0aW9uKGkpIHtcclxuICAgICAgcmV0dXJuIG51bWVyYWxzWytpXTtcclxuICAgIH0pO1xyXG4gIH07XHJcbn1cclxuXHJcbi8vIFtbZmlsbF1hbGlnbl1bc2lnbl1bc3ltYm9sXVswXVt3aWR0aF1bLF1bLnByZWNpc2lvbl1bfl1bdHlwZV1cclxudmFyIHJlID0gL14oPzooLik/KFs8Pj1eXSkpPyhbK1xcLVxcKCBdKT8oWyQjXSk/KDApPyhcXGQrKT8oLCk/KFxcLlxcZCspPyh+KT8oW2EteiVdKT8kL2k7XHJcblxyXG5mdW5jdGlvbiBmb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyKSB7XHJcbiAgcmV0dXJuIG5ldyBGb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyKTtcclxufVxyXG5cclxuZm9ybWF0U3BlY2lmaWVyLnByb3RvdHlwZSA9IEZvcm1hdFNwZWNpZmllci5wcm90b3R5cGU7IC8vIGluc3RhbmNlb2ZcclxuXHJcbmZ1bmN0aW9uIEZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIpIHtcclxuICBpZiAoIShtYXRjaCA9IHJlLmV4ZWMoc3BlY2lmaWVyKSkpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZm9ybWF0OiBcIiArIHNwZWNpZmllcik7XHJcbiAgdmFyIG1hdGNoO1xyXG4gIHRoaXMuZmlsbCA9IG1hdGNoWzFdIHx8IFwiIFwiO1xyXG4gIHRoaXMuYWxpZ24gPSBtYXRjaFsyXSB8fCBcIj5cIjtcclxuICB0aGlzLnNpZ24gPSBtYXRjaFszXSB8fCBcIi1cIjtcclxuICB0aGlzLnN5bWJvbCA9IG1hdGNoWzRdIHx8IFwiXCI7XHJcbiAgdGhpcy56ZXJvID0gISFtYXRjaFs1XTtcclxuICB0aGlzLndpZHRoID0gbWF0Y2hbNl0gJiYgK21hdGNoWzZdO1xyXG4gIHRoaXMuY29tbWEgPSAhIW1hdGNoWzddO1xyXG4gIHRoaXMucHJlY2lzaW9uID0gbWF0Y2hbOF0gJiYgK21hdGNoWzhdLnNsaWNlKDEpO1xyXG4gIHRoaXMudHJpbSA9ICEhbWF0Y2hbOV07XHJcbiAgdGhpcy50eXBlID0gbWF0Y2hbMTBdIHx8IFwiXCI7XHJcbn1cclxuXHJcbkZvcm1hdFNwZWNpZmllci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gdGhpcy5maWxsXHJcbiAgICAgICsgdGhpcy5hbGlnblxyXG4gICAgICArIHRoaXMuc2lnblxyXG4gICAgICArIHRoaXMuc3ltYm9sXHJcbiAgICAgICsgKHRoaXMuemVybyA/IFwiMFwiIDogXCJcIilcclxuICAgICAgKyAodGhpcy53aWR0aCA9PSBudWxsID8gXCJcIiA6IE1hdGgubWF4KDEsIHRoaXMud2lkdGggfCAwKSlcclxuICAgICAgKyAodGhpcy5jb21tYSA/IFwiLFwiIDogXCJcIilcclxuICAgICAgKyAodGhpcy5wcmVjaXNpb24gPT0gbnVsbCA/IFwiXCIgOiBcIi5cIiArIE1hdGgubWF4KDAsIHRoaXMucHJlY2lzaW9uIHwgMCkpXHJcbiAgICAgICsgKHRoaXMudHJpbSA/IFwiflwiIDogXCJcIilcclxuICAgICAgKyB0aGlzLnR5cGU7XHJcbn07XHJcblxyXG4vLyBUcmltcyBpbnNpZ25pZmljYW50IHplcm9zLCBlLmcuLCByZXBsYWNlcyAxLjIwMDBrIHdpdGggMS4yay5cclxuZnVuY3Rpb24gZm9ybWF0VHJpbShzKSB7XHJcbiAgb3V0OiBmb3IgKHZhciBuID0gcy5sZW5ndGgsIGkgPSAxLCBpMCA9IC0xLCBpMTsgaSA8IG47ICsraSkge1xyXG4gICAgc3dpdGNoIChzW2ldKSB7XHJcbiAgICAgIGNhc2UgXCIuXCI6IGkwID0gaTEgPSBpOyBicmVhaztcclxuICAgICAgY2FzZSBcIjBcIjogaWYgKGkwID09PSAwKSBpMCA9IGk7IGkxID0gaTsgYnJlYWs7XHJcbiAgICAgIGRlZmF1bHQ6IGlmIChpMCA+IDApIHsgaWYgKCErc1tpXSkgYnJlYWsgb3V0OyBpMCA9IDA7IH0gYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBpMCA+IDAgPyBzLnNsaWNlKDAsIGkwKSArIHMuc2xpY2UoaTEgKyAxKSA6IHM7XHJcbn1cclxuXHJcbnZhciBwcmVmaXhFeHBvbmVudDtcclxuXHJcbmZ1bmN0aW9uIGZvcm1hdFByZWZpeEF1dG8oeCwgcCkge1xyXG4gIHZhciBkID0gZm9ybWF0RGVjaW1hbCh4LCBwKTtcclxuICBpZiAoIWQpIHJldHVybiB4ICsgXCJcIjtcclxuICB2YXIgY29lZmZpY2llbnQgPSBkWzBdLFxyXG4gICAgICBleHBvbmVudCA9IGRbMV0sXHJcbiAgICAgIGkgPSBleHBvbmVudCAtIChwcmVmaXhFeHBvbmVudCA9IE1hdGgubWF4KC04LCBNYXRoLm1pbig4LCBNYXRoLmZsb29yKGV4cG9uZW50IC8gMykpKSAqIDMpICsgMSxcclxuICAgICAgbiA9IGNvZWZmaWNpZW50Lmxlbmd0aDtcclxuICByZXR1cm4gaSA9PT0gbiA/IGNvZWZmaWNpZW50XHJcbiAgICAgIDogaSA+IG4gPyBjb2VmZmljaWVudCArIG5ldyBBcnJheShpIC0gbiArIDEpLmpvaW4oXCIwXCIpXHJcbiAgICAgIDogaSA+IDAgPyBjb2VmZmljaWVudC5zbGljZSgwLCBpKSArIFwiLlwiICsgY29lZmZpY2llbnQuc2xpY2UoaSlcclxuICAgICAgOiBcIjAuXCIgKyBuZXcgQXJyYXkoMSAtIGkpLmpvaW4oXCIwXCIpICsgZm9ybWF0RGVjaW1hbCh4LCBNYXRoLm1heCgwLCBwICsgaSAtIDEpKVswXTsgLy8gbGVzcyB0aGFuIDF5IVxyXG59XHJcblxyXG5mdW5jdGlvbiBmb3JtYXRSb3VuZGVkKHgsIHApIHtcclxuICB2YXIgZCA9IGZvcm1hdERlY2ltYWwoeCwgcCk7XHJcbiAgaWYgKCFkKSByZXR1cm4geCArIFwiXCI7XHJcbiAgdmFyIGNvZWZmaWNpZW50ID0gZFswXSxcclxuICAgICAgZXhwb25lbnQgPSBkWzFdO1xyXG4gIHJldHVybiBleHBvbmVudCA8IDAgPyBcIjAuXCIgKyBuZXcgQXJyYXkoLWV4cG9uZW50KS5qb2luKFwiMFwiKSArIGNvZWZmaWNpZW50XHJcbiAgICAgIDogY29lZmZpY2llbnQubGVuZ3RoID4gZXhwb25lbnQgKyAxID8gY29lZmZpY2llbnQuc2xpY2UoMCwgZXhwb25lbnQgKyAxKSArIFwiLlwiICsgY29lZmZpY2llbnQuc2xpY2UoZXhwb25lbnQgKyAxKVxyXG4gICAgICA6IGNvZWZmaWNpZW50ICsgbmV3IEFycmF5KGV4cG9uZW50IC0gY29lZmZpY2llbnQubGVuZ3RoICsgMikuam9pbihcIjBcIik7XHJcbn1cclxuXHJcbnZhciBmb3JtYXRUeXBlcyA9IHtcclxuICBcIiVcIjogZnVuY3Rpb24oeCwgcCkgeyByZXR1cm4gKHggKiAxMDApLnRvRml4ZWQocCk7IH0sXHJcbiAgXCJiXCI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgucm91bmQoeCkudG9TdHJpbmcoMik7IH0sXHJcbiAgXCJjXCI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHggKyBcIlwiOyB9LFxyXG4gIFwiZFwiOiBmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLnJvdW5kKHgpLnRvU3RyaW5nKDEwKTsgfSxcclxuICBcImVcIjogZnVuY3Rpb24oeCwgcCkgeyByZXR1cm4geC50b0V4cG9uZW50aWFsKHApOyB9LFxyXG4gIFwiZlwiOiBmdW5jdGlvbih4LCBwKSB7IHJldHVybiB4LnRvRml4ZWQocCk7IH0sXHJcbiAgXCJnXCI6IGZ1bmN0aW9uKHgsIHApIHsgcmV0dXJuIHgudG9QcmVjaXNpb24ocCk7IH0sXHJcbiAgXCJvXCI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgucm91bmQoeCkudG9TdHJpbmcoOCk7IH0sXHJcbiAgXCJwXCI6IGZ1bmN0aW9uKHgsIHApIHsgcmV0dXJuIGZvcm1hdFJvdW5kZWQoeCAqIDEwMCwgcCk7IH0sXHJcbiAgXCJyXCI6IGZvcm1hdFJvdW5kZWQsXHJcbiAgXCJzXCI6IGZvcm1hdFByZWZpeEF1dG8sXHJcbiAgXCJYXCI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgucm91bmQoeCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7IH0sXHJcbiAgXCJ4XCI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgucm91bmQoeCkudG9TdHJpbmcoMTYpOyB9XHJcbn07XHJcblxyXG5mdW5jdGlvbiBpZGVudGl0eSQzKHgpIHtcclxuICByZXR1cm4geDtcclxufVxyXG5cclxudmFyIHByZWZpeGVzID0gW1wieVwiLFwielwiLFwiYVwiLFwiZlwiLFwicFwiLFwiblwiLFwiXFx4QjVcIixcIm1cIixcIlwiLFwia1wiLFwiTVwiLFwiR1wiLFwiVFwiLFwiUFwiLFwiRVwiLFwiWlwiLFwiWVwiXTtcclxuXHJcbmZ1bmN0aW9uIGZvcm1hdExvY2FsZShsb2NhbGUpIHtcclxuICB2YXIgZ3JvdXAgPSBsb2NhbGUuZ3JvdXBpbmcgJiYgbG9jYWxlLnRob3VzYW5kcyA/IGZvcm1hdEdyb3VwKGxvY2FsZS5ncm91cGluZywgbG9jYWxlLnRob3VzYW5kcykgOiBpZGVudGl0eSQzLFxyXG4gICAgICBjdXJyZW5jeSA9IGxvY2FsZS5jdXJyZW5jeSxcclxuICAgICAgZGVjaW1hbCA9IGxvY2FsZS5kZWNpbWFsLFxyXG4gICAgICBudW1lcmFscyA9IGxvY2FsZS5udW1lcmFscyA/IGZvcm1hdE51bWVyYWxzKGxvY2FsZS5udW1lcmFscykgOiBpZGVudGl0eSQzLFxyXG4gICAgICBwZXJjZW50ID0gbG9jYWxlLnBlcmNlbnQgfHwgXCIlXCI7XHJcblxyXG4gIGZ1bmN0aW9uIG5ld0Zvcm1hdChzcGVjaWZpZXIpIHtcclxuICAgIHNwZWNpZmllciA9IGZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIpO1xyXG5cclxuICAgIHZhciBmaWxsID0gc3BlY2lmaWVyLmZpbGwsXHJcbiAgICAgICAgYWxpZ24gPSBzcGVjaWZpZXIuYWxpZ24sXHJcbiAgICAgICAgc2lnbiA9IHNwZWNpZmllci5zaWduLFxyXG4gICAgICAgIHN5bWJvbCA9IHNwZWNpZmllci5zeW1ib2wsXHJcbiAgICAgICAgemVybyA9IHNwZWNpZmllci56ZXJvLFxyXG4gICAgICAgIHdpZHRoID0gc3BlY2lmaWVyLndpZHRoLFxyXG4gICAgICAgIGNvbW1hID0gc3BlY2lmaWVyLmNvbW1hLFxyXG4gICAgICAgIHByZWNpc2lvbiA9IHNwZWNpZmllci5wcmVjaXNpb24sXHJcbiAgICAgICAgdHJpbSA9IHNwZWNpZmllci50cmltLFxyXG4gICAgICAgIHR5cGUgPSBzcGVjaWZpZXIudHlwZTtcclxuXHJcbiAgICAvLyBUaGUgXCJuXCIgdHlwZSBpcyBhbiBhbGlhcyBmb3IgXCIsZ1wiLlxyXG4gICAgaWYgKHR5cGUgPT09IFwiblwiKSBjb21tYSA9IHRydWUsIHR5cGUgPSBcImdcIjtcclxuXHJcbiAgICAvLyBUaGUgXCJcIiB0eXBlLCBhbmQgYW55IGludmFsaWQgdHlwZSwgaXMgYW4gYWxpYXMgZm9yIFwiLjEyfmdcIi5cclxuICAgIGVsc2UgaWYgKCFmb3JtYXRUeXBlc1t0eXBlXSkgcHJlY2lzaW9uID09IG51bGwgJiYgKHByZWNpc2lvbiA9IDEyKSwgdHJpbSA9IHRydWUsIHR5cGUgPSBcImdcIjtcclxuXHJcbiAgICAvLyBJZiB6ZXJvIGZpbGwgaXMgc3BlY2lmaWVkLCBwYWRkaW5nIGdvZXMgYWZ0ZXIgc2lnbiBhbmQgYmVmb3JlIGRpZ2l0cy5cclxuICAgIGlmICh6ZXJvIHx8IChmaWxsID09PSBcIjBcIiAmJiBhbGlnbiA9PT0gXCI9XCIpKSB6ZXJvID0gdHJ1ZSwgZmlsbCA9IFwiMFwiLCBhbGlnbiA9IFwiPVwiO1xyXG5cclxuICAgIC8vIENvbXB1dGUgdGhlIHByZWZpeCBhbmQgc3VmZml4LlxyXG4gICAgLy8gRm9yIFNJLXByZWZpeCwgdGhlIHN1ZmZpeCBpcyBsYXppbHkgY29tcHV0ZWQuXHJcbiAgICB2YXIgcHJlZml4ID0gc3ltYm9sID09PSBcIiRcIiA/IGN1cnJlbmN5WzBdIDogc3ltYm9sID09PSBcIiNcIiAmJiAvW2JveFhdLy50ZXN0KHR5cGUpID8gXCIwXCIgKyB0eXBlLnRvTG93ZXJDYXNlKCkgOiBcIlwiLFxyXG4gICAgICAgIHN1ZmZpeCA9IHN5bWJvbCA9PT0gXCIkXCIgPyBjdXJyZW5jeVsxXSA6IC9bJXBdLy50ZXN0KHR5cGUpID8gcGVyY2VudCA6IFwiXCI7XHJcblxyXG4gICAgLy8gV2hhdCBmb3JtYXQgZnVuY3Rpb24gc2hvdWxkIHdlIHVzZT9cclxuICAgIC8vIElzIHRoaXMgYW4gaW50ZWdlciB0eXBlP1xyXG4gICAgLy8gQ2FuIHRoaXMgdHlwZSBnZW5lcmF0ZSBleHBvbmVudGlhbCBub3RhdGlvbj9cclxuICAgIHZhciBmb3JtYXRUeXBlID0gZm9ybWF0VHlwZXNbdHlwZV0sXHJcbiAgICAgICAgbWF5YmVTdWZmaXggPSAvW2RlZmdwcnMlXS8udGVzdCh0eXBlKTtcclxuXHJcbiAgICAvLyBTZXQgdGhlIGRlZmF1bHQgcHJlY2lzaW9uIGlmIG5vdCBzcGVjaWZpZWQsXHJcbiAgICAvLyBvciBjbGFtcCB0aGUgc3BlY2lmaWVkIHByZWNpc2lvbiB0byB0aGUgc3VwcG9ydGVkIHJhbmdlLlxyXG4gICAgLy8gRm9yIHNpZ25pZmljYW50IHByZWNpc2lvbiwgaXQgbXVzdCBiZSBpbiBbMSwgMjFdLlxyXG4gICAgLy8gRm9yIGZpeGVkIHByZWNpc2lvbiwgaXQgbXVzdCBiZSBpbiBbMCwgMjBdLlxyXG4gICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uID09IG51bGwgPyA2XHJcbiAgICAgICAgOiAvW2dwcnNdLy50ZXN0KHR5cGUpID8gTWF0aC5tYXgoMSwgTWF0aC5taW4oMjEsIHByZWNpc2lvbikpXHJcbiAgICAgICAgOiBNYXRoLm1heCgwLCBNYXRoLm1pbigyMCwgcHJlY2lzaW9uKSk7XHJcblxyXG4gICAgZnVuY3Rpb24gZm9ybWF0KHZhbHVlKSB7XHJcbiAgICAgIHZhciB2YWx1ZVByZWZpeCA9IHByZWZpeCxcclxuICAgICAgICAgIHZhbHVlU3VmZml4ID0gc3VmZml4LFxyXG4gICAgICAgICAgaSwgbiwgYztcclxuXHJcbiAgICAgIGlmICh0eXBlID09PSBcImNcIikge1xyXG4gICAgICAgIHZhbHVlU3VmZml4ID0gZm9ybWF0VHlwZSh2YWx1ZSkgKyB2YWx1ZVN1ZmZpeDtcclxuICAgICAgICB2YWx1ZSA9IFwiXCI7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFsdWUgPSArdmFsdWU7XHJcblxyXG4gICAgICAgIC8vIFBlcmZvcm0gdGhlIGluaXRpYWwgZm9ybWF0dGluZy5cclxuICAgICAgICB2YXIgdmFsdWVOZWdhdGl2ZSA9IHZhbHVlIDwgMDtcclxuICAgICAgICB2YWx1ZSA9IGZvcm1hdFR5cGUoTWF0aC5hYnModmFsdWUpLCBwcmVjaXNpb24pO1xyXG5cclxuICAgICAgICAvLyBUcmltIGluc2lnbmlmaWNhbnQgemVyb3MuXHJcbiAgICAgICAgaWYgKHRyaW0pIHZhbHVlID0gZm9ybWF0VHJpbSh2YWx1ZSk7XHJcblxyXG4gICAgICAgIC8vIElmIGEgbmVnYXRpdmUgdmFsdWUgcm91bmRzIHRvIHplcm8gZHVyaW5nIGZvcm1hdHRpbmcsIHRyZWF0IGFzIHBvc2l0aXZlLlxyXG4gICAgICAgIGlmICh2YWx1ZU5lZ2F0aXZlICYmICt2YWx1ZSA9PT0gMCkgdmFsdWVOZWdhdGl2ZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAvLyBDb21wdXRlIHRoZSBwcmVmaXggYW5kIHN1ZmZpeC5cclxuICAgICAgICB2YWx1ZVByZWZpeCA9ICh2YWx1ZU5lZ2F0aXZlID8gKHNpZ24gPT09IFwiKFwiID8gc2lnbiA6IFwiLVwiKSA6IHNpZ24gPT09IFwiLVwiIHx8IHNpZ24gPT09IFwiKFwiID8gXCJcIiA6IHNpZ24pICsgdmFsdWVQcmVmaXg7XHJcbiAgICAgICAgdmFsdWVTdWZmaXggPSAodHlwZSA9PT0gXCJzXCIgPyBwcmVmaXhlc1s4ICsgcHJlZml4RXhwb25lbnQgLyAzXSA6IFwiXCIpICsgdmFsdWVTdWZmaXggKyAodmFsdWVOZWdhdGl2ZSAmJiBzaWduID09PSBcIihcIiA/IFwiKVwiIDogXCJcIik7XHJcblxyXG4gICAgICAgIC8vIEJyZWFrIHRoZSBmb3JtYXR0ZWQgdmFsdWUgaW50byB0aGUgaW50ZWdlciDigJx2YWx1ZeKAnSBwYXJ0IHRoYXQgY2FuIGJlXHJcbiAgICAgICAgLy8gZ3JvdXBlZCwgYW5kIGZyYWN0aW9uYWwgb3IgZXhwb25lbnRpYWwg4oCcc3VmZml44oCdIHBhcnQgdGhhdCBpcyBub3QuXHJcbiAgICAgICAgaWYgKG1heWJlU3VmZml4KSB7XHJcbiAgICAgICAgICBpID0gLTEsIG4gPSB2YWx1ZS5sZW5ndGg7XHJcbiAgICAgICAgICB3aGlsZSAoKytpIDwgbikge1xyXG4gICAgICAgICAgICBpZiAoYyA9IHZhbHVlLmNoYXJDb2RlQXQoaSksIDQ4ID4gYyB8fCBjID4gNTcpIHtcclxuICAgICAgICAgICAgICB2YWx1ZVN1ZmZpeCA9IChjID09PSA0NiA/IGRlY2ltYWwgKyB2YWx1ZS5zbGljZShpICsgMSkgOiB2YWx1ZS5zbGljZShpKSkgKyB2YWx1ZVN1ZmZpeDtcclxuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDAsIGkpO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBJZiB0aGUgZmlsbCBjaGFyYWN0ZXIgaXMgbm90IFwiMFwiLCBncm91cGluZyBpcyBhcHBsaWVkIGJlZm9yZSBwYWRkaW5nLlxyXG4gICAgICBpZiAoY29tbWEgJiYgIXplcm8pIHZhbHVlID0gZ3JvdXAodmFsdWUsIEluZmluaXR5KTtcclxuXHJcbiAgICAgIC8vIENvbXB1dGUgdGhlIHBhZGRpbmcuXHJcbiAgICAgIHZhciBsZW5ndGggPSB2YWx1ZVByZWZpeC5sZW5ndGggKyB2YWx1ZS5sZW5ndGggKyB2YWx1ZVN1ZmZpeC5sZW5ndGgsXHJcbiAgICAgICAgICBwYWRkaW5nID0gbGVuZ3RoIDwgd2lkdGggPyBuZXcgQXJyYXkod2lkdGggLSBsZW5ndGggKyAxKS5qb2luKGZpbGwpIDogXCJcIjtcclxuXHJcbiAgICAgIC8vIElmIHRoZSBmaWxsIGNoYXJhY3RlciBpcyBcIjBcIiwgZ3JvdXBpbmcgaXMgYXBwbGllZCBhZnRlciBwYWRkaW5nLlxyXG4gICAgICBpZiAoY29tbWEgJiYgemVybykgdmFsdWUgPSBncm91cChwYWRkaW5nICsgdmFsdWUsIHBhZGRpbmcubGVuZ3RoID8gd2lkdGggLSB2YWx1ZVN1ZmZpeC5sZW5ndGggOiBJbmZpbml0eSksIHBhZGRpbmcgPSBcIlwiO1xyXG5cclxuICAgICAgLy8gUmVjb25zdHJ1Y3QgdGhlIGZpbmFsIG91dHB1dCBiYXNlZCBvbiB0aGUgZGVzaXJlZCBhbGlnbm1lbnQuXHJcbiAgICAgIHN3aXRjaCAoYWxpZ24pIHtcclxuICAgICAgICBjYXNlIFwiPFwiOiB2YWx1ZSA9IHZhbHVlUHJlZml4ICsgdmFsdWUgKyB2YWx1ZVN1ZmZpeCArIHBhZGRpbmc7IGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCI9XCI6IHZhbHVlID0gdmFsdWVQcmVmaXggKyBwYWRkaW5nICsgdmFsdWUgKyB2YWx1ZVN1ZmZpeDsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcIl5cIjogdmFsdWUgPSBwYWRkaW5nLnNsaWNlKDAsIGxlbmd0aCA9IHBhZGRpbmcubGVuZ3RoID4+IDEpICsgdmFsdWVQcmVmaXggKyB2YWx1ZSArIHZhbHVlU3VmZml4ICsgcGFkZGluZy5zbGljZShsZW5ndGgpOyBicmVhaztcclxuICAgICAgICBkZWZhdWx0OiB2YWx1ZSA9IHBhZGRpbmcgKyB2YWx1ZVByZWZpeCArIHZhbHVlICsgdmFsdWVTdWZmaXg7IGJyZWFrO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbnVtZXJhbHModmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIGZvcm1hdC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gc3BlY2lmaWVyICsgXCJcIjtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIGZvcm1hdDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGZvcm1hdFByZWZpeChzcGVjaWZpZXIsIHZhbHVlKSB7XHJcbiAgICB2YXIgZiA9IG5ld0Zvcm1hdCgoc3BlY2lmaWVyID0gZm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllciksIHNwZWNpZmllci50eXBlID0gXCJmXCIsIHNwZWNpZmllcikpLFxyXG4gICAgICAgIGUgPSBNYXRoLm1heCgtOCwgTWF0aC5taW4oOCwgTWF0aC5mbG9vcihleHBvbmVudCQxKHZhbHVlKSAvIDMpKSkgKiAzLFxyXG4gICAgICAgIGsgPSBNYXRoLnBvdygxMCwgLWUpLFxyXG4gICAgICAgIHByZWZpeCA9IHByZWZpeGVzWzggKyBlIC8gM107XHJcbiAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgcmV0dXJuIGYoayAqIHZhbHVlKSArIHByZWZpeDtcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgZm9ybWF0OiBuZXdGb3JtYXQsXHJcbiAgICBmb3JtYXRQcmVmaXg6IGZvcm1hdFByZWZpeFxyXG4gIH07XHJcbn1cclxuXHJcbnZhciBsb2NhbGU7XHJcblxyXG5kZWZhdWx0TG9jYWxlKHtcclxuICBkZWNpbWFsOiBcIi5cIixcclxuICB0aG91c2FuZHM6IFwiLFwiLFxyXG4gIGdyb3VwaW5nOiBbM10sXHJcbiAgY3VycmVuY3k6IFtcIiRcIiwgXCJcIl1cclxufSk7XHJcblxyXG5mdW5jdGlvbiBkZWZhdWx0TG9jYWxlKGRlZmluaXRpb24pIHtcclxuICBsb2NhbGUgPSBmb3JtYXRMb2NhbGUoZGVmaW5pdGlvbik7XHJcbiAgZDMuZm9ybWF0ID0gbG9jYWxlLmZvcm1hdDtcclxuICBkMy5mb3JtYXRQcmVmaXggPSBsb2NhbGUuZm9ybWF0UHJlZml4O1xyXG4gIHJldHVybiBsb2NhbGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHByZWNpc2lvbkZpeGVkKHN0ZXApIHtcclxuICByZXR1cm4gTWF0aC5tYXgoMCwgLWV4cG9uZW50JDEoTWF0aC5hYnMoc3RlcCkpKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcHJlY2lzaW9uUHJlZml4KHN0ZXAsIHZhbHVlKSB7XHJcbiAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWF4KC04LCBNYXRoLm1pbig4LCBNYXRoLmZsb29yKGV4cG9uZW50JDEodmFsdWUpIC8gMykpKSAqIDMgLSBleHBvbmVudCQxKE1hdGguYWJzKHN0ZXApKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHByZWNpc2lvblJvdW5kKHN0ZXAsIG1heCkge1xyXG4gIHN0ZXAgPSBNYXRoLmFicyhzdGVwKSwgbWF4ID0gTWF0aC5hYnMobWF4KSAtIHN0ZXA7XHJcbiAgcmV0dXJuIE1hdGgubWF4KDAsIGV4cG9uZW50JDEobWF4KSAtIGV4cG9uZW50JDEoc3RlcCkpICsgMTtcclxufVxyXG5cclxuLy8gQWRkcyBmbG9hdGluZyBwb2ludCBudW1iZXJzIHdpdGggdHdpY2UgdGhlIG5vcm1hbCBwcmVjaXNpb24uXHJcbi8vIFJlZmVyZW5jZTogSi4gUi4gU2hld2NodWssIEFkYXB0aXZlIFByZWNpc2lvbiBGbG9hdGluZy1Qb2ludCBBcml0aG1ldGljIGFuZFxyXG4vLyBGYXN0IFJvYnVzdCBHZW9tZXRyaWMgUHJlZGljYXRlcywgRGlzY3JldGUgJiBDb21wdXRhdGlvbmFsIEdlb21ldHJ5IDE4KDMpXHJcbi8vIDMwNeKAkzM2MyAoMTk5NykuXHJcbi8vIENvZGUgYWRhcHRlZCBmcm9tIEdlb2dyYXBoaWNMaWIgYnkgQ2hhcmxlcyBGLiBGLiBLYXJuZXksXHJcbi8vIGh0dHA6Ly9nZW9ncmFwaGljbGliLnNvdXJjZWZvcmdlLm5ldC9cclxuXHJcbmZ1bmN0aW9uIGFkZGVyKCkge1xyXG4gIHJldHVybiBuZXcgQWRkZXI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEFkZGVyKCkge1xyXG4gIHRoaXMucmVzZXQoKTtcclxufVxyXG5cclxuQWRkZXIucHJvdG90eXBlID0ge1xyXG4gIGNvbnN0cnVjdG9yOiBBZGRlcixcclxuICByZXNldDogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLnMgPSAvLyByb3VuZGVkIHZhbHVlXHJcbiAgICB0aGlzLnQgPSAwOyAvLyBleGFjdCBlcnJvclxyXG4gIH0sXHJcbiAgYWRkOiBmdW5jdGlvbih5KSB7XHJcbiAgICBhZGQkMSh0ZW1wLCB5LCB0aGlzLnQpO1xyXG4gICAgYWRkJDEodGhpcywgdGVtcC5zLCB0aGlzLnMpO1xyXG4gICAgaWYgKHRoaXMucykgdGhpcy50ICs9IHRlbXAudDtcclxuICAgIGVsc2UgdGhpcy5zID0gdGVtcC50O1xyXG4gIH0sXHJcbiAgdmFsdWVPZjogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zO1xyXG4gIH1cclxufTtcclxuXHJcbnZhciB0ZW1wID0gbmV3IEFkZGVyO1xyXG5cclxuZnVuY3Rpb24gYWRkJDEoYWRkZXIsIGEsIGIpIHtcclxuICB2YXIgeCA9IGFkZGVyLnMgPSBhICsgYixcclxuICAgICAgYnYgPSB4IC0gYSxcclxuICAgICAgYXYgPSB4IC0gYnY7XHJcbiAgYWRkZXIudCA9IChhIC0gYXYpICsgKGIgLSBidik7XHJcbn1cclxuXHJcbnZhciBlcHNpbG9uJDIgPSAxZS02O1xyXG52YXIgZXBzaWxvbjIkMSA9IDFlLTEyO1xyXG52YXIgcGkkMyA9IE1hdGguUEk7XHJcbnZhciBoYWxmUGkkMiA9IHBpJDMgLyAyO1xyXG52YXIgcXVhcnRlclBpID0gcGkkMyAvIDQ7XHJcbnZhciB0YXUkMyA9IHBpJDMgKiAyO1xyXG5cclxudmFyIGRlZ3JlZXMkMSA9IDE4MCAvIHBpJDM7XHJcbnZhciByYWRpYW5zID0gcGkkMyAvIDE4MDtcclxuXHJcbnZhciBhYnMgPSBNYXRoLmFicztcclxudmFyIGF0YW4gPSBNYXRoLmF0YW47XHJcbnZhciBhdGFuMiA9IE1hdGguYXRhbjI7XHJcbnZhciBjb3MkMSA9IE1hdGguY29zO1xyXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcclxudmFyIGV4cCA9IE1hdGguZXhwO1xyXG52YXIgbG9nID0gTWF0aC5sb2c7XHJcbnZhciBwb3cgPSBNYXRoLnBvdztcclxudmFyIHNpbiQxID0gTWF0aC5zaW47XHJcbnZhciBzaWduID0gTWF0aC5zaWduIHx8IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHggPiAwID8gMSA6IHggPCAwID8gLTEgOiAwOyB9O1xyXG52YXIgc3FydCA9IE1hdGguc3FydDtcclxudmFyIHRhbiA9IE1hdGgudGFuO1xyXG5cclxuZnVuY3Rpb24gYWNvcyh4KSB7XHJcbiAgcmV0dXJuIHggPiAxID8gMCA6IHggPCAtMSA/IHBpJDMgOiBNYXRoLmFjb3MoeCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFzaW4oeCkge1xyXG4gIHJldHVybiB4ID4gMSA/IGhhbGZQaSQyIDogeCA8IC0xID8gLWhhbGZQaSQyIDogTWF0aC5hc2luKHgpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBoYXZlcnNpbih4KSB7XHJcbiAgcmV0dXJuICh4ID0gc2luJDEoeCAvIDIpKSAqIHg7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5vb3AkMigpIHt9XHJcblxyXG5mdW5jdGlvbiBzdHJlYW1HZW9tZXRyeShnZW9tZXRyeSwgc3RyZWFtKSB7XHJcbiAgaWYgKGdlb21ldHJ5ICYmIHN0cmVhbUdlb21ldHJ5VHlwZS5oYXNPd25Qcm9wZXJ0eShnZW9tZXRyeS50eXBlKSkge1xyXG4gICAgc3RyZWFtR2VvbWV0cnlUeXBlW2dlb21ldHJ5LnR5cGVdKGdlb21ldHJ5LCBzdHJlYW0pO1xyXG4gIH1cclxufVxyXG5cclxudmFyIHN0cmVhbU9iamVjdFR5cGUgPSB7XHJcbiAgRmVhdHVyZTogZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcclxuICAgIHN0cmVhbUdlb21ldHJ5KG9iamVjdC5nZW9tZXRyeSwgc3RyZWFtKTtcclxuICB9LFxyXG4gIEZlYXR1cmVDb2xsZWN0aW9uOiBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xyXG4gICAgdmFyIGZlYXR1cmVzID0gb2JqZWN0LmZlYXR1cmVzLCBpID0gLTEsIG4gPSBmZWF0dXJlcy5sZW5ndGg7XHJcbiAgICB3aGlsZSAoKytpIDwgbikgc3RyZWFtR2VvbWV0cnkoZmVhdHVyZXNbaV0uZ2VvbWV0cnksIHN0cmVhbSk7XHJcbiAgfVxyXG59O1xyXG5cclxudmFyIHN0cmVhbUdlb21ldHJ5VHlwZSA9IHtcclxuICBTcGhlcmU6IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XHJcbiAgICBzdHJlYW0uc3BoZXJlKCk7XHJcbiAgfSxcclxuICBQb2ludDogZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcclxuICAgIG9iamVjdCA9IG9iamVjdC5jb29yZGluYXRlcztcclxuICAgIHN0cmVhbS5wb2ludChvYmplY3RbMF0sIG9iamVjdFsxXSwgb2JqZWN0WzJdKTtcclxuICB9LFxyXG4gIE11bHRpUG9pbnQ6IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XHJcbiAgICB2YXIgY29vcmRpbmF0ZXMgPSBvYmplY3QuY29vcmRpbmF0ZXMsIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcclxuICAgIHdoaWxlICgrK2kgPCBuKSBvYmplY3QgPSBjb29yZGluYXRlc1tpXSwgc3RyZWFtLnBvaW50KG9iamVjdFswXSwgb2JqZWN0WzFdLCBvYmplY3RbMl0pO1xyXG4gIH0sXHJcbiAgTGluZVN0cmluZzogZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcclxuICAgIHN0cmVhbUxpbmUob2JqZWN0LmNvb3JkaW5hdGVzLCBzdHJlYW0sIDApO1xyXG4gIH0sXHJcbiAgTXVsdGlMaW5lU3RyaW5nOiBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xyXG4gICAgdmFyIGNvb3JkaW5hdGVzID0gb2JqZWN0LmNvb3JkaW5hdGVzLCBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7XHJcbiAgICB3aGlsZSAoKytpIDwgbikgc3RyZWFtTGluZShjb29yZGluYXRlc1tpXSwgc3RyZWFtLCAwKTtcclxuICB9LFxyXG4gIFBvbHlnb246IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XHJcbiAgICBzdHJlYW1Qb2x5Z29uKG9iamVjdC5jb29yZGluYXRlcywgc3RyZWFtKTtcclxuICB9LFxyXG4gIE11bHRpUG9seWdvbjogZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcclxuICAgIHZhciBjb29yZGluYXRlcyA9IG9iamVjdC5jb29yZGluYXRlcywgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xyXG4gICAgd2hpbGUgKCsraSA8IG4pIHN0cmVhbVBvbHlnb24oY29vcmRpbmF0ZXNbaV0sIHN0cmVhbSk7XHJcbiAgfSxcclxuICBHZW9tZXRyeUNvbGxlY3Rpb246IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XHJcbiAgICB2YXIgZ2VvbWV0cmllcyA9IG9iamVjdC5nZW9tZXRyaWVzLCBpID0gLTEsIG4gPSBnZW9tZXRyaWVzLmxlbmd0aDtcclxuICAgIHdoaWxlICgrK2kgPCBuKSBzdHJlYW1HZW9tZXRyeShnZW9tZXRyaWVzW2ldLCBzdHJlYW0pO1xyXG4gIH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIHN0cmVhbUxpbmUoY29vcmRpbmF0ZXMsIHN0cmVhbSwgY2xvc2VkKSB7XHJcbiAgdmFyIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aCAtIGNsb3NlZCwgY29vcmRpbmF0ZTtcclxuICBzdHJlYW0ubGluZVN0YXJ0KCk7XHJcbiAgd2hpbGUgKCsraSA8IG4pIGNvb3JkaW5hdGUgPSBjb29yZGluYXRlc1tpXSwgc3RyZWFtLnBvaW50KGNvb3JkaW5hdGVbMF0sIGNvb3JkaW5hdGVbMV0sIGNvb3JkaW5hdGVbMl0pO1xyXG4gIHN0cmVhbS5saW5lRW5kKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN0cmVhbVBvbHlnb24oY29vcmRpbmF0ZXMsIHN0cmVhbSkge1xyXG4gIHZhciBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7XHJcbiAgc3RyZWFtLnBvbHlnb25TdGFydCgpO1xyXG4gIHdoaWxlICgrK2kgPCBuKSBzdHJlYW1MaW5lKGNvb3JkaW5hdGVzW2ldLCBzdHJlYW0sIDEpO1xyXG4gIHN0cmVhbS5wb2x5Z29uRW5kKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlb1N0cmVhbShvYmplY3QsIHN0cmVhbSkge1xyXG4gIGlmIChvYmplY3QgJiYgc3RyZWFtT2JqZWN0VHlwZS5oYXNPd25Qcm9wZXJ0eShvYmplY3QudHlwZSkpIHtcclxuICAgIHN0cmVhbU9iamVjdFR5cGVbb2JqZWN0LnR5cGVdKG9iamVjdCwgc3RyZWFtKTtcclxuICB9IGVsc2Uge1xyXG4gICAgc3RyZWFtR2VvbWV0cnkob2JqZWN0LCBzdHJlYW0pO1xyXG4gIH1cclxufVxyXG5cclxudmFyIGFyZWFSaW5nU3VtID0gYWRkZXIoKTtcclxuXHJcbnZhciBhcmVhU3VtID0gYWRkZXIoKSxcclxuICAgIGxhbWJkYTAwLFxyXG4gICAgcGhpMDAsXHJcbiAgICBsYW1iZGEwLFxyXG4gICAgY29zUGhpMCxcclxuICAgIHNpblBoaTA7XHJcblxyXG52YXIgYXJlYVN0cmVhbSA9IHtcclxuICBwb2ludDogbm9vcCQyLFxyXG4gIGxpbmVTdGFydDogbm9vcCQyLFxyXG4gIGxpbmVFbmQ6IG5vb3AkMixcclxuICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgYXJlYVJpbmdTdW0ucmVzZXQoKTtcclxuICAgIGFyZWFTdHJlYW0ubGluZVN0YXJ0ID0gYXJlYVJpbmdTdGFydDtcclxuICAgIGFyZWFTdHJlYW0ubGluZUVuZCA9IGFyZWFSaW5nRW5kO1xyXG4gIH0sXHJcbiAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgYXJlYVJpbmcgPSArYXJlYVJpbmdTdW07XHJcbiAgICBhcmVhU3VtLmFkZChhcmVhUmluZyA8IDAgPyB0YXUkMyArIGFyZWFSaW5nIDogYXJlYVJpbmcpO1xyXG4gICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLmxpbmVFbmQgPSB0aGlzLnBvaW50ID0gbm9vcCQyO1xyXG4gIH0sXHJcbiAgc3BoZXJlOiBmdW5jdGlvbigpIHtcclxuICAgIGFyZWFTdW0uYWRkKHRhdSQzKTtcclxuICB9XHJcbn07XHJcblxyXG5mdW5jdGlvbiBhcmVhUmluZ1N0YXJ0KCkge1xyXG4gIGFyZWFTdHJlYW0ucG9pbnQgPSBhcmVhUG9pbnRGaXJzdDtcclxufVxyXG5cclxuZnVuY3Rpb24gYXJlYVJpbmdFbmQoKSB7XHJcbiAgYXJlYVBvaW50KGxhbWJkYTAwLCBwaGkwMCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFyZWFQb2ludEZpcnN0KGxhbWJkYSwgcGhpKSB7XHJcbiAgYXJlYVN0cmVhbS5wb2ludCA9IGFyZWFQb2ludDtcclxuICBsYW1iZGEwMCA9IGxhbWJkYSwgcGhpMDAgPSBwaGk7XHJcbiAgbGFtYmRhICo9IHJhZGlhbnMsIHBoaSAqPSByYWRpYW5zO1xyXG4gIGxhbWJkYTAgPSBsYW1iZGEsIGNvc1BoaTAgPSBjb3MkMShwaGkgPSBwaGkgLyAyICsgcXVhcnRlclBpKSwgc2luUGhpMCA9IHNpbiQxKHBoaSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFyZWFQb2ludChsYW1iZGEsIHBoaSkge1xyXG4gIGxhbWJkYSAqPSByYWRpYW5zLCBwaGkgKj0gcmFkaWFucztcclxuICBwaGkgPSBwaGkgLyAyICsgcXVhcnRlclBpOyAvLyBoYWxmIHRoZSBhbmd1bGFyIGRpc3RhbmNlIGZyb20gc291dGggcG9sZVxyXG5cclxuICAvLyBTcGhlcmljYWwgZXhjZXNzIEUgZm9yIGEgc3BoZXJpY2FsIHRyaWFuZ2xlIHdpdGggdmVydGljZXM6IHNvdXRoIHBvbGUsXHJcbiAgLy8gcHJldmlvdXMgcG9pbnQsIGN1cnJlbnQgcG9pbnQuICBVc2VzIGEgZm9ybXVsYSBkZXJpdmVkIGZyb20gQ2Fnbm9saeKAmXNcclxuICAvLyB0aGVvcmVtLiAgU2VlIFRvZGh1bnRlciwgU3BoZXJpY2FsIFRyaWcuICgxODcxKSwgU2VjLiAxMDMsIEVxLiAoMikuXHJcbiAgdmFyIGRMYW1iZGEgPSBsYW1iZGEgLSBsYW1iZGEwLFxyXG4gICAgICBzZExhbWJkYSA9IGRMYW1iZGEgPj0gMCA/IDEgOiAtMSxcclxuICAgICAgYWRMYW1iZGEgPSBzZExhbWJkYSAqIGRMYW1iZGEsXHJcbiAgICAgIGNvc1BoaSA9IGNvcyQxKHBoaSksXHJcbiAgICAgIHNpblBoaSA9IHNpbiQxKHBoaSksXHJcbiAgICAgIGsgPSBzaW5QaGkwICogc2luUGhpLFxyXG4gICAgICB1ID0gY29zUGhpMCAqIGNvc1BoaSArIGsgKiBjb3MkMShhZExhbWJkYSksXHJcbiAgICAgIHYgPSBrICogc2RMYW1iZGEgKiBzaW4kMShhZExhbWJkYSk7XHJcbiAgYXJlYVJpbmdTdW0uYWRkKGF0YW4yKHYsIHUpKTtcclxuXHJcbiAgLy8gQWR2YW5jZSB0aGUgcHJldmlvdXMgcG9pbnRzLlxyXG4gIGxhbWJkYTAgPSBsYW1iZGEsIGNvc1BoaTAgPSBjb3NQaGksIHNpblBoaTAgPSBzaW5QaGk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFyZWEkMShvYmplY3QpIHtcclxuICBhcmVhU3VtLnJlc2V0KCk7XHJcbiAgZ2VvU3RyZWFtKG9iamVjdCwgYXJlYVN0cmVhbSk7XHJcbiAgcmV0dXJuIGFyZWFTdW0gKiAyO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzcGhlcmljYWwoY2FydGVzaWFuKSB7XHJcbiAgcmV0dXJuIFthdGFuMihjYXJ0ZXNpYW5bMV0sIGNhcnRlc2lhblswXSksIGFzaW4oY2FydGVzaWFuWzJdKV07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNhcnRlc2lhbihzcGhlcmljYWwpIHtcclxuICB2YXIgbGFtYmRhID0gc3BoZXJpY2FsWzBdLCBwaGkgPSBzcGhlcmljYWxbMV0sIGNvc1BoaSA9IGNvcyQxKHBoaSk7XHJcbiAgcmV0dXJuIFtjb3NQaGkgKiBjb3MkMShsYW1iZGEpLCBjb3NQaGkgKiBzaW4kMShsYW1iZGEpLCBzaW4kMShwaGkpXTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2FydGVzaWFuRG90KGEsIGIpIHtcclxuICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjYXJ0ZXNpYW5Dcm9zcyhhLCBiKSB7XHJcbiAgcmV0dXJuIFthWzFdICogYlsyXSAtIGFbMl0gKiBiWzFdLCBhWzJdICogYlswXSAtIGFbMF0gKiBiWzJdLCBhWzBdICogYlsxXSAtIGFbMV0gKiBiWzBdXTtcclxufVxyXG5cclxuLy8gVE9ETyByZXR1cm4gYVxyXG5mdW5jdGlvbiBjYXJ0ZXNpYW5BZGRJblBsYWNlKGEsIGIpIHtcclxuICBhWzBdICs9IGJbMF0sIGFbMV0gKz0gYlsxXSwgYVsyXSArPSBiWzJdO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjYXJ0ZXNpYW5TY2FsZSh2ZWN0b3IsIGspIHtcclxuICByZXR1cm4gW3ZlY3RvclswXSAqIGssIHZlY3RvclsxXSAqIGssIHZlY3RvclsyXSAqIGtdO1xyXG59XHJcblxyXG4vLyBUT0RPIHJldHVybiBkXHJcbmZ1bmN0aW9uIGNhcnRlc2lhbk5vcm1hbGl6ZUluUGxhY2UoZCkge1xyXG4gIHZhciBsID0gc3FydChkWzBdICogZFswXSArIGRbMV0gKiBkWzFdICsgZFsyXSAqIGRbMl0pO1xyXG4gIGRbMF0gLz0gbCwgZFsxXSAvPSBsLCBkWzJdIC89IGw7XHJcbn1cclxuXHJcbnZhciBsYW1iZGEwJDEsIHBoaTAsIGxhbWJkYTEsIHBoaTEsIC8vIGJvdW5kc1xyXG4gICAgbGFtYmRhMiwgLy8gcHJldmlvdXMgbGFtYmRhLWNvb3JkaW5hdGVcclxuICAgIGxhbWJkYTAwJDEsIHBoaTAwJDEsIC8vIGZpcnN0IHBvaW50XHJcbiAgICBwMCwgLy8gcHJldmlvdXMgM0QgcG9pbnRcclxuICAgIGRlbHRhU3VtID0gYWRkZXIoKSxcclxuICAgIHJhbmdlcyxcclxuICAgIHJhbmdlO1xyXG5cclxudmFyIGJvdW5kc1N0cmVhbSA9IHtcclxuICBwb2ludDogYm91bmRzUG9pbnQsXHJcbiAgbGluZVN0YXJ0OiBib3VuZHNMaW5lU3RhcnQsXHJcbiAgbGluZUVuZDogYm91bmRzTGluZUVuZCxcclxuICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgYm91bmRzU3RyZWFtLnBvaW50ID0gYm91bmRzUmluZ1BvaW50O1xyXG4gICAgYm91bmRzU3RyZWFtLmxpbmVTdGFydCA9IGJvdW5kc1JpbmdTdGFydDtcclxuICAgIGJvdW5kc1N0cmVhbS5saW5lRW5kID0gYm91bmRzUmluZ0VuZDtcclxuICAgIGRlbHRhU3VtLnJlc2V0KCk7XHJcbiAgICBhcmVhU3RyZWFtLnBvbHlnb25TdGFydCgpO1xyXG4gIH0sXHJcbiAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XHJcbiAgICBhcmVhU3RyZWFtLnBvbHlnb25FbmQoKTtcclxuICAgIGJvdW5kc1N0cmVhbS5wb2ludCA9IGJvdW5kc1BvaW50O1xyXG4gICAgYm91bmRzU3RyZWFtLmxpbmVTdGFydCA9IGJvdW5kc0xpbmVTdGFydDtcclxuICAgIGJvdW5kc1N0cmVhbS5saW5lRW5kID0gYm91bmRzTGluZUVuZDtcclxuICAgIGlmIChhcmVhUmluZ1N1bSA8IDApIGxhbWJkYTAkMSA9IC0obGFtYmRhMSA9IDE4MCksIHBoaTAgPSAtKHBoaTEgPSA5MCk7XHJcbiAgICBlbHNlIGlmIChkZWx0YVN1bSA+IGVwc2lsb24kMikgcGhpMSA9IDkwO1xyXG4gICAgZWxzZSBpZiAoZGVsdGFTdW0gPCAtZXBzaWxvbiQyKSBwaGkwID0gLTkwO1xyXG4gICAgcmFuZ2VbMF0gPSBsYW1iZGEwJDEsIHJhbmdlWzFdID0gbGFtYmRhMTtcclxuICB9XHJcbn07XHJcblxyXG5mdW5jdGlvbiBib3VuZHNQb2ludChsYW1iZGEsIHBoaSkge1xyXG4gIHJhbmdlcy5wdXNoKHJhbmdlID0gW2xhbWJkYTAkMSA9IGxhbWJkYSwgbGFtYmRhMSA9IGxhbWJkYV0pO1xyXG4gIGlmIChwaGkgPCBwaGkwKSBwaGkwID0gcGhpO1xyXG4gIGlmIChwaGkgPiBwaGkxKSBwaGkxID0gcGhpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBsaW5lUG9pbnQobGFtYmRhLCBwaGkpIHtcclxuICB2YXIgcCA9IGNhcnRlc2lhbihbbGFtYmRhICogcmFkaWFucywgcGhpICogcmFkaWFuc10pO1xyXG4gIGlmIChwMCkge1xyXG4gICAgdmFyIG5vcm1hbCA9IGNhcnRlc2lhbkNyb3NzKHAwLCBwKSxcclxuICAgICAgICBlcXVhdG9yaWFsID0gW25vcm1hbFsxXSwgLW5vcm1hbFswXSwgMF0sXHJcbiAgICAgICAgaW5mbGVjdGlvbiA9IGNhcnRlc2lhbkNyb3NzKGVxdWF0b3JpYWwsIG5vcm1hbCk7XHJcbiAgICBjYXJ0ZXNpYW5Ob3JtYWxpemVJblBsYWNlKGluZmxlY3Rpb24pO1xyXG4gICAgaW5mbGVjdGlvbiA9IHNwaGVyaWNhbChpbmZsZWN0aW9uKTtcclxuICAgIHZhciBkZWx0YSA9IGxhbWJkYSAtIGxhbWJkYTIsXHJcbiAgICAgICAgc2lnbiQkMSA9IGRlbHRhID4gMCA/IDEgOiAtMSxcclxuICAgICAgICBsYW1iZGFpID0gaW5mbGVjdGlvblswXSAqIGRlZ3JlZXMkMSAqIHNpZ24kJDEsXHJcbiAgICAgICAgcGhpaSxcclxuICAgICAgICBhbnRpbWVyaWRpYW4gPSBhYnMoZGVsdGEpID4gMTgwO1xyXG4gICAgaWYgKGFudGltZXJpZGlhbiBeIChzaWduJCQxICogbGFtYmRhMiA8IGxhbWJkYWkgJiYgbGFtYmRhaSA8IHNpZ24kJDEgKiBsYW1iZGEpKSB7XHJcbiAgICAgIHBoaWkgPSBpbmZsZWN0aW9uWzFdICogZGVncmVlcyQxO1xyXG4gICAgICBpZiAocGhpaSA+IHBoaTEpIHBoaTEgPSBwaGlpO1xyXG4gICAgfSBlbHNlIGlmIChsYW1iZGFpID0gKGxhbWJkYWkgKyAzNjApICUgMzYwIC0gMTgwLCBhbnRpbWVyaWRpYW4gXiAoc2lnbiQkMSAqIGxhbWJkYTIgPCBsYW1iZGFpICYmIGxhbWJkYWkgPCBzaWduJCQxICogbGFtYmRhKSkge1xyXG4gICAgICBwaGlpID0gLWluZmxlY3Rpb25bMV0gKiBkZWdyZWVzJDE7XHJcbiAgICAgIGlmIChwaGlpIDwgcGhpMCkgcGhpMCA9IHBoaWk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAocGhpIDwgcGhpMCkgcGhpMCA9IHBoaTtcclxuICAgICAgaWYgKHBoaSA+IHBoaTEpIHBoaTEgPSBwaGk7XHJcbiAgICB9XHJcbiAgICBpZiAoYW50aW1lcmlkaWFuKSB7XHJcbiAgICAgIGlmIChsYW1iZGEgPCBsYW1iZGEyKSB7XHJcbiAgICAgICAgaWYgKGFuZ2xlKGxhbWJkYTAkMSwgbGFtYmRhKSA+IGFuZ2xlKGxhbWJkYTAkMSwgbGFtYmRhMSkpIGxhbWJkYTEgPSBsYW1iZGE7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKGFuZ2xlKGxhbWJkYSwgbGFtYmRhMSkgPiBhbmdsZShsYW1iZGEwJDEsIGxhbWJkYTEpKSBsYW1iZGEwJDEgPSBsYW1iZGE7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmIChsYW1iZGExID49IGxhbWJkYTAkMSkge1xyXG4gICAgICAgIGlmIChsYW1iZGEgPCBsYW1iZGEwJDEpIGxhbWJkYTAkMSA9IGxhbWJkYTtcclxuICAgICAgICBpZiAobGFtYmRhID4gbGFtYmRhMSkgbGFtYmRhMSA9IGxhbWJkYTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAobGFtYmRhID4gbGFtYmRhMikge1xyXG4gICAgICAgICAgaWYgKGFuZ2xlKGxhbWJkYTAkMSwgbGFtYmRhKSA+IGFuZ2xlKGxhbWJkYTAkMSwgbGFtYmRhMSkpIGxhbWJkYTEgPSBsYW1iZGE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGlmIChhbmdsZShsYW1iZGEsIGxhbWJkYTEpID4gYW5nbGUobGFtYmRhMCQxLCBsYW1iZGExKSkgbGFtYmRhMCQxID0gbGFtYmRhO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICByYW5nZXMucHVzaChyYW5nZSA9IFtsYW1iZGEwJDEgPSBsYW1iZGEsIGxhbWJkYTEgPSBsYW1iZGFdKTtcclxuICB9XHJcbiAgaWYgKHBoaSA8IHBoaTApIHBoaTAgPSBwaGk7XHJcbiAgaWYgKHBoaSA+IHBoaTEpIHBoaTEgPSBwaGk7XHJcbiAgcDAgPSBwLCBsYW1iZGEyID0gbGFtYmRhO1xyXG59XHJcblxyXG5mdW5jdGlvbiBib3VuZHNMaW5lU3RhcnQoKSB7XHJcbiAgYm91bmRzU3RyZWFtLnBvaW50ID0gbGluZVBvaW50O1xyXG59XHJcblxyXG5mdW5jdGlvbiBib3VuZHNMaW5lRW5kKCkge1xyXG4gIHJhbmdlWzBdID0gbGFtYmRhMCQxLCByYW5nZVsxXSA9IGxhbWJkYTE7XHJcbiAgYm91bmRzU3RyZWFtLnBvaW50ID0gYm91bmRzUG9pbnQ7XHJcbiAgcDAgPSBudWxsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBib3VuZHNSaW5nUG9pbnQobGFtYmRhLCBwaGkpIHtcclxuICBpZiAocDApIHtcclxuICAgIHZhciBkZWx0YSA9IGxhbWJkYSAtIGxhbWJkYTI7XHJcbiAgICBkZWx0YVN1bS5hZGQoYWJzKGRlbHRhKSA+IDE4MCA/IGRlbHRhICsgKGRlbHRhID4gMCA/IDM2MCA6IC0zNjApIDogZGVsdGEpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBsYW1iZGEwMCQxID0gbGFtYmRhLCBwaGkwMCQxID0gcGhpO1xyXG4gIH1cclxuICBhcmVhU3RyZWFtLnBvaW50KGxhbWJkYSwgcGhpKTtcclxuICBsaW5lUG9pbnQobGFtYmRhLCBwaGkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBib3VuZHNSaW5nU3RhcnQoKSB7XHJcbiAgYXJlYVN0cmVhbS5saW5lU3RhcnQoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gYm91bmRzUmluZ0VuZCgpIHtcclxuICBib3VuZHNSaW5nUG9pbnQobGFtYmRhMDAkMSwgcGhpMDAkMSk7XHJcbiAgYXJlYVN0cmVhbS5saW5lRW5kKCk7XHJcbiAgaWYgKGFicyhkZWx0YVN1bSkgPiBlcHNpbG9uJDIpIGxhbWJkYTAkMSA9IC0obGFtYmRhMSA9IDE4MCk7XHJcbiAgcmFuZ2VbMF0gPSBsYW1iZGEwJDEsIHJhbmdlWzFdID0gbGFtYmRhMTtcclxuICBwMCA9IG51bGw7XHJcbn1cclxuXHJcbi8vIEZpbmRzIHRoZSBsZWZ0LXJpZ2h0IGRpc3RhbmNlIGJldHdlZW4gdHdvIGxvbmdpdHVkZXMuXHJcbi8vIFRoaXMgaXMgYWxtb3N0IHRoZSBzYW1lIGFzIChsYW1iZGExIC0gbGFtYmRhMCArIDM2MMKwKSAlIDM2MMKwLCBleGNlcHQgdGhhdCB3ZSB3YW50XHJcbi8vIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIMKxMTgwwrAgdG8gYmUgMzYwwrAuXHJcbmZ1bmN0aW9uIGFuZ2xlKGxhbWJkYTAsIGxhbWJkYTEpIHtcclxuICByZXR1cm4gKGxhbWJkYTEgLT0gbGFtYmRhMCkgPCAwID8gbGFtYmRhMSArIDM2MCA6IGxhbWJkYTE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJhbmdlQ29tcGFyZShhLCBiKSB7XHJcbiAgcmV0dXJuIGFbMF0gLSBiWzBdO1xyXG59XHJcblxyXG5mdW5jdGlvbiByYW5nZUNvbnRhaW5zKHJhbmdlLCB4KSB7XHJcbiAgcmV0dXJuIHJhbmdlWzBdIDw9IHJhbmdlWzFdID8gcmFuZ2VbMF0gPD0geCAmJiB4IDw9IHJhbmdlWzFdIDogeCA8IHJhbmdlWzBdIHx8IHJhbmdlWzFdIDwgeDtcclxufVxyXG5cclxuZnVuY3Rpb24gYm91bmRzKGZlYXR1cmUpIHtcclxuICB2YXIgaSwgbiwgYSwgYiwgbWVyZ2VkLCBkZWx0YU1heCwgZGVsdGE7XHJcblxyXG4gIHBoaTEgPSBsYW1iZGExID0gLShsYW1iZGEwJDEgPSBwaGkwID0gSW5maW5pdHkpO1xyXG4gIHJhbmdlcyA9IFtdO1xyXG4gIGdlb1N0cmVhbShmZWF0dXJlLCBib3VuZHNTdHJlYW0pO1xyXG5cclxuICAvLyBGaXJzdCwgc29ydCByYW5nZXMgYnkgdGhlaXIgbWluaW11bSBsb25naXR1ZGVzLlxyXG4gIGlmIChuID0gcmFuZ2VzLmxlbmd0aCkge1xyXG4gICAgcmFuZ2VzLnNvcnQocmFuZ2VDb21wYXJlKTtcclxuXHJcbiAgICAvLyBUaGVuLCBtZXJnZSBhbnkgcmFuZ2VzIHRoYXQgb3ZlcmxhcC5cclxuICAgIGZvciAoaSA9IDEsIGEgPSByYW5nZXNbMF0sIG1lcmdlZCA9IFthXTsgaSA8IG47ICsraSkge1xyXG4gICAgICBiID0gcmFuZ2VzW2ldO1xyXG4gICAgICBpZiAocmFuZ2VDb250YWlucyhhLCBiWzBdKSB8fCByYW5nZUNvbnRhaW5zKGEsIGJbMV0pKSB7XHJcbiAgICAgICAgaWYgKGFuZ2xlKGFbMF0sIGJbMV0pID4gYW5nbGUoYVswXSwgYVsxXSkpIGFbMV0gPSBiWzFdO1xyXG4gICAgICAgIGlmIChhbmdsZShiWzBdLCBhWzFdKSA+IGFuZ2xlKGFbMF0sIGFbMV0pKSBhWzBdID0gYlswXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBtZXJnZWQucHVzaChhID0gYik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBGaW5hbGx5LCBmaW5kIHRoZSBsYXJnZXN0IGdhcCBiZXR3ZWVuIHRoZSBtZXJnZWQgcmFuZ2VzLlxyXG4gICAgLy8gVGhlIGZpbmFsIGJvdW5kaW5nIGJveCB3aWxsIGJlIHRoZSBpbnZlcnNlIG9mIHRoaXMgZ2FwLlxyXG4gICAgZm9yIChkZWx0YU1heCA9IC1JbmZpbml0eSwgbiA9IG1lcmdlZC5sZW5ndGggLSAxLCBpID0gMCwgYSA9IG1lcmdlZFtuXTsgaSA8PSBuOyBhID0gYiwgKytpKSB7XHJcbiAgICAgIGIgPSBtZXJnZWRbaV07XHJcbiAgICAgIGlmICgoZGVsdGEgPSBhbmdsZShhWzFdLCBiWzBdKSkgPiBkZWx0YU1heCkgZGVsdGFNYXggPSBkZWx0YSwgbGFtYmRhMCQxID0gYlswXSwgbGFtYmRhMSA9IGFbMV07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByYW5nZXMgPSByYW5nZSA9IG51bGw7XHJcblxyXG4gIHJldHVybiBsYW1iZGEwJDEgPT09IEluZmluaXR5IHx8IHBoaTAgPT09IEluZmluaXR5XHJcbiAgICAgID8gW1tOYU4sIE5hTl0sIFtOYU4sIE5hTl1dXHJcbiAgICAgIDogW1tsYW1iZGEwJDEsIHBoaTBdLCBbbGFtYmRhMSwgcGhpMV1dO1xyXG59XHJcblxyXG52YXIgVzAsIFcxLFxyXG4gICAgWDAsIFkwLCBaMCxcclxuICAgIFgxLCBZMSwgWjEsXHJcbiAgICBYMiwgWTIsIFoyLFxyXG4gICAgbGFtYmRhMDAkMiwgcGhpMDAkMiwgLy8gZmlyc3QgcG9pbnRcclxuICAgIHgwLCB5MCwgejA7IC8vIHByZXZpb3VzIHBvaW50XHJcblxyXG52YXIgY2VudHJvaWRTdHJlYW0gPSB7XHJcbiAgc3BoZXJlOiBub29wJDIsXHJcbiAgcG9pbnQ6IGNlbnRyb2lkUG9pbnQsXHJcbiAgbGluZVN0YXJ0OiBjZW50cm9pZExpbmVTdGFydCxcclxuICBsaW5lRW5kOiBjZW50cm9pZExpbmVFbmQsXHJcbiAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcclxuICAgIGNlbnRyb2lkU3RyZWFtLmxpbmVTdGFydCA9IGNlbnRyb2lkUmluZ1N0YXJ0O1xyXG4gICAgY2VudHJvaWRTdHJlYW0ubGluZUVuZCA9IGNlbnRyb2lkUmluZ0VuZDtcclxuICB9LFxyXG4gIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgY2VudHJvaWRTdHJlYW0ubGluZVN0YXJ0ID0gY2VudHJvaWRMaW5lU3RhcnQ7XHJcbiAgICBjZW50cm9pZFN0cmVhbS5saW5lRW5kID0gY2VudHJvaWRMaW5lRW5kO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIEFyaXRobWV0aWMgbWVhbiBvZiBDYXJ0ZXNpYW4gdmVjdG9ycy5cclxuZnVuY3Rpb24gY2VudHJvaWRQb2ludChsYW1iZGEsIHBoaSkge1xyXG4gIGxhbWJkYSAqPSByYWRpYW5zLCBwaGkgKj0gcmFkaWFucztcclxuICB2YXIgY29zUGhpID0gY29zJDEocGhpKTtcclxuICBjZW50cm9pZFBvaW50Q2FydGVzaWFuKGNvc1BoaSAqIGNvcyQxKGxhbWJkYSksIGNvc1BoaSAqIHNpbiQxKGxhbWJkYSksIHNpbiQxKHBoaSkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjZW50cm9pZFBvaW50Q2FydGVzaWFuKHgsIHksIHopIHtcclxuICArK1cwO1xyXG4gIFgwICs9ICh4IC0gWDApIC8gVzA7XHJcbiAgWTAgKz0gKHkgLSBZMCkgLyBXMDtcclxuICBaMCArPSAoeiAtIFowKSAvIFcwO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjZW50cm9pZExpbmVTdGFydCgpIHtcclxuICBjZW50cm9pZFN0cmVhbS5wb2ludCA9IGNlbnRyb2lkTGluZVBvaW50Rmlyc3Q7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNlbnRyb2lkTGluZVBvaW50Rmlyc3QobGFtYmRhLCBwaGkpIHtcclxuICBsYW1iZGEgKj0gcmFkaWFucywgcGhpICo9IHJhZGlhbnM7XHJcbiAgdmFyIGNvc1BoaSA9IGNvcyQxKHBoaSk7XHJcbiAgeDAgPSBjb3NQaGkgKiBjb3MkMShsYW1iZGEpO1xyXG4gIHkwID0gY29zUGhpICogc2luJDEobGFtYmRhKTtcclxuICB6MCA9IHNpbiQxKHBoaSk7XHJcbiAgY2VudHJvaWRTdHJlYW0ucG9pbnQgPSBjZW50cm9pZExpbmVQb2ludDtcclxuICBjZW50cm9pZFBvaW50Q2FydGVzaWFuKHgwLCB5MCwgejApO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjZW50cm9pZExpbmVQb2ludChsYW1iZGEsIHBoaSkge1xyXG4gIGxhbWJkYSAqPSByYWRpYW5zLCBwaGkgKj0gcmFkaWFucztcclxuICB2YXIgY29zUGhpID0gY29zJDEocGhpKSxcclxuICAgICAgeCA9IGNvc1BoaSAqIGNvcyQxKGxhbWJkYSksXHJcbiAgICAgIHkgPSBjb3NQaGkgKiBzaW4kMShsYW1iZGEpLFxyXG4gICAgICB6ID0gc2luJDEocGhpKSxcclxuICAgICAgdyA9IGF0YW4yKHNxcnQoKHcgPSB5MCAqIHogLSB6MCAqIHkpICogdyArICh3ID0gejAgKiB4IC0geDAgKiB6KSAqIHcgKyAodyA9IHgwICogeSAtIHkwICogeCkgKiB3KSwgeDAgKiB4ICsgeTAgKiB5ICsgejAgKiB6KTtcclxuICBXMSArPSB3O1xyXG4gIFgxICs9IHcgKiAoeDAgKyAoeDAgPSB4KSk7XHJcbiAgWTEgKz0gdyAqICh5MCArICh5MCA9IHkpKTtcclxuICBaMSArPSB3ICogKHowICsgKHowID0geikpO1xyXG4gIGNlbnRyb2lkUG9pbnRDYXJ0ZXNpYW4oeDAsIHkwLCB6MCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNlbnRyb2lkTGluZUVuZCgpIHtcclxuICBjZW50cm9pZFN0cmVhbS5wb2ludCA9IGNlbnRyb2lkUG9pbnQ7XHJcbn1cclxuXHJcbi8vIFNlZSBKLiBFLiBCcm9jaywgVGhlIEluZXJ0aWEgVGVuc29yIGZvciBhIFNwaGVyaWNhbCBUcmlhbmdsZSxcclxuLy8gSi4gQXBwbGllZCBNZWNoYW5pY3MgNDIsIDIzOSAoMTk3NSkuXHJcbmZ1bmN0aW9uIGNlbnRyb2lkUmluZ1N0YXJ0KCkge1xyXG4gIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRSaW5nUG9pbnRGaXJzdDtcclxufVxyXG5cclxuZnVuY3Rpb24gY2VudHJvaWRSaW5nRW5kKCkge1xyXG4gIGNlbnRyb2lkUmluZ1BvaW50KGxhbWJkYTAwJDIsIHBoaTAwJDIpO1xyXG4gIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRQb2ludDtcclxufVxyXG5cclxuZnVuY3Rpb24gY2VudHJvaWRSaW5nUG9pbnRGaXJzdChsYW1iZGEsIHBoaSkge1xyXG4gIGxhbWJkYTAwJDIgPSBsYW1iZGEsIHBoaTAwJDIgPSBwaGk7XHJcbiAgbGFtYmRhICo9IHJhZGlhbnMsIHBoaSAqPSByYWRpYW5zO1xyXG4gIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRSaW5nUG9pbnQ7XHJcbiAgdmFyIGNvc1BoaSA9IGNvcyQxKHBoaSk7XHJcbiAgeDAgPSBjb3NQaGkgKiBjb3MkMShsYW1iZGEpO1xyXG4gIHkwID0gY29zUGhpICogc2luJDEobGFtYmRhKTtcclxuICB6MCA9IHNpbiQxKHBoaSk7XHJcbiAgY2VudHJvaWRQb2ludENhcnRlc2lhbih4MCwgeTAsIHowKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2VudHJvaWRSaW5nUG9pbnQobGFtYmRhLCBwaGkpIHtcclxuICBsYW1iZGEgKj0gcmFkaWFucywgcGhpICo9IHJhZGlhbnM7XHJcbiAgdmFyIGNvc1BoaSA9IGNvcyQxKHBoaSksXHJcbiAgICAgIHggPSBjb3NQaGkgKiBjb3MkMShsYW1iZGEpLFxyXG4gICAgICB5ID0gY29zUGhpICogc2luJDEobGFtYmRhKSxcclxuICAgICAgeiA9IHNpbiQxKHBoaSksXHJcbiAgICAgIGN4ID0geTAgKiB6IC0gejAgKiB5LFxyXG4gICAgICBjeSA9IHowICogeCAtIHgwICogeixcclxuICAgICAgY3ogPSB4MCAqIHkgLSB5MCAqIHgsXHJcbiAgICAgIG0gPSBzcXJ0KGN4ICogY3ggKyBjeSAqIGN5ICsgY3ogKiBjeiksXHJcbiAgICAgIHcgPSBhc2luKG0pLCAvLyBsaW5lIHdlaWdodCA9IGFuZ2xlXHJcbiAgICAgIHYgPSBtICYmIC13IC8gbTsgLy8gYXJlYSB3ZWlnaHQgbXVsdGlwbGllclxyXG4gIFgyICs9IHYgKiBjeDtcclxuICBZMiArPSB2ICogY3k7XHJcbiAgWjIgKz0gdiAqIGN6O1xyXG4gIFcxICs9IHc7XHJcbiAgWDEgKz0gdyAqICh4MCArICh4MCA9IHgpKTtcclxuICBZMSArPSB3ICogKHkwICsgKHkwID0geSkpO1xyXG4gIFoxICs9IHcgKiAoejAgKyAoejAgPSB6KSk7XHJcbiAgY2VudHJvaWRQb2ludENhcnRlc2lhbih4MCwgeTAsIHowKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2VudHJvaWQob2JqZWN0KSB7XHJcbiAgVzAgPSBXMSA9XHJcbiAgWDAgPSBZMCA9IFowID1cclxuICBYMSA9IFkxID0gWjEgPVxyXG4gIFgyID0gWTIgPSBaMiA9IDA7XHJcbiAgZ2VvU3RyZWFtKG9iamVjdCwgY2VudHJvaWRTdHJlYW0pO1xyXG5cclxuICB2YXIgeCA9IFgyLFxyXG4gICAgICB5ID0gWTIsXHJcbiAgICAgIHogPSBaMixcclxuICAgICAgbSA9IHggKiB4ICsgeSAqIHkgKyB6ICogejtcclxuXHJcbiAgLy8gSWYgdGhlIGFyZWEtd2VpZ2h0ZWQgY2NlbnRyb2lkIGlzIHVuZGVmaW5lZCwgZmFsbCBiYWNrIHRvIGxlbmd0aC13ZWlnaHRlZCBjY2VudHJvaWQuXHJcbiAgaWYgKG0gPCBlcHNpbG9uMiQxKSB7XHJcbiAgICB4ID0gWDEsIHkgPSBZMSwgeiA9IFoxO1xyXG4gICAgLy8gSWYgdGhlIGZlYXR1cmUgaGFzIHplcm8gbGVuZ3RoLCBmYWxsIGJhY2sgdG8gYXJpdGhtZXRpYyBtZWFuIG9mIHBvaW50IHZlY3RvcnMuXHJcbiAgICBpZiAoVzEgPCBlcHNpbG9uJDIpIHggPSBYMCwgeSA9IFkwLCB6ID0gWjA7XHJcbiAgICBtID0geCAqIHggKyB5ICogeSArIHogKiB6O1xyXG4gICAgLy8gSWYgdGhlIGZlYXR1cmUgc3RpbGwgaGFzIGFuIHVuZGVmaW5lZCBjY2VudHJvaWQsIHRoZW4gcmV0dXJuLlxyXG4gICAgaWYgKG0gPCBlcHNpbG9uMiQxKSByZXR1cm4gW05hTiwgTmFOXTtcclxuICB9XHJcblxyXG4gIHJldHVybiBbYXRhbjIoeSwgeCkgKiBkZWdyZWVzJDEsIGFzaW4oeiAvIHNxcnQobSkpICogZGVncmVlcyQxXTtcclxufVxyXG5cclxuZnVuY3Rpb24gY29uc3RhbnQkOCh4KSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHg7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gY29tcG9zZShhLCBiKSB7XHJcblxyXG4gIGZ1bmN0aW9uIGNvbXBvc2UoeCwgeSkge1xyXG4gICAgcmV0dXJuIHggPSBhKHgsIHkpLCBiKHhbMF0sIHhbMV0pO1xyXG4gIH1cclxuXHJcbiAgaWYgKGEuaW52ZXJ0ICYmIGIuaW52ZXJ0KSBjb21wb3NlLmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgIHJldHVybiB4ID0gYi5pbnZlcnQoeCwgeSksIHggJiYgYS5pbnZlcnQoeFswXSwgeFsxXSk7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIGNvbXBvc2U7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJvdGF0aW9uSWRlbnRpdHkobGFtYmRhLCBwaGkpIHtcclxuICByZXR1cm4gW2xhbWJkYSA+IHBpJDMgPyBsYW1iZGEgLSB0YXUkMyA6IGxhbWJkYSA8IC1waSQzID8gbGFtYmRhICsgdGF1JDMgOiBsYW1iZGEsIHBoaV07XHJcbn1cclxuXHJcbnJvdGF0aW9uSWRlbnRpdHkuaW52ZXJ0ID0gcm90YXRpb25JZGVudGl0eTtcclxuXHJcbmZ1bmN0aW9uIHJvdGF0ZVJhZGlhbnMoZGVsdGFMYW1iZGEsIGRlbHRhUGhpLCBkZWx0YUdhbW1hKSB7XHJcbiAgcmV0dXJuIChkZWx0YUxhbWJkYSAlPSB0YXUkMykgPyAoZGVsdGFQaGkgfHwgZGVsdGFHYW1tYSA/IGNvbXBvc2Uocm90YXRpb25MYW1iZGEoZGVsdGFMYW1iZGEpLCByb3RhdGlvblBoaUdhbW1hKGRlbHRhUGhpLCBkZWx0YUdhbW1hKSlcclxuICAgIDogcm90YXRpb25MYW1iZGEoZGVsdGFMYW1iZGEpKVxyXG4gICAgOiAoZGVsdGFQaGkgfHwgZGVsdGFHYW1tYSA/IHJvdGF0aW9uUGhpR2FtbWEoZGVsdGFQaGksIGRlbHRhR2FtbWEpXHJcbiAgICA6IHJvdGF0aW9uSWRlbnRpdHkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBmb3J3YXJkUm90YXRpb25MYW1iZGEoZGVsdGFMYW1iZGEpIHtcclxuICByZXR1cm4gZnVuY3Rpb24obGFtYmRhLCBwaGkpIHtcclxuICAgIHJldHVybiBsYW1iZGEgKz0gZGVsdGFMYW1iZGEsIFtsYW1iZGEgPiBwaSQzID8gbGFtYmRhIC0gdGF1JDMgOiBsYW1iZGEgPCAtcGkkMyA/IGxhbWJkYSArIHRhdSQzIDogbGFtYmRhLCBwaGldO1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJvdGF0aW9uTGFtYmRhKGRlbHRhTGFtYmRhKSB7XHJcbiAgdmFyIHJvdGF0aW9uID0gZm9yd2FyZFJvdGF0aW9uTGFtYmRhKGRlbHRhTGFtYmRhKTtcclxuICByb3RhdGlvbi5pbnZlcnQgPSBmb3J3YXJkUm90YXRpb25MYW1iZGEoLWRlbHRhTGFtYmRhKTtcclxuICByZXR1cm4gcm90YXRpb247XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJvdGF0aW9uUGhpR2FtbWEoZGVsdGFQaGksIGRlbHRhR2FtbWEpIHtcclxuICB2YXIgY29zRGVsdGFQaGkgPSBjb3MkMShkZWx0YVBoaSksXHJcbiAgICAgIHNpbkRlbHRhUGhpID0gc2luJDEoZGVsdGFQaGkpLFxyXG4gICAgICBjb3NEZWx0YUdhbW1hID0gY29zJDEoZGVsdGFHYW1tYSksXHJcbiAgICAgIHNpbkRlbHRhR2FtbWEgPSBzaW4kMShkZWx0YUdhbW1hKTtcclxuXHJcbiAgZnVuY3Rpb24gcm90YXRpb24obGFtYmRhLCBwaGkpIHtcclxuICAgIHZhciBjb3NQaGkgPSBjb3MkMShwaGkpLFxyXG4gICAgICAgIHggPSBjb3MkMShsYW1iZGEpICogY29zUGhpLFxyXG4gICAgICAgIHkgPSBzaW4kMShsYW1iZGEpICogY29zUGhpLFxyXG4gICAgICAgIHogPSBzaW4kMShwaGkpLFxyXG4gICAgICAgIGsgPSB6ICogY29zRGVsdGFQaGkgKyB4ICogc2luRGVsdGFQaGk7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICBhdGFuMih5ICogY29zRGVsdGFHYW1tYSAtIGsgKiBzaW5EZWx0YUdhbW1hLCB4ICogY29zRGVsdGFQaGkgLSB6ICogc2luRGVsdGFQaGkpLFxyXG4gICAgICBhc2luKGsgKiBjb3NEZWx0YUdhbW1hICsgeSAqIHNpbkRlbHRhR2FtbWEpXHJcbiAgICBdO1xyXG4gIH1cclxuXHJcbiAgcm90YXRpb24uaW52ZXJ0ID0gZnVuY3Rpb24obGFtYmRhLCBwaGkpIHtcclxuICAgIHZhciBjb3NQaGkgPSBjb3MkMShwaGkpLFxyXG4gICAgICAgIHggPSBjb3MkMShsYW1iZGEpICogY29zUGhpLFxyXG4gICAgICAgIHkgPSBzaW4kMShsYW1iZGEpICogY29zUGhpLFxyXG4gICAgICAgIHogPSBzaW4kMShwaGkpLFxyXG4gICAgICAgIGsgPSB6ICogY29zRGVsdGFHYW1tYSAtIHkgKiBzaW5EZWx0YUdhbW1hO1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgYXRhbjIoeSAqIGNvc0RlbHRhR2FtbWEgKyB6ICogc2luRGVsdGFHYW1tYSwgeCAqIGNvc0RlbHRhUGhpICsgayAqIHNpbkRlbHRhUGhpKSxcclxuICAgICAgYXNpbihrICogY29zRGVsdGFQaGkgLSB4ICogc2luRGVsdGFQaGkpXHJcbiAgICBdO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiByb3RhdGlvbjtcclxufVxyXG5cclxuZnVuY3Rpb24gcm90YXRpb24ocm90YXRlKSB7XHJcbiAgcm90YXRlID0gcm90YXRlUmFkaWFucyhyb3RhdGVbMF0gKiByYWRpYW5zLCByb3RhdGVbMV0gKiByYWRpYW5zLCByb3RhdGUubGVuZ3RoID4gMiA/IHJvdGF0ZVsyXSAqIHJhZGlhbnMgOiAwKTtcclxuXHJcbiAgZnVuY3Rpb24gZm9yd2FyZChjb29yZGluYXRlcykge1xyXG4gICAgY29vcmRpbmF0ZXMgPSByb3RhdGUoY29vcmRpbmF0ZXNbMF0gKiByYWRpYW5zLCBjb29yZGluYXRlc1sxXSAqIHJhZGlhbnMpO1xyXG4gICAgcmV0dXJuIGNvb3JkaW5hdGVzWzBdICo9IGRlZ3JlZXMkMSwgY29vcmRpbmF0ZXNbMV0gKj0gZGVncmVlcyQxLCBjb29yZGluYXRlcztcclxuICB9XHJcblxyXG4gIGZvcndhcmQuaW52ZXJ0ID0gZnVuY3Rpb24oY29vcmRpbmF0ZXMpIHtcclxuICAgIGNvb3JkaW5hdGVzID0gcm90YXRlLmludmVydChjb29yZGluYXRlc1swXSAqIHJhZGlhbnMsIGNvb3JkaW5hdGVzWzFdICogcmFkaWFucyk7XHJcbiAgICByZXR1cm4gY29vcmRpbmF0ZXNbMF0gKj0gZGVncmVlcyQxLCBjb29yZGluYXRlc1sxXSAqPSBkZWdyZWVzJDEsIGNvb3JkaW5hdGVzO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBmb3J3YXJkO1xyXG59XHJcblxyXG4vLyBHZW5lcmF0ZXMgYSBjaXJjbGUgY2VudGVyZWQgYXQgWzDCsCwgMMKwXSwgd2l0aCBhIGdpdmVuIHJhZGl1cyBhbmQgcHJlY2lzaW9uLlxyXG5mdW5jdGlvbiBjaXJjbGVTdHJlYW0oc3RyZWFtLCByYWRpdXMsIGRlbHRhLCBkaXJlY3Rpb24sIHQwLCB0MSkge1xyXG4gIGlmICghZGVsdGEpIHJldHVybjtcclxuICB2YXIgY29zUmFkaXVzID0gY29zJDEocmFkaXVzKSxcclxuICAgICAgc2luUmFkaXVzID0gc2luJDEocmFkaXVzKSxcclxuICAgICAgc3RlcCA9IGRpcmVjdGlvbiAqIGRlbHRhO1xyXG4gIGlmICh0MCA9PSBudWxsKSB7XHJcbiAgICB0MCA9IHJhZGl1cyArIGRpcmVjdGlvbiAqIHRhdSQzO1xyXG4gICAgdDEgPSByYWRpdXMgLSBzdGVwIC8gMjtcclxuICB9IGVsc2Uge1xyXG4gICAgdDAgPSBjaXJjbGVSYWRpdXMoY29zUmFkaXVzLCB0MCk7XHJcbiAgICB0MSA9IGNpcmNsZVJhZGl1cyhjb3NSYWRpdXMsIHQxKTtcclxuICAgIGlmIChkaXJlY3Rpb24gPiAwID8gdDAgPCB0MSA6IHQwID4gdDEpIHQwICs9IGRpcmVjdGlvbiAqIHRhdSQzO1xyXG4gIH1cclxuICBmb3IgKHZhciBwb2ludCwgdCA9IHQwOyBkaXJlY3Rpb24gPiAwID8gdCA+IHQxIDogdCA8IHQxOyB0IC09IHN0ZXApIHtcclxuICAgIHBvaW50ID0gc3BoZXJpY2FsKFtjb3NSYWRpdXMsIC1zaW5SYWRpdXMgKiBjb3MkMSh0KSwgLXNpblJhZGl1cyAqIHNpbiQxKHQpXSk7XHJcbiAgICBzdHJlYW0ucG9pbnQocG9pbnRbMF0sIHBvaW50WzFdKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIFJldHVybnMgdGhlIHNpZ25lZCBhbmdsZSBvZiBhIGNhcnRlc2lhbiBwb2ludCByZWxhdGl2ZSB0byBbY29zUmFkaXVzLCAwLCAwXS5cclxuZnVuY3Rpb24gY2lyY2xlUmFkaXVzKGNvc1JhZGl1cywgcG9pbnQpIHtcclxuICBwb2ludCA9IGNhcnRlc2lhbihwb2ludCksIHBvaW50WzBdIC09IGNvc1JhZGl1cztcclxuICBjYXJ0ZXNpYW5Ob3JtYWxpemVJblBsYWNlKHBvaW50KTtcclxuICB2YXIgcmFkaXVzID0gYWNvcygtcG9pbnRbMV0pO1xyXG4gIHJldHVybiAoKC1wb2ludFsyXSA8IDAgPyAtcmFkaXVzIDogcmFkaXVzKSArIHRhdSQzIC0gZXBzaWxvbiQyKSAlIHRhdSQzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjaXJjbGUoKSB7XHJcbiAgdmFyIGNlbnRlciA9IGNvbnN0YW50JDgoWzAsIDBdKSxcclxuICAgICAgcmFkaXVzID0gY29uc3RhbnQkOCg5MCksXHJcbiAgICAgIHByZWNpc2lvbiA9IGNvbnN0YW50JDgoNiksXHJcbiAgICAgIHJpbmcsXHJcbiAgICAgIHJvdGF0ZSxcclxuICAgICAgc3RyZWFtID0ge3BvaW50OiBwb2ludH07XHJcblxyXG4gIGZ1bmN0aW9uIHBvaW50KHgsIHkpIHtcclxuICAgIHJpbmcucHVzaCh4ID0gcm90YXRlKHgsIHkpKTtcclxuICAgIHhbMF0gKj0gZGVncmVlcyQxLCB4WzFdICo9IGRlZ3JlZXMkMTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNpcmNsZSgpIHtcclxuICAgIHZhciBjID0gY2VudGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXHJcbiAgICAgICAgciA9IHJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpICogcmFkaWFucyxcclxuICAgICAgICBwID0gcHJlY2lzaW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgKiByYWRpYW5zO1xyXG4gICAgcmluZyA9IFtdO1xyXG4gICAgcm90YXRlID0gcm90YXRlUmFkaWFucygtY1swXSAqIHJhZGlhbnMsIC1jWzFdICogcmFkaWFucywgMCkuaW52ZXJ0O1xyXG4gICAgY2lyY2xlU3RyZWFtKHN0cmVhbSwgciwgcCwgMSk7XHJcbiAgICBjID0ge3R5cGU6IFwiUG9seWdvblwiLCBjb29yZGluYXRlczogW3JpbmddfTtcclxuICAgIHJpbmcgPSByb3RhdGUgPSBudWxsO1xyXG4gICAgcmV0dXJuIGM7XHJcbiAgfVxyXG5cclxuICBjaXJjbGUuY2VudGVyID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY2VudGVyID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCQ4KFsrX1swXSwgK19bMV1dKSwgY2lyY2xlKSA6IGNlbnRlcjtcclxuICB9O1xyXG5cclxuICBjaXJjbGUucmFkaXVzID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFkaXVzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCQ4KCtfKSwgY2lyY2xlKSA6IHJhZGl1cztcclxuICB9O1xyXG5cclxuICBjaXJjbGUucHJlY2lzaW9uID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocHJlY2lzaW9uID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCQ4KCtfKSwgY2lyY2xlKSA6IHByZWNpc2lvbjtcclxuICB9O1xyXG5cclxuICByZXR1cm4gY2lyY2xlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjbGlwQnVmZmVyKCkge1xyXG4gIHZhciBsaW5lcyA9IFtdLFxyXG4gICAgICBsaW5lO1xyXG4gIHJldHVybiB7XHJcbiAgICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgICBsaW5lLnB1c2goW3gsIHldKTtcclxuICAgIH0sXHJcbiAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICBsaW5lcy5wdXNoKGxpbmUgPSBbXSk7XHJcbiAgICB9LFxyXG4gICAgbGluZUVuZDogbm9vcCQyLFxyXG4gICAgcmVqb2luOiBmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKGxpbmVzLmxlbmd0aCA+IDEpIGxpbmVzLnB1c2gobGluZXMucG9wKCkuY29uY2F0KGxpbmVzLnNoaWZ0KCkpKTtcclxuICAgIH0sXHJcbiAgICByZXN1bHQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgcmVzdWx0ID0gbGluZXM7XHJcbiAgICAgIGxpbmVzID0gW107XHJcbiAgICAgIGxpbmUgPSBudWxsO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBvaW50RXF1YWwoYSwgYikge1xyXG4gIHJldHVybiBhYnMoYVswXSAtIGJbMF0pIDwgZXBzaWxvbiQyICYmIGFicyhhWzFdIC0gYlsxXSkgPCBlcHNpbG9uJDI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEludGVyc2VjdGlvbihwb2ludCwgcG9pbnRzLCBvdGhlciwgZW50cnkpIHtcclxuICB0aGlzLnggPSBwb2ludDtcclxuICB0aGlzLnogPSBwb2ludHM7XHJcbiAgdGhpcy5vID0gb3RoZXI7IC8vIGFub3RoZXIgaW50ZXJzZWN0aW9uXHJcbiAgdGhpcy5lID0gZW50cnk7IC8vIGlzIGFuIGVudHJ5P1xyXG4gIHRoaXMudiA9IGZhbHNlOyAvLyB2aXNpdGVkXHJcbiAgdGhpcy5uID0gdGhpcy5wID0gbnVsbDsgLy8gbmV4dCAmIHByZXZpb3VzXHJcbn1cclxuXHJcbi8vIEEgZ2VuZXJhbGl6ZWQgcG9seWdvbiBjbGlwcGluZyBhbGdvcml0aG06IGdpdmVuIGEgcG9seWdvbiB0aGF0IGhhcyBiZWVuIGN1dFxyXG4vLyBpbnRvIGl0cyB2aXNpYmxlIGxpbmUgc2VnbWVudHMsIGFuZCByZWpvaW5zIHRoZSBzZWdtZW50cyBieSBpbnRlcnBvbGF0aW5nXHJcbi8vIGFsb25nIHRoZSBjbGlwIGVkZ2UuXHJcbmZ1bmN0aW9uIGNsaXBSZWpvaW4oc2VnbWVudHMsIGNvbXBhcmVJbnRlcnNlY3Rpb24sIHN0YXJ0SW5zaWRlLCBpbnRlcnBvbGF0ZSwgc3RyZWFtKSB7XHJcbiAgdmFyIHN1YmplY3QgPSBbXSxcclxuICAgICAgY2xpcCA9IFtdLFxyXG4gICAgICBpLFxyXG4gICAgICBuO1xyXG5cclxuICBzZWdtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKHNlZ21lbnQpIHtcclxuICAgIGlmICgobiA9IHNlZ21lbnQubGVuZ3RoIC0gMSkgPD0gMCkgcmV0dXJuO1xyXG4gICAgdmFyIG4sIHAwID0gc2VnbWVudFswXSwgcDEgPSBzZWdtZW50W25dLCB4O1xyXG5cclxuICAgIC8vIElmIHRoZSBmaXJzdCBhbmQgbGFzdCBwb2ludHMgb2YgYSBzZWdtZW50IGFyZSBjb2luY2lkZW50LCB0aGVuIHRyZWF0IGFzIGFcclxuICAgIC8vIGNsb3NlZCByaW5nLiBUT0RPIGlmIGFsbCByaW5ncyBhcmUgY2xvc2VkLCB0aGVuIHRoZSB3aW5kaW5nIG9yZGVyIG9mIHRoZVxyXG4gICAgLy8gZXh0ZXJpb3IgcmluZyBzaG91bGQgYmUgY2hlY2tlZC5cclxuICAgIGlmIChwb2ludEVxdWFsKHAwLCBwMSkpIHtcclxuICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSBzdHJlYW0ucG9pbnQoKHAwID0gc2VnbWVudFtpXSlbMF0sIHAwWzFdKTtcclxuICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHN1YmplY3QucHVzaCh4ID0gbmV3IEludGVyc2VjdGlvbihwMCwgc2VnbWVudCwgbnVsbCwgdHJ1ZSkpO1xyXG4gICAgY2xpcC5wdXNoKHgubyA9IG5ldyBJbnRlcnNlY3Rpb24ocDAsIG51bGwsIHgsIGZhbHNlKSk7XHJcbiAgICBzdWJqZWN0LnB1c2goeCA9IG5ldyBJbnRlcnNlY3Rpb24ocDEsIHNlZ21lbnQsIG51bGwsIGZhbHNlKSk7XHJcbiAgICBjbGlwLnB1c2goeC5vID0gbmV3IEludGVyc2VjdGlvbihwMSwgbnVsbCwgeCwgdHJ1ZSkpO1xyXG4gIH0pO1xyXG5cclxuICBpZiAoIXN1YmplY3QubGVuZ3RoKSByZXR1cm47XHJcblxyXG4gIGNsaXAuc29ydChjb21wYXJlSW50ZXJzZWN0aW9uKTtcclxuICBsaW5rJDEoc3ViamVjdCk7XHJcbiAgbGluayQxKGNsaXApO1xyXG5cclxuICBmb3IgKGkgPSAwLCBuID0gY2xpcC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcclxuICAgIGNsaXBbaV0uZSA9IHN0YXJ0SW5zaWRlID0gIXN0YXJ0SW5zaWRlO1xyXG4gIH1cclxuXHJcbiAgdmFyIHN0YXJ0ID0gc3ViamVjdFswXSxcclxuICAgICAgcG9pbnRzLFxyXG4gICAgICBwb2ludDtcclxuXHJcbiAgd2hpbGUgKDEpIHtcclxuICAgIC8vIEZpbmQgZmlyc3QgdW52aXNpdGVkIGludGVyc2VjdGlvbi5cclxuICAgIHZhciBjdXJyZW50ID0gc3RhcnQsXHJcbiAgICAgICAgaXNTdWJqZWN0ID0gdHJ1ZTtcclxuICAgIHdoaWxlIChjdXJyZW50LnYpIGlmICgoY3VycmVudCA9IGN1cnJlbnQubikgPT09IHN0YXJ0KSByZXR1cm47XHJcbiAgICBwb2ludHMgPSBjdXJyZW50Lno7XHJcbiAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XHJcbiAgICBkbyB7XHJcbiAgICAgIGN1cnJlbnQudiA9IGN1cnJlbnQuby52ID0gdHJ1ZTtcclxuICAgICAgaWYgKGN1cnJlbnQuZSkge1xyXG4gICAgICAgIGlmIChpc1N1YmplY3QpIHtcclxuICAgICAgICAgIGZvciAoaSA9IDAsIG4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbjsgKytpKSBzdHJlYW0ucG9pbnQoKHBvaW50ID0gcG9pbnRzW2ldKVswXSwgcG9pbnRbMV0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpbnRlcnBvbGF0ZShjdXJyZW50LngsIGN1cnJlbnQubi54LCAxLCBzdHJlYW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChpc1N1YmplY3QpIHtcclxuICAgICAgICAgIHBvaW50cyA9IGN1cnJlbnQucC56O1xyXG4gICAgICAgICAgZm9yIChpID0gcG9pbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSBzdHJlYW0ucG9pbnQoKHBvaW50ID0gcG9pbnRzW2ldKVswXSwgcG9pbnRbMV0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpbnRlcnBvbGF0ZShjdXJyZW50LngsIGN1cnJlbnQucC54LCAtMSwgc3RyZWFtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucDtcclxuICAgICAgfVxyXG4gICAgICBjdXJyZW50ID0gY3VycmVudC5vO1xyXG4gICAgICBwb2ludHMgPSBjdXJyZW50Lno7XHJcbiAgICAgIGlzU3ViamVjdCA9ICFpc1N1YmplY3Q7XHJcbiAgICB9IHdoaWxlICghY3VycmVudC52KTtcclxuICAgIHN0cmVhbS5saW5lRW5kKCk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBsaW5rJDEoYXJyYXkpIHtcclxuICBpZiAoIShuID0gYXJyYXkubGVuZ3RoKSkgcmV0dXJuO1xyXG4gIHZhciBuLFxyXG4gICAgICBpID0gMCxcclxuICAgICAgYSA9IGFycmF5WzBdLFxyXG4gICAgICBiO1xyXG4gIHdoaWxlICgrK2kgPCBuKSB7XHJcbiAgICBhLm4gPSBiID0gYXJyYXlbaV07XHJcbiAgICBiLnAgPSBhO1xyXG4gICAgYSA9IGI7XHJcbiAgfVxyXG4gIGEubiA9IGIgPSBhcnJheVswXTtcclxuICBiLnAgPSBhO1xyXG59XHJcblxyXG52YXIgc3VtJDEgPSBhZGRlcigpO1xyXG5cclxuZnVuY3Rpb24gcG9seWdvbkNvbnRhaW5zKHBvbHlnb24sIHBvaW50KSB7XHJcbiAgdmFyIGxhbWJkYSA9IHBvaW50WzBdLFxyXG4gICAgICBwaGkgPSBwb2ludFsxXSxcclxuICAgICAgc2luUGhpID0gc2luJDEocGhpKSxcclxuICAgICAgbm9ybWFsID0gW3NpbiQxKGxhbWJkYSksIC1jb3MkMShsYW1iZGEpLCAwXSxcclxuICAgICAgYW5nbGUgPSAwLFxyXG4gICAgICB3aW5kaW5nID0gMDtcclxuXHJcbiAgc3VtJDEucmVzZXQoKTtcclxuXHJcbiAgaWYgKHNpblBoaSA9PT0gMSkgcGhpID0gaGFsZlBpJDIgKyBlcHNpbG9uJDI7XHJcbiAgZWxzZSBpZiAoc2luUGhpID09PSAtMSkgcGhpID0gLWhhbGZQaSQyIC0gZXBzaWxvbiQyO1xyXG5cclxuICBmb3IgKHZhciBpID0gMCwgbiA9IHBvbHlnb24ubGVuZ3RoOyBpIDwgbjsgKytpKSB7XHJcbiAgICBpZiAoIShtID0gKHJpbmcgPSBwb2x5Z29uW2ldKS5sZW5ndGgpKSBjb250aW51ZTtcclxuICAgIHZhciByaW5nLFxyXG4gICAgICAgIG0sXHJcbiAgICAgICAgcG9pbnQwID0gcmluZ1ttIC0gMV0sXHJcbiAgICAgICAgbGFtYmRhMCA9IHBvaW50MFswXSxcclxuICAgICAgICBwaGkwID0gcG9pbnQwWzFdIC8gMiArIHF1YXJ0ZXJQaSxcclxuICAgICAgICBzaW5QaGkwID0gc2luJDEocGhpMCksXHJcbiAgICAgICAgY29zUGhpMCA9IGNvcyQxKHBoaTApO1xyXG5cclxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbTsgKytqLCBsYW1iZGEwID0gbGFtYmRhMSwgc2luUGhpMCA9IHNpblBoaTEsIGNvc1BoaTAgPSBjb3NQaGkxLCBwb2ludDAgPSBwb2ludDEpIHtcclxuICAgICAgdmFyIHBvaW50MSA9IHJpbmdbal0sXHJcbiAgICAgICAgICBsYW1iZGExID0gcG9pbnQxWzBdLFxyXG4gICAgICAgICAgcGhpMSA9IHBvaW50MVsxXSAvIDIgKyBxdWFydGVyUGksXHJcbiAgICAgICAgICBzaW5QaGkxID0gc2luJDEocGhpMSksXHJcbiAgICAgICAgICBjb3NQaGkxID0gY29zJDEocGhpMSksXHJcbiAgICAgICAgICBkZWx0YSA9IGxhbWJkYTEgLSBsYW1iZGEwLFxyXG4gICAgICAgICAgc2lnbiQkMSA9IGRlbHRhID49IDAgPyAxIDogLTEsXHJcbiAgICAgICAgICBhYnNEZWx0YSA9IHNpZ24kJDEgKiBkZWx0YSxcclxuICAgICAgICAgIGFudGltZXJpZGlhbiA9IGFic0RlbHRhID4gcGkkMyxcclxuICAgICAgICAgIGsgPSBzaW5QaGkwICogc2luUGhpMTtcclxuXHJcbiAgICAgIHN1bSQxLmFkZChhdGFuMihrICogc2lnbiQkMSAqIHNpbiQxKGFic0RlbHRhKSwgY29zUGhpMCAqIGNvc1BoaTEgKyBrICogY29zJDEoYWJzRGVsdGEpKSk7XHJcbiAgICAgIGFuZ2xlICs9IGFudGltZXJpZGlhbiA/IGRlbHRhICsgc2lnbiQkMSAqIHRhdSQzIDogZGVsdGE7XHJcblxyXG4gICAgICAvLyBBcmUgdGhlIGxvbmdpdHVkZXMgZWl0aGVyIHNpZGUgb2YgdGhlIHBvaW504oCZcyBtZXJpZGlhbiAobGFtYmRhKSxcclxuICAgICAgLy8gYW5kIGFyZSB0aGUgbGF0aXR1ZGVzIHNtYWxsZXIgdGhhbiB0aGUgcGFyYWxsZWwgKHBoaSk/XHJcbiAgICAgIGlmIChhbnRpbWVyaWRpYW4gXiBsYW1iZGEwID49IGxhbWJkYSBeIGxhbWJkYTEgPj0gbGFtYmRhKSB7XHJcbiAgICAgICAgdmFyIGFyYyA9IGNhcnRlc2lhbkNyb3NzKGNhcnRlc2lhbihwb2ludDApLCBjYXJ0ZXNpYW4ocG9pbnQxKSk7XHJcbiAgICAgICAgY2FydGVzaWFuTm9ybWFsaXplSW5QbGFjZShhcmMpO1xyXG4gICAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSBjYXJ0ZXNpYW5Dcm9zcyhub3JtYWwsIGFyYyk7XHJcbiAgICAgICAgY2FydGVzaWFuTm9ybWFsaXplSW5QbGFjZShpbnRlcnNlY3Rpb24pO1xyXG4gICAgICAgIHZhciBwaGlBcmMgPSAoYW50aW1lcmlkaWFuIF4gZGVsdGEgPj0gMCA/IC0xIDogMSkgKiBhc2luKGludGVyc2VjdGlvblsyXSk7XHJcbiAgICAgICAgaWYgKHBoaSA+IHBoaUFyYyB8fCBwaGkgPT09IHBoaUFyYyAmJiAoYXJjWzBdIHx8IGFyY1sxXSkpIHtcclxuICAgICAgICAgIHdpbmRpbmcgKz0gYW50aW1lcmlkaWFuIF4gZGVsdGEgPj0gMCA/IDEgOiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEZpcnN0LCBkZXRlcm1pbmUgd2hldGhlciB0aGUgU291dGggcG9sZSBpcyBpbnNpZGUgb3Igb3V0c2lkZTpcclxuICAvL1xyXG4gIC8vIEl0IGlzIGluc2lkZSBpZjpcclxuICAvLyAqIHRoZSBwb2x5Z29uIHdpbmRzIGFyb3VuZCBpdCBpbiBhIGNsb2Nrd2lzZSBkaXJlY3Rpb24uXHJcbiAgLy8gKiB0aGUgcG9seWdvbiBkb2VzIG5vdCAoY3VtdWxhdGl2ZWx5KSB3aW5kIGFyb3VuZCBpdCwgYnV0IGhhcyBhIG5lZ2F0aXZlXHJcbiAgLy8gICAoY291bnRlci1jbG9ja3dpc2UpIGFyZWEuXHJcbiAgLy9cclxuICAvLyBTZWNvbmQsIGNvdW50IHRoZSAoc2lnbmVkKSBudW1iZXIgb2YgdGltZXMgYSBzZWdtZW50IGNyb3NzZXMgYSBsYW1iZGFcclxuICAvLyBmcm9tIHRoZSBwb2ludCB0byB0aGUgU291dGggcG9sZS4gIElmIGl0IGlzIHplcm8sIHRoZW4gdGhlIHBvaW50IGlzIHRoZVxyXG4gIC8vIHNhbWUgc2lkZSBhcyB0aGUgU291dGggcG9sZS5cclxuXHJcbiAgcmV0dXJuIChhbmdsZSA8IC1lcHNpbG9uJDIgfHwgYW5nbGUgPCBlcHNpbG9uJDIgJiYgc3VtJDEgPCAtZXBzaWxvbiQyKSBeICh3aW5kaW5nICYgMSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNsaXAocG9pbnRWaXNpYmxlLCBjbGlwTGluZSwgaW50ZXJwb2xhdGUsIHN0YXJ0KSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKHNpbmspIHtcclxuICAgIHZhciBsaW5lID0gY2xpcExpbmUoc2luayksXHJcbiAgICAgICAgcmluZ0J1ZmZlciA9IGNsaXBCdWZmZXIoKSxcclxuICAgICAgICByaW5nU2luayA9IGNsaXBMaW5lKHJpbmdCdWZmZXIpLFxyXG4gICAgICAgIHBvbHlnb25TdGFydGVkID0gZmFsc2UsXHJcbiAgICAgICAgcG9seWdvbixcclxuICAgICAgICBzZWdtZW50cyxcclxuICAgICAgICByaW5nO1xyXG5cclxuICAgIHZhciBjbGlwID0ge1xyXG4gICAgICBwb2ludDogcG9pbnQsXHJcbiAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxyXG4gICAgICBsaW5lRW5kOiBsaW5lRW5kLFxyXG4gICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGNsaXAucG9pbnQgPSBwb2ludFJpbmc7XHJcbiAgICAgICAgY2xpcC5saW5lU3RhcnQgPSByaW5nU3RhcnQ7XHJcbiAgICAgICAgY2xpcC5saW5lRW5kID0gcmluZ0VuZDtcclxuICAgICAgICBzZWdtZW50cyA9IFtdO1xyXG4gICAgICAgIHBvbHlnb24gPSBbXTtcclxuICAgICAgfSxcclxuICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgY2xpcC5wb2ludCA9IHBvaW50O1xyXG4gICAgICAgIGNsaXAubGluZVN0YXJ0ID0gbGluZVN0YXJ0O1xyXG4gICAgICAgIGNsaXAubGluZUVuZCA9IGxpbmVFbmQ7XHJcbiAgICAgICAgc2VnbWVudHMgPSBtZXJnZShzZWdtZW50cyk7XHJcbiAgICAgICAgdmFyIHN0YXJ0SW5zaWRlID0gcG9seWdvbkNvbnRhaW5zKHBvbHlnb24sIHN0YXJ0KTtcclxuICAgICAgICBpZiAoc2VnbWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICBpZiAoIXBvbHlnb25TdGFydGVkKSBzaW5rLnBvbHlnb25TdGFydCgpLCBwb2x5Z29uU3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICBjbGlwUmVqb2luKHNlZ21lbnRzLCBjb21wYXJlSW50ZXJzZWN0aW9uLCBzdGFydEluc2lkZSwgaW50ZXJwb2xhdGUsIHNpbmspO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoc3RhcnRJbnNpZGUpIHtcclxuICAgICAgICAgIGlmICghcG9seWdvblN0YXJ0ZWQpIHNpbmsucG9seWdvblN0YXJ0KCksIHBvbHlnb25TdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICAgIHNpbmsubGluZVN0YXJ0KCk7XHJcbiAgICAgICAgICBpbnRlcnBvbGF0ZShudWxsLCBudWxsLCAxLCBzaW5rKTtcclxuICAgICAgICAgIHNpbmsubGluZUVuZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocG9seWdvblN0YXJ0ZWQpIHNpbmsucG9seWdvbkVuZCgpLCBwb2x5Z29uU3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIHNlZ21lbnRzID0gcG9seWdvbiA9IG51bGw7XHJcbiAgICAgIH0sXHJcbiAgICAgIHNwaGVyZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgc2luay5wb2x5Z29uU3RhcnQoKTtcclxuICAgICAgICBzaW5rLmxpbmVTdGFydCgpO1xyXG4gICAgICAgIGludGVycG9sYXRlKG51bGwsIG51bGwsIDEsIHNpbmspO1xyXG4gICAgICAgIHNpbmsubGluZUVuZCgpO1xyXG4gICAgICAgIHNpbmsucG9seWdvbkVuZCgpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIHBvaW50KGxhbWJkYSwgcGhpKSB7XHJcbiAgICAgIGlmIChwb2ludFZpc2libGUobGFtYmRhLCBwaGkpKSBzaW5rLnBvaW50KGxhbWJkYSwgcGhpKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwb2ludExpbmUobGFtYmRhLCBwaGkpIHtcclxuICAgICAgbGluZS5wb2ludChsYW1iZGEsIHBoaSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbGluZVN0YXJ0KCkge1xyXG4gICAgICBjbGlwLnBvaW50ID0gcG9pbnRMaW5lO1xyXG4gICAgICBsaW5lLmxpbmVTdGFydCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGxpbmVFbmQoKSB7XHJcbiAgICAgIGNsaXAucG9pbnQgPSBwb2ludDtcclxuICAgICAgbGluZS5saW5lRW5kKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcG9pbnRSaW5nKGxhbWJkYSwgcGhpKSB7XHJcbiAgICAgIHJpbmcucHVzaChbbGFtYmRhLCBwaGldKTtcclxuICAgICAgcmluZ1NpbmsucG9pbnQobGFtYmRhLCBwaGkpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJpbmdTdGFydCgpIHtcclxuICAgICAgcmluZ1NpbmsubGluZVN0YXJ0KCk7XHJcbiAgICAgIHJpbmcgPSBbXTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByaW5nRW5kKCkge1xyXG4gICAgICBwb2ludFJpbmcocmluZ1swXVswXSwgcmluZ1swXVsxXSk7XHJcbiAgICAgIHJpbmdTaW5rLmxpbmVFbmQoKTtcclxuXHJcbiAgICAgIHZhciBjbGVhbiA9IHJpbmdTaW5rLmNsZWFuKCksXHJcbiAgICAgICAgICByaW5nU2VnbWVudHMgPSByaW5nQnVmZmVyLnJlc3VsdCgpLFxyXG4gICAgICAgICAgaSwgbiA9IHJpbmdTZWdtZW50cy5sZW5ndGgsIG0sXHJcbiAgICAgICAgICBzZWdtZW50LFxyXG4gICAgICAgICAgcG9pbnQ7XHJcblxyXG4gICAgICByaW5nLnBvcCgpO1xyXG4gICAgICBwb2x5Z29uLnB1c2gocmluZyk7XHJcbiAgICAgIHJpbmcgPSBudWxsO1xyXG5cclxuICAgICAgaWYgKCFuKSByZXR1cm47XHJcblxyXG4gICAgICAvLyBObyBpbnRlcnNlY3Rpb25zLlxyXG4gICAgICBpZiAoY2xlYW4gJiAxKSB7XHJcbiAgICAgICAgc2VnbWVudCA9IHJpbmdTZWdtZW50c1swXTtcclxuICAgICAgICBpZiAoKG0gPSBzZWdtZW50Lmxlbmd0aCAtIDEpID4gMCkge1xyXG4gICAgICAgICAgaWYgKCFwb2x5Z29uU3RhcnRlZCkgc2luay5wb2x5Z29uU3RhcnQoKSwgcG9seWdvblN0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgc2luay5saW5lU3RhcnQoKTtcclxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBtOyArK2kpIHNpbmsucG9pbnQoKHBvaW50ID0gc2VnbWVudFtpXSlbMF0sIHBvaW50WzFdKTtcclxuICAgICAgICAgIHNpbmsubGluZUVuZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFJlam9pbiBjb25uZWN0ZWQgc2VnbWVudHMuXHJcbiAgICAgIC8vIFRPRE8gcmV1c2UgcmluZ0J1ZmZlci5yZWpvaW4oKT9cclxuICAgICAgaWYgKG4gPiAxICYmIGNsZWFuICYgMikgcmluZ1NlZ21lbnRzLnB1c2gocmluZ1NlZ21lbnRzLnBvcCgpLmNvbmNhdChyaW5nU2VnbWVudHMuc2hpZnQoKSkpO1xyXG5cclxuICAgICAgc2VnbWVudHMucHVzaChyaW5nU2VnbWVudHMuZmlsdGVyKHZhbGlkU2VnbWVudCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjbGlwO1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHZhbGlkU2VnbWVudChzZWdtZW50KSB7XHJcbiAgcmV0dXJuIHNlZ21lbnQubGVuZ3RoID4gMTtcclxufVxyXG5cclxuLy8gSW50ZXJzZWN0aW9ucyBhcmUgc29ydGVkIGFsb25nIHRoZSBjbGlwIGVkZ2UuIEZvciBib3RoIGFudGltZXJpZGlhbiBjdXR0aW5nXHJcbi8vIGFuZCBjaXJjbGUgY2xpcHBpbmcsIHRoZSBzYW1lIGNvbXBhcmlzb24gaXMgdXNlZC5cclxuZnVuY3Rpb24gY29tcGFyZUludGVyc2VjdGlvbihhLCBiKSB7XHJcbiAgcmV0dXJuICgoYSA9IGEueClbMF0gPCAwID8gYVsxXSAtIGhhbGZQaSQyIC0gZXBzaWxvbiQyIDogaGFsZlBpJDIgLSBhWzFdKVxyXG4gICAgICAgLSAoKGIgPSBiLngpWzBdIDwgMCA/IGJbMV0gLSBoYWxmUGkkMiAtIGVwc2lsb24kMiA6IGhhbGZQaSQyIC0gYlsxXSk7XHJcbn1cclxuXHJcbnZhciBjbGlwQW50aW1lcmlkaWFuID0gY2xpcChcclxuICBmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH0sXHJcbiAgY2xpcEFudGltZXJpZGlhbkxpbmUsXHJcbiAgY2xpcEFudGltZXJpZGlhbkludGVycG9sYXRlLFxyXG4gIFstcGkkMywgLWhhbGZQaSQyXVxyXG4pO1xyXG5cclxuLy8gVGFrZXMgYSBsaW5lIGFuZCBjdXRzIGludG8gdmlzaWJsZSBzZWdtZW50cy4gUmV0dXJuIHZhbHVlczogMCAtIHRoZXJlIHdlcmVcclxuLy8gaW50ZXJzZWN0aW9ucyBvciB0aGUgbGluZSB3YXMgZW1wdHk7IDEgLSBubyBpbnRlcnNlY3Rpb25zOyAyIC0gdGhlcmUgd2VyZVxyXG4vLyBpbnRlcnNlY3Rpb25zLCBhbmQgdGhlIGZpcnN0IGFuZCBsYXN0IHNlZ21lbnRzIHNob3VsZCBiZSByZWpvaW5lZC5cclxuZnVuY3Rpb24gY2xpcEFudGltZXJpZGlhbkxpbmUoc3RyZWFtKSB7XHJcbiAgdmFyIGxhbWJkYTAgPSBOYU4sXHJcbiAgICAgIHBoaTAgPSBOYU4sXHJcbiAgICAgIHNpZ24wID0gTmFOLFxyXG4gICAgICBjbGVhbjsgLy8gbm8gaW50ZXJzZWN0aW9uc1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcclxuICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xyXG4gICAgICBjbGVhbiA9IDE7XHJcbiAgICB9LFxyXG4gICAgcG9pbnQ6IGZ1bmN0aW9uKGxhbWJkYTEsIHBoaTEpIHtcclxuICAgICAgdmFyIHNpZ24xID0gbGFtYmRhMSA+IDAgPyBwaSQzIDogLXBpJDMsXHJcbiAgICAgICAgICBkZWx0YSA9IGFicyhsYW1iZGExIC0gbGFtYmRhMCk7XHJcbiAgICAgIGlmIChhYnMoZGVsdGEgLSBwaSQzKSA8IGVwc2lsb24kMikgeyAvLyBsaW5lIGNyb3NzZXMgYSBwb2xlXHJcbiAgICAgICAgc3RyZWFtLnBvaW50KGxhbWJkYTAsIHBoaTAgPSAocGhpMCArIHBoaTEpIC8gMiA+IDAgPyBoYWxmUGkkMiA6IC1oYWxmUGkkMik7XHJcbiAgICAgICAgc3RyZWFtLnBvaW50KHNpZ24wLCBwaGkwKTtcclxuICAgICAgICBzdHJlYW0ubGluZUVuZCgpO1xyXG4gICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcclxuICAgICAgICBzdHJlYW0ucG9pbnQoc2lnbjEsIHBoaTApO1xyXG4gICAgICAgIHN0cmVhbS5wb2ludChsYW1iZGExLCBwaGkwKTtcclxuICAgICAgICBjbGVhbiA9IDA7XHJcbiAgICAgIH0gZWxzZSBpZiAoc2lnbjAgIT09IHNpZ24xICYmIGRlbHRhID49IHBpJDMpIHsgLy8gbGluZSBjcm9zc2VzIGFudGltZXJpZGlhblxyXG4gICAgICAgIGlmIChhYnMobGFtYmRhMCAtIHNpZ24wKSA8IGVwc2lsb24kMikgbGFtYmRhMCAtPSBzaWduMCAqIGVwc2lsb24kMjsgLy8gaGFuZGxlIGRlZ2VuZXJhY2llc1xyXG4gICAgICAgIGlmIChhYnMobGFtYmRhMSAtIHNpZ24xKSA8IGVwc2lsb24kMikgbGFtYmRhMSAtPSBzaWduMSAqIGVwc2lsb24kMjtcclxuICAgICAgICBwaGkwID0gY2xpcEFudGltZXJpZGlhbkludGVyc2VjdChsYW1iZGEwLCBwaGkwLCBsYW1iZGExLCBwaGkxKTtcclxuICAgICAgICBzdHJlYW0ucG9pbnQoc2lnbjAsIHBoaTApO1xyXG4gICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XHJcbiAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xyXG4gICAgICAgIHN0cmVhbS5wb2ludChzaWduMSwgcGhpMCk7XHJcbiAgICAgICAgY2xlYW4gPSAwO1xyXG4gICAgICB9XHJcbiAgICAgIHN0cmVhbS5wb2ludChsYW1iZGEwID0gbGFtYmRhMSwgcGhpMCA9IHBoaTEpO1xyXG4gICAgICBzaWduMCA9IHNpZ24xO1xyXG4gICAgfSxcclxuICAgIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICBzdHJlYW0ubGluZUVuZCgpO1xyXG4gICAgICBsYW1iZGEwID0gcGhpMCA9IE5hTjtcclxuICAgIH0sXHJcbiAgICBjbGVhbjogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiAyIC0gY2xlYW47IC8vIGlmIGludGVyc2VjdGlvbnMsIHJlam9pbiBmaXJzdCBhbmQgbGFzdCBzZWdtZW50c1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNsaXBBbnRpbWVyaWRpYW5JbnRlcnNlY3QobGFtYmRhMCwgcGhpMCwgbGFtYmRhMSwgcGhpMSkge1xyXG4gIHZhciBjb3NQaGkwLFxyXG4gICAgICBjb3NQaGkxLFxyXG4gICAgICBzaW5MYW1iZGEwTGFtYmRhMSA9IHNpbiQxKGxhbWJkYTAgLSBsYW1iZGExKTtcclxuICByZXR1cm4gYWJzKHNpbkxhbWJkYTBMYW1iZGExKSA+IGVwc2lsb24kMlxyXG4gICAgICA/IGF0YW4oKHNpbiQxKHBoaTApICogKGNvc1BoaTEgPSBjb3MkMShwaGkxKSkgKiBzaW4kMShsYW1iZGExKVxyXG4gICAgICAgICAgLSBzaW4kMShwaGkxKSAqIChjb3NQaGkwID0gY29zJDEocGhpMCkpICogc2luJDEobGFtYmRhMCkpXHJcbiAgICAgICAgICAvIChjb3NQaGkwICogY29zUGhpMSAqIHNpbkxhbWJkYTBMYW1iZGExKSlcclxuICAgICAgOiAocGhpMCArIHBoaTEpIC8gMjtcclxufVxyXG5cclxuZnVuY3Rpb24gY2xpcEFudGltZXJpZGlhbkludGVycG9sYXRlKGZyb20sIHRvLCBkaXJlY3Rpb24sIHN0cmVhbSkge1xyXG4gIHZhciBwaGk7XHJcbiAgaWYgKGZyb20gPT0gbnVsbCkge1xyXG4gICAgcGhpID0gZGlyZWN0aW9uICogaGFsZlBpJDI7XHJcbiAgICBzdHJlYW0ucG9pbnQoLXBpJDMsIHBoaSk7XHJcbiAgICBzdHJlYW0ucG9pbnQoMCwgcGhpKTtcclxuICAgIHN0cmVhbS5wb2ludChwaSQzLCBwaGkpO1xyXG4gICAgc3RyZWFtLnBvaW50KHBpJDMsIDApO1xyXG4gICAgc3RyZWFtLnBvaW50KHBpJDMsIC1waGkpO1xyXG4gICAgc3RyZWFtLnBvaW50KDAsIC1waGkpO1xyXG4gICAgc3RyZWFtLnBvaW50KC1waSQzLCAtcGhpKTtcclxuICAgIHN0cmVhbS5wb2ludCgtcGkkMywgMCk7XHJcbiAgICBzdHJlYW0ucG9pbnQoLXBpJDMsIHBoaSk7XHJcbiAgfSBlbHNlIGlmIChhYnMoZnJvbVswXSAtIHRvWzBdKSA+IGVwc2lsb24kMikge1xyXG4gICAgdmFyIGxhbWJkYSA9IGZyb21bMF0gPCB0b1swXSA/IHBpJDMgOiAtcGkkMztcclxuICAgIHBoaSA9IGRpcmVjdGlvbiAqIGxhbWJkYSAvIDI7XHJcbiAgICBzdHJlYW0ucG9pbnQoLWxhbWJkYSwgcGhpKTtcclxuICAgIHN0cmVhbS5wb2ludCgwLCBwaGkpO1xyXG4gICAgc3RyZWFtLnBvaW50KGxhbWJkYSwgcGhpKTtcclxuICB9IGVsc2Uge1xyXG4gICAgc3RyZWFtLnBvaW50KHRvWzBdLCB0b1sxXSk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBjbGlwQ2lyY2xlKHJhZGl1cykge1xyXG4gIHZhciBjciA9IGNvcyQxKHJhZGl1cyksXHJcbiAgICAgIGRlbHRhID0gNiAqIHJhZGlhbnMsXHJcbiAgICAgIHNtYWxsUmFkaXVzID0gY3IgPiAwLFxyXG4gICAgICBub3RIZW1pc3BoZXJlID0gYWJzKGNyKSA+IGVwc2lsb24kMjsgLy8gVE9ETyBvcHRpbWlzZSBmb3IgdGhpcyBjb21tb24gY2FzZVxyXG5cclxuICBmdW5jdGlvbiBpbnRlcnBvbGF0ZShmcm9tLCB0bywgZGlyZWN0aW9uLCBzdHJlYW0pIHtcclxuICAgIGNpcmNsZVN0cmVhbShzdHJlYW0sIHJhZGl1cywgZGVsdGEsIGRpcmVjdGlvbiwgZnJvbSwgdG8pO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdmlzaWJsZShsYW1iZGEsIHBoaSkge1xyXG4gICAgcmV0dXJuIGNvcyQxKGxhbWJkYSkgKiBjb3MkMShwaGkpID4gY3I7XHJcbiAgfVxyXG5cclxuICAvLyBUYWtlcyBhIGxpbmUgYW5kIGN1dHMgaW50byB2aXNpYmxlIHNlZ21lbnRzLiBSZXR1cm4gdmFsdWVzIHVzZWQgZm9yIHBvbHlnb25cclxuICAvLyBjbGlwcGluZzogMCAtIHRoZXJlIHdlcmUgaW50ZXJzZWN0aW9ucyBvciB0aGUgbGluZSB3YXMgZW1wdHk7IDEgLSBub1xyXG4gIC8vIGludGVyc2VjdGlvbnMgMiAtIHRoZXJlIHdlcmUgaW50ZXJzZWN0aW9ucywgYW5kIHRoZSBmaXJzdCBhbmQgbGFzdCBzZWdtZW50c1xyXG4gIC8vIHNob3VsZCBiZSByZWpvaW5lZC5cclxuICBmdW5jdGlvbiBjbGlwTGluZShzdHJlYW0pIHtcclxuICAgIHZhciBwb2ludDAsIC8vIHByZXZpb3VzIHBvaW50XHJcbiAgICAgICAgYzAsIC8vIGNvZGUgZm9yIHByZXZpb3VzIHBvaW50XHJcbiAgICAgICAgdjAsIC8vIHZpc2liaWxpdHkgb2YgcHJldmlvdXMgcG9pbnRcclxuICAgICAgICB2MDAsIC8vIHZpc2liaWxpdHkgb2YgZmlyc3QgcG9pbnRcclxuICAgICAgICBjbGVhbjsgLy8gbm8gaW50ZXJzZWN0aW9uc1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2MDAgPSB2MCA9IGZhbHNlO1xyXG4gICAgICAgIGNsZWFuID0gMTtcclxuICAgICAgfSxcclxuICAgICAgcG9pbnQ6IGZ1bmN0aW9uKGxhbWJkYSwgcGhpKSB7XHJcbiAgICAgICAgdmFyIHBvaW50MSA9IFtsYW1iZGEsIHBoaV0sXHJcbiAgICAgICAgICAgIHBvaW50MixcclxuICAgICAgICAgICAgdiA9IHZpc2libGUobGFtYmRhLCBwaGkpLFxyXG4gICAgICAgICAgICBjID0gc21hbGxSYWRpdXNcclxuICAgICAgICAgICAgICA/IHYgPyAwIDogY29kZShsYW1iZGEsIHBoaSlcclxuICAgICAgICAgICAgICA6IHYgPyBjb2RlKGxhbWJkYSArIChsYW1iZGEgPCAwID8gcGkkMyA6IC1waSQzKSwgcGhpKSA6IDA7XHJcbiAgICAgICAgaWYgKCFwb2ludDAgJiYgKHYwMCA9IHYwID0gdikpIHN0cmVhbS5saW5lU3RhcnQoKTtcclxuICAgICAgICAvLyBIYW5kbGUgZGVnZW5lcmFjaWVzLlxyXG4gICAgICAgIC8vIFRPRE8gaWdub3JlIGlmIG5vdCBjbGlwcGluZyBwb2x5Z29ucy5cclxuICAgICAgICBpZiAodiAhPT0gdjApIHtcclxuICAgICAgICAgIHBvaW50MiA9IGludGVyc2VjdChwb2ludDAsIHBvaW50MSk7XHJcbiAgICAgICAgICBpZiAoIXBvaW50MiB8fCBwb2ludEVxdWFsKHBvaW50MCwgcG9pbnQyKSB8fCBwb2ludEVxdWFsKHBvaW50MSwgcG9pbnQyKSkge1xyXG4gICAgICAgICAgICBwb2ludDFbMF0gKz0gZXBzaWxvbiQyO1xyXG4gICAgICAgICAgICBwb2ludDFbMV0gKz0gZXBzaWxvbiQyO1xyXG4gICAgICAgICAgICB2ID0gdmlzaWJsZShwb2ludDFbMF0sIHBvaW50MVsxXSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2ICE9PSB2MCkge1xyXG4gICAgICAgICAgY2xlYW4gPSAwO1xyXG4gICAgICAgICAgaWYgKHYpIHtcclxuICAgICAgICAgICAgLy8gb3V0c2lkZSBnb2luZyBpblxyXG4gICAgICAgICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XHJcbiAgICAgICAgICAgIHBvaW50MiA9IGludGVyc2VjdChwb2ludDEsIHBvaW50MCk7XHJcbiAgICAgICAgICAgIHN0cmVhbS5wb2ludChwb2ludDJbMF0sIHBvaW50MlsxXSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBpbnNpZGUgZ29pbmcgb3V0XHJcbiAgICAgICAgICAgIHBvaW50MiA9IGludGVyc2VjdChwb2ludDAsIHBvaW50MSk7XHJcbiAgICAgICAgICAgIHN0cmVhbS5wb2ludChwb2ludDJbMF0sIHBvaW50MlsxXSk7XHJcbiAgICAgICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBwb2ludDAgPSBwb2ludDI7XHJcbiAgICAgICAgfSBlbHNlIGlmIChub3RIZW1pc3BoZXJlICYmIHBvaW50MCAmJiBzbWFsbFJhZGl1cyBeIHYpIHtcclxuICAgICAgICAgIHZhciB0O1xyXG4gICAgICAgICAgLy8gSWYgdGhlIGNvZGVzIGZvciB0d28gcG9pbnRzIGFyZSBkaWZmZXJlbnQsIG9yIGFyZSBib3RoIHplcm8sXHJcbiAgICAgICAgICAvLyBhbmQgdGhlcmUgdGhpcyBzZWdtZW50IGludGVyc2VjdHMgd2l0aCB0aGUgc21hbGwgY2lyY2xlLlxyXG4gICAgICAgICAgaWYgKCEoYyAmIGMwKSAmJiAodCA9IGludGVyc2VjdChwb2ludDEsIHBvaW50MCwgdHJ1ZSkpKSB7XHJcbiAgICAgICAgICAgIGNsZWFuID0gMDtcclxuICAgICAgICAgICAgaWYgKHNtYWxsUmFkaXVzKSB7XHJcbiAgICAgICAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xyXG4gICAgICAgICAgICAgIHN0cmVhbS5wb2ludCh0WzBdWzBdLCB0WzBdWzFdKTtcclxuICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQodFsxXVswXSwgdFsxXVsxXSk7XHJcbiAgICAgICAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQodFsxXVswXSwgdFsxXVsxXSk7XHJcbiAgICAgICAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcclxuICAgICAgICAgICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XHJcbiAgICAgICAgICAgICAgc3RyZWFtLnBvaW50KHRbMF1bMF0sIHRbMF1bMV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2ICYmICghcG9pbnQwIHx8ICFwb2ludEVxdWFsKHBvaW50MCwgcG9pbnQxKSkpIHtcclxuICAgICAgICAgIHN0cmVhbS5wb2ludChwb2ludDFbMF0sIHBvaW50MVsxXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBvaW50MCA9IHBvaW50MSwgdjAgPSB2LCBjMCA9IGM7XHJcbiAgICAgIH0sXHJcbiAgICAgIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh2MCkgc3RyZWFtLmxpbmVFbmQoKTtcclxuICAgICAgICBwb2ludDAgPSBudWxsO1xyXG4gICAgICB9LFxyXG4gICAgICAvLyBSZWpvaW4gZmlyc3QgYW5kIGxhc3Qgc2VnbWVudHMgaWYgdGhlcmUgd2VyZSBpbnRlcnNlY3Rpb25zIGFuZCB0aGUgZmlyc3RcclxuICAgICAgLy8gYW5kIGxhc3QgcG9pbnRzIHdlcmUgdmlzaWJsZS5cclxuICAgICAgY2xlYW46IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBjbGVhbiB8ICgodjAwICYmIHYwKSA8PCAxKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIEludGVyc2VjdHMgdGhlIGdyZWF0IGNpcmNsZSBiZXR3ZWVuIGEgYW5kIGIgd2l0aCB0aGUgY2xpcCBjaXJjbGUuXHJcbiAgZnVuY3Rpb24gaW50ZXJzZWN0KGEsIGIsIHR3bykge1xyXG4gICAgdmFyIHBhID0gY2FydGVzaWFuKGEpLFxyXG4gICAgICAgIHBiID0gY2FydGVzaWFuKGIpO1xyXG5cclxuICAgIC8vIFdlIGhhdmUgdHdvIHBsYW5lcywgbjEucCA9IGQxIGFuZCBuMi5wID0gZDIuXHJcbiAgICAvLyBGaW5kIGludGVyc2VjdGlvbiBsaW5lIHAodCkgPSBjMSBuMSArIGMyIG4yICsgdCAobjEg4qivIG4yKS5cclxuICAgIHZhciBuMSA9IFsxLCAwLCAwXSwgLy8gbm9ybWFsXHJcbiAgICAgICAgbjIgPSBjYXJ0ZXNpYW5Dcm9zcyhwYSwgcGIpLFxyXG4gICAgICAgIG4ybjIgPSBjYXJ0ZXNpYW5Eb3QobjIsIG4yKSxcclxuICAgICAgICBuMW4yID0gbjJbMF0sIC8vIGNhcnRlc2lhbkRvdChuMSwgbjIpLFxyXG4gICAgICAgIGRldGVybWluYW50ID0gbjJuMiAtIG4xbjIgKiBuMW4yO1xyXG5cclxuICAgIC8vIFR3byBwb2xhciBwb2ludHMuXHJcbiAgICBpZiAoIWRldGVybWluYW50KSByZXR1cm4gIXR3byAmJiBhO1xyXG5cclxuICAgIHZhciBjMSA9ICBjciAqIG4ybjIgLyBkZXRlcm1pbmFudCxcclxuICAgICAgICBjMiA9IC1jciAqIG4xbjIgLyBkZXRlcm1pbmFudCxcclxuICAgICAgICBuMXhuMiA9IGNhcnRlc2lhbkNyb3NzKG4xLCBuMiksXHJcbiAgICAgICAgQSA9IGNhcnRlc2lhblNjYWxlKG4xLCBjMSksXHJcbiAgICAgICAgQiA9IGNhcnRlc2lhblNjYWxlKG4yLCBjMik7XHJcbiAgICBjYXJ0ZXNpYW5BZGRJblBsYWNlKEEsIEIpO1xyXG5cclxuICAgIC8vIFNvbHZlIHxwKHQpfF4yID0gMS5cclxuICAgIHZhciB1ID0gbjF4bjIsXHJcbiAgICAgICAgdyA9IGNhcnRlc2lhbkRvdChBLCB1KSxcclxuICAgICAgICB1dSA9IGNhcnRlc2lhbkRvdCh1LCB1KSxcclxuICAgICAgICB0MiA9IHcgKiB3IC0gdXUgKiAoY2FydGVzaWFuRG90KEEsIEEpIC0gMSk7XHJcblxyXG4gICAgaWYgKHQyIDwgMCkgcmV0dXJuO1xyXG5cclxuICAgIHZhciB0ID0gc3FydCh0MiksXHJcbiAgICAgICAgcSA9IGNhcnRlc2lhblNjYWxlKHUsICgtdyAtIHQpIC8gdXUpO1xyXG4gICAgY2FydGVzaWFuQWRkSW5QbGFjZShxLCBBKTtcclxuICAgIHEgPSBzcGhlcmljYWwocSk7XHJcblxyXG4gICAgaWYgKCF0d28pIHJldHVybiBxO1xyXG5cclxuICAgIC8vIFR3byBpbnRlcnNlY3Rpb24gcG9pbnRzLlxyXG4gICAgdmFyIGxhbWJkYTAgPSBhWzBdLFxyXG4gICAgICAgIGxhbWJkYTEgPSBiWzBdLFxyXG4gICAgICAgIHBoaTAgPSBhWzFdLFxyXG4gICAgICAgIHBoaTEgPSBiWzFdLFxyXG4gICAgICAgIHo7XHJcblxyXG4gICAgaWYgKGxhbWJkYTEgPCBsYW1iZGEwKSB6ID0gbGFtYmRhMCwgbGFtYmRhMCA9IGxhbWJkYTEsIGxhbWJkYTEgPSB6O1xyXG5cclxuICAgIHZhciBkZWx0YSA9IGxhbWJkYTEgLSBsYW1iZGEwLFxyXG4gICAgICAgIHBvbGFyID0gYWJzKGRlbHRhIC0gcGkkMykgPCBlcHNpbG9uJDIsXHJcbiAgICAgICAgbWVyaWRpYW4gPSBwb2xhciB8fCBkZWx0YSA8IGVwc2lsb24kMjtcclxuXHJcbiAgICBpZiAoIXBvbGFyICYmIHBoaTEgPCBwaGkwKSB6ID0gcGhpMCwgcGhpMCA9IHBoaTEsIHBoaTEgPSB6O1xyXG5cclxuICAgIC8vIENoZWNrIHRoYXQgdGhlIGZpcnN0IHBvaW50IGlzIGJldHdlZW4gYSBhbmQgYi5cclxuICAgIGlmIChtZXJpZGlhblxyXG4gICAgICAgID8gcG9sYXJcclxuICAgICAgICAgID8gcGhpMCArIHBoaTEgPiAwIF4gcVsxXSA8IChhYnMocVswXSAtIGxhbWJkYTApIDwgZXBzaWxvbiQyID8gcGhpMCA6IHBoaTEpXHJcbiAgICAgICAgICA6IHBoaTAgPD0gcVsxXSAmJiBxWzFdIDw9IHBoaTFcclxuICAgICAgICA6IGRlbHRhID4gcGkkMyBeIChsYW1iZGEwIDw9IHFbMF0gJiYgcVswXSA8PSBsYW1iZGExKSkge1xyXG4gICAgICB2YXIgcTEgPSBjYXJ0ZXNpYW5TY2FsZSh1LCAoLXcgKyB0KSAvIHV1KTtcclxuICAgICAgY2FydGVzaWFuQWRkSW5QbGFjZShxMSwgQSk7XHJcbiAgICAgIHJldHVybiBbcSwgc3BoZXJpY2FsKHExKV07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBHZW5lcmF0ZXMgYSA0LWJpdCB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBsb2NhdGlvbiBvZiBhIHBvaW50IHJlbGF0aXZlIHRvXHJcbiAgLy8gdGhlIHNtYWxsIGNpcmNsZSdzIGJvdW5kaW5nIGJveC5cclxuICBmdW5jdGlvbiBjb2RlKGxhbWJkYSwgcGhpKSB7XHJcbiAgICB2YXIgciA9IHNtYWxsUmFkaXVzID8gcmFkaXVzIDogcGkkMyAtIHJhZGl1cyxcclxuICAgICAgICBjb2RlID0gMDtcclxuICAgIGlmIChsYW1iZGEgPCAtcikgY29kZSB8PSAxOyAvLyBsZWZ0XHJcbiAgICBlbHNlIGlmIChsYW1iZGEgPiByKSBjb2RlIHw9IDI7IC8vIHJpZ2h0XHJcbiAgICBpZiAocGhpIDwgLXIpIGNvZGUgfD0gNDsgLy8gYmVsb3dcclxuICAgIGVsc2UgaWYgKHBoaSA+IHIpIGNvZGUgfD0gODsgLy8gYWJvdmVcclxuICAgIHJldHVybiBjb2RlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGNsaXAodmlzaWJsZSwgY2xpcExpbmUsIGludGVycG9sYXRlLCBzbWFsbFJhZGl1cyA/IFswLCAtcmFkaXVzXSA6IFstcGkkMywgcmFkaXVzIC0gcGkkM10pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjbGlwTGluZShhLCBiLCB4MCwgeTAsIHgxLCB5MSkge1xyXG4gIHZhciBheCA9IGFbMF0sXHJcbiAgICAgIGF5ID0gYVsxXSxcclxuICAgICAgYnggPSBiWzBdLFxyXG4gICAgICBieSA9IGJbMV0sXHJcbiAgICAgIHQwID0gMCxcclxuICAgICAgdDEgPSAxLFxyXG4gICAgICBkeCA9IGJ4IC0gYXgsXHJcbiAgICAgIGR5ID0gYnkgLSBheSxcclxuICAgICAgcjtcclxuXHJcbiAgciA9IHgwIC0gYXg7XHJcbiAgaWYgKCFkeCAmJiByID4gMCkgcmV0dXJuO1xyXG4gIHIgLz0gZHg7XHJcbiAgaWYgKGR4IDwgMCkge1xyXG4gICAgaWYgKHIgPCB0MCkgcmV0dXJuO1xyXG4gICAgaWYgKHIgPCB0MSkgdDEgPSByO1xyXG4gIH0gZWxzZSBpZiAoZHggPiAwKSB7XHJcbiAgICBpZiAociA+IHQxKSByZXR1cm47XHJcbiAgICBpZiAociA+IHQwKSB0MCA9IHI7XHJcbiAgfVxyXG5cclxuICByID0geDEgLSBheDtcclxuICBpZiAoIWR4ICYmIHIgPCAwKSByZXR1cm47XHJcbiAgciAvPSBkeDtcclxuICBpZiAoZHggPCAwKSB7XHJcbiAgICBpZiAociA+IHQxKSByZXR1cm47XHJcbiAgICBpZiAociA+IHQwKSB0MCA9IHI7XHJcbiAgfSBlbHNlIGlmIChkeCA+IDApIHtcclxuICAgIGlmIChyIDwgdDApIHJldHVybjtcclxuICAgIGlmIChyIDwgdDEpIHQxID0gcjtcclxuICB9XHJcblxyXG4gIHIgPSB5MCAtIGF5O1xyXG4gIGlmICghZHkgJiYgciA+IDApIHJldHVybjtcclxuICByIC89IGR5O1xyXG4gIGlmIChkeSA8IDApIHtcclxuICAgIGlmIChyIDwgdDApIHJldHVybjtcclxuICAgIGlmIChyIDwgdDEpIHQxID0gcjtcclxuICB9IGVsc2UgaWYgKGR5ID4gMCkge1xyXG4gICAgaWYgKHIgPiB0MSkgcmV0dXJuO1xyXG4gICAgaWYgKHIgPiB0MCkgdDAgPSByO1xyXG4gIH1cclxuXHJcbiAgciA9IHkxIC0gYXk7XHJcbiAgaWYgKCFkeSAmJiByIDwgMCkgcmV0dXJuO1xyXG4gIHIgLz0gZHk7XHJcbiAgaWYgKGR5IDwgMCkge1xyXG4gICAgaWYgKHIgPiB0MSkgcmV0dXJuO1xyXG4gICAgaWYgKHIgPiB0MCkgdDAgPSByO1xyXG4gIH0gZWxzZSBpZiAoZHkgPiAwKSB7XHJcbiAgICBpZiAociA8IHQwKSByZXR1cm47XHJcbiAgICBpZiAociA8IHQxKSB0MSA9IHI7XHJcbiAgfVxyXG5cclxuICBpZiAodDAgPiAwKSBhWzBdID0gYXggKyB0MCAqIGR4LCBhWzFdID0gYXkgKyB0MCAqIGR5O1xyXG4gIGlmICh0MSA8IDEpIGJbMF0gPSBheCArIHQxICogZHgsIGJbMV0gPSBheSArIHQxICogZHk7XHJcbiAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbnZhciBjbGlwTWF4ID0gMWU5LCBjbGlwTWluID0gLWNsaXBNYXg7XHJcblxyXG4vLyBUT0RPIFVzZSBkMy1wb2x5Z29u4oCZcyBwb2x5Z29uQ29udGFpbnMgaGVyZSBmb3IgdGhlIHJpbmcgY2hlY2s/XHJcbi8vIFRPRE8gRWxpbWluYXRlIGR1cGxpY2F0ZSBidWZmZXJpbmcgaW4gY2xpcEJ1ZmZlciBhbmQgcG9seWdvbi5wdXNoP1xyXG5cclxuZnVuY3Rpb24gY2xpcFJlY3RhbmdsZSh4MCwgeTAsIHgxLCB5MSkge1xyXG5cclxuICBmdW5jdGlvbiB2aXNpYmxlKHgsIHkpIHtcclxuICAgIHJldHVybiB4MCA8PSB4ICYmIHggPD0geDEgJiYgeTAgPD0geSAmJiB5IDw9IHkxO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaW50ZXJwb2xhdGUoZnJvbSwgdG8sIGRpcmVjdGlvbiwgc3RyZWFtKSB7XHJcbiAgICB2YXIgYSA9IDAsIGExID0gMDtcclxuICAgIGlmIChmcm9tID09IG51bGxcclxuICAgICAgICB8fCAoYSA9IGNvcm5lcihmcm9tLCBkaXJlY3Rpb24pKSAhPT0gKGExID0gY29ybmVyKHRvLCBkaXJlY3Rpb24pKVxyXG4gICAgICAgIHx8IGNvbXBhcmVQb2ludChmcm9tLCB0bykgPCAwIF4gZGlyZWN0aW9uID4gMCkge1xyXG4gICAgICBkbyBzdHJlYW0ucG9pbnQoYSA9PT0gMCB8fCBhID09PSAzID8geDAgOiB4MSwgYSA+IDEgPyB5MSA6IHkwKTtcclxuICAgICAgd2hpbGUgKChhID0gKGEgKyBkaXJlY3Rpb24gKyA0KSAlIDQpICE9PSBhMSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzdHJlYW0ucG9pbnQodG9bMF0sIHRvWzFdKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNvcm5lcihwLCBkaXJlY3Rpb24pIHtcclxuICAgIHJldHVybiBhYnMocFswXSAtIHgwKSA8IGVwc2lsb24kMiA/IGRpcmVjdGlvbiA+IDAgPyAwIDogM1xyXG4gICAgICAgIDogYWJzKHBbMF0gLSB4MSkgPCBlcHNpbG9uJDIgPyBkaXJlY3Rpb24gPiAwID8gMiA6IDFcclxuICAgICAgICA6IGFicyhwWzFdIC0geTApIDwgZXBzaWxvbiQyID8gZGlyZWN0aW9uID4gMCA/IDEgOiAwXHJcbiAgICAgICAgOiBkaXJlY3Rpb24gPiAwID8gMyA6IDI7IC8vIGFicyhwWzFdIC0geTEpIDwgZXBzaWxvblxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY29tcGFyZUludGVyc2VjdGlvbihhLCBiKSB7XHJcbiAgICByZXR1cm4gY29tcGFyZVBvaW50KGEueCwgYi54KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNvbXBhcmVQb2ludChhLCBiKSB7XHJcbiAgICB2YXIgY2EgPSBjb3JuZXIoYSwgMSksXHJcbiAgICAgICAgY2IgPSBjb3JuZXIoYiwgMSk7XHJcbiAgICByZXR1cm4gY2EgIT09IGNiID8gY2EgLSBjYlxyXG4gICAgICAgIDogY2EgPT09IDAgPyBiWzFdIC0gYVsxXVxyXG4gICAgICAgIDogY2EgPT09IDEgPyBhWzBdIC0gYlswXVxyXG4gICAgICAgIDogY2EgPT09IDIgPyBhWzFdIC0gYlsxXVxyXG4gICAgICAgIDogYlswXSAtIGFbMF07XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtKSB7XHJcbiAgICB2YXIgYWN0aXZlU3RyZWFtID0gc3RyZWFtLFxyXG4gICAgICAgIGJ1ZmZlclN0cmVhbSA9IGNsaXBCdWZmZXIoKSxcclxuICAgICAgICBzZWdtZW50cyxcclxuICAgICAgICBwb2x5Z29uLFxyXG4gICAgICAgIHJpbmcsXHJcbiAgICAgICAgeF9fLCB5X18sIHZfXywgLy8gZmlyc3QgcG9pbnRcclxuICAgICAgICB4XywgeV8sIHZfLCAvLyBwcmV2aW91cyBwb2ludFxyXG4gICAgICAgIGZpcnN0LFxyXG4gICAgICAgIGNsZWFuO1xyXG5cclxuICAgIHZhciBjbGlwU3RyZWFtID0ge1xyXG4gICAgICBwb2ludDogcG9pbnQsXHJcbiAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxyXG4gICAgICBsaW5lRW5kOiBsaW5lRW5kLFxyXG4gICAgICBwb2x5Z29uU3RhcnQ6IHBvbHlnb25TdGFydCxcclxuICAgICAgcG9seWdvbkVuZDogcG9seWdvbkVuZFxyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBwb2ludCh4LCB5KSB7XHJcbiAgICAgIGlmICh2aXNpYmxlKHgsIHkpKSBhY3RpdmVTdHJlYW0ucG9pbnQoeCwgeSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcG9seWdvbkluc2lkZSgpIHtcclxuICAgICAgdmFyIHdpbmRpbmcgPSAwO1xyXG5cclxuICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBwb2x5Z29uLmxlbmd0aDsgaSA8IG47ICsraSkge1xyXG4gICAgICAgIGZvciAodmFyIHJpbmcgPSBwb2x5Z29uW2ldLCBqID0gMSwgbSA9IHJpbmcubGVuZ3RoLCBwb2ludCA9IHJpbmdbMF0sIGEwLCBhMSwgYjAgPSBwb2ludFswXSwgYjEgPSBwb2ludFsxXTsgaiA8IG07ICsraikge1xyXG4gICAgICAgICAgYTAgPSBiMCwgYTEgPSBiMSwgcG9pbnQgPSByaW5nW2pdLCBiMCA9IHBvaW50WzBdLCBiMSA9IHBvaW50WzFdO1xyXG4gICAgICAgICAgaWYgKGExIDw9IHkxKSB7IGlmIChiMSA+IHkxICYmIChiMCAtIGEwKSAqICh5MSAtIGExKSA+IChiMSAtIGExKSAqICh4MCAtIGEwKSkgKyt3aW5kaW5nOyB9XHJcbiAgICAgICAgICBlbHNlIHsgaWYgKGIxIDw9IHkxICYmIChiMCAtIGEwKSAqICh5MSAtIGExKSA8IChiMSAtIGExKSAqICh4MCAtIGEwKSkgLS13aW5kaW5nOyB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gd2luZGluZztcclxuICAgIH1cclxuXHJcbiAgICAvLyBCdWZmZXIgZ2VvbWV0cnkgd2l0aGluIGEgcG9seWdvbiBhbmQgdGhlbiBjbGlwIGl0IGVuIG1hc3NlLlxyXG4gICAgZnVuY3Rpb24gcG9seWdvblN0YXJ0KCkge1xyXG4gICAgICBhY3RpdmVTdHJlYW0gPSBidWZmZXJTdHJlYW0sIHNlZ21lbnRzID0gW10sIHBvbHlnb24gPSBbXSwgY2xlYW4gPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHBvbHlnb25FbmQoKSB7XHJcbiAgICAgIHZhciBzdGFydEluc2lkZSA9IHBvbHlnb25JbnNpZGUoKSxcclxuICAgICAgICAgIGNsZWFuSW5zaWRlID0gY2xlYW4gJiYgc3RhcnRJbnNpZGUsXHJcbiAgICAgICAgICB2aXNpYmxlID0gKHNlZ21lbnRzID0gbWVyZ2Uoc2VnbWVudHMpKS5sZW5ndGg7XHJcbiAgICAgIGlmIChjbGVhbkluc2lkZSB8fCB2aXNpYmxlKSB7XHJcbiAgICAgICAgc3RyZWFtLnBvbHlnb25TdGFydCgpO1xyXG4gICAgICAgIGlmIChjbGVhbkluc2lkZSkge1xyXG4gICAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xyXG4gICAgICAgICAgaW50ZXJwb2xhdGUobnVsbCwgbnVsbCwgMSwgc3RyZWFtKTtcclxuICAgICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2aXNpYmxlKSB7XHJcbiAgICAgICAgICBjbGlwUmVqb2luKHNlZ21lbnRzLCBjb21wYXJlSW50ZXJzZWN0aW9uLCBzdGFydEluc2lkZSwgaW50ZXJwb2xhdGUsIHN0cmVhbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0cmVhbS5wb2x5Z29uRW5kKCk7XHJcbiAgICAgIH1cclxuICAgICAgYWN0aXZlU3RyZWFtID0gc3RyZWFtLCBzZWdtZW50cyA9IHBvbHlnb24gPSByaW5nID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBsaW5lU3RhcnQoKSB7XHJcbiAgICAgIGNsaXBTdHJlYW0ucG9pbnQgPSBsaW5lUG9pbnQ7XHJcbiAgICAgIGlmIChwb2x5Z29uKSBwb2x5Z29uLnB1c2gocmluZyA9IFtdKTtcclxuICAgICAgZmlyc3QgPSB0cnVlO1xyXG4gICAgICB2XyA9IGZhbHNlO1xyXG4gICAgICB4XyA9IHlfID0gTmFOO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRPRE8gcmF0aGVyIHRoYW4gc3BlY2lhbC1jYXNlIHBvbHlnb25zLCBzaW1wbHkgaGFuZGxlIHRoZW0gc2VwYXJhdGVseS5cclxuICAgIC8vIElkZWFsbHksIGNvaW5jaWRlbnQgaW50ZXJzZWN0aW9uIHBvaW50cyBzaG91bGQgYmUgaml0dGVyZWQgdG8gYXZvaWRcclxuICAgIC8vIGNsaXBwaW5nIGlzc3Vlcy5cclxuICAgIGZ1bmN0aW9uIGxpbmVFbmQoKSB7XHJcbiAgICAgIGlmIChzZWdtZW50cykge1xyXG4gICAgICAgIGxpbmVQb2ludCh4X18sIHlfXyk7XHJcbiAgICAgICAgaWYgKHZfXyAmJiB2XykgYnVmZmVyU3RyZWFtLnJlam9pbigpO1xyXG4gICAgICAgIHNlZ21lbnRzLnB1c2goYnVmZmVyU3RyZWFtLnJlc3VsdCgpKTtcclxuICAgICAgfVxyXG4gICAgICBjbGlwU3RyZWFtLnBvaW50ID0gcG9pbnQ7XHJcbiAgICAgIGlmICh2XykgYWN0aXZlU3RyZWFtLmxpbmVFbmQoKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBsaW5lUG9pbnQoeCwgeSkge1xyXG4gICAgICB2YXIgdiA9IHZpc2libGUoeCwgeSk7XHJcbiAgICAgIGlmIChwb2x5Z29uKSByaW5nLnB1c2goW3gsIHldKTtcclxuICAgICAgaWYgKGZpcnN0KSB7XHJcbiAgICAgICAgeF9fID0geCwgeV9fID0geSwgdl9fID0gdjtcclxuICAgICAgICBmaXJzdCA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh2KSB7XHJcbiAgICAgICAgICBhY3RpdmVTdHJlYW0ubGluZVN0YXJ0KCk7XHJcbiAgICAgICAgICBhY3RpdmVTdHJlYW0ucG9pbnQoeCwgeSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmICh2ICYmIHZfKSBhY3RpdmVTdHJlYW0ucG9pbnQoeCwgeSk7XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICB2YXIgYSA9IFt4XyA9IE1hdGgubWF4KGNsaXBNaW4sIE1hdGgubWluKGNsaXBNYXgsIHhfKSksIHlfID0gTWF0aC5tYXgoY2xpcE1pbiwgTWF0aC5taW4oY2xpcE1heCwgeV8pKV0sXHJcbiAgICAgICAgICAgICAgYiA9IFt4ID0gTWF0aC5tYXgoY2xpcE1pbiwgTWF0aC5taW4oY2xpcE1heCwgeCkpLCB5ID0gTWF0aC5tYXgoY2xpcE1pbiwgTWF0aC5taW4oY2xpcE1heCwgeSkpXTtcclxuICAgICAgICAgIGlmIChjbGlwTGluZShhLCBiLCB4MCwgeTAsIHgxLCB5MSkpIHtcclxuICAgICAgICAgICAgaWYgKCF2Xykge1xyXG4gICAgICAgICAgICAgIGFjdGl2ZVN0cmVhbS5saW5lU3RhcnQoKTtcclxuICAgICAgICAgICAgICBhY3RpdmVTdHJlYW0ucG9pbnQoYVswXSwgYVsxXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYWN0aXZlU3RyZWFtLnBvaW50KGJbMF0sIGJbMV0pO1xyXG4gICAgICAgICAgICBpZiAoIXYpIGFjdGl2ZVN0cmVhbS5saW5lRW5kKCk7XHJcbiAgICAgICAgICAgIGNsZWFuID0gZmFsc2U7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHYpIHtcclxuICAgICAgICAgICAgYWN0aXZlU3RyZWFtLmxpbmVTdGFydCgpO1xyXG4gICAgICAgICAgICBhY3RpdmVTdHJlYW0ucG9pbnQoeCwgeSk7XHJcbiAgICAgICAgICAgIGNsZWFuID0gZmFsc2U7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHhfID0geCwgeV8gPSB5LCB2XyA9IHY7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNsaXBTdHJlYW07XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gZXh0ZW50JDEoKSB7XHJcbiAgdmFyIHgwID0gMCxcclxuICAgICAgeTAgPSAwLFxyXG4gICAgICB4MSA9IDk2MCxcclxuICAgICAgeTEgPSA1MDAsXHJcbiAgICAgIGNhY2hlLFxyXG4gICAgICBjYWNoZVN0cmVhbSxcclxuICAgICAgY2xpcDtcclxuXHJcbiAgcmV0dXJuIGNsaXAgPSB7XHJcbiAgICBzdHJlYW06IGZ1bmN0aW9uKHN0cmVhbSkge1xyXG4gICAgICByZXR1cm4gY2FjaGUgJiYgY2FjaGVTdHJlYW0gPT09IHN0cmVhbSA/IGNhY2hlIDogY2FjaGUgPSBjbGlwUmVjdGFuZ2xlKHgwLCB5MCwgeDEsIHkxKShjYWNoZVN0cmVhbSA9IHN0cmVhbSk7XHJcbiAgICB9LFxyXG4gICAgZXh0ZW50OiBmdW5jdGlvbihfKSB7XHJcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHgwID0gK19bMF1bMF0sIHkwID0gK19bMF1bMV0sIHgxID0gK19bMV1bMF0sIHkxID0gK19bMV1bMV0sIGNhY2hlID0gY2FjaGVTdHJlYW0gPSBudWxsLCBjbGlwKSA6IFtbeDAsIHkwXSwgW3gxLCB5MV1dO1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuXHJcbnZhciBsZW5ndGhTdW0gPSBhZGRlcigpLFxyXG4gICAgbGFtYmRhMCQyLFxyXG4gICAgc2luUGhpMCQxLFxyXG4gICAgY29zUGhpMCQxO1xyXG5cclxudmFyIGxlbmd0aFN0cmVhbSA9IHtcclxuICBzcGhlcmU6IG5vb3AkMixcclxuICBwb2ludDogbm9vcCQyLFxyXG4gIGxpbmVTdGFydDogbGVuZ3RoTGluZVN0YXJ0LFxyXG4gIGxpbmVFbmQ6IG5vb3AkMixcclxuICBwb2x5Z29uU3RhcnQ6IG5vb3AkMixcclxuICBwb2x5Z29uRW5kOiBub29wJDJcclxufTtcclxuXHJcbmZ1bmN0aW9uIGxlbmd0aExpbmVTdGFydCgpIHtcclxuICBsZW5ndGhTdHJlYW0ucG9pbnQgPSBsZW5ndGhQb2ludEZpcnN0O1xyXG4gIGxlbmd0aFN0cmVhbS5saW5lRW5kID0gbGVuZ3RoTGluZUVuZDtcclxufVxyXG5cclxuZnVuY3Rpb24gbGVuZ3RoTGluZUVuZCgpIHtcclxuICBsZW5ndGhTdHJlYW0ucG9pbnQgPSBsZW5ndGhTdHJlYW0ubGluZUVuZCA9IG5vb3AkMjtcclxufVxyXG5cclxuZnVuY3Rpb24gbGVuZ3RoUG9pbnRGaXJzdChsYW1iZGEsIHBoaSkge1xyXG4gIGxhbWJkYSAqPSByYWRpYW5zLCBwaGkgKj0gcmFkaWFucztcclxuICBsYW1iZGEwJDIgPSBsYW1iZGEsIHNpblBoaTAkMSA9IHNpbiQxKHBoaSksIGNvc1BoaTAkMSA9IGNvcyQxKHBoaSk7XHJcbiAgbGVuZ3RoU3RyZWFtLnBvaW50ID0gbGVuZ3RoUG9pbnQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxlbmd0aFBvaW50KGxhbWJkYSwgcGhpKSB7XHJcbiAgbGFtYmRhICo9IHJhZGlhbnMsIHBoaSAqPSByYWRpYW5zO1xyXG4gIHZhciBzaW5QaGkgPSBzaW4kMShwaGkpLFxyXG4gICAgICBjb3NQaGkgPSBjb3MkMShwaGkpLFxyXG4gICAgICBkZWx0YSA9IGFicyhsYW1iZGEgLSBsYW1iZGEwJDIpLFxyXG4gICAgICBjb3NEZWx0YSA9IGNvcyQxKGRlbHRhKSxcclxuICAgICAgc2luRGVsdGEgPSBzaW4kMShkZWx0YSksXHJcbiAgICAgIHggPSBjb3NQaGkgKiBzaW5EZWx0YSxcclxuICAgICAgeSA9IGNvc1BoaTAkMSAqIHNpblBoaSAtIHNpblBoaTAkMSAqIGNvc1BoaSAqIGNvc0RlbHRhLFxyXG4gICAgICB6ID0gc2luUGhpMCQxICogc2luUGhpICsgY29zUGhpMCQxICogY29zUGhpICogY29zRGVsdGE7XHJcbiAgbGVuZ3RoU3VtLmFkZChhdGFuMihzcXJ0KHggKiB4ICsgeSAqIHkpLCB6KSk7XHJcbiAgbGFtYmRhMCQyID0gbGFtYmRhLCBzaW5QaGkwJDEgPSBzaW5QaGksIGNvc1BoaTAkMSA9IGNvc1BoaTtcclxufVxyXG5cclxuZnVuY3Rpb24gbGVuZ3RoJDEob2JqZWN0KSB7XHJcbiAgbGVuZ3RoU3VtLnJlc2V0KCk7XHJcbiAgZ2VvU3RyZWFtKG9iamVjdCwgbGVuZ3RoU3RyZWFtKTtcclxuICByZXR1cm4gK2xlbmd0aFN1bTtcclxufVxyXG5cclxudmFyIGNvb3JkaW5hdGVzID0gW251bGwsIG51bGxdLFxyXG4gICAgb2JqZWN0JDEgPSB7dHlwZTogXCJMaW5lU3RyaW5nXCIsIGNvb3JkaW5hdGVzOiBjb29yZGluYXRlc307XHJcblxyXG5mdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XHJcbiAgY29vcmRpbmF0ZXNbMF0gPSBhO1xyXG4gIGNvb3JkaW5hdGVzWzFdID0gYjtcclxuICByZXR1cm4gbGVuZ3RoJDEob2JqZWN0JDEpO1xyXG59XHJcblxyXG52YXIgY29udGFpbnNPYmplY3RUeXBlID0ge1xyXG4gIEZlYXR1cmU6IGZ1bmN0aW9uKG9iamVjdCwgcG9pbnQpIHtcclxuICAgIHJldHVybiBjb250YWluc0dlb21ldHJ5KG9iamVjdC5nZW9tZXRyeSwgcG9pbnQpO1xyXG4gIH0sXHJcbiAgRmVhdHVyZUNvbGxlY3Rpb246IGZ1bmN0aW9uKG9iamVjdCwgcG9pbnQpIHtcclxuICAgIHZhciBmZWF0dXJlcyA9IG9iamVjdC5mZWF0dXJlcywgaSA9IC0xLCBuID0gZmVhdHVyZXMubGVuZ3RoO1xyXG4gICAgd2hpbGUgKCsraSA8IG4pIGlmIChjb250YWluc0dlb21ldHJ5KGZlYXR1cmVzW2ldLmdlb21ldHJ5LCBwb2ludCkpIHJldHVybiB0cnVlO1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufTtcclxuXHJcbnZhciBjb250YWluc0dlb21ldHJ5VHlwZSA9IHtcclxuICBTcGhlcmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSxcclxuICBQb2ludDogZnVuY3Rpb24ob2JqZWN0LCBwb2ludCkge1xyXG4gICAgcmV0dXJuIGNvbnRhaW5zUG9pbnQob2JqZWN0LmNvb3JkaW5hdGVzLCBwb2ludCk7XHJcbiAgfSxcclxuICBNdWx0aVBvaW50OiBmdW5jdGlvbihvYmplY3QsIHBvaW50KSB7XHJcbiAgICB2YXIgY29vcmRpbmF0ZXMgPSBvYmplY3QuY29vcmRpbmF0ZXMsIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcclxuICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoY29udGFpbnNQb2ludChjb29yZGluYXRlc1tpXSwgcG9pbnQpKSByZXR1cm4gdHJ1ZTtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9LFxyXG4gIExpbmVTdHJpbmc6IGZ1bmN0aW9uKG9iamVjdCwgcG9pbnQpIHtcclxuICAgIHJldHVybiBjb250YWluc0xpbmUob2JqZWN0LmNvb3JkaW5hdGVzLCBwb2ludCk7XHJcbiAgfSxcclxuICBNdWx0aUxpbmVTdHJpbmc6IGZ1bmN0aW9uKG9iamVjdCwgcG9pbnQpIHtcclxuICAgIHZhciBjb29yZGluYXRlcyA9IG9iamVjdC5jb29yZGluYXRlcywgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xyXG4gICAgd2hpbGUgKCsraSA8IG4pIGlmIChjb250YWluc0xpbmUoY29vcmRpbmF0ZXNbaV0sIHBvaW50KSkgcmV0dXJuIHRydWU7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfSxcclxuICBQb2x5Z29uOiBmdW5jdGlvbihvYmplY3QsIHBvaW50KSB7XHJcbiAgICByZXR1cm4gY29udGFpbnNQb2x5Z29uKG9iamVjdC5jb29yZGluYXRlcywgcG9pbnQpO1xyXG4gIH0sXHJcbiAgTXVsdGlQb2x5Z29uOiBmdW5jdGlvbihvYmplY3QsIHBvaW50KSB7XHJcbiAgICB2YXIgY29vcmRpbmF0ZXMgPSBvYmplY3QuY29vcmRpbmF0ZXMsIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcclxuICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoY29udGFpbnNQb2x5Z29uKGNvb3JkaW5hdGVzW2ldLCBwb2ludCkpIHJldHVybiB0cnVlO1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH0sXHJcbiAgR2VvbWV0cnlDb2xsZWN0aW9uOiBmdW5jdGlvbihvYmplY3QsIHBvaW50KSB7XHJcbiAgICB2YXIgZ2VvbWV0cmllcyA9IG9iamVjdC5nZW9tZXRyaWVzLCBpID0gLTEsIG4gPSBnZW9tZXRyaWVzLmxlbmd0aDtcclxuICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoY29udGFpbnNHZW9tZXRyeShnZW9tZXRyaWVzW2ldLCBwb2ludCkpIHJldHVybiB0cnVlO1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIGNvbnRhaW5zR2VvbWV0cnkoZ2VvbWV0cnksIHBvaW50KSB7XHJcbiAgcmV0dXJuIGdlb21ldHJ5ICYmIGNvbnRhaW5zR2VvbWV0cnlUeXBlLmhhc093blByb3BlcnR5KGdlb21ldHJ5LnR5cGUpXHJcbiAgICAgID8gY29udGFpbnNHZW9tZXRyeVR5cGVbZ2VvbWV0cnkudHlwZV0oZ2VvbWV0cnksIHBvaW50KVxyXG4gICAgICA6IGZhbHNlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb250YWluc1BvaW50KGNvb3JkaW5hdGVzLCBwb2ludCkge1xyXG4gIHJldHVybiBkaXN0YW5jZShjb29yZGluYXRlcywgcG9pbnQpID09PSAwO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb250YWluc0xpbmUoY29vcmRpbmF0ZXMsIHBvaW50KSB7XHJcbiAgdmFyIGFiID0gZGlzdGFuY2UoY29vcmRpbmF0ZXNbMF0sIGNvb3JkaW5hdGVzWzFdKSxcclxuICAgICAgYW8gPSBkaXN0YW5jZShjb29yZGluYXRlc1swXSwgcG9pbnQpLFxyXG4gICAgICBvYiA9IGRpc3RhbmNlKHBvaW50LCBjb29yZGluYXRlc1sxXSk7XHJcbiAgcmV0dXJuIGFvICsgb2IgPD0gYWIgKyBlcHNpbG9uJDI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbnRhaW5zUG9seWdvbihjb29yZGluYXRlcywgcG9pbnQpIHtcclxuICByZXR1cm4gISFwb2x5Z29uQ29udGFpbnMoY29vcmRpbmF0ZXMubWFwKHJpbmdSYWRpYW5zKSwgcG9pbnRSYWRpYW5zKHBvaW50KSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJpbmdSYWRpYW5zKHJpbmcpIHtcclxuICByZXR1cm4gcmluZyA9IHJpbmcubWFwKHBvaW50UmFkaWFucyksIHJpbmcucG9wKCksIHJpbmc7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBvaW50UmFkaWFucyhwb2ludCkge1xyXG4gIHJldHVybiBbcG9pbnRbMF0gKiByYWRpYW5zLCBwb2ludFsxXSAqIHJhZGlhbnNdO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb250YWlucyQxKG9iamVjdCwgcG9pbnQpIHtcclxuICByZXR1cm4gKG9iamVjdCAmJiBjb250YWluc09iamVjdFR5cGUuaGFzT3duUHJvcGVydHkob2JqZWN0LnR5cGUpXHJcbiAgICAgID8gY29udGFpbnNPYmplY3RUeXBlW29iamVjdC50eXBlXVxyXG4gICAgICA6IGNvbnRhaW5zR2VvbWV0cnkpKG9iamVjdCwgcG9pbnQpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBncmF0aWN1bGVYKHkwLCB5MSwgZHkpIHtcclxuICB2YXIgeSA9IHNlcXVlbmNlKHkwLCB5MSAtIGVwc2lsb24kMiwgZHkpLmNvbmNhdCh5MSk7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHkubWFwKGZ1bmN0aW9uKHkpIHsgcmV0dXJuIFt4LCB5XTsgfSk7IH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdyYXRpY3VsZVkoeDAsIHgxLCBkeCkge1xyXG4gIHZhciB4ID0gc2VxdWVuY2UoeDAsIHgxIC0gZXBzaWxvbiQyLCBkeCkuY29uY2F0KHgxKTtcclxuICByZXR1cm4gZnVuY3Rpb24oeSkgeyByZXR1cm4geC5tYXAoZnVuY3Rpb24oeCkgeyByZXR1cm4gW3gsIHldOyB9KTsgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ3JhdGljdWxlKCkge1xyXG4gIHZhciB4MSwgeDAsIFgxLCBYMCxcclxuICAgICAgeTEsIHkwLCBZMSwgWTAsXHJcbiAgICAgIGR4ID0gMTAsIGR5ID0gZHgsIERYID0gOTAsIERZID0gMzYwLFxyXG4gICAgICB4LCB5LCBYLCBZLFxyXG4gICAgICBwcmVjaXNpb24gPSAyLjU7XHJcblxyXG4gIGZ1bmN0aW9uIGdyYXRpY3VsZSgpIHtcclxuICAgIHJldHVybiB7dHlwZTogXCJNdWx0aUxpbmVTdHJpbmdcIiwgY29vcmRpbmF0ZXM6IGxpbmVzKCl9O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gbGluZXMoKSB7XHJcbiAgICByZXR1cm4gc2VxdWVuY2UoY2VpbChYMCAvIERYKSAqIERYLCBYMSwgRFgpLm1hcChYKVxyXG4gICAgICAgIC5jb25jYXQoc2VxdWVuY2UoY2VpbChZMCAvIERZKSAqIERZLCBZMSwgRFkpLm1hcChZKSlcclxuICAgICAgICAuY29uY2F0KHNlcXVlbmNlKGNlaWwoeDAgLyBkeCkgKiBkeCwgeDEsIGR4KS5maWx0ZXIoZnVuY3Rpb24oeCkgeyByZXR1cm4gYWJzKHggJSBEWCkgPiBlcHNpbG9uJDI7IH0pLm1hcCh4KSlcclxuICAgICAgICAuY29uY2F0KHNlcXVlbmNlKGNlaWwoeTAgLyBkeSkgKiBkeSwgeTEsIGR5KS5maWx0ZXIoZnVuY3Rpb24oeSkgeyByZXR1cm4gYWJzKHkgJSBEWSkgPiBlcHNpbG9uJDI7IH0pLm1hcCh5KSk7XHJcbiAgfVxyXG5cclxuICBncmF0aWN1bGUubGluZXMgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBsaW5lcygpLm1hcChmdW5jdGlvbihjb29yZGluYXRlcykgeyByZXR1cm4ge3R5cGU6IFwiTGluZVN0cmluZ1wiLCBjb29yZGluYXRlczogY29vcmRpbmF0ZXN9OyB9KTtcclxuICB9O1xyXG5cclxuICBncmF0aWN1bGUub3V0bGluZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdHlwZTogXCJQb2x5Z29uXCIsXHJcbiAgICAgIGNvb3JkaW5hdGVzOiBbXHJcbiAgICAgICAgWChYMCkuY29uY2F0KFxyXG4gICAgICAgIFkoWTEpLnNsaWNlKDEpLFxyXG4gICAgICAgIFgoWDEpLnJldmVyc2UoKS5zbGljZSgxKSxcclxuICAgICAgICBZKFkwKS5yZXZlcnNlKCkuc2xpY2UoMSkpXHJcbiAgICAgIF1cclxuICAgIH07XHJcbiAgfTtcclxuXHJcbiAgZ3JhdGljdWxlLmV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGdyYXRpY3VsZS5leHRlbnRNaW5vcigpO1xyXG4gICAgcmV0dXJuIGdyYXRpY3VsZS5leHRlbnRNYWpvcihfKS5leHRlbnRNaW5vcihfKTtcclxuICB9O1xyXG5cclxuICBncmF0aWN1bGUuZXh0ZW50TWFqb3IgPSBmdW5jdGlvbihfKSB7XHJcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbW1gwLCBZMF0sIFtYMSwgWTFdXTtcclxuICAgIFgwID0gK19bMF1bMF0sIFgxID0gK19bMV1bMF07XHJcbiAgICBZMCA9ICtfWzBdWzFdLCBZMSA9ICtfWzFdWzFdO1xyXG4gICAgaWYgKFgwID4gWDEpIF8gPSBYMCwgWDAgPSBYMSwgWDEgPSBfO1xyXG4gICAgaWYgKFkwID4gWTEpIF8gPSBZMCwgWTAgPSBZMSwgWTEgPSBfO1xyXG4gICAgcmV0dXJuIGdyYXRpY3VsZS5wcmVjaXNpb24ocHJlY2lzaW9uKTtcclxuICB9O1xyXG5cclxuICBncmF0aWN1bGUuZXh0ZW50TWlub3IgPSBmdW5jdGlvbihfKSB7XHJcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbW3gwLCB5MF0sIFt4MSwgeTFdXTtcclxuICAgIHgwID0gK19bMF1bMF0sIHgxID0gK19bMV1bMF07XHJcbiAgICB5MCA9ICtfWzBdWzFdLCB5MSA9ICtfWzFdWzFdO1xyXG4gICAgaWYgKHgwID4geDEpIF8gPSB4MCwgeDAgPSB4MSwgeDEgPSBfO1xyXG4gICAgaWYgKHkwID4geTEpIF8gPSB5MCwgeTAgPSB5MSwgeTEgPSBfO1xyXG4gICAgcmV0dXJuIGdyYXRpY3VsZS5wcmVjaXNpb24ocHJlY2lzaW9uKTtcclxuICB9O1xyXG5cclxuICBncmF0aWN1bGUuc3RlcCA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGdyYXRpY3VsZS5zdGVwTWlub3IoKTtcclxuICAgIHJldHVybiBncmF0aWN1bGUuc3RlcE1ham9yKF8pLnN0ZXBNaW5vcihfKTtcclxuICB9O1xyXG5cclxuICBncmF0aWN1bGUuc3RlcE1ham9yID0gZnVuY3Rpb24oXykge1xyXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gW0RYLCBEWV07XHJcbiAgICBEWCA9ICtfWzBdLCBEWSA9ICtfWzFdO1xyXG4gICAgcmV0dXJuIGdyYXRpY3VsZTtcclxuICB9O1xyXG5cclxuICBncmF0aWN1bGUuc3RlcE1pbm9yID0gZnVuY3Rpb24oXykge1xyXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gW2R4LCBkeV07XHJcbiAgICBkeCA9ICtfWzBdLCBkeSA9ICtfWzFdO1xyXG4gICAgcmV0dXJuIGdyYXRpY3VsZTtcclxuICB9O1xyXG5cclxuICBncmF0aWN1bGUucHJlY2lzaW9uID0gZnVuY3Rpb24oXykge1xyXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcHJlY2lzaW9uO1xyXG4gICAgcHJlY2lzaW9uID0gK187XHJcbiAgICB4ID0gZ3JhdGljdWxlWCh5MCwgeTEsIDkwKTtcclxuICAgIHkgPSBncmF0aWN1bGVZKHgwLCB4MSwgcHJlY2lzaW9uKTtcclxuICAgIFggPSBncmF0aWN1bGVYKFkwLCBZMSwgOTApO1xyXG4gICAgWSA9IGdyYXRpY3VsZVkoWDAsIFgxLCBwcmVjaXNpb24pO1xyXG4gICAgcmV0dXJuIGdyYXRpY3VsZTtcclxuICB9O1xyXG5cclxuICByZXR1cm4gZ3JhdGljdWxlXHJcbiAgICAgIC5leHRlbnRNYWpvcihbWy0xODAsIC05MCArIGVwc2lsb24kMl0sIFsxODAsIDkwIC0gZXBzaWxvbiQyXV0pXHJcbiAgICAgIC5leHRlbnRNaW5vcihbWy0xODAsIC04MCAtIGVwc2lsb24kMl0sIFsxODAsIDgwICsgZXBzaWxvbiQyXV0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBncmF0aWN1bGUxMCgpIHtcclxuICByZXR1cm4gZ3JhdGljdWxlKCkoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaW50ZXJwb2xhdGUkMShhLCBiKSB7XHJcbiAgdmFyIHgwID0gYVswXSAqIHJhZGlhbnMsXHJcbiAgICAgIHkwID0gYVsxXSAqIHJhZGlhbnMsXHJcbiAgICAgIHgxID0gYlswXSAqIHJhZGlhbnMsXHJcbiAgICAgIHkxID0gYlsxXSAqIHJhZGlhbnMsXHJcbiAgICAgIGN5MCA9IGNvcyQxKHkwKSxcclxuICAgICAgc3kwID0gc2luJDEoeTApLFxyXG4gICAgICBjeTEgPSBjb3MkMSh5MSksXHJcbiAgICAgIHN5MSA9IHNpbiQxKHkxKSxcclxuICAgICAga3gwID0gY3kwICogY29zJDEoeDApLFxyXG4gICAgICBreTAgPSBjeTAgKiBzaW4kMSh4MCksXHJcbiAgICAgIGt4MSA9IGN5MSAqIGNvcyQxKHgxKSxcclxuICAgICAga3kxID0gY3kxICogc2luJDEoeDEpLFxyXG4gICAgICBkID0gMiAqIGFzaW4oc3FydChoYXZlcnNpbih5MSAtIHkwKSArIGN5MCAqIGN5MSAqIGhhdmVyc2luKHgxIC0geDApKSksXHJcbiAgICAgIGsgPSBzaW4kMShkKTtcclxuXHJcbiAgdmFyIGludGVycG9sYXRlID0gZCA/IGZ1bmN0aW9uKHQpIHtcclxuICAgIHZhciBCID0gc2luJDEodCAqPSBkKSAvIGssXHJcbiAgICAgICAgQSA9IHNpbiQxKGQgLSB0KSAvIGssXHJcbiAgICAgICAgeCA9IEEgKiBreDAgKyBCICoga3gxLFxyXG4gICAgICAgIHkgPSBBICoga3kwICsgQiAqIGt5MSxcclxuICAgICAgICB6ID0gQSAqIHN5MCArIEIgKiBzeTE7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICBhdGFuMih5LCB4KSAqIGRlZ3JlZXMkMSxcclxuICAgICAgYXRhbjIoeiwgc3FydCh4ICogeCArIHkgKiB5KSkgKiBkZWdyZWVzJDFcclxuICAgIF07XHJcbiAgfSA6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIFt4MCAqIGRlZ3JlZXMkMSwgeTAgKiBkZWdyZWVzJDFdO1xyXG4gIH07XHJcblxyXG4gIGludGVycG9sYXRlLmRpc3RhbmNlID0gZDtcclxuXHJcbiAgcmV0dXJuIGludGVycG9sYXRlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpZGVudGl0eSQ0KHgpIHtcclxuICByZXR1cm4geDtcclxufVxyXG5cclxudmFyIGFyZWFTdW0kMSA9IGFkZGVyKCksXHJcbiAgICBhcmVhUmluZ1N1bSQxID0gYWRkZXIoKSxcclxuICAgIHgwMCxcclxuICAgIHkwMCxcclxuICAgIHgwJDEsXHJcbiAgICB5MCQxO1xyXG5cclxudmFyIGFyZWFTdHJlYW0kMSA9IHtcclxuICBwb2ludDogbm9vcCQyLFxyXG4gIGxpbmVTdGFydDogbm9vcCQyLFxyXG4gIGxpbmVFbmQ6IG5vb3AkMixcclxuICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgYXJlYVN0cmVhbSQxLmxpbmVTdGFydCA9IGFyZWFSaW5nU3RhcnQkMTtcclxuICAgIGFyZWFTdHJlYW0kMS5saW5lRW5kID0gYXJlYVJpbmdFbmQkMTtcclxuICB9LFxyXG4gIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgYXJlYVN0cmVhbSQxLmxpbmVTdGFydCA9IGFyZWFTdHJlYW0kMS5saW5lRW5kID0gYXJlYVN0cmVhbSQxLnBvaW50ID0gbm9vcCQyO1xyXG4gICAgYXJlYVN1bSQxLmFkZChhYnMoYXJlYVJpbmdTdW0kMSkpO1xyXG4gICAgYXJlYVJpbmdTdW0kMS5yZXNldCgpO1xyXG4gIH0sXHJcbiAgcmVzdWx0OiBmdW5jdGlvbigpIHtcclxuICAgIHZhciBhcmVhID0gYXJlYVN1bSQxIC8gMjtcclxuICAgIGFyZWFTdW0kMS5yZXNldCgpO1xyXG4gICAgcmV0dXJuIGFyZWE7XHJcbiAgfVxyXG59O1xyXG5cclxuZnVuY3Rpb24gYXJlYVJpbmdTdGFydCQxKCkge1xyXG4gIGFyZWFTdHJlYW0kMS5wb2ludCA9IGFyZWFQb2ludEZpcnN0JDE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFyZWFQb2ludEZpcnN0JDEoeCwgeSkge1xyXG4gIGFyZWFTdHJlYW0kMS5wb2ludCA9IGFyZWFQb2ludCQxO1xyXG4gIHgwMCA9IHgwJDEgPSB4LCB5MDAgPSB5MCQxID0geTtcclxufVxyXG5cclxuZnVuY3Rpb24gYXJlYVBvaW50JDEoeCwgeSkge1xyXG4gIGFyZWFSaW5nU3VtJDEuYWRkKHkwJDEgKiB4IC0geDAkMSAqIHkpO1xyXG4gIHgwJDEgPSB4LCB5MCQxID0geTtcclxufVxyXG5cclxuZnVuY3Rpb24gYXJlYVJpbmdFbmQkMSgpIHtcclxuICBhcmVhUG9pbnQkMSh4MDAsIHkwMCk7XHJcbn1cclxuXHJcbnZhciB4MCQyID0gSW5maW5pdHksXHJcbiAgICB5MCQyID0geDAkMixcclxuICAgIHgxID0gLXgwJDIsXHJcbiAgICB5MSA9IHgxO1xyXG5cclxudmFyIGJvdW5kc1N0cmVhbSQxID0ge1xyXG4gIHBvaW50OiBib3VuZHNQb2ludCQxLFxyXG4gIGxpbmVTdGFydDogbm9vcCQyLFxyXG4gIGxpbmVFbmQ6IG5vb3AkMixcclxuICBwb2x5Z29uU3RhcnQ6IG5vb3AkMixcclxuICBwb2x5Z29uRW5kOiBub29wJDIsXHJcbiAgcmVzdWx0OiBmdW5jdGlvbigpIHtcclxuICAgIHZhciBib3VuZHMgPSBbW3gwJDIsIHkwJDJdLCBbeDEsIHkxXV07XHJcbiAgICB4MSA9IHkxID0gLSh5MCQyID0geDAkMiA9IEluZmluaXR5KTtcclxuICAgIHJldHVybiBib3VuZHM7XHJcbiAgfVxyXG59O1xyXG5cclxuZnVuY3Rpb24gYm91bmRzUG9pbnQkMSh4LCB5KSB7XHJcbiAgaWYgKHggPCB4MCQyKSB4MCQyID0geDtcclxuICBpZiAoeCA+IHgxKSB4MSA9IHg7XHJcbiAgaWYgKHkgPCB5MCQyKSB5MCQyID0geTtcclxuICBpZiAoeSA+IHkxKSB5MSA9IHk7XHJcbn1cclxuXHJcbi8vIFRPRE8gRW5mb3JjZSBwb3NpdGl2ZSBhcmVhIGZvciBleHRlcmlvciwgbmVnYXRpdmUgYXJlYSBmb3IgaW50ZXJpb3I/XHJcblxyXG52YXIgWDAkMSA9IDAsXHJcbiAgICBZMCQxID0gMCxcclxuICAgIFowJDEgPSAwLFxyXG4gICAgWDEkMSA9IDAsXHJcbiAgICBZMSQxID0gMCxcclxuICAgIFoxJDEgPSAwLFxyXG4gICAgWDIkMSA9IDAsXHJcbiAgICBZMiQxID0gMCxcclxuICAgIFoyJDEgPSAwLFxyXG4gICAgeDAwJDEsXHJcbiAgICB5MDAkMSxcclxuICAgIHgwJDMsXHJcbiAgICB5MCQzO1xyXG5cclxudmFyIGNlbnRyb2lkU3RyZWFtJDEgPSB7XHJcbiAgcG9pbnQ6IGNlbnRyb2lkUG9pbnQkMSxcclxuICBsaW5lU3RhcnQ6IGNlbnRyb2lkTGluZVN0YXJ0JDEsXHJcbiAgbGluZUVuZDogY2VudHJvaWRMaW5lRW5kJDEsXHJcbiAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcclxuICAgIGNlbnRyb2lkU3RyZWFtJDEubGluZVN0YXJ0ID0gY2VudHJvaWRSaW5nU3RhcnQkMTtcclxuICAgIGNlbnRyb2lkU3RyZWFtJDEubGluZUVuZCA9IGNlbnRyb2lkUmluZ0VuZCQxO1xyXG4gIH0sXHJcbiAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XHJcbiAgICBjZW50cm9pZFN0cmVhbSQxLnBvaW50ID0gY2VudHJvaWRQb2ludCQxO1xyXG4gICAgY2VudHJvaWRTdHJlYW0kMS5saW5lU3RhcnQgPSBjZW50cm9pZExpbmVTdGFydCQxO1xyXG4gICAgY2VudHJvaWRTdHJlYW0kMS5saW5lRW5kID0gY2VudHJvaWRMaW5lRW5kJDE7XHJcbiAgfSxcclxuICByZXN1bHQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGNlbnRyb2lkID0gWjIkMSA/IFtYMiQxIC8gWjIkMSwgWTIkMSAvIFoyJDFdXHJcbiAgICAgICAgOiBaMSQxID8gW1gxJDEgLyBaMSQxLCBZMSQxIC8gWjEkMV1cclxuICAgICAgICA6IFowJDEgPyBbWDAkMSAvIFowJDEsIFkwJDEgLyBaMCQxXVxyXG4gICAgICAgIDogW05hTiwgTmFOXTtcclxuICAgIFgwJDEgPSBZMCQxID0gWjAkMSA9XHJcbiAgICBYMSQxID0gWTEkMSA9IFoxJDEgPVxyXG4gICAgWDIkMSA9IFkyJDEgPSBaMiQxID0gMDtcclxuICAgIHJldHVybiBjZW50cm9pZDtcclxuICB9XHJcbn07XHJcblxyXG5mdW5jdGlvbiBjZW50cm9pZFBvaW50JDEoeCwgeSkge1xyXG4gIFgwJDEgKz0geDtcclxuICBZMCQxICs9IHk7XHJcbiAgKytaMCQxO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjZW50cm9pZExpbmVTdGFydCQxKCkge1xyXG4gIGNlbnRyb2lkU3RyZWFtJDEucG9pbnQgPSBjZW50cm9pZFBvaW50Rmlyc3RMaW5lO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjZW50cm9pZFBvaW50Rmlyc3RMaW5lKHgsIHkpIHtcclxuICBjZW50cm9pZFN0cmVhbSQxLnBvaW50ID0gY2VudHJvaWRQb2ludExpbmU7XHJcbiAgY2VudHJvaWRQb2ludCQxKHgwJDMgPSB4LCB5MCQzID0geSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNlbnRyb2lkUG9pbnRMaW5lKHgsIHkpIHtcclxuICB2YXIgZHggPSB4IC0geDAkMywgZHkgPSB5IC0geTAkMywgeiA9IHNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xyXG4gIFgxJDEgKz0geiAqICh4MCQzICsgeCkgLyAyO1xyXG4gIFkxJDEgKz0geiAqICh5MCQzICsgeSkgLyAyO1xyXG4gIFoxJDEgKz0gejtcclxuICBjZW50cm9pZFBvaW50JDEoeDAkMyA9IHgsIHkwJDMgPSB5KTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2VudHJvaWRMaW5lRW5kJDEoKSB7XHJcbiAgY2VudHJvaWRTdHJlYW0kMS5wb2ludCA9IGNlbnRyb2lkUG9pbnQkMTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2VudHJvaWRSaW5nU3RhcnQkMSgpIHtcclxuICBjZW50cm9pZFN0cmVhbSQxLnBvaW50ID0gY2VudHJvaWRQb2ludEZpcnN0UmluZztcclxufVxyXG5cclxuZnVuY3Rpb24gY2VudHJvaWRSaW5nRW5kJDEoKSB7XHJcbiAgY2VudHJvaWRQb2ludFJpbmcoeDAwJDEsIHkwMCQxKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2VudHJvaWRQb2ludEZpcnN0UmluZyh4LCB5KSB7XHJcbiAgY2VudHJvaWRTdHJlYW0kMS5wb2ludCA9IGNlbnRyb2lkUG9pbnRSaW5nO1xyXG4gIGNlbnRyb2lkUG9pbnQkMSh4MDAkMSA9IHgwJDMgPSB4LCB5MDAkMSA9IHkwJDMgPSB5KTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2VudHJvaWRQb2ludFJpbmcoeCwgeSkge1xyXG4gIHZhciBkeCA9IHggLSB4MCQzLFxyXG4gICAgICBkeSA9IHkgLSB5MCQzLFxyXG4gICAgICB6ID0gc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XHJcblxyXG4gIFgxJDEgKz0geiAqICh4MCQzICsgeCkgLyAyO1xyXG4gIFkxJDEgKz0geiAqICh5MCQzICsgeSkgLyAyO1xyXG4gIFoxJDEgKz0gejtcclxuXHJcbiAgeiA9IHkwJDMgKiB4IC0geDAkMyAqIHk7XHJcbiAgWDIkMSArPSB6ICogKHgwJDMgKyB4KTtcclxuICBZMiQxICs9IHogKiAoeTAkMyArIHkpO1xyXG4gIFoyJDEgKz0geiAqIDM7XHJcbiAgY2VudHJvaWRQb2ludCQxKHgwJDMgPSB4LCB5MCQzID0geSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIFBhdGhDb250ZXh0KGNvbnRleHQpIHtcclxuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcclxufVxyXG5cclxuUGF0aENvbnRleHQucHJvdG90eXBlID0ge1xyXG4gIF9yYWRpdXM6IDQuNSxcclxuICBwb2ludFJhZGl1czogZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIHRoaXMuX3JhZGl1cyA9IF8sIHRoaXM7XHJcbiAgfSxcclxuICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5fbGluZSA9IDA7XHJcbiAgfSxcclxuICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuX2xpbmUgPSBOYU47XHJcbiAgfSxcclxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5fcG9pbnQgPSAwO1xyXG4gIH0sXHJcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XHJcbiAgICBpZiAodGhpcy5fbGluZSA9PT0gMCkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcclxuICAgIHRoaXMuX3BvaW50ID0gTmFOO1xyXG4gIH0sXHJcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcclxuICAgICAgY2FzZSAwOiB7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7XHJcbiAgICAgICAgdGhpcy5fcG9pbnQgPSAxO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIGNhc2UgMToge1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIGRlZmF1bHQ6IHtcclxuICAgICAgICB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4ICsgdGhpcy5fcmFkaXVzLCB5KTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmFyYyh4LCB5LCB0aGlzLl9yYWRpdXMsIDAsIHRhdSQzKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgcmVzdWx0OiBub29wJDJcclxufTtcclxuXHJcbnZhciBsZW5ndGhTdW0kMSA9IGFkZGVyKCksXHJcbiAgICBsZW5ndGhSaW5nLFxyXG4gICAgeDAwJDIsXHJcbiAgICB5MDAkMixcclxuICAgIHgwJDQsXHJcbiAgICB5MCQ0O1xyXG5cclxudmFyIGxlbmd0aFN0cmVhbSQxID0ge1xyXG4gIHBvaW50OiBub29wJDIsXHJcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcclxuICAgIGxlbmd0aFN0cmVhbSQxLnBvaW50ID0gbGVuZ3RoUG9pbnRGaXJzdCQxO1xyXG4gIH0sXHJcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XHJcbiAgICBpZiAobGVuZ3RoUmluZykgbGVuZ3RoUG9pbnQkMSh4MDAkMiwgeTAwJDIpO1xyXG4gICAgbGVuZ3RoU3RyZWFtJDEucG9pbnQgPSBub29wJDI7XHJcbiAgfSxcclxuICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgbGVuZ3RoUmluZyA9IHRydWU7XHJcbiAgfSxcclxuICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcclxuICAgIGxlbmd0aFJpbmcgPSBudWxsO1xyXG4gIH0sXHJcbiAgcmVzdWx0OiBmdW5jdGlvbigpIHtcclxuICAgIHZhciBsZW5ndGggPSArbGVuZ3RoU3VtJDE7XHJcbiAgICBsZW5ndGhTdW0kMS5yZXNldCgpO1xyXG4gICAgcmV0dXJuIGxlbmd0aDtcclxuICB9XHJcbn07XHJcblxyXG5mdW5jdGlvbiBsZW5ndGhQb2ludEZpcnN0JDEoeCwgeSkge1xyXG4gIGxlbmd0aFN0cmVhbSQxLnBvaW50ID0gbGVuZ3RoUG9pbnQkMTtcclxuICB4MDAkMiA9IHgwJDQgPSB4LCB5MDAkMiA9IHkwJDQgPSB5O1xyXG59XHJcblxyXG5mdW5jdGlvbiBsZW5ndGhQb2ludCQxKHgsIHkpIHtcclxuICB4MCQ0IC09IHgsIHkwJDQgLT0geTtcclxuICBsZW5ndGhTdW0kMS5hZGQoc3FydCh4MCQ0ICogeDAkNCArIHkwJDQgKiB5MCQ0KSk7XHJcbiAgeDAkNCA9IHgsIHkwJDQgPSB5O1xyXG59XHJcblxyXG5mdW5jdGlvbiBQYXRoU3RyaW5nKCkge1xyXG4gIHRoaXMuX3N0cmluZyA9IFtdO1xyXG59XHJcblxyXG5QYXRoU3RyaW5nLnByb3RvdHlwZSA9IHtcclxuICBfcmFkaXVzOiA0LjUsXHJcbiAgX2NpcmNsZTogY2lyY2xlJDEoNC41KSxcclxuICBwb2ludFJhZGl1czogZnVuY3Rpb24oXykge1xyXG4gICAgaWYgKChfID0gK18pICE9PSB0aGlzLl9yYWRpdXMpIHRoaXMuX3JhZGl1cyA9IF8sIHRoaXMuX2NpcmNsZSA9IG51bGw7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG4gIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLl9saW5lID0gMDtcclxuICB9LFxyXG4gIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5fbGluZSA9IE5hTjtcclxuICB9LFxyXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLl9wb2ludCA9IDA7XHJcbiAgfSxcclxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcclxuICAgIGlmICh0aGlzLl9saW5lID09PSAwKSB0aGlzLl9zdHJpbmcucHVzaChcIlpcIik7XHJcbiAgICB0aGlzLl9wb2ludCA9IE5hTjtcclxuICB9LFxyXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XHJcbiAgICAgIGNhc2UgMDoge1xyXG4gICAgICAgIHRoaXMuX3N0cmluZy5wdXNoKFwiTVwiLCB4LCBcIixcIiwgeSk7XHJcbiAgICAgICAgdGhpcy5fcG9pbnQgPSAxO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIGNhc2UgMToge1xyXG4gICAgICAgIHRoaXMuX3N0cmluZy5wdXNoKFwiTFwiLCB4LCBcIixcIiwgeSk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgZGVmYXVsdDoge1xyXG4gICAgICAgIGlmICh0aGlzLl9jaXJjbGUgPT0gbnVsbCkgdGhpcy5fY2lyY2xlID0gY2lyY2xlJDEodGhpcy5fcmFkaXVzKTtcclxuICAgICAgICB0aGlzLl9zdHJpbmcucHVzaChcIk1cIiwgeCwgXCIsXCIsIHksIHRoaXMuX2NpcmNsZSk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG4gIHJlc3VsdDogZnVuY3Rpb24oKSB7XHJcbiAgICBpZiAodGhpcy5fc3RyaW5nLmxlbmd0aCkge1xyXG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fc3RyaW5nLmpvaW4oXCJcIik7XHJcbiAgICAgIHRoaXMuX3N0cmluZyA9IFtdO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuZnVuY3Rpb24gY2lyY2xlJDEocmFkaXVzKSB7XHJcbiAgcmV0dXJuIFwibTAsXCIgKyByYWRpdXNcclxuICAgICAgKyBcImFcIiArIHJhZGl1cyArIFwiLFwiICsgcmFkaXVzICsgXCIgMCAxLDEgMCxcIiArIC0yICogcmFkaXVzXHJcbiAgICAgICsgXCJhXCIgKyByYWRpdXMgKyBcIixcIiArIHJhZGl1cyArIFwiIDAgMSwxIDAsXCIgKyAyICogcmFkaXVzXHJcbiAgICAgICsgXCJ6XCI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluZGV4JDEocHJvamVjdGlvbiwgY29udGV4dCkge1xyXG4gIHZhciBwb2ludFJhZGl1cyA9IDQuNSxcclxuICAgICAgcHJvamVjdGlvblN0cmVhbSxcclxuICAgICAgY29udGV4dFN0cmVhbTtcclxuXHJcbiAgZnVuY3Rpb24gcGF0aChvYmplY3QpIHtcclxuICAgIGlmIChvYmplY3QpIHtcclxuICAgICAgaWYgKHR5cGVvZiBwb2ludFJhZGl1cyA9PT0gXCJmdW5jdGlvblwiKSBjb250ZXh0U3RyZWFtLnBvaW50UmFkaXVzKCtwb2ludFJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcclxuICAgICAgZ2VvU3RyZWFtKG9iamVjdCwgcHJvamVjdGlvblN0cmVhbShjb250ZXh0U3RyZWFtKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29udGV4dFN0cmVhbS5yZXN1bHQoKTtcclxuICB9XHJcblxyXG4gIHBhdGguYXJlYSA9IGZ1bmN0aW9uKG9iamVjdCkge1xyXG4gICAgZ2VvU3RyZWFtKG9iamVjdCwgcHJvamVjdGlvblN0cmVhbShhcmVhU3RyZWFtJDEpKTtcclxuICAgIHJldHVybiBhcmVhU3RyZWFtJDEucmVzdWx0KCk7XHJcbiAgfTtcclxuXHJcbiAgcGF0aC5tZWFzdXJlID0gZnVuY3Rpb24ob2JqZWN0KSB7XHJcbiAgICBnZW9TdHJlYW0ob2JqZWN0LCBwcm9qZWN0aW9uU3RyZWFtKGxlbmd0aFN0cmVhbSQxKSk7XHJcbiAgICByZXR1cm4gbGVuZ3RoU3RyZWFtJDEucmVzdWx0KCk7XHJcbiAgfTtcclxuXHJcbiAgcGF0aC5ib3VuZHMgPSBmdW5jdGlvbihvYmplY3QpIHtcclxuICAgIGdlb1N0cmVhbShvYmplY3QsIHByb2plY3Rpb25TdHJlYW0oYm91bmRzU3RyZWFtJDEpKTtcclxuICAgIHJldHVybiBib3VuZHNTdHJlYW0kMS5yZXN1bHQoKTtcclxuICB9O1xyXG5cclxuICBwYXRoLmNlbnRyb2lkID0gZnVuY3Rpb24ob2JqZWN0KSB7XHJcbiAgICBnZW9TdHJlYW0ob2JqZWN0LCBwcm9qZWN0aW9uU3RyZWFtKGNlbnRyb2lkU3RyZWFtJDEpKTtcclxuICAgIHJldHVybiBjZW50cm9pZFN0cmVhbSQxLnJlc3VsdCgpO1xyXG4gIH07XHJcblxyXG4gIHBhdGgucHJvamVjdGlvbiA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHByb2plY3Rpb25TdHJlYW0gPSBfID09IG51bGwgPyAocHJvamVjdGlvbiA9IG51bGwsIGlkZW50aXR5JDQpIDogKHByb2plY3Rpb24gPSBfKS5zdHJlYW0sIHBhdGgpIDogcHJvamVjdGlvbjtcclxuICB9O1xyXG5cclxuICBwYXRoLmNvbnRleHQgPSBmdW5jdGlvbihfKSB7XHJcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjb250ZXh0O1xyXG4gICAgY29udGV4dFN0cmVhbSA9IF8gPT0gbnVsbCA/IChjb250ZXh0ID0gbnVsbCwgbmV3IFBhdGhTdHJpbmcpIDogbmV3IFBhdGhDb250ZXh0KGNvbnRleHQgPSBfKTtcclxuICAgIGlmICh0eXBlb2YgcG9pbnRSYWRpdXMgIT09IFwiZnVuY3Rpb25cIikgY29udGV4dFN0cmVhbS5wb2ludFJhZGl1cyhwb2ludFJhZGl1cyk7XHJcbiAgICByZXR1cm4gcGF0aDtcclxuICB9O1xyXG5cclxuICBwYXRoLnBvaW50UmFkaXVzID0gZnVuY3Rpb24oXykge1xyXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcG9pbnRSYWRpdXM7XHJcbiAgICBwb2ludFJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogKGNvbnRleHRTdHJlYW0ucG9pbnRSYWRpdXMoK18pLCArXyk7XHJcbiAgICByZXR1cm4gcGF0aDtcclxuICB9O1xyXG5cclxuICByZXR1cm4gcGF0aC5wcm9qZWN0aW9uKHByb2plY3Rpb24pLmNvbnRleHQoY29udGV4dCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybShtZXRob2RzKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHN0cmVhbTogdHJhbnNmb3JtZXIobWV0aG9kcylcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1lcihtZXRob2RzKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSkge1xyXG4gICAgdmFyIHMgPSBuZXcgVHJhbnNmb3JtU3RyZWFtO1xyXG4gICAgZm9yICh2YXIga2V5IGluIG1ldGhvZHMpIHNba2V5XSA9IG1ldGhvZHNba2V5XTtcclxuICAgIHMuc3RyZWFtID0gc3RyZWFtO1xyXG4gICAgcmV0dXJuIHM7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtKCkge31cclxuXHJcblRyYW5zZm9ybVN0cmVhbS5wcm90b3R5cGUgPSB7XHJcbiAgY29uc3RydWN0b3I6IFRyYW5zZm9ybVN0cmVhbSxcclxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkgeyB0aGlzLnN0cmVhbS5wb2ludCh4LCB5KTsgfSxcclxuICBzcGhlcmU6IGZ1bmN0aW9uKCkgeyB0aGlzLnN0cmVhbS5zcGhlcmUoKTsgfSxcclxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkgeyB0aGlzLnN0cmVhbS5saW5lU3RhcnQoKTsgfSxcclxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHsgdGhpcy5zdHJlYW0ubGluZUVuZCgpOyB9LFxyXG4gIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7IHRoaXMuc3RyZWFtLnBvbHlnb25TdGFydCgpOyB9LFxyXG4gIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkgeyB0aGlzLnN0cmVhbS5wb2x5Z29uRW5kKCk7IH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIGZpdChwcm9qZWN0aW9uLCBmaXRCb3VuZHMsIG9iamVjdCkge1xyXG4gIHZhciBjbGlwID0gcHJvamVjdGlvbi5jbGlwRXh0ZW50ICYmIHByb2plY3Rpb24uY2xpcEV4dGVudCgpO1xyXG4gIHByb2plY3Rpb24uc2NhbGUoMTUwKS50cmFuc2xhdGUoWzAsIDBdKTtcclxuICBpZiAoY2xpcCAhPSBudWxsKSBwcm9qZWN0aW9uLmNsaXBFeHRlbnQobnVsbCk7XHJcbiAgZ2VvU3RyZWFtKG9iamVjdCwgcHJvamVjdGlvbi5zdHJlYW0oYm91bmRzU3RyZWFtJDEpKTtcclxuICBmaXRCb3VuZHMoYm91bmRzU3RyZWFtJDEucmVzdWx0KCkpO1xyXG4gIGlmIChjbGlwICE9IG51bGwpIHByb2plY3Rpb24uY2xpcEV4dGVudChjbGlwKTtcclxuICByZXR1cm4gcHJvamVjdGlvbjtcclxufVxyXG5cclxuZnVuY3Rpb24gZml0RXh0ZW50KHByb2plY3Rpb24sIGV4dGVudCwgb2JqZWN0KSB7XHJcbiAgcmV0dXJuIGZpdChwcm9qZWN0aW9uLCBmdW5jdGlvbihiKSB7XHJcbiAgICB2YXIgdyA9IGV4dGVudFsxXVswXSAtIGV4dGVudFswXVswXSxcclxuICAgICAgICBoID0gZXh0ZW50WzFdWzFdIC0gZXh0ZW50WzBdWzFdLFxyXG4gICAgICAgIGsgPSBNYXRoLm1pbih3IC8gKGJbMV1bMF0gLSBiWzBdWzBdKSwgaCAvIChiWzFdWzFdIC0gYlswXVsxXSkpLFxyXG4gICAgICAgIHggPSArZXh0ZW50WzBdWzBdICsgKHcgLSBrICogKGJbMV1bMF0gKyBiWzBdWzBdKSkgLyAyLFxyXG4gICAgICAgIHkgPSArZXh0ZW50WzBdWzFdICsgKGggLSBrICogKGJbMV1bMV0gKyBiWzBdWzFdKSkgLyAyO1xyXG4gICAgcHJvamVjdGlvbi5zY2FsZSgxNTAgKiBrKS50cmFuc2xhdGUoW3gsIHldKTtcclxuICB9LCBvYmplY3QpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBmaXRTaXplKHByb2plY3Rpb24sIHNpemUsIG9iamVjdCkge1xyXG4gIHJldHVybiBmaXRFeHRlbnQocHJvamVjdGlvbiwgW1swLCAwXSwgc2l6ZV0sIG9iamVjdCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZpdFdpZHRoKHByb2plY3Rpb24sIHdpZHRoLCBvYmplY3QpIHtcclxuICByZXR1cm4gZml0KHByb2plY3Rpb24sIGZ1bmN0aW9uKGIpIHtcclxuICAgIHZhciB3ID0gK3dpZHRoLFxyXG4gICAgICAgIGsgPSB3IC8gKGJbMV1bMF0gLSBiWzBdWzBdKSxcclxuICAgICAgICB4ID0gKHcgLSBrICogKGJbMV1bMF0gKyBiWzBdWzBdKSkgLyAyLFxyXG4gICAgICAgIHkgPSAtayAqIGJbMF1bMV07XHJcbiAgICBwcm9qZWN0aW9uLnNjYWxlKDE1MCAqIGspLnRyYW5zbGF0ZShbeCwgeV0pO1xyXG4gIH0sIG9iamVjdCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZpdEhlaWdodChwcm9qZWN0aW9uLCBoZWlnaHQsIG9iamVjdCkge1xyXG4gIHJldHVybiBmaXQocHJvamVjdGlvbiwgZnVuY3Rpb24oYikge1xyXG4gICAgdmFyIGggPSAraGVpZ2h0LFxyXG4gICAgICAgIGsgPSBoIC8gKGJbMV1bMV0gLSBiWzBdWzFdKSxcclxuICAgICAgICB4ID0gLWsgKiBiWzBdWzBdLFxyXG4gICAgICAgIHkgPSAoaCAtIGsgKiAoYlsxXVsxXSArIGJbMF1bMV0pKSAvIDI7XHJcbiAgICBwcm9qZWN0aW9uLnNjYWxlKDE1MCAqIGspLnRyYW5zbGF0ZShbeCwgeV0pO1xyXG4gIH0sIG9iamVjdCk7XHJcbn1cclxuXHJcbnZhciBtYXhEZXB0aCA9IDE2LCAvLyBtYXhpbXVtIGRlcHRoIG9mIHN1YmRpdmlzaW9uXHJcbiAgICBjb3NNaW5EaXN0YW5jZSA9IGNvcyQxKDMwICogcmFkaWFucyk7IC8vIGNvcyhtaW5pbXVtIGFuZ3VsYXIgZGlzdGFuY2UpXHJcblxyXG5mdW5jdGlvbiByZXNhbXBsZShwcm9qZWN0LCBkZWx0YTIpIHtcclxuICByZXR1cm4gK2RlbHRhMiA/IHJlc2FtcGxlJDEocHJvamVjdCwgZGVsdGEyKSA6IHJlc2FtcGxlTm9uZShwcm9qZWN0KTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVzYW1wbGVOb25lKHByb2plY3QpIHtcclxuICByZXR1cm4gdHJhbnNmb3JtZXIoe1xyXG4gICAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgICAgeCA9IHByb2plY3QoeCwgeSk7XHJcbiAgICAgIHRoaXMuc3RyZWFtLnBvaW50KHhbMF0sIHhbMV0pO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZXNhbXBsZSQxKHByb2plY3QsIGRlbHRhMikge1xyXG5cclxuICBmdW5jdGlvbiByZXNhbXBsZUxpbmVUbyh4MCwgeTAsIGxhbWJkYTAsIGEwLCBiMCwgYzAsIHgxLCB5MSwgbGFtYmRhMSwgYTEsIGIxLCBjMSwgZGVwdGgsIHN0cmVhbSkge1xyXG4gICAgdmFyIGR4ID0geDEgLSB4MCxcclxuICAgICAgICBkeSA9IHkxIC0geTAsXHJcbiAgICAgICAgZDIgPSBkeCAqIGR4ICsgZHkgKiBkeTtcclxuICAgIGlmIChkMiA+IDQgKiBkZWx0YTIgJiYgZGVwdGgtLSkge1xyXG4gICAgICB2YXIgYSA9IGEwICsgYTEsXHJcbiAgICAgICAgICBiID0gYjAgKyBiMSxcclxuICAgICAgICAgIGMgPSBjMCArIGMxLFxyXG4gICAgICAgICAgbSA9IHNxcnQoYSAqIGEgKyBiICogYiArIGMgKiBjKSxcclxuICAgICAgICAgIHBoaTIgPSBhc2luKGMgLz0gbSksXHJcbiAgICAgICAgICBsYW1iZGEyID0gYWJzKGFicyhjKSAtIDEpIDwgZXBzaWxvbiQyIHx8IGFicyhsYW1iZGEwIC0gbGFtYmRhMSkgPCBlcHNpbG9uJDIgPyAobGFtYmRhMCArIGxhbWJkYTEpIC8gMiA6IGF0YW4yKGIsIGEpLFxyXG4gICAgICAgICAgcCA9IHByb2plY3QobGFtYmRhMiwgcGhpMiksXHJcbiAgICAgICAgICB4MiA9IHBbMF0sXHJcbiAgICAgICAgICB5MiA9IHBbMV0sXHJcbiAgICAgICAgICBkeDIgPSB4MiAtIHgwLFxyXG4gICAgICAgICAgZHkyID0geTIgLSB5MCxcclxuICAgICAgICAgIGR6ID0gZHkgKiBkeDIgLSBkeCAqIGR5MjtcclxuICAgICAgaWYgKGR6ICogZHogLyBkMiA+IGRlbHRhMiAvLyBwZXJwZW5kaWN1bGFyIHByb2plY3RlZCBkaXN0YW5jZVxyXG4gICAgICAgICAgfHwgYWJzKChkeCAqIGR4MiArIGR5ICogZHkyKSAvIGQyIC0gMC41KSA+IDAuMyAvLyBtaWRwb2ludCBjbG9zZSB0byBhbiBlbmRcclxuICAgICAgICAgIHx8IGEwICogYTEgKyBiMCAqIGIxICsgYzAgKiBjMSA8IGNvc01pbkRpc3RhbmNlKSB7IC8vIGFuZ3VsYXIgZGlzdGFuY2VcclxuICAgICAgICByZXNhbXBsZUxpbmVUbyh4MCwgeTAsIGxhbWJkYTAsIGEwLCBiMCwgYzAsIHgyLCB5MiwgbGFtYmRhMiwgYSAvPSBtLCBiIC89IG0sIGMsIGRlcHRoLCBzdHJlYW0pO1xyXG4gICAgICAgIHN0cmVhbS5wb2ludCh4MiwgeTIpO1xyXG4gICAgICAgIHJlc2FtcGxlTGluZVRvKHgyLCB5MiwgbGFtYmRhMiwgYSwgYiwgYywgeDEsIHkxLCBsYW1iZGExLCBhMSwgYjEsIGMxLCBkZXB0aCwgc3RyZWFtKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtKSB7XHJcbiAgICB2YXIgbGFtYmRhMDAsIHgwMCwgeTAwLCBhMDAsIGIwMCwgYzAwLCAvLyBmaXJzdCBwb2ludFxyXG4gICAgICAgIGxhbWJkYTAsIHgwLCB5MCwgYTAsIGIwLCBjMDsgLy8gcHJldmlvdXMgcG9pbnRcclxuXHJcbiAgICB2YXIgcmVzYW1wbGVTdHJlYW0gPSB7XHJcbiAgICAgIHBvaW50OiBwb2ludCxcclxuICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXHJcbiAgICAgIGxpbmVFbmQ6IGxpbmVFbmQsXHJcbiAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7IHN0cmVhbS5wb2x5Z29uU3RhcnQoKTsgcmVzYW1wbGVTdHJlYW0ubGluZVN0YXJ0ID0gcmluZ1N0YXJ0OyB9LFxyXG4gICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHsgc3RyZWFtLnBvbHlnb25FbmQoKTsgcmVzYW1wbGVTdHJlYW0ubGluZVN0YXJ0ID0gbGluZVN0YXJ0OyB9XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIHBvaW50KHgsIHkpIHtcclxuICAgICAgeCA9IHByb2plY3QoeCwgeSk7XHJcbiAgICAgIHN0cmVhbS5wb2ludCh4WzBdLCB4WzFdKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBsaW5lU3RhcnQoKSB7XHJcbiAgICAgIHgwID0gTmFOO1xyXG4gICAgICByZXNhbXBsZVN0cmVhbS5wb2ludCA9IGxpbmVQb2ludDtcclxuICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGxpbmVQb2ludChsYW1iZGEsIHBoaSkge1xyXG4gICAgICB2YXIgYyA9IGNhcnRlc2lhbihbbGFtYmRhLCBwaGldKSwgcCA9IHByb2plY3QobGFtYmRhLCBwaGkpO1xyXG4gICAgICByZXNhbXBsZUxpbmVUbyh4MCwgeTAsIGxhbWJkYTAsIGEwLCBiMCwgYzAsIHgwID0gcFswXSwgeTAgPSBwWzFdLCBsYW1iZGEwID0gbGFtYmRhLCBhMCA9IGNbMF0sIGIwID0gY1sxXSwgYzAgPSBjWzJdLCBtYXhEZXB0aCwgc3RyZWFtKTtcclxuICAgICAgc3RyZWFtLnBvaW50KHgwLCB5MCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbGluZUVuZCgpIHtcclxuICAgICAgcmVzYW1wbGVTdHJlYW0ucG9pbnQgPSBwb2ludDtcclxuICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByaW5nU3RhcnQoKSB7XHJcbiAgICAgIGxpbmVTdGFydCgpO1xyXG4gICAgICByZXNhbXBsZVN0cmVhbS5wb2ludCA9IHJpbmdQb2ludDtcclxuICAgICAgcmVzYW1wbGVTdHJlYW0ubGluZUVuZCA9IHJpbmdFbmQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmluZ1BvaW50KGxhbWJkYSwgcGhpKSB7XHJcbiAgICAgIGxpbmVQb2ludChsYW1iZGEwMCA9IGxhbWJkYSwgcGhpKSwgeDAwID0geDAsIHkwMCA9IHkwLCBhMDAgPSBhMCwgYjAwID0gYjAsIGMwMCA9IGMwO1xyXG4gICAgICByZXNhbXBsZVN0cmVhbS5wb2ludCA9IGxpbmVQb2ludDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByaW5nRW5kKCkge1xyXG4gICAgICByZXNhbXBsZUxpbmVUbyh4MCwgeTAsIGxhbWJkYTAsIGEwLCBiMCwgYzAsIHgwMCwgeTAwLCBsYW1iZGEwMCwgYTAwLCBiMDAsIGMwMCwgbWF4RGVwdGgsIHN0cmVhbSk7XHJcbiAgICAgIHJlc2FtcGxlU3RyZWFtLmxpbmVFbmQgPSBsaW5lRW5kO1xyXG4gICAgICBsaW5lRW5kKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc2FtcGxlU3RyZWFtO1xyXG4gIH07XHJcbn1cclxuXHJcbnZhciB0cmFuc2Zvcm1SYWRpYW5zID0gdHJhbnNmb3JtZXIoe1xyXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICB0aGlzLnN0cmVhbS5wb2ludCh4ICogcmFkaWFucywgeSAqIHJhZGlhbnMpO1xyXG4gIH1cclxufSk7XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1Sb3RhdGUocm90YXRlKSB7XHJcbiAgcmV0dXJuIHRyYW5zZm9ybWVyKHtcclxuICAgIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICAgIHZhciByID0gcm90YXRlKHgsIHkpO1xyXG4gICAgICByZXR1cm4gdGhpcy5zdHJlYW0ucG9pbnQoclswXSwgclsxXSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNjYWxlVHJhbnNsYXRlKGssIGR4LCBkeSkge1xyXG4gIGZ1bmN0aW9uIHRyYW5zZm9ybSQkMSh4LCB5KSB7XHJcbiAgICByZXR1cm4gW2R4ICsgayAqIHgsIGR5IC0gayAqIHldO1xyXG4gIH1cclxuICB0cmFuc2Zvcm0kJDEuaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgcmV0dXJuIFsoeCAtIGR4KSAvIGssIChkeSAtIHkpIC8ga107XHJcbiAgfTtcclxuICByZXR1cm4gdHJhbnNmb3JtJCQxO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzY2FsZVRyYW5zbGF0ZVJvdGF0ZShrLCBkeCwgZHksIGFscGhhKSB7XHJcbiAgdmFyIGNvc0FscGhhID0gY29zJDEoYWxwaGEpLFxyXG4gICAgICBzaW5BbHBoYSA9IHNpbiQxKGFscGhhKSxcclxuICAgICAgYSA9IGNvc0FscGhhICogayxcclxuICAgICAgYiA9IHNpbkFscGhhICogayxcclxuICAgICAgYWkgPSBjb3NBbHBoYSAvIGssXHJcbiAgICAgIGJpID0gc2luQWxwaGEgLyBrLFxyXG4gICAgICBjaSA9IChzaW5BbHBoYSAqIGR5IC0gY29zQWxwaGEgKiBkeCkgLyBrLFxyXG4gICAgICBmaSA9IChzaW5BbHBoYSAqIGR4ICsgY29zQWxwaGEgKiBkeSkgLyBrO1xyXG4gIGZ1bmN0aW9uIHRyYW5zZm9ybSQkMSh4LCB5KSB7XHJcbiAgICByZXR1cm4gW2EgKiB4IC0gYiAqIHkgKyBkeCwgZHkgLSBiICogeCAtIGEgKiB5XTtcclxuICB9XHJcbiAgdHJhbnNmb3JtJCQxLmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgIHJldHVybiBbYWkgKiB4IC0gYmkgKiB5ICsgY2ksIGZpIC0gYmkgKiB4IC0gYWkgKiB5XTtcclxuICB9O1xyXG4gIHJldHVybiB0cmFuc2Zvcm0kJDE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHByb2plY3Rpb24ocHJvamVjdCkge1xyXG4gIHJldHVybiBwcm9qZWN0aW9uTXV0YXRvcihmdW5jdGlvbigpIHsgcmV0dXJuIHByb2plY3Q7IH0pKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHByb2plY3Rpb25NdXRhdG9yKHByb2plY3RBdCkge1xyXG4gIHZhciBwcm9qZWN0LFxyXG4gICAgICBrID0gMTUwLCAvLyBzY2FsZVxyXG4gICAgICB4ID0gNDgwLCB5ID0gMjUwLCAvLyB0cmFuc2xhdGVcclxuICAgICAgbGFtYmRhID0gMCwgcGhpID0gMCwgLy8gY2VudGVyXHJcbiAgICAgIGRlbHRhTGFtYmRhID0gMCwgZGVsdGFQaGkgPSAwLCBkZWx0YUdhbW1hID0gMCwgcm90YXRlLCAvLyBwcmUtcm90YXRlXHJcbiAgICAgIGFscGhhID0gMCwgLy8gcG9zdC1yb3RhdGVcclxuICAgICAgdGhldGEgPSBudWxsLCBwcmVjbGlwID0gY2xpcEFudGltZXJpZGlhbiwgLy8gcHJlLWNsaXAgYW5nbGVcclxuICAgICAgeDAgPSBudWxsLCB5MCwgeDEsIHkxLCBwb3N0Y2xpcCA9IGlkZW50aXR5JDQsIC8vIHBvc3QtY2xpcCBleHRlbnRcclxuICAgICAgZGVsdGEyID0gMC41LCAvLyBwcmVjaXNpb25cclxuICAgICAgcHJvamVjdFJlc2FtcGxlLFxyXG4gICAgICBwcm9qZWN0VHJhbnNmb3JtLFxyXG4gICAgICBwcm9qZWN0Um90YXRlVHJhbnNmb3JtLFxyXG4gICAgICBjYWNoZSxcclxuICAgICAgY2FjaGVTdHJlYW07XHJcblxyXG4gIGZ1bmN0aW9uIHByb2plY3Rpb24ocG9pbnQpIHtcclxuICAgIHJldHVybiBwcm9qZWN0Um90YXRlVHJhbnNmb3JtKHBvaW50WzBdICogcmFkaWFucywgcG9pbnRbMV0gKiByYWRpYW5zKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGludmVydChwb2ludCkge1xyXG4gICAgcG9pbnQgPSBwcm9qZWN0Um90YXRlVHJhbnNmb3JtLmludmVydChwb2ludFswXSwgcG9pbnRbMV0pO1xyXG4gICAgcmV0dXJuIHBvaW50ICYmIFtwb2ludFswXSAqIGRlZ3JlZXMkMSwgcG9pbnRbMV0gKiBkZWdyZWVzJDFdO1xyXG4gIH1cclxuXHJcbiAgcHJvamVjdGlvbi5zdHJlYW0gPSBmdW5jdGlvbihzdHJlYW0pIHtcclxuICAgIHJldHVybiBjYWNoZSAmJiBjYWNoZVN0cmVhbSA9PT0gc3RyZWFtID8gY2FjaGUgOiBjYWNoZSA9IHRyYW5zZm9ybVJhZGlhbnModHJhbnNmb3JtUm90YXRlKHJvdGF0ZSkocHJlY2xpcChwcm9qZWN0UmVzYW1wbGUocG9zdGNsaXAoY2FjaGVTdHJlYW0gPSBzdHJlYW0pKSkpKTtcclxuICB9O1xyXG5cclxuICBwcm9qZWN0aW9uLnByZWNsaXAgPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwcmVjbGlwID0gXywgdGhldGEgPSB1bmRlZmluZWQsIHJlc2V0KCkpIDogcHJlY2xpcDtcclxuICB9O1xyXG5cclxuICBwcm9qZWN0aW9uLnBvc3RjbGlwID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocG9zdGNsaXAgPSBfLCB4MCA9IHkwID0geDEgPSB5MSA9IG51bGwsIHJlc2V0KCkpIDogcG9zdGNsaXA7XHJcbiAgfTtcclxuXHJcbiAgcHJvamVjdGlvbi5jbGlwQW5nbGUgPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwcmVjbGlwID0gK18gPyBjbGlwQ2lyY2xlKHRoZXRhID0gXyAqIHJhZGlhbnMpIDogKHRoZXRhID0gbnVsbCwgY2xpcEFudGltZXJpZGlhbiksIHJlc2V0KCkpIDogdGhldGEgKiBkZWdyZWVzJDE7XHJcbiAgfTtcclxuXHJcbiAgcHJvamVjdGlvbi5jbGlwRXh0ZW50ID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocG9zdGNsaXAgPSBfID09IG51bGwgPyAoeDAgPSB5MCA9IHgxID0geTEgPSBudWxsLCBpZGVudGl0eSQ0KSA6IGNsaXBSZWN0YW5nbGUoeDAgPSArX1swXVswXSwgeTAgPSArX1swXVsxXSwgeDEgPSArX1sxXVswXSwgeTEgPSArX1sxXVsxXSksIHJlc2V0KCkpIDogeDAgPT0gbnVsbCA/IG51bGwgOiBbW3gwLCB5MF0sIFt4MSwgeTFdXTtcclxuICB9O1xyXG5cclxuICBwcm9qZWN0aW9uLnNjYWxlID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoayA9ICtfLCByZWNlbnRlcigpKSA6IGs7XHJcbiAgfTtcclxuXHJcbiAgcHJvamVjdGlvbi50cmFuc2xhdGUgPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4ID0gK19bMF0sIHkgPSArX1sxXSwgcmVjZW50ZXIoKSkgOiBbeCwgeV07XHJcbiAgfTtcclxuXHJcbiAgcHJvamVjdGlvbi5jZW50ZXIgPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChsYW1iZGEgPSBfWzBdICUgMzYwICogcmFkaWFucywgcGhpID0gX1sxXSAlIDM2MCAqIHJhZGlhbnMsIHJlY2VudGVyKCkpIDogW2xhbWJkYSAqIGRlZ3JlZXMkMSwgcGhpICogZGVncmVlcyQxXTtcclxuICB9O1xyXG5cclxuICBwcm9qZWN0aW9uLnJvdGF0ZSA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRlbHRhTGFtYmRhID0gX1swXSAlIDM2MCAqIHJhZGlhbnMsIGRlbHRhUGhpID0gX1sxXSAlIDM2MCAqIHJhZGlhbnMsIGRlbHRhR2FtbWEgPSBfLmxlbmd0aCA+IDIgPyBfWzJdICUgMzYwICogcmFkaWFucyA6IDAsIHJlY2VudGVyKCkpIDogW2RlbHRhTGFtYmRhICogZGVncmVlcyQxLCBkZWx0YVBoaSAqIGRlZ3JlZXMkMSwgZGVsdGFHYW1tYSAqIGRlZ3JlZXMkMV07XHJcbiAgfTtcclxuXHJcbiAgcHJvamVjdGlvbi5hbmdsZSA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGFscGhhID0gXyAlIDM2MCAqIHJhZGlhbnMsIHJlY2VudGVyKCkpIDogYWxwaGEgKiBkZWdyZWVzJDE7XHJcbiAgfTtcclxuXHJcbiAgcHJvamVjdGlvbi5wcmVjaXNpb24gPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwcm9qZWN0UmVzYW1wbGUgPSByZXNhbXBsZShwcm9qZWN0VHJhbnNmb3JtLCBkZWx0YTIgPSBfICogXyksIHJlc2V0KCkpIDogc3FydChkZWx0YTIpO1xyXG4gIH07XHJcblxyXG4gIHByb2plY3Rpb24uZml0RXh0ZW50ID0gZnVuY3Rpb24oZXh0ZW50LCBvYmplY3QpIHtcclxuICAgIHJldHVybiBmaXRFeHRlbnQocHJvamVjdGlvbiwgZXh0ZW50LCBvYmplY3QpO1xyXG4gIH07XHJcblxyXG4gIHByb2plY3Rpb24uZml0U2l6ZSA9IGZ1bmN0aW9uKHNpemUsIG9iamVjdCkge1xyXG4gICAgcmV0dXJuIGZpdFNpemUocHJvamVjdGlvbiwgc2l6ZSwgb2JqZWN0KTtcclxuICB9O1xyXG5cclxuICBwcm9qZWN0aW9uLmZpdFdpZHRoID0gZnVuY3Rpb24od2lkdGgsIG9iamVjdCkge1xyXG4gICAgcmV0dXJuIGZpdFdpZHRoKHByb2plY3Rpb24sIHdpZHRoLCBvYmplY3QpO1xyXG4gIH07XHJcblxyXG4gIHByb2plY3Rpb24uZml0SGVpZ2h0ID0gZnVuY3Rpb24oaGVpZ2h0LCBvYmplY3QpIHtcclxuICAgIHJldHVybiBmaXRIZWlnaHQocHJvamVjdGlvbiwgaGVpZ2h0LCBvYmplY3QpO1xyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIHJlY2VudGVyKCkge1xyXG4gICAgdmFyIGNlbnRlciA9IHNjYWxlVHJhbnNsYXRlUm90YXRlKGssIDAsIDAsIGFscGhhKS5hcHBseShudWxsLCBwcm9qZWN0KGxhbWJkYSwgcGhpKSksXHJcbiAgICAgICAgdHJhbnNmb3JtJCQxID0gKGFscGhhID8gc2NhbGVUcmFuc2xhdGVSb3RhdGUgOiBzY2FsZVRyYW5zbGF0ZSkoaywgeCAtIGNlbnRlclswXSwgeSAtIGNlbnRlclsxXSwgYWxwaGEpO1xyXG4gICAgcm90YXRlID0gcm90YXRlUmFkaWFucyhkZWx0YUxhbWJkYSwgZGVsdGFQaGksIGRlbHRhR2FtbWEpO1xyXG4gICAgcHJvamVjdFRyYW5zZm9ybSA9IGNvbXBvc2UocHJvamVjdCwgdHJhbnNmb3JtJCQxKTtcclxuICAgIHByb2plY3RSb3RhdGVUcmFuc2Zvcm0gPSBjb21wb3NlKHJvdGF0ZSwgcHJvamVjdFRyYW5zZm9ybSk7XHJcbiAgICBwcm9qZWN0UmVzYW1wbGUgPSByZXNhbXBsZShwcm9qZWN0VHJhbnNmb3JtLCBkZWx0YTIpO1xyXG4gICAgcmV0dXJuIHJlc2V0KCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByZXNldCgpIHtcclxuICAgIGNhY2hlID0gY2FjaGVTdHJlYW0gPSBudWxsO1xyXG4gICAgcmV0dXJuIHByb2plY3Rpb247XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICBwcm9qZWN0ID0gcHJvamVjdEF0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICBwcm9qZWN0aW9uLmludmVydCA9IHByb2plY3QuaW52ZXJ0ICYmIGludmVydDtcclxuICAgIHJldHVybiByZWNlbnRlcigpO1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbmljUHJvamVjdGlvbihwcm9qZWN0QXQpIHtcclxuICB2YXIgcGhpMCA9IDAsXHJcbiAgICAgIHBoaTEgPSBwaSQzIC8gMyxcclxuICAgICAgbSA9IHByb2plY3Rpb25NdXRhdG9yKHByb2plY3RBdCksXHJcbiAgICAgIHAgPSBtKHBoaTAsIHBoaTEpO1xyXG5cclxuICBwLnBhcmFsbGVscyA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gbShwaGkwID0gX1swXSAqIHJhZGlhbnMsIHBoaTEgPSBfWzFdICogcmFkaWFucykgOiBbcGhpMCAqIGRlZ3JlZXMkMSwgcGhpMSAqIGRlZ3JlZXMkMV07XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIHA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGN5bGluZHJpY2FsRXF1YWxBcmVhUmF3KHBoaTApIHtcclxuICB2YXIgY29zUGhpMCA9IGNvcyQxKHBoaTApO1xyXG5cclxuICBmdW5jdGlvbiBmb3J3YXJkKGxhbWJkYSwgcGhpKSB7XHJcbiAgICByZXR1cm4gW2xhbWJkYSAqIGNvc1BoaTAsIHNpbiQxKHBoaSkgLyBjb3NQaGkwXTtcclxuICB9XHJcblxyXG4gIGZvcndhcmQuaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgcmV0dXJuIFt4IC8gY29zUGhpMCwgYXNpbih5ICogY29zUGhpMCldO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBmb3J3YXJkO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb25pY0VxdWFsQXJlYVJhdyh5MCwgeTEpIHtcclxuICB2YXIgc3kwID0gc2luJDEoeTApLCBuID0gKHN5MCArIHNpbiQxKHkxKSkgLyAyO1xyXG5cclxuICAvLyBBcmUgdGhlIHBhcmFsbGVscyBzeW1tZXRyaWNhbCBhcm91bmQgdGhlIEVxdWF0b3I/XHJcbiAgaWYgKGFicyhuKSA8IGVwc2lsb24kMikgcmV0dXJuIGN5bGluZHJpY2FsRXF1YWxBcmVhUmF3KHkwKTtcclxuXHJcbiAgdmFyIGMgPSAxICsgc3kwICogKDIgKiBuIC0gc3kwKSwgcjAgPSBzcXJ0KGMpIC8gbjtcclxuXHJcbiAgZnVuY3Rpb24gcHJvamVjdCh4LCB5KSB7XHJcbiAgICB2YXIgciA9IHNxcnQoYyAtIDIgKiBuICogc2luJDEoeSkpIC8gbjtcclxuICAgIHJldHVybiBbciAqIHNpbiQxKHggKj0gbiksIHIwIC0gciAqIGNvcyQxKHgpXTtcclxuICB9XHJcblxyXG4gIHByb2plY3QuaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgdmFyIHIweSA9IHIwIC0geTtcclxuICAgIHJldHVybiBbYXRhbjIoeCwgYWJzKHIweSkpIC8gbiAqIHNpZ24ocjB5KSwgYXNpbigoYyAtICh4ICogeCArIHIweSAqIHIweSkgKiBuICogbikgLyAoMiAqIG4pKV07XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIHByb2plY3Q7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbmljRXF1YWxBcmVhKCkge1xyXG4gIHJldHVybiBjb25pY1Byb2plY3Rpb24oY29uaWNFcXVhbEFyZWFSYXcpXHJcbiAgICAgIC5zY2FsZSgxNTUuNDI0KVxyXG4gICAgICAuY2VudGVyKFswLCAzMy42NDQyXSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFsYmVycygpIHtcclxuICByZXR1cm4gY29uaWNFcXVhbEFyZWEoKVxyXG4gICAgICAucGFyYWxsZWxzKFsyOS41LCA0NS41XSlcclxuICAgICAgLnNjYWxlKDEwNzApXHJcbiAgICAgIC50cmFuc2xhdGUoWzQ4MCwgMjUwXSlcclxuICAgICAgLnJvdGF0ZShbOTYsIDBdKVxyXG4gICAgICAuY2VudGVyKFstMC42LCAzOC43XSk7XHJcbn1cclxuXHJcbi8vIFRoZSBwcm9qZWN0aW9ucyBtdXN0IGhhdmUgbXV0dWFsbHkgZXhjbHVzaXZlIGNsaXAgcmVnaW9ucyBvbiB0aGUgc3BoZXJlLFxyXG4vLyBhcyB0aGlzIHdpbGwgYXZvaWQgZW1pdHRpbmcgaW50ZXJsZWF2aW5nIGxpbmVzIGFuZCBwb2x5Z29ucy5cclxuZnVuY3Rpb24gbXVsdGlwbGV4KHN0cmVhbXMpIHtcclxuICB2YXIgbiA9IHN0cmVhbXMubGVuZ3RoO1xyXG4gIHJldHVybiB7XHJcbiAgICBwb2ludDogZnVuY3Rpb24oeCwgeSkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikgc3RyZWFtc1tpXS5wb2ludCh4LCB5KTsgfSxcclxuICAgIHNwaGVyZTogZnVuY3Rpb24oKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSBzdHJlYW1zW2ldLnNwaGVyZSgpOyB9LFxyXG4gICAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHN0cmVhbXNbaV0ubGluZVN0YXJ0KCk7IH0sXHJcbiAgICBsaW5lRW5kOiBmdW5jdGlvbigpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHN0cmVhbXNbaV0ubGluZUVuZCgpOyB9LFxyXG4gICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHN0cmVhbXNbaV0ucG9seWdvblN0YXJ0KCk7IH0sXHJcbiAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHN0cmVhbXNbaV0ucG9seWdvbkVuZCgpOyB9XHJcbiAgfTtcclxufVxyXG5cclxuLy8gQSBjb21wb3NpdGUgcHJvamVjdGlvbiBmb3IgdGhlIFVuaXRlZCBTdGF0ZXMsIGNvbmZpZ3VyZWQgYnkgZGVmYXVsdCBmb3JcclxuLy8gOTYww5c1MDAuIFRoZSBwcm9qZWN0aW9uIGFsc28gd29ya3MgcXVpdGUgd2VsbCBhdCA5NjDDlzYwMCBpZiB5b3UgY2hhbmdlIHRoZVxyXG4vLyBzY2FsZSB0byAxMjg1IGFuZCBhZGp1c3QgdGhlIHRyYW5zbGF0ZSBhY2NvcmRpbmdseS4gVGhlIHNldCBvZiBzdGFuZGFyZFxyXG4vLyBwYXJhbGxlbHMgZm9yIGVhY2ggcmVnaW9uIGNvbWVzIGZyb20gVVNHUywgd2hpY2ggaXMgcHVibGlzaGVkIGhlcmU6XHJcbi8vIGh0dHA6Ly9lZ3NjLnVzZ3MuZ292L2lzYi9wdWJzL01hcFByb2plY3Rpb25zL3Byb2plY3Rpb25zLmh0bWwjYWxiZXJzXHJcbmZ1bmN0aW9uIGFsYmVyc1VzYSgpIHtcclxuICB2YXIgY2FjaGUsXHJcbiAgICAgIGNhY2hlU3RyZWFtLFxyXG4gICAgICBsb3dlcjQ4ID0gYWxiZXJzKCksIGxvd2VyNDhQb2ludCxcclxuICAgICAgYWxhc2thID0gY29uaWNFcXVhbEFyZWEoKS5yb3RhdGUoWzE1NCwgMF0pLmNlbnRlcihbLTIsIDU4LjVdKS5wYXJhbGxlbHMoWzU1LCA2NV0pLCBhbGFza2FQb2ludCwgLy8gRVBTRzozMzM4XHJcbiAgICAgIGhhd2FpaSA9IGNvbmljRXF1YWxBcmVhKCkucm90YXRlKFsxNTcsIDBdKS5jZW50ZXIoWy0zLCAxOS45XSkucGFyYWxsZWxzKFs4LCAxOF0pLCBoYXdhaWlQb2ludCwgLy8gRVNSSToxMDIwMDdcclxuICAgICAgcG9pbnQsIHBvaW50U3RyZWFtID0ge3BvaW50OiBmdW5jdGlvbih4LCB5KSB7IHBvaW50ID0gW3gsIHldOyB9fTtcclxuXHJcbiAgZnVuY3Rpb24gYWxiZXJzVXNhKGNvb3JkaW5hdGVzKSB7XHJcbiAgICB2YXIgeCA9IGNvb3JkaW5hdGVzWzBdLCB5ID0gY29vcmRpbmF0ZXNbMV07XHJcbiAgICByZXR1cm4gcG9pbnQgPSBudWxsLCAobG93ZXI0OFBvaW50LnBvaW50KHgsIHkpLCBwb2ludClcclxuICAgICAgICB8fCAoYWxhc2thUG9pbnQucG9pbnQoeCwgeSksIHBvaW50KVxyXG4gICAgICAgIHx8IChoYXdhaWlQb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpO1xyXG4gIH1cclxuXHJcbiAgYWxiZXJzVXNhLmludmVydCA9IGZ1bmN0aW9uKGNvb3JkaW5hdGVzKSB7XHJcbiAgICB2YXIgayA9IGxvd2VyNDguc2NhbGUoKSxcclxuICAgICAgICB0ID0gbG93ZXI0OC50cmFuc2xhdGUoKSxcclxuICAgICAgICB4ID0gKGNvb3JkaW5hdGVzWzBdIC0gdFswXSkgLyBrLFxyXG4gICAgICAgIHkgPSAoY29vcmRpbmF0ZXNbMV0gLSB0WzFdKSAvIGs7XHJcbiAgICByZXR1cm4gKHkgPj0gMC4xMjAgJiYgeSA8IDAuMjM0ICYmIHggPj0gLTAuNDI1ICYmIHggPCAtMC4yMTQgPyBhbGFza2FcclxuICAgICAgICA6IHkgPj0gMC4xNjYgJiYgeSA8IDAuMjM0ICYmIHggPj0gLTAuMjE0ICYmIHggPCAtMC4xMTUgPyBoYXdhaWlcclxuICAgICAgICA6IGxvd2VyNDgpLmludmVydChjb29yZGluYXRlcyk7XHJcbiAgfTtcclxuXHJcbiAgYWxiZXJzVXNhLnN0cmVhbSA9IGZ1bmN0aW9uKHN0cmVhbSkge1xyXG4gICAgcmV0dXJuIGNhY2hlICYmIGNhY2hlU3RyZWFtID09PSBzdHJlYW0gPyBjYWNoZSA6IGNhY2hlID0gbXVsdGlwbGV4KFtsb3dlcjQ4LnN0cmVhbShjYWNoZVN0cmVhbSA9IHN0cmVhbSksIGFsYXNrYS5zdHJlYW0oc3RyZWFtKSwgaGF3YWlpLnN0cmVhbShzdHJlYW0pXSk7XHJcbiAgfTtcclxuXHJcbiAgYWxiZXJzVXNhLnByZWNpc2lvbiA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxvd2VyNDgucHJlY2lzaW9uKCk7XHJcbiAgICBsb3dlcjQ4LnByZWNpc2lvbihfKSwgYWxhc2thLnByZWNpc2lvbihfKSwgaGF3YWlpLnByZWNpc2lvbihfKTtcclxuICAgIHJldHVybiByZXNldCgpO1xyXG4gIH07XHJcblxyXG4gIGFsYmVyc1VzYS5zY2FsZSA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxvd2VyNDguc2NhbGUoKTtcclxuICAgIGxvd2VyNDguc2NhbGUoXyksIGFsYXNrYS5zY2FsZShfICogMC4zNSksIGhhd2FpaS5zY2FsZShfKTtcclxuICAgIHJldHVybiBhbGJlcnNVc2EudHJhbnNsYXRlKGxvd2VyNDgudHJhbnNsYXRlKCkpO1xyXG4gIH07XHJcblxyXG4gIGFsYmVyc1VzYS50cmFuc2xhdGUgPSBmdW5jdGlvbihfKSB7XHJcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsb3dlcjQ4LnRyYW5zbGF0ZSgpO1xyXG4gICAgdmFyIGsgPSBsb3dlcjQ4LnNjYWxlKCksIHggPSArX1swXSwgeSA9ICtfWzFdO1xyXG5cclxuICAgIGxvd2VyNDhQb2ludCA9IGxvd2VyNDhcclxuICAgICAgICAudHJhbnNsYXRlKF8pXHJcbiAgICAgICAgLmNsaXBFeHRlbnQoW1t4IC0gMC40NTUgKiBrLCB5IC0gMC4yMzggKiBrXSwgW3ggKyAwLjQ1NSAqIGssIHkgKyAwLjIzOCAqIGtdXSlcclxuICAgICAgICAuc3RyZWFtKHBvaW50U3RyZWFtKTtcclxuXHJcbiAgICBhbGFza2FQb2ludCA9IGFsYXNrYVxyXG4gICAgICAgIC50cmFuc2xhdGUoW3ggLSAwLjMwNyAqIGssIHkgKyAwLjIwMSAqIGtdKVxyXG4gICAgICAgIC5jbGlwRXh0ZW50KFtbeCAtIDAuNDI1ICogayArIGVwc2lsb24kMiwgeSArIDAuMTIwICogayArIGVwc2lsb24kMl0sIFt4IC0gMC4yMTQgKiBrIC0gZXBzaWxvbiQyLCB5ICsgMC4yMzQgKiBrIC0gZXBzaWxvbiQyXV0pXHJcbiAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XHJcblxyXG4gICAgaGF3YWlpUG9pbnQgPSBoYXdhaWlcclxuICAgICAgICAudHJhbnNsYXRlKFt4IC0gMC4yMDUgKiBrLCB5ICsgMC4yMTIgKiBrXSlcclxuICAgICAgICAuY2xpcEV4dGVudChbW3ggLSAwLjIxNCAqIGsgKyBlcHNpbG9uJDIsIHkgKyAwLjE2NiAqIGsgKyBlcHNpbG9uJDJdLCBbeCAtIDAuMTE1ICogayAtIGVwc2lsb24kMiwgeSArIDAuMjM0ICogayAtIGVwc2lsb24kMl1dKVxyXG4gICAgICAgIC5zdHJlYW0ocG9pbnRTdHJlYW0pO1xyXG5cclxuICAgIHJldHVybiByZXNldCgpO1xyXG4gIH07XHJcblxyXG4gIGFsYmVyc1VzYS5maXRFeHRlbnQgPSBmdW5jdGlvbihleHRlbnQsIG9iamVjdCkge1xyXG4gICAgcmV0dXJuIGZpdEV4dGVudChhbGJlcnNVc2EsIGV4dGVudCwgb2JqZWN0KTtcclxuICB9O1xyXG5cclxuICBhbGJlcnNVc2EuZml0U2l6ZSA9IGZ1bmN0aW9uKHNpemUsIG9iamVjdCkge1xyXG4gICAgcmV0dXJuIGZpdFNpemUoYWxiZXJzVXNhLCBzaXplLCBvYmplY3QpO1xyXG4gIH07XHJcblxyXG4gIGFsYmVyc1VzYS5maXRXaWR0aCA9IGZ1bmN0aW9uKHdpZHRoLCBvYmplY3QpIHtcclxuICAgIHJldHVybiBmaXRXaWR0aChhbGJlcnNVc2EsIHdpZHRoLCBvYmplY3QpO1xyXG4gIH07XHJcblxyXG4gIGFsYmVyc1VzYS5maXRIZWlnaHQgPSBmdW5jdGlvbihoZWlnaHQsIG9iamVjdCkge1xyXG4gICAgcmV0dXJuIGZpdEhlaWdodChhbGJlcnNVc2EsIGhlaWdodCwgb2JqZWN0KTtcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiByZXNldCgpIHtcclxuICAgIGNhY2hlID0gY2FjaGVTdHJlYW0gPSBudWxsO1xyXG4gICAgcmV0dXJuIGFsYmVyc1VzYTtcclxuICB9XHJcblxyXG4gIHJldHVybiBhbGJlcnNVc2Euc2NhbGUoMTA3MCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGF6aW11dGhhbFJhdyhzY2FsZSkge1xyXG4gIHJldHVybiBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICB2YXIgY3ggPSBjb3MkMSh4KSxcclxuICAgICAgICBjeSA9IGNvcyQxKHkpLFxyXG4gICAgICAgIGsgPSBzY2FsZShjeCAqIGN5KTtcclxuICAgIHJldHVybiBbXHJcbiAgICAgIGsgKiBjeSAqIHNpbiQxKHgpLFxyXG4gICAgICBrICogc2luJDEoeSlcclxuICAgIF07XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBhemltdXRoYWxJbnZlcnQoYW5nbGUpIHtcclxuICByZXR1cm4gZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgdmFyIHogPSBzcXJ0KHggKiB4ICsgeSAqIHkpLFxyXG4gICAgICAgIGMgPSBhbmdsZSh6KSxcclxuICAgICAgICBzYyA9IHNpbiQxKGMpLFxyXG4gICAgICAgIGNjID0gY29zJDEoYyk7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICBhdGFuMih4ICogc2MsIHogKiBjYyksXHJcbiAgICAgIGFzaW4oeiAmJiB5ICogc2MgLyB6KVxyXG4gICAgXTtcclxuICB9XHJcbn1cclxuXHJcbnZhciBhemltdXRoYWxFcXVhbEFyZWFSYXcgPSBhemltdXRoYWxSYXcoZnVuY3Rpb24oY3hjeSkge1xyXG4gIHJldHVybiBzcXJ0KDIgLyAoMSArIGN4Y3kpKTtcclxufSk7XHJcblxyXG5hemltdXRoYWxFcXVhbEFyZWFSYXcuaW52ZXJ0ID0gYXppbXV0aGFsSW52ZXJ0KGZ1bmN0aW9uKHopIHtcclxuICByZXR1cm4gMiAqIGFzaW4oeiAvIDIpO1xyXG59KTtcclxuXHJcbmZ1bmN0aW9uIGF6aW11dGhhbEVxdWFsQXJlYSgpIHtcclxuICByZXR1cm4gcHJvamVjdGlvbihhemltdXRoYWxFcXVhbEFyZWFSYXcpXHJcbiAgICAgIC5zY2FsZSgxMjQuNzUpXHJcbiAgICAgIC5jbGlwQW5nbGUoMTgwIC0gMWUtMyk7XHJcbn1cclxuXHJcbnZhciBhemltdXRoYWxFcXVpZGlzdGFudFJhdyA9IGF6aW11dGhhbFJhdyhmdW5jdGlvbihjKSB7XHJcbiAgcmV0dXJuIChjID0gYWNvcyhjKSkgJiYgYyAvIHNpbiQxKGMpO1xyXG59KTtcclxuXHJcbmF6aW11dGhhbEVxdWlkaXN0YW50UmF3LmludmVydCA9IGF6aW11dGhhbEludmVydChmdW5jdGlvbih6KSB7XHJcbiAgcmV0dXJuIHo7XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gYXppbXV0aGFsRXF1aWRpc3RhbnQoKSB7XHJcbiAgcmV0dXJuIHByb2plY3Rpb24oYXppbXV0aGFsRXF1aWRpc3RhbnRSYXcpXHJcbiAgICAgIC5zY2FsZSg3OS40MTg4KVxyXG4gICAgICAuY2xpcEFuZ2xlKDE4MCAtIDFlLTMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBtZXJjYXRvclJhdyhsYW1iZGEsIHBoaSkge1xyXG4gIHJldHVybiBbbGFtYmRhLCBsb2codGFuKChoYWxmUGkkMiArIHBoaSkgLyAyKSldO1xyXG59XHJcblxyXG5tZXJjYXRvclJhdy5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XHJcbiAgcmV0dXJuIFt4LCAyICogYXRhbihleHAoeSkpIC0gaGFsZlBpJDJdO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gbWVyY2F0b3IoKSB7XHJcbiAgcmV0dXJuIG1lcmNhdG9yUHJvamVjdGlvbihtZXJjYXRvclJhdylcclxuICAgICAgLnNjYWxlKDk2MSAvIHRhdSQzKTtcclxufVxyXG5cclxuZnVuY3Rpb24gbWVyY2F0b3JQcm9qZWN0aW9uKHByb2plY3QpIHtcclxuICB2YXIgbSA9IHByb2plY3Rpb24ocHJvamVjdCksXHJcbiAgICAgIGNlbnRlciA9IG0uY2VudGVyLFxyXG4gICAgICBzY2FsZSA9IG0uc2NhbGUsXHJcbiAgICAgIHRyYW5zbGF0ZSA9IG0udHJhbnNsYXRlLFxyXG4gICAgICBjbGlwRXh0ZW50ID0gbS5jbGlwRXh0ZW50LFxyXG4gICAgICB4MCA9IG51bGwsIHkwLCB4MSwgeTE7IC8vIGNsaXAgZXh0ZW50XHJcblxyXG4gIG0uc2NhbGUgPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzY2FsZShfKSwgcmVjbGlwKCkpIDogc2NhbGUoKTtcclxuICB9O1xyXG5cclxuICBtLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRyYW5zbGF0ZShfKSwgcmVjbGlwKCkpIDogdHJhbnNsYXRlKCk7XHJcbiAgfTtcclxuXHJcbiAgbS5jZW50ZXIgPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjZW50ZXIoXyksIHJlY2xpcCgpKSA6IGNlbnRlcigpO1xyXG4gIH07XHJcblxyXG4gIG0uY2xpcEV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKF8gPT0gbnVsbCA/IHgwID0geTAgPSB4MSA9IHkxID0gbnVsbCA6ICh4MCA9ICtfWzBdWzBdLCB5MCA9ICtfWzBdWzFdLCB4MSA9ICtfWzFdWzBdLCB5MSA9ICtfWzFdWzFdKSwgcmVjbGlwKCkpIDogeDAgPT0gbnVsbCA/IG51bGwgOiBbW3gwLCB5MF0sIFt4MSwgeTFdXTtcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiByZWNsaXAoKSB7XHJcbiAgICB2YXIgayA9IHBpJDMgKiBzY2FsZSgpLFxyXG4gICAgICAgIHQgPSBtKHJvdGF0aW9uKG0ucm90YXRlKCkpLmludmVydChbMCwgMF0pKTtcclxuICAgIHJldHVybiBjbGlwRXh0ZW50KHgwID09IG51bGxcclxuICAgICAgICA/IFtbdFswXSAtIGssIHRbMV0gLSBrXSwgW3RbMF0gKyBrLCB0WzFdICsga11dIDogcHJvamVjdCA9PT0gbWVyY2F0b3JSYXdcclxuICAgICAgICA/IFtbTWF0aC5tYXgodFswXSAtIGssIHgwKSwgeTBdLCBbTWF0aC5taW4odFswXSArIGssIHgxKSwgeTFdXVxyXG4gICAgICAgIDogW1t4MCwgTWF0aC5tYXgodFsxXSAtIGssIHkwKV0sIFt4MSwgTWF0aC5taW4odFsxXSArIGssIHkxKV1dKTtcclxuICB9XHJcblxyXG4gIHJldHVybiByZWNsaXAoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gdGFueSh5KSB7XHJcbiAgcmV0dXJuIHRhbigoaGFsZlBpJDIgKyB5KSAvIDIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb25pY0NvbmZvcm1hbFJhdyh5MCwgeTEpIHtcclxuICB2YXIgY3kwID0gY29zJDEoeTApLFxyXG4gICAgICBuID0geTAgPT09IHkxID8gc2luJDEoeTApIDogbG9nKGN5MCAvIGNvcyQxKHkxKSkgLyBsb2codGFueSh5MSkgLyB0YW55KHkwKSksXHJcbiAgICAgIGYgPSBjeTAgKiBwb3codGFueSh5MCksIG4pIC8gbjtcclxuXHJcbiAgaWYgKCFuKSByZXR1cm4gbWVyY2F0b3JSYXc7XHJcblxyXG4gIGZ1bmN0aW9uIHByb2plY3QoeCwgeSkge1xyXG4gICAgaWYgKGYgPiAwKSB7IGlmICh5IDwgLWhhbGZQaSQyICsgZXBzaWxvbiQyKSB5ID0gLWhhbGZQaSQyICsgZXBzaWxvbiQyOyB9XHJcbiAgICBlbHNlIHsgaWYgKHkgPiBoYWxmUGkkMiAtIGVwc2lsb24kMikgeSA9IGhhbGZQaSQyIC0gZXBzaWxvbiQyOyB9XHJcbiAgICB2YXIgciA9IGYgLyBwb3codGFueSh5KSwgbik7XHJcbiAgICByZXR1cm4gW3IgKiBzaW4kMShuICogeCksIGYgLSByICogY29zJDEobiAqIHgpXTtcclxuICB9XHJcblxyXG4gIHByb2plY3QuaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgdmFyIGZ5ID0gZiAtIHksIHIgPSBzaWduKG4pICogc3FydCh4ICogeCArIGZ5ICogZnkpO1xyXG4gICAgcmV0dXJuIFthdGFuMih4LCBhYnMoZnkpKSAvIG4gKiBzaWduKGZ5KSwgMiAqIGF0YW4ocG93KGYgLyByLCAxIC8gbikpIC0gaGFsZlBpJDJdO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBwcm9qZWN0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb25pY0NvbmZvcm1hbCgpIHtcclxuICByZXR1cm4gY29uaWNQcm9qZWN0aW9uKGNvbmljQ29uZm9ybWFsUmF3KVxyXG4gICAgICAuc2NhbGUoMTA5LjUpXHJcbiAgICAgIC5wYXJhbGxlbHMoWzMwLCAzMF0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBlcXVpcmVjdGFuZ3VsYXJSYXcobGFtYmRhLCBwaGkpIHtcclxuICByZXR1cm4gW2xhbWJkYSwgcGhpXTtcclxufVxyXG5cclxuZXF1aXJlY3Rhbmd1bGFyUmF3LmludmVydCA9IGVxdWlyZWN0YW5ndWxhclJhdztcclxuXHJcbmZ1bmN0aW9uIGVxdWlyZWN0YW5ndWxhcigpIHtcclxuICByZXR1cm4gcHJvamVjdGlvbihlcXVpcmVjdGFuZ3VsYXJSYXcpXHJcbiAgICAgIC5zY2FsZSgxNTIuNjMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb25pY0VxdWlkaXN0YW50UmF3KHkwLCB5MSkge1xyXG4gIHZhciBjeTAgPSBjb3MkMSh5MCksXHJcbiAgICAgIG4gPSB5MCA9PT0geTEgPyBzaW4kMSh5MCkgOiAoY3kwIC0gY29zJDEoeTEpKSAvICh5MSAtIHkwKSxcclxuICAgICAgZyA9IGN5MCAvIG4gKyB5MDtcclxuXHJcbiAgaWYgKGFicyhuKSA8IGVwc2lsb24kMikgcmV0dXJuIGVxdWlyZWN0YW5ndWxhclJhdztcclxuXHJcbiAgZnVuY3Rpb24gcHJvamVjdCh4LCB5KSB7XHJcbiAgICB2YXIgZ3kgPSBnIC0geSwgbnggPSBuICogeDtcclxuICAgIHJldHVybiBbZ3kgKiBzaW4kMShueCksIGcgLSBneSAqIGNvcyQxKG54KV07XHJcbiAgfVxyXG5cclxuICBwcm9qZWN0LmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgIHZhciBneSA9IGcgLSB5O1xyXG4gICAgcmV0dXJuIFthdGFuMih4LCBhYnMoZ3kpKSAvIG4gKiBzaWduKGd5KSwgZyAtIHNpZ24obikgKiBzcXJ0KHggKiB4ICsgZ3kgKiBneSldO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBwcm9qZWN0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb25pY0VxdWlkaXN0YW50KCkge1xyXG4gIHJldHVybiBjb25pY1Byb2plY3Rpb24oY29uaWNFcXVpZGlzdGFudFJhdylcclxuICAgICAgLnNjYWxlKDEzMS4xNTQpXHJcbiAgICAgIC5jZW50ZXIoWzAsIDEzLjkzODldKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ25vbW9uaWNSYXcoeCwgeSkge1xyXG4gIHZhciBjeSA9IGNvcyQxKHkpLCBrID0gY29zJDEoeCkgKiBjeTtcclxuICByZXR1cm4gW2N5ICogc2luJDEoeCkgLyBrLCBzaW4kMSh5KSAvIGtdO1xyXG59XHJcblxyXG5nbm9tb25pY1Jhdy5pbnZlcnQgPSBhemltdXRoYWxJbnZlcnQoYXRhbik7XHJcblxyXG5mdW5jdGlvbiBnbm9tb25pYygpIHtcclxuICByZXR1cm4gcHJvamVjdGlvbihnbm9tb25pY1JhdylcclxuICAgICAgLnNjYWxlKDE0NC4wNDkpXHJcbiAgICAgIC5jbGlwQW5nbGUoNjApO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzY2FsZVRyYW5zbGF0ZSQxKGt4LCBreSwgdHgsIHR5KSB7XHJcbiAgcmV0dXJuIGt4ID09PSAxICYmIGt5ID09PSAxICYmIHR4ID09PSAwICYmIHR5ID09PSAwID8gaWRlbnRpdHkkNCA6IHRyYW5zZm9ybWVyKHtcclxuICAgIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICAgIHRoaXMuc3RyZWFtLnBvaW50KHggKiBreCArIHR4LCB5ICoga3kgKyB0eSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlkZW50aXR5JDUoKSB7XHJcbiAgdmFyIGsgPSAxLCB0eCA9IDAsIHR5ID0gMCwgc3ggPSAxLCBzeSA9IDEsIHRyYW5zZm9ybSQkMSA9IGlkZW50aXR5JDQsIC8vIHNjYWxlLCB0cmFuc2xhdGUgYW5kIHJlZmxlY3RcclxuICAgICAgeDAgPSBudWxsLCB5MCwgeDEsIHkxLCAvLyBjbGlwIGV4dGVudFxyXG4gICAgICBwb3N0Y2xpcCA9IGlkZW50aXR5JDQsXHJcbiAgICAgIGNhY2hlLFxyXG4gICAgICBjYWNoZVN0cmVhbSxcclxuICAgICAgcHJvamVjdGlvbjtcclxuXHJcbiAgZnVuY3Rpb24gcmVzZXQoKSB7XHJcbiAgICBjYWNoZSA9IGNhY2hlU3RyZWFtID0gbnVsbDtcclxuICAgIHJldHVybiBwcm9qZWN0aW9uO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHByb2plY3Rpb24gPSB7XHJcbiAgICBzdHJlYW06IGZ1bmN0aW9uKHN0cmVhbSkge1xyXG4gICAgICByZXR1cm4gY2FjaGUgJiYgY2FjaGVTdHJlYW0gPT09IHN0cmVhbSA/IGNhY2hlIDogY2FjaGUgPSB0cmFuc2Zvcm0kJDEocG9zdGNsaXAoY2FjaGVTdHJlYW0gPSBzdHJlYW0pKTtcclxuICAgIH0sXHJcbiAgICBwb3N0Y2xpcDogZnVuY3Rpb24oXykge1xyXG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwb3N0Y2xpcCA9IF8sIHgwID0geTAgPSB4MSA9IHkxID0gbnVsbCwgcmVzZXQoKSkgOiBwb3N0Y2xpcDtcclxuICAgIH0sXHJcbiAgICBjbGlwRXh0ZW50OiBmdW5jdGlvbihfKSB7XHJcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBvc3RjbGlwID0gXyA9PSBudWxsID8gKHgwID0geTAgPSB4MSA9IHkxID0gbnVsbCwgaWRlbnRpdHkkNCkgOiBjbGlwUmVjdGFuZ2xlKHgwID0gK19bMF1bMF0sIHkwID0gK19bMF1bMV0sIHgxID0gK19bMV1bMF0sIHkxID0gK19bMV1bMV0pLCByZXNldCgpKSA6IHgwID09IG51bGwgPyBudWxsIDogW1t4MCwgeTBdLCBbeDEsIHkxXV07XHJcbiAgICB9LFxyXG4gICAgc2NhbGU6IGZ1bmN0aW9uKF8pIHtcclxuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodHJhbnNmb3JtJCQxID0gc2NhbGVUcmFuc2xhdGUkMSgoayA9ICtfKSAqIHN4LCBrICogc3ksIHR4LCB0eSksIHJlc2V0KCkpIDogaztcclxuICAgIH0sXHJcbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uKF8pIHtcclxuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodHJhbnNmb3JtJCQxID0gc2NhbGVUcmFuc2xhdGUkMShrICogc3gsIGsgKiBzeSwgdHggPSArX1swXSwgdHkgPSArX1sxXSksIHJlc2V0KCkpIDogW3R4LCB0eV07XHJcbiAgICB9LFxyXG4gICAgcmVmbGVjdFg6IGZ1bmN0aW9uKF8pIHtcclxuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodHJhbnNmb3JtJCQxID0gc2NhbGVUcmFuc2xhdGUkMShrICogKHN4ID0gXyA/IC0xIDogMSksIGsgKiBzeSwgdHgsIHR5KSwgcmVzZXQoKSkgOiBzeCA8IDA7XHJcbiAgICB9LFxyXG4gICAgcmVmbGVjdFk6IGZ1bmN0aW9uKF8pIHtcclxuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodHJhbnNmb3JtJCQxID0gc2NhbGVUcmFuc2xhdGUkMShrICogc3gsIGsgKiAoc3kgPSBfID8gLTEgOiAxKSwgdHgsIHR5KSwgcmVzZXQoKSkgOiBzeSA8IDA7XHJcbiAgICB9LFxyXG4gICAgZml0RXh0ZW50OiBmdW5jdGlvbihleHRlbnQsIG9iamVjdCkge1xyXG4gICAgICByZXR1cm4gZml0RXh0ZW50KHByb2plY3Rpb24sIGV4dGVudCwgb2JqZWN0KTtcclxuICAgIH0sXHJcbiAgICBmaXRTaXplOiBmdW5jdGlvbihzaXplLCBvYmplY3QpIHtcclxuICAgICAgcmV0dXJuIGZpdFNpemUocHJvamVjdGlvbiwgc2l6ZSwgb2JqZWN0KTtcclxuICAgIH0sXHJcbiAgICBmaXRXaWR0aDogZnVuY3Rpb24od2lkdGgsIG9iamVjdCkge1xyXG4gICAgICByZXR1cm4gZml0V2lkdGgocHJvamVjdGlvbiwgd2lkdGgsIG9iamVjdCk7XHJcbiAgICB9LFxyXG4gICAgZml0SGVpZ2h0OiBmdW5jdGlvbihoZWlnaHQsIG9iamVjdCkge1xyXG4gICAgICByZXR1cm4gZml0SGVpZ2h0KHByb2plY3Rpb24sIGhlaWdodCwgb2JqZWN0KTtcclxuICAgIH1cclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBuYXR1cmFsRWFydGgxUmF3KGxhbWJkYSwgcGhpKSB7XHJcbiAgdmFyIHBoaTIgPSBwaGkgKiBwaGksIHBoaTQgPSBwaGkyICogcGhpMjtcclxuICByZXR1cm4gW1xyXG4gICAgbGFtYmRhICogKDAuODcwNyAtIDAuMTMxOTc5ICogcGhpMiArIHBoaTQgKiAoLTAuMDEzNzkxICsgcGhpNCAqICgwLjAwMzk3MSAqIHBoaTIgLSAwLjAwMTUyOSAqIHBoaTQpKSksXHJcbiAgICBwaGkgKiAoMS4wMDcyMjYgKyBwaGkyICogKDAuMDE1MDg1ICsgcGhpNCAqICgtMC4wNDQ0NzUgKyAwLjAyODg3NCAqIHBoaTIgLSAwLjAwNTkxNiAqIHBoaTQpKSlcclxuICBdO1xyXG59XHJcblxyXG5uYXR1cmFsRWFydGgxUmF3LmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcclxuICB2YXIgcGhpID0geSwgaSA9IDI1LCBkZWx0YTtcclxuICBkbyB7XHJcbiAgICB2YXIgcGhpMiA9IHBoaSAqIHBoaSwgcGhpNCA9IHBoaTIgKiBwaGkyO1xyXG4gICAgcGhpIC09IGRlbHRhID0gKHBoaSAqICgxLjAwNzIyNiArIHBoaTIgKiAoMC4wMTUwODUgKyBwaGk0ICogKC0wLjA0NDQ3NSArIDAuMDI4ODc0ICogcGhpMiAtIDAuMDA1OTE2ICogcGhpNCkpKSAtIHkpIC9cclxuICAgICAgICAoMS4wMDcyMjYgKyBwaGkyICogKDAuMDE1MDg1ICogMyArIHBoaTQgKiAoLTAuMDQ0NDc1ICogNyArIDAuMDI4ODc0ICogOSAqIHBoaTIgLSAwLjAwNTkxNiAqIDExICogcGhpNCkpKTtcclxuICB9IHdoaWxlIChhYnMoZGVsdGEpID4gZXBzaWxvbiQyICYmIC0taSA+IDApO1xyXG4gIHJldHVybiBbXHJcbiAgICB4IC8gKDAuODcwNyArIChwaGkyID0gcGhpICogcGhpKSAqICgtMC4xMzE5NzkgKyBwaGkyICogKC0wLjAxMzc5MSArIHBoaTIgKiBwaGkyICogcGhpMiAqICgwLjAwMzk3MSAtIDAuMDAxNTI5ICogcGhpMikpKSksXHJcbiAgICBwaGlcclxuICBdO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gbmF0dXJhbEVhcnRoMSgpIHtcclxuICByZXR1cm4gcHJvamVjdGlvbihuYXR1cmFsRWFydGgxUmF3KVxyXG4gICAgICAuc2NhbGUoMTc1LjI5NSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG9ydGhvZ3JhcGhpY1Jhdyh4LCB5KSB7XHJcbiAgcmV0dXJuIFtjb3MkMSh5KSAqIHNpbiQxKHgpLCBzaW4kMSh5KV07XHJcbn1cclxuXHJcbm9ydGhvZ3JhcGhpY1Jhdy5pbnZlcnQgPSBhemltdXRoYWxJbnZlcnQoYXNpbik7XHJcblxyXG5mdW5jdGlvbiBvcnRob2dyYXBoaWMoKSB7XHJcbiAgcmV0dXJuIHByb2plY3Rpb24ob3J0aG9ncmFwaGljUmF3KVxyXG4gICAgICAuc2NhbGUoMjQ5LjUpXHJcbiAgICAgIC5jbGlwQW5nbGUoOTAgKyBlcHNpbG9uJDIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzdGVyZW9ncmFwaGljUmF3KHgsIHkpIHtcclxuICB2YXIgY3kgPSBjb3MkMSh5KSwgayA9IDEgKyBjb3MkMSh4KSAqIGN5O1xyXG4gIHJldHVybiBbY3kgKiBzaW4kMSh4KSAvIGssIHNpbiQxKHkpIC8ga107XHJcbn1cclxuXHJcbnN0ZXJlb2dyYXBoaWNSYXcuaW52ZXJ0ID0gYXppbXV0aGFsSW52ZXJ0KGZ1bmN0aW9uKHopIHtcclxuICByZXR1cm4gMiAqIGF0YW4oeik7XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gc3RlcmVvZ3JhcGhpYygpIHtcclxuICByZXR1cm4gcHJvamVjdGlvbihzdGVyZW9ncmFwaGljUmF3KVxyXG4gICAgICAuc2NhbGUoMjUwKVxyXG4gICAgICAuY2xpcEFuZ2xlKDE0Mik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRyYW5zdmVyc2VNZXJjYXRvclJhdyhsYW1iZGEsIHBoaSkge1xyXG4gIHJldHVybiBbbG9nKHRhbigoaGFsZlBpJDIgKyBwaGkpIC8gMikpLCAtbGFtYmRhXTtcclxufVxyXG5cclxudHJhbnN2ZXJzZU1lcmNhdG9yUmF3LmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcclxuICByZXR1cm4gWy15LCAyICogYXRhbihleHAoeCkpIC0gaGFsZlBpJDJdO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnN2ZXJzZU1lcmNhdG9yKCkge1xyXG4gIHZhciBtID0gbWVyY2F0b3JQcm9qZWN0aW9uKHRyYW5zdmVyc2VNZXJjYXRvclJhdyksXHJcbiAgICAgIGNlbnRlciA9IG0uY2VudGVyLFxyXG4gICAgICByb3RhdGUgPSBtLnJvdGF0ZTtcclxuXHJcbiAgbS5jZW50ZXIgPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IGNlbnRlcihbLV9bMV0sIF9bMF1dKSA6IChfID0gY2VudGVyKCksIFtfWzFdLCAtX1swXV0pO1xyXG4gIH07XHJcblxyXG4gIG0ucm90YXRlID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyByb3RhdGUoW19bMF0sIF9bMV0sIF8ubGVuZ3RoID4gMiA/IF9bMl0gKyA5MCA6IDkwXSkgOiAoXyA9IHJvdGF0ZSgpLCBbX1swXSwgX1sxXSwgX1syXSAtIDkwXSk7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIHJvdGF0ZShbMCwgMCwgOTBdKVxyXG4gICAgICAuc2NhbGUoMTU5LjE1NSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlZmF1bHRTZXBhcmF0aW9uKGEsIGIpIHtcclxuICByZXR1cm4gYS5wYXJlbnQgPT09IGIucGFyZW50ID8gMSA6IDI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1lYW5YKGNoaWxkcmVuKSB7XHJcbiAgcmV0dXJuIGNoaWxkcmVuLnJlZHVjZShtZWFuWFJlZHVjZSwgMCkgLyBjaGlsZHJlbi5sZW5ndGg7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1lYW5YUmVkdWNlKHgsIGMpIHtcclxuICByZXR1cm4geCArIGMueDtcclxufVxyXG5cclxuZnVuY3Rpb24gbWF4WShjaGlsZHJlbikge1xyXG4gIHJldHVybiAxICsgY2hpbGRyZW4ucmVkdWNlKG1heFlSZWR1Y2UsIDApO1xyXG59XHJcblxyXG5mdW5jdGlvbiBtYXhZUmVkdWNlKHksIGMpIHtcclxuICByZXR1cm4gTWF0aC5tYXgoeSwgYy55KTtcclxufVxyXG5cclxuZnVuY3Rpb24gbGVhZkxlZnQobm9kZSkge1xyXG4gIHZhciBjaGlsZHJlbjtcclxuICB3aGlsZSAoY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuKSBub2RlID0gY2hpbGRyZW5bMF07XHJcbiAgcmV0dXJuIG5vZGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxlYWZSaWdodChub2RlKSB7XHJcbiAgdmFyIGNoaWxkcmVuO1xyXG4gIHdoaWxlIChjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4pIG5vZGUgPSBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXTtcclxuICByZXR1cm4gbm9kZTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2x1c3RlcigpIHtcclxuICB2YXIgc2VwYXJhdGlvbiA9IGRlZmF1bHRTZXBhcmF0aW9uLFxyXG4gICAgICBkeCA9IDEsXHJcbiAgICAgIGR5ID0gMSxcclxuICAgICAgbm9kZVNpemUgPSBmYWxzZTtcclxuXHJcbiAgZnVuY3Rpb24gY2x1c3Rlcihyb290KSB7XHJcbiAgICB2YXIgcHJldmlvdXNOb2RlLFxyXG4gICAgICAgIHggPSAwO1xyXG5cclxuICAgIC8vIEZpcnN0IHdhbGssIGNvbXB1dGluZyB0aGUgaW5pdGlhbCB4ICYgeSB2YWx1ZXMuXHJcbiAgICByb290LmVhY2hBZnRlcihmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XHJcbiAgICAgIGlmIChjaGlsZHJlbikge1xyXG4gICAgICAgIG5vZGUueCA9IG1lYW5YKGNoaWxkcmVuKTtcclxuICAgICAgICBub2RlLnkgPSBtYXhZKGNoaWxkcmVuKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBub2RlLnggPSBwcmV2aW91c05vZGUgPyB4ICs9IHNlcGFyYXRpb24obm9kZSwgcHJldmlvdXNOb2RlKSA6IDA7XHJcbiAgICAgICAgbm9kZS55ID0gMDtcclxuICAgICAgICBwcmV2aW91c05vZGUgPSBub2RlO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICB2YXIgbGVmdCA9IGxlYWZMZWZ0KHJvb3QpLFxyXG4gICAgICAgIHJpZ2h0ID0gbGVhZlJpZ2h0KHJvb3QpLFxyXG4gICAgICAgIHgwID0gbGVmdC54IC0gc2VwYXJhdGlvbihsZWZ0LCByaWdodCkgLyAyLFxyXG4gICAgICAgIHgxID0gcmlnaHQueCArIHNlcGFyYXRpb24ocmlnaHQsIGxlZnQpIC8gMjtcclxuXHJcbiAgICAvLyBTZWNvbmQgd2Fsaywgbm9ybWFsaXppbmcgeCAmIHkgdG8gdGhlIGRlc2lyZWQgc2l6ZS5cclxuICAgIHJldHVybiByb290LmVhY2hBZnRlcihub2RlU2l6ZSA/IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgbm9kZS54ID0gKG5vZGUueCAtIHJvb3QueCkgKiBkeDtcclxuICAgICAgbm9kZS55ID0gKHJvb3QueSAtIG5vZGUueSkgKiBkeTtcclxuICAgIH0gOiBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgIG5vZGUueCA9IChub2RlLnggLSB4MCkgLyAoeDEgLSB4MCkgKiBkeDtcclxuICAgICAgbm9kZS55ID0gKDEgLSAocm9vdC55ID8gbm9kZS55IC8gcm9vdC55IDogMSkpICogZHk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGNsdXN0ZXIuc2VwYXJhdGlvbiA9IGZ1bmN0aW9uKHgpIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNlcGFyYXRpb24gPSB4LCBjbHVzdGVyKSA6IHNlcGFyYXRpb247XHJcbiAgfTtcclxuXHJcbiAgY2x1c3Rlci5zaXplID0gZnVuY3Rpb24oeCkge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobm9kZVNpemUgPSBmYWxzZSwgZHggPSAreFswXSwgZHkgPSAreFsxXSwgY2x1c3RlcikgOiAobm9kZVNpemUgPyBudWxsIDogW2R4LCBkeV0pO1xyXG4gIH07XHJcblxyXG4gIGNsdXN0ZXIubm9kZVNpemUgPSBmdW5jdGlvbih4KSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChub2RlU2l6ZSA9IHRydWUsIGR4ID0gK3hbMF0sIGR5ID0gK3hbMV0sIGNsdXN0ZXIpIDogKG5vZGVTaXplID8gW2R4LCBkeV0gOiBudWxsKTtcclxuICB9O1xyXG5cclxuICByZXR1cm4gY2x1c3RlcjtcclxufVxyXG5cclxuZnVuY3Rpb24gY291bnQobm9kZSkge1xyXG4gIHZhciBzdW0gPSAwLFxyXG4gICAgICBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4sXHJcbiAgICAgIGkgPSBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGg7XHJcbiAgaWYgKCFpKSBzdW0gPSAxO1xyXG4gIGVsc2Ugd2hpbGUgKC0taSA+PSAwKSBzdW0gKz0gY2hpbGRyZW5baV0udmFsdWU7XHJcbiAgbm9kZS52YWx1ZSA9IHN1bTtcclxufVxyXG5cclxuZnVuY3Rpb24gbm9kZV9jb3VudCgpIHtcclxuICByZXR1cm4gdGhpcy5lYWNoQWZ0ZXIoY291bnQpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBub2RlX2VhY2goY2FsbGJhY2spIHtcclxuICB2YXIgbm9kZSA9IHRoaXMsIGN1cnJlbnQsIG5leHQgPSBbbm9kZV0sIGNoaWxkcmVuLCBpLCBuO1xyXG4gIGRvIHtcclxuICAgIGN1cnJlbnQgPSBuZXh0LnJldmVyc2UoKSwgbmV4dCA9IFtdO1xyXG4gICAgd2hpbGUgKG5vZGUgPSBjdXJyZW50LnBvcCgpKSB7XHJcbiAgICAgIGNhbGxiYWNrKG5vZGUpLCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XHJcbiAgICAgIGlmIChjaGlsZHJlbikgZm9yIChpID0gMCwgbiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IG47ICsraSkge1xyXG4gICAgICAgIG5leHQucHVzaChjaGlsZHJlbltpXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9IHdoaWxlIChuZXh0Lmxlbmd0aCk7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5vZGVfZWFjaEJlZm9yZShjYWxsYmFjaykge1xyXG4gIHZhciBub2RlID0gdGhpcywgbm9kZXMgPSBbbm9kZV0sIGNoaWxkcmVuLCBpO1xyXG4gIHdoaWxlIChub2RlID0gbm9kZXMucG9wKCkpIHtcclxuICAgIGNhbGxiYWNrKG5vZGUpLCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XHJcbiAgICBpZiAoY2hpbGRyZW4pIGZvciAoaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XHJcbiAgICAgIG5vZGVzLnB1c2goY2hpbGRyZW5baV0pO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuZnVuY3Rpb24gbm9kZV9lYWNoQWZ0ZXIoY2FsbGJhY2spIHtcclxuICB2YXIgbm9kZSA9IHRoaXMsIG5vZGVzID0gW25vZGVdLCBuZXh0ID0gW10sIGNoaWxkcmVuLCBpLCBuO1xyXG4gIHdoaWxlIChub2RlID0gbm9kZXMucG9wKCkpIHtcclxuICAgIG5leHQucHVzaChub2RlKSwgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xyXG4gICAgaWYgKGNoaWxkcmVuKSBmb3IgKGkgPSAwLCBuID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgIG5vZGVzLnB1c2goY2hpbGRyZW5baV0pO1xyXG4gICAgfVxyXG4gIH1cclxuICB3aGlsZSAobm9kZSA9IG5leHQucG9wKCkpIHtcclxuICAgIGNhbGxiYWNrKG5vZGUpO1xyXG4gIH1cclxuICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuZnVuY3Rpb24gbm9kZV9zdW0odmFsdWUpIHtcclxuICByZXR1cm4gdGhpcy5lYWNoQWZ0ZXIoZnVuY3Rpb24obm9kZSkge1xyXG4gICAgdmFyIHN1bSA9ICt2YWx1ZShub2RlLmRhdGEpIHx8IDAsXHJcbiAgICAgICAgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuLFxyXG4gICAgICAgIGkgPSBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGg7XHJcbiAgICB3aGlsZSAoLS1pID49IDApIHN1bSArPSBjaGlsZHJlbltpXS52YWx1ZTtcclxuICAgIG5vZGUudmFsdWUgPSBzdW07XHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5vZGVfc29ydChjb21wYXJlKSB7XHJcbiAgcmV0dXJuIHRoaXMuZWFjaEJlZm9yZShmdW5jdGlvbihub2RlKSB7XHJcbiAgICBpZiAobm9kZS5jaGlsZHJlbikge1xyXG4gICAgICBub2RlLmNoaWxkcmVuLnNvcnQoY29tcGFyZSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5vZGVfcGF0aChlbmQpIHtcclxuICB2YXIgc3RhcnQgPSB0aGlzLFxyXG4gICAgICBhbmNlc3RvciA9IGxlYXN0Q29tbW9uQW5jZXN0b3Ioc3RhcnQsIGVuZCksXHJcbiAgICAgIG5vZGVzID0gW3N0YXJ0XTtcclxuICB3aGlsZSAoc3RhcnQgIT09IGFuY2VzdG9yKSB7XHJcbiAgICBzdGFydCA9IHN0YXJ0LnBhcmVudDtcclxuICAgIG5vZGVzLnB1c2goc3RhcnQpO1xyXG4gIH1cclxuICB2YXIgayA9IG5vZGVzLmxlbmd0aDtcclxuICB3aGlsZSAoZW5kICE9PSBhbmNlc3Rvcikge1xyXG4gICAgbm9kZXMuc3BsaWNlKGssIDAsIGVuZCk7XHJcbiAgICBlbmQgPSBlbmQucGFyZW50O1xyXG4gIH1cclxuICByZXR1cm4gbm9kZXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxlYXN0Q29tbW9uQW5jZXN0b3IoYSwgYikge1xyXG4gIGlmIChhID09PSBiKSByZXR1cm4gYTtcclxuICB2YXIgYU5vZGVzID0gYS5hbmNlc3RvcnMoKSxcclxuICAgICAgYk5vZGVzID0gYi5hbmNlc3RvcnMoKSxcclxuICAgICAgYyA9IG51bGw7XHJcbiAgYSA9IGFOb2Rlcy5wb3AoKTtcclxuICBiID0gYk5vZGVzLnBvcCgpO1xyXG4gIHdoaWxlIChhID09PSBiKSB7XHJcbiAgICBjID0gYTtcclxuICAgIGEgPSBhTm9kZXMucG9wKCk7XHJcbiAgICBiID0gYk5vZGVzLnBvcCgpO1xyXG4gIH1cclxuICByZXR1cm4gYztcclxufVxyXG5cclxuZnVuY3Rpb24gbm9kZV9hbmNlc3RvcnMoKSB7XHJcbiAgdmFyIG5vZGUgPSB0aGlzLCBub2RlcyA9IFtub2RlXTtcclxuICB3aGlsZSAobm9kZSA9IG5vZGUucGFyZW50KSB7XHJcbiAgICBub2Rlcy5wdXNoKG5vZGUpO1xyXG4gIH1cclxuICByZXR1cm4gbm9kZXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5vZGVfZGVzY2VuZGFudHMoKSB7XHJcbiAgdmFyIG5vZGVzID0gW107XHJcbiAgdGhpcy5lYWNoKGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgIG5vZGVzLnB1c2gobm9kZSk7XHJcbiAgfSk7XHJcbiAgcmV0dXJuIG5vZGVzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBub2RlX2xlYXZlcygpIHtcclxuICB2YXIgbGVhdmVzID0gW107XHJcbiAgdGhpcy5lYWNoQmVmb3JlKGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgIGlmICghbm9kZS5jaGlsZHJlbikge1xyXG4gICAgICBsZWF2ZXMucHVzaChub2RlKTtcclxuICAgIH1cclxuICB9KTtcclxuICByZXR1cm4gbGVhdmVzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBub2RlX2xpbmtzKCkge1xyXG4gIHZhciByb290ID0gdGhpcywgbGlua3MgPSBbXTtcclxuICByb290LmVhY2goZnVuY3Rpb24obm9kZSkge1xyXG4gICAgaWYgKG5vZGUgIT09IHJvb3QpIHsgLy8gRG9u4oCZdCBpbmNsdWRlIHRoZSByb2904oCZcyBwYXJlbnQsIGlmIGFueS5cclxuICAgICAgbGlua3MucHVzaCh7c291cmNlOiBub2RlLnBhcmVudCwgdGFyZ2V0OiBub2RlfSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgcmV0dXJuIGxpbmtzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBoaWVyYXJjaHkoZGF0YSwgY2hpbGRyZW4pIHtcclxuICB2YXIgcm9vdCA9IG5ldyBOb2RlKGRhdGEpLFxyXG4gICAgICB2YWx1ZWQgPSArZGF0YS52YWx1ZSAmJiAocm9vdC52YWx1ZSA9IGRhdGEudmFsdWUpLFxyXG4gICAgICBub2RlLFxyXG4gICAgICBub2RlcyA9IFtyb290XSxcclxuICAgICAgY2hpbGQsXHJcbiAgICAgIGNoaWxkcyxcclxuICAgICAgaSxcclxuICAgICAgbjtcclxuXHJcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIGNoaWxkcmVuID0gZGVmYXVsdENoaWxkcmVuO1xyXG5cclxuICB3aGlsZSAobm9kZSA9IG5vZGVzLnBvcCgpKSB7XHJcbiAgICBpZiAodmFsdWVkKSBub2RlLnZhbHVlID0gK25vZGUuZGF0YS52YWx1ZTtcclxuICAgIGlmICgoY2hpbGRzID0gY2hpbGRyZW4obm9kZS5kYXRhKSkgJiYgKG4gPSBjaGlsZHMubGVuZ3RoKSkge1xyXG4gICAgICBub2RlLmNoaWxkcmVuID0gbmV3IEFycmF5KG4pO1xyXG4gICAgICBmb3IgKGkgPSBuIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuICAgICAgICBub2Rlcy5wdXNoKGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXSA9IG5ldyBOb2RlKGNoaWxkc1tpXSkpO1xyXG4gICAgICAgIGNoaWxkLnBhcmVudCA9IG5vZGU7XHJcbiAgICAgICAgY2hpbGQuZGVwdGggPSBub2RlLmRlcHRoICsgMTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJvb3QuZWFjaEJlZm9yZShjb21wdXRlSGVpZ2h0KTtcclxufVxyXG5cclxuZnVuY3Rpb24gbm9kZV9jb3B5KCkge1xyXG4gIHJldHVybiBoaWVyYXJjaHkodGhpcykuZWFjaEJlZm9yZShjb3B5RGF0YSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlZmF1bHRDaGlsZHJlbihkKSB7XHJcbiAgcmV0dXJuIGQuY2hpbGRyZW47XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvcHlEYXRhKG5vZGUpIHtcclxuICBub2RlLmRhdGEgPSBub2RlLmRhdGEuZGF0YTtcclxufVxyXG5cclxuZnVuY3Rpb24gY29tcHV0ZUhlaWdodChub2RlKSB7XHJcbiAgdmFyIGhlaWdodCA9IDA7XHJcbiAgZG8gbm9kZS5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgd2hpbGUgKChub2RlID0gbm9kZS5wYXJlbnQpICYmIChub2RlLmhlaWdodCA8ICsraGVpZ2h0KSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIE5vZGUoZGF0YSkge1xyXG4gIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgdGhpcy5kZXB0aCA9XHJcbiAgdGhpcy5oZWlnaHQgPSAwO1xyXG4gIHRoaXMucGFyZW50ID0gbnVsbDtcclxufVxyXG5cclxuTm9kZS5wcm90b3R5cGUgPSBoaWVyYXJjaHkucHJvdG90eXBlID0ge1xyXG4gIGNvbnN0cnVjdG9yOiBOb2RlLFxyXG4gIGNvdW50OiBub2RlX2NvdW50LFxyXG4gIGVhY2g6IG5vZGVfZWFjaCxcclxuICBlYWNoQWZ0ZXI6IG5vZGVfZWFjaEFmdGVyLFxyXG4gIGVhY2hCZWZvcmU6IG5vZGVfZWFjaEJlZm9yZSxcclxuICBzdW06IG5vZGVfc3VtLFxyXG4gIHNvcnQ6IG5vZGVfc29ydCxcclxuICBwYXRoOiBub2RlX3BhdGgsXHJcbiAgYW5jZXN0b3JzOiBub2RlX2FuY2VzdG9ycyxcclxuICBkZXNjZW5kYW50czogbm9kZV9kZXNjZW5kYW50cyxcclxuICBsZWF2ZXM6IG5vZGVfbGVhdmVzLFxyXG4gIGxpbmtzOiBub2RlX2xpbmtzLFxyXG4gIGNvcHk6IG5vZGVfY29weVxyXG59O1xyXG5cclxudmFyIHNsaWNlJDQgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XHJcblxyXG5mdW5jdGlvbiBzaHVmZmxlJDEoYXJyYXkpIHtcclxuICB2YXIgbSA9IGFycmF5Lmxlbmd0aCxcclxuICAgICAgdCxcclxuICAgICAgaTtcclxuXHJcbiAgd2hpbGUgKG0pIHtcclxuICAgIGkgPSBNYXRoLnJhbmRvbSgpICogbS0tIHwgMDtcclxuICAgIHQgPSBhcnJheVttXTtcclxuICAgIGFycmF5W21dID0gYXJyYXlbaV07XHJcbiAgICBhcnJheVtpXSA9IHQ7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gYXJyYXk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVuY2xvc2UoY2lyY2xlcykge1xyXG4gIHZhciBpID0gMCwgbiA9IChjaXJjbGVzID0gc2h1ZmZsZSQxKHNsaWNlJDQuY2FsbChjaXJjbGVzKSkpLmxlbmd0aCwgQiA9IFtdLCBwLCBlO1xyXG5cclxuICB3aGlsZSAoaSA8IG4pIHtcclxuICAgIHAgPSBjaXJjbGVzW2ldO1xyXG4gICAgaWYgKGUgJiYgZW5jbG9zZXNXZWFrKGUsIHApKSArK2k7XHJcbiAgICBlbHNlIGUgPSBlbmNsb3NlQmFzaXMoQiA9IGV4dGVuZEJhc2lzKEIsIHApKSwgaSA9IDA7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZTtcclxufVxyXG5cclxuZnVuY3Rpb24gZXh0ZW5kQmFzaXMoQiwgcCkge1xyXG4gIHZhciBpLCBqO1xyXG5cclxuICBpZiAoZW5jbG9zZXNXZWFrQWxsKHAsIEIpKSByZXR1cm4gW3BdO1xyXG5cclxuICAvLyBJZiB3ZSBnZXQgaGVyZSB0aGVuIEIgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBlbGVtZW50LlxyXG4gIGZvciAoaSA9IDA7IGkgPCBCLmxlbmd0aDsgKytpKSB7XHJcbiAgICBpZiAoZW5jbG9zZXNOb3QocCwgQltpXSlcclxuICAgICAgICAmJiBlbmNsb3Nlc1dlYWtBbGwoZW5jbG9zZUJhc2lzMihCW2ldLCBwKSwgQikpIHtcclxuICAgICAgcmV0dXJuIFtCW2ldLCBwXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIElmIHdlIGdldCBoZXJlIHRoZW4gQiBtdXN0IGhhdmUgYXQgbGVhc3QgdHdvIGVsZW1lbnRzLlxyXG4gIGZvciAoaSA9IDA7IGkgPCBCLmxlbmd0aCAtIDE7ICsraSkge1xyXG4gICAgZm9yIChqID0gaSArIDE7IGogPCBCLmxlbmd0aDsgKytqKSB7XHJcbiAgICAgIGlmIChlbmNsb3Nlc05vdChlbmNsb3NlQmFzaXMyKEJbaV0sIEJbal0pLCBwKVxyXG4gICAgICAgICAgJiYgZW5jbG9zZXNOb3QoZW5jbG9zZUJhc2lzMihCW2ldLCBwKSwgQltqXSlcclxuICAgICAgICAgICYmIGVuY2xvc2VzTm90KGVuY2xvc2VCYXNpczIoQltqXSwgcCksIEJbaV0pXHJcbiAgICAgICAgICAmJiBlbmNsb3Nlc1dlYWtBbGwoZW5jbG9zZUJhc2lzMyhCW2ldLCBCW2pdLCBwKSwgQikpIHtcclxuICAgICAgICByZXR1cm4gW0JbaV0sIEJbal0sIHBdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBJZiB3ZSBnZXQgaGVyZSB0aGVuIHNvbWV0aGluZyBpcyB2ZXJ5IHdyb25nLlxyXG4gIHRocm93IG5ldyBFcnJvcjtcclxufVxyXG5cclxuZnVuY3Rpb24gZW5jbG9zZXNOb3QoYSwgYikge1xyXG4gIHZhciBkciA9IGEuciAtIGIuciwgZHggPSBiLnggLSBhLngsIGR5ID0gYi55IC0gYS55O1xyXG4gIHJldHVybiBkciA8IDAgfHwgZHIgKiBkciA8IGR4ICogZHggKyBkeSAqIGR5O1xyXG59XHJcblxyXG5mdW5jdGlvbiBlbmNsb3Nlc1dlYWsoYSwgYikge1xyXG4gIHZhciBkciA9IGEuciAtIGIuciArIDFlLTYsIGR4ID0gYi54IC0gYS54LCBkeSA9IGIueSAtIGEueTtcclxuICByZXR1cm4gZHIgPiAwICYmIGRyICogZHIgPiBkeCAqIGR4ICsgZHkgKiBkeTtcclxufVxyXG5cclxuZnVuY3Rpb24gZW5jbG9zZXNXZWFrQWxsKGEsIEIpIHtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IEIubGVuZ3RoOyArK2kpIHtcclxuICAgIGlmICghZW5jbG9zZXNXZWFrKGEsIEJbaV0pKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVuY2xvc2VCYXNpcyhCKSB7XHJcbiAgc3dpdGNoIChCLmxlbmd0aCkge1xyXG4gICAgY2FzZSAxOiByZXR1cm4gZW5jbG9zZUJhc2lzMShCWzBdKTtcclxuICAgIGNhc2UgMjogcmV0dXJuIGVuY2xvc2VCYXNpczIoQlswXSwgQlsxXSk7XHJcbiAgICBjYXNlIDM6IHJldHVybiBlbmNsb3NlQmFzaXMzKEJbMF0sIEJbMV0sIEJbMl0pO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZW5jbG9zZUJhc2lzMShhKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHg6IGEueCxcclxuICAgIHk6IGEueSxcclxuICAgIHI6IGEuclxyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVuY2xvc2VCYXNpczIoYSwgYikge1xyXG4gIHZhciB4MSA9IGEueCwgeTEgPSBhLnksIHIxID0gYS5yLFxyXG4gICAgICB4MiA9IGIueCwgeTIgPSBiLnksIHIyID0gYi5yLFxyXG4gICAgICB4MjEgPSB4MiAtIHgxLCB5MjEgPSB5MiAtIHkxLCByMjEgPSByMiAtIHIxLFxyXG4gICAgICBsID0gTWF0aC5zcXJ0KHgyMSAqIHgyMSArIHkyMSAqIHkyMSk7XHJcbiAgcmV0dXJuIHtcclxuICAgIHg6ICh4MSArIHgyICsgeDIxIC8gbCAqIHIyMSkgLyAyLFxyXG4gICAgeTogKHkxICsgeTIgKyB5MjEgLyBsICogcjIxKSAvIDIsXHJcbiAgICByOiAobCArIHIxICsgcjIpIC8gMlxyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVuY2xvc2VCYXNpczMoYSwgYiwgYykge1xyXG4gIHZhciB4MSA9IGEueCwgeTEgPSBhLnksIHIxID0gYS5yLFxyXG4gICAgICB4MiA9IGIueCwgeTIgPSBiLnksIHIyID0gYi5yLFxyXG4gICAgICB4MyA9IGMueCwgeTMgPSBjLnksIHIzID0gYy5yLFxyXG4gICAgICBhMiA9IHgxIC0geDIsXHJcbiAgICAgIGEzID0geDEgLSB4MyxcclxuICAgICAgYjIgPSB5MSAtIHkyLFxyXG4gICAgICBiMyA9IHkxIC0geTMsXHJcbiAgICAgIGMyID0gcjIgLSByMSxcclxuICAgICAgYzMgPSByMyAtIHIxLFxyXG4gICAgICBkMSA9IHgxICogeDEgKyB5MSAqIHkxIC0gcjEgKiByMSxcclxuICAgICAgZDIgPSBkMSAtIHgyICogeDIgLSB5MiAqIHkyICsgcjIgKiByMixcclxuICAgICAgZDMgPSBkMSAtIHgzICogeDMgLSB5MyAqIHkzICsgcjMgKiByMyxcclxuICAgICAgYWIgPSBhMyAqIGIyIC0gYTIgKiBiMyxcclxuICAgICAgeGEgPSAoYjIgKiBkMyAtIGIzICogZDIpIC8gKGFiICogMikgLSB4MSxcclxuICAgICAgeGIgPSAoYjMgKiBjMiAtIGIyICogYzMpIC8gYWIsXHJcbiAgICAgIHlhID0gKGEzICogZDIgLSBhMiAqIGQzKSAvIChhYiAqIDIpIC0geTEsXHJcbiAgICAgIHliID0gKGEyICogYzMgLSBhMyAqIGMyKSAvIGFiLFxyXG4gICAgICBBID0geGIgKiB4YiArIHliICogeWIgLSAxLFxyXG4gICAgICBCID0gMiAqIChyMSArIHhhICogeGIgKyB5YSAqIHliKSxcclxuICAgICAgQyA9IHhhICogeGEgKyB5YSAqIHlhIC0gcjEgKiByMSxcclxuICAgICAgciA9IC0oQSA/IChCICsgTWF0aC5zcXJ0KEIgKiBCIC0gNCAqIEEgKiBDKSkgLyAoMiAqIEEpIDogQyAvIEIpO1xyXG4gIHJldHVybiB7XHJcbiAgICB4OiB4MSArIHhhICsgeGIgKiByLFxyXG4gICAgeTogeTEgKyB5YSArIHliICogcixcclxuICAgIHI6IHJcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBwbGFjZShiLCBhLCBjKSB7XHJcbiAgdmFyIGR4ID0gYi54IC0gYS54LCB4LCBhMixcclxuICAgICAgZHkgPSBiLnkgLSBhLnksIHksIGIyLFxyXG4gICAgICBkMiA9IGR4ICogZHggKyBkeSAqIGR5O1xyXG4gIGlmIChkMikge1xyXG4gICAgYTIgPSBhLnIgKyBjLnIsIGEyICo9IGEyO1xyXG4gICAgYjIgPSBiLnIgKyBjLnIsIGIyICo9IGIyO1xyXG4gICAgaWYgKGEyID4gYjIpIHtcclxuICAgICAgeCA9IChkMiArIGIyIC0gYTIpIC8gKDIgKiBkMik7XHJcbiAgICAgIHkgPSBNYXRoLnNxcnQoTWF0aC5tYXgoMCwgYjIgLyBkMiAtIHggKiB4KSk7XHJcbiAgICAgIGMueCA9IGIueCAtIHggKiBkeCAtIHkgKiBkeTtcclxuICAgICAgYy55ID0gYi55IC0geCAqIGR5ICsgeSAqIGR4O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgeCA9IChkMiArIGEyIC0gYjIpIC8gKDIgKiBkMik7XHJcbiAgICAgIHkgPSBNYXRoLnNxcnQoTWF0aC5tYXgoMCwgYTIgLyBkMiAtIHggKiB4KSk7XHJcbiAgICAgIGMueCA9IGEueCArIHggKiBkeCAtIHkgKiBkeTtcclxuICAgICAgYy55ID0gYS55ICsgeCAqIGR5ICsgeSAqIGR4O1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICBjLnggPSBhLnggKyBjLnI7XHJcbiAgICBjLnkgPSBhLnk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBpbnRlcnNlY3RzKGEsIGIpIHtcclxuICB2YXIgZHIgPSBhLnIgKyBiLnIgLSAxZS02LCBkeCA9IGIueCAtIGEueCwgZHkgPSBiLnkgLSBhLnk7XHJcbiAgcmV0dXJuIGRyID4gMCAmJiBkciAqIGRyID4gZHggKiBkeCArIGR5ICogZHk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNjb3JlKG5vZGUpIHtcclxuICB2YXIgYSA9IG5vZGUuXyxcclxuICAgICAgYiA9IG5vZGUubmV4dC5fLFxyXG4gICAgICBhYiA9IGEuciArIGIucixcclxuICAgICAgZHggPSAoYS54ICogYi5yICsgYi54ICogYS5yKSAvIGFiLFxyXG4gICAgICBkeSA9IChhLnkgKiBiLnIgKyBiLnkgKiBhLnIpIC8gYWI7XHJcbiAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xyXG59XHJcblxyXG5mdW5jdGlvbiBOb2RlJDEoY2lyY2xlKSB7XHJcbiAgdGhpcy5fID0gY2lyY2xlO1xyXG4gIHRoaXMubmV4dCA9IG51bGw7XHJcbiAgdGhpcy5wcmV2aW91cyA9IG51bGw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhY2tFbmNsb3NlKGNpcmNsZXMpIHtcclxuICBpZiAoIShuID0gY2lyY2xlcy5sZW5ndGgpKSByZXR1cm4gMDtcclxuXHJcbiAgdmFyIGEsIGIsIGMsIG4sIGFhLCBjYSwgaSwgaiwgaywgc2osIHNrO1xyXG5cclxuICAvLyBQbGFjZSB0aGUgZmlyc3QgY2lyY2xlLlxyXG4gIGEgPSBjaXJjbGVzWzBdLCBhLnggPSAwLCBhLnkgPSAwO1xyXG4gIGlmICghKG4gPiAxKSkgcmV0dXJuIGEucjtcclxuXHJcbiAgLy8gUGxhY2UgdGhlIHNlY29uZCBjaXJjbGUuXHJcbiAgYiA9IGNpcmNsZXNbMV0sIGEueCA9IC1iLnIsIGIueCA9IGEuciwgYi55ID0gMDtcclxuICBpZiAoIShuID4gMikpIHJldHVybiBhLnIgKyBiLnI7XHJcblxyXG4gIC8vIFBsYWNlIHRoZSB0aGlyZCBjaXJjbGUuXHJcbiAgcGxhY2UoYiwgYSwgYyA9IGNpcmNsZXNbMl0pO1xyXG5cclxuICAvLyBJbml0aWFsaXplIHRoZSBmcm9udC1jaGFpbiB1c2luZyB0aGUgZmlyc3QgdGhyZWUgY2lyY2xlcyBhLCBiIGFuZCBjLlxyXG4gIGEgPSBuZXcgTm9kZSQxKGEpLCBiID0gbmV3IE5vZGUkMShiKSwgYyA9IG5ldyBOb2RlJDEoYyk7XHJcbiAgYS5uZXh0ID0gYy5wcmV2aW91cyA9IGI7XHJcbiAgYi5uZXh0ID0gYS5wcmV2aW91cyA9IGM7XHJcbiAgYy5uZXh0ID0gYi5wcmV2aW91cyA9IGE7XHJcblxyXG4gIC8vIEF0dGVtcHQgdG8gcGxhY2UgZWFjaCByZW1haW5pbmcgY2lyY2xl4oCmXHJcbiAgcGFjazogZm9yIChpID0gMzsgaSA8IG47ICsraSkge1xyXG4gICAgcGxhY2UoYS5fLCBiLl8sIGMgPSBjaXJjbGVzW2ldKSwgYyA9IG5ldyBOb2RlJDEoYyk7XHJcblxyXG4gICAgLy8gRmluZCB0aGUgY2xvc2VzdCBpbnRlcnNlY3RpbmcgY2lyY2xlIG9uIHRoZSBmcm9udC1jaGFpbiwgaWYgYW55LlxyXG4gICAgLy8g4oCcQ2xvc2VuZXNz4oCdIGlzIGRldGVybWluZWQgYnkgbGluZWFyIGRpc3RhbmNlIGFsb25nIHRoZSBmcm9udC1jaGFpbi5cclxuICAgIC8vIOKAnEFoZWFk4oCdIG9yIOKAnGJlaGluZOKAnSBpcyBsaWtld2lzZSBkZXRlcm1pbmVkIGJ5IGxpbmVhciBkaXN0YW5jZS5cclxuICAgIGogPSBiLm5leHQsIGsgPSBhLnByZXZpb3VzLCBzaiA9IGIuXy5yLCBzayA9IGEuXy5yO1xyXG4gICAgZG8ge1xyXG4gICAgICBpZiAoc2ogPD0gc2spIHtcclxuICAgICAgICBpZiAoaW50ZXJzZWN0cyhqLl8sIGMuXykpIHtcclxuICAgICAgICAgIGIgPSBqLCBhLm5leHQgPSBiLCBiLnByZXZpb3VzID0gYSwgLS1pO1xyXG4gICAgICAgICAgY29udGludWUgcGFjaztcclxuICAgICAgICB9XHJcbiAgICAgICAgc2ogKz0gai5fLnIsIGogPSBqLm5leHQ7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKGludGVyc2VjdHMoay5fLCBjLl8pKSB7XHJcbiAgICAgICAgICBhID0gaywgYS5uZXh0ID0gYiwgYi5wcmV2aW91cyA9IGEsIC0taTtcclxuICAgICAgICAgIGNvbnRpbnVlIHBhY2s7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNrICs9IGsuXy5yLCBrID0gay5wcmV2aW91cztcclxuICAgICAgfVxyXG4gICAgfSB3aGlsZSAoaiAhPT0gay5uZXh0KTtcclxuXHJcbiAgICAvLyBTdWNjZXNzISBJbnNlcnQgdGhlIG5ldyBjaXJjbGUgYyBiZXR3ZWVuIGEgYW5kIGIuXHJcbiAgICBjLnByZXZpb3VzID0gYSwgYy5uZXh0ID0gYiwgYS5uZXh0ID0gYi5wcmV2aW91cyA9IGIgPSBjO1xyXG5cclxuICAgIC8vIENvbXB1dGUgdGhlIG5ldyBjbG9zZXN0IGNpcmNsZSBwYWlyIHRvIHRoZSBjZW50cm9pZC5cclxuICAgIGFhID0gc2NvcmUoYSk7XHJcbiAgICB3aGlsZSAoKGMgPSBjLm5leHQpICE9PSBiKSB7XHJcbiAgICAgIGlmICgoY2EgPSBzY29yZShjKSkgPCBhYSkge1xyXG4gICAgICAgIGEgPSBjLCBhYSA9IGNhO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBiID0gYS5uZXh0O1xyXG4gIH1cclxuXHJcbiAgLy8gQ29tcHV0ZSB0aGUgZW5jbG9zaW5nIGNpcmNsZSBvZiB0aGUgZnJvbnQgY2hhaW4uXHJcbiAgYSA9IFtiLl9dLCBjID0gYjsgd2hpbGUgKChjID0gYy5uZXh0KSAhPT0gYikgYS5wdXNoKGMuXyk7IGMgPSBlbmNsb3NlKGEpO1xyXG5cclxuICAvLyBUcmFuc2xhdGUgdGhlIGNpcmNsZXMgdG8gcHV0IHRoZSBlbmNsb3NpbmcgY2lyY2xlIGFyb3VuZCB0aGUgb3JpZ2luLlxyXG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIGEgPSBjaXJjbGVzW2ldLCBhLnggLT0gYy54LCBhLnkgLT0gYy55O1xyXG5cclxuICByZXR1cm4gYy5yO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzaWJsaW5ncyhjaXJjbGVzKSB7XHJcbiAgcGFja0VuY2xvc2UoY2lyY2xlcyk7XHJcbiAgcmV0dXJuIGNpcmNsZXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG9wdGlvbmFsKGYpIHtcclxuICByZXR1cm4gZiA9PSBudWxsID8gbnVsbCA6IHJlcXVpcmVkKGYpO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZXF1aXJlZChmKSB7XHJcbiAgaWYgKHR5cGVvZiBmICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcjtcclxuICByZXR1cm4gZjtcclxufVxyXG5cclxuZnVuY3Rpb24gY29uc3RhbnRaZXJvKCkge1xyXG4gIHJldHVybiAwO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb25zdGFudCQ5KHgpIHtcclxuICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4geDtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBkZWZhdWx0UmFkaXVzJDEoZCkge1xyXG4gIHJldHVybiBNYXRoLnNxcnQoZC52YWx1ZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluZGV4JDIoKSB7XHJcbiAgdmFyIHJhZGl1cyA9IG51bGwsXHJcbiAgICAgIGR4ID0gMSxcclxuICAgICAgZHkgPSAxLFxyXG4gICAgICBwYWRkaW5nID0gY29uc3RhbnRaZXJvO1xyXG5cclxuICBmdW5jdGlvbiBwYWNrKHJvb3QpIHtcclxuICAgIHJvb3QueCA9IGR4IC8gMiwgcm9vdC55ID0gZHkgLyAyO1xyXG4gICAgaWYgKHJhZGl1cykge1xyXG4gICAgICByb290LmVhY2hCZWZvcmUocmFkaXVzTGVhZihyYWRpdXMpKVxyXG4gICAgICAgICAgLmVhY2hBZnRlcihwYWNrQ2hpbGRyZW4ocGFkZGluZywgMC41KSlcclxuICAgICAgICAgIC5lYWNoQmVmb3JlKHRyYW5zbGF0ZUNoaWxkKDEpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJvb3QuZWFjaEJlZm9yZShyYWRpdXNMZWFmKGRlZmF1bHRSYWRpdXMkMSkpXHJcbiAgICAgICAgICAuZWFjaEFmdGVyKHBhY2tDaGlsZHJlbihjb25zdGFudFplcm8sIDEpKVxyXG4gICAgICAgICAgLmVhY2hBZnRlcihwYWNrQ2hpbGRyZW4ocGFkZGluZywgcm9vdC5yIC8gTWF0aC5taW4oZHgsIGR5KSkpXHJcbiAgICAgICAgICAuZWFjaEJlZm9yZSh0cmFuc2xhdGVDaGlsZChNYXRoLm1pbihkeCwgZHkpIC8gKDIgKiByb290LnIpKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcm9vdDtcclxuICB9XHJcblxyXG4gIHBhY2sucmFkaXVzID0gZnVuY3Rpb24oeCkge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFkaXVzID0gb3B0aW9uYWwoeCksIHBhY2spIDogcmFkaXVzO1xyXG4gIH07XHJcblxyXG4gIHBhY2suc2l6ZSA9IGZ1bmN0aW9uKHgpIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGR4ID0gK3hbMF0sIGR5ID0gK3hbMV0sIHBhY2spIDogW2R4LCBkeV07XHJcbiAgfTtcclxuXHJcbiAgcGFjay5wYWRkaW5nID0gZnVuY3Rpb24oeCkge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZyA9IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4IDogY29uc3RhbnQkOSgreCksIHBhY2spIDogcGFkZGluZztcclxuICB9O1xyXG5cclxuICByZXR1cm4gcGFjaztcclxufVxyXG5cclxuZnVuY3Rpb24gcmFkaXVzTGVhZihyYWRpdXMpIHtcclxuICByZXR1cm4gZnVuY3Rpb24obm9kZSkge1xyXG4gICAgaWYgKCFub2RlLmNoaWxkcmVuKSB7XHJcbiAgICAgIG5vZGUuciA9IE1hdGgubWF4KDAsICtyYWRpdXMobm9kZSkgfHwgMCk7XHJcbiAgICB9XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gcGFja0NoaWxkcmVuKHBhZGRpbmcsIGspIHtcclxuICByZXR1cm4gZnVuY3Rpb24obm9kZSkge1xyXG4gICAgaWYgKGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbikge1xyXG4gICAgICB2YXIgY2hpbGRyZW4sXHJcbiAgICAgICAgICBpLFxyXG4gICAgICAgICAgbiA9IGNoaWxkcmVuLmxlbmd0aCxcclxuICAgICAgICAgIHIgPSBwYWRkaW5nKG5vZGUpICogayB8fCAwLFxyXG4gICAgICAgICAgZTtcclxuXHJcbiAgICAgIGlmIChyKSBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSBjaGlsZHJlbltpXS5yICs9IHI7XHJcbiAgICAgIGUgPSBwYWNrRW5jbG9zZShjaGlsZHJlbik7XHJcbiAgICAgIGlmIChyKSBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSBjaGlsZHJlbltpXS5yIC09IHI7XHJcbiAgICAgIG5vZGUuciA9IGUgKyByO1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRyYW5zbGF0ZUNoaWxkKGspIHtcclxuICByZXR1cm4gZnVuY3Rpb24obm9kZSkge1xyXG4gICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50O1xyXG4gICAgbm9kZS5yICo9IGs7XHJcbiAgICBpZiAocGFyZW50KSB7XHJcbiAgICAgIG5vZGUueCA9IHBhcmVudC54ICsgayAqIG5vZGUueDtcclxuICAgICAgbm9kZS55ID0gcGFyZW50LnkgKyBrICogbm9kZS55O1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJvdW5kTm9kZShub2RlKSB7XHJcbiAgbm9kZS54MCA9IE1hdGgucm91bmQobm9kZS54MCk7XHJcbiAgbm9kZS55MCA9IE1hdGgucm91bmQobm9kZS55MCk7XHJcbiAgbm9kZS54MSA9IE1hdGgucm91bmQobm9kZS54MSk7XHJcbiAgbm9kZS55MSA9IE1hdGgucm91bmQobm9kZS55MSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRyZWVtYXBEaWNlKHBhcmVudCwgeDAsIHkwLCB4MSwgeTEpIHtcclxuICB2YXIgbm9kZXMgPSBwYXJlbnQuY2hpbGRyZW4sXHJcbiAgICAgIG5vZGUsXHJcbiAgICAgIGkgPSAtMSxcclxuICAgICAgbiA9IG5vZGVzLmxlbmd0aCxcclxuICAgICAgayA9IHBhcmVudC52YWx1ZSAmJiAoeDEgLSB4MCkgLyBwYXJlbnQudmFsdWU7XHJcblxyXG4gIHdoaWxlICgrK2kgPCBuKSB7XHJcbiAgICBub2RlID0gbm9kZXNbaV0sIG5vZGUueTAgPSB5MCwgbm9kZS55MSA9IHkxO1xyXG4gICAgbm9kZS54MCA9IHgwLCBub2RlLngxID0geDAgKz0gbm9kZS52YWx1ZSAqIGs7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBwYXJ0aXRpb24oKSB7XHJcbiAgdmFyIGR4ID0gMSxcclxuICAgICAgZHkgPSAxLFxyXG4gICAgICBwYWRkaW5nID0gMCxcclxuICAgICAgcm91bmQgPSBmYWxzZTtcclxuXHJcbiAgZnVuY3Rpb24gcGFydGl0aW9uKHJvb3QpIHtcclxuICAgIHZhciBuID0gcm9vdC5oZWlnaHQgKyAxO1xyXG4gICAgcm9vdC54MCA9XHJcbiAgICByb290LnkwID0gcGFkZGluZztcclxuICAgIHJvb3QueDEgPSBkeDtcclxuICAgIHJvb3QueTEgPSBkeSAvIG47XHJcbiAgICByb290LmVhY2hCZWZvcmUocG9zaXRpb25Ob2RlKGR5LCBuKSk7XHJcbiAgICBpZiAocm91bmQpIHJvb3QuZWFjaEJlZm9yZShyb3VuZE5vZGUpO1xyXG4gICAgcmV0dXJuIHJvb3Q7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBwb3NpdGlvbk5vZGUoZHksIG4pIHtcclxuICAgIHJldHVybiBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgdHJlZW1hcERpY2Uobm9kZSwgbm9kZS54MCwgZHkgKiAobm9kZS5kZXB0aCArIDEpIC8gbiwgbm9kZS54MSwgZHkgKiAobm9kZS5kZXB0aCArIDIpIC8gbik7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHgwID0gbm9kZS54MCxcclxuICAgICAgICAgIHkwID0gbm9kZS55MCxcclxuICAgICAgICAgIHgxID0gbm9kZS54MSAtIHBhZGRpbmcsXHJcbiAgICAgICAgICB5MSA9IG5vZGUueTEgLSBwYWRkaW5nO1xyXG4gICAgICBpZiAoeDEgPCB4MCkgeDAgPSB4MSA9ICh4MCArIHgxKSAvIDI7XHJcbiAgICAgIGlmICh5MSA8IHkwKSB5MCA9IHkxID0gKHkwICsgeTEpIC8gMjtcclxuICAgICAgbm9kZS54MCA9IHgwO1xyXG4gICAgICBub2RlLnkwID0geTA7XHJcbiAgICAgIG5vZGUueDEgPSB4MTtcclxuICAgICAgbm9kZS55MSA9IHkxO1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHBhcnRpdGlvbi5yb3VuZCA9IGZ1bmN0aW9uKHgpIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJvdW5kID0gISF4LCBwYXJ0aXRpb24pIDogcm91bmQ7XHJcbiAgfTtcclxuXHJcbiAgcGFydGl0aW9uLnNpemUgPSBmdW5jdGlvbih4KSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkeCA9ICt4WzBdLCBkeSA9ICt4WzFdLCBwYXJ0aXRpb24pIDogW2R4LCBkeV07XHJcbiAgfTtcclxuXHJcbiAgcGFydGl0aW9uLnBhZGRpbmcgPSBmdW5jdGlvbih4KSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRkaW5nID0gK3gsIHBhcnRpdGlvbikgOiBwYWRkaW5nO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBwYXJ0aXRpb247XHJcbn1cclxuXHJcbnZhciBrZXlQcmVmaXgkMSA9IFwiJFwiLCAvLyBQcm90ZWN0IGFnYWluc3Qga2V5cyBsaWtlIOKAnF9fcHJvdG9fX+KAnS5cclxuICAgIHByZXJvb3QgPSB7ZGVwdGg6IC0xfSxcclxuICAgIGFtYmlndW91cyA9IHt9O1xyXG5cclxuZnVuY3Rpb24gZGVmYXVsdElkKGQpIHtcclxuICByZXR1cm4gZC5pZDtcclxufVxyXG5cclxuZnVuY3Rpb24gZGVmYXVsdFBhcmVudElkKGQpIHtcclxuICByZXR1cm4gZC5wYXJlbnRJZDtcclxufVxyXG5cclxuZnVuY3Rpb24gc3RyYXRpZnkoKSB7XHJcbiAgdmFyIGlkID0gZGVmYXVsdElkLFxyXG4gICAgICBwYXJlbnRJZCA9IGRlZmF1bHRQYXJlbnRJZDtcclxuXHJcbiAgZnVuY3Rpb24gc3RyYXRpZnkoZGF0YSkge1xyXG4gICAgdmFyIGQsXHJcbiAgICAgICAgaSxcclxuICAgICAgICBuID0gZGF0YS5sZW5ndGgsXHJcbiAgICAgICAgcm9vdCxcclxuICAgICAgICBwYXJlbnQsXHJcbiAgICAgICAgbm9kZSxcclxuICAgICAgICBub2RlcyA9IG5ldyBBcnJheShuKSxcclxuICAgICAgICBub2RlSWQsXHJcbiAgICAgICAgbm9kZUtleSxcclxuICAgICAgICBub2RlQnlLZXkgPSB7fTtcclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgIGQgPSBkYXRhW2ldLCBub2RlID0gbm9kZXNbaV0gPSBuZXcgTm9kZShkKTtcclxuICAgICAgaWYgKChub2RlSWQgPSBpZChkLCBpLCBkYXRhKSkgIT0gbnVsbCAmJiAobm9kZUlkICs9IFwiXCIpKSB7XHJcbiAgICAgICAgbm9kZUtleSA9IGtleVByZWZpeCQxICsgKG5vZGUuaWQgPSBub2RlSWQpO1xyXG4gICAgICAgIG5vZGVCeUtleVtub2RlS2V5XSA9IG5vZGVLZXkgaW4gbm9kZUJ5S2V5ID8gYW1iaWd1b3VzIDogbm9kZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcclxuICAgICAgbm9kZSA9IG5vZGVzW2ldLCBub2RlSWQgPSBwYXJlbnRJZChkYXRhW2ldLCBpLCBkYXRhKTtcclxuICAgICAgaWYgKG5vZGVJZCA9PSBudWxsIHx8ICEobm9kZUlkICs9IFwiXCIpKSB7XHJcbiAgICAgICAgaWYgKHJvb3QpIHRocm93IG5ldyBFcnJvcihcIm11bHRpcGxlIHJvb3RzXCIpO1xyXG4gICAgICAgIHJvb3QgPSBub2RlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHBhcmVudCA9IG5vZGVCeUtleVtrZXlQcmVmaXgkMSArIG5vZGVJZF07XHJcbiAgICAgICAgaWYgKCFwYXJlbnQpIHRocm93IG5ldyBFcnJvcihcIm1pc3Npbmc6IFwiICsgbm9kZUlkKTtcclxuICAgICAgICBpZiAocGFyZW50ID09PSBhbWJpZ3VvdXMpIHRocm93IG5ldyBFcnJvcihcImFtYmlndW91czogXCIgKyBub2RlSWQpO1xyXG4gICAgICAgIGlmIChwYXJlbnQuY2hpbGRyZW4pIHBhcmVudC5jaGlsZHJlbi5wdXNoKG5vZGUpO1xyXG4gICAgICAgIGVsc2UgcGFyZW50LmNoaWxkcmVuID0gW25vZGVdO1xyXG4gICAgICAgIG5vZGUucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFyb290KSB0aHJvdyBuZXcgRXJyb3IoXCJubyByb290XCIpO1xyXG4gICAgcm9vdC5wYXJlbnQgPSBwcmVyb290O1xyXG4gICAgcm9vdC5lYWNoQmVmb3JlKGZ1bmN0aW9uKG5vZGUpIHsgbm9kZS5kZXB0aCA9IG5vZGUucGFyZW50LmRlcHRoICsgMTsgLS1uOyB9KS5lYWNoQmVmb3JlKGNvbXB1dGVIZWlnaHQpO1xyXG4gICAgcm9vdC5wYXJlbnQgPSBudWxsO1xyXG4gICAgaWYgKG4gPiAwKSB0aHJvdyBuZXcgRXJyb3IoXCJjeWNsZVwiKTtcclxuXHJcbiAgICByZXR1cm4gcm9vdDtcclxuICB9XHJcblxyXG4gIHN0cmF0aWZ5LmlkID0gZnVuY3Rpb24oeCkge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaWQgPSByZXF1aXJlZCh4KSwgc3RyYXRpZnkpIDogaWQ7XHJcbiAgfTtcclxuXHJcbiAgc3RyYXRpZnkucGFyZW50SWQgPSBmdW5jdGlvbih4KSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYXJlbnRJZCA9IHJlcXVpcmVkKHgpLCBzdHJhdGlmeSkgOiBwYXJlbnRJZDtcclxuICB9O1xyXG5cclxuICByZXR1cm4gc3RyYXRpZnk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlZmF1bHRTZXBhcmF0aW9uJDEoYSwgYikge1xyXG4gIHJldHVybiBhLnBhcmVudCA9PT0gYi5wYXJlbnQgPyAxIDogMjtcclxufVxyXG5cclxuLy8gZnVuY3Rpb24gcmFkaWFsU2VwYXJhdGlvbihhLCBiKSB7XHJcbi8vICAgcmV0dXJuIChhLnBhcmVudCA9PT0gYi5wYXJlbnQgPyAxIDogMikgLyBhLmRlcHRoO1xyXG4vLyB9XHJcblxyXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gdHJhdmVyc2UgdGhlIGxlZnQgY29udG91ciBvZiBhIHN1YnRyZWUgKG9yXHJcbi8vIHN1YmZvcmVzdCkuIEl0IHJldHVybnMgdGhlIHN1Y2Nlc3NvciBvZiB2IG9uIHRoaXMgY29udG91ci4gVGhpcyBzdWNjZXNzb3IgaXNcclxuLy8gZWl0aGVyIGdpdmVuIGJ5IHRoZSBsZWZ0bW9zdCBjaGlsZCBvZiB2IG9yIGJ5IHRoZSB0aHJlYWQgb2Ygdi4gVGhlIGZ1bmN0aW9uXHJcbi8vIHJldHVybnMgbnVsbCBpZiBhbmQgb25seSBpZiB2IGlzIG9uIHRoZSBoaWdoZXN0IGxldmVsIG9mIGl0cyBzdWJ0cmVlLlxyXG5mdW5jdGlvbiBuZXh0TGVmdCh2KSB7XHJcbiAgdmFyIGNoaWxkcmVuID0gdi5jaGlsZHJlbjtcclxuICByZXR1cm4gY2hpbGRyZW4gPyBjaGlsZHJlblswXSA6IHYudDtcclxufVxyXG5cclxuLy8gVGhpcyBmdW5jdGlvbiB3b3JrcyBhbmFsb2dvdXNseSB0byBuZXh0TGVmdC5cclxuZnVuY3Rpb24gbmV4dFJpZ2h0KHYpIHtcclxuICB2YXIgY2hpbGRyZW4gPSB2LmNoaWxkcmVuO1xyXG4gIHJldHVybiBjaGlsZHJlbiA/IGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdIDogdi50O1xyXG59XHJcblxyXG4vLyBTaGlmdHMgdGhlIGN1cnJlbnQgc3VidHJlZSByb290ZWQgYXQgdysuIFRoaXMgaXMgZG9uZSBieSBpbmNyZWFzaW5nXHJcbi8vIHByZWxpbSh3KykgYW5kIG1vZCh3KykgYnkgc2hpZnQuXHJcbmZ1bmN0aW9uIG1vdmVTdWJ0cmVlKHdtLCB3cCwgc2hpZnQpIHtcclxuICB2YXIgY2hhbmdlID0gc2hpZnQgLyAod3AuaSAtIHdtLmkpO1xyXG4gIHdwLmMgLT0gY2hhbmdlO1xyXG4gIHdwLnMgKz0gc2hpZnQ7XHJcbiAgd20uYyArPSBjaGFuZ2U7XHJcbiAgd3AueiArPSBzaGlmdDtcclxuICB3cC5tICs9IHNoaWZ0O1xyXG59XHJcblxyXG4vLyBBbGwgb3RoZXIgc2hpZnRzLCBhcHBsaWVkIHRvIHRoZSBzbWFsbGVyIHN1YnRyZWVzIGJldHdlZW4gdy0gYW5kIHcrLCBhcmVcclxuLy8gcGVyZm9ybWVkIGJ5IHRoaXMgZnVuY3Rpb24uIFRvIHByZXBhcmUgdGhlIHNoaWZ0cywgd2UgaGF2ZSB0byBhZGp1c3RcclxuLy8gY2hhbmdlKHcrKSwgc2hpZnQodyspLCBhbmQgY2hhbmdlKHctKS5cclxuZnVuY3Rpb24gZXhlY3V0ZVNoaWZ0cyh2KSB7XHJcbiAgdmFyIHNoaWZ0ID0gMCxcclxuICAgICAgY2hhbmdlID0gMCxcclxuICAgICAgY2hpbGRyZW4gPSB2LmNoaWxkcmVuLFxyXG4gICAgICBpID0gY2hpbGRyZW4ubGVuZ3RoLFxyXG4gICAgICB3O1xyXG4gIHdoaWxlICgtLWkgPj0gMCkge1xyXG4gICAgdyA9IGNoaWxkcmVuW2ldO1xyXG4gICAgdy56ICs9IHNoaWZ0O1xyXG4gICAgdy5tICs9IHNoaWZ0O1xyXG4gICAgc2hpZnQgKz0gdy5zICsgKGNoYW5nZSArPSB3LmMpO1xyXG4gIH1cclxufVxyXG5cclxuLy8gSWYgdmkt4oCZcyBhbmNlc3RvciBpcyBhIHNpYmxpbmcgb2YgdiwgcmV0dXJucyB2aS3igJlzIGFuY2VzdG9yLiBPdGhlcndpc2UsXHJcbi8vIHJldHVybnMgdGhlIHNwZWNpZmllZCAoZGVmYXVsdCkgYW5jZXN0b3IuXHJcbmZ1bmN0aW9uIG5leHRBbmNlc3Rvcih2aW0sIHYsIGFuY2VzdG9yKSB7XHJcbiAgcmV0dXJuIHZpbS5hLnBhcmVudCA9PT0gdi5wYXJlbnQgPyB2aW0uYSA6IGFuY2VzdG9yO1xyXG59XHJcblxyXG5mdW5jdGlvbiBUcmVlTm9kZShub2RlLCBpKSB7XHJcbiAgdGhpcy5fID0gbm9kZTtcclxuICB0aGlzLnBhcmVudCA9IG51bGw7XHJcbiAgdGhpcy5jaGlsZHJlbiA9IG51bGw7XHJcbiAgdGhpcy5BID0gbnVsbDsgLy8gZGVmYXVsdCBhbmNlc3RvclxyXG4gIHRoaXMuYSA9IHRoaXM7IC8vIGFuY2VzdG9yXHJcbiAgdGhpcy56ID0gMDsgLy8gcHJlbGltXHJcbiAgdGhpcy5tID0gMDsgLy8gbW9kXHJcbiAgdGhpcy5jID0gMDsgLy8gY2hhbmdlXHJcbiAgdGhpcy5zID0gMDsgLy8gc2hpZnRcclxuICB0aGlzLnQgPSBudWxsOyAvLyB0aHJlYWRcclxuICB0aGlzLmkgPSBpOyAvLyBudW1iZXJcclxufVxyXG5cclxuVHJlZU5vZGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShOb2RlLnByb3RvdHlwZSk7XHJcblxyXG5mdW5jdGlvbiB0cmVlUm9vdChyb290KSB7XHJcbiAgdmFyIHRyZWUgPSBuZXcgVHJlZU5vZGUocm9vdCwgMCksXHJcbiAgICAgIG5vZGUsXHJcbiAgICAgIG5vZGVzID0gW3RyZWVdLFxyXG4gICAgICBjaGlsZCxcclxuICAgICAgY2hpbGRyZW4sXHJcbiAgICAgIGksXHJcbiAgICAgIG47XHJcblxyXG4gIHdoaWxlIChub2RlID0gbm9kZXMucG9wKCkpIHtcclxuICAgIGlmIChjaGlsZHJlbiA9IG5vZGUuXy5jaGlsZHJlbikge1xyXG4gICAgICBub2RlLmNoaWxkcmVuID0gbmV3IEFycmF5KG4gPSBjaGlsZHJlbi5sZW5ndGgpO1xyXG4gICAgICBmb3IgKGkgPSBuIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuICAgICAgICBub2Rlcy5wdXNoKGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXSA9IG5ldyBUcmVlTm9kZShjaGlsZHJlbltpXSwgaSkpO1xyXG4gICAgICAgIGNoaWxkLnBhcmVudCA9IG5vZGU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gICh0cmVlLnBhcmVudCA9IG5ldyBUcmVlTm9kZShudWxsLCAwKSkuY2hpbGRyZW4gPSBbdHJlZV07XHJcbiAgcmV0dXJuIHRyZWU7XHJcbn1cclxuXHJcbi8vIE5vZGUtbGluayB0cmVlIGRpYWdyYW0gdXNpbmcgdGhlIFJlaW5nb2xkLVRpbGZvcmQgXCJ0aWR5XCIgYWxnb3JpdGhtXHJcbmZ1bmN0aW9uIHRyZWUoKSB7XHJcbiAgdmFyIHNlcGFyYXRpb24gPSBkZWZhdWx0U2VwYXJhdGlvbiQxLFxyXG4gICAgICBkeCA9IDEsXHJcbiAgICAgIGR5ID0gMSxcclxuICAgICAgbm9kZVNpemUgPSBudWxsO1xyXG5cclxuICBmdW5jdGlvbiB0cmVlKHJvb3QpIHtcclxuICAgIHZhciB0ID0gdHJlZVJvb3Qocm9vdCk7XHJcblxyXG4gICAgLy8gQ29tcHV0ZSB0aGUgbGF5b3V0IHVzaW5nIEJ1Y2hoZWltIGV0IGFsLuKAmXMgYWxnb3JpdGhtLlxyXG4gICAgdC5lYWNoQWZ0ZXIoZmlyc3RXYWxrKSwgdC5wYXJlbnQubSA9IC10Lno7XHJcbiAgICB0LmVhY2hCZWZvcmUoc2Vjb25kV2Fsayk7XHJcblxyXG4gICAgLy8gSWYgYSBmaXhlZCBub2RlIHNpemUgaXMgc3BlY2lmaWVkLCBzY2FsZSB4IGFuZCB5LlxyXG4gICAgaWYgKG5vZGVTaXplKSByb290LmVhY2hCZWZvcmUoc2l6ZU5vZGUpO1xyXG5cclxuICAgIC8vIElmIGEgZml4ZWQgdHJlZSBzaXplIGlzIHNwZWNpZmllZCwgc2NhbGUgeCBhbmQgeSBiYXNlZCBvbiB0aGUgZXh0ZW50LlxyXG4gICAgLy8gQ29tcHV0ZSB0aGUgbGVmdC1tb3N0LCByaWdodC1tb3N0LCBhbmQgZGVwdGgtbW9zdCBub2RlcyBmb3IgZXh0ZW50cy5cclxuICAgIGVsc2Uge1xyXG4gICAgICB2YXIgbGVmdCA9IHJvb3QsXHJcbiAgICAgICAgICByaWdodCA9IHJvb3QsXHJcbiAgICAgICAgICBib3R0b20gPSByb290O1xyXG4gICAgICByb290LmVhY2hCZWZvcmUoZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgIGlmIChub2RlLnggPCBsZWZ0LngpIGxlZnQgPSBub2RlO1xyXG4gICAgICAgIGlmIChub2RlLnggPiByaWdodC54KSByaWdodCA9IG5vZGU7XHJcbiAgICAgICAgaWYgKG5vZGUuZGVwdGggPiBib3R0b20uZGVwdGgpIGJvdHRvbSA9IG5vZGU7XHJcbiAgICAgIH0pO1xyXG4gICAgICB2YXIgcyA9IGxlZnQgPT09IHJpZ2h0ID8gMSA6IHNlcGFyYXRpb24obGVmdCwgcmlnaHQpIC8gMixcclxuICAgICAgICAgIHR4ID0gcyAtIGxlZnQueCxcclxuICAgICAgICAgIGt4ID0gZHggLyAocmlnaHQueCArIHMgKyB0eCksXHJcbiAgICAgICAgICBreSA9IGR5IC8gKGJvdHRvbS5kZXB0aCB8fCAxKTtcclxuICAgICAgcm9vdC5lYWNoQmVmb3JlKGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICBub2RlLnggPSAobm9kZS54ICsgdHgpICoga3g7XHJcbiAgICAgICAgbm9kZS55ID0gbm9kZS5kZXB0aCAqIGt5O1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcm9vdDtcclxuICB9XHJcblxyXG4gIC8vIENvbXB1dGVzIGEgcHJlbGltaW5hcnkgeC1jb29yZGluYXRlIGZvciB2LiBCZWZvcmUgdGhhdCwgRklSU1QgV0FMSyBpc1xyXG4gIC8vIGFwcGxpZWQgcmVjdXJzaXZlbHkgdG8gdGhlIGNoaWxkcmVuIG9mIHYsIGFzIHdlbGwgYXMgdGhlIGZ1bmN0aW9uXHJcbiAgLy8gQVBQT1JUSU9OLiBBZnRlciBzcGFjaW5nIG91dCB0aGUgY2hpbGRyZW4gYnkgY2FsbGluZyBFWEVDVVRFIFNISUZUUywgdGhlXHJcbiAgLy8gbm9kZSB2IGlzIHBsYWNlZCB0byB0aGUgbWlkcG9pbnQgb2YgaXRzIG91dGVybW9zdCBjaGlsZHJlbi5cclxuICBmdW5jdGlvbiBmaXJzdFdhbGsodikge1xyXG4gICAgdmFyIGNoaWxkcmVuID0gdi5jaGlsZHJlbixcclxuICAgICAgICBzaWJsaW5ncyA9IHYucGFyZW50LmNoaWxkcmVuLFxyXG4gICAgICAgIHcgPSB2LmkgPyBzaWJsaW5nc1t2LmkgLSAxXSA6IG51bGw7XHJcbiAgICBpZiAoY2hpbGRyZW4pIHtcclxuICAgICAgZXhlY3V0ZVNoaWZ0cyh2KTtcclxuICAgICAgdmFyIG1pZHBvaW50ID0gKGNoaWxkcmVuWzBdLnogKyBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXS56KSAvIDI7XHJcbiAgICAgIGlmICh3KSB7XHJcbiAgICAgICAgdi56ID0gdy56ICsgc2VwYXJhdGlvbih2Ll8sIHcuXyk7XHJcbiAgICAgICAgdi5tID0gdi56IC0gbWlkcG9pbnQ7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdi56ID0gbWlkcG9pbnQ7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAodykge1xyXG4gICAgICB2LnogPSB3LnogKyBzZXBhcmF0aW9uKHYuXywgdy5fKTtcclxuICAgIH1cclxuICAgIHYucGFyZW50LkEgPSBhcHBvcnRpb24odiwgdywgdi5wYXJlbnQuQSB8fCBzaWJsaW5nc1swXSk7XHJcbiAgfVxyXG5cclxuICAvLyBDb21wdXRlcyBhbGwgcmVhbCB4LWNvb3JkaW5hdGVzIGJ5IHN1bW1pbmcgdXAgdGhlIG1vZGlmaWVycyByZWN1cnNpdmVseS5cclxuICBmdW5jdGlvbiBzZWNvbmRXYWxrKHYpIHtcclxuICAgIHYuXy54ID0gdi56ICsgdi5wYXJlbnQubTtcclxuICAgIHYubSArPSB2LnBhcmVudC5tO1xyXG4gIH1cclxuXHJcbiAgLy8gVGhlIGNvcmUgb2YgdGhlIGFsZ29yaXRobS4gSGVyZSwgYSBuZXcgc3VidHJlZSBpcyBjb21iaW5lZCB3aXRoIHRoZVxyXG4gIC8vIHByZXZpb3VzIHN1YnRyZWVzLiBUaHJlYWRzIGFyZSB1c2VkIHRvIHRyYXZlcnNlIHRoZSBpbnNpZGUgYW5kIG91dHNpZGVcclxuICAvLyBjb250b3VycyBvZiB0aGUgbGVmdCBhbmQgcmlnaHQgc3VidHJlZSB1cCB0byB0aGUgaGlnaGVzdCBjb21tb24gbGV2ZWwuIFRoZVxyXG4gIC8vIHZlcnRpY2VzIHVzZWQgZm9yIHRoZSB0cmF2ZXJzYWxzIGFyZSB2aSssIHZpLSwgdm8tLCBhbmQgdm8rLCB3aGVyZSB0aGVcclxuICAvLyBzdXBlcnNjcmlwdCBvIG1lYW5zIG91dHNpZGUgYW5kIGkgbWVhbnMgaW5zaWRlLCB0aGUgc3Vic2NyaXB0IC0gbWVhbnMgbGVmdFxyXG4gIC8vIHN1YnRyZWUgYW5kICsgbWVhbnMgcmlnaHQgc3VidHJlZS4gRm9yIHN1bW1pbmcgdXAgdGhlIG1vZGlmaWVycyBhbG9uZyB0aGVcclxuICAvLyBjb250b3VyLCB3ZSB1c2UgcmVzcGVjdGl2ZSB2YXJpYWJsZXMgc2krLCBzaS0sIHNvLSwgYW5kIHNvKy4gV2hlbmV2ZXIgdHdvXHJcbiAgLy8gbm9kZXMgb2YgdGhlIGluc2lkZSBjb250b3VycyBjb25mbGljdCwgd2UgY29tcHV0ZSB0aGUgbGVmdCBvbmUgb2YgdGhlXHJcbiAgLy8gZ3JlYXRlc3QgdW5jb21tb24gYW5jZXN0b3JzIHVzaW5nIHRoZSBmdW5jdGlvbiBBTkNFU1RPUiBhbmQgY2FsbCBNT1ZFXHJcbiAgLy8gU1VCVFJFRSB0byBzaGlmdCB0aGUgc3VidHJlZSBhbmQgcHJlcGFyZSB0aGUgc2hpZnRzIG9mIHNtYWxsZXIgc3VidHJlZXMuXHJcbiAgLy8gRmluYWxseSwgd2UgYWRkIGEgbmV3IHRocmVhZCAoaWYgbmVjZXNzYXJ5KS5cclxuICBmdW5jdGlvbiBhcHBvcnRpb24odiwgdywgYW5jZXN0b3IpIHtcclxuICAgIGlmICh3KSB7XHJcbiAgICAgIHZhciB2aXAgPSB2LFxyXG4gICAgICAgICAgdm9wID0gdixcclxuICAgICAgICAgIHZpbSA9IHcsXHJcbiAgICAgICAgICB2b20gPSB2aXAucGFyZW50LmNoaWxkcmVuWzBdLFxyXG4gICAgICAgICAgc2lwID0gdmlwLm0sXHJcbiAgICAgICAgICBzb3AgPSB2b3AubSxcclxuICAgICAgICAgIHNpbSA9IHZpbS5tLFxyXG4gICAgICAgICAgc29tID0gdm9tLm0sXHJcbiAgICAgICAgICBzaGlmdDtcclxuICAgICAgd2hpbGUgKHZpbSA9IG5leHRSaWdodCh2aW0pLCB2aXAgPSBuZXh0TGVmdCh2aXApLCB2aW0gJiYgdmlwKSB7XHJcbiAgICAgICAgdm9tID0gbmV4dExlZnQodm9tKTtcclxuICAgICAgICB2b3AgPSBuZXh0UmlnaHQodm9wKTtcclxuICAgICAgICB2b3AuYSA9IHY7XHJcbiAgICAgICAgc2hpZnQgPSB2aW0ueiArIHNpbSAtIHZpcC56IC0gc2lwICsgc2VwYXJhdGlvbih2aW0uXywgdmlwLl8pO1xyXG4gICAgICAgIGlmIChzaGlmdCA+IDApIHtcclxuICAgICAgICAgIG1vdmVTdWJ0cmVlKG5leHRBbmNlc3Rvcih2aW0sIHYsIGFuY2VzdG9yKSwgdiwgc2hpZnQpO1xyXG4gICAgICAgICAgc2lwICs9IHNoaWZ0O1xyXG4gICAgICAgICAgc29wICs9IHNoaWZ0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBzaW0gKz0gdmltLm07XHJcbiAgICAgICAgc2lwICs9IHZpcC5tO1xyXG4gICAgICAgIHNvbSArPSB2b20ubTtcclxuICAgICAgICBzb3AgKz0gdm9wLm07XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHZpbSAmJiAhbmV4dFJpZ2h0KHZvcCkpIHtcclxuICAgICAgICB2b3AudCA9IHZpbTtcclxuICAgICAgICB2b3AubSArPSBzaW0gLSBzb3A7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHZpcCAmJiAhbmV4dExlZnQodm9tKSkge1xyXG4gICAgICAgIHZvbS50ID0gdmlwO1xyXG4gICAgICAgIHZvbS5tICs9IHNpcCAtIHNvbTtcclxuICAgICAgICBhbmNlc3RvciA9IHY7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBhbmNlc3RvcjtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHNpemVOb2RlKG5vZGUpIHtcclxuICAgIG5vZGUueCAqPSBkeDtcclxuICAgIG5vZGUueSA9IG5vZGUuZGVwdGggKiBkeTtcclxuICB9XHJcblxyXG4gIHRyZWUuc2VwYXJhdGlvbiA9IGZ1bmN0aW9uKHgpIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNlcGFyYXRpb24gPSB4LCB0cmVlKSA6IHNlcGFyYXRpb247XHJcbiAgfTtcclxuXHJcbiAgdHJlZS5zaXplID0gZnVuY3Rpb24oeCkge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobm9kZVNpemUgPSBmYWxzZSwgZHggPSAreFswXSwgZHkgPSAreFsxXSwgdHJlZSkgOiAobm9kZVNpemUgPyBudWxsIDogW2R4LCBkeV0pO1xyXG4gIH07XHJcblxyXG4gIHRyZWUubm9kZVNpemUgPSBmdW5jdGlvbih4KSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChub2RlU2l6ZSA9IHRydWUsIGR4ID0gK3hbMF0sIGR5ID0gK3hbMV0sIHRyZWUpIDogKG5vZGVTaXplID8gW2R4LCBkeV0gOiBudWxsKTtcclxuICB9O1xyXG5cclxuICByZXR1cm4gdHJlZTtcclxufVxyXG5cclxuZnVuY3Rpb24gdHJlZW1hcFNsaWNlKHBhcmVudCwgeDAsIHkwLCB4MSwgeTEpIHtcclxuICB2YXIgbm9kZXMgPSBwYXJlbnQuY2hpbGRyZW4sXHJcbiAgICAgIG5vZGUsXHJcbiAgICAgIGkgPSAtMSxcclxuICAgICAgbiA9IG5vZGVzLmxlbmd0aCxcclxuICAgICAgayA9IHBhcmVudC52YWx1ZSAmJiAoeTEgLSB5MCkgLyBwYXJlbnQudmFsdWU7XHJcblxyXG4gIHdoaWxlICgrK2kgPCBuKSB7XHJcbiAgICBub2RlID0gbm9kZXNbaV0sIG5vZGUueDAgPSB4MCwgbm9kZS54MSA9IHgxO1xyXG4gICAgbm9kZS55MCA9IHkwLCBub2RlLnkxID0geTAgKz0gbm9kZS52YWx1ZSAqIGs7XHJcbiAgfVxyXG59XHJcblxyXG52YXIgcGhpID0gKDEgKyBNYXRoLnNxcnQoNSkpIC8gMjtcclxuXHJcbmZ1bmN0aW9uIHNxdWFyaWZ5UmF0aW8ocmF0aW8sIHBhcmVudCwgeDAsIHkwLCB4MSwgeTEpIHtcclxuICB2YXIgcm93cyA9IFtdLFxyXG4gICAgICBub2RlcyA9IHBhcmVudC5jaGlsZHJlbixcclxuICAgICAgcm93LFxyXG4gICAgICBub2RlVmFsdWUsXHJcbiAgICAgIGkwID0gMCxcclxuICAgICAgaTEgPSAwLFxyXG4gICAgICBuID0gbm9kZXMubGVuZ3RoLFxyXG4gICAgICBkeCwgZHksXHJcbiAgICAgIHZhbHVlID0gcGFyZW50LnZhbHVlLFxyXG4gICAgICBzdW1WYWx1ZSxcclxuICAgICAgbWluVmFsdWUsXHJcbiAgICAgIG1heFZhbHVlLFxyXG4gICAgICBuZXdSYXRpbyxcclxuICAgICAgbWluUmF0aW8sXHJcbiAgICAgIGFscGhhLFxyXG4gICAgICBiZXRhO1xyXG5cclxuICB3aGlsZSAoaTAgPCBuKSB7XHJcbiAgICBkeCA9IHgxIC0geDAsIGR5ID0geTEgLSB5MDtcclxuXHJcbiAgICAvLyBGaW5kIHRoZSBuZXh0IG5vbi1lbXB0eSBub2RlLlxyXG4gICAgZG8gc3VtVmFsdWUgPSBub2Rlc1tpMSsrXS52YWx1ZTsgd2hpbGUgKCFzdW1WYWx1ZSAmJiBpMSA8IG4pO1xyXG4gICAgbWluVmFsdWUgPSBtYXhWYWx1ZSA9IHN1bVZhbHVlO1xyXG4gICAgYWxwaGEgPSBNYXRoLm1heChkeSAvIGR4LCBkeCAvIGR5KSAvICh2YWx1ZSAqIHJhdGlvKTtcclxuICAgIGJldGEgPSBzdW1WYWx1ZSAqIHN1bVZhbHVlICogYWxwaGE7XHJcbiAgICBtaW5SYXRpbyA9IE1hdGgubWF4KG1heFZhbHVlIC8gYmV0YSwgYmV0YSAvIG1pblZhbHVlKTtcclxuXHJcbiAgICAvLyBLZWVwIGFkZGluZyBub2RlcyB3aGlsZSB0aGUgYXNwZWN0IHJhdGlvIG1haW50YWlucyBvciBpbXByb3Zlcy5cclxuICAgIGZvciAoOyBpMSA8IG47ICsraTEpIHtcclxuICAgICAgc3VtVmFsdWUgKz0gbm9kZVZhbHVlID0gbm9kZXNbaTFdLnZhbHVlO1xyXG4gICAgICBpZiAobm9kZVZhbHVlIDwgbWluVmFsdWUpIG1pblZhbHVlID0gbm9kZVZhbHVlO1xyXG4gICAgICBpZiAobm9kZVZhbHVlID4gbWF4VmFsdWUpIG1heFZhbHVlID0gbm9kZVZhbHVlO1xyXG4gICAgICBiZXRhID0gc3VtVmFsdWUgKiBzdW1WYWx1ZSAqIGFscGhhO1xyXG4gICAgICBuZXdSYXRpbyA9IE1hdGgubWF4KG1heFZhbHVlIC8gYmV0YSwgYmV0YSAvIG1pblZhbHVlKTtcclxuICAgICAgaWYgKG5ld1JhdGlvID4gbWluUmF0aW8pIHsgc3VtVmFsdWUgLT0gbm9kZVZhbHVlOyBicmVhazsgfVxyXG4gICAgICBtaW5SYXRpbyA9IG5ld1JhdGlvO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFBvc2l0aW9uIGFuZCByZWNvcmQgdGhlIHJvdyBvcmllbnRhdGlvbi5cclxuICAgIHJvd3MucHVzaChyb3cgPSB7dmFsdWU6IHN1bVZhbHVlLCBkaWNlOiBkeCA8IGR5LCBjaGlsZHJlbjogbm9kZXMuc2xpY2UoaTAsIGkxKX0pO1xyXG4gICAgaWYgKHJvdy5kaWNlKSB0cmVlbWFwRGljZShyb3csIHgwLCB5MCwgeDEsIHZhbHVlID8geTAgKz0gZHkgKiBzdW1WYWx1ZSAvIHZhbHVlIDogeTEpO1xyXG4gICAgZWxzZSB0cmVlbWFwU2xpY2Uocm93LCB4MCwgeTAsIHZhbHVlID8geDAgKz0gZHggKiBzdW1WYWx1ZSAvIHZhbHVlIDogeDEsIHkxKTtcclxuICAgIHZhbHVlIC09IHN1bVZhbHVlLCBpMCA9IGkxO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJvd3M7XHJcbn1cclxuXHJcbnZhciBzcXVhcmlmeSA9IChmdW5jdGlvbiBjdXN0b20ocmF0aW8pIHtcclxuXHJcbiAgZnVuY3Rpb24gc3F1YXJpZnkocGFyZW50LCB4MCwgeTAsIHgxLCB5MSkge1xyXG4gICAgc3F1YXJpZnlSYXRpbyhyYXRpbywgcGFyZW50LCB4MCwgeTAsIHgxLCB5MSk7XHJcbiAgfVxyXG5cclxuICBzcXVhcmlmeS5yYXRpbyA9IGZ1bmN0aW9uKHgpIHtcclxuICAgIHJldHVybiBjdXN0b20oKHggPSAreCkgPiAxID8geCA6IDEpO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBzcXVhcmlmeTtcclxufSkocGhpKTtcclxuXHJcbmZ1bmN0aW9uIGluZGV4JDMoKSB7XHJcbiAgdmFyIHRpbGUgPSBzcXVhcmlmeSxcclxuICAgICAgcm91bmQgPSBmYWxzZSxcclxuICAgICAgZHggPSAxLFxyXG4gICAgICBkeSA9IDEsXHJcbiAgICAgIHBhZGRpbmdTdGFjayA9IFswXSxcclxuICAgICAgcGFkZGluZ0lubmVyID0gY29uc3RhbnRaZXJvLFxyXG4gICAgICBwYWRkaW5nVG9wID0gY29uc3RhbnRaZXJvLFxyXG4gICAgICBwYWRkaW5nUmlnaHQgPSBjb25zdGFudFplcm8sXHJcbiAgICAgIHBhZGRpbmdCb3R0b20gPSBjb25zdGFudFplcm8sXHJcbiAgICAgIHBhZGRpbmdMZWZ0ID0gY29uc3RhbnRaZXJvO1xyXG5cclxuICBmdW5jdGlvbiB0cmVlbWFwKHJvb3QpIHtcclxuICAgIHJvb3QueDAgPVxyXG4gICAgcm9vdC55MCA9IDA7XHJcbiAgICByb290LngxID0gZHg7XHJcbiAgICByb290LnkxID0gZHk7XHJcbiAgICByb290LmVhY2hCZWZvcmUocG9zaXRpb25Ob2RlKTtcclxuICAgIHBhZGRpbmdTdGFjayA9IFswXTtcclxuICAgIGlmIChyb3VuZCkgcm9vdC5lYWNoQmVmb3JlKHJvdW5kTm9kZSk7XHJcbiAgICByZXR1cm4gcm9vdDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHBvc2l0aW9uTm9kZShub2RlKSB7XHJcbiAgICB2YXIgcCA9IHBhZGRpbmdTdGFja1tub2RlLmRlcHRoXSxcclxuICAgICAgICB4MCA9IG5vZGUueDAgKyBwLFxyXG4gICAgICAgIHkwID0gbm9kZS55MCArIHAsXHJcbiAgICAgICAgeDEgPSBub2RlLngxIC0gcCxcclxuICAgICAgICB5MSA9IG5vZGUueTEgLSBwO1xyXG4gICAgaWYgKHgxIDwgeDApIHgwID0geDEgPSAoeDAgKyB4MSkgLyAyO1xyXG4gICAgaWYgKHkxIDwgeTApIHkwID0geTEgPSAoeTAgKyB5MSkgLyAyO1xyXG4gICAgbm9kZS54MCA9IHgwO1xyXG4gICAgbm9kZS55MCA9IHkwO1xyXG4gICAgbm9kZS54MSA9IHgxO1xyXG4gICAgbm9kZS55MSA9IHkxO1xyXG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcclxuICAgICAgcCA9IHBhZGRpbmdTdGFja1tub2RlLmRlcHRoICsgMV0gPSBwYWRkaW5nSW5uZXIobm9kZSkgLyAyO1xyXG4gICAgICB4MCArPSBwYWRkaW5nTGVmdChub2RlKSAtIHA7XHJcbiAgICAgIHkwICs9IHBhZGRpbmdUb3Aobm9kZSkgLSBwO1xyXG4gICAgICB4MSAtPSBwYWRkaW5nUmlnaHQobm9kZSkgLSBwO1xyXG4gICAgICB5MSAtPSBwYWRkaW5nQm90dG9tKG5vZGUpIC0gcDtcclxuICAgICAgaWYgKHgxIDwgeDApIHgwID0geDEgPSAoeDAgKyB4MSkgLyAyO1xyXG4gICAgICBpZiAoeTEgPCB5MCkgeTAgPSB5MSA9ICh5MCArIHkxKSAvIDI7XHJcbiAgICAgIHRpbGUobm9kZSwgeDAsIHkwLCB4MSwgeTEpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdHJlZW1hcC5yb3VuZCA9IGZ1bmN0aW9uKHgpIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJvdW5kID0gISF4LCB0cmVlbWFwKSA6IHJvdW5kO1xyXG4gIH07XHJcblxyXG4gIHRyZWVtYXAuc2l6ZSA9IGZ1bmN0aW9uKHgpIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGR4ID0gK3hbMF0sIGR5ID0gK3hbMV0sIHRyZWVtYXApIDogW2R4LCBkeV07XHJcbiAgfTtcclxuXHJcbiAgdHJlZW1hcC50aWxlID0gZnVuY3Rpb24oeCkge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGlsZSA9IHJlcXVpcmVkKHgpLCB0cmVlbWFwKSA6IHRpbGU7XHJcbiAgfTtcclxuXHJcbiAgdHJlZW1hcC5wYWRkaW5nID0gZnVuY3Rpb24oeCkge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0cmVlbWFwLnBhZGRpbmdJbm5lcih4KS5wYWRkaW5nT3V0ZXIoeCkgOiB0cmVlbWFwLnBhZGRpbmdJbm5lcigpO1xyXG4gIH07XHJcblxyXG4gIHRyZWVtYXAucGFkZGluZ0lubmVyID0gZnVuY3Rpb24oeCkge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZ0lubmVyID0gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHggOiBjb25zdGFudCQ5KCt4KSwgdHJlZW1hcCkgOiBwYWRkaW5nSW5uZXI7XHJcbiAgfTtcclxuXHJcbiAgdHJlZW1hcC5wYWRkaW5nT3V0ZXIgPSBmdW5jdGlvbih4KSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRyZWVtYXAucGFkZGluZ1RvcCh4KS5wYWRkaW5nUmlnaHQoeCkucGFkZGluZ0JvdHRvbSh4KS5wYWRkaW5nTGVmdCh4KSA6IHRyZWVtYXAucGFkZGluZ1RvcCgpO1xyXG4gIH07XHJcblxyXG4gIHRyZWVtYXAucGFkZGluZ1RvcCA9IGZ1bmN0aW9uKHgpIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmdUb3AgPSB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8geCA6IGNvbnN0YW50JDkoK3gpLCB0cmVlbWFwKSA6IHBhZGRpbmdUb3A7XHJcbiAgfTtcclxuXHJcbiAgdHJlZW1hcC5wYWRkaW5nUmlnaHQgPSBmdW5jdGlvbih4KSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRkaW5nUmlnaHQgPSB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8geCA6IGNvbnN0YW50JDkoK3gpLCB0cmVlbWFwKSA6IHBhZGRpbmdSaWdodDtcclxuICB9O1xyXG5cclxuICB0cmVlbWFwLnBhZGRpbmdCb3R0b20gPSBmdW5jdGlvbih4KSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRkaW5nQm90dG9tID0gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHggOiBjb25zdGFudCQ5KCt4KSwgdHJlZW1hcCkgOiBwYWRkaW5nQm90dG9tO1xyXG4gIH07XHJcblxyXG4gIHRyZWVtYXAucGFkZGluZ0xlZnQgPSBmdW5jdGlvbih4KSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRkaW5nTGVmdCA9IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4IDogY29uc3RhbnQkOSgreCksIHRyZWVtYXApIDogcGFkZGluZ0xlZnQ7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIHRyZWVtYXA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGJpbmFyeShwYXJlbnQsIHgwLCB5MCwgeDEsIHkxKSB7XHJcbiAgdmFyIG5vZGVzID0gcGFyZW50LmNoaWxkcmVuLFxyXG4gICAgICBpLCBuID0gbm9kZXMubGVuZ3RoLFxyXG4gICAgICBzdW0sIHN1bXMgPSBuZXcgQXJyYXkobiArIDEpO1xyXG5cclxuICBmb3IgKHN1bXNbMF0gPSBzdW0gPSBpID0gMDsgaSA8IG47ICsraSkge1xyXG4gICAgc3Vtc1tpICsgMV0gPSBzdW0gKz0gbm9kZXNbaV0udmFsdWU7XHJcbiAgfVxyXG5cclxuICBwYXJ0aXRpb24oMCwgbiwgcGFyZW50LnZhbHVlLCB4MCwgeTAsIHgxLCB5MSk7XHJcblxyXG4gIGZ1bmN0aW9uIHBhcnRpdGlvbihpLCBqLCB2YWx1ZSwgeDAsIHkwLCB4MSwgeTEpIHtcclxuICAgIGlmIChpID49IGogLSAxKSB7XHJcbiAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XHJcbiAgICAgIG5vZGUueDAgPSB4MCwgbm9kZS55MCA9IHkwO1xyXG4gICAgICBub2RlLngxID0geDEsIG5vZGUueTEgPSB5MTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB2YWx1ZU9mZnNldCA9IHN1bXNbaV0sXHJcbiAgICAgICAgdmFsdWVUYXJnZXQgPSAodmFsdWUgLyAyKSArIHZhbHVlT2Zmc2V0LFxyXG4gICAgICAgIGsgPSBpICsgMSxcclxuICAgICAgICBoaSA9IGogLSAxO1xyXG5cclxuICAgIHdoaWxlIChrIDwgaGkpIHtcclxuICAgICAgdmFyIG1pZCA9IGsgKyBoaSA+Pj4gMTtcclxuICAgICAgaWYgKHN1bXNbbWlkXSA8IHZhbHVlVGFyZ2V0KSBrID0gbWlkICsgMTtcclxuICAgICAgZWxzZSBoaSA9IG1pZDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoKHZhbHVlVGFyZ2V0IC0gc3Vtc1trIC0gMV0pIDwgKHN1bXNba10gLSB2YWx1ZVRhcmdldCkgJiYgaSArIDEgPCBrKSAtLWs7XHJcblxyXG4gICAgdmFyIHZhbHVlTGVmdCA9IHN1bXNba10gLSB2YWx1ZU9mZnNldCxcclxuICAgICAgICB2YWx1ZVJpZ2h0ID0gdmFsdWUgLSB2YWx1ZUxlZnQ7XHJcblxyXG4gICAgaWYgKCh4MSAtIHgwKSA+ICh5MSAtIHkwKSkge1xyXG4gICAgICB2YXIgeGsgPSAoeDAgKiB2YWx1ZVJpZ2h0ICsgeDEgKiB2YWx1ZUxlZnQpIC8gdmFsdWU7XHJcbiAgICAgIHBhcnRpdGlvbihpLCBrLCB2YWx1ZUxlZnQsIHgwLCB5MCwgeGssIHkxKTtcclxuICAgICAgcGFydGl0aW9uKGssIGosIHZhbHVlUmlnaHQsIHhrLCB5MCwgeDEsIHkxKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhciB5ayA9ICh5MCAqIHZhbHVlUmlnaHQgKyB5MSAqIHZhbHVlTGVmdCkgLyB2YWx1ZTtcclxuICAgICAgcGFydGl0aW9uKGksIGssIHZhbHVlTGVmdCwgeDAsIHkwLCB4MSwgeWspO1xyXG4gICAgICBwYXJ0aXRpb24oaywgaiwgdmFsdWVSaWdodCwgeDAsIHlrLCB4MSwgeTEpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gc2xpY2VEaWNlKHBhcmVudCwgeDAsIHkwLCB4MSwgeTEpIHtcclxuICAocGFyZW50LmRlcHRoICYgMSA/IHRyZWVtYXBTbGljZSA6IHRyZWVtYXBEaWNlKShwYXJlbnQsIHgwLCB5MCwgeDEsIHkxKTtcclxufVxyXG5cclxudmFyIHJlc3F1YXJpZnkgPSAoZnVuY3Rpb24gY3VzdG9tKHJhdGlvKSB7XHJcblxyXG4gIGZ1bmN0aW9uIHJlc3F1YXJpZnkocGFyZW50LCB4MCwgeTAsIHgxLCB5MSkge1xyXG4gICAgaWYgKChyb3dzID0gcGFyZW50Ll9zcXVhcmlmeSkgJiYgKHJvd3MucmF0aW8gPT09IHJhdGlvKSkge1xyXG4gICAgICB2YXIgcm93cyxcclxuICAgICAgICAgIHJvdyxcclxuICAgICAgICAgIG5vZGVzLFxyXG4gICAgICAgICAgaSxcclxuICAgICAgICAgIGogPSAtMSxcclxuICAgICAgICAgIG4sXHJcbiAgICAgICAgICBtID0gcm93cy5sZW5ndGgsXHJcbiAgICAgICAgICB2YWx1ZSA9IHBhcmVudC52YWx1ZTtcclxuXHJcbiAgICAgIHdoaWxlICgrK2ogPCBtKSB7XHJcbiAgICAgICAgcm93ID0gcm93c1tqXSwgbm9kZXMgPSByb3cuY2hpbGRyZW47XHJcbiAgICAgICAgZm9yIChpID0gcm93LnZhbHVlID0gMCwgbiA9IG5vZGVzLmxlbmd0aDsgaSA8IG47ICsraSkgcm93LnZhbHVlICs9IG5vZGVzW2ldLnZhbHVlO1xyXG4gICAgICAgIGlmIChyb3cuZGljZSkgdHJlZW1hcERpY2Uocm93LCB4MCwgeTAsIHgxLCB5MCArPSAoeTEgLSB5MCkgKiByb3cudmFsdWUgLyB2YWx1ZSk7XHJcbiAgICAgICAgZWxzZSB0cmVlbWFwU2xpY2Uocm93LCB4MCwgeTAsIHgwICs9ICh4MSAtIHgwKSAqIHJvdy52YWx1ZSAvIHZhbHVlLCB5MSk7XHJcbiAgICAgICAgdmFsdWUgLT0gcm93LnZhbHVlO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBwYXJlbnQuX3NxdWFyaWZ5ID0gcm93cyA9IHNxdWFyaWZ5UmF0aW8ocmF0aW8sIHBhcmVudCwgeDAsIHkwLCB4MSwgeTEpO1xyXG4gICAgICByb3dzLnJhdGlvID0gcmF0aW87XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXNxdWFyaWZ5LnJhdGlvID0gZnVuY3Rpb24oeCkge1xyXG4gICAgcmV0dXJuIGN1c3RvbSgoeCA9ICt4KSA+IDEgPyB4IDogMSk7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIHJlc3F1YXJpZnk7XHJcbn0pKHBoaSk7XHJcblxyXG5mdW5jdGlvbiBhcmVhJDIocG9seWdvbikge1xyXG4gIHZhciBpID0gLTEsXHJcbiAgICAgIG4gPSBwb2x5Z29uLmxlbmd0aCxcclxuICAgICAgYSxcclxuICAgICAgYiA9IHBvbHlnb25bbiAtIDFdLFxyXG4gICAgICBhcmVhID0gMDtcclxuXHJcbiAgd2hpbGUgKCsraSA8IG4pIHtcclxuICAgIGEgPSBiO1xyXG4gICAgYiA9IHBvbHlnb25baV07XHJcbiAgICBhcmVhICs9IGFbMV0gKiBiWzBdIC0gYVswXSAqIGJbMV07XHJcbiAgfVxyXG5cclxuICByZXR1cm4gYXJlYSAvIDI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNlbnRyb2lkJDEocG9seWdvbikge1xyXG4gIHZhciBpID0gLTEsXHJcbiAgICAgIG4gPSBwb2x5Z29uLmxlbmd0aCxcclxuICAgICAgeCA9IDAsXHJcbiAgICAgIHkgPSAwLFxyXG4gICAgICBhLFxyXG4gICAgICBiID0gcG9seWdvbltuIC0gMV0sXHJcbiAgICAgIGMsXHJcbiAgICAgIGsgPSAwO1xyXG5cclxuICB3aGlsZSAoKytpIDwgbikge1xyXG4gICAgYSA9IGI7XHJcbiAgICBiID0gcG9seWdvbltpXTtcclxuICAgIGsgKz0gYyA9IGFbMF0gKiBiWzFdIC0gYlswXSAqIGFbMV07XHJcbiAgICB4ICs9IChhWzBdICsgYlswXSkgKiBjO1xyXG4gICAgeSArPSAoYVsxXSArIGJbMV0pICogYztcclxuICB9XHJcblxyXG4gIHJldHVybiBrICo9IDMsIFt4IC8gaywgeSAvIGtdO1xyXG59XHJcblxyXG4vLyBSZXR1cm5zIHRoZSAyRCBjcm9zcyBwcm9kdWN0IG9mIEFCIGFuZCBBQyB2ZWN0b3JzLCBpLmUuLCB0aGUgei1jb21wb25lbnQgb2ZcclxuLy8gdGhlIDNEIGNyb3NzIHByb2R1Y3QgaW4gYSBxdWFkcmFudCBJIENhcnRlc2lhbiBjb29yZGluYXRlIHN5c3RlbSAoK3ggaXNcclxuLy8gcmlnaHQsICt5IGlzIHVwKS4gUmV0dXJucyBhIHBvc2l0aXZlIHZhbHVlIGlmIEFCQyBpcyBjb3VudGVyLWNsb2Nrd2lzZSxcclxuLy8gbmVnYXRpdmUgaWYgY2xvY2t3aXNlLCBhbmQgemVybyBpZiB0aGUgcG9pbnRzIGFyZSBjb2xsaW5lYXIuXHJcbmZ1bmN0aW9uIGNyb3NzJDEoYSwgYiwgYykge1xyXG4gIHJldHVybiAoYlswXSAtIGFbMF0pICogKGNbMV0gLSBhWzFdKSAtIChiWzFdIC0gYVsxXSkgKiAoY1swXSAtIGFbMF0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBsZXhpY29ncmFwaGljT3JkZXIoYSwgYikge1xyXG4gIHJldHVybiBhWzBdIC0gYlswXSB8fCBhWzFdIC0gYlsxXTtcclxufVxyXG5cclxuLy8gQ29tcHV0ZXMgdGhlIHVwcGVyIGNvbnZleCBodWxsIHBlciB0aGUgbW9ub3RvbmUgY2hhaW4gYWxnb3JpdGhtLlxyXG4vLyBBc3N1bWVzIHBvaW50cy5sZW5ndGggPj0gMywgaXMgc29ydGVkIGJ5IHgsIHVuaXF1ZSBpbiB5LlxyXG4vLyBSZXR1cm5zIGFuIGFycmF5IG9mIGluZGljZXMgaW50byBwb2ludHMgaW4gbGVmdC10by1yaWdodCBvcmRlci5cclxuZnVuY3Rpb24gY29tcHV0ZVVwcGVySHVsbEluZGV4ZXMocG9pbnRzKSB7XHJcbiAgdmFyIG4gPSBwb2ludHMubGVuZ3RoLFxyXG4gICAgICBpbmRleGVzID0gWzAsIDFdLFxyXG4gICAgICBzaXplID0gMjtcclxuXHJcbiAgZm9yICh2YXIgaSA9IDI7IGkgPCBuOyArK2kpIHtcclxuICAgIHdoaWxlIChzaXplID4gMSAmJiBjcm9zcyQxKHBvaW50c1tpbmRleGVzW3NpemUgLSAyXV0sIHBvaW50c1tpbmRleGVzW3NpemUgLSAxXV0sIHBvaW50c1tpXSkgPD0gMCkgLS1zaXplO1xyXG4gICAgaW5kZXhlc1tzaXplKytdID0gaTtcclxuICB9XHJcblxyXG4gIHJldHVybiBpbmRleGVzLnNsaWNlKDAsIHNpemUpOyAvLyByZW1vdmUgcG9wcGVkIHBvaW50c1xyXG59XHJcblxyXG5mdW5jdGlvbiBodWxsKHBvaW50cykge1xyXG4gIGlmICgobiA9IHBvaW50cy5sZW5ndGgpIDwgMykgcmV0dXJuIG51bGw7XHJcblxyXG4gIHZhciBpLFxyXG4gICAgICBuLFxyXG4gICAgICBzb3J0ZWRQb2ludHMgPSBuZXcgQXJyYXkobiksXHJcbiAgICAgIGZsaXBwZWRQb2ludHMgPSBuZXcgQXJyYXkobik7XHJcblxyXG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHNvcnRlZFBvaW50c1tpXSA9IFsrcG9pbnRzW2ldWzBdLCArcG9pbnRzW2ldWzFdLCBpXTtcclxuICBzb3J0ZWRQb2ludHMuc29ydChsZXhpY29ncmFwaGljT3JkZXIpO1xyXG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIGZsaXBwZWRQb2ludHNbaV0gPSBbc29ydGVkUG9pbnRzW2ldWzBdLCAtc29ydGVkUG9pbnRzW2ldWzFdXTtcclxuXHJcbiAgdmFyIHVwcGVySW5kZXhlcyA9IGNvbXB1dGVVcHBlckh1bGxJbmRleGVzKHNvcnRlZFBvaW50cyksXHJcbiAgICAgIGxvd2VySW5kZXhlcyA9IGNvbXB1dGVVcHBlckh1bGxJbmRleGVzKGZsaXBwZWRQb2ludHMpO1xyXG5cclxuICAvLyBDb25zdHJ1Y3QgdGhlIGh1bGwgcG9seWdvbiwgcmVtb3ZpbmcgcG9zc2libGUgZHVwbGljYXRlIGVuZHBvaW50cy5cclxuICB2YXIgc2tpcExlZnQgPSBsb3dlckluZGV4ZXNbMF0gPT09IHVwcGVySW5kZXhlc1swXSxcclxuICAgICAgc2tpcFJpZ2h0ID0gbG93ZXJJbmRleGVzW2xvd2VySW5kZXhlcy5sZW5ndGggLSAxXSA9PT0gdXBwZXJJbmRleGVzW3VwcGVySW5kZXhlcy5sZW5ndGggLSAxXSxcclxuICAgICAgaHVsbCA9IFtdO1xyXG5cclxuICAvLyBBZGQgdXBwZXIgaHVsbCBpbiByaWdodC10by1sIG9yZGVyLlxyXG4gIC8vIFRoZW4gYWRkIGxvd2VyIGh1bGwgaW4gbGVmdC10by1yaWdodCBvcmRlci5cclxuICBmb3IgKGkgPSB1cHBlckluZGV4ZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIGh1bGwucHVzaChwb2ludHNbc29ydGVkUG9pbnRzW3VwcGVySW5kZXhlc1tpXV1bMl1dKTtcclxuICBmb3IgKGkgPSArc2tpcExlZnQ7IGkgPCBsb3dlckluZGV4ZXMubGVuZ3RoIC0gc2tpcFJpZ2h0OyArK2kpIGh1bGwucHVzaChwb2ludHNbc29ydGVkUG9pbnRzW2xvd2VySW5kZXhlc1tpXV1bMl1dKTtcclxuXHJcbiAgcmV0dXJuIGh1bGw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbnRhaW5zJDIocG9seWdvbiwgcG9pbnQpIHtcclxuICB2YXIgbiA9IHBvbHlnb24ubGVuZ3RoLFxyXG4gICAgICBwID0gcG9seWdvbltuIC0gMV0sXHJcbiAgICAgIHggPSBwb2ludFswXSwgeSA9IHBvaW50WzFdLFxyXG4gICAgICB4MCA9IHBbMF0sIHkwID0gcFsxXSxcclxuICAgICAgeDEsIHkxLFxyXG4gICAgICBpbnNpZGUgPSBmYWxzZTtcclxuXHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcclxuICAgIHAgPSBwb2x5Z29uW2ldLCB4MSA9IHBbMF0sIHkxID0gcFsxXTtcclxuICAgIGlmICgoKHkxID4geSkgIT09ICh5MCA+IHkpKSAmJiAoeCA8ICh4MCAtIHgxKSAqICh5IC0geTEpIC8gKHkwIC0geTEpICsgeDEpKSBpbnNpZGUgPSAhaW5zaWRlO1xyXG4gICAgeDAgPSB4MSwgeTAgPSB5MTtcclxuICB9XHJcblxyXG4gIHJldHVybiBpbnNpZGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxlbmd0aCQyKHBvbHlnb24pIHtcclxuICB2YXIgaSA9IC0xLFxyXG4gICAgICBuID0gcG9seWdvbi5sZW5ndGgsXHJcbiAgICAgIGIgPSBwb2x5Z29uW24gLSAxXSxcclxuICAgICAgeGEsXHJcbiAgICAgIHlhLFxyXG4gICAgICB4YiA9IGJbMF0sXHJcbiAgICAgIHliID0gYlsxXSxcclxuICAgICAgcGVyaW1ldGVyID0gMDtcclxuXHJcbiAgd2hpbGUgKCsraSA8IG4pIHtcclxuICAgIHhhID0geGI7XHJcbiAgICB5YSA9IHliO1xyXG4gICAgYiA9IHBvbHlnb25baV07XHJcbiAgICB4YiA9IGJbMF07XHJcbiAgICB5YiA9IGJbMV07XHJcbiAgICB4YSAtPSB4YjtcclxuICAgIHlhIC09IHliO1xyXG4gICAgcGVyaW1ldGVyICs9IE1hdGguc3FydCh4YSAqIHhhICsgeWEgKiB5YSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcGVyaW1ldGVyO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkZWZhdWx0U291cmNlJDEoKSB7XHJcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCk7XHJcbn1cclxuXHJcbnZhciB1bmlmb3JtID0gKGZ1bmN0aW9uIHNvdXJjZVJhbmRvbVVuaWZvcm0oc291cmNlKSB7XHJcbiAgZnVuY3Rpb24gcmFuZG9tVW5pZm9ybShtaW4sIG1heCkge1xyXG4gICAgbWluID0gbWluID09IG51bGwgPyAwIDogK21pbjtcclxuICAgIG1heCA9IG1heCA9PSBudWxsID8gMSA6ICttYXg7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgbWF4ID0gbWluLCBtaW4gPSAwO1xyXG4gICAgZWxzZSBtYXggLT0gbWluO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gc291cmNlKCkgKiBtYXggKyBtaW47XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgcmFuZG9tVW5pZm9ybS5zb3VyY2UgPSBzb3VyY2VSYW5kb21Vbmlmb3JtO1xyXG5cclxuICByZXR1cm4gcmFuZG9tVW5pZm9ybTtcclxufSkoZGVmYXVsdFNvdXJjZSQxKTtcclxuXHJcbnZhciBub3JtYWwgPSAoZnVuY3Rpb24gc291cmNlUmFuZG9tTm9ybWFsKHNvdXJjZSkge1xyXG4gIGZ1bmN0aW9uIHJhbmRvbU5vcm1hbChtdSwgc2lnbWEpIHtcclxuICAgIHZhciB4LCByO1xyXG4gICAgbXUgPSBtdSA9PSBudWxsID8gMCA6ICttdTtcclxuICAgIHNpZ21hID0gc2lnbWEgPT0gbnVsbCA/IDEgOiArc2lnbWE7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciB5O1xyXG5cclxuICAgICAgLy8gSWYgYXZhaWxhYmxlLCB1c2UgdGhlIHNlY29uZCBwcmV2aW91c2x5LWdlbmVyYXRlZCB1bmlmb3JtIHJhbmRvbS5cclxuICAgICAgaWYgKHggIT0gbnVsbCkgeSA9IHgsIHggPSBudWxsO1xyXG5cclxuICAgICAgLy8gT3RoZXJ3aXNlLCBnZW5lcmF0ZSBhIG5ldyB4IGFuZCB5LlxyXG4gICAgICBlbHNlIGRvIHtcclxuICAgICAgICB4ID0gc291cmNlKCkgKiAyIC0gMTtcclxuICAgICAgICB5ID0gc291cmNlKCkgKiAyIC0gMTtcclxuICAgICAgICByID0geCAqIHggKyB5ICogeTtcclxuICAgICAgfSB3aGlsZSAoIXIgfHwgciA+IDEpO1xyXG5cclxuICAgICAgcmV0dXJuIG11ICsgc2lnbWEgKiB5ICogTWF0aC5zcXJ0KC0yICogTWF0aC5sb2cocikgLyByKTtcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICByYW5kb21Ob3JtYWwuc291cmNlID0gc291cmNlUmFuZG9tTm9ybWFsO1xyXG5cclxuICByZXR1cm4gcmFuZG9tTm9ybWFsO1xyXG59KShkZWZhdWx0U291cmNlJDEpO1xyXG5cclxudmFyIGxvZ05vcm1hbCA9IChmdW5jdGlvbiBzb3VyY2VSYW5kb21Mb2dOb3JtYWwoc291cmNlKSB7XHJcbiAgZnVuY3Rpb24gcmFuZG9tTG9nTm9ybWFsKCkge1xyXG4gICAgdmFyIHJhbmRvbU5vcm1hbCA9IG5vcm1hbC5zb3VyY2Uoc291cmNlKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gTWF0aC5leHAocmFuZG9tTm9ybWFsKCkpO1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHJhbmRvbUxvZ05vcm1hbC5zb3VyY2UgPSBzb3VyY2VSYW5kb21Mb2dOb3JtYWw7XHJcblxyXG4gIHJldHVybiByYW5kb21Mb2dOb3JtYWw7XHJcbn0pKGRlZmF1bHRTb3VyY2UkMSk7XHJcblxyXG52YXIgaXJ3aW5IYWxsID0gKGZ1bmN0aW9uIHNvdXJjZVJhbmRvbUlyd2luSGFsbChzb3VyY2UpIHtcclxuICBmdW5jdGlvbiByYW5kb21JcndpbkhhbGwobikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICBmb3IgKHZhciBzdW0gPSAwLCBpID0gMDsgaSA8IG47ICsraSkgc3VtICs9IHNvdXJjZSgpO1xyXG4gICAgICByZXR1cm4gc3VtO1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHJhbmRvbUlyd2luSGFsbC5zb3VyY2UgPSBzb3VyY2VSYW5kb21JcndpbkhhbGw7XHJcblxyXG4gIHJldHVybiByYW5kb21JcndpbkhhbGw7XHJcbn0pKGRlZmF1bHRTb3VyY2UkMSk7XHJcblxyXG52YXIgYmF0ZXMgPSAoZnVuY3Rpb24gc291cmNlUmFuZG9tQmF0ZXMoc291cmNlKSB7XHJcbiAgZnVuY3Rpb24gcmFuZG9tQmF0ZXMobikge1xyXG4gICAgdmFyIHJhbmRvbUlyd2luSGFsbCA9IGlyd2luSGFsbC5zb3VyY2Uoc291cmNlKShuKTtcclxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIHJhbmRvbUlyd2luSGFsbCgpIC8gbjtcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICByYW5kb21CYXRlcy5zb3VyY2UgPSBzb3VyY2VSYW5kb21CYXRlcztcclxuXHJcbiAgcmV0dXJuIHJhbmRvbUJhdGVzO1xyXG59KShkZWZhdWx0U291cmNlJDEpO1xyXG5cclxudmFyIGV4cG9uZW50aWFsJDEgPSAoZnVuY3Rpb24gc291cmNlUmFuZG9tRXhwb25lbnRpYWwoc291cmNlKSB7XHJcbiAgZnVuY3Rpb24gcmFuZG9tRXhwb25lbnRpYWwobGFtYmRhKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiAtTWF0aC5sb2coMSAtIHNvdXJjZSgpKSAvIGxhbWJkYTtcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICByYW5kb21FeHBvbmVudGlhbC5zb3VyY2UgPSBzb3VyY2VSYW5kb21FeHBvbmVudGlhbDtcclxuXHJcbiAgcmV0dXJuIHJhbmRvbUV4cG9uZW50aWFsO1xyXG59KShkZWZhdWx0U291cmNlJDEpO1xyXG5cclxudmFyIGFycmF5JDMgPSBBcnJheS5wcm90b3R5cGU7XHJcblxyXG52YXIgbWFwJDIgPSBhcnJheSQzLm1hcDtcclxudmFyIHNsaWNlJDUgPSBhcnJheSQzLnNsaWNlO1xyXG5cclxudmFyIGltcGxpY2l0ID0ge25hbWU6IFwiaW1wbGljaXRcIn07XHJcblxyXG5mdW5jdGlvbiBvcmRpbmFsKHJhbmdlKSB7XHJcbiAgdmFyIGluZGV4ID0gbWFwJDEoKSxcclxuICAgICAgZG9tYWluID0gW10sXHJcbiAgICAgIHVua25vd24gPSBpbXBsaWNpdDtcclxuXHJcbiAgcmFuZ2UgPSByYW5nZSA9PSBudWxsID8gW10gOiBzbGljZSQ1LmNhbGwocmFuZ2UpO1xyXG5cclxuICBmdW5jdGlvbiBzY2FsZShkKSB7XHJcbiAgICB2YXIga2V5ID0gZCArIFwiXCIsIGkgPSBpbmRleC5nZXQoa2V5KTtcclxuICAgIGlmICghaSkge1xyXG4gICAgICBpZiAodW5rbm93biAhPT0gaW1wbGljaXQpIHJldHVybiB1bmtub3duO1xyXG4gICAgICBpbmRleC5zZXQoa2V5LCBpID0gZG9tYWluLnB1c2goZCkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJhbmdlWyhpIC0gMSkgJSByYW5nZS5sZW5ndGhdO1xyXG4gIH1cclxuXHJcbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xyXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZG9tYWluLnNsaWNlKCk7XHJcbiAgICBkb21haW4gPSBbXSwgaW5kZXggPSBtYXAkMSgpO1xyXG4gICAgdmFyIGkgPSAtMSwgbiA9IF8ubGVuZ3RoLCBkLCBrZXk7XHJcbiAgICB3aGlsZSAoKytpIDwgbikgaWYgKCFpbmRleC5oYXMoa2V5ID0gKGQgPSBfW2ldKSArIFwiXCIpKSBpbmRleC5zZXQoa2V5LCBkb21haW4ucHVzaChkKSk7XHJcbiAgICByZXR1cm4gc2NhbGU7XHJcbiAgfTtcclxuXHJcbiAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYW5nZSA9IHNsaWNlJDUuY2FsbChfKSwgc2NhbGUpIDogcmFuZ2Uuc2xpY2UoKTtcclxuICB9O1xyXG5cclxuICBzY2FsZS51bmtub3duID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHVua25vd247XHJcbiAgfTtcclxuXHJcbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIG9yZGluYWwoKVxyXG4gICAgICAgIC5kb21haW4oZG9tYWluKVxyXG4gICAgICAgIC5yYW5nZShyYW5nZSlcclxuICAgICAgICAudW5rbm93bih1bmtub3duKTtcclxuICB9O1xyXG5cclxuICByZXR1cm4gc2NhbGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGJhbmQoKSB7XHJcbiAgdmFyIHNjYWxlID0gb3JkaW5hbCgpLnVua25vd24odW5kZWZpbmVkKSxcclxuICAgICAgZG9tYWluID0gc2NhbGUuZG9tYWluLFxyXG4gICAgICBvcmRpbmFsUmFuZ2UgPSBzY2FsZS5yYW5nZSxcclxuICAgICAgcmFuZ2UkJDEgPSBbMCwgMV0sXHJcbiAgICAgIHN0ZXAsXHJcbiAgICAgIGJhbmR3aWR0aCxcclxuICAgICAgcm91bmQgPSBmYWxzZSxcclxuICAgICAgcGFkZGluZ0lubmVyID0gMCxcclxuICAgICAgcGFkZGluZ091dGVyID0gMCxcclxuICAgICAgYWxpZ24gPSAwLjU7XHJcblxyXG4gIGRlbGV0ZSBzY2FsZS51bmtub3duO1xyXG5cclxuICBmdW5jdGlvbiByZXNjYWxlKCkge1xyXG4gICAgdmFyIG4gPSBkb21haW4oKS5sZW5ndGgsXHJcbiAgICAgICAgcmV2ZXJzZSA9IHJhbmdlJCQxWzFdIDwgcmFuZ2UkJDFbMF0sXHJcbiAgICAgICAgc3RhcnQgPSByYW5nZSQkMVtyZXZlcnNlIC0gMF0sXHJcbiAgICAgICAgc3RvcCA9IHJhbmdlJCQxWzEgLSByZXZlcnNlXTtcclxuICAgIHN0ZXAgPSAoc3RvcCAtIHN0YXJ0KSAvIE1hdGgubWF4KDEsIG4gLSBwYWRkaW5nSW5uZXIgKyBwYWRkaW5nT3V0ZXIgKiAyKTtcclxuICAgIGlmIChyb3VuZCkgc3RlcCA9IE1hdGguZmxvb3Ioc3RlcCk7XHJcbiAgICBzdGFydCArPSAoc3RvcCAtIHN0YXJ0IC0gc3RlcCAqIChuIC0gcGFkZGluZ0lubmVyKSkgKiBhbGlnbjtcclxuICAgIGJhbmR3aWR0aCA9IHN0ZXAgKiAoMSAtIHBhZGRpbmdJbm5lcik7XHJcbiAgICBpZiAocm91bmQpIHN0YXJ0ID0gTWF0aC5yb3VuZChzdGFydCksIGJhbmR3aWR0aCA9IE1hdGgucm91bmQoYmFuZHdpZHRoKTtcclxuICAgIHZhciB2YWx1ZXMgPSBzZXF1ZW5jZShuKS5tYXAoZnVuY3Rpb24oaSkgeyByZXR1cm4gc3RhcnQgKyBzdGVwICogaTsgfSk7XHJcbiAgICByZXR1cm4gb3JkaW5hbFJhbmdlKHJldmVyc2UgPyB2YWx1ZXMucmV2ZXJzZSgpIDogdmFsdWVzKTtcclxuICB9XHJcblxyXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRvbWFpbihfKSwgcmVzY2FsZSgpKSA6IGRvbWFpbigpO1xyXG4gIH07XHJcblxyXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFuZ2UkJDEgPSBbK19bMF0sICtfWzFdXSwgcmVzY2FsZSgpKSA6IHJhbmdlJCQxLnNsaWNlKCk7XHJcbiAgfTtcclxuXHJcbiAgc2NhbGUucmFuZ2VSb3VuZCA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiByYW5nZSQkMSA9IFsrX1swXSwgK19bMV1dLCByb3VuZCA9IHRydWUsIHJlc2NhbGUoKTtcclxuICB9O1xyXG5cclxuICBzY2FsZS5iYW5kd2lkdGggPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBiYW5kd2lkdGg7XHJcbiAgfTtcclxuXHJcbiAgc2NhbGUuc3RlcCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHN0ZXA7XHJcbiAgfTtcclxuXHJcbiAgc2NhbGUucm91bmQgPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyb3VuZCA9ICEhXywgcmVzY2FsZSgpKSA6IHJvdW5kO1xyXG4gIH07XHJcblxyXG4gIHNjYWxlLnBhZGRpbmcgPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRkaW5nSW5uZXIgPSBwYWRkaW5nT3V0ZXIgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBfKSksIHJlc2NhbGUoKSkgOiBwYWRkaW5nSW5uZXI7XHJcbiAgfTtcclxuXHJcbiAgc2NhbGUucGFkZGluZ0lubmVyID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZ0lubmVyID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgXykpLCByZXNjYWxlKCkpIDogcGFkZGluZ0lubmVyO1xyXG4gIH07XHJcblxyXG4gIHNjYWxlLnBhZGRpbmdPdXRlciA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmdPdXRlciA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIF8pKSwgcmVzY2FsZSgpKSA6IHBhZGRpbmdPdXRlcjtcclxuICB9O1xyXG5cclxuICBzY2FsZS5hbGlnbiA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGFsaWduID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgXykpLCByZXNjYWxlKCkpIDogYWxpZ247XHJcbiAgfTtcclxuXHJcbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIGJhbmQoKVxyXG4gICAgICAgIC5kb21haW4oZG9tYWluKCkpXHJcbiAgICAgICAgLnJhbmdlKHJhbmdlJCQxKVxyXG4gICAgICAgIC5yb3VuZChyb3VuZClcclxuICAgICAgICAucGFkZGluZ0lubmVyKHBhZGRpbmdJbm5lcilcclxuICAgICAgICAucGFkZGluZ091dGVyKHBhZGRpbmdPdXRlcilcclxuICAgICAgICAuYWxpZ24oYWxpZ24pO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiByZXNjYWxlKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBvaW50aXNoKHNjYWxlKSB7XHJcbiAgdmFyIGNvcHkgPSBzY2FsZS5jb3B5O1xyXG5cclxuICBzY2FsZS5wYWRkaW5nID0gc2NhbGUucGFkZGluZ091dGVyO1xyXG4gIGRlbGV0ZSBzY2FsZS5wYWRkaW5nSW5uZXI7XHJcbiAgZGVsZXRlIHNjYWxlLnBhZGRpbmdPdXRlcjtcclxuXHJcbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHBvaW50aXNoKGNvcHkoKSk7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIHNjYWxlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwb2ludCQxKCkge1xyXG4gIHJldHVybiBwb2ludGlzaChiYW5kKCkucGFkZGluZ0lubmVyKDEpKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY29uc3RhbnQkMTAoeCkge1xyXG4gIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB4O1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG51bWJlciQyKHgpIHtcclxuICByZXR1cm4gK3g7XHJcbn1cclxuXHJcbnZhciB1bml0ID0gWzAsIDFdO1xyXG5cclxuZnVuY3Rpb24gZGVpbnRlcnBvbGF0ZUxpbmVhcihhLCBiKSB7XHJcbiAgcmV0dXJuIChiIC09IChhID0gK2EpKVxyXG4gICAgICA/IGZ1bmN0aW9uKHgpIHsgcmV0dXJuICh4IC0gYSkgLyBiOyB9XHJcbiAgICAgIDogY29uc3RhbnQkMTAoYik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlaW50ZXJwb2xhdGVDbGFtcChkZWludGVycG9sYXRlKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgIHZhciBkID0gZGVpbnRlcnBvbGF0ZShhID0gK2EsIGIgPSArYik7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24oeCkgeyByZXR1cm4geCA8PSBhID8gMCA6IHggPj0gYiA/IDEgOiBkKHgpOyB9O1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlaW50ZXJwb2xhdGVDbGFtcChyZWludGVycG9sYXRlJCQxKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgIHZhciByID0gcmVpbnRlcnBvbGF0ZSQkMShhID0gK2EsIGIgPSArYik7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24odCkgeyByZXR1cm4gdCA8PSAwID8gYSA6IHQgPj0gMSA/IGIgOiByKHQpOyB9O1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGJpbWFwKGRvbWFpbiwgcmFuZ2UsIGRlaW50ZXJwb2xhdGUsIHJlaW50ZXJwb2xhdGUkJDEpIHtcclxuICB2YXIgZDAgPSBkb21haW5bMF0sIGQxID0gZG9tYWluWzFdLCByMCA9IHJhbmdlWzBdLCByMSA9IHJhbmdlWzFdO1xyXG4gIGlmIChkMSA8IGQwKSBkMCA9IGRlaW50ZXJwb2xhdGUoZDEsIGQwKSwgcjAgPSByZWludGVycG9sYXRlJCQxKHIxLCByMCk7XHJcbiAgZWxzZSBkMCA9IGRlaW50ZXJwb2xhdGUoZDAsIGQxKSwgcjAgPSByZWludGVycG9sYXRlJCQxKHIwLCByMSk7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHIwKGQwKHgpKTsgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gcG9seW1hcChkb21haW4sIHJhbmdlLCBkZWludGVycG9sYXRlLCByZWludGVycG9sYXRlJCQxKSB7XHJcbiAgdmFyIGogPSBNYXRoLm1pbihkb21haW4ubGVuZ3RoLCByYW5nZS5sZW5ndGgpIC0gMSxcclxuICAgICAgZCA9IG5ldyBBcnJheShqKSxcclxuICAgICAgciA9IG5ldyBBcnJheShqKSxcclxuICAgICAgaSA9IC0xO1xyXG5cclxuICAvLyBSZXZlcnNlIGRlc2NlbmRpbmcgZG9tYWlucy5cclxuICBpZiAoZG9tYWluW2pdIDwgZG9tYWluWzBdKSB7XHJcbiAgICBkb21haW4gPSBkb21haW4uc2xpY2UoKS5yZXZlcnNlKCk7XHJcbiAgICByYW5nZSA9IHJhbmdlLnNsaWNlKCkucmV2ZXJzZSgpO1xyXG4gIH1cclxuXHJcbiAgd2hpbGUgKCsraSA8IGopIHtcclxuICAgIGRbaV0gPSBkZWludGVycG9sYXRlKGRvbWFpbltpXSwgZG9tYWluW2kgKyAxXSk7XHJcbiAgICByW2ldID0gcmVpbnRlcnBvbGF0ZSQkMShyYW5nZVtpXSwgcmFuZ2VbaSArIDFdKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBmdW5jdGlvbih4KSB7XHJcbiAgICB2YXIgaSA9IGJpc2VjdFJpZ2h0KGRvbWFpbiwgeCwgMSwgaikgLSAxO1xyXG4gICAgcmV0dXJuIHJbaV0oZFtpXSh4KSk7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gY29weShzb3VyY2UsIHRhcmdldCkge1xyXG4gIHJldHVybiB0YXJnZXRcclxuICAgICAgLmRvbWFpbihzb3VyY2UuZG9tYWluKCkpXHJcbiAgICAgIC5yYW5nZShzb3VyY2UucmFuZ2UoKSlcclxuICAgICAgLmludGVycG9sYXRlKHNvdXJjZS5pbnRlcnBvbGF0ZSgpKVxyXG4gICAgICAuY2xhbXAoc291cmNlLmNsYW1wKCkpO1xyXG59XHJcblxyXG4vLyBkZWludGVycG9sYXRlKGEsIGIpKHgpIHRha2VzIGEgZG9tYWluIHZhbHVlIHggaW4gW2EsYl0gYW5kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGFyYW1ldGVyIHQgaW4gWzAsMV0uXHJcbi8vIHJlaW50ZXJwb2xhdGUoYSwgYikodCkgdGFrZXMgYSBwYXJhbWV0ZXIgdCBpbiBbMCwxXSBhbmQgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBkb21haW4gdmFsdWUgeCBpbiBbYSxiXS5cclxuZnVuY3Rpb24gY29udGludW91cyhkZWludGVycG9sYXRlLCByZWludGVycG9sYXRlJCQxKSB7XHJcbiAgdmFyIGRvbWFpbiA9IHVuaXQsXHJcbiAgICAgIHJhbmdlID0gdW5pdCxcclxuICAgICAgaW50ZXJwb2xhdGUkJDEgPSBpbnRlcnBvbGF0ZVZhbHVlLFxyXG4gICAgICBjbGFtcCA9IGZhbHNlLFxyXG4gICAgICBwaWVjZXdpc2UkJDEsXHJcbiAgICAgIG91dHB1dCxcclxuICAgICAgaW5wdXQ7XHJcblxyXG4gIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XHJcbiAgICBwaWVjZXdpc2UkJDEgPSBNYXRoLm1pbihkb21haW4ubGVuZ3RoLCByYW5nZS5sZW5ndGgpID4gMiA/IHBvbHltYXAgOiBiaW1hcDtcclxuICAgIG91dHB1dCA9IGlucHV0ID0gbnVsbDtcclxuICAgIHJldHVybiBzY2FsZTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcclxuICAgIHJldHVybiAob3V0cHV0IHx8IChvdXRwdXQgPSBwaWVjZXdpc2UkJDEoZG9tYWluLCByYW5nZSwgY2xhbXAgPyBkZWludGVycG9sYXRlQ2xhbXAoZGVpbnRlcnBvbGF0ZSkgOiBkZWludGVycG9sYXRlLCBpbnRlcnBvbGF0ZSQkMSkpKSgreCk7XHJcbiAgfVxyXG5cclxuICBzY2FsZS5pbnZlcnQgPSBmdW5jdGlvbih5KSB7XHJcbiAgICByZXR1cm4gKGlucHV0IHx8IChpbnB1dCA9IHBpZWNld2lzZSQkMShyYW5nZSwgZG9tYWluLCBkZWludGVycG9sYXRlTGluZWFyLCBjbGFtcCA/IHJlaW50ZXJwb2xhdGVDbGFtcChyZWludGVycG9sYXRlJCQxKSA6IHJlaW50ZXJwb2xhdGUkJDEpKSkoK3kpO1xyXG4gIH07XHJcblxyXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRvbWFpbiA9IG1hcCQyLmNhbGwoXywgbnVtYmVyJDIpLCByZXNjYWxlKCkpIDogZG9tYWluLnNsaWNlKCk7XHJcbiAgfTtcclxuXHJcbiAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYW5nZSA9IHNsaWNlJDUuY2FsbChfKSwgcmVzY2FsZSgpKSA6IHJhbmdlLnNsaWNlKCk7XHJcbiAgfTtcclxuXHJcbiAgc2NhbGUucmFuZ2VSb3VuZCA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiByYW5nZSA9IHNsaWNlJDUuY2FsbChfKSwgaW50ZXJwb2xhdGUkJDEgPSBpbnRlcnBvbGF0ZVJvdW5kLCByZXNjYWxlKCk7XHJcbiAgfTtcclxuXHJcbiAgc2NhbGUuY2xhbXAgPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjbGFtcCA9ICEhXywgcmVzY2FsZSgpKSA6IGNsYW1wO1xyXG4gIH07XHJcblxyXG4gIHNjYWxlLmludGVycG9sYXRlID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaW50ZXJwb2xhdGUkJDEgPSBfLCByZXNjYWxlKCkpIDogaW50ZXJwb2xhdGUkJDE7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIHJlc2NhbGUoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gdGlja0Zvcm1hdChkb21haW4sIGNvdW50LCBzcGVjaWZpZXIpIHtcclxuICB2YXIgc3RhcnQgPSBkb21haW5bMF0sXHJcbiAgICAgIHN0b3AgPSBkb21haW5bZG9tYWluLmxlbmd0aCAtIDFdLFxyXG4gICAgICBzdGVwID0gdGlja1N0ZXAoc3RhcnQsIHN0b3AsIGNvdW50ID09IG51bGwgPyAxMCA6IGNvdW50KSxcclxuICAgICAgcHJlY2lzaW9uO1xyXG4gIHNwZWNpZmllciA9IGZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIgPT0gbnVsbCA/IFwiLGZcIiA6IHNwZWNpZmllcik7XHJcbiAgc3dpdGNoIChzcGVjaWZpZXIudHlwZSkge1xyXG4gICAgY2FzZSBcInNcIjoge1xyXG4gICAgICB2YXIgdmFsdWUgPSBNYXRoLm1heChNYXRoLmFicyhzdGFydCksIE1hdGguYWJzKHN0b3ApKTtcclxuICAgICAgaWYgKHNwZWNpZmllci5wcmVjaXNpb24gPT0gbnVsbCAmJiAhaXNOYU4ocHJlY2lzaW9uID0gcHJlY2lzaW9uUHJlZml4KHN0ZXAsIHZhbHVlKSkpIHNwZWNpZmllci5wcmVjaXNpb24gPSBwcmVjaXNpb247XHJcbiAgICAgIHJldHVybiBkMy5mb3JtYXRQcmVmaXgoc3BlY2lmaWVyLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXNlIFwiXCI6XHJcbiAgICBjYXNlIFwiZVwiOlxyXG4gICAgY2FzZSBcImdcIjpcclxuICAgIGNhc2UgXCJwXCI6XHJcbiAgICBjYXNlIFwiclwiOiB7XHJcbiAgICAgIGlmIChzcGVjaWZpZXIucHJlY2lzaW9uID09IG51bGwgJiYgIWlzTmFOKHByZWNpc2lvbiA9IHByZWNpc2lvblJvdW5kKHN0ZXAsIE1hdGgubWF4KE1hdGguYWJzKHN0YXJ0KSwgTWF0aC5hYnMoc3RvcCkpKSkpIHNwZWNpZmllci5wcmVjaXNpb24gPSBwcmVjaXNpb24gLSAoc3BlY2lmaWVyLnR5cGUgPT09IFwiZVwiKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICBjYXNlIFwiZlwiOlxyXG4gICAgY2FzZSBcIiVcIjoge1xyXG4gICAgICBpZiAoc3BlY2lmaWVyLnByZWNpc2lvbiA9PSBudWxsICYmICFpc05hTihwcmVjaXNpb24gPSBwcmVjaXNpb25GaXhlZChzdGVwKSkpIHNwZWNpZmllci5wcmVjaXNpb24gPSBwcmVjaXNpb24gLSAoc3BlY2lmaWVyLnR5cGUgPT09IFwiJVwiKSAqIDI7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gZDMuZm9ybWF0KHNwZWNpZmllcik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxpbmVhcmlzaChzY2FsZSkge1xyXG4gIHZhciBkb21haW4gPSBzY2FsZS5kb21haW47XHJcblxyXG4gIHNjYWxlLnRpY2tzID0gZnVuY3Rpb24oY291bnQpIHtcclxuICAgIHZhciBkID0gZG9tYWluKCk7XHJcbiAgICByZXR1cm4gdGlja3MoZFswXSwgZFtkLmxlbmd0aCAtIDFdLCBjb3VudCA9PSBudWxsID8gMTAgOiBjb3VudCk7XHJcbiAgfTtcclxuXHJcbiAgc2NhbGUudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKGNvdW50LCBzcGVjaWZpZXIpIHtcclxuICAgIHJldHVybiB0aWNrRm9ybWF0KGRvbWFpbigpLCBjb3VudCwgc3BlY2lmaWVyKTtcclxuICB9O1xyXG5cclxuICBzY2FsZS5uaWNlID0gZnVuY3Rpb24oY291bnQpIHtcclxuICAgIGlmIChjb3VudCA9PSBudWxsKSBjb3VudCA9IDEwO1xyXG5cclxuICAgIHZhciBkID0gZG9tYWluKCksXHJcbiAgICAgICAgaTAgPSAwLFxyXG4gICAgICAgIGkxID0gZC5sZW5ndGggLSAxLFxyXG4gICAgICAgIHN0YXJ0ID0gZFtpMF0sXHJcbiAgICAgICAgc3RvcCA9IGRbaTFdLFxyXG4gICAgICAgIHN0ZXA7XHJcblxyXG4gICAgaWYgKHN0b3AgPCBzdGFydCkge1xyXG4gICAgICBzdGVwID0gc3RhcnQsIHN0YXJ0ID0gc3RvcCwgc3RvcCA9IHN0ZXA7XHJcbiAgICAgIHN0ZXAgPSBpMCwgaTAgPSBpMSwgaTEgPSBzdGVwO1xyXG4gICAgfVxyXG5cclxuICAgIHN0ZXAgPSB0aWNrSW5jcmVtZW50KHN0YXJ0LCBzdG9wLCBjb3VudCk7XHJcblxyXG4gICAgaWYgKHN0ZXAgPiAwKSB7XHJcbiAgICAgIHN0YXJ0ID0gTWF0aC5mbG9vcihzdGFydCAvIHN0ZXApICogc3RlcDtcclxuICAgICAgc3RvcCA9IE1hdGguY2VpbChzdG9wIC8gc3RlcCkgKiBzdGVwO1xyXG4gICAgICBzdGVwID0gdGlja0luY3JlbWVudChzdGFydCwgc3RvcCwgY291bnQpO1xyXG4gICAgfSBlbHNlIGlmIChzdGVwIDwgMCkge1xyXG4gICAgICBzdGFydCA9IE1hdGguY2VpbChzdGFydCAqIHN0ZXApIC8gc3RlcDtcclxuICAgICAgc3RvcCA9IE1hdGguZmxvb3Ioc3RvcCAqIHN0ZXApIC8gc3RlcDtcclxuICAgICAgc3RlcCA9IHRpY2tJbmNyZW1lbnQoc3RhcnQsIHN0b3AsIGNvdW50KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc3RlcCA+IDApIHtcclxuICAgICAgZFtpMF0gPSBNYXRoLmZsb29yKHN0YXJ0IC8gc3RlcCkgKiBzdGVwO1xyXG4gICAgICBkW2kxXSA9IE1hdGguY2VpbChzdG9wIC8gc3RlcCkgKiBzdGVwO1xyXG4gICAgICBkb21haW4oZCk7XHJcbiAgICB9IGVsc2UgaWYgKHN0ZXAgPCAwKSB7XHJcbiAgICAgIGRbaTBdID0gTWF0aC5jZWlsKHN0YXJ0ICogc3RlcCkgLyBzdGVwO1xyXG4gICAgICBkW2kxXSA9IE1hdGguZmxvb3Ioc3RvcCAqIHN0ZXApIC8gc3RlcDtcclxuICAgICAgZG9tYWluKGQpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzY2FsZTtcclxuICB9O1xyXG5cclxuICByZXR1cm4gc2NhbGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxpbmVhciQyKCkge1xyXG4gIHZhciBzY2FsZSA9IGNvbnRpbnVvdXMoZGVpbnRlcnBvbGF0ZUxpbmVhciwgcmVpbnRlcnBvbGF0ZSk7XHJcblxyXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBjb3B5KHNjYWxlLCBsaW5lYXIkMigpKTtcclxuICB9O1xyXG5cclxuICByZXR1cm4gbGluZWFyaXNoKHNjYWxlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaWRlbnRpdHkkNigpIHtcclxuICB2YXIgZG9tYWluID0gWzAsIDFdO1xyXG5cclxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XHJcbiAgICByZXR1cm4gK3g7XHJcbiAgfVxyXG5cclxuICBzY2FsZS5pbnZlcnQgPSBzY2FsZTtcclxuXHJcbiAgc2NhbGUuZG9tYWluID0gc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4gPSBtYXAkMi5jYWxsKF8sIG51bWJlciQyKSwgc2NhbGUpIDogZG9tYWluLnNsaWNlKCk7XHJcbiAgfTtcclxuXHJcbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIGlkZW50aXR5JDYoKS5kb21haW4oZG9tYWluKTtcclxuICB9O1xyXG5cclxuICByZXR1cm4gbGluZWFyaXNoKHNjYWxlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gbmljZShkb21haW4sIGludGVydmFsKSB7XHJcbiAgZG9tYWluID0gZG9tYWluLnNsaWNlKCk7XHJcblxyXG4gIHZhciBpMCA9IDAsXHJcbiAgICAgIGkxID0gZG9tYWluLmxlbmd0aCAtIDEsXHJcbiAgICAgIHgwID0gZG9tYWluW2kwXSxcclxuICAgICAgeDEgPSBkb21haW5baTFdLFxyXG4gICAgICB0O1xyXG5cclxuICBpZiAoeDEgPCB4MCkge1xyXG4gICAgdCA9IGkwLCBpMCA9IGkxLCBpMSA9IHQ7XHJcbiAgICB0ID0geDAsIHgwID0geDEsIHgxID0gdDtcclxuICB9XHJcblxyXG4gIGRvbWFpbltpMF0gPSBpbnRlcnZhbC5mbG9vcih4MCk7XHJcbiAgZG9tYWluW2kxXSA9IGludGVydmFsLmNlaWwoeDEpO1xyXG4gIHJldHVybiBkb21haW47XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlaW50ZXJwb2xhdGUoYSwgYikge1xyXG4gIHJldHVybiAoYiA9IE1hdGgubG9nKGIgLyBhKSlcclxuICAgICAgPyBmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLmxvZyh4IC8gYSkgLyBiOyB9XHJcbiAgICAgIDogY29uc3RhbnQkMTAoYik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlaW50ZXJwb2xhdGUkMShhLCBiKSB7XHJcbiAgcmV0dXJuIGEgPCAwXHJcbiAgICAgID8gZnVuY3Rpb24odCkgeyByZXR1cm4gLU1hdGgucG93KC1iLCB0KSAqIE1hdGgucG93KC1hLCAxIC0gdCk7IH1cclxuICAgICAgOiBmdW5jdGlvbih0KSB7IHJldHVybiBNYXRoLnBvdyhiLCB0KSAqIE1hdGgucG93KGEsIDEgLSB0KTsgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gcG93MTAoeCkge1xyXG4gIHJldHVybiBpc0Zpbml0ZSh4KSA/ICsoXCIxZVwiICsgeCkgOiB4IDwgMCA/IDAgOiB4O1xyXG59XHJcblxyXG5mdW5jdGlvbiBwb3dwKGJhc2UpIHtcclxuICByZXR1cm4gYmFzZSA9PT0gMTAgPyBwb3cxMFxyXG4gICAgICA6IGJhc2UgPT09IE1hdGguRSA/IE1hdGguZXhwXHJcbiAgICAgIDogZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5wb3coYmFzZSwgeCk7IH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxvZ3AoYmFzZSkge1xyXG4gIHJldHVybiBiYXNlID09PSBNYXRoLkUgPyBNYXRoLmxvZ1xyXG4gICAgICA6IGJhc2UgPT09IDEwICYmIE1hdGgubG9nMTBcclxuICAgICAgfHwgYmFzZSA9PT0gMiAmJiBNYXRoLmxvZzJcclxuICAgICAgfHwgKGJhc2UgPSBNYXRoLmxvZyhiYXNlKSwgZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5sb2coeCkgLyBiYXNlOyB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVmbGVjdChmKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcclxuICAgIHJldHVybiAtZigteCk7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gbG9nJDEoKSB7XHJcbiAgdmFyIHNjYWxlID0gY29udGludW91cyhkZWludGVycG9sYXRlLCByZWludGVycG9sYXRlJDEpLmRvbWFpbihbMSwgMTBdKSxcclxuICAgICAgZG9tYWluID0gc2NhbGUuZG9tYWluLFxyXG4gICAgICBiYXNlID0gMTAsXHJcbiAgICAgIGxvZ3MgPSBsb2dwKDEwKSxcclxuICAgICAgcG93cyA9IHBvd3AoMTApO1xyXG5cclxuICBmdW5jdGlvbiByZXNjYWxlKCkge1xyXG4gICAgbG9ncyA9IGxvZ3AoYmFzZSksIHBvd3MgPSBwb3dwKGJhc2UpO1xyXG4gICAgaWYgKGRvbWFpbigpWzBdIDwgMCkgbG9ncyA9IHJlZmxlY3QobG9ncyksIHBvd3MgPSByZWZsZWN0KHBvd3MpO1xyXG4gICAgcmV0dXJuIHNjYWxlO1xyXG4gIH1cclxuXHJcbiAgc2NhbGUuYmFzZSA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGJhc2UgPSArXywgcmVzY2FsZSgpKSA6IGJhc2U7XHJcbiAgfTtcclxuXHJcbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZG9tYWluKF8pLCByZXNjYWxlKCkpIDogZG9tYWluKCk7XHJcbiAgfTtcclxuXHJcbiAgc2NhbGUudGlja3MgPSBmdW5jdGlvbihjb3VudCkge1xyXG4gICAgdmFyIGQgPSBkb21haW4oKSxcclxuICAgICAgICB1ID0gZFswXSxcclxuICAgICAgICB2ID0gZFtkLmxlbmd0aCAtIDFdLFxyXG4gICAgICAgIHI7XHJcblxyXG4gICAgaWYgKHIgPSB2IDwgdSkgaSA9IHUsIHUgPSB2LCB2ID0gaTtcclxuXHJcbiAgICB2YXIgaSA9IGxvZ3ModSksXHJcbiAgICAgICAgaiA9IGxvZ3ModiksXHJcbiAgICAgICAgcCxcclxuICAgICAgICBrLFxyXG4gICAgICAgIHQsXHJcbiAgICAgICAgbiA9IGNvdW50ID09IG51bGwgPyAxMCA6ICtjb3VudCxcclxuICAgICAgICB6ID0gW107XHJcblxyXG4gICAgaWYgKCEoYmFzZSAlIDEpICYmIGogLSBpIDwgbikge1xyXG4gICAgICBpID0gTWF0aC5yb3VuZChpKSAtIDEsIGogPSBNYXRoLnJvdW5kKGopICsgMTtcclxuICAgICAgaWYgKHUgPiAwKSBmb3IgKDsgaSA8IGo7ICsraSkge1xyXG4gICAgICAgIGZvciAoayA9IDEsIHAgPSBwb3dzKGkpOyBrIDwgYmFzZTsgKytrKSB7XHJcbiAgICAgICAgICB0ID0gcCAqIGs7XHJcbiAgICAgICAgICBpZiAodCA8IHUpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgaWYgKHQgPiB2KSBicmVhaztcclxuICAgICAgICAgIHoucHVzaCh0KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBmb3IgKDsgaSA8IGo7ICsraSkge1xyXG4gICAgICAgIGZvciAoayA9IGJhc2UgLSAxLCBwID0gcG93cyhpKTsgayA+PSAxOyAtLWspIHtcclxuICAgICAgICAgIHQgPSBwICogaztcclxuICAgICAgICAgIGlmICh0IDwgdSkgY29udGludWU7XHJcbiAgICAgICAgICBpZiAodCA+IHYpIGJyZWFrO1xyXG4gICAgICAgICAgei5wdXNoKHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgeiA9IHRpY2tzKGksIGosIE1hdGgubWluKGogLSBpLCBuKSkubWFwKHBvd3MpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByID8gei5yZXZlcnNlKCkgOiB6O1xyXG4gIH07XHJcblxyXG4gIHNjYWxlLnRpY2tGb3JtYXQgPSBmdW5jdGlvbihjb3VudCwgc3BlY2lmaWVyKSB7XHJcbiAgICBpZiAoc3BlY2lmaWVyID09IG51bGwpIHNwZWNpZmllciA9IGJhc2UgPT09IDEwID8gXCIuMGVcIiA6IFwiLFwiO1xyXG4gICAgaWYgKHR5cGVvZiBzcGVjaWZpZXIgIT09IFwiZnVuY3Rpb25cIikgc3BlY2lmaWVyID0gZDMuZm9ybWF0KHNwZWNpZmllcik7XHJcbiAgICBpZiAoY291bnQgPT09IEluZmluaXR5KSByZXR1cm4gc3BlY2lmaWVyO1xyXG4gICAgaWYgKGNvdW50ID09IG51bGwpIGNvdW50ID0gMTA7XHJcbiAgICB2YXIgayA9IE1hdGgubWF4KDEsIGJhc2UgKiBjb3VudCAvIHNjYWxlLnRpY2tzKCkubGVuZ3RoKTsgLy8gVE9ETyBmYXN0IGVzdGltYXRlP1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGQpIHtcclxuICAgICAgdmFyIGkgPSBkIC8gcG93cyhNYXRoLnJvdW5kKGxvZ3MoZCkpKTtcclxuICAgICAgaWYgKGkgKiBiYXNlIDwgYmFzZSAtIDAuNSkgaSAqPSBiYXNlO1xyXG4gICAgICByZXR1cm4gaSA8PSBrID8gc3BlY2lmaWVyKGQpIDogXCJcIjtcclxuICAgIH07XHJcbiAgfTtcclxuXHJcbiAgc2NhbGUubmljZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIGRvbWFpbihuaWNlKGRvbWFpbigpLCB7XHJcbiAgICAgIGZsb29yOiBmdW5jdGlvbih4KSB7IHJldHVybiBwb3dzKE1hdGguZmxvb3IobG9ncyh4KSkpOyB9LFxyXG4gICAgICBjZWlsOiBmdW5jdGlvbih4KSB7IHJldHVybiBwb3dzKE1hdGguY2VpbChsb2dzKHgpKSk7IH1cclxuICAgIH0pKTtcclxuICB9O1xyXG5cclxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gY29weShzY2FsZSwgbG9nJDEoKS5iYXNlKGJhc2UpKTtcclxuICB9O1xyXG5cclxuICByZXR1cm4gc2NhbGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJhaXNlJDEoeCwgZXhwb25lbnQpIHtcclxuICByZXR1cm4geCA8IDAgPyAtTWF0aC5wb3coLXgsIGV4cG9uZW50KSA6IE1hdGgucG93KHgsIGV4cG9uZW50KTtcclxufVxyXG5cclxuZnVuY3Rpb24gcG93JDEoKSB7XHJcbiAgdmFyIGV4cG9uZW50ID0gMSxcclxuICAgICAgc2NhbGUgPSBjb250aW51b3VzKGRlaW50ZXJwb2xhdGUsIHJlaW50ZXJwb2xhdGUpLFxyXG4gICAgICBkb21haW4gPSBzY2FsZS5kb21haW47XHJcblxyXG4gIGZ1bmN0aW9uIGRlaW50ZXJwb2xhdGUoYSwgYikge1xyXG4gICAgcmV0dXJuIChiID0gcmFpc2UkMShiLCBleHBvbmVudCkgLSAoYSA9IHJhaXNlJDEoYSwgZXhwb25lbnQpKSlcclxuICAgICAgICA/IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIChyYWlzZSQxKHgsIGV4cG9uZW50KSAtIGEpIC8gYjsgfVxyXG4gICAgICAgIDogY29uc3RhbnQkMTAoYik7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByZWludGVycG9sYXRlKGEsIGIpIHtcclxuICAgIGIgPSByYWlzZSQxKGIsIGV4cG9uZW50KSAtIChhID0gcmFpc2UkMShhLCBleHBvbmVudCkpO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHsgcmV0dXJuIHJhaXNlJDEoYSArIGIgKiB0LCAxIC8gZXhwb25lbnQpOyB9O1xyXG4gIH1cclxuXHJcbiAgc2NhbGUuZXhwb25lbnQgPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChleHBvbmVudCA9ICtfLCBkb21haW4oZG9tYWluKCkpKSA6IGV4cG9uZW50O1xyXG4gIH07XHJcblxyXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBjb3B5KHNjYWxlLCBwb3ckMSgpLmV4cG9uZW50KGV4cG9uZW50KSk7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIGxpbmVhcmlzaChzY2FsZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNxcnQkMSgpIHtcclxuICByZXR1cm4gcG93JDEoKS5leHBvbmVudCgwLjUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBxdWFudGlsZSQkMSgpIHtcclxuICB2YXIgZG9tYWluID0gW10sXHJcbiAgICAgIHJhbmdlID0gW10sXHJcbiAgICAgIHRocmVzaG9sZHMgPSBbXTtcclxuXHJcbiAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcclxuICAgIHZhciBpID0gMCwgbiA9IE1hdGgubWF4KDEsIHJhbmdlLmxlbmd0aCk7XHJcbiAgICB0aHJlc2hvbGRzID0gbmV3IEFycmF5KG4gLSAxKTtcclxuICAgIHdoaWxlICgrK2kgPCBuKSB0aHJlc2hvbGRzW2kgLSAxXSA9IHRocmVzaG9sZChkb21haW4sIGkgLyBuKTtcclxuICAgIHJldHVybiBzY2FsZTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcclxuICAgIGlmICghaXNOYU4oeCA9ICt4KSkgcmV0dXJuIHJhbmdlW2Jpc2VjdFJpZ2h0KHRocmVzaG9sZHMsIHgpXTtcclxuICB9XHJcblxyXG4gIHNjYWxlLmludmVydEV4dGVudCA9IGZ1bmN0aW9uKHkpIHtcclxuICAgIHZhciBpID0gcmFuZ2UuaW5kZXhPZih5KTtcclxuICAgIHJldHVybiBpIDwgMCA/IFtOYU4sIE5hTl0gOiBbXHJcbiAgICAgIGkgPiAwID8gdGhyZXNob2xkc1tpIC0gMV0gOiBkb21haW5bMF0sXHJcbiAgICAgIGkgPCB0aHJlc2hvbGRzLmxlbmd0aCA/IHRocmVzaG9sZHNbaV0gOiBkb21haW5bZG9tYWluLmxlbmd0aCAtIDFdXHJcbiAgICBdO1xyXG4gIH07XHJcblxyXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpbi5zbGljZSgpO1xyXG4gICAgZG9tYWluID0gW107XHJcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IF8ubGVuZ3RoLCBkOyBpIDwgbjsgKytpKSBpZiAoZCA9IF9baV0sIGQgIT0gbnVsbCAmJiAhaXNOYU4oZCA9ICtkKSkgZG9tYWluLnB1c2goZCk7XHJcbiAgICBkb21haW4uc29ydChhc2NlbmRpbmcpO1xyXG4gICAgcmV0dXJuIHJlc2NhbGUoKTtcclxuICB9O1xyXG5cclxuICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhbmdlID0gc2xpY2UkNS5jYWxsKF8pLCByZXNjYWxlKCkpIDogcmFuZ2Uuc2xpY2UoKTtcclxuICB9O1xyXG5cclxuICBzY2FsZS5xdWFudGlsZXMgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aHJlc2hvbGRzLnNsaWNlKCk7XHJcbiAgfTtcclxuXHJcbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHF1YW50aWxlJCQxKClcclxuICAgICAgICAuZG9tYWluKGRvbWFpbilcclxuICAgICAgICAucmFuZ2UocmFuZ2UpO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBzY2FsZTtcclxufVxyXG5cclxuZnVuY3Rpb24gcXVhbnRpemUkMSgpIHtcclxuICB2YXIgeDAgPSAwLFxyXG4gICAgICB4MSA9IDEsXHJcbiAgICAgIG4gPSAxLFxyXG4gICAgICBkb21haW4gPSBbMC41XSxcclxuICAgICAgcmFuZ2UgPSBbMCwgMV07XHJcblxyXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcclxuICAgIGlmICh4IDw9IHgpIHJldHVybiByYW5nZVtiaXNlY3RSaWdodChkb21haW4sIHgsIDAsIG4pXTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XHJcbiAgICB2YXIgaSA9IC0xO1xyXG4gICAgZG9tYWluID0gbmV3IEFycmF5KG4pO1xyXG4gICAgd2hpbGUgKCsraSA8IG4pIGRvbWFpbltpXSA9ICgoaSArIDEpICogeDEgLSAoaSAtIG4pICogeDApIC8gKG4gKyAxKTtcclxuICAgIHJldHVybiBzY2FsZTtcclxuICB9XHJcblxyXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHgwID0gK19bMF0sIHgxID0gK19bMV0sIHJlc2NhbGUoKSkgOiBbeDAsIHgxXTtcclxuICB9O1xyXG5cclxuICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG4gPSAocmFuZ2UgPSBzbGljZSQ1LmNhbGwoXykpLmxlbmd0aCAtIDEsIHJlc2NhbGUoKSkgOiByYW5nZS5zbGljZSgpO1xyXG4gIH07XHJcblxyXG4gIHNjYWxlLmludmVydEV4dGVudCA9IGZ1bmN0aW9uKHkpIHtcclxuICAgIHZhciBpID0gcmFuZ2UuaW5kZXhPZih5KTtcclxuICAgIHJldHVybiBpIDwgMCA/IFtOYU4sIE5hTl1cclxuICAgICAgICA6IGkgPCAxID8gW3gwLCBkb21haW5bMF1dXHJcbiAgICAgICAgOiBpID49IG4gPyBbZG9tYWluW24gLSAxXSwgeDFdXHJcbiAgICAgICAgOiBbZG9tYWluW2kgLSAxXSwgZG9tYWluW2ldXTtcclxuICB9O1xyXG5cclxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gcXVhbnRpemUkMSgpXHJcbiAgICAgICAgLmRvbWFpbihbeDAsIHgxXSlcclxuICAgICAgICAucmFuZ2UocmFuZ2UpO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBsaW5lYXJpc2goc2NhbGUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiB0aHJlc2hvbGQkMSgpIHtcclxuICB2YXIgZG9tYWluID0gWzAuNV0sXHJcbiAgICAgIHJhbmdlID0gWzAsIDFdLFxyXG4gICAgICBuID0gMTtcclxuXHJcbiAgZnVuY3Rpb24gc2NhbGUoeCkge1xyXG4gICAgaWYgKHggPD0geCkgcmV0dXJuIHJhbmdlW2Jpc2VjdFJpZ2h0KGRvbWFpbiwgeCwgMCwgbildO1xyXG4gIH1cclxuXHJcbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZG9tYWluID0gc2xpY2UkNS5jYWxsKF8pLCBuID0gTWF0aC5taW4oZG9tYWluLmxlbmd0aCwgcmFuZ2UubGVuZ3RoIC0gMSksIHNjYWxlKSA6IGRvbWFpbi5zbGljZSgpO1xyXG4gIH07XHJcblxyXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFuZ2UgPSBzbGljZSQ1LmNhbGwoXyksIG4gPSBNYXRoLm1pbihkb21haW4ubGVuZ3RoLCByYW5nZS5sZW5ndGggLSAxKSwgc2NhbGUpIDogcmFuZ2Uuc2xpY2UoKTtcclxuICB9O1xyXG5cclxuICBzY2FsZS5pbnZlcnRFeHRlbnQgPSBmdW5jdGlvbih5KSB7XHJcbiAgICB2YXIgaSA9IHJhbmdlLmluZGV4T2YoeSk7XHJcbiAgICByZXR1cm4gW2RvbWFpbltpIC0gMV0sIGRvbWFpbltpXV07XHJcbiAgfTtcclxuXHJcbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRocmVzaG9sZCQxKClcclxuICAgICAgICAuZG9tYWluKGRvbWFpbilcclxuICAgICAgICAucmFuZ2UocmFuZ2UpO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBzY2FsZTtcclxufVxyXG5cclxudmFyIHQwJDEgPSBuZXcgRGF0ZSxcclxuICAgIHQxJDEgPSBuZXcgRGF0ZTtcclxuXHJcbmZ1bmN0aW9uIG5ld0ludGVydmFsKGZsb29yaSwgb2Zmc2V0aSwgY291bnQsIGZpZWxkKSB7XHJcblxyXG4gIGZ1bmN0aW9uIGludGVydmFsKGRhdGUpIHtcclxuICAgIHJldHVybiBmbG9vcmkoZGF0ZSA9IG5ldyBEYXRlKCtkYXRlKSksIGRhdGU7XHJcbiAgfVxyXG5cclxuICBpbnRlcnZhbC5mbG9vciA9IGludGVydmFsO1xyXG5cclxuICBpbnRlcnZhbC5jZWlsID0gZnVuY3Rpb24oZGF0ZSkge1xyXG4gICAgcmV0dXJuIGZsb29yaShkYXRlID0gbmV3IERhdGUoZGF0ZSAtIDEpKSwgb2Zmc2V0aShkYXRlLCAxKSwgZmxvb3JpKGRhdGUpLCBkYXRlO1xyXG4gIH07XHJcblxyXG4gIGludGVydmFsLnJvdW5kID0gZnVuY3Rpb24oZGF0ZSkge1xyXG4gICAgdmFyIGQwID0gaW50ZXJ2YWwoZGF0ZSksXHJcbiAgICAgICAgZDEgPSBpbnRlcnZhbC5jZWlsKGRhdGUpO1xyXG4gICAgcmV0dXJuIGRhdGUgLSBkMCA8IGQxIC0gZGF0ZSA/IGQwIDogZDE7XHJcbiAgfTtcclxuXHJcbiAgaW50ZXJ2YWwub2Zmc2V0ID0gZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xyXG4gICAgcmV0dXJuIG9mZnNldGkoZGF0ZSA9IG5ldyBEYXRlKCtkYXRlKSwgc3RlcCA9PSBudWxsID8gMSA6IE1hdGguZmxvb3Ioc3RlcCkpLCBkYXRlO1xyXG4gIH07XHJcblxyXG4gIGludGVydmFsLnJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcclxuICAgIHZhciByYW5nZSA9IFtdLCBwcmV2aW91cztcclxuICAgIHN0YXJ0ID0gaW50ZXJ2YWwuY2VpbChzdGFydCk7XHJcbiAgICBzdGVwID0gc3RlcCA9PSBudWxsID8gMSA6IE1hdGguZmxvb3Ioc3RlcCk7XHJcbiAgICBpZiAoIShzdGFydCA8IHN0b3ApIHx8ICEoc3RlcCA+IDApKSByZXR1cm4gcmFuZ2U7IC8vIGFsc28gaGFuZGxlcyBJbnZhbGlkIERhdGVcclxuICAgIGRvIHJhbmdlLnB1c2gocHJldmlvdXMgPSBuZXcgRGF0ZSgrc3RhcnQpKSwgb2Zmc2V0aShzdGFydCwgc3RlcCksIGZsb29yaShzdGFydCk7XHJcbiAgICB3aGlsZSAocHJldmlvdXMgPCBzdGFydCAmJiBzdGFydCA8IHN0b3ApO1xyXG4gICAgcmV0dXJuIHJhbmdlO1xyXG4gIH07XHJcblxyXG4gIGludGVydmFsLmZpbHRlciA9IGZ1bmN0aW9uKHRlc3QpIHtcclxuICAgIHJldHVybiBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XHJcbiAgICAgIGlmIChkYXRlID49IGRhdGUpIHdoaWxlIChmbG9vcmkoZGF0ZSksICF0ZXN0KGRhdGUpKSBkYXRlLnNldFRpbWUoZGF0ZSAtIDEpO1xyXG4gICAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xyXG4gICAgICBpZiAoZGF0ZSA+PSBkYXRlKSB7XHJcbiAgICAgICAgaWYgKHN0ZXAgPCAwKSB3aGlsZSAoKytzdGVwIDw9IDApIHtcclxuICAgICAgICAgIHdoaWxlIChvZmZzZXRpKGRhdGUsIC0xKSwgIXRlc3QoZGF0ZSkpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHlcclxuICAgICAgICB9IGVsc2Ugd2hpbGUgKC0tc3RlcCA+PSAwKSB7XHJcbiAgICAgICAgICB3aGlsZSAob2Zmc2V0aShkYXRlLCArMSksICF0ZXN0KGRhdGUpKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICBpZiAoY291bnQpIHtcclxuICAgIGludGVydmFsLmNvdW50ID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xyXG4gICAgICB0MCQxLnNldFRpbWUoK3N0YXJ0KSwgdDEkMS5zZXRUaW1lKCtlbmQpO1xyXG4gICAgICBmbG9vcmkodDAkMSksIGZsb29yaSh0MSQxKTtcclxuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoY291bnQodDAkMSwgdDEkMSkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBpbnRlcnZhbC5ldmVyeSA9IGZ1bmN0aW9uKHN0ZXApIHtcclxuICAgICAgc3RlcCA9IE1hdGguZmxvb3Ioc3RlcCk7XHJcbiAgICAgIHJldHVybiAhaXNGaW5pdGUoc3RlcCkgfHwgIShzdGVwID4gMCkgPyBudWxsXHJcbiAgICAgICAgICA6ICEoc3RlcCA+IDEpID8gaW50ZXJ2YWxcclxuICAgICAgICAgIDogaW50ZXJ2YWwuZmlsdGVyKGZpZWxkXHJcbiAgICAgICAgICAgICAgPyBmdW5jdGlvbihkKSB7IHJldHVybiBmaWVsZChkKSAlIHN0ZXAgPT09IDA7IH1cclxuICAgICAgICAgICAgICA6IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGludGVydmFsLmNvdW50KDAsIGQpICUgc3RlcCA9PT0gMDsgfSk7XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGludGVydmFsO1xyXG59XHJcblxyXG52YXIgbWlsbGlzZWNvbmQgPSBuZXdJbnRlcnZhbChmdW5jdGlvbigpIHtcclxuICAvLyBub29wXHJcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcclxuICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwKTtcclxufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xyXG4gIHJldHVybiBlbmQgLSBzdGFydDtcclxufSk7XHJcblxyXG4vLyBBbiBvcHRpbWl6ZWQgaW1wbGVtZW50YXRpb24gZm9yIHRoaXMgc2ltcGxlIGNhc2UuXHJcbm1pbGxpc2Vjb25kLmV2ZXJ5ID0gZnVuY3Rpb24oaykge1xyXG4gIGsgPSBNYXRoLmZsb29yKGspO1xyXG4gIGlmICghaXNGaW5pdGUoaykgfHwgIShrID4gMCkpIHJldHVybiBudWxsO1xyXG4gIGlmICghKGsgPiAxKSkgcmV0dXJuIG1pbGxpc2Vjb25kO1xyXG4gIHJldHVybiBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XHJcbiAgICBkYXRlLnNldFRpbWUoTWF0aC5mbG9vcihkYXRlIC8gaykgKiBrKTtcclxuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XHJcbiAgICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwICogayk7XHJcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xyXG4gICAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyBrO1xyXG4gIH0pO1xyXG59O1xyXG52YXIgbWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmQucmFuZ2U7XHJcblxyXG52YXIgZHVyYXRpb25TZWNvbmQgPSAxZTM7XHJcbnZhciBkdXJhdGlvbk1pbnV0ZSA9IDZlNDtcclxudmFyIGR1cmF0aW9uSG91ciA9IDM2ZTU7XHJcbnZhciBkdXJhdGlvbkRheSA9IDg2NGU1O1xyXG52YXIgZHVyYXRpb25XZWVrID0gNjA0OGU1O1xyXG5cclxudmFyIHNlY29uZCA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcclxuICBkYXRlLnNldFRpbWUoTWF0aC5mbG9vcihkYXRlIC8gZHVyYXRpb25TZWNvbmQpICogZHVyYXRpb25TZWNvbmQpO1xyXG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XHJcbiAgZGF0ZS5zZXRUaW1lKCtkYXRlICsgc3RlcCAqIGR1cmF0aW9uU2Vjb25kKTtcclxufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xyXG4gIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gZHVyYXRpb25TZWNvbmQ7XHJcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcclxuICByZXR1cm4gZGF0ZS5nZXRVVENTZWNvbmRzKCk7XHJcbn0pO1xyXG52YXIgc2Vjb25kcyA9IHNlY29uZC5yYW5nZTtcclxuXHJcbnZhciBtaW51dGUgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XHJcbiAgZGF0ZS5zZXRUaW1lKE1hdGguZmxvb3IoZGF0ZSAvIGR1cmF0aW9uTWludXRlKSAqIGR1cmF0aW9uTWludXRlKTtcclxufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xyXG4gIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXAgKiBkdXJhdGlvbk1pbnV0ZSk7XHJcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcclxuICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIGR1cmF0aW9uTWludXRlO1xyXG59LCBmdW5jdGlvbihkYXRlKSB7XHJcbiAgcmV0dXJuIGRhdGUuZ2V0TWludXRlcygpO1xyXG59KTtcclxudmFyIG1pbnV0ZXMgPSBtaW51dGUucmFuZ2U7XHJcblxyXG52YXIgaG91ciA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcclxuICB2YXIgb2Zmc2V0ID0gZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpICogZHVyYXRpb25NaW51dGUgJSBkdXJhdGlvbkhvdXI7XHJcbiAgaWYgKG9mZnNldCA8IDApIG9mZnNldCArPSBkdXJhdGlvbkhvdXI7XHJcbiAgZGF0ZS5zZXRUaW1lKE1hdGguZmxvb3IoKCtkYXRlIC0gb2Zmc2V0KSAvIGR1cmF0aW9uSG91cikgKiBkdXJhdGlvbkhvdXIgKyBvZmZzZXQpO1xyXG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XHJcbiAgZGF0ZS5zZXRUaW1lKCtkYXRlICsgc3RlcCAqIGR1cmF0aW9uSG91cik7XHJcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcclxuICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIGR1cmF0aW9uSG91cjtcclxufSwgZnVuY3Rpb24oZGF0ZSkge1xyXG4gIHJldHVybiBkYXRlLmdldEhvdXJzKCk7XHJcbn0pO1xyXG52YXIgaG91cnMgPSBob3VyLnJhbmdlO1xyXG5cclxudmFyIGRheSA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcclxuICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xyXG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XHJcbiAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgc3RlcCk7XHJcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcclxuICByZXR1cm4gKGVuZCAtIHN0YXJ0IC0gKGVuZC5nZXRUaW1lem9uZU9mZnNldCgpIC0gc3RhcnQuZ2V0VGltZXpvbmVPZmZzZXQoKSkgKiBkdXJhdGlvbk1pbnV0ZSkgLyBkdXJhdGlvbkRheTtcclxufSwgZnVuY3Rpb24oZGF0ZSkge1xyXG4gIHJldHVybiBkYXRlLmdldERhdGUoKSAtIDE7XHJcbn0pO1xyXG52YXIgZGF5cyA9IGRheS5yYW5nZTtcclxuXHJcbmZ1bmN0aW9uIHdlZWtkYXkoaSkge1xyXG4gIHJldHVybiBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XHJcbiAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgLSAoZGF0ZS5nZXREYXkoKSArIDcgLSBpKSAlIDcpO1xyXG4gICAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcclxuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XHJcbiAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyBzdGVwICogNyk7XHJcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xyXG4gICAgcmV0dXJuIChlbmQgLSBzdGFydCAtIChlbmQuZ2V0VGltZXpvbmVPZmZzZXQoKSAtIHN0YXJ0LmdldFRpbWV6b25lT2Zmc2V0KCkpICogZHVyYXRpb25NaW51dGUpIC8gZHVyYXRpb25XZWVrO1xyXG4gIH0pO1xyXG59XHJcblxyXG52YXIgc3VuZGF5ID0gd2Vla2RheSgwKTtcclxudmFyIG1vbmRheSA9IHdlZWtkYXkoMSk7XHJcbnZhciB0dWVzZGF5ID0gd2Vla2RheSgyKTtcclxudmFyIHdlZG5lc2RheSA9IHdlZWtkYXkoMyk7XHJcbnZhciB0aHVyc2RheSA9IHdlZWtkYXkoNCk7XHJcbnZhciBmcmlkYXkgPSB3ZWVrZGF5KDUpO1xyXG52YXIgc2F0dXJkYXkgPSB3ZWVrZGF5KDYpO1xyXG5cclxudmFyIHN1bmRheXMgPSBzdW5kYXkucmFuZ2U7XHJcbnZhciBtb25kYXlzID0gbW9uZGF5LnJhbmdlO1xyXG52YXIgdHVlc2RheXMgPSB0dWVzZGF5LnJhbmdlO1xyXG52YXIgd2VkbmVzZGF5cyA9IHdlZG5lc2RheS5yYW5nZTtcclxudmFyIHRodXJzZGF5cyA9IHRodXJzZGF5LnJhbmdlO1xyXG52YXIgZnJpZGF5cyA9IGZyaWRheS5yYW5nZTtcclxudmFyIHNhdHVyZGF5cyA9IHNhdHVyZGF5LnJhbmdlO1xyXG5cclxudmFyIG1vbnRoID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xyXG4gIGRhdGUuc2V0RGF0ZSgxKTtcclxuICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xyXG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XHJcbiAgZGF0ZS5zZXRNb250aChkYXRlLmdldE1vbnRoKCkgKyBzdGVwKTtcclxufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xyXG4gIHJldHVybiBlbmQuZ2V0TW9udGgoKSAtIHN0YXJ0LmdldE1vbnRoKCkgKyAoZW5kLmdldEZ1bGxZZWFyKCkgLSBzdGFydC5nZXRGdWxsWWVhcigpKSAqIDEyO1xyXG59LCBmdW5jdGlvbihkYXRlKSB7XHJcbiAgcmV0dXJuIGRhdGUuZ2V0TW9udGgoKTtcclxufSk7XHJcbnZhciBtb250aHMgPSBtb250aC5yYW5nZTtcclxuXHJcbnZhciB5ZWFyID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xyXG4gIGRhdGUuc2V0TW9udGgoMCwgMSk7XHJcbiAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcclxufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xyXG4gIGRhdGUuc2V0RnVsbFllYXIoZGF0ZS5nZXRGdWxsWWVhcigpICsgc3RlcCk7XHJcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcclxuICByZXR1cm4gZW5kLmdldEZ1bGxZZWFyKCkgLSBzdGFydC5nZXRGdWxsWWVhcigpO1xyXG59LCBmdW5jdGlvbihkYXRlKSB7XHJcbiAgcmV0dXJuIGRhdGUuZ2V0RnVsbFllYXIoKTtcclxufSk7XHJcblxyXG4vLyBBbiBvcHRpbWl6ZWQgaW1wbGVtZW50YXRpb24gZm9yIHRoaXMgc2ltcGxlIGNhc2UuXHJcbnllYXIuZXZlcnkgPSBmdW5jdGlvbihrKSB7XHJcbiAgcmV0dXJuICFpc0Zpbml0ZShrID0gTWF0aC5mbG9vcihrKSkgfHwgIShrID4gMCkgPyBudWxsIDogbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xyXG4gICAgZGF0ZS5zZXRGdWxsWWVhcihNYXRoLmZsb29yKGRhdGUuZ2V0RnVsbFllYXIoKSAvIGspICogayk7XHJcbiAgICBkYXRlLnNldE1vbnRoKDAsIDEpO1xyXG4gICAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcclxuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XHJcbiAgICBkYXRlLnNldEZ1bGxZZWFyKGRhdGUuZ2V0RnVsbFllYXIoKSArIHN0ZXAgKiBrKTtcclxuICB9KTtcclxufTtcclxudmFyIHllYXJzID0geWVhci5yYW5nZTtcclxuXHJcbnZhciB1dGNNaW51dGUgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XHJcbiAgZGF0ZS5zZXRVVENTZWNvbmRzKDAsIDApO1xyXG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XHJcbiAgZGF0ZS5zZXRUaW1lKCtkYXRlICsgc3RlcCAqIGR1cmF0aW9uTWludXRlKTtcclxufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xyXG4gIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gZHVyYXRpb25NaW51dGU7XHJcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcclxuICByZXR1cm4gZGF0ZS5nZXRVVENNaW51dGVzKCk7XHJcbn0pO1xyXG52YXIgdXRjTWludXRlcyA9IHV0Y01pbnV0ZS5yYW5nZTtcclxuXHJcbnZhciB1dGNIb3VyID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xyXG4gIGRhdGUuc2V0VVRDTWludXRlcygwLCAwLCAwKTtcclxufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xyXG4gIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXAgKiBkdXJhdGlvbkhvdXIpO1xyXG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XHJcbiAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyBkdXJhdGlvbkhvdXI7XHJcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcclxuICByZXR1cm4gZGF0ZS5nZXRVVENIb3VycygpO1xyXG59KTtcclxudmFyIHV0Y0hvdXJzID0gdXRjSG91ci5yYW5nZTtcclxuXHJcbnZhciB1dGNEYXkgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XHJcbiAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcclxufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xyXG4gIGRhdGUuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSArIHN0ZXApO1xyXG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XHJcbiAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyBkdXJhdGlvbkRheTtcclxufSwgZnVuY3Rpb24oZGF0ZSkge1xyXG4gIHJldHVybiBkYXRlLmdldFVUQ0RhdGUoKSAtIDE7XHJcbn0pO1xyXG52YXIgdXRjRGF5cyA9IHV0Y0RheS5yYW5nZTtcclxuXHJcbmZ1bmN0aW9uIHV0Y1dlZWtkYXkoaSkge1xyXG4gIHJldHVybiBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XHJcbiAgICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgLSAoZGF0ZS5nZXRVVENEYXkoKSArIDcgLSBpKSAlIDcpO1xyXG4gICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcclxuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XHJcbiAgICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgKyBzdGVwICogNyk7XHJcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xyXG4gICAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyBkdXJhdGlvbldlZWs7XHJcbiAgfSk7XHJcbn1cclxuXHJcbnZhciB1dGNTdW5kYXkgPSB1dGNXZWVrZGF5KDApO1xyXG52YXIgdXRjTW9uZGF5ID0gdXRjV2Vla2RheSgxKTtcclxudmFyIHV0Y1R1ZXNkYXkgPSB1dGNXZWVrZGF5KDIpO1xyXG52YXIgdXRjV2VkbmVzZGF5ID0gdXRjV2Vla2RheSgzKTtcclxudmFyIHV0Y1RodXJzZGF5ID0gdXRjV2Vla2RheSg0KTtcclxudmFyIHV0Y0ZyaWRheSA9IHV0Y1dlZWtkYXkoNSk7XHJcbnZhciB1dGNTYXR1cmRheSA9IHV0Y1dlZWtkYXkoNik7XHJcblxyXG52YXIgdXRjU3VuZGF5cyA9IHV0Y1N1bmRheS5yYW5nZTtcclxudmFyIHV0Y01vbmRheXMgPSB1dGNNb25kYXkucmFuZ2U7XHJcbnZhciB1dGNUdWVzZGF5cyA9IHV0Y1R1ZXNkYXkucmFuZ2U7XHJcbnZhciB1dGNXZWRuZXNkYXlzID0gdXRjV2VkbmVzZGF5LnJhbmdlO1xyXG52YXIgdXRjVGh1cnNkYXlzID0gdXRjVGh1cnNkYXkucmFuZ2U7XHJcbnZhciB1dGNGcmlkYXlzID0gdXRjRnJpZGF5LnJhbmdlO1xyXG52YXIgdXRjU2F0dXJkYXlzID0gdXRjU2F0dXJkYXkucmFuZ2U7XHJcblxyXG52YXIgdXRjTW9udGggPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XHJcbiAgZGF0ZS5zZXRVVENEYXRlKDEpO1xyXG4gIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XHJcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcclxuICBkYXRlLnNldFVUQ01vbnRoKGRhdGUuZ2V0VVRDTW9udGgoKSArIHN0ZXApO1xyXG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XHJcbiAgcmV0dXJuIGVuZC5nZXRVVENNb250aCgpIC0gc3RhcnQuZ2V0VVRDTW9udGgoKSArIChlbmQuZ2V0VVRDRnVsbFllYXIoKSAtIHN0YXJ0LmdldFVUQ0Z1bGxZZWFyKCkpICogMTI7XHJcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcclxuICByZXR1cm4gZGF0ZS5nZXRVVENNb250aCgpO1xyXG59KTtcclxudmFyIHV0Y01vbnRocyA9IHV0Y01vbnRoLnJhbmdlO1xyXG5cclxudmFyIHV0Y1llYXIgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XHJcbiAgZGF0ZS5zZXRVVENNb250aCgwLCAxKTtcclxuICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xyXG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XHJcbiAgZGF0ZS5zZXRVVENGdWxsWWVhcihkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgKyBzdGVwKTtcclxufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xyXG4gIHJldHVybiBlbmQuZ2V0VVRDRnVsbFllYXIoKSAtIHN0YXJ0LmdldFVUQ0Z1bGxZZWFyKCk7XHJcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcclxuICByZXR1cm4gZGF0ZS5nZXRVVENGdWxsWWVhcigpO1xyXG59KTtcclxuXHJcbi8vIEFuIG9wdGltaXplZCBpbXBsZW1lbnRhdGlvbiBmb3IgdGhpcyBzaW1wbGUgY2FzZS5cclxudXRjWWVhci5ldmVyeSA9IGZ1bmN0aW9uKGspIHtcclxuICByZXR1cm4gIWlzRmluaXRlKGsgPSBNYXRoLmZsb29yKGspKSB8fCAhKGsgPiAwKSA/IG51bGwgOiBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XHJcbiAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKE1hdGguZmxvb3IoZGF0ZS5nZXRVVENGdWxsWWVhcigpIC8gaykgKiBrKTtcclxuICAgIGRhdGUuc2V0VVRDTW9udGgoMCwgMSk7XHJcbiAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xyXG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcclxuICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoZGF0ZS5nZXRVVENGdWxsWWVhcigpICsgc3RlcCAqIGspO1xyXG4gIH0pO1xyXG59O1xyXG52YXIgdXRjWWVhcnMgPSB1dGNZZWFyLnJhbmdlO1xyXG5cclxuZnVuY3Rpb24gbG9jYWxEYXRlKGQpIHtcclxuICBpZiAoMCA8PSBkLnkgJiYgZC55IDwgMTAwKSB7XHJcbiAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKC0xLCBkLm0sIGQuZCwgZC5ILCBkLk0sIGQuUywgZC5MKTtcclxuICAgIGRhdGUuc2V0RnVsbFllYXIoZC55KTtcclxuICAgIHJldHVybiBkYXRlO1xyXG4gIH1cclxuICByZXR1cm4gbmV3IERhdGUoZC55LCBkLm0sIGQuZCwgZC5ILCBkLk0sIGQuUywgZC5MKTtcclxufVxyXG5cclxuZnVuY3Rpb24gdXRjRGF0ZShkKSB7XHJcbiAgaWYgKDAgPD0gZC55ICYmIGQueSA8IDEwMCkge1xyXG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQygtMSwgZC5tLCBkLmQsIGQuSCwgZC5NLCBkLlMsIGQuTCkpO1xyXG4gICAgZGF0ZS5zZXRVVENGdWxsWWVhcihkLnkpO1xyXG4gICAgcmV0dXJuIGRhdGU7XHJcbiAgfVxyXG4gIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyhkLnksIGQubSwgZC5kLCBkLkgsIGQuTSwgZC5TLCBkLkwpKTtcclxufVxyXG5cclxuZnVuY3Rpb24gbmV3WWVhcih5KSB7XHJcbiAgcmV0dXJuIHt5OiB5LCBtOiAwLCBkOiAxLCBIOiAwLCBNOiAwLCBTOiAwLCBMOiAwfTtcclxufVxyXG5cclxuZnVuY3Rpb24gZm9ybWF0TG9jYWxlJDEobG9jYWxlKSB7XHJcbiAgdmFyIGxvY2FsZV9kYXRlVGltZSA9IGxvY2FsZS5kYXRlVGltZSxcclxuICAgICAgbG9jYWxlX2RhdGUgPSBsb2NhbGUuZGF0ZSxcclxuICAgICAgbG9jYWxlX3RpbWUgPSBsb2NhbGUudGltZSxcclxuICAgICAgbG9jYWxlX3BlcmlvZHMgPSBsb2NhbGUucGVyaW9kcyxcclxuICAgICAgbG9jYWxlX3dlZWtkYXlzID0gbG9jYWxlLmRheXMsXHJcbiAgICAgIGxvY2FsZV9zaG9ydFdlZWtkYXlzID0gbG9jYWxlLnNob3J0RGF5cyxcclxuICAgICAgbG9jYWxlX21vbnRocyA9IGxvY2FsZS5tb250aHMsXHJcbiAgICAgIGxvY2FsZV9zaG9ydE1vbnRocyA9IGxvY2FsZS5zaG9ydE1vbnRocztcclxuXHJcbiAgdmFyIHBlcmlvZFJlID0gZm9ybWF0UmUobG9jYWxlX3BlcmlvZHMpLFxyXG4gICAgICBwZXJpb2RMb29rdXAgPSBmb3JtYXRMb29rdXAobG9jYWxlX3BlcmlvZHMpLFxyXG4gICAgICB3ZWVrZGF5UmUgPSBmb3JtYXRSZShsb2NhbGVfd2Vla2RheXMpLFxyXG4gICAgICB3ZWVrZGF5TG9va3VwID0gZm9ybWF0TG9va3VwKGxvY2FsZV93ZWVrZGF5cyksXHJcbiAgICAgIHNob3J0V2Vla2RheVJlID0gZm9ybWF0UmUobG9jYWxlX3Nob3J0V2Vla2RheXMpLFxyXG4gICAgICBzaG9ydFdlZWtkYXlMb29rdXAgPSBmb3JtYXRMb29rdXAobG9jYWxlX3Nob3J0V2Vla2RheXMpLFxyXG4gICAgICBtb250aFJlID0gZm9ybWF0UmUobG9jYWxlX21vbnRocyksXHJcbiAgICAgIG1vbnRoTG9va3VwID0gZm9ybWF0TG9va3VwKGxvY2FsZV9tb250aHMpLFxyXG4gICAgICBzaG9ydE1vbnRoUmUgPSBmb3JtYXRSZShsb2NhbGVfc2hvcnRNb250aHMpLFxyXG4gICAgICBzaG9ydE1vbnRoTG9va3VwID0gZm9ybWF0TG9va3VwKGxvY2FsZV9zaG9ydE1vbnRocyk7XHJcblxyXG4gIHZhciBmb3JtYXRzID0ge1xyXG4gICAgXCJhXCI6IGZvcm1hdFNob3J0V2Vla2RheSxcclxuICAgIFwiQVwiOiBmb3JtYXRXZWVrZGF5LFxyXG4gICAgXCJiXCI6IGZvcm1hdFNob3J0TW9udGgsXHJcbiAgICBcIkJcIjogZm9ybWF0TW9udGgsXHJcbiAgICBcImNcIjogbnVsbCxcclxuICAgIFwiZFwiOiBmb3JtYXREYXlPZk1vbnRoLFxyXG4gICAgXCJlXCI6IGZvcm1hdERheU9mTW9udGgsXHJcbiAgICBcImZcIjogZm9ybWF0TWljcm9zZWNvbmRzLFxyXG4gICAgXCJIXCI6IGZvcm1hdEhvdXIyNCxcclxuICAgIFwiSVwiOiBmb3JtYXRIb3VyMTIsXHJcbiAgICBcImpcIjogZm9ybWF0RGF5T2ZZZWFyLFxyXG4gICAgXCJMXCI6IGZvcm1hdE1pbGxpc2Vjb25kcyxcclxuICAgIFwibVwiOiBmb3JtYXRNb250aE51bWJlcixcclxuICAgIFwiTVwiOiBmb3JtYXRNaW51dGVzLFxyXG4gICAgXCJwXCI6IGZvcm1hdFBlcmlvZCxcclxuICAgIFwiUVwiOiBmb3JtYXRVbml4VGltZXN0YW1wLFxyXG4gICAgXCJzXCI6IGZvcm1hdFVuaXhUaW1lc3RhbXBTZWNvbmRzLFxyXG4gICAgXCJTXCI6IGZvcm1hdFNlY29uZHMsXHJcbiAgICBcInVcIjogZm9ybWF0V2Vla2RheU51bWJlck1vbmRheSxcclxuICAgIFwiVVwiOiBmb3JtYXRXZWVrTnVtYmVyU3VuZGF5LFxyXG4gICAgXCJWXCI6IGZvcm1hdFdlZWtOdW1iZXJJU08sXHJcbiAgICBcIndcIjogZm9ybWF0V2Vla2RheU51bWJlclN1bmRheSxcclxuICAgIFwiV1wiOiBmb3JtYXRXZWVrTnVtYmVyTW9uZGF5LFxyXG4gICAgXCJ4XCI6IG51bGwsXHJcbiAgICBcIlhcIjogbnVsbCxcclxuICAgIFwieVwiOiBmb3JtYXRZZWFyLFxyXG4gICAgXCJZXCI6IGZvcm1hdEZ1bGxZZWFyLFxyXG4gICAgXCJaXCI6IGZvcm1hdFpvbmUsXHJcbiAgICBcIiVcIjogZm9ybWF0TGl0ZXJhbFBlcmNlbnRcclxuICB9O1xyXG5cclxuICB2YXIgdXRjRm9ybWF0cyA9IHtcclxuICAgIFwiYVwiOiBmb3JtYXRVVENTaG9ydFdlZWtkYXksXHJcbiAgICBcIkFcIjogZm9ybWF0VVRDV2Vla2RheSxcclxuICAgIFwiYlwiOiBmb3JtYXRVVENTaG9ydE1vbnRoLFxyXG4gICAgXCJCXCI6IGZvcm1hdFVUQ01vbnRoLFxyXG4gICAgXCJjXCI6IG51bGwsXHJcbiAgICBcImRcIjogZm9ybWF0VVRDRGF5T2ZNb250aCxcclxuICAgIFwiZVwiOiBmb3JtYXRVVENEYXlPZk1vbnRoLFxyXG4gICAgXCJmXCI6IGZvcm1hdFVUQ01pY3Jvc2Vjb25kcyxcclxuICAgIFwiSFwiOiBmb3JtYXRVVENIb3VyMjQsXHJcbiAgICBcIklcIjogZm9ybWF0VVRDSG91cjEyLFxyXG4gICAgXCJqXCI6IGZvcm1hdFVUQ0RheU9mWWVhcixcclxuICAgIFwiTFwiOiBmb3JtYXRVVENNaWxsaXNlY29uZHMsXHJcbiAgICBcIm1cIjogZm9ybWF0VVRDTW9udGhOdW1iZXIsXHJcbiAgICBcIk1cIjogZm9ybWF0VVRDTWludXRlcyxcclxuICAgIFwicFwiOiBmb3JtYXRVVENQZXJpb2QsXHJcbiAgICBcIlFcIjogZm9ybWF0VW5peFRpbWVzdGFtcCxcclxuICAgIFwic1wiOiBmb3JtYXRVbml4VGltZXN0YW1wU2Vjb25kcyxcclxuICAgIFwiU1wiOiBmb3JtYXRVVENTZWNvbmRzLFxyXG4gICAgXCJ1XCI6IGZvcm1hdFVUQ1dlZWtkYXlOdW1iZXJNb25kYXksXHJcbiAgICBcIlVcIjogZm9ybWF0VVRDV2Vla051bWJlclN1bmRheSxcclxuICAgIFwiVlwiOiBmb3JtYXRVVENXZWVrTnVtYmVySVNPLFxyXG4gICAgXCJ3XCI6IGZvcm1hdFVUQ1dlZWtkYXlOdW1iZXJTdW5kYXksXHJcbiAgICBcIldcIjogZm9ybWF0VVRDV2Vla051bWJlck1vbmRheSxcclxuICAgIFwieFwiOiBudWxsLFxyXG4gICAgXCJYXCI6IG51bGwsXHJcbiAgICBcInlcIjogZm9ybWF0VVRDWWVhcixcclxuICAgIFwiWVwiOiBmb3JtYXRVVENGdWxsWWVhcixcclxuICAgIFwiWlwiOiBmb3JtYXRVVENab25lLFxyXG4gICAgXCIlXCI6IGZvcm1hdExpdGVyYWxQZXJjZW50XHJcbiAgfTtcclxuXHJcbiAgdmFyIHBhcnNlcyA9IHtcclxuICAgIFwiYVwiOiBwYXJzZVNob3J0V2Vla2RheSxcclxuICAgIFwiQVwiOiBwYXJzZVdlZWtkYXksXHJcbiAgICBcImJcIjogcGFyc2VTaG9ydE1vbnRoLFxyXG4gICAgXCJCXCI6IHBhcnNlTW9udGgsXHJcbiAgICBcImNcIjogcGFyc2VMb2NhbGVEYXRlVGltZSxcclxuICAgIFwiZFwiOiBwYXJzZURheU9mTW9udGgsXHJcbiAgICBcImVcIjogcGFyc2VEYXlPZk1vbnRoLFxyXG4gICAgXCJmXCI6IHBhcnNlTWljcm9zZWNvbmRzLFxyXG4gICAgXCJIXCI6IHBhcnNlSG91cjI0LFxyXG4gICAgXCJJXCI6IHBhcnNlSG91cjI0LFxyXG4gICAgXCJqXCI6IHBhcnNlRGF5T2ZZZWFyLFxyXG4gICAgXCJMXCI6IHBhcnNlTWlsbGlzZWNvbmRzLFxyXG4gICAgXCJtXCI6IHBhcnNlTW9udGhOdW1iZXIsXHJcbiAgICBcIk1cIjogcGFyc2VNaW51dGVzLFxyXG4gICAgXCJwXCI6IHBhcnNlUGVyaW9kLFxyXG4gICAgXCJRXCI6IHBhcnNlVW5peFRpbWVzdGFtcCxcclxuICAgIFwic1wiOiBwYXJzZVVuaXhUaW1lc3RhbXBTZWNvbmRzLFxyXG4gICAgXCJTXCI6IHBhcnNlU2Vjb25kcyxcclxuICAgIFwidVwiOiBwYXJzZVdlZWtkYXlOdW1iZXJNb25kYXksXHJcbiAgICBcIlVcIjogcGFyc2VXZWVrTnVtYmVyU3VuZGF5LFxyXG4gICAgXCJWXCI6IHBhcnNlV2Vla051bWJlcklTTyxcclxuICAgIFwid1wiOiBwYXJzZVdlZWtkYXlOdW1iZXJTdW5kYXksXHJcbiAgICBcIldcIjogcGFyc2VXZWVrTnVtYmVyTW9uZGF5LFxyXG4gICAgXCJ4XCI6IHBhcnNlTG9jYWxlRGF0ZSxcclxuICAgIFwiWFwiOiBwYXJzZUxvY2FsZVRpbWUsXHJcbiAgICBcInlcIjogcGFyc2VZZWFyLFxyXG4gICAgXCJZXCI6IHBhcnNlRnVsbFllYXIsXHJcbiAgICBcIlpcIjogcGFyc2Vab25lLFxyXG4gICAgXCIlXCI6IHBhcnNlTGl0ZXJhbFBlcmNlbnRcclxuICB9O1xyXG5cclxuICAvLyBUaGVzZSByZWN1cnNpdmUgZGlyZWN0aXZlIGRlZmluaXRpb25zIG11c3QgYmUgZGVmZXJyZWQuXHJcbiAgZm9ybWF0cy54ID0gbmV3Rm9ybWF0KGxvY2FsZV9kYXRlLCBmb3JtYXRzKTtcclxuICBmb3JtYXRzLlggPSBuZXdGb3JtYXQobG9jYWxlX3RpbWUsIGZvcm1hdHMpO1xyXG4gIGZvcm1hdHMuYyA9IG5ld0Zvcm1hdChsb2NhbGVfZGF0ZVRpbWUsIGZvcm1hdHMpO1xyXG4gIHV0Y0Zvcm1hdHMueCA9IG5ld0Zvcm1hdChsb2NhbGVfZGF0ZSwgdXRjRm9ybWF0cyk7XHJcbiAgdXRjRm9ybWF0cy5YID0gbmV3Rm9ybWF0KGxvY2FsZV90aW1lLCB1dGNGb3JtYXRzKTtcclxuICB1dGNGb3JtYXRzLmMgPSBuZXdGb3JtYXQobG9jYWxlX2RhdGVUaW1lLCB1dGNGb3JtYXRzKTtcclxuXHJcbiAgZnVuY3Rpb24gbmV3Rm9ybWF0KHNwZWNpZmllciwgZm9ybWF0cykge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGRhdGUpIHtcclxuICAgICAgdmFyIHN0cmluZyA9IFtdLFxyXG4gICAgICAgICAgaSA9IC0xLFxyXG4gICAgICAgICAgaiA9IDAsXHJcbiAgICAgICAgICBuID0gc3BlY2lmaWVyLmxlbmd0aCxcclxuICAgICAgICAgIGMsXHJcbiAgICAgICAgICBwYWQsXHJcbiAgICAgICAgICBmb3JtYXQ7XHJcblxyXG4gICAgICBpZiAoIShkYXRlIGluc3RhbmNlb2YgRGF0ZSkpIGRhdGUgPSBuZXcgRGF0ZSgrZGF0ZSk7XHJcblxyXG4gICAgICB3aGlsZSAoKytpIDwgbikge1xyXG4gICAgICAgIGlmIChzcGVjaWZpZXIuY2hhckNvZGVBdChpKSA9PT0gMzcpIHtcclxuICAgICAgICAgIHN0cmluZy5wdXNoKHNwZWNpZmllci5zbGljZShqLCBpKSk7XHJcbiAgICAgICAgICBpZiAoKHBhZCA9IHBhZHNbYyA9IHNwZWNpZmllci5jaGFyQXQoKytpKV0pICE9IG51bGwpIGMgPSBzcGVjaWZpZXIuY2hhckF0KCsraSk7XHJcbiAgICAgICAgICBlbHNlIHBhZCA9IGMgPT09IFwiZVwiID8gXCIgXCIgOiBcIjBcIjtcclxuICAgICAgICAgIGlmIChmb3JtYXQgPSBmb3JtYXRzW2NdKSBjID0gZm9ybWF0KGRhdGUsIHBhZCk7XHJcbiAgICAgICAgICBzdHJpbmcucHVzaChjKTtcclxuICAgICAgICAgIGogPSBpICsgMTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHN0cmluZy5wdXNoKHNwZWNpZmllci5zbGljZShqLCBpKSk7XHJcbiAgICAgIHJldHVybiBzdHJpbmcuam9pbihcIlwiKTtcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBuZXdQYXJzZShzcGVjaWZpZXIsIG5ld0RhdGUpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcclxuICAgICAgdmFyIGQgPSBuZXdZZWFyKDE5MDApLFxyXG4gICAgICAgICAgaSA9IHBhcnNlU3BlY2lmaWVyKGQsIHNwZWNpZmllciwgc3RyaW5nICs9IFwiXCIsIDApLFxyXG4gICAgICAgICAgd2VlaywgZGF5JCQxO1xyXG4gICAgICBpZiAoaSAhPSBzdHJpbmcubGVuZ3RoKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgIC8vIElmIGEgVU5JWCB0aW1lc3RhbXAgaXMgc3BlY2lmaWVkLCByZXR1cm4gaXQuXHJcbiAgICAgIGlmIChcIlFcIiBpbiBkKSByZXR1cm4gbmV3IERhdGUoZC5RKTtcclxuXHJcbiAgICAgIC8vIFRoZSBhbS1wbSBmbGFnIGlzIDAgZm9yIEFNLCBhbmQgMSBmb3IgUE0uXHJcbiAgICAgIGlmIChcInBcIiBpbiBkKSBkLkggPSBkLkggJSAxMiArIGQucCAqIDEyO1xyXG5cclxuICAgICAgLy8gQ29udmVydCBkYXktb2Ytd2VlayBhbmQgd2Vlay1vZi15ZWFyIHRvIGRheS1vZi15ZWFyLlxyXG4gICAgICBpZiAoXCJWXCIgaW4gZCkge1xyXG4gICAgICAgIGlmIChkLlYgPCAxIHx8IGQuViA+IDUzKSByZXR1cm4gbnVsbDtcclxuICAgICAgICBpZiAoIShcIndcIiBpbiBkKSkgZC53ID0gMTtcclxuICAgICAgICBpZiAoXCJaXCIgaW4gZCkge1xyXG4gICAgICAgICAgd2VlayA9IHV0Y0RhdGUobmV3WWVhcihkLnkpKSwgZGF5JCQxID0gd2Vlay5nZXRVVENEYXkoKTtcclxuICAgICAgICAgIHdlZWsgPSBkYXkkJDEgPiA0IHx8IGRheSQkMSA9PT0gMCA/IHV0Y01vbmRheS5jZWlsKHdlZWspIDogdXRjTW9uZGF5KHdlZWspO1xyXG4gICAgICAgICAgd2VlayA9IHV0Y0RheS5vZmZzZXQod2VlaywgKGQuViAtIDEpICogNyk7XHJcbiAgICAgICAgICBkLnkgPSB3ZWVrLmdldFVUQ0Z1bGxZZWFyKCk7XHJcbiAgICAgICAgICBkLm0gPSB3ZWVrLmdldFVUQ01vbnRoKCk7XHJcbiAgICAgICAgICBkLmQgPSB3ZWVrLmdldFVUQ0RhdGUoKSArIChkLncgKyA2KSAlIDc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHdlZWsgPSBuZXdEYXRlKG5ld1llYXIoZC55KSksIGRheSQkMSA9IHdlZWsuZ2V0RGF5KCk7XHJcbiAgICAgICAgICB3ZWVrID0gZGF5JCQxID4gNCB8fCBkYXkkJDEgPT09IDAgPyBtb25kYXkuY2VpbCh3ZWVrKSA6IG1vbmRheSh3ZWVrKTtcclxuICAgICAgICAgIHdlZWsgPSBkYXkub2Zmc2V0KHdlZWssIChkLlYgLSAxKSAqIDcpO1xyXG4gICAgICAgICAgZC55ID0gd2Vlay5nZXRGdWxsWWVhcigpO1xyXG4gICAgICAgICAgZC5tID0gd2Vlay5nZXRNb250aCgpO1xyXG4gICAgICAgICAgZC5kID0gd2Vlay5nZXREYXRlKCkgKyAoZC53ICsgNikgJSA3O1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmIChcIldcIiBpbiBkIHx8IFwiVVwiIGluIGQpIHtcclxuICAgICAgICBpZiAoIShcIndcIiBpbiBkKSkgZC53ID0gXCJ1XCIgaW4gZCA/IGQudSAlIDcgOiBcIldcIiBpbiBkID8gMSA6IDA7XHJcbiAgICAgICAgZGF5JCQxID0gXCJaXCIgaW4gZCA/IHV0Y0RhdGUobmV3WWVhcihkLnkpKS5nZXRVVENEYXkoKSA6IG5ld0RhdGUobmV3WWVhcihkLnkpKS5nZXREYXkoKTtcclxuICAgICAgICBkLm0gPSAwO1xyXG4gICAgICAgIGQuZCA9IFwiV1wiIGluIGQgPyAoZC53ICsgNikgJSA3ICsgZC5XICogNyAtIChkYXkkJDEgKyA1KSAlIDcgOiBkLncgKyBkLlUgKiA3IC0gKGRheSQkMSArIDYpICUgNztcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSWYgYSB0aW1lIHpvbmUgaXMgc3BlY2lmaWVkLCBhbGwgZmllbGRzIGFyZSBpbnRlcnByZXRlZCBhcyBVVEMgYW5kIHRoZW5cclxuICAgICAgLy8gb2Zmc2V0IGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIHRpbWUgem9uZS5cclxuICAgICAgaWYgKFwiWlwiIGluIGQpIHtcclxuICAgICAgICBkLkggKz0gZC5aIC8gMTAwIHwgMDtcclxuICAgICAgICBkLk0gKz0gZC5aICUgMTAwO1xyXG4gICAgICAgIHJldHVybiB1dGNEYXRlKGQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBPdGhlcndpc2UsIGFsbCBmaWVsZHMgYXJlIGluIGxvY2FsIHRpbWUuXHJcbiAgICAgIHJldHVybiBuZXdEYXRlKGQpO1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHBhcnNlU3BlY2lmaWVyKGQsIHNwZWNpZmllciwgc3RyaW5nLCBqKSB7XHJcbiAgICB2YXIgaSA9IDAsXHJcbiAgICAgICAgbiA9IHNwZWNpZmllci5sZW5ndGgsXHJcbiAgICAgICAgbSA9IHN0cmluZy5sZW5ndGgsXHJcbiAgICAgICAgYyxcclxuICAgICAgICBwYXJzZTtcclxuXHJcbiAgICB3aGlsZSAoaSA8IG4pIHtcclxuICAgICAgaWYgKGogPj0gbSkgcmV0dXJuIC0xO1xyXG4gICAgICBjID0gc3BlY2lmaWVyLmNoYXJDb2RlQXQoaSsrKTtcclxuICAgICAgaWYgKGMgPT09IDM3KSB7XHJcbiAgICAgICAgYyA9IHNwZWNpZmllci5jaGFyQXQoaSsrKTtcclxuICAgICAgICBwYXJzZSA9IHBhcnNlc1tjIGluIHBhZHMgPyBzcGVjaWZpZXIuY2hhckF0KGkrKykgOiBjXTtcclxuICAgICAgICBpZiAoIXBhcnNlIHx8ICgoaiA9IHBhcnNlKGQsIHN0cmluZywgaikpIDwgMCkpIHJldHVybiAtMTtcclxuICAgICAgfSBlbHNlIGlmIChjICE9IHN0cmluZy5jaGFyQ29kZUF0KGorKykpIHtcclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gajtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHBhcnNlUGVyaW9kKGQsIHN0cmluZywgaSkge1xyXG4gICAgdmFyIG4gPSBwZXJpb2RSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XHJcbiAgICByZXR1cm4gbiA/IChkLnAgPSBwZXJpb2RMb29rdXBbblswXS50b0xvd2VyQ2FzZSgpXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcGFyc2VTaG9ydFdlZWtkYXkoZCwgc3RyaW5nLCBpKSB7XHJcbiAgICB2YXIgbiA9IHNob3J0V2Vla2RheVJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcclxuICAgIHJldHVybiBuID8gKGQudyA9IHNob3J0V2Vla2RheUxvb2t1cFtuWzBdLnRvTG93ZXJDYXNlKCldLCBpICsgblswXS5sZW5ndGgpIDogLTE7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBwYXJzZVdlZWtkYXkoZCwgc3RyaW5nLCBpKSB7XHJcbiAgICB2YXIgbiA9IHdlZWtkYXlSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XHJcbiAgICByZXR1cm4gbiA/IChkLncgPSB3ZWVrZGF5TG9va3VwW25bMF0udG9Mb3dlckNhc2UoKV0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHBhcnNlU2hvcnRNb250aChkLCBzdHJpbmcsIGkpIHtcclxuICAgIHZhciBuID0gc2hvcnRNb250aFJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcclxuICAgIHJldHVybiBuID8gKGQubSA9IHNob3J0TW9udGhMb29rdXBbblswXS50b0xvd2VyQ2FzZSgpXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcGFyc2VNb250aChkLCBzdHJpbmcsIGkpIHtcclxuICAgIHZhciBuID0gbW9udGhSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XHJcbiAgICByZXR1cm4gbiA/IChkLm0gPSBtb250aExvb2t1cFtuWzBdLnRvTG93ZXJDYXNlKCldLCBpICsgblswXS5sZW5ndGgpIDogLTE7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBwYXJzZUxvY2FsZURhdGVUaW1lKGQsIHN0cmluZywgaSkge1xyXG4gICAgcmV0dXJuIHBhcnNlU3BlY2lmaWVyKGQsIGxvY2FsZV9kYXRlVGltZSwgc3RyaW5nLCBpKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHBhcnNlTG9jYWxlRGF0ZShkLCBzdHJpbmcsIGkpIHtcclxuICAgIHJldHVybiBwYXJzZVNwZWNpZmllcihkLCBsb2NhbGVfZGF0ZSwgc3RyaW5nLCBpKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHBhcnNlTG9jYWxlVGltZShkLCBzdHJpbmcsIGkpIHtcclxuICAgIHJldHVybiBwYXJzZVNwZWNpZmllcihkLCBsb2NhbGVfdGltZSwgc3RyaW5nLCBpKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGZvcm1hdFNob3J0V2Vla2RheShkKSB7XHJcbiAgICByZXR1cm4gbG9jYWxlX3Nob3J0V2Vla2RheXNbZC5nZXREYXkoKV07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBmb3JtYXRXZWVrZGF5KGQpIHtcclxuICAgIHJldHVybiBsb2NhbGVfd2Vla2RheXNbZC5nZXREYXkoKV07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBmb3JtYXRTaG9ydE1vbnRoKGQpIHtcclxuICAgIHJldHVybiBsb2NhbGVfc2hvcnRNb250aHNbZC5nZXRNb250aCgpXTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGZvcm1hdE1vbnRoKGQpIHtcclxuICAgIHJldHVybiBsb2NhbGVfbW9udGhzW2QuZ2V0TW9udGgoKV07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBmb3JtYXRQZXJpb2QoZCkge1xyXG4gICAgcmV0dXJuIGxvY2FsZV9wZXJpb2RzWysoZC5nZXRIb3VycygpID49IDEyKV07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBmb3JtYXRVVENTaG9ydFdlZWtkYXkoZCkge1xyXG4gICAgcmV0dXJuIGxvY2FsZV9zaG9ydFdlZWtkYXlzW2QuZ2V0VVRDRGF5KCldO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZm9ybWF0VVRDV2Vla2RheShkKSB7XHJcbiAgICByZXR1cm4gbG9jYWxlX3dlZWtkYXlzW2QuZ2V0VVRDRGF5KCldO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZm9ybWF0VVRDU2hvcnRNb250aChkKSB7XHJcbiAgICByZXR1cm4gbG9jYWxlX3Nob3J0TW9udGhzW2QuZ2V0VVRDTW9udGgoKV07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBmb3JtYXRVVENNb250aChkKSB7XHJcbiAgICByZXR1cm4gbG9jYWxlX21vbnRoc1tkLmdldFVUQ01vbnRoKCldO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZm9ybWF0VVRDUGVyaW9kKGQpIHtcclxuICAgIHJldHVybiBsb2NhbGVfcGVyaW9kc1srKGQuZ2V0VVRDSG91cnMoKSA+PSAxMildO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGZvcm1hdDogZnVuY3Rpb24oc3BlY2lmaWVyKSB7XHJcbiAgICAgIHZhciBmID0gbmV3Rm9ybWF0KHNwZWNpZmllciArPSBcIlwiLCBmb3JtYXRzKTtcclxuICAgICAgZi50b1N0cmluZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gc3BlY2lmaWVyOyB9O1xyXG4gICAgICByZXR1cm4gZjtcclxuICAgIH0sXHJcbiAgICBwYXJzZTogZnVuY3Rpb24oc3BlY2lmaWVyKSB7XHJcbiAgICAgIHZhciBwID0gbmV3UGFyc2Uoc3BlY2lmaWVyICs9IFwiXCIsIGxvY2FsRGF0ZSk7XHJcbiAgICAgIHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHNwZWNpZmllcjsgfTtcclxuICAgICAgcmV0dXJuIHA7XHJcbiAgICB9LFxyXG4gICAgdXRjRm9ybWF0OiBmdW5jdGlvbihzcGVjaWZpZXIpIHtcclxuICAgICAgdmFyIGYgPSBuZXdGb3JtYXQoc3BlY2lmaWVyICs9IFwiXCIsIHV0Y0Zvcm1hdHMpO1xyXG4gICAgICBmLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7IHJldHVybiBzcGVjaWZpZXI7IH07XHJcbiAgICAgIHJldHVybiBmO1xyXG4gICAgfSxcclxuICAgIHV0Y1BhcnNlOiBmdW5jdGlvbihzcGVjaWZpZXIpIHtcclxuICAgICAgdmFyIHAgPSBuZXdQYXJzZShzcGVjaWZpZXIsIHV0Y0RhdGUpO1xyXG4gICAgICBwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7IHJldHVybiBzcGVjaWZpZXI7IH07XHJcbiAgICAgIHJldHVybiBwO1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuXHJcbnZhciBwYWRzID0ge1wiLVwiOiBcIlwiLCBcIl9cIjogXCIgXCIsIFwiMFwiOiBcIjBcIn0sXHJcbiAgICBudW1iZXJSZSA9IC9eXFxzKlxcZCsvLCAvLyBub3RlOiBpZ25vcmVzIG5leHQgZGlyZWN0aXZlXHJcbiAgICBwZXJjZW50UmUgPSAvXiUvLFxyXG4gICAgcmVxdW90ZVJlID0gL1tcXFxcXiQqKz98W1xcXSgpLnt9XS9nO1xyXG5cclxuZnVuY3Rpb24gcGFkKHZhbHVlLCBmaWxsLCB3aWR0aCkge1xyXG4gIHZhciBzaWduID0gdmFsdWUgPCAwID8gXCItXCIgOiBcIlwiLFxyXG4gICAgICBzdHJpbmcgPSAoc2lnbiA/IC12YWx1ZSA6IHZhbHVlKSArIFwiXCIsXHJcbiAgICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XHJcbiAgcmV0dXJuIHNpZ24gKyAobGVuZ3RoIDwgd2lkdGggPyBuZXcgQXJyYXkod2lkdGggLSBsZW5ndGggKyAxKS5qb2luKGZpbGwpICsgc3RyaW5nIDogc3RyaW5nKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVxdW90ZShzKSB7XHJcbiAgcmV0dXJuIHMucmVwbGFjZShyZXF1b3RlUmUsIFwiXFxcXCQmXCIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBmb3JtYXRSZShuYW1lcykge1xyXG4gIHJldHVybiBuZXcgUmVnRXhwKFwiXig/OlwiICsgbmFtZXMubWFwKHJlcXVvdGUpLmpvaW4oXCJ8XCIpICsgXCIpXCIsIFwiaVwiKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZm9ybWF0TG9va3VwKG5hbWVzKSB7XHJcbiAgdmFyIG1hcCA9IHt9LCBpID0gLTEsIG4gPSBuYW1lcy5sZW5ndGg7XHJcbiAgd2hpbGUgKCsraSA8IG4pIG1hcFtuYW1lc1tpXS50b0xvd2VyQ2FzZSgpXSA9IGk7XHJcbiAgcmV0dXJuIG1hcDtcclxufVxyXG5cclxuZnVuY3Rpb24gcGFyc2VXZWVrZGF5TnVtYmVyU3VuZGF5KGQsIHN0cmluZywgaSkge1xyXG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDEpKTtcclxuICByZXR1cm4gbiA/IChkLncgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYXJzZVdlZWtkYXlOdW1iZXJNb25kYXkoZCwgc3RyaW5nLCBpKSB7XHJcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMSkpO1xyXG4gIHJldHVybiBuID8gKGQudSA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnNlV2Vla051bWJlclN1bmRheShkLCBzdHJpbmcsIGkpIHtcclxuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XHJcbiAgcmV0dXJuIG4gPyAoZC5VID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcclxufVxyXG5cclxuZnVuY3Rpb24gcGFyc2VXZWVrTnVtYmVySVNPKGQsIHN0cmluZywgaSkge1xyXG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcclxuICByZXR1cm4gbiA/IChkLlYgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYXJzZVdlZWtOdW1iZXJNb25kYXkoZCwgc3RyaW5nLCBpKSB7XHJcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xyXG4gIHJldHVybiBuID8gKGQuVyA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnNlRnVsbFllYXIoZCwgc3RyaW5nLCBpKSB7XHJcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgNCkpO1xyXG4gIHJldHVybiBuID8gKGQueSA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnNlWWVhcihkLCBzdHJpbmcsIGkpIHtcclxuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XHJcbiAgcmV0dXJuIG4gPyAoZC55ID0gK25bMF0gKyAoK25bMF0gPiA2OCA/IDE5MDAgOiAyMDAwKSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYXJzZVpvbmUoZCwgc3RyaW5nLCBpKSB7XHJcbiAgdmFyIG4gPSAvXihaKXwoWystXVxcZFxcZCkoPzo6PyhcXGRcXGQpKT8vLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyA2KSk7XHJcbiAgcmV0dXJuIG4gPyAoZC5aID0gblsxXSA/IDAgOiAtKG5bMl0gKyAoblszXSB8fCBcIjAwXCIpKSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYXJzZU1vbnRoTnVtYmVyKGQsIHN0cmluZywgaSkge1xyXG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcclxuICByZXR1cm4gbiA/IChkLm0gPSBuWzBdIC0gMSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYXJzZURheU9mTW9udGgoZCwgc3RyaW5nLCBpKSB7XHJcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xyXG4gIHJldHVybiBuID8gKGQuZCA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnNlRGF5T2ZZZWFyKGQsIHN0cmluZywgaSkge1xyXG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDMpKTtcclxuICByZXR1cm4gbiA/IChkLm0gPSAwLCBkLmQgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYXJzZUhvdXIyNChkLCBzdHJpbmcsIGkpIHtcclxuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XHJcbiAgcmV0dXJuIG4gPyAoZC5IID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcclxufVxyXG5cclxuZnVuY3Rpb24gcGFyc2VNaW51dGVzKGQsIHN0cmluZywgaSkge1xyXG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcclxuICByZXR1cm4gbiA/IChkLk0gPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYXJzZVNlY29uZHMoZCwgc3RyaW5nLCBpKSB7XHJcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xyXG4gIHJldHVybiBuID8gKGQuUyA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnNlTWlsbGlzZWNvbmRzKGQsIHN0cmluZywgaSkge1xyXG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDMpKTtcclxuICByZXR1cm4gbiA/IChkLkwgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYXJzZU1pY3Jvc2Vjb25kcyhkLCBzdHJpbmcsIGkpIHtcclxuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyA2KSk7XHJcbiAgcmV0dXJuIG4gPyAoZC5MID0gTWF0aC5mbG9vcihuWzBdIC8gMTAwMCksIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcclxufVxyXG5cclxuZnVuY3Rpb24gcGFyc2VMaXRlcmFsUGVyY2VudChkLCBzdHJpbmcsIGkpIHtcclxuICB2YXIgbiA9IHBlcmNlbnRSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMSkpO1xyXG4gIHJldHVybiBuID8gaSArIG5bMF0ubGVuZ3RoIDogLTE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnNlVW5peFRpbWVzdGFtcChkLCBzdHJpbmcsIGkpIHtcclxuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcclxuICByZXR1cm4gbiA/IChkLlEgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYXJzZVVuaXhUaW1lc3RhbXBTZWNvbmRzKGQsIHN0cmluZywgaSkge1xyXG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xyXG4gIHJldHVybiBuID8gKGQuUSA9ICgrblswXSkgKiAxMDAwLCBpICsgblswXS5sZW5ndGgpIDogLTE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZvcm1hdERheU9mTW9udGgoZCwgcCkge1xyXG4gIHJldHVybiBwYWQoZC5nZXREYXRlKCksIHAsIDIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBmb3JtYXRIb3VyMjQoZCwgcCkge1xyXG4gIHJldHVybiBwYWQoZC5nZXRIb3VycygpLCBwLCAyKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZm9ybWF0SG91cjEyKGQsIHApIHtcclxuICByZXR1cm4gcGFkKGQuZ2V0SG91cnMoKSAlIDEyIHx8IDEyLCBwLCAyKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZm9ybWF0RGF5T2ZZZWFyKGQsIHApIHtcclxuICByZXR1cm4gcGFkKDEgKyBkYXkuY291bnQoeWVhcihkKSwgZCksIHAsIDMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBmb3JtYXRNaWxsaXNlY29uZHMoZCwgcCkge1xyXG4gIHJldHVybiBwYWQoZC5nZXRNaWxsaXNlY29uZHMoKSwgcCwgMyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZvcm1hdE1pY3Jvc2Vjb25kcyhkLCBwKSB7XHJcbiAgcmV0dXJuIGZvcm1hdE1pbGxpc2Vjb25kcyhkLCBwKSArIFwiMDAwXCI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZvcm1hdE1vbnRoTnVtYmVyKGQsIHApIHtcclxuICByZXR1cm4gcGFkKGQuZ2V0TW9udGgoKSArIDEsIHAsIDIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBmb3JtYXRNaW51dGVzKGQsIHApIHtcclxuICByZXR1cm4gcGFkKGQuZ2V0TWludXRlcygpLCBwLCAyKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZm9ybWF0U2Vjb25kcyhkLCBwKSB7XHJcbiAgcmV0dXJuIHBhZChkLmdldFNlY29uZHMoKSwgcCwgMik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZvcm1hdFdlZWtkYXlOdW1iZXJNb25kYXkoZCkge1xyXG4gIHZhciBkYXkkJDEgPSBkLmdldERheSgpO1xyXG4gIHJldHVybiBkYXkkJDEgPT09IDAgPyA3IDogZGF5JCQxO1xyXG59XHJcblxyXG5mdW5jdGlvbiBmb3JtYXRXZWVrTnVtYmVyU3VuZGF5KGQsIHApIHtcclxuICByZXR1cm4gcGFkKHN1bmRheS5jb3VudCh5ZWFyKGQpLCBkKSwgcCwgMik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZvcm1hdFdlZWtOdW1iZXJJU08oZCwgcCkge1xyXG4gIHZhciBkYXkkJDEgPSBkLmdldERheSgpO1xyXG4gIGQgPSAoZGF5JCQxID49IDQgfHwgZGF5JCQxID09PSAwKSA/IHRodXJzZGF5KGQpIDogdGh1cnNkYXkuY2VpbChkKTtcclxuICByZXR1cm4gcGFkKHRodXJzZGF5LmNvdW50KHllYXIoZCksIGQpICsgKHllYXIoZCkuZ2V0RGF5KCkgPT09IDQpLCBwLCAyKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZm9ybWF0V2Vla2RheU51bWJlclN1bmRheShkKSB7XHJcbiAgcmV0dXJuIGQuZ2V0RGF5KCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZvcm1hdFdlZWtOdW1iZXJNb25kYXkoZCwgcCkge1xyXG4gIHJldHVybiBwYWQobW9uZGF5LmNvdW50KHllYXIoZCksIGQpLCBwLCAyKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZm9ybWF0WWVhcihkLCBwKSB7XHJcbiAgcmV0dXJuIHBhZChkLmdldEZ1bGxZZWFyKCkgJSAxMDAsIHAsIDIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBmb3JtYXRGdWxsWWVhcihkLCBwKSB7XHJcbiAgcmV0dXJuIHBhZChkLmdldEZ1bGxZZWFyKCkgJSAxMDAwMCwgcCwgNCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZvcm1hdFpvbmUoZCkge1xyXG4gIHZhciB6ID0gZC5nZXRUaW1lem9uZU9mZnNldCgpO1xyXG4gIHJldHVybiAoeiA+IDAgPyBcIi1cIiA6ICh6ICo9IC0xLCBcIitcIikpXHJcbiAgICAgICsgcGFkKHogLyA2MCB8IDAsIFwiMFwiLCAyKVxyXG4gICAgICArIHBhZCh6ICUgNjAsIFwiMFwiLCAyKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZm9ybWF0VVRDRGF5T2ZNb250aChkLCBwKSB7XHJcbiAgcmV0dXJuIHBhZChkLmdldFVUQ0RhdGUoKSwgcCwgMik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZvcm1hdFVUQ0hvdXIyNChkLCBwKSB7XHJcbiAgcmV0dXJuIHBhZChkLmdldFVUQ0hvdXJzKCksIHAsIDIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBmb3JtYXRVVENIb3VyMTIoZCwgcCkge1xyXG4gIHJldHVybiBwYWQoZC5nZXRVVENIb3VycygpICUgMTIgfHwgMTIsIHAsIDIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBmb3JtYXRVVENEYXlPZlllYXIoZCwgcCkge1xyXG4gIHJldHVybiBwYWQoMSArIHV0Y0RheS5jb3VudCh1dGNZZWFyKGQpLCBkKSwgcCwgMyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZvcm1hdFVUQ01pbGxpc2Vjb25kcyhkLCBwKSB7XHJcbiAgcmV0dXJuIHBhZChkLmdldFVUQ01pbGxpc2Vjb25kcygpLCBwLCAzKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZm9ybWF0VVRDTWljcm9zZWNvbmRzKGQsIHApIHtcclxuICByZXR1cm4gZm9ybWF0VVRDTWlsbGlzZWNvbmRzKGQsIHApICsgXCIwMDBcIjtcclxufVxyXG5cclxuZnVuY3Rpb24gZm9ybWF0VVRDTW9udGhOdW1iZXIoZCwgcCkge1xyXG4gIHJldHVybiBwYWQoZC5nZXRVVENNb250aCgpICsgMSwgcCwgMik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZvcm1hdFVUQ01pbnV0ZXMoZCwgcCkge1xyXG4gIHJldHVybiBwYWQoZC5nZXRVVENNaW51dGVzKCksIHAsIDIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBmb3JtYXRVVENTZWNvbmRzKGQsIHApIHtcclxuICByZXR1cm4gcGFkKGQuZ2V0VVRDU2Vjb25kcygpLCBwLCAyKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZm9ybWF0VVRDV2Vla2RheU51bWJlck1vbmRheShkKSB7XHJcbiAgdmFyIGRvdyA9IGQuZ2V0VVRDRGF5KCk7XHJcbiAgcmV0dXJuIGRvdyA9PT0gMCA/IDcgOiBkb3c7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZvcm1hdFVUQ1dlZWtOdW1iZXJTdW5kYXkoZCwgcCkge1xyXG4gIHJldHVybiBwYWQodXRjU3VuZGF5LmNvdW50KHV0Y1llYXIoZCksIGQpLCBwLCAyKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZm9ybWF0VVRDV2Vla051bWJlcklTTyhkLCBwKSB7XHJcbiAgdmFyIGRheSQkMSA9IGQuZ2V0VVRDRGF5KCk7XHJcbiAgZCA9IChkYXkkJDEgPj0gNCB8fCBkYXkkJDEgPT09IDApID8gdXRjVGh1cnNkYXkoZCkgOiB1dGNUaHVyc2RheS5jZWlsKGQpO1xyXG4gIHJldHVybiBwYWQodXRjVGh1cnNkYXkuY291bnQodXRjWWVhcihkKSwgZCkgKyAodXRjWWVhcihkKS5nZXRVVENEYXkoKSA9PT0gNCksIHAsIDIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBmb3JtYXRVVENXZWVrZGF5TnVtYmVyU3VuZGF5KGQpIHtcclxuICByZXR1cm4gZC5nZXRVVENEYXkoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZm9ybWF0VVRDV2Vla051bWJlck1vbmRheShkLCBwKSB7XHJcbiAgcmV0dXJuIHBhZCh1dGNNb25kYXkuY291bnQodXRjWWVhcihkKSwgZCksIHAsIDIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBmb3JtYXRVVENZZWFyKGQsIHApIHtcclxuICByZXR1cm4gcGFkKGQuZ2V0VVRDRnVsbFllYXIoKSAlIDEwMCwgcCwgMik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZvcm1hdFVUQ0Z1bGxZZWFyKGQsIHApIHtcclxuICByZXR1cm4gcGFkKGQuZ2V0VVRDRnVsbFllYXIoKSAlIDEwMDAwLCBwLCA0KTtcclxufVxyXG5cclxuZnVuY3Rpb24gZm9ybWF0VVRDWm9uZSgpIHtcclxuICByZXR1cm4gXCIrMDAwMFwiO1xyXG59XHJcblxyXG5mdW5jdGlvbiBmb3JtYXRMaXRlcmFsUGVyY2VudCgpIHtcclxuICByZXR1cm4gXCIlXCI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZvcm1hdFVuaXhUaW1lc3RhbXAoZCkge1xyXG4gIHJldHVybiArZDtcclxufVxyXG5cclxuZnVuY3Rpb24gZm9ybWF0VW5peFRpbWVzdGFtcFNlY29uZHMoZCkge1xyXG4gIHJldHVybiBNYXRoLmZsb29yKCtkIC8gMTAwMCk7XHJcbn1cclxuXHJcbnZhciBsb2NhbGUkMTtcclxuXHJcbmRlZmF1bHRMb2NhbGUkMSh7XHJcbiAgZGF0ZVRpbWU6IFwiJXgsICVYXCIsXHJcbiAgZGF0ZTogXCIlLW0vJS1kLyVZXCIsXHJcbiAgdGltZTogXCIlLUk6JU06JVMgJXBcIixcclxuICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLFxyXG4gIGRheXM6IFtcIlN1bmRheVwiLCBcIk1vbmRheVwiLCBcIlR1ZXNkYXlcIiwgXCJXZWRuZXNkYXlcIiwgXCJUaHVyc2RheVwiLCBcIkZyaWRheVwiLCBcIlNhdHVyZGF5XCJdLFxyXG4gIHNob3J0RGF5czogW1wiU3VuXCIsIFwiTW9uXCIsIFwiVHVlXCIsIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsIFwiU2F0XCJdLFxyXG4gIG1vbnRoczogW1wiSmFudWFyeVwiLCBcIkZlYnJ1YXJ5XCIsIFwiTWFyY2hcIiwgXCJBcHJpbFwiLCBcIk1heVwiLCBcIkp1bmVcIiwgXCJKdWx5XCIsIFwiQXVndXN0XCIsIFwiU2VwdGVtYmVyXCIsIFwiT2N0b2JlclwiLCBcIk5vdmVtYmVyXCIsIFwiRGVjZW1iZXJcIl0sXHJcbiAgc2hvcnRNb250aHM6IFtcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1heVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkF1Z1wiLCBcIlNlcFwiLCBcIk9jdFwiLCBcIk5vdlwiLCBcIkRlY1wiXVxyXG59KTtcclxuXHJcbmZ1bmN0aW9uIGRlZmF1bHRMb2NhbGUkMShkZWZpbml0aW9uKSB7XHJcbiAgbG9jYWxlJDEgPSBmb3JtYXRMb2NhbGUkMShkZWZpbml0aW9uKTtcclxuICBkMy50aW1lRm9ybWF0ID0gbG9jYWxlJDEuZm9ybWF0O1xyXG4gIGQzLnRpbWVQYXJzZSA9IGxvY2FsZSQxLnBhcnNlO1xyXG4gIGQzLnV0Y0Zvcm1hdCA9IGxvY2FsZSQxLnV0Y0Zvcm1hdDtcclxuICBkMy51dGNQYXJzZSA9IGxvY2FsZSQxLnV0Y1BhcnNlO1xyXG4gIHJldHVybiBsb2NhbGUkMTtcclxufVxyXG5cclxudmFyIGlzb1NwZWNpZmllciA9IFwiJVktJW0tJWRUJUg6JU06JVMuJUxaXCI7XHJcblxyXG5mdW5jdGlvbiBmb3JtYXRJc29OYXRpdmUoZGF0ZSkge1xyXG4gIHJldHVybiBkYXRlLnRvSVNPU3RyaW5nKCk7XHJcbn1cclxuXHJcbnZhciBmb3JtYXRJc28gPSBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZ1xyXG4gICAgPyBmb3JtYXRJc29OYXRpdmVcclxuICAgIDogZDMudXRjRm9ybWF0KGlzb1NwZWNpZmllcik7XHJcblxyXG5mdW5jdGlvbiBwYXJzZUlzb05hdGl2ZShzdHJpbmcpIHtcclxuICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHN0cmluZyk7XHJcbiAgcmV0dXJuIGlzTmFOKGRhdGUpID8gbnVsbCA6IGRhdGU7XHJcbn1cclxuXHJcbnZhciBwYXJzZUlzbyA9ICtuZXcgRGF0ZShcIjIwMDAtMDEtMDFUMDA6MDA6MDAuMDAwWlwiKVxyXG4gICAgPyBwYXJzZUlzb05hdGl2ZVxyXG4gICAgOiBkMy51dGNQYXJzZShpc29TcGVjaWZpZXIpO1xyXG5cclxudmFyIGR1cmF0aW9uU2Vjb25kJDEgPSAxMDAwLFxyXG4gICAgZHVyYXRpb25NaW51dGUkMSA9IGR1cmF0aW9uU2Vjb25kJDEgKiA2MCxcclxuICAgIGR1cmF0aW9uSG91ciQxID0gZHVyYXRpb25NaW51dGUkMSAqIDYwLFxyXG4gICAgZHVyYXRpb25EYXkkMSA9IGR1cmF0aW9uSG91ciQxICogMjQsXHJcbiAgICBkdXJhdGlvbldlZWskMSA9IGR1cmF0aW9uRGF5JDEgKiA3LFxyXG4gICAgZHVyYXRpb25Nb250aCA9IGR1cmF0aW9uRGF5JDEgKiAzMCxcclxuICAgIGR1cmF0aW9uWWVhciA9IGR1cmF0aW9uRGF5JDEgKiAzNjU7XHJcblxyXG5mdW5jdGlvbiBkYXRlJDEodCkge1xyXG4gIHJldHVybiBuZXcgRGF0ZSh0KTtcclxufVxyXG5cclxuZnVuY3Rpb24gbnVtYmVyJDModCkge1xyXG4gIHJldHVybiB0IGluc3RhbmNlb2YgRGF0ZSA/ICt0IDogK25ldyBEYXRlKCt0KTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2FsZW5kYXIoeWVhciQkMSwgbW9udGgkJDEsIHdlZWssIGRheSQkMSwgaG91ciQkMSwgbWludXRlJCQxLCBzZWNvbmQkJDEsIG1pbGxpc2Vjb25kJCQxLCBmb3JtYXQpIHtcclxuICB2YXIgc2NhbGUgPSBjb250aW51b3VzKGRlaW50ZXJwb2xhdGVMaW5lYXIsIHJlaW50ZXJwb2xhdGUpLFxyXG4gICAgICBpbnZlcnQgPSBzY2FsZS5pbnZlcnQsXHJcbiAgICAgIGRvbWFpbiA9IHNjYWxlLmRvbWFpbjtcclxuXHJcbiAgdmFyIGZvcm1hdE1pbGxpc2Vjb25kID0gZm9ybWF0KFwiLiVMXCIpLFxyXG4gICAgICBmb3JtYXRTZWNvbmQgPSBmb3JtYXQoXCI6JVNcIiksXHJcbiAgICAgIGZvcm1hdE1pbnV0ZSA9IGZvcm1hdChcIiVJOiVNXCIpLFxyXG4gICAgICBmb3JtYXRIb3VyID0gZm9ybWF0KFwiJUkgJXBcIiksXHJcbiAgICAgIGZvcm1hdERheSA9IGZvcm1hdChcIiVhICVkXCIpLFxyXG4gICAgICBmb3JtYXRXZWVrID0gZm9ybWF0KFwiJWIgJWRcIiksXHJcbiAgICAgIGZvcm1hdE1vbnRoID0gZm9ybWF0KFwiJUJcIiksXHJcbiAgICAgIGZvcm1hdFllYXIgPSBmb3JtYXQoXCIlWVwiKTtcclxuXHJcbiAgdmFyIHRpY2tJbnRlcnZhbHMgPSBbXHJcbiAgICBbc2Vjb25kJCQxLCAgMSwgICAgICBkdXJhdGlvblNlY29uZCQxXSxcclxuICAgIFtzZWNvbmQkJDEsICA1LCAgNSAqIGR1cmF0aW9uU2Vjb25kJDFdLFxyXG4gICAgW3NlY29uZCQkMSwgMTUsIDE1ICogZHVyYXRpb25TZWNvbmQkMV0sXHJcbiAgICBbc2Vjb25kJCQxLCAzMCwgMzAgKiBkdXJhdGlvblNlY29uZCQxXSxcclxuICAgIFttaW51dGUkJDEsICAxLCAgICAgIGR1cmF0aW9uTWludXRlJDFdLFxyXG4gICAgW21pbnV0ZSQkMSwgIDUsICA1ICogZHVyYXRpb25NaW51dGUkMV0sXHJcbiAgICBbbWludXRlJCQxLCAxNSwgMTUgKiBkdXJhdGlvbk1pbnV0ZSQxXSxcclxuICAgIFttaW51dGUkJDEsIDMwLCAzMCAqIGR1cmF0aW9uTWludXRlJDFdLFxyXG4gICAgWyAgaG91ciQkMSwgIDEsICAgICAgZHVyYXRpb25Ib3VyJDEgIF0sXHJcbiAgICBbICBob3VyJCQxLCAgMywgIDMgKiBkdXJhdGlvbkhvdXIkMSAgXSxcclxuICAgIFsgIGhvdXIkJDEsICA2LCAgNiAqIGR1cmF0aW9uSG91ciQxICBdLFxyXG4gICAgWyAgaG91ciQkMSwgMTIsIDEyICogZHVyYXRpb25Ib3VyJDEgIF0sXHJcbiAgICBbICAgZGF5JCQxLCAgMSwgICAgICBkdXJhdGlvbkRheSQxICAgXSxcclxuICAgIFsgICBkYXkkJDEsICAyLCAgMiAqIGR1cmF0aW9uRGF5JDEgICBdLFxyXG4gICAgWyAgd2VlaywgIDEsICAgICAgZHVyYXRpb25XZWVrJDEgIF0sXHJcbiAgICBbIG1vbnRoJCQxLCAgMSwgICAgICBkdXJhdGlvbk1vbnRoIF0sXHJcbiAgICBbIG1vbnRoJCQxLCAgMywgIDMgKiBkdXJhdGlvbk1vbnRoIF0sXHJcbiAgICBbICB5ZWFyJCQxLCAgMSwgICAgICBkdXJhdGlvblllYXIgIF1cclxuICBdO1xyXG5cclxuICBmdW5jdGlvbiB0aWNrRm9ybWF0KGRhdGUkJDEpIHtcclxuICAgIHJldHVybiAoc2Vjb25kJCQxKGRhdGUkJDEpIDwgZGF0ZSQkMSA/IGZvcm1hdE1pbGxpc2Vjb25kXHJcbiAgICAgICAgOiBtaW51dGUkJDEoZGF0ZSQkMSkgPCBkYXRlJCQxID8gZm9ybWF0U2Vjb25kXHJcbiAgICAgICAgOiBob3VyJCQxKGRhdGUkJDEpIDwgZGF0ZSQkMSA/IGZvcm1hdE1pbnV0ZVxyXG4gICAgICAgIDogZGF5JCQxKGRhdGUkJDEpIDwgZGF0ZSQkMSA/IGZvcm1hdEhvdXJcclxuICAgICAgICA6IG1vbnRoJCQxKGRhdGUkJDEpIDwgZGF0ZSQkMSA/ICh3ZWVrKGRhdGUkJDEpIDwgZGF0ZSQkMSA/IGZvcm1hdERheSA6IGZvcm1hdFdlZWspXHJcbiAgICAgICAgOiB5ZWFyJCQxKGRhdGUkJDEpIDwgZGF0ZSQkMSA/IGZvcm1hdE1vbnRoXHJcbiAgICAgICAgOiBmb3JtYXRZZWFyKShkYXRlJCQxKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHRpY2tJbnRlcnZhbChpbnRlcnZhbCwgc3RhcnQsIHN0b3AsIHN0ZXApIHtcclxuICAgIGlmIChpbnRlcnZhbCA9PSBudWxsKSBpbnRlcnZhbCA9IDEwO1xyXG5cclxuICAgIC8vIElmIGEgZGVzaXJlZCB0aWNrIGNvdW50IGlzIHNwZWNpZmllZCwgcGljayBhIHJlYXNvbmFibGUgdGljayBpbnRlcnZhbFxyXG4gICAgLy8gYmFzZWQgb24gdGhlIGV4dGVudCBvZiB0aGUgZG9tYWluIGFuZCBhIHJvdWdoIGVzdGltYXRlIG9mIHRpY2sgc2l6ZS5cclxuICAgIC8vIE90aGVyd2lzZSwgYXNzdW1lIGludGVydmFsIGlzIGFscmVhZHkgYSB0aW1lIGludGVydmFsIGFuZCB1c2UgaXQuXHJcbiAgICBpZiAodHlwZW9mIGludGVydmFsID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgIHZhciB0YXJnZXQgPSBNYXRoLmFicyhzdG9wIC0gc3RhcnQpIC8gaW50ZXJ2YWwsXHJcbiAgICAgICAgICBpID0gYmlzZWN0b3IoZnVuY3Rpb24oaSkgeyByZXR1cm4gaVsyXTsgfSkucmlnaHQodGlja0ludGVydmFscywgdGFyZ2V0KTtcclxuICAgICAgaWYgKGkgPT09IHRpY2tJbnRlcnZhbHMubGVuZ3RoKSB7XHJcbiAgICAgICAgc3RlcCA9IHRpY2tTdGVwKHN0YXJ0IC8gZHVyYXRpb25ZZWFyLCBzdG9wIC8gZHVyYXRpb25ZZWFyLCBpbnRlcnZhbCk7XHJcbiAgICAgICAgaW50ZXJ2YWwgPSB5ZWFyJCQxO1xyXG4gICAgICB9IGVsc2UgaWYgKGkpIHtcclxuICAgICAgICBpID0gdGlja0ludGVydmFsc1t0YXJnZXQgLyB0aWNrSW50ZXJ2YWxzW2kgLSAxXVsyXSA8IHRpY2tJbnRlcnZhbHNbaV1bMl0gLyB0YXJnZXQgPyBpIC0gMSA6IGldO1xyXG4gICAgICAgIHN0ZXAgPSBpWzFdO1xyXG4gICAgICAgIGludGVydmFsID0gaVswXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzdGVwID0gTWF0aC5tYXgodGlja1N0ZXAoc3RhcnQsIHN0b3AsIGludGVydmFsKSwgMSk7XHJcbiAgICAgICAgaW50ZXJ2YWwgPSBtaWxsaXNlY29uZCQkMTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzdGVwID09IG51bGwgPyBpbnRlcnZhbCA6IGludGVydmFsLmV2ZXJ5KHN0ZXApO1xyXG4gIH1cclxuXHJcbiAgc2NhbGUuaW52ZXJ0ID0gZnVuY3Rpb24oeSkge1xyXG4gICAgcmV0dXJuIG5ldyBEYXRlKGludmVydCh5KSk7XHJcbiAgfTtcclxuXHJcbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBkb21haW4obWFwJDIuY2FsbChfLCBudW1iZXIkMykpIDogZG9tYWluKCkubWFwKGRhdGUkMSk7XHJcbiAgfTtcclxuXHJcbiAgc2NhbGUudGlja3MgPSBmdW5jdGlvbihpbnRlcnZhbCwgc3RlcCkge1xyXG4gICAgdmFyIGQgPSBkb21haW4oKSxcclxuICAgICAgICB0MCA9IGRbMF0sXHJcbiAgICAgICAgdDEgPSBkW2QubGVuZ3RoIC0gMV0sXHJcbiAgICAgICAgciA9IHQxIDwgdDAsXHJcbiAgICAgICAgdDtcclxuICAgIGlmIChyKSB0ID0gdDAsIHQwID0gdDEsIHQxID0gdDtcclxuICAgIHQgPSB0aWNrSW50ZXJ2YWwoaW50ZXJ2YWwsIHQwLCB0MSwgc3RlcCk7XHJcbiAgICB0ID0gdCA/IHQucmFuZ2UodDAsIHQxICsgMSkgOiBbXTsgLy8gaW5jbHVzaXZlIHN0b3BcclxuICAgIHJldHVybiByID8gdC5yZXZlcnNlKCkgOiB0O1xyXG4gIH07XHJcblxyXG4gIHNjYWxlLnRpY2tGb3JtYXQgPSBmdW5jdGlvbihjb3VudCwgc3BlY2lmaWVyKSB7XHJcbiAgICByZXR1cm4gc3BlY2lmaWVyID09IG51bGwgPyB0aWNrRm9ybWF0IDogZm9ybWF0KHNwZWNpZmllcik7XHJcbiAgfTtcclxuXHJcbiAgc2NhbGUubmljZSA9IGZ1bmN0aW9uKGludGVydmFsLCBzdGVwKSB7XHJcbiAgICB2YXIgZCA9IGRvbWFpbigpO1xyXG4gICAgcmV0dXJuIChpbnRlcnZhbCA9IHRpY2tJbnRlcnZhbChpbnRlcnZhbCwgZFswXSwgZFtkLmxlbmd0aCAtIDFdLCBzdGVwKSlcclxuICAgICAgICA/IGRvbWFpbihuaWNlKGQsIGludGVydmFsKSlcclxuICAgICAgICA6IHNjYWxlO1xyXG4gIH07XHJcblxyXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBjb3B5KHNjYWxlLCBjYWxlbmRhcih5ZWFyJCQxLCBtb250aCQkMSwgd2VlaywgZGF5JCQxLCBob3VyJCQxLCBtaW51dGUkJDEsIHNlY29uZCQkMSwgbWlsbGlzZWNvbmQkJDEsIGZvcm1hdCkpO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBzY2FsZTtcclxufVxyXG5cclxuZnVuY3Rpb24gdGltZSgpIHtcclxuICByZXR1cm4gY2FsZW5kYXIoeWVhciwgbW9udGgsIHN1bmRheSwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIGQzLnRpbWVGb3JtYXQpLmRvbWFpbihbbmV3IERhdGUoMjAwMCwgMCwgMSksIG5ldyBEYXRlKDIwMDAsIDAsIDIpXSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHV0Y1RpbWUoKSB7XHJcbiAgcmV0dXJuIGNhbGVuZGFyKHV0Y1llYXIsIHV0Y01vbnRoLCB1dGNTdW5kYXksIHV0Y0RheSwgdXRjSG91ciwgdXRjTWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBkMy51dGNGb3JtYXQpLmRvbWFpbihbRGF0ZS5VVEMoMjAwMCwgMCwgMSksIERhdGUuVVRDKDIwMDAsIDAsIDIpXSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNlcXVlbnRpYWwoaW50ZXJwb2xhdG9yKSB7XHJcbiAgdmFyIHgwID0gMCxcclxuICAgICAgeDEgPSAxLFxyXG4gICAgICBjbGFtcCA9IGZhbHNlO1xyXG5cclxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XHJcbiAgICB2YXIgdCA9ICh4IC0geDApIC8gKHgxIC0geDApO1xyXG4gICAgcmV0dXJuIGludGVycG9sYXRvcihjbGFtcCA/IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHQpKSA6IHQpO1xyXG4gIH1cclxuXHJcbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeDAgPSArX1swXSwgeDEgPSArX1sxXSwgc2NhbGUpIDogW3gwLCB4MV07XHJcbiAgfTtcclxuXHJcbiAgc2NhbGUuY2xhbXAgPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjbGFtcCA9ICEhXywgc2NhbGUpIDogY2xhbXA7XHJcbiAgfTtcclxuXHJcbiAgc2NhbGUuaW50ZXJwb2xhdG9yID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaW50ZXJwb2xhdG9yID0gXywgc2NhbGUpIDogaW50ZXJwb2xhdG9yO1xyXG4gIH07XHJcblxyXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBzZXF1ZW50aWFsKGludGVycG9sYXRvcikuZG9tYWluKFt4MCwgeDFdKS5jbGFtcChjbGFtcCk7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIGxpbmVhcmlzaChzY2FsZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbG9ycyhzcGVjaWZpZXIpIHtcclxuICB2YXIgbiA9IHNwZWNpZmllci5sZW5ndGggLyA2IHwgMCwgY29sb3JzID0gbmV3IEFycmF5KG4pLCBpID0gMDtcclxuICB3aGlsZSAoaSA8IG4pIGNvbG9yc1tpXSA9IFwiI1wiICsgc3BlY2lmaWVyLnNsaWNlKGkgKiA2LCArK2kgKiA2KTtcclxuICByZXR1cm4gY29sb3JzO1xyXG59XHJcblxyXG52YXIgY2F0ZWdvcnkxMCA9IGNvbG9ycyhcIjFmNzdiNGZmN2YwZTJjYTAyY2Q2MjcyODk0NjdiZDhjNTY0YmUzNzdjMjdmN2Y3ZmJjYmQyMjE3YmVjZlwiKTtcclxuXHJcbnZhciBBY2NlbnQgPSBjb2xvcnMoXCI3ZmM5N2ZiZWFlZDRmZGMwODZmZmZmOTkzODZjYjBmMDAyN2ZiZjViMTc2NjY2NjZcIik7XHJcblxyXG52YXIgRGFyazIgPSBjb2xvcnMoXCIxYjllNzdkOTVmMDI3NTcwYjNlNzI5OGE2NmE2MWVlNmFiMDJhNjc2MWQ2NjY2NjZcIik7XHJcblxyXG52YXIgUGFpcmVkID0gY29sb3JzKFwiYTZjZWUzMWY3OGI0YjJkZjhhMzNhMDJjZmI5YTk5ZTMxYTFjZmRiZjZmZmY3ZjAwY2FiMmQ2NmEzZDlhZmZmZjk5YjE1OTI4XCIpO1xyXG5cclxudmFyIFBhc3RlbDEgPSBjb2xvcnMoXCJmYmI0YWViM2NkZTNjY2ViYzVkZWNiZTRmZWQ5YTZmZmZmY2NlNWQ4YmRmZGRhZWNmMmYyZjJcIik7XHJcblxyXG52YXIgUGFzdGVsMiA9IGNvbG9ycyhcImIzZTJjZGZkY2RhY2NiZDVlOGY0Y2FlNGU2ZjVjOWZmZjJhZWYxZTJjY2NjY2NjY1wiKTtcclxuXHJcbnZhciBTZXQxID0gY29sb3JzKFwiZTQxYTFjMzc3ZWI4NGRhZjRhOTg0ZWEzZmY3ZjAwZmZmZjMzYTY1NjI4Zjc4MWJmOTk5OTk5XCIpO1xyXG5cclxudmFyIFNldDIgPSBjb2xvcnMoXCI2NmMyYTVmYzhkNjI4ZGEwY2JlNzhhYzNhNmQ4NTRmZmQ5MmZlNWM0OTRiM2IzYjNcIik7XHJcblxyXG52YXIgU2V0MyA9IGNvbG9ycyhcIjhkZDNjN2ZmZmZiM2JlYmFkYWZiODA3MjgwYjFkM2ZkYjQ2MmIzZGU2OWZjY2RlNWQ5ZDlkOWJjODBiZGNjZWJjNWZmZWQ2ZlwiKTtcclxuXHJcbmZ1bmN0aW9uIHJhbXAoc2NoZW1lKSB7XHJcbiAgcmV0dXJuIHJnYkJhc2lzKHNjaGVtZVtzY2hlbWUubGVuZ3RoIC0gMV0pO1xyXG59XHJcblxyXG52YXIgc2NoZW1lID0gbmV3IEFycmF5KDMpLmNvbmNhdChcclxuICBcImQ4YjM2NWY1ZjVmNTVhYjRhY1wiLFxyXG4gIFwiYTY2MTFhZGZjMjdkODBjZGMxMDE4NTcxXCIsXHJcbiAgXCJhNjYxMWFkZmMyN2RmNWY1ZjU4MGNkYzEwMTg1NzFcIixcclxuICBcIjhjNTEwYWQ4YjM2NWY2ZThjM2M3ZWFlNTVhYjRhYzAxNjY1ZVwiLFxyXG4gIFwiOGM1MTBhZDhiMzY1ZjZlOGMzZjVmNWY1YzdlYWU1NWFiNGFjMDE2NjVlXCIsXHJcbiAgXCI4YzUxMGFiZjgxMmRkZmMyN2RmNmU4YzNjN2VhZTU4MGNkYzEzNTk3OGYwMTY2NWVcIixcclxuICBcIjhjNTEwYWJmODEyZGRmYzI3ZGY2ZThjM2Y1ZjVmNWM3ZWFlNTgwY2RjMTM1OTc4ZjAxNjY1ZVwiLFxyXG4gIFwiNTQzMDA1OGM1MTBhYmY4MTJkZGZjMjdkZjZlOGMzYzdlYWU1ODBjZGMxMzU5NzhmMDE2NjVlMDAzYzMwXCIsXHJcbiAgXCI1NDMwMDU4YzUxMGFiZjgxMmRkZmMyN2RmNmU4YzNmNWY1ZjVjN2VhZTU4MGNkYzEzNTk3OGYwMTY2NWUwMDNjMzBcIlxyXG4pLm1hcChjb2xvcnMpO1xyXG5cclxudmFyIEJyQkcgPSByYW1wKHNjaGVtZSk7XHJcblxyXG52YXIgc2NoZW1lJDEgPSBuZXcgQXJyYXkoMykuY29uY2F0KFxyXG4gIFwiYWY4ZGMzZjdmN2Y3N2ZiZjdiXCIsXHJcbiAgXCI3YjMyOTRjMmE1Y2ZhNmRiYTAwMDg4MzdcIixcclxuICBcIjdiMzI5NGMyYTVjZmY3ZjdmN2E2ZGJhMDAwODgzN1wiLFxyXG4gIFwiNzYyYTgzYWY4ZGMzZTdkNGU4ZDlmMGQzN2ZiZjdiMWI3ODM3XCIsXHJcbiAgXCI3NjJhODNhZjhkYzNlN2Q0ZThmN2Y3ZjdkOWYwZDM3ZmJmN2IxYjc4MzdcIixcclxuICBcIjc2MmE4Mzk5NzBhYmMyYTVjZmU3ZDRlOGQ5ZjBkM2E2ZGJhMDVhYWU2MTFiNzgzN1wiLFxyXG4gIFwiNzYyYTgzOTk3MGFiYzJhNWNmZTdkNGU4ZjdmN2Y3ZDlmMGQzYTZkYmEwNWFhZTYxMWI3ODM3XCIsXHJcbiAgXCI0MDAwNGI3NjJhODM5OTcwYWJjMmE1Y2ZlN2Q0ZThkOWYwZDNhNmRiYTA1YWFlNjExYjc4MzcwMDQ0MWJcIixcclxuICBcIjQwMDA0Yjc2MmE4Mzk5NzBhYmMyYTVjZmU3ZDRlOGY3ZjdmN2Q5ZjBkM2E2ZGJhMDVhYWU2MTFiNzgzNzAwNDQxYlwiXHJcbikubWFwKGNvbG9ycyk7XHJcblxyXG52YXIgUFJHbiA9IHJhbXAoc2NoZW1lJDEpO1xyXG5cclxudmFyIHNjaGVtZSQyID0gbmV3IEFycmF5KDMpLmNvbmNhdChcclxuICBcImU5YTNjOWY3ZjdmN2ExZDc2YVwiLFxyXG4gIFwiZDAxYzhiZjFiNmRhYjhlMTg2NGRhYzI2XCIsXHJcbiAgXCJkMDFjOGJmMWI2ZGFmN2Y3ZjdiOGUxODY0ZGFjMjZcIixcclxuICBcImM1MWI3ZGU5YTNjOWZkZTBlZmU2ZjVkMGExZDc2YTRkOTIyMVwiLFxyXG4gIFwiYzUxYjdkZTlhM2M5ZmRlMGVmZjdmN2Y3ZTZmNWQwYTFkNzZhNGQ5MjIxXCIsXHJcbiAgXCJjNTFiN2RkZTc3YWVmMWI2ZGFmZGUwZWZlNmY1ZDBiOGUxODY3ZmJjNDE0ZDkyMjFcIixcclxuICBcImM1MWI3ZGRlNzdhZWYxYjZkYWZkZTBlZmY3ZjdmN2U2ZjVkMGI4ZTE4NjdmYmM0MTRkOTIyMVwiLFxyXG4gIFwiOGUwMTUyYzUxYjdkZGU3N2FlZjFiNmRhZmRlMGVmZTZmNWQwYjhlMTg2N2ZiYzQxNGQ5MjIxMjc2NDE5XCIsXHJcbiAgXCI4ZTAxNTJjNTFiN2RkZTc3YWVmMWI2ZGFmZGUwZWZmN2Y3ZjdlNmY1ZDBiOGUxODY3ZmJjNDE0ZDkyMjEyNzY0MTlcIlxyXG4pLm1hcChjb2xvcnMpO1xyXG5cclxudmFyIFBpWUcgPSByYW1wKHNjaGVtZSQyKTtcclxuXHJcbnZhciBzY2hlbWUkMyA9IG5ldyBBcnJheSgzKS5jb25jYXQoXHJcbiAgXCI5OThlYzNmN2Y3ZjdmMWEzNDBcIixcclxuICBcIjVlM2M5OWIyYWJkMmZkYjg2M2U2NjEwMVwiLFxyXG4gIFwiNWUzYzk5YjJhYmQyZjdmN2Y3ZmRiODYzZTY2MTAxXCIsXHJcbiAgXCI1NDI3ODg5OThlYzNkOGRhZWJmZWUwYjZmMWEzNDBiMzU4MDZcIixcclxuICBcIjU0Mjc4ODk5OGVjM2Q4ZGFlYmY3ZjdmN2ZlZTBiNmYxYTM0MGIzNTgwNlwiLFxyXG4gIFwiNTQyNzg4ODA3M2FjYjJhYmQyZDhkYWViZmVlMGI2ZmRiODYzZTA4MjE0YjM1ODA2XCIsXHJcbiAgXCI1NDI3ODg4MDczYWNiMmFiZDJkOGRhZWJmN2Y3ZjdmZWUwYjZmZGI4NjNlMDgyMTRiMzU4MDZcIixcclxuICBcIjJkMDA0YjU0Mjc4ODgwNzNhY2IyYWJkMmQ4ZGFlYmZlZTBiNmZkYjg2M2UwODIxNGIzNTgwNjdmM2IwOFwiLFxyXG4gIFwiMmQwMDRiNTQyNzg4ODA3M2FjYjJhYmQyZDhkYWViZjdmN2Y3ZmVlMGI2ZmRiODYzZTA4MjE0YjM1ODA2N2YzYjA4XCJcclxuKS5tYXAoY29sb3JzKTtcclxuXHJcbnZhciBQdU9yID0gcmFtcChzY2hlbWUkMyk7XHJcblxyXG52YXIgc2NoZW1lJDQgPSBuZXcgQXJyYXkoMykuY29uY2F0KFxyXG4gIFwiZWY4YTYyZjdmN2Y3NjdhOWNmXCIsXHJcbiAgXCJjYTAwMjBmNGE1ODI5MmM1ZGUwNTcxYjBcIixcclxuICBcImNhMDAyMGY0YTU4MmY3ZjdmNzkyYzVkZTA1NzFiMFwiLFxyXG4gIFwiYjIxODJiZWY4YTYyZmRkYmM3ZDFlNWYwNjdhOWNmMjE2NmFjXCIsXHJcbiAgXCJiMjE4MmJlZjhhNjJmZGRiYzdmN2Y3ZjdkMWU1ZjA2N2E5Y2YyMTY2YWNcIixcclxuICBcImIyMTgyYmQ2NjA0ZGY0YTU4MmZkZGJjN2QxZTVmMDkyYzVkZTQzOTNjMzIxNjZhY1wiLFxyXG4gIFwiYjIxODJiZDY2MDRkZjRhNTgyZmRkYmM3ZjdmN2Y3ZDFlNWYwOTJjNWRlNDM5M2MzMjE2NmFjXCIsXHJcbiAgXCI2NzAwMWZiMjE4MmJkNjYwNGRmNGE1ODJmZGRiYzdkMWU1ZjA5MmM1ZGU0MzkzYzMyMTY2YWMwNTMwNjFcIixcclxuICBcIjY3MDAxZmIyMTgyYmQ2NjA0ZGY0YTU4MmZkZGJjN2Y3ZjdmN2QxZTVmMDkyYzVkZTQzOTNjMzIxNjZhYzA1MzA2MVwiXHJcbikubWFwKGNvbG9ycyk7XHJcblxyXG52YXIgUmRCdSA9IHJhbXAoc2NoZW1lJDQpO1xyXG5cclxudmFyIHNjaGVtZSQ1ID0gbmV3IEFycmF5KDMpLmNvbmNhdChcclxuICBcImVmOGE2MmZmZmZmZjk5OTk5OVwiLFxyXG4gIFwiY2EwMDIwZjRhNTgyYmFiYWJhNDA0MDQwXCIsXHJcbiAgXCJjYTAwMjBmNGE1ODJmZmZmZmZiYWJhYmE0MDQwNDBcIixcclxuICBcImIyMTgyYmVmOGE2MmZkZGJjN2UwZTBlMDk5OTk5OTRkNGQ0ZFwiLFxyXG4gIFwiYjIxODJiZWY4YTYyZmRkYmM3ZmZmZmZmZTBlMGUwOTk5OTk5NGQ0ZDRkXCIsXHJcbiAgXCJiMjE4MmJkNjYwNGRmNGE1ODJmZGRiYzdlMGUwZTBiYWJhYmE4Nzg3ODc0ZDRkNGRcIixcclxuICBcImIyMTgyYmQ2NjA0ZGY0YTU4MmZkZGJjN2ZmZmZmZmUwZTBlMGJhYmFiYTg3ODc4NzRkNGQ0ZFwiLFxyXG4gIFwiNjcwMDFmYjIxODJiZDY2MDRkZjRhNTgyZmRkYmM3ZTBlMGUwYmFiYWJhODc4Nzg3NGQ0ZDRkMWExYTFhXCIsXHJcbiAgXCI2NzAwMWZiMjE4MmJkNjYwNGRmNGE1ODJmZGRiYzdmZmZmZmZlMGUwZTBiYWJhYmE4Nzg3ODc0ZDRkNGQxYTFhMWFcIlxyXG4pLm1hcChjb2xvcnMpO1xyXG5cclxudmFyIFJkR3kgPSByYW1wKHNjaGVtZSQ1KTtcclxuXHJcbnZhciBzY2hlbWUkNiA9IG5ldyBBcnJheSgzKS5jb25jYXQoXHJcbiAgXCJmYzhkNTlmZmZmYmY5MWJmZGJcIixcclxuICBcImQ3MTkxY2ZkYWU2MWFiZDllOTJjN2JiNlwiLFxyXG4gIFwiZDcxOTFjZmRhZTYxZmZmZmJmYWJkOWU5MmM3YmI2XCIsXHJcbiAgXCJkNzMwMjdmYzhkNTlmZWUwOTBlMGYzZjg5MWJmZGI0NTc1YjRcIixcclxuICBcImQ3MzAyN2ZjOGQ1OWZlZTA5MGZmZmZiZmUwZjNmODkxYmZkYjQ1NzViNFwiLFxyXG4gIFwiZDczMDI3ZjQ2ZDQzZmRhZTYxZmVlMDkwZTBmM2Y4YWJkOWU5NzRhZGQxNDU3NWI0XCIsXHJcbiAgXCJkNzMwMjdmNDZkNDNmZGFlNjFmZWUwOTBmZmZmYmZlMGYzZjhhYmQ5ZTk3NGFkZDE0NTc1YjRcIixcclxuICBcImE1MDAyNmQ3MzAyN2Y0NmQ0M2ZkYWU2MWZlZTA5MGUwZjNmOGFiZDllOTc0YWRkMTQ1NzViNDMxMzY5NVwiLFxyXG4gIFwiYTUwMDI2ZDczMDI3ZjQ2ZDQzZmRhZTYxZmVlMDkwZmZmZmJmZTBmM2Y4YWJkOWU5NzRhZGQxNDU3NWI0MzEzNjk1XCJcclxuKS5tYXAoY29sb3JzKTtcclxuXHJcbnZhciBSZFlsQnUgPSByYW1wKHNjaGVtZSQ2KTtcclxuXHJcbnZhciBzY2hlbWUkNyA9IG5ldyBBcnJheSgzKS5jb25jYXQoXHJcbiAgXCJmYzhkNTlmZmZmYmY5MWNmNjBcIixcclxuICBcImQ3MTkxY2ZkYWU2MWE2ZDk2YTFhOTY0MVwiLFxyXG4gIFwiZDcxOTFjZmRhZTYxZmZmZmJmYTZkOTZhMWE5NjQxXCIsXHJcbiAgXCJkNzMwMjdmYzhkNTlmZWUwOGJkOWVmOGI5MWNmNjAxYTk4NTBcIixcclxuICBcImQ3MzAyN2ZjOGQ1OWZlZTA4YmZmZmZiZmQ5ZWY4YjkxY2Y2MDFhOTg1MFwiLFxyXG4gIFwiZDczMDI3ZjQ2ZDQzZmRhZTYxZmVlMDhiZDllZjhiYTZkOTZhNjZiZDYzMWE5ODUwXCIsXHJcbiAgXCJkNzMwMjdmNDZkNDNmZGFlNjFmZWUwOGJmZmZmYmZkOWVmOGJhNmQ5NmE2NmJkNjMxYTk4NTBcIixcclxuICBcImE1MDAyNmQ3MzAyN2Y0NmQ0M2ZkYWU2MWZlZTA4YmQ5ZWY4YmE2ZDk2YTY2YmQ2MzFhOTg1MDAwNjgzN1wiLFxyXG4gIFwiYTUwMDI2ZDczMDI3ZjQ2ZDQzZmRhZTYxZmVlMDhiZmZmZmJmZDllZjhiYTZkOTZhNjZiZDYzMWE5ODUwMDA2ODM3XCJcclxuKS5tYXAoY29sb3JzKTtcclxuXHJcbnZhciBSZFlsR24gPSByYW1wKHNjaGVtZSQ3KTtcclxuXHJcbnZhciBzY2hlbWUkOCA9IG5ldyBBcnJheSgzKS5jb25jYXQoXHJcbiAgXCJmYzhkNTlmZmZmYmY5OWQ1OTRcIixcclxuICBcImQ3MTkxY2ZkYWU2MWFiZGRhNDJiODNiYVwiLFxyXG4gIFwiZDcxOTFjZmRhZTYxZmZmZmJmYWJkZGE0MmI4M2JhXCIsXHJcbiAgXCJkNTNlNGZmYzhkNTlmZWUwOGJlNmY1OTg5OWQ1OTQzMjg4YmRcIixcclxuICBcImQ1M2U0ZmZjOGQ1OWZlZTA4YmZmZmZiZmU2ZjU5ODk5ZDU5NDMyODhiZFwiLFxyXG4gIFwiZDUzZTRmZjQ2ZDQzZmRhZTYxZmVlMDhiZTZmNTk4YWJkZGE0NjZjMmE1MzI4OGJkXCIsXHJcbiAgXCJkNTNlNGZmNDZkNDNmZGFlNjFmZWUwOGJmZmZmYmZlNmY1OThhYmRkYTQ2NmMyYTUzMjg4YmRcIixcclxuICBcIjllMDE0MmQ1M2U0ZmY0NmQ0M2ZkYWU2MWZlZTA4YmU2ZjU5OGFiZGRhNDY2YzJhNTMyODhiZDVlNGZhMlwiLFxyXG4gIFwiOWUwMTQyZDUzZTRmZjQ2ZDQzZmRhZTYxZmVlMDhiZmZmZmJmZTZmNTk4YWJkZGE0NjZjMmE1MzI4OGJkNWU0ZmEyXCJcclxuKS5tYXAoY29sb3JzKTtcclxuXHJcbnZhciBTcGVjdHJhbCA9IHJhbXAoc2NoZW1lJDgpO1xyXG5cclxudmFyIHNjaGVtZSQ5ID0gbmV3IEFycmF5KDMpLmNvbmNhdChcclxuICBcImU1ZjVmOTk5ZDhjOTJjYTI1ZlwiLFxyXG4gIFwiZWRmOGZiYjJlMmUyNjZjMmE0MjM4YjQ1XCIsXHJcbiAgXCJlZGY4ZmJiMmUyZTI2NmMyYTQyY2EyNWYwMDZkMmNcIixcclxuICBcImVkZjhmYmNjZWNlNjk5ZDhjOTY2YzJhNDJjYTI1ZjAwNmQyY1wiLFxyXG4gIFwiZWRmOGZiY2NlY2U2OTlkOGM5NjZjMmE0NDFhZTc2MjM4YjQ1MDA1ODI0XCIsXHJcbiAgXCJmN2ZjZmRlNWY1ZjljY2VjZTY5OWQ4Yzk2NmMyYTQ0MWFlNzYyMzhiNDUwMDU4MjRcIixcclxuICBcImY3ZmNmZGU1ZjVmOWNjZWNlNjk5ZDhjOTY2YzJhNDQxYWU3NjIzOGI0NTAwNmQyYzAwNDQxYlwiXHJcbikubWFwKGNvbG9ycyk7XHJcblxyXG52YXIgQnVHbiA9IHJhbXAoc2NoZW1lJDkpO1xyXG5cclxudmFyIHNjaGVtZSQxMCA9IG5ldyBBcnJheSgzKS5jb25jYXQoXHJcbiAgXCJlMGVjZjQ5ZWJjZGE4ODU2YTdcIixcclxuICBcImVkZjhmYmIzY2RlMzhjOTZjNjg4NDE5ZFwiLFxyXG4gIFwiZWRmOGZiYjNjZGUzOGM5NmM2ODg1NmE3ODEwZjdjXCIsXHJcbiAgXCJlZGY4ZmJiZmQzZTY5ZWJjZGE4Yzk2YzY4ODU2YTc4MTBmN2NcIixcclxuICBcImVkZjhmYmJmZDNlNjllYmNkYThjOTZjNjhjNmJiMTg4NDE5ZDZlMDE2YlwiLFxyXG4gIFwiZjdmY2ZkZTBlY2Y0YmZkM2U2OWViY2RhOGM5NmM2OGM2YmIxODg0MTlkNmUwMTZiXCIsXHJcbiAgXCJmN2ZjZmRlMGVjZjRiZmQzZTY5ZWJjZGE4Yzk2YzY4YzZiYjE4ODQxOWQ4MTBmN2M0ZDAwNGJcIlxyXG4pLm1hcChjb2xvcnMpO1xyXG5cclxudmFyIEJ1UHUgPSByYW1wKHNjaGVtZSQxMCk7XHJcblxyXG52YXIgc2NoZW1lJDExID0gbmV3IEFycmF5KDMpLmNvbmNhdChcclxuICBcImUwZjNkYmE4ZGRiNTQzYTJjYVwiLFxyXG4gIFwiZjBmOWU4YmFlNGJjN2JjY2M0MmI4Y2JlXCIsXHJcbiAgXCJmMGY5ZThiYWU0YmM3YmNjYzQ0M2EyY2EwODY4YWNcIixcclxuICBcImYwZjllOGNjZWJjNWE4ZGRiNTdiY2NjNDQzYTJjYTA4NjhhY1wiLFxyXG4gIFwiZjBmOWU4Y2NlYmM1YThkZGI1N2JjY2M0NGViM2QzMmI4Y2JlMDg1ODllXCIsXHJcbiAgXCJmN2ZjZjBlMGYzZGJjY2ViYzVhOGRkYjU3YmNjYzQ0ZWIzZDMyYjhjYmUwODU4OWVcIixcclxuICBcImY3ZmNmMGUwZjNkYmNjZWJjNWE4ZGRiNTdiY2NjNDRlYjNkMzJiOGNiZTA4NjhhYzA4NDA4MVwiXHJcbikubWFwKGNvbG9ycyk7XHJcblxyXG52YXIgR25CdSA9IHJhbXAoc2NoZW1lJDExKTtcclxuXHJcbnZhciBzY2hlbWUkMTIgPSBuZXcgQXJyYXkoMykuY29uY2F0KFxyXG4gIFwiZmVlOGM4ZmRiYjg0ZTM0YTMzXCIsXHJcbiAgXCJmZWYwZDlmZGNjOGFmYzhkNTlkNzMwMWZcIixcclxuICBcImZlZjBkOWZkY2M4YWZjOGQ1OWUzNGEzM2IzMDAwMFwiLFxyXG4gIFwiZmVmMGQ5ZmRkNDllZmRiYjg0ZmM4ZDU5ZTM0YTMzYjMwMDAwXCIsXHJcbiAgXCJmZWYwZDlmZGQ0OWVmZGJiODRmYzhkNTllZjY1NDhkNzMwMWY5OTAwMDBcIixcclxuICBcImZmZjdlY2ZlZThjOGZkZDQ5ZWZkYmI4NGZjOGQ1OWVmNjU0OGQ3MzAxZjk5MDAwMFwiLFxyXG4gIFwiZmZmN2VjZmVlOGM4ZmRkNDllZmRiYjg0ZmM4ZDU5ZWY2NTQ4ZDczMDFmYjMwMDAwN2YwMDAwXCJcclxuKS5tYXAoY29sb3JzKTtcclxuXHJcbnZhciBPclJkID0gcmFtcChzY2hlbWUkMTIpO1xyXG5cclxudmFyIHNjaGVtZSQxMyA9IG5ldyBBcnJheSgzKS5jb25jYXQoXHJcbiAgXCJlY2UyZjBhNmJkZGIxYzkwOTlcIixcclxuICBcImY2ZWZmN2JkYzllMTY3YTljZjAyODE4YVwiLFxyXG4gIFwiZjZlZmY3YmRjOWUxNjdhOWNmMWM5MDk5MDE2YzU5XCIsXHJcbiAgXCJmNmVmZjdkMGQxZTZhNmJkZGI2N2E5Y2YxYzkwOTkwMTZjNTlcIixcclxuICBcImY2ZWZmN2QwZDFlNmE2YmRkYjY3YTljZjM2OTBjMDAyODE4YTAxNjQ1MFwiLFxyXG4gIFwiZmZmN2ZiZWNlMmYwZDBkMWU2YTZiZGRiNjdhOWNmMzY5MGMwMDI4MThhMDE2NDUwXCIsXHJcbiAgXCJmZmY3ZmJlY2UyZjBkMGQxZTZhNmJkZGI2N2E5Y2YzNjkwYzAwMjgxOGEwMTZjNTkwMTQ2MzZcIlxyXG4pLm1hcChjb2xvcnMpO1xyXG5cclxudmFyIFB1QnVHbiA9IHJhbXAoc2NoZW1lJDEzKTtcclxuXHJcbnZhciBzY2hlbWUkMTQgPSBuZXcgQXJyYXkoMykuY29uY2F0KFxyXG4gIFwiZWNlN2YyYTZiZGRiMmI4Y2JlXCIsXHJcbiAgXCJmMWVlZjZiZGM5ZTE3NGE5Y2YwNTcwYjBcIixcclxuICBcImYxZWVmNmJkYzllMTc0YTljZjJiOGNiZTA0NWE4ZFwiLFxyXG4gIFwiZjFlZWY2ZDBkMWU2YTZiZGRiNzRhOWNmMmI4Y2JlMDQ1YThkXCIsXHJcbiAgXCJmMWVlZjZkMGQxZTZhNmJkZGI3NGE5Y2YzNjkwYzAwNTcwYjAwMzRlN2JcIixcclxuICBcImZmZjdmYmVjZTdmMmQwZDFlNmE2YmRkYjc0YTljZjM2OTBjMDA1NzBiMDAzNGU3YlwiLFxyXG4gIFwiZmZmN2ZiZWNlN2YyZDBkMWU2YTZiZGRiNzRhOWNmMzY5MGMwMDU3MGIwMDQ1YThkMDIzODU4XCJcclxuKS5tYXAoY29sb3JzKTtcclxuXHJcbnZhciBQdUJ1ID0gcmFtcChzY2hlbWUkMTQpO1xyXG5cclxudmFyIHNjaGVtZSQxNSA9IG5ldyBBcnJheSgzKS5jb25jYXQoXHJcbiAgXCJlN2UxZWZjOTk0YzdkZDFjNzdcIixcclxuICBcImYxZWVmNmQ3YjVkOGRmNjViMGNlMTI1NlwiLFxyXG4gIFwiZjFlZWY2ZDdiNWQ4ZGY2NWIwZGQxYzc3OTgwMDQzXCIsXHJcbiAgXCJmMWVlZjZkNGI5ZGFjOTk0YzdkZjY1YjBkZDFjNzc5ODAwNDNcIixcclxuICBcImYxZWVmNmQ0YjlkYWM5OTRjN2RmNjViMGU3Mjk4YWNlMTI1NjkxMDAzZlwiLFxyXG4gIFwiZjdmNGY5ZTdlMWVmZDRiOWRhYzk5NGM3ZGY2NWIwZTcyOThhY2UxMjU2OTEwMDNmXCIsXHJcbiAgXCJmN2Y0ZjllN2UxZWZkNGI5ZGFjOTk0YzdkZjY1YjBlNzI5OGFjZTEyNTY5ODAwNDM2NzAwMWZcIlxyXG4pLm1hcChjb2xvcnMpO1xyXG5cclxudmFyIFB1UmQgPSByYW1wKHNjaGVtZSQxNSk7XHJcblxyXG52YXIgc2NoZW1lJDE2ID0gbmV3IEFycmF5KDMpLmNvbmNhdChcclxuICBcImZkZTBkZGZhOWZiNWM1MWI4YVwiLFxyXG4gIFwiZmVlYmUyZmJiNGI5Zjc2OGExYWUwMTdlXCIsXHJcbiAgXCJmZWViZTJmYmI0YjlmNzY4YTFjNTFiOGE3YTAxNzdcIixcclxuICBcImZlZWJlMmZjYzVjMGZhOWZiNWY3NjhhMWM1MWI4YTdhMDE3N1wiLFxyXG4gIFwiZmVlYmUyZmNjNWMwZmE5ZmI1Zjc2OGExZGQzNDk3YWUwMTdlN2EwMTc3XCIsXHJcbiAgXCJmZmY3ZjNmZGUwZGRmY2M1YzBmYTlmYjVmNzY4YTFkZDM0OTdhZTAxN2U3YTAxNzdcIixcclxuICBcImZmZjdmM2ZkZTBkZGZjYzVjMGZhOWZiNWY3NjhhMWRkMzQ5N2FlMDE3ZTdhMDE3NzQ5MDA2YVwiXHJcbikubWFwKGNvbG9ycyk7XHJcblxyXG52YXIgUmRQdSA9IHJhbXAoc2NoZW1lJDE2KTtcclxuXHJcbnZhciBzY2hlbWUkMTcgPSBuZXcgQXJyYXkoMykuY29uY2F0KFxyXG4gIFwiZWRmOGIxN2ZjZGJiMmM3ZmI4XCIsXHJcbiAgXCJmZmZmY2NhMWRhYjQ0MWI2YzQyMjVlYThcIixcclxuICBcImZmZmZjY2ExZGFiNDQxYjZjNDJjN2ZiODI1MzQ5NFwiLFxyXG4gIFwiZmZmZmNjYzdlOWI0N2ZjZGJiNDFiNmM0MmM3ZmI4MjUzNDk0XCIsXHJcbiAgXCJmZmZmY2NjN2U5YjQ3ZmNkYmI0MWI2YzQxZDkxYzAyMjVlYTgwYzJjODRcIixcclxuICBcImZmZmZkOWVkZjhiMWM3ZTliNDdmY2RiYjQxYjZjNDFkOTFjMDIyNWVhODBjMmM4NFwiLFxyXG4gIFwiZmZmZmQ5ZWRmOGIxYzdlOWI0N2ZjZGJiNDFiNmM0MWQ5MWMwMjI1ZWE4MjUzNDk0MDgxZDU4XCJcclxuKS5tYXAoY29sb3JzKTtcclxuXHJcbnZhciBZbEduQnUgPSByYW1wKHNjaGVtZSQxNyk7XHJcblxyXG52YXIgc2NoZW1lJDE4ID0gbmV3IEFycmF5KDMpLmNvbmNhdChcclxuICBcImY3ZmNiOWFkZGQ4ZTMxYTM1NFwiLFxyXG4gIFwiZmZmZmNjYzJlNjk5NzhjNjc5MjM4NDQzXCIsXHJcbiAgXCJmZmZmY2NjMmU2OTk3OGM2NzkzMWEzNTQwMDY4MzdcIixcclxuICBcImZmZmZjY2Q5ZjBhM2FkZGQ4ZTc4YzY3OTMxYTM1NDAwNjgzN1wiLFxyXG4gIFwiZmZmZmNjZDlmMGEzYWRkZDhlNzhjNjc5NDFhYjVkMjM4NDQzMDA1YTMyXCIsXHJcbiAgXCJmZmZmZTVmN2ZjYjlkOWYwYTNhZGRkOGU3OGM2Nzk0MWFiNWQyMzg0NDMwMDVhMzJcIixcclxuICBcImZmZmZlNWY3ZmNiOWQ5ZjBhM2FkZGQ4ZTc4YzY3OTQxYWI1ZDIzODQ0MzAwNjgzNzAwNDUyOVwiXHJcbikubWFwKGNvbG9ycyk7XHJcblxyXG52YXIgWWxHbiA9IHJhbXAoc2NoZW1lJDE4KTtcclxuXHJcbnZhciBzY2hlbWUkMTkgPSBuZXcgQXJyYXkoMykuY29uY2F0KFxyXG4gIFwiZmZmN2JjZmVjNDRmZDk1ZjBlXCIsXHJcbiAgXCJmZmZmZDRmZWQ5OGVmZTk5MjljYzRjMDJcIixcclxuICBcImZmZmZkNGZlZDk4ZWZlOTkyOWQ5NWYwZTk5MzQwNFwiLFxyXG4gIFwiZmZmZmQ0ZmVlMzkxZmVjNDRmZmU5OTI5ZDk1ZjBlOTkzNDA0XCIsXHJcbiAgXCJmZmZmZDRmZWUzOTFmZWM0NGZmZTk5MjllYzcwMTRjYzRjMDI4YzJkMDRcIixcclxuICBcImZmZmZlNWZmZjdiY2ZlZTM5MWZlYzQ0ZmZlOTkyOWVjNzAxNGNjNGMwMjhjMmQwNFwiLFxyXG4gIFwiZmZmZmU1ZmZmN2JjZmVlMzkxZmVjNDRmZmU5OTI5ZWM3MDE0Y2M0YzAyOTkzNDA0NjYyNTA2XCJcclxuKS5tYXAoY29sb3JzKTtcclxuXHJcbnZhciBZbE9yQnIgPSByYW1wKHNjaGVtZSQxOSk7XHJcblxyXG52YXIgc2NoZW1lJDIwID0gbmV3IEFycmF5KDMpLmNvbmNhdChcclxuICBcImZmZWRhMGZlYjI0Y2YwM2IyMFwiLFxyXG4gIFwiZmZmZmIyZmVjYzVjZmQ4ZDNjZTMxYTFjXCIsXHJcbiAgXCJmZmZmYjJmZWNjNWNmZDhkM2NmMDNiMjBiZDAwMjZcIixcclxuICBcImZmZmZiMmZlZDk3NmZlYjI0Y2ZkOGQzY2YwM2IyMGJkMDAyNlwiLFxyXG4gIFwiZmZmZmIyZmVkOTc2ZmViMjRjZmQ4ZDNjZmM0ZTJhZTMxYTFjYjEwMDI2XCIsXHJcbiAgXCJmZmZmY2NmZmVkYTBmZWQ5NzZmZWIyNGNmZDhkM2NmYzRlMmFlMzFhMWNiMTAwMjZcIixcclxuICBcImZmZmZjY2ZmZWRhMGZlZDk3NmZlYjI0Y2ZkOGQzY2ZjNGUyYWUzMWExY2JkMDAyNjgwMDAyNlwiXHJcbikubWFwKGNvbG9ycyk7XHJcblxyXG52YXIgWWxPclJkID0gcmFtcChzY2hlbWUkMjApO1xyXG5cclxudmFyIHNjaGVtZSQyMSA9IG5ldyBBcnJheSgzKS5jb25jYXQoXHJcbiAgXCJkZWViZjc5ZWNhZTEzMTgyYmRcIixcclxuICBcImVmZjNmZmJkZDdlNzZiYWVkNjIxNzFiNVwiLFxyXG4gIFwiZWZmM2ZmYmRkN2U3NmJhZWQ2MzE4MmJkMDg1MTljXCIsXHJcbiAgXCJlZmYzZmZjNmRiZWY5ZWNhZTE2YmFlZDYzMTgyYmQwODUxOWNcIixcclxuICBcImVmZjNmZmM2ZGJlZjllY2FlMTZiYWVkNjQyOTJjNjIxNzFiNTA4NDU5NFwiLFxyXG4gIFwiZjdmYmZmZGVlYmY3YzZkYmVmOWVjYWUxNmJhZWQ2NDI5MmM2MjE3MWI1MDg0NTk0XCIsXHJcbiAgXCJmN2ZiZmZkZWViZjdjNmRiZWY5ZWNhZTE2YmFlZDY0MjkyYzYyMTcxYjUwODUxOWMwODMwNmJcIlxyXG4pLm1hcChjb2xvcnMpO1xyXG5cclxudmFyIEJsdWVzID0gcmFtcChzY2hlbWUkMjEpO1xyXG5cclxudmFyIHNjaGVtZSQyMiA9IG5ldyBBcnJheSgzKS5jb25jYXQoXHJcbiAgXCJlNWY1ZTBhMWQ5OWIzMWEzNTRcIixcclxuICBcImVkZjhlOWJhZTRiMzc0YzQ3NjIzOGI0NVwiLFxyXG4gIFwiZWRmOGU5YmFlNGIzNzRjNDc2MzFhMzU0MDA2ZDJjXCIsXHJcbiAgXCJlZGY4ZTljN2U5YzBhMWQ5OWI3NGM0NzYzMWEzNTQwMDZkMmNcIixcclxuICBcImVkZjhlOWM3ZTljMGExZDk5Yjc0YzQ3NjQxYWI1ZDIzOGI0NTAwNWEzMlwiLFxyXG4gIFwiZjdmY2Y1ZTVmNWUwYzdlOWMwYTFkOTliNzRjNDc2NDFhYjVkMjM4YjQ1MDA1YTMyXCIsXHJcbiAgXCJmN2ZjZjVlNWY1ZTBjN2U5YzBhMWQ5OWI3NGM0NzY0MWFiNWQyMzhiNDUwMDZkMmMwMDQ0MWJcIlxyXG4pLm1hcChjb2xvcnMpO1xyXG5cclxudmFyIEdyZWVucyA9IHJhbXAoc2NoZW1lJDIyKTtcclxuXHJcbnZhciBzY2hlbWUkMjMgPSBuZXcgQXJyYXkoMykuY29uY2F0KFxyXG4gIFwiZjBmMGYwYmRiZGJkNjM2MzYzXCIsXHJcbiAgXCJmN2Y3ZjdjY2NjY2M5Njk2OTY1MjUyNTJcIixcclxuICBcImY3ZjdmN2NjY2NjYzk2OTY5NjYzNjM2MzI1MjUyNVwiLFxyXG4gIFwiZjdmN2Y3ZDlkOWQ5YmRiZGJkOTY5Njk2NjM2MzYzMjUyNTI1XCIsXHJcbiAgXCJmN2Y3ZjdkOWQ5ZDliZGJkYmQ5Njk2OTY3MzczNzM1MjUyNTIyNTI1MjVcIixcclxuICBcImZmZmZmZmYwZjBmMGQ5ZDlkOWJkYmRiZDk2OTY5NjczNzM3MzUyNTI1MjI1MjUyNVwiLFxyXG4gIFwiZmZmZmZmZjBmMGYwZDlkOWQ5YmRiZGJkOTY5Njk2NzM3MzczNTI1MjUyMjUyNTI1MDAwMDAwXCJcclxuKS5tYXAoY29sb3JzKTtcclxuXHJcbnZhciBHcmV5cyA9IHJhbXAoc2NoZW1lJDIzKTtcclxuXHJcbnZhciBzY2hlbWUkMjQgPSBuZXcgQXJyYXkoMykuY29uY2F0KFxyXG4gIFwiZWZlZGY1YmNiZGRjNzU2YmIxXCIsXHJcbiAgXCJmMmYwZjdjYmM5ZTI5ZTlhYzg2YTUxYTNcIixcclxuICBcImYyZjBmN2NiYzllMjllOWFjODc1NmJiMTU0Mjc4ZlwiLFxyXG4gIFwiZjJmMGY3ZGFkYWViYmNiZGRjOWU5YWM4NzU2YmIxNTQyNzhmXCIsXHJcbiAgXCJmMmYwZjdkYWRhZWJiY2JkZGM5ZTlhYzg4MDdkYmE2YTUxYTM0YTE0ODZcIixcclxuICBcImZjZmJmZGVmZWRmNWRhZGFlYmJjYmRkYzllOWFjODgwN2RiYTZhNTFhMzRhMTQ4NlwiLFxyXG4gIFwiZmNmYmZkZWZlZGY1ZGFkYWViYmNiZGRjOWU5YWM4ODA3ZGJhNmE1MWEzNTQyNzhmM2YwMDdkXCJcclxuKS5tYXAoY29sb3JzKTtcclxuXHJcbnZhciBQdXJwbGVzID0gcmFtcChzY2hlbWUkMjQpO1xyXG5cclxudmFyIHNjaGVtZSQyNSA9IG5ldyBBcnJheSgzKS5jb25jYXQoXHJcbiAgXCJmZWUwZDJmYzkyNzJkZTJkMjZcIixcclxuICBcImZlZTVkOWZjYWU5MWZiNmE0YWNiMTgxZFwiLFxyXG4gIFwiZmVlNWQ5ZmNhZTkxZmI2YTRhZGUyZDI2YTUwZjE1XCIsXHJcbiAgXCJmZWU1ZDlmY2JiYTFmYzkyNzJmYjZhNGFkZTJkMjZhNTBmMTVcIixcclxuICBcImZlZTVkOWZjYmJhMWZjOTI3MmZiNmE0YWVmM2IyY2NiMTgxZDk5MDAwZFwiLFxyXG4gIFwiZmZmNWYwZmVlMGQyZmNiYmExZmM5MjcyZmI2YTRhZWYzYjJjY2IxODFkOTkwMDBkXCIsXHJcbiAgXCJmZmY1ZjBmZWUwZDJmY2JiYTFmYzkyNzJmYjZhNGFlZjNiMmNjYjE4MWRhNTBmMTU2NzAwMGRcIlxyXG4pLm1hcChjb2xvcnMpO1xyXG5cclxudmFyIFJlZHMgPSByYW1wKHNjaGVtZSQyNSk7XHJcblxyXG52YXIgc2NoZW1lJDI2ID0gbmV3IEFycmF5KDMpLmNvbmNhdChcclxuICBcImZlZTZjZWZkYWU2YmU2NTUwZFwiLFxyXG4gIFwiZmVlZGRlZmRiZTg1ZmQ4ZDNjZDk0NzAxXCIsXHJcbiAgXCJmZWVkZGVmZGJlODVmZDhkM2NlNjU1MGRhNjM2MDNcIixcclxuICBcImZlZWRkZWZkZDBhMmZkYWU2YmZkOGQzY2U2NTUwZGE2MzYwM1wiLFxyXG4gIFwiZmVlZGRlZmRkMGEyZmRhZTZiZmQ4ZDNjZjE2OTEzZDk0ODAxOGMyZDA0XCIsXHJcbiAgXCJmZmY1ZWJmZWU2Y2VmZGQwYTJmZGFlNmJmZDhkM2NmMTY5MTNkOTQ4MDE4YzJkMDRcIixcclxuICBcImZmZjVlYmZlZTZjZWZkZDBhMmZkYWU2YmZkOGQzY2YxNjkxM2Q5NDgwMWE2MzYwMzdmMjcwNFwiXHJcbikubWFwKGNvbG9ycyk7XHJcblxyXG52YXIgT3JhbmdlcyA9IHJhbXAoc2NoZW1lJDI2KTtcclxuXHJcbnZhciBjdWJlaGVsaXgkMyA9IGN1YmVoZWxpeExvbmcoY3ViZWhlbGl4KDMwMCwgMC41LCAwLjApLCBjdWJlaGVsaXgoLTI0MCwgMC41LCAxLjApKTtcclxuXHJcbnZhciB3YXJtID0gY3ViZWhlbGl4TG9uZyhjdWJlaGVsaXgoLTEwMCwgMC43NSwgMC4zNSksIGN1YmVoZWxpeCg4MCwgMS41MCwgMC44KSk7XHJcblxyXG52YXIgY29vbCA9IGN1YmVoZWxpeExvbmcoY3ViZWhlbGl4KDI2MCwgMC43NSwgMC4zNSksIGN1YmVoZWxpeCg4MCwgMS41MCwgMC44KSk7XHJcblxyXG52YXIgYyA9IGN1YmVoZWxpeCgpO1xyXG5cclxuZnVuY3Rpb24gcmFpbmJvdyh0KSB7XHJcbiAgaWYgKHQgPCAwIHx8IHQgPiAxKSB0IC09IE1hdGguZmxvb3IodCk7XHJcbiAgdmFyIHRzID0gTWF0aC5hYnModCAtIDAuNSk7XHJcbiAgYy5oID0gMzYwICogdCAtIDEwMDtcclxuICBjLnMgPSAxLjUgLSAxLjUgKiB0cztcclxuICBjLmwgPSAwLjggLSAwLjkgKiB0cztcclxuICByZXR1cm4gYyArIFwiXCI7XHJcbn1cclxuXHJcbnZhciBjJDEgPSByZ2IoKSxcclxuICAgIHBpXzFfMyA9IE1hdGguUEkgLyAzLFxyXG4gICAgcGlfMl8zID0gTWF0aC5QSSAqIDIgLyAzO1xyXG5cclxuZnVuY3Rpb24gc2luZWJvdyh0KSB7XHJcbiAgdmFyIHg7XHJcbiAgdCA9ICgwLjUgLSB0KSAqIE1hdGguUEk7XHJcbiAgYyQxLnIgPSAyNTUgKiAoeCA9IE1hdGguc2luKHQpKSAqIHg7XHJcbiAgYyQxLmcgPSAyNTUgKiAoeCA9IE1hdGguc2luKHQgKyBwaV8xXzMpKSAqIHg7XHJcbiAgYyQxLmIgPSAyNTUgKiAoeCA9IE1hdGguc2luKHQgKyBwaV8yXzMpKSAqIHg7XHJcbiAgcmV0dXJuIGMkMSArIFwiXCI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJhbXAkMShyYW5nZSkge1xyXG4gIHZhciBuID0gcmFuZ2UubGVuZ3RoO1xyXG4gIHJldHVybiBmdW5jdGlvbih0KSB7XHJcbiAgICByZXR1cm4gcmFuZ2VbTWF0aC5tYXgoMCwgTWF0aC5taW4obiAtIDEsIE1hdGguZmxvb3IodCAqIG4pKSldO1xyXG4gIH07XHJcbn1cclxuXHJcbnZhciB2aXJpZGlzID0gcmFtcCQxKGNvbG9ycyhcIjQ0MDE1NDQ0MDI1NjQ1MDQ1NzQ1MDU1OTQ2MDc1YTQ2MDg1YzQ2MGE1ZDQ2MGI1ZTQ3MGQ2MDQ3MGU2MTQ3MTA2MzQ3MTE2NDQ3MTM2NTQ4MTQ2NzQ4MTY2ODQ4MTc2OTQ4MTg2YTQ4MWE2YzQ4MWI2ZDQ4MWM2ZTQ4MWQ2ZjQ4MWY3MDQ4MjA3MTQ4MjE3MzQ4MjM3NDQ4MjQ3NTQ4MjU3NjQ4MjY3NzQ4Mjg3ODQ4Mjk3OTQ3MmE3YTQ3MmM3YTQ3MmQ3YjQ3MmU3YzQ3MmY3ZDQ2MzA3ZTQ2MzI3ZTQ2MzM3ZjQ2MzQ4MDQ1MzU4MTQ1Mzc4MTQ1Mzg4MjQ0Mzk4MzQ0M2E4MzQ0M2I4NDQzM2Q4NDQzM2U4NTQyM2Y4NTQyNDA4NjQyNDE4NjQxNDI4NzQxNDQ4NzQwNDU4ODQwNDY4ODNmNDc4ODNmNDg4OTNlNDk4OTNlNGE4OTNlNGM4YTNkNGQ4YTNkNGU4YTNjNGY4YTNjNTA4YjNiNTE4YjNiNTI4YjNhNTM4YjNhNTQ4YzM5NTU4YzM5NTY4YzM4NTg4YzM4NTk4YzM3NWE4YzM3NWI4ZDM2NWM4ZDM2NWQ4ZDM1NWU4ZDM1NWY4ZDM0NjA4ZDM0NjE4ZDMzNjI4ZDMzNjM4ZDMyNjQ4ZTMyNjU4ZTMxNjY4ZTMxNjc4ZTMxNjg4ZTMwNjk4ZTMwNmE4ZTJmNmI4ZTJmNmM4ZTJlNmQ4ZTJlNmU4ZTJlNmY4ZTJkNzA4ZTJkNzE4ZTJjNzE4ZTJjNzI4ZTJjNzM4ZTJiNzQ4ZTJiNzU4ZTJhNzY4ZTJhNzc4ZTJhNzg4ZTI5Nzk4ZTI5N2E4ZTI5N2I4ZTI4N2M4ZTI4N2Q4ZTI3N2U4ZTI3N2Y4ZTI3ODA4ZTI2ODE4ZTI2ODI4ZTI2ODI4ZTI1ODM4ZTI1ODQ4ZTI1ODU4ZTI0ODY4ZTI0ODc4ZTIzODg4ZTIzODk4ZTIzOGE4ZDIyOGI4ZDIyOGM4ZDIyOGQ4ZDIxOGU4ZDIxOGY4ZDIxOTA4ZDIxOTE4YzIwOTI4YzIwOTI4YzIwOTM4YzFmOTQ4YzFmOTU4YjFmOTY4YjFmOTc4YjFmOTg4YjFmOTk4YTFmOWE4YTFlOWI4YTFlOWM4OTFlOWQ4OTFmOWU4OTFmOWY4ODFmYTA4ODFmYTE4ODFmYTE4NzFmYTI4NzIwYTM4NjIwYTQ4NjIxYTU4NTIxYTY4NTIyYTc4NTIyYTg4NDIzYTk4MzI0YWE4MzI1YWI4MjI1YWM4MjI2YWQ4MTI3YWQ4MTI4YWU4MDI5YWY3ZjJhYjA3ZjJjYjE3ZTJkYjI3ZDJlYjM3YzJmYjQ3YzMxYjU3YjMyYjY3YTM0YjY3OTM1Yjc3OTM3Yjg3ODM4Yjk3NzNhYmE3NjNiYmI3NTNkYmM3NDNmYmM3MzQwYmQ3MjQyYmU3MTQ0YmY3MDQ2YzA2ZjQ4YzE2ZTRhYzE2ZDRjYzI2YzRlYzM2YjUwYzQ2YTUyYzU2OTU0YzU2ODU2YzY2NzU4Yzc2NTVhYzg2NDVjYzg2MzVlYzk2MjYwY2E2MDYzY2I1ZjY1Y2I1ZTY3Y2M1YzY5Y2Q1YjZjY2Q1YTZlY2U1ODcwY2Y1NzczZDA1Njc1ZDA1NDc3ZDE1MzdhZDE1MTdjZDI1MDdmZDM0ZTgxZDM0ZDg0ZDQ0Yjg2ZDU0OTg5ZDU0ODhiZDY0NjhlZDY0NTkwZDc0MzkzZDc0MTk1ZDg0MDk4ZDgzZTliZDkzYzlkZDkzYmEwZGEzOWEyZGEzN2E1ZGIzNmE4ZGIzNGFhZGMzMmFkZGMzMGIwZGQyZmIyZGQyZGI1ZGUyYmI4ZGUyOWJhZGUyOGJkZGYyNmMwZGYyNWMyZGYyM2M1ZTAyMWM4ZTAyMGNhZTExZmNkZTExZGQwZTExY2QyZTIxYmQ1ZTIxYWQ4ZTIxOWRhZTMxOWRkZTMxOGRmZTMxOGUyZTQxOGU1ZTQxOWU3ZTQxOWVhZTUxYWVjZTUxYmVmZTUxY2YxZTUxZGY0ZTYxZWY2ZTYyMGY4ZTYyMWZiZTcyM2ZkZTcyNVwiKSk7XHJcblxyXG52YXIgbWFnbWEgPSByYW1wJDEoY29sb3JzKFwiMDAwMDA0MDEwMDA1MDEwMTA2MDEwMTA4MDIwMTA5MDIwMjBiMDIwMjBkMDMwMzBmMDMwMzEyMDQwNDE0MDUwNDE2MDYwNTE4MDYwNTFhMDcwNjFjMDgwNzFlMDkwNzIwMGEwODIyMGIwOTI0MGMwOTI2MGQwYTI5MGUwYjJiMTAwYjJkMTEwYzJmMTIwZDMxMTMwZDM0MTQwZTM2MTUwZTM4MTYwZjNiMTgwZjNkMTkxMDNmMWExMDQyMWMxMDQ0MWQxMTQ3MWUxMTQ5MjAxMTRiMjExMTRlMjIxMTUwMjQxMjUzMjUxMjU1MjcxMjU4MjkxMTVhMmExMTVjMmMxMTVmMmQxMTYxMmYxMTYzMzExMTY1MzMxMDY3MzQxMDY5MzYxMDZiMzgxMDZjMzkwZjZlM2IwZjcwM2QwZjcxM2YwZjcyNDAwZjc0NDIwZjc1NDQwZjc2NDUxMDc3NDcxMDc4NDkxMDc4NGExMDc5NGMxMTdhNGUxMTdiNGYxMjdiNTExMjdjNTIxMzdjNTQxMzdkNTYxNDdkNTcxNTdlNTkxNTdlNWExNjdlNWMxNjdmNWQxNzdmNWYxODdmNjAxODgwNjIxOTgwNjQxYTgwNjUxYTgwNjcxYjgwNjgxYzgxNmExYzgxNmIxZDgxNmQxZDgxNmUxZTgxNzAxZjgxNzIxZjgxNzMyMDgxNzUyMTgxNzYyMTgxNzgyMjgxNzkyMjgyN2IyMzgyN2MyMzgyN2UyNDgyODAyNTgyODEyNTgxODMyNjgxODQyNjgxODYyNzgxODgyNzgxODkyODgxOGIyOTgxOGMyOTgxOGUyYTgxOTAyYTgxOTEyYjgxOTMyYjgwOTQyYzgwOTYyYzgwOTgyZDgwOTkyZDgwOWIyZTdmOWMyZTdmOWUyZjdmYTAyZjdmYTEzMDdlYTMzMDdlYTUzMTdlYTYzMTdkYTgzMjdkYWEzMzdkYWIzMzdjYWQzNDdjYWUzNDdiYjAzNTdiYjIzNTdiYjMzNjdhYjUzNjdhYjczNzc5YjgzNzc5YmEzODc4YmMzOTc4YmQzOTc3YmYzYTc3YzAzYTc2YzIzYjc1YzQzYzc1YzUzYzc0YzczZDczYzgzZTczY2EzZTcyY2MzZjcxY2Q0MDcxY2Y0MDcwZDA0MTZmZDI0MjZmZDM0MzZlZDU0NDZkZDY0NTZjZDg0NTZjZDk0NjZiZGI0NzZhZGM0ODY5ZGU0OTY4ZGY0YTY4ZTA0YzY3ZTI0ZDY2ZTM0ZTY1ZTQ0ZjY0ZTU1MDY0ZTc1MjYzZTg1MzYyZTk1NDYyZWE1NjYxZWI1NzYwZWM1ODYwZWQ1YTVmZWU1YjVlZWY1ZDVlZjA1ZjVlZjE2MDVkZjI2MjVkZjI2NDVjZjM2NTVjZjQ2NzVjZjQ2OTVjZjU2YjVjZjY2YzVjZjY2ZTVjZjc3MDVjZjc3MjVjZjg3NDVjZjg3NjVjZjk3ODVkZjk3OTVkZjk3YjVkZmE3ZDVlZmE3ZjVlZmE4MTVmZmI4MzVmZmI4NTYwZmI4NzYxZmM4OTYxZmM4YTYyZmM4YzYzZmM4ZTY0ZmM5MDY1ZmQ5MjY2ZmQ5NDY3ZmQ5NjY4ZmQ5ODY5ZmQ5YTZhZmQ5YjZiZmU5ZDZjZmU5ZjZkZmVhMTZlZmVhMzZmZmVhNTcxZmVhNzcyZmVhOTczZmVhYTc0ZmVhYzc2ZmVhZTc3ZmViMDc4ZmViMjdhZmViNDdiZmViNjdjZmViNzdlZmViOTdmZmViYjgxZmViZDgyZmViZjg0ZmVjMTg1ZmVjMjg3ZmVjNDg4ZmVjNjhhZmVjODhjZmVjYThkZmVjYzhmZmVjZDkwZmVjZjkyZmVkMTk0ZmVkMzk1ZmVkNTk3ZmVkNzk5ZmVkODlhZmRkYTljZmRkYzllZmRkZWEwZmRlMGExZmRlMmEzZmRlM2E1ZmRlNWE3ZmRlN2E5ZmRlOWFhZmRlYmFjZmNlY2FlZmNlZWIwZmNmMGIyZmNmMmI0ZmNmNGI2ZmNmNmI4ZmNmN2I5ZmNmOWJiZmNmYmJkZmNmZGJmXCIpKTtcclxuXHJcbnZhciBpbmZlcm5vID0gcmFtcCQxKGNvbG9ycyhcIjAwMDAwNDAxMDAwNTAxMDEwNjAxMDEwODAyMDEwYTAyMDIwYzAyMDIwZTAzMDIxMDA0MDMxMjA0MDMxNDA1MDQxNzA2MDQxOTA3MDUxYjA4MDUxZDA5MDYxZjBhMDcyMjBiMDcyNDBjMDgyNjBkMDgyOTBlMDkyYjEwMDkyZDExMGEzMDEyMGEzMjE0MGIzNDE1MGIzNzE2MGIzOTE4MGMzYzE5MGMzZTFiMGM0MTFjMGM0MzFlMGM0NTFmMGM0ODIxMGM0YTIzMGM0YzI0MGM0ZjI2MGM1MTI4MGI1MzI5MGI1NTJiMGI1NzJkMGI1OTJmMGE1YjMxMGE1YzMyMGE1ZTM0MGE1ZjM2MDk2MTM4MDk2MjM5MDk2MzNiMDk2NDNkMDk2NTNlMDk2NjQwMGE2NzQyMGE2ODQ0MGE2ODQ1MGE2OTQ3MGI2YTQ5MGI2YTRhMGM2YjRjMGM2YjRkMGQ2YzRmMGQ2YzUxMGU2YzUyMGU2ZDU0MGY2ZDU1MGY2ZDU3MTA2ZTU5MTA2ZTVhMTE2ZTVjMTI2ZTVkMTI2ZTVmMTM2ZTYxMTM2ZTYyMTQ2ZTY0MTU2ZTY1MTU2ZTY3MTY2ZTY5MTY2ZTZhMTc2ZTZjMTg2ZTZkMTg2ZTZmMTk2ZTcxMTk2ZTcyMWE2ZTc0MWE2ZTc1MWI2ZTc3MWM2ZDc4MWM2ZDdhMWQ2ZDdjMWQ2ZDdkMWU2ZDdmMWU2YzgwMWY2YzgyMjA2Yzg0MjA2Yjg1MjE2Yjg3MjE2Yjg4MjI2YThhMjI2YThjMjM2OThkMjM2OThmMjQ2OTkwMjU2ODkyMjU2ODkzMjY2Nzk1MjY2Nzk3Mjc2Njk4Mjc2NjlhMjg2NTliMjk2NDlkMjk2NDlmMmE2M2EwMmE2M2EyMmI2MmEzMmM2MWE1MmM2MGE2MmQ2MGE4MmU1ZmE5MmU1ZWFiMmY1ZWFkMzA1ZGFlMzA1Y2IwMzE1YmIxMzI1YWIzMzI1YWI0MzM1OWI2MzQ1OGI3MzU1N2I5MzU1NmJhMzY1NWJjMzc1NGJkMzg1M2JmMzk1MmMwM2E1MWMxM2E1MGMzM2I0ZmM0M2M0ZWM2M2Q0ZGM3M2U0Y2M4M2Y0YmNhNDA0YWNiNDE0OWNjNDI0OGNlNDM0N2NmNDQ0NmQwNDU0NWQyNDY0NGQzNDc0M2Q0NDg0MmQ1NGE0MWQ3NGIzZmQ4NGMzZWQ5NGQzZGRhNGUzY2RiNTAzYmRkNTEzYWRlNTIzOGRmNTMzN2UwNTUzNmUxNTYzNWUyNTczNGUzNTkzM2U0NWEzMWU1NWMzMGU2NWQyZmU3NWUyZWU4NjAyZGU5NjEyYmVhNjMyYWViNjQyOWViNjYyOGVjNjcyNmVkNjkyNWVlNmEyNGVmNmMyM2VmNmUyMWYwNmYyMGYxNzExZmYxNzMxZGYyNzQxY2YzNzYxYmYzNzgxOWY0NzkxOGY1N2IxN2Y1N2QxNWY2N2UxNGY2ODAxM2Y3ODIxMmY3ODQxMGY4ODUwZmY4ODcwZWY4ODkwY2Y5OGIwYmY5OGMwYWY5OGUwOWZhOTAwOGZhOTIwN2ZhOTQwN2ZiOTYwNmZiOTcwNmZiOTkwNmZiOWIwNmZiOWQwN2ZjOWYwN2ZjYTEwOGZjYTMwOWZjYTUwYWZjYTYwY2ZjYTgwZGZjYWEwZmZjYWMxMWZjYWUxMmZjYjAxNGZjYjIxNmZjYjQxOGZiYjYxYWZiYjgxZGZiYmExZmZiYmMyMWZiYmUyM2ZhYzAyNmZhYzIyOGZhYzQyYWZhYzYyZGY5YzcyZmY5YzkzMmY5Y2IzNWY4Y2QzN2Y4Y2YzYWY3ZDEzZGY3ZDM0MGY2ZDU0M2Y2ZDc0NmY1ZDk0OWY1ZGI0Y2Y0ZGQ0ZmY0ZGY1M2Y0ZTE1NmYzZTM1YWYzZTU1ZGYyZTY2MWYyZTg2NWYyZWE2OWYxZWM2ZGYxZWQ3MWYxZWY3NWYxZjE3OWYyZjI3ZGYyZjQ4MmYzZjU4NmYzZjY4YWY0Zjg4ZWY1Zjk5MmY2ZmE5NmY4ZmI5YWY5ZmM5ZGZhZmRhMWZjZmZhNFwiKSk7XHJcblxyXG52YXIgcGxhc21hID0gcmFtcCQxKGNvbG9ycyhcIjBkMDg4NzEwMDc4ODEzMDc4OTE2MDc4YTE5MDY4YzFiMDY4ZDFkMDY4ZTIwMDY4ZjIyMDY5MDI0MDY5MTI2MDU5MTI4MDU5MjJhMDU5MzJjMDU5NDJlMDU5NTJmMDU5NjMxMDU5NzMzMDU5NzM1MDQ5ODM3MDQ5OTM4MDQ5YTNhMDQ5YTNjMDQ5YjNlMDQ5YzNmMDQ5YzQxMDQ5ZDQzMDM5ZTQ0MDM5ZTQ2MDM5ZjQ4MDM5ZjQ5MDNhMDRiMDNhMTRjMDJhMTRlMDJhMjUwMDJhMjUxMDJhMzUzMDJhMzU1MDJhNDU2MDFhNDU4MDFhNDU5MDFhNTViMDFhNTVjMDFhNjVlMDFhNjYwMDFhNjYxMDBhNzYzMDBhNzY0MDBhNzY2MDBhNzY3MDBhODY5MDBhODZhMDBhODZjMDBhODZlMDBhODZmMDBhODcxMDBhODcyMDFhODc0MDFhODc1MDFhODc3MDFhODc4MDFhODdhMDJhODdiMDJhODdkMDNhODdlMDNhODgwMDRhODgxMDRhNzgzMDVhNzg0MDVhNzg2MDZhNjg3MDdhNjg4MDhhNjhhMDlhNThiMGFhNThkMGJhNThlMGNhNDhmMGRhNDkxMGVhMzkyMGZhMzk0MTBhMjk1MTFhMTk2MTNhMTk4MTRhMDk5MTU5ZjlhMTY5ZjljMTc5ZTlkMTg5ZDllMTk5ZGEwMWE5Y2ExMWI5YmEyMWQ5YWEzMWU5YWE1MWY5OWE2MjA5OGE3MjE5N2E4MjI5NmFhMjM5NWFiMjQ5NGFjMjY5NGFkMjc5M2FlMjg5MmIwMjk5MWIxMmE5MGIyMmI4ZmIzMmM4ZWI0MmU4ZGI1MmY4Y2I2MzA4YmI3MzE4YWI4MzI4OWJhMzM4OGJiMzQ4OGJjMzU4N2JkMzc4NmJlMzg4NWJmMzk4NGMwM2E4M2MxM2I4MmMyM2M4MWMzM2Q4MGM0M2U3ZmM1NDA3ZWM2NDE3ZGM3NDI3Y2M4NDM3YmM5NDQ3YWNhNDU3YWNiNDY3OWNjNDc3OGNjNDk3N2NkNGE3NmNlNGI3NWNmNGM3NGQwNGQ3M2QxNGU3MmQyNGY3MWQzNTE3MWQ0NTI3MGQ1NTM2ZmQ1NTQ2ZWQ2NTU2ZGQ3NTY2Y2Q4NTc2YmQ5NTg2YWRhNWE2YWRhNWI2OWRiNWM2OGRjNWQ2N2RkNWU2NmRlNWY2NWRlNjE2NGRmNjI2M2UwNjM2M2UxNjQ2MmUyNjU2MWUyNjY2MGUzNjg1ZmU0Njk1ZWU1NmE1ZGU1NmI1ZGU2NmM1Y2U3NmU1YmU3NmY1YWU4NzA1OWU5NzE1OGU5NzI1N2VhNzQ1N2ViNzU1NmViNzY1NWVjNzc1NGVkNzk1M2VkN2E1MmVlN2I1MWVmN2M1MWVmN2U1MGYwN2Y0ZmYwODA0ZWYxODE0ZGYxODM0Y2YyODQ0YmYzODU0YmYzODc0YWY0ODg0OWY0ODk0OGY1OGI0N2Y1OGM0NmY2OGQ0NWY2OGY0NGY3OTA0NGY3OTE0M2Y3OTM0MmY4OTQ0MWY4OTU0MGY5OTczZmY5OTgzZWY5OWEzZWZhOWIzZGZhOWMzY2ZhOWUzYmZiOWYzYWZiYTEzOWZiYTIzOGZjYTMzOGZjYTUzN2ZjYTYzNmZjYTgzNWZjYTkzNGZkYWIzM2ZkYWMzM2ZkYWUzMmZkYWYzMWZkYjEzMGZkYjIyZmZkYjQyZmZkYjUyZWZlYjcyZGZlYjgyY2ZlYmEyY2ZlYmIyYmZlYmQyYWZlYmUyYWZlYzAyOWZkYzIyOWZkYzMyOGZkYzUyN2ZkYzYyN2ZkYzgyN2ZkY2EyNmZkY2IyNmZjY2QyNWZjY2UyNWZjZDAyNWZjZDIyNWZiZDMyNGZiZDUyNGZiZDcyNGZhZDgyNGZhZGEyNGY5ZGMyNGY5ZGQyNWY4ZGYyNWY4ZTEyNWY3ZTIyNWY3ZTQyNWY2ZTYyNmY2ZTgyNmY1ZTkyNmY1ZWIyN2Y0ZWQyN2YzZWUyN2YzZjAyN2YyZjIyN2YxZjQyNmYxZjUyNWYwZjcyNGYwZjkyMVwiKSk7XHJcblxyXG5mdW5jdGlvbiBjb25zdGFudCQxMSh4KSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbnN0YW50KCkge1xyXG4gICAgcmV0dXJuIHg7XHJcbiAgfTtcclxufVxyXG5cclxudmFyIGFicyQxID0gTWF0aC5hYnM7XHJcbnZhciBhdGFuMiQxID0gTWF0aC5hdGFuMjtcclxudmFyIGNvcyQyID0gTWF0aC5jb3M7XHJcbnZhciBtYXgkMiA9IE1hdGgubWF4O1xyXG52YXIgbWluJDEgPSBNYXRoLm1pbjtcclxudmFyIHNpbiQyID0gTWF0aC5zaW47XHJcbnZhciBzcXJ0JDIgPSBNYXRoLnNxcnQ7XHJcblxyXG52YXIgZXBzaWxvbiQzID0gMWUtMTI7XHJcbnZhciBwaSQ0ID0gTWF0aC5QSTtcclxudmFyIGhhbGZQaSQzID0gcGkkNCAvIDI7XHJcbnZhciB0YXUkNCA9IDIgKiBwaSQ0O1xyXG5cclxuZnVuY3Rpb24gYWNvcyQxKHgpIHtcclxuICByZXR1cm4geCA+IDEgPyAwIDogeCA8IC0xID8gcGkkNCA6IE1hdGguYWNvcyh4KTtcclxufVxyXG5cclxuZnVuY3Rpb24gYXNpbiQxKHgpIHtcclxuICByZXR1cm4geCA+PSAxID8gaGFsZlBpJDMgOiB4IDw9IC0xID8gLWhhbGZQaSQzIDogTWF0aC5hc2luKHgpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhcmNJbm5lclJhZGl1cyhkKSB7XHJcbiAgcmV0dXJuIGQuaW5uZXJSYWRpdXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFyY091dGVyUmFkaXVzKGQpIHtcclxuICByZXR1cm4gZC5vdXRlclJhZGl1cztcclxufVxyXG5cclxuZnVuY3Rpb24gYXJjU3RhcnRBbmdsZShkKSB7XHJcbiAgcmV0dXJuIGQuc3RhcnRBbmdsZTtcclxufVxyXG5cclxuZnVuY3Rpb24gYXJjRW5kQW5nbGUoZCkge1xyXG4gIHJldHVybiBkLmVuZEFuZ2xlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhcmNQYWRBbmdsZShkKSB7XHJcbiAgcmV0dXJuIGQgJiYgZC5wYWRBbmdsZTsgLy8gTm90ZTogb3B0aW9uYWwhXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGludGVyc2VjdCh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcclxuICB2YXIgeDEwID0geDEgLSB4MCwgeTEwID0geTEgLSB5MCxcclxuICAgICAgeDMyID0geDMgLSB4MiwgeTMyID0geTMgLSB5MixcclxuICAgICAgdCA9ICh4MzIgKiAoeTAgLSB5MikgLSB5MzIgKiAoeDAgLSB4MikpIC8gKHkzMiAqIHgxMCAtIHgzMiAqIHkxMCk7XHJcbiAgcmV0dXJuIFt4MCArIHQgKiB4MTAsIHkwICsgdCAqIHkxMF07XHJcbn1cclxuXHJcbi8vIENvbXB1dGUgcGVycGVuZGljdWxhciBvZmZzZXQgbGluZSBvZiBsZW5ndGggcmMuXHJcbi8vIGh0dHA6Ly9tYXRod29ybGQud29sZnJhbS5jb20vQ2lyY2xlLUxpbmVJbnRlcnNlY3Rpb24uaHRtbFxyXG5mdW5jdGlvbiBjb3JuZXJUYW5nZW50cyh4MCwgeTAsIHgxLCB5MSwgcjEsIHJjLCBjdykge1xyXG4gIHZhciB4MDEgPSB4MCAtIHgxLFxyXG4gICAgICB5MDEgPSB5MCAtIHkxLFxyXG4gICAgICBsbyA9IChjdyA/IHJjIDogLXJjKSAvIHNxcnQkMih4MDEgKiB4MDEgKyB5MDEgKiB5MDEpLFxyXG4gICAgICBveCA9IGxvICogeTAxLFxyXG4gICAgICBveSA9IC1sbyAqIHgwMSxcclxuICAgICAgeDExID0geDAgKyBveCxcclxuICAgICAgeTExID0geTAgKyBveSxcclxuICAgICAgeDEwID0geDEgKyBveCxcclxuICAgICAgeTEwID0geTEgKyBveSxcclxuICAgICAgeDAwID0gKHgxMSArIHgxMCkgLyAyLFxyXG4gICAgICB5MDAgPSAoeTExICsgeTEwKSAvIDIsXHJcbiAgICAgIGR4ID0geDEwIC0geDExLFxyXG4gICAgICBkeSA9IHkxMCAtIHkxMSxcclxuICAgICAgZDIgPSBkeCAqIGR4ICsgZHkgKiBkeSxcclxuICAgICAgciA9IHIxIC0gcmMsXHJcbiAgICAgIEQgPSB4MTEgKiB5MTAgLSB4MTAgKiB5MTEsXHJcbiAgICAgIGQgPSAoZHkgPCAwID8gLTEgOiAxKSAqIHNxcnQkMihtYXgkMigwLCByICogciAqIGQyIC0gRCAqIEQpKSxcclxuICAgICAgY3gwID0gKEQgKiBkeSAtIGR4ICogZCkgLyBkMixcclxuICAgICAgY3kwID0gKC1EICogZHggLSBkeSAqIGQpIC8gZDIsXHJcbiAgICAgIGN4MSA9IChEICogZHkgKyBkeCAqIGQpIC8gZDIsXHJcbiAgICAgIGN5MSA9ICgtRCAqIGR4ICsgZHkgKiBkKSAvIGQyLFxyXG4gICAgICBkeDAgPSBjeDAgLSB4MDAsXHJcbiAgICAgIGR5MCA9IGN5MCAtIHkwMCxcclxuICAgICAgZHgxID0gY3gxIC0geDAwLFxyXG4gICAgICBkeTEgPSBjeTEgLSB5MDA7XHJcblxyXG4gIC8vIFBpY2sgdGhlIGNsb3NlciBvZiB0aGUgdHdvIGludGVyc2VjdGlvbiBwb2ludHMuXHJcbiAgLy8gVE9ETyBJcyB0aGVyZSBhIGZhc3RlciB3YXkgdG8gZGV0ZXJtaW5lIHdoaWNoIGludGVyc2VjdGlvbiB0byB1c2U/XHJcbiAgaWYgKGR4MCAqIGR4MCArIGR5MCAqIGR5MCA+IGR4MSAqIGR4MSArIGR5MSAqIGR5MSkgY3gwID0gY3gxLCBjeTAgPSBjeTE7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBjeDogY3gwLFxyXG4gICAgY3k6IGN5MCxcclxuICAgIHgwMTogLW94LFxyXG4gICAgeTAxOiAtb3ksXHJcbiAgICB4MTE6IGN4MCAqIChyMSAvIHIgLSAxKSxcclxuICAgIHkxMTogY3kwICogKHIxIC8gciAtIDEpXHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gYXJjKCkge1xyXG4gIHZhciBpbm5lclJhZGl1cyA9IGFyY0lubmVyUmFkaXVzLFxyXG4gICAgICBvdXRlclJhZGl1cyA9IGFyY091dGVyUmFkaXVzLFxyXG4gICAgICBjb3JuZXJSYWRpdXMgPSBjb25zdGFudCQxMSgwKSxcclxuICAgICAgcGFkUmFkaXVzID0gbnVsbCxcclxuICAgICAgc3RhcnRBbmdsZSA9IGFyY1N0YXJ0QW5nbGUsXHJcbiAgICAgIGVuZEFuZ2xlID0gYXJjRW5kQW5nbGUsXHJcbiAgICAgIHBhZEFuZ2xlID0gYXJjUGFkQW5nbGUsXHJcbiAgICAgIGNvbnRleHQgPSBudWxsO1xyXG5cclxuICBmdW5jdGlvbiBhcmMoKSB7XHJcbiAgICB2YXIgYnVmZmVyLFxyXG4gICAgICAgIHIsXHJcbiAgICAgICAgcjAgPSAraW5uZXJSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcclxuICAgICAgICByMSA9ICtvdXRlclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxyXG4gICAgICAgIGEwID0gc3RhcnRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIC0gaGFsZlBpJDMsXHJcbiAgICAgICAgYTEgPSBlbmRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIC0gaGFsZlBpJDMsXHJcbiAgICAgICAgZGEgPSBhYnMkMShhMSAtIGEwKSxcclxuICAgICAgICBjdyA9IGExID4gYTA7XHJcblxyXG4gICAgaWYgKCFjb250ZXh0KSBjb250ZXh0ID0gYnVmZmVyID0gcGF0aCgpO1xyXG5cclxuICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBvdXRlciByYWRpdXMgaXMgYWx3YXlzIGxhcmdlciB0aGFuIHRoZSBpbm5lciByYWRpdXMuXHJcbiAgICBpZiAocjEgPCByMCkgciA9IHIxLCByMSA9IHIwLCByMCA9IHI7XHJcblxyXG4gICAgLy8gSXMgaXQgYSBwb2ludD9cclxuICAgIGlmICghKHIxID4gZXBzaWxvbiQzKSkgY29udGV4dC5tb3ZlVG8oMCwgMCk7XHJcblxyXG4gICAgLy8gT3IgaXMgaXQgYSBjaXJjbGUgb3IgYW5udWx1cz9cclxuICAgIGVsc2UgaWYgKGRhID4gdGF1JDQgLSBlcHNpbG9uJDMpIHtcclxuICAgICAgY29udGV4dC5tb3ZlVG8ocjEgKiBjb3MkMihhMCksIHIxICogc2luJDIoYTApKTtcclxuICAgICAgY29udGV4dC5hcmMoMCwgMCwgcjEsIGEwLCBhMSwgIWN3KTtcclxuICAgICAgaWYgKHIwID4gZXBzaWxvbiQzKSB7XHJcbiAgICAgICAgY29udGV4dC5tb3ZlVG8ocjAgKiBjb3MkMihhMSksIHIwICogc2luJDIoYTEpKTtcclxuICAgICAgICBjb250ZXh0LmFyYygwLCAwLCByMCwgYTEsIGEwLCBjdyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBPciBpcyBpdCBhIGNpcmN1bGFyIG9yIGFubnVsYXIgc2VjdG9yP1xyXG4gICAgZWxzZSB7XHJcbiAgICAgIHZhciBhMDEgPSBhMCxcclxuICAgICAgICAgIGExMSA9IGExLFxyXG4gICAgICAgICAgYTAwID0gYTAsXHJcbiAgICAgICAgICBhMTAgPSBhMSxcclxuICAgICAgICAgIGRhMCA9IGRhLFxyXG4gICAgICAgICAgZGExID0gZGEsXHJcbiAgICAgICAgICBhcCA9IHBhZEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgLyAyLFxyXG4gICAgICAgICAgcnAgPSAoYXAgPiBlcHNpbG9uJDMpICYmIChwYWRSYWRpdXMgPyArcGFkUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBzcXJ0JDIocjAgKiByMCArIHIxICogcjEpKSxcclxuICAgICAgICAgIHJjID0gbWluJDEoYWJzJDEocjEgLSByMCkgLyAyLCArY29ybmVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpLFxyXG4gICAgICAgICAgcmMwID0gcmMsXHJcbiAgICAgICAgICByYzEgPSByYyxcclxuICAgICAgICAgIHQwLFxyXG4gICAgICAgICAgdDE7XHJcblxyXG4gICAgICAvLyBBcHBseSBwYWRkaW5nPyBOb3RlIHRoYXQgc2luY2UgcjEg4omlIHIwLCBkYTEg4omlIGRhMC5cclxuICAgICAgaWYgKHJwID4gZXBzaWxvbiQzKSB7XHJcbiAgICAgICAgdmFyIHAwID0gYXNpbiQxKHJwIC8gcjAgKiBzaW4kMihhcCkpLFxyXG4gICAgICAgICAgICBwMSA9IGFzaW4kMShycCAvIHIxICogc2luJDIoYXApKTtcclxuICAgICAgICBpZiAoKGRhMCAtPSBwMCAqIDIpID4gZXBzaWxvbiQzKSBwMCAqPSAoY3cgPyAxIDogLTEpLCBhMDAgKz0gcDAsIGExMCAtPSBwMDtcclxuICAgICAgICBlbHNlIGRhMCA9IDAsIGEwMCA9IGExMCA9IChhMCArIGExKSAvIDI7XHJcbiAgICAgICAgaWYgKChkYTEgLT0gcDEgKiAyKSA+IGVwc2lsb24kMykgcDEgKj0gKGN3ID8gMSA6IC0xKSwgYTAxICs9IHAxLCBhMTEgLT0gcDE7XHJcbiAgICAgICAgZWxzZSBkYTEgPSAwLCBhMDEgPSBhMTEgPSAoYTAgKyBhMSkgLyAyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgeDAxID0gcjEgKiBjb3MkMihhMDEpLFxyXG4gICAgICAgICAgeTAxID0gcjEgKiBzaW4kMihhMDEpLFxyXG4gICAgICAgICAgeDEwID0gcjAgKiBjb3MkMihhMTApLFxyXG4gICAgICAgICAgeTEwID0gcjAgKiBzaW4kMihhMTApO1xyXG5cclxuICAgICAgLy8gQXBwbHkgcm91bmRlZCBjb3JuZXJzP1xyXG4gICAgICBpZiAocmMgPiBlcHNpbG9uJDMpIHtcclxuICAgICAgICB2YXIgeDExID0gcjEgKiBjb3MkMihhMTEpLFxyXG4gICAgICAgICAgICB5MTEgPSByMSAqIHNpbiQyKGExMSksXHJcbiAgICAgICAgICAgIHgwMCA9IHIwICogY29zJDIoYTAwKSxcclxuICAgICAgICAgICAgeTAwID0gcjAgKiBzaW4kMihhMDApO1xyXG5cclxuICAgICAgICAvLyBSZXN0cmljdCB0aGUgY29ybmVyIHJhZGl1cyBhY2NvcmRpbmcgdG8gdGhlIHNlY3RvciBhbmdsZS5cclxuICAgICAgICBpZiAoZGEgPCBwaSQ0KSB7XHJcbiAgICAgICAgICB2YXIgb2MgPSBkYTAgPiBlcHNpbG9uJDMgPyBpbnRlcnNlY3QoeDAxLCB5MDEsIHgwMCwgeTAwLCB4MTEsIHkxMSwgeDEwLCB5MTApIDogW3gxMCwgeTEwXSxcclxuICAgICAgICAgICAgICBheCA9IHgwMSAtIG9jWzBdLFxyXG4gICAgICAgICAgICAgIGF5ID0geTAxIC0gb2NbMV0sXHJcbiAgICAgICAgICAgICAgYnggPSB4MTEgLSBvY1swXSxcclxuICAgICAgICAgICAgICBieSA9IHkxMSAtIG9jWzFdLFxyXG4gICAgICAgICAgICAgIGtjID0gMSAvIHNpbiQyKGFjb3MkMSgoYXggKiBieCArIGF5ICogYnkpIC8gKHNxcnQkMihheCAqIGF4ICsgYXkgKiBheSkgKiBzcXJ0JDIoYnggKiBieCArIGJ5ICogYnkpKSkgLyAyKSxcclxuICAgICAgICAgICAgICBsYyA9IHNxcnQkMihvY1swXSAqIG9jWzBdICsgb2NbMV0gKiBvY1sxXSk7XHJcbiAgICAgICAgICByYzAgPSBtaW4kMShyYywgKHIwIC0gbGMpIC8gKGtjIC0gMSkpO1xyXG4gICAgICAgICAgcmMxID0gbWluJDEocmMsIChyMSAtIGxjKSAvIChrYyArIDEpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIElzIHRoZSBzZWN0b3IgY29sbGFwc2VkIHRvIGEgbGluZT9cclxuICAgICAgaWYgKCEoZGExID4gZXBzaWxvbiQzKSkgY29udGV4dC5tb3ZlVG8oeDAxLCB5MDEpO1xyXG5cclxuICAgICAgLy8gRG9lcyB0aGUgc2VjdG9y4oCZcyBvdXRlciByaW5nIGhhdmUgcm91bmRlZCBjb3JuZXJzP1xyXG4gICAgICBlbHNlIGlmIChyYzEgPiBlcHNpbG9uJDMpIHtcclxuICAgICAgICB0MCA9IGNvcm5lclRhbmdlbnRzKHgwMCwgeTAwLCB4MDEsIHkwMSwgcjEsIHJjMSwgY3cpO1xyXG4gICAgICAgIHQxID0gY29ybmVyVGFuZ2VudHMoeDExLCB5MTEsIHgxMCwgeTEwLCByMSwgcmMxLCBjdyk7XHJcblxyXG4gICAgICAgIGNvbnRleHQubW92ZVRvKHQwLmN4ICsgdDAueDAxLCB0MC5jeSArIHQwLnkwMSk7XHJcblxyXG4gICAgICAgIC8vIEhhdmUgdGhlIGNvcm5lcnMgbWVyZ2VkP1xyXG4gICAgICAgIGlmIChyYzEgPCByYykgY29udGV4dC5hcmModDAuY3gsIHQwLmN5LCByYzEsIGF0YW4yJDEodDAueTAxLCB0MC54MDEpLCBhdGFuMiQxKHQxLnkwMSwgdDEueDAxKSwgIWN3KTtcclxuXHJcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBkcmF3IHRoZSB0d28gY29ybmVycyBhbmQgdGhlIHJpbmcuXHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICBjb250ZXh0LmFyYyh0MC5jeCwgdDAuY3ksIHJjMSwgYXRhbjIkMSh0MC55MDEsIHQwLngwMSksIGF0YW4yJDEodDAueTExLCB0MC54MTEpLCAhY3cpO1xyXG4gICAgICAgICAgY29udGV4dC5hcmMoMCwgMCwgcjEsIGF0YW4yJDEodDAuY3kgKyB0MC55MTEsIHQwLmN4ICsgdDAueDExKSwgYXRhbjIkMSh0MS5jeSArIHQxLnkxMSwgdDEuY3ggKyB0MS54MTEpLCAhY3cpO1xyXG4gICAgICAgICAgY29udGV4dC5hcmModDEuY3gsIHQxLmN5LCByYzEsIGF0YW4yJDEodDEueTExLCB0MS54MTEpLCBhdGFuMiQxKHQxLnkwMSwgdDEueDAxKSwgIWN3KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE9yIGlzIHRoZSBvdXRlciByaW5nIGp1c3QgYSBjaXJjdWxhciBhcmM/XHJcbiAgICAgIGVsc2UgY29udGV4dC5tb3ZlVG8oeDAxLCB5MDEpLCBjb250ZXh0LmFyYygwLCAwLCByMSwgYTAxLCBhMTEsICFjdyk7XHJcblxyXG4gICAgICAvLyBJcyB0aGVyZSBubyBpbm5lciByaW5nLCBhbmQgaXTigJlzIGEgY2lyY3VsYXIgc2VjdG9yP1xyXG4gICAgICAvLyBPciBwZXJoYXBzIGl04oCZcyBhbiBhbm51bGFyIHNlY3RvciBjb2xsYXBzZWQgZHVlIHRvIHBhZGRpbmc/XHJcbiAgICAgIGlmICghKHIwID4gZXBzaWxvbiQzKSB8fCAhKGRhMCA+IGVwc2lsb24kMykpIGNvbnRleHQubGluZVRvKHgxMCwgeTEwKTtcclxuXHJcbiAgICAgIC8vIERvZXMgdGhlIHNlY3RvcuKAmXMgaW5uZXIgcmluZyAob3IgcG9pbnQpIGhhdmUgcm91bmRlZCBjb3JuZXJzP1xyXG4gICAgICBlbHNlIGlmIChyYzAgPiBlcHNpbG9uJDMpIHtcclxuICAgICAgICB0MCA9IGNvcm5lclRhbmdlbnRzKHgxMCwgeTEwLCB4MTEsIHkxMSwgcjAsIC1yYzAsIGN3KTtcclxuICAgICAgICB0MSA9IGNvcm5lclRhbmdlbnRzKHgwMSwgeTAxLCB4MDAsIHkwMCwgcjAsIC1yYzAsIGN3KTtcclxuXHJcbiAgICAgICAgY29udGV4dC5saW5lVG8odDAuY3ggKyB0MC54MDEsIHQwLmN5ICsgdDAueTAxKTtcclxuXHJcbiAgICAgICAgLy8gSGF2ZSB0aGUgY29ybmVycyBtZXJnZWQ/XHJcbiAgICAgICAgaWYgKHJjMCA8IHJjKSBjb250ZXh0LmFyYyh0MC5jeCwgdDAuY3ksIHJjMCwgYXRhbjIkMSh0MC55MDEsIHQwLngwMSksIGF0YW4yJDEodDEueTAxLCB0MS54MDEpLCAhY3cpO1xyXG5cclxuICAgICAgICAvLyBPdGhlcndpc2UsIGRyYXcgdGhlIHR3byBjb3JuZXJzIGFuZCB0aGUgcmluZy5cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIGNvbnRleHQuYXJjKHQwLmN4LCB0MC5jeSwgcmMwLCBhdGFuMiQxKHQwLnkwMSwgdDAueDAxKSwgYXRhbjIkMSh0MC55MTEsIHQwLngxMSksICFjdyk7XHJcbiAgICAgICAgICBjb250ZXh0LmFyYygwLCAwLCByMCwgYXRhbjIkMSh0MC5jeSArIHQwLnkxMSwgdDAuY3ggKyB0MC54MTEpLCBhdGFuMiQxKHQxLmN5ICsgdDEueTExLCB0MS5jeCArIHQxLngxMSksIGN3KTtcclxuICAgICAgICAgIGNvbnRleHQuYXJjKHQxLmN4LCB0MS5jeSwgcmMwLCBhdGFuMiQxKHQxLnkxMSwgdDEueDExKSwgYXRhbjIkMSh0MS55MDEsIHQxLngwMSksICFjdyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBPciBpcyB0aGUgaW5uZXIgcmluZyBqdXN0IGEgY2lyY3VsYXIgYXJjP1xyXG4gICAgICBlbHNlIGNvbnRleHQuYXJjKDAsIDAsIHIwLCBhMTAsIGEwMCwgY3cpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XHJcblxyXG4gICAgaWYgKGJ1ZmZlcikgcmV0dXJuIGNvbnRleHQgPSBudWxsLCBidWZmZXIgKyBcIlwiIHx8IG51bGw7XHJcbiAgfVxyXG5cclxuICBhcmMuY2VudHJvaWQgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciByID0gKCtpbm5lclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpICsgK291dGVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIC8gMixcclxuICAgICAgICBhID0gKCtzdGFydEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgKyArZW5kQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgLyAyIC0gcGkkNCAvIDI7XHJcbiAgICByZXR1cm4gW2NvcyQyKGEpICogciwgc2luJDIoYSkgKiByXTtcclxuICB9O1xyXG5cclxuICBhcmMuaW5uZXJSYWRpdXMgPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpbm5lclJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQkMTEoK18pLCBhcmMpIDogaW5uZXJSYWRpdXM7XHJcbiAgfTtcclxuXHJcbiAgYXJjLm91dGVyUmFkaXVzID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAob3V0ZXJSYWRpdXMgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50JDExKCtfKSwgYXJjKSA6IG91dGVyUmFkaXVzO1xyXG4gIH07XHJcblxyXG4gIGFyYy5jb3JuZXJSYWRpdXMgPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjb3JuZXJSYWRpdXMgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50JDExKCtfKSwgYXJjKSA6IGNvcm5lclJhZGl1cztcclxuICB9O1xyXG5cclxuICBhcmMucGFkUmFkaXVzID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkUmFkaXVzID0gXyA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQkMTEoK18pLCBhcmMpIDogcGFkUmFkaXVzO1xyXG4gIH07XHJcblxyXG4gIGFyYy5zdGFydEFuZ2xlID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3RhcnRBbmdsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQkMTEoK18pLCBhcmMpIDogc3RhcnRBbmdsZTtcclxuICB9O1xyXG5cclxuICBhcmMuZW5kQW5nbGUgPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChlbmRBbmdsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQkMTEoK18pLCBhcmMpIDogZW5kQW5nbGU7XHJcbiAgfTtcclxuXHJcbiAgYXJjLnBhZEFuZ2xlID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkQW5nbGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50JDExKCtfKSwgYXJjKSA6IHBhZEFuZ2xlO1xyXG4gIH07XHJcblxyXG4gIGFyYy5jb250ZXh0ID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY29udGV4dCA9IF8gPT0gbnVsbCA/IG51bGwgOiBfLCBhcmMpIDogY29udGV4dDtcclxuICB9O1xyXG5cclxuICByZXR1cm4gYXJjO1xyXG59XHJcblxyXG5mdW5jdGlvbiBMaW5lYXIoY29udGV4dCkge1xyXG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xyXG59XHJcblxyXG5MaW5lYXIucHJvdG90eXBlID0ge1xyXG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLl9saW5lID0gMDtcclxuICB9LFxyXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5fbGluZSA9IE5hTjtcclxuICB9LFxyXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLl9wb2ludCA9IDA7XHJcbiAgfSxcclxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcclxuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAxKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcclxuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcclxuICB9LFxyXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICB4ID0gK3gsIHkgPSAreTtcclxuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcclxuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHgsIHkpOyBicmVhaztcclxuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IC8vIHByb2NlZWRcclxuICAgICAgZGVmYXVsdDogdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSk7IGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIGN1cnZlTGluZWFyKGNvbnRleHQpIHtcclxuICByZXR1cm4gbmV3IExpbmVhcihjb250ZXh0KTtcclxufVxyXG5cclxuZnVuY3Rpb24geCQzKHApIHtcclxuICByZXR1cm4gcFswXTtcclxufVxyXG5cclxuZnVuY3Rpb24geSQzKHApIHtcclxuICByZXR1cm4gcFsxXTtcclxufVxyXG5cclxuZnVuY3Rpb24gbGluZSgpIHtcclxuICB2YXIgeCQkMSA9IHgkMyxcclxuICAgICAgeSQkMSA9IHkkMyxcclxuICAgICAgZGVmaW5lZCA9IGNvbnN0YW50JDExKHRydWUpLFxyXG4gICAgICBjb250ZXh0ID0gbnVsbCxcclxuICAgICAgY3VydmUgPSBjdXJ2ZUxpbmVhcixcclxuICAgICAgb3V0cHV0ID0gbnVsbDtcclxuXHJcbiAgZnVuY3Rpb24gbGluZShkYXRhKSB7XHJcbiAgICB2YXIgaSxcclxuICAgICAgICBuID0gZGF0YS5sZW5ndGgsXHJcbiAgICAgICAgZCxcclxuICAgICAgICBkZWZpbmVkMCA9IGZhbHNlLFxyXG4gICAgICAgIGJ1ZmZlcjtcclxuXHJcbiAgICBpZiAoY29udGV4dCA9PSBudWxsKSBvdXRwdXQgPSBjdXJ2ZShidWZmZXIgPSBwYXRoKCkpO1xyXG5cclxuICAgIGZvciAoaSA9IDA7IGkgPD0gbjsgKytpKSB7XHJcbiAgICAgIGlmICghKGkgPCBuICYmIGRlZmluZWQoZCA9IGRhdGFbaV0sIGksIGRhdGEpKSA9PT0gZGVmaW5lZDApIHtcclxuICAgICAgICBpZiAoZGVmaW5lZDAgPSAhZGVmaW5lZDApIG91dHB1dC5saW5lU3RhcnQoKTtcclxuICAgICAgICBlbHNlIG91dHB1dC5saW5lRW5kKCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGRlZmluZWQwKSBvdXRwdXQucG9pbnQoK3gkJDEoZCwgaSwgZGF0YSksICt5JCQxKGQsIGksIGRhdGEpKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoYnVmZmVyKSByZXR1cm4gb3V0cHV0ID0gbnVsbCwgYnVmZmVyICsgXCJcIiB8fCBudWxsO1xyXG4gIH1cclxuXHJcbiAgbGluZS54ID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeCQkMSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQkMTEoK18pLCBsaW5lKSA6IHgkJDE7XHJcbiAgfTtcclxuXHJcbiAgbGluZS55ID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeSQkMSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQkMTEoK18pLCBsaW5lKSA6IHkkJDE7XHJcbiAgfTtcclxuXHJcbiAgbGluZS5kZWZpbmVkID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZGVmaW5lZCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQkMTEoISFfKSwgbGluZSkgOiBkZWZpbmVkO1xyXG4gIH07XHJcblxyXG4gIGxpbmUuY3VydmUgPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjdXJ2ZSA9IF8sIGNvbnRleHQgIT0gbnVsbCAmJiAob3V0cHV0ID0gY3VydmUoY29udGV4dCkpLCBsaW5lKSA6IGN1cnZlO1xyXG4gIH07XHJcblxyXG4gIGxpbmUuY29udGV4dCA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKF8gPT0gbnVsbCA/IGNvbnRleHQgPSBvdXRwdXQgPSBudWxsIDogb3V0cHV0ID0gY3VydmUoY29udGV4dCA9IF8pLCBsaW5lKSA6IGNvbnRleHQ7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIGxpbmU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFyZWEkMygpIHtcclxuICB2YXIgeDAgPSB4JDMsXHJcbiAgICAgIHgxID0gbnVsbCxcclxuICAgICAgeTAgPSBjb25zdGFudCQxMSgwKSxcclxuICAgICAgeTEgPSB5JDMsXHJcbiAgICAgIGRlZmluZWQgPSBjb25zdGFudCQxMSh0cnVlKSxcclxuICAgICAgY29udGV4dCA9IG51bGwsXHJcbiAgICAgIGN1cnZlID0gY3VydmVMaW5lYXIsXHJcbiAgICAgIG91dHB1dCA9IG51bGw7XHJcblxyXG4gIGZ1bmN0aW9uIGFyZWEoZGF0YSkge1xyXG4gICAgdmFyIGksXHJcbiAgICAgICAgaixcclxuICAgICAgICBrLFxyXG4gICAgICAgIG4gPSBkYXRhLmxlbmd0aCxcclxuICAgICAgICBkLFxyXG4gICAgICAgIGRlZmluZWQwID0gZmFsc2UsXHJcbiAgICAgICAgYnVmZmVyLFxyXG4gICAgICAgIHgweiA9IG5ldyBBcnJheShuKSxcclxuICAgICAgICB5MHogPSBuZXcgQXJyYXkobik7XHJcblxyXG4gICAgaWYgKGNvbnRleHQgPT0gbnVsbCkgb3V0cHV0ID0gY3VydmUoYnVmZmVyID0gcGF0aCgpKTtcclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDw9IG47ICsraSkge1xyXG4gICAgICBpZiAoIShpIDwgbiAmJiBkZWZpbmVkKGQgPSBkYXRhW2ldLCBpLCBkYXRhKSkgPT09IGRlZmluZWQwKSB7XHJcbiAgICAgICAgaWYgKGRlZmluZWQwID0gIWRlZmluZWQwKSB7XHJcbiAgICAgICAgICBqID0gaTtcclxuICAgICAgICAgIG91dHB1dC5hcmVhU3RhcnQoKTtcclxuICAgICAgICAgIG91dHB1dC5saW5lU3RhcnQoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgb3V0cHV0LmxpbmVFbmQoKTtcclxuICAgICAgICAgIG91dHB1dC5saW5lU3RhcnQoKTtcclxuICAgICAgICAgIGZvciAoayA9IGkgLSAxOyBrID49IGo7IC0taykge1xyXG4gICAgICAgICAgICBvdXRwdXQucG9pbnQoeDB6W2tdLCB5MHpba10pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgb3V0cHV0LmxpbmVFbmQoKTtcclxuICAgICAgICAgIG91dHB1dC5hcmVhRW5kKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChkZWZpbmVkMCkge1xyXG4gICAgICAgIHgweltpXSA9ICt4MChkLCBpLCBkYXRhKSwgeTB6W2ldID0gK3kwKGQsIGksIGRhdGEpO1xyXG4gICAgICAgIG91dHB1dC5wb2ludCh4MSA/ICt4MShkLCBpLCBkYXRhKSA6IHgweltpXSwgeTEgPyAreTEoZCwgaSwgZGF0YSkgOiB5MHpbaV0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGJ1ZmZlcikgcmV0dXJuIG91dHB1dCA9IG51bGwsIGJ1ZmZlciArIFwiXCIgfHwgbnVsbDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGFyZWFsaW5lKCkge1xyXG4gICAgcmV0dXJuIGxpbmUoKS5kZWZpbmVkKGRlZmluZWQpLmN1cnZlKGN1cnZlKS5jb250ZXh0KGNvbnRleHQpO1xyXG4gIH1cclxuXHJcbiAgYXJlYS54ID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeDAgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50JDExKCtfKSwgeDEgPSBudWxsLCBhcmVhKSA6IHgwO1xyXG4gIH07XHJcblxyXG4gIGFyZWEueDAgPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4MCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQkMTEoK18pLCBhcmVhKSA6IHgwO1xyXG4gIH07XHJcblxyXG4gIGFyZWEueDEgPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4MSA9IF8gPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50JDExKCtfKSwgYXJlYSkgOiB4MTtcclxuICB9O1xyXG5cclxuICBhcmVhLnkgPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5MCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQkMTEoK18pLCB5MSA9IG51bGwsIGFyZWEpIDogeTA7XHJcbiAgfTtcclxuXHJcbiAgYXJlYS55MCA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkwID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCQxMSgrXyksIGFyZWEpIDogeTA7XHJcbiAgfTtcclxuXHJcbiAgYXJlYS55MSA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkxID0gXyA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQkMTEoK18pLCBhcmVhKSA6IHkxO1xyXG4gIH07XHJcblxyXG4gIGFyZWEubGluZVgwID1cclxuICBhcmVhLmxpbmVZMCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIGFyZWFsaW5lKCkueCh4MCkueSh5MCk7XHJcbiAgfTtcclxuXHJcbiAgYXJlYS5saW5lWTEgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBhcmVhbGluZSgpLngoeDApLnkoeTEpO1xyXG4gIH07XHJcblxyXG4gIGFyZWEubGluZVgxID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gYXJlYWxpbmUoKS54KHgxKS55KHkwKTtcclxuICB9O1xyXG5cclxuICBhcmVhLmRlZmluZWQgPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkZWZpbmVkID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCQxMSghIV8pLCBhcmVhKSA6IGRlZmluZWQ7XHJcbiAgfTtcclxuXHJcbiAgYXJlYS5jdXJ2ZSA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGN1cnZlID0gXywgY29udGV4dCAhPSBudWxsICYmIChvdXRwdXQgPSBjdXJ2ZShjb250ZXh0KSksIGFyZWEpIDogY3VydmU7XHJcbiAgfTtcclxuXHJcbiAgYXJlYS5jb250ZXh0ID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoXyA9PSBudWxsID8gY29udGV4dCA9IG91dHB1dCA9IG51bGwgOiBvdXRwdXQgPSBjdXJ2ZShjb250ZXh0ID0gXyksIGFyZWEpIDogY29udGV4dDtcclxuICB9O1xyXG5cclxuICByZXR1cm4gYXJlYTtcclxufVxyXG5cclxuZnVuY3Rpb24gZGVzY2VuZGluZyQxKGEsIGIpIHtcclxuICByZXR1cm4gYiA8IGEgPyAtMSA6IGIgPiBhID8gMSA6IGIgPj0gYSA/IDAgOiBOYU47XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlkZW50aXR5JDcoZCkge1xyXG4gIHJldHVybiBkO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwaWUoKSB7XHJcbiAgdmFyIHZhbHVlID0gaWRlbnRpdHkkNyxcclxuICAgICAgc29ydFZhbHVlcyA9IGRlc2NlbmRpbmckMSxcclxuICAgICAgc29ydCA9IG51bGwsXHJcbiAgICAgIHN0YXJ0QW5nbGUgPSBjb25zdGFudCQxMSgwKSxcclxuICAgICAgZW5kQW5nbGUgPSBjb25zdGFudCQxMSh0YXUkNCksXHJcbiAgICAgIHBhZEFuZ2xlID0gY29uc3RhbnQkMTEoMCk7XHJcblxyXG4gIGZ1bmN0aW9uIHBpZShkYXRhKSB7XHJcbiAgICB2YXIgaSxcclxuICAgICAgICBuID0gZGF0YS5sZW5ndGgsXHJcbiAgICAgICAgaixcclxuICAgICAgICBrLFxyXG4gICAgICAgIHN1bSA9IDAsXHJcbiAgICAgICAgaW5kZXggPSBuZXcgQXJyYXkobiksXHJcbiAgICAgICAgYXJjcyA9IG5ldyBBcnJheShuKSxcclxuICAgICAgICBhMCA9ICtzdGFydEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXHJcbiAgICAgICAgZGEgPSBNYXRoLm1pbih0YXUkNCwgTWF0aC5tYXgoLXRhdSQ0LCBlbmRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIC0gYTApKSxcclxuICAgICAgICBhMSxcclxuICAgICAgICBwID0gTWF0aC5taW4oTWF0aC5hYnMoZGEpIC8gbiwgcGFkQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSksXHJcbiAgICAgICAgcGEgPSBwICogKGRhIDwgMCA/IC0xIDogMSksXHJcbiAgICAgICAgdjtcclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgIGlmICgodiA9IGFyY3NbaW5kZXhbaV0gPSBpXSA9ICt2YWx1ZShkYXRhW2ldLCBpLCBkYXRhKSkgPiAwKSB7XHJcbiAgICAgICAgc3VtICs9IHY7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBPcHRpb25hbGx5IHNvcnQgdGhlIGFyY3MgYnkgcHJldmlvdXNseS1jb21wdXRlZCB2YWx1ZXMgb3IgYnkgZGF0YS5cclxuICAgIGlmIChzb3J0VmFsdWVzICE9IG51bGwpIGluZGV4LnNvcnQoZnVuY3Rpb24oaSwgaikgeyByZXR1cm4gc29ydFZhbHVlcyhhcmNzW2ldLCBhcmNzW2pdKTsgfSk7XHJcbiAgICBlbHNlIGlmIChzb3J0ICE9IG51bGwpIGluZGV4LnNvcnQoZnVuY3Rpb24oaSwgaikgeyByZXR1cm4gc29ydChkYXRhW2ldLCBkYXRhW2pdKTsgfSk7XHJcblxyXG4gICAgLy8gQ29tcHV0ZSB0aGUgYXJjcyEgVGhleSBhcmUgc3RvcmVkIGluIHRoZSBvcmlnaW5hbCBkYXRhJ3Mgb3JkZXIuXHJcbiAgICBmb3IgKGkgPSAwLCBrID0gc3VtID8gKGRhIC0gbiAqIHBhKSAvIHN1bSA6IDA7IGkgPCBuOyArK2ksIGEwID0gYTEpIHtcclxuICAgICAgaiA9IGluZGV4W2ldLCB2ID0gYXJjc1tqXSwgYTEgPSBhMCArICh2ID4gMCA/IHYgKiBrIDogMCkgKyBwYSwgYXJjc1tqXSA9IHtcclxuICAgICAgICBkYXRhOiBkYXRhW2pdLFxyXG4gICAgICAgIGluZGV4OiBpLFxyXG4gICAgICAgIHZhbHVlOiB2LFxyXG4gICAgICAgIHN0YXJ0QW5nbGU6IGEwLFxyXG4gICAgICAgIGVuZEFuZ2xlOiBhMSxcclxuICAgICAgICBwYWRBbmdsZTogcFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBhcmNzO1xyXG4gIH1cclxuXHJcbiAgcGllLnZhbHVlID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodmFsdWUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50JDExKCtfKSwgcGllKSA6IHZhbHVlO1xyXG4gIH07XHJcblxyXG4gIHBpZS5zb3J0VmFsdWVzID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc29ydFZhbHVlcyA9IF8sIHNvcnQgPSBudWxsLCBwaWUpIDogc29ydFZhbHVlcztcclxuICB9O1xyXG5cclxuICBwaWUuc29ydCA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNvcnQgPSBfLCBzb3J0VmFsdWVzID0gbnVsbCwgcGllKSA6IHNvcnQ7XHJcbiAgfTtcclxuXHJcbiAgcGllLnN0YXJ0QW5nbGUgPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzdGFydEFuZ2xlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCQxMSgrXyksIHBpZSkgOiBzdGFydEFuZ2xlO1xyXG4gIH07XHJcblxyXG4gIHBpZS5lbmRBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGVuZEFuZ2xlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCQxMSgrXyksIHBpZSkgOiBlbmRBbmdsZTtcclxuICB9O1xyXG5cclxuICBwaWUucGFkQW5nbGUgPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRBbmdsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQkMTEoK18pLCBwaWUpIDogcGFkQW5nbGU7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIHBpZTtcclxufVxyXG5cclxudmFyIGN1cnZlUmFkaWFsTGluZWFyID0gY3VydmVSYWRpYWwoY3VydmVMaW5lYXIpO1xyXG5cclxuZnVuY3Rpb24gUmFkaWFsKGN1cnZlKSB7XHJcbiAgdGhpcy5fY3VydmUgPSBjdXJ2ZTtcclxufVxyXG5cclxuUmFkaWFsLnByb3RvdHlwZSA9IHtcclxuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5fY3VydmUuYXJlYVN0YXJ0KCk7XHJcbiAgfSxcclxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuX2N1cnZlLmFyZWFFbmQoKTtcclxuICB9LFxyXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLl9jdXJ2ZS5saW5lU3RhcnQoKTtcclxuICB9LFxyXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5fY3VydmUubGluZUVuZCgpO1xyXG4gIH0sXHJcbiAgcG9pbnQ6IGZ1bmN0aW9uKGEsIHIpIHtcclxuICAgIHRoaXMuX2N1cnZlLnBvaW50KHIgKiBNYXRoLnNpbihhKSwgciAqIC1NYXRoLmNvcyhhKSk7XHJcbiAgfVxyXG59O1xyXG5cclxuZnVuY3Rpb24gY3VydmVSYWRpYWwoY3VydmUpIHtcclxuXHJcbiAgZnVuY3Rpb24gcmFkaWFsKGNvbnRleHQpIHtcclxuICAgIHJldHVybiBuZXcgUmFkaWFsKGN1cnZlKGNvbnRleHQpKTtcclxuICB9XHJcblxyXG4gIHJhZGlhbC5fY3VydmUgPSBjdXJ2ZTtcclxuXHJcbiAgcmV0dXJuIHJhZGlhbDtcclxufVxyXG5cclxuZnVuY3Rpb24gbGluZVJhZGlhbChsKSB7XHJcbiAgdmFyIGMgPSBsLmN1cnZlO1xyXG5cclxuICBsLmFuZ2xlID0gbC54LCBkZWxldGUgbC54O1xyXG4gIGwucmFkaXVzID0gbC55LCBkZWxldGUgbC55O1xyXG5cclxuICBsLmN1cnZlID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBjKGN1cnZlUmFkaWFsKF8pKSA6IGMoKS5fY3VydmU7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIGw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxpbmVSYWRpYWwkMSgpIHtcclxuICByZXR1cm4gbGluZVJhZGlhbChsaW5lKCkuY3VydmUoY3VydmVSYWRpYWxMaW5lYXIpKTtcclxufVxyXG5cclxuZnVuY3Rpb24gYXJlYVJhZGlhbCgpIHtcclxuICB2YXIgYSA9IGFyZWEkMygpLmN1cnZlKGN1cnZlUmFkaWFsTGluZWFyKSxcclxuICAgICAgYyA9IGEuY3VydmUsXHJcbiAgICAgIHgwID0gYS5saW5lWDAsXHJcbiAgICAgIHgxID0gYS5saW5lWDEsXHJcbiAgICAgIHkwID0gYS5saW5lWTAsXHJcbiAgICAgIHkxID0gYS5saW5lWTE7XHJcblxyXG4gIGEuYW5nbGUgPSBhLngsIGRlbGV0ZSBhLng7XHJcbiAgYS5zdGFydEFuZ2xlID0gYS54MCwgZGVsZXRlIGEueDA7XHJcbiAgYS5lbmRBbmdsZSA9IGEueDEsIGRlbGV0ZSBhLngxO1xyXG4gIGEucmFkaXVzID0gYS55LCBkZWxldGUgYS55O1xyXG4gIGEuaW5uZXJSYWRpdXMgPSBhLnkwLCBkZWxldGUgYS55MDtcclxuICBhLm91dGVyUmFkaXVzID0gYS55MSwgZGVsZXRlIGEueTE7XHJcbiAgYS5saW5lU3RhcnRBbmdsZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gbGluZVJhZGlhbCh4MCgpKTsgfSwgZGVsZXRlIGEubGluZVgwO1xyXG4gIGEubGluZUVuZEFuZ2xlID0gZnVuY3Rpb24oKSB7IHJldHVybiBsaW5lUmFkaWFsKHgxKCkpOyB9LCBkZWxldGUgYS5saW5lWDE7XHJcbiAgYS5saW5lSW5uZXJSYWRpdXMgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGxpbmVSYWRpYWwoeTAoKSk7IH0sIGRlbGV0ZSBhLmxpbmVZMDtcclxuICBhLmxpbmVPdXRlclJhZGl1cyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gbGluZVJhZGlhbCh5MSgpKTsgfSwgZGVsZXRlIGEubGluZVkxO1xyXG5cclxuICBhLmN1cnZlID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBjKGN1cnZlUmFkaWFsKF8pKSA6IGMoKS5fY3VydmU7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIGE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBvaW50UmFkaWFsKHgsIHkpIHtcclxuICByZXR1cm4gWyh5ID0gK3kpICogTWF0aC5jb3MoeCAtPSBNYXRoLlBJIC8gMiksIHkgKiBNYXRoLnNpbih4KV07XHJcbn1cclxuXHJcbnZhciBzbGljZSQ2ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xyXG5cclxuZnVuY3Rpb24gbGlua1NvdXJjZShkKSB7XHJcbiAgcmV0dXJuIGQuc291cmNlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBsaW5rVGFyZ2V0KGQpIHtcclxuICByZXR1cm4gZC50YXJnZXQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxpbmskMihjdXJ2ZSkge1xyXG4gIHZhciBzb3VyY2UgPSBsaW5rU291cmNlLFxyXG4gICAgICB0YXJnZXQgPSBsaW5rVGFyZ2V0LFxyXG4gICAgICB4JCQxID0geCQzLFxyXG4gICAgICB5JCQxID0geSQzLFxyXG4gICAgICBjb250ZXh0ID0gbnVsbDtcclxuXHJcbiAgZnVuY3Rpb24gbGluaygpIHtcclxuICAgIHZhciBidWZmZXIsIGFyZ3YgPSBzbGljZSQ2LmNhbGwoYXJndW1lbnRzKSwgcyA9IHNvdXJjZS5hcHBseSh0aGlzLCBhcmd2KSwgdCA9IHRhcmdldC5hcHBseSh0aGlzLCBhcmd2KTtcclxuICAgIGlmICghY29udGV4dCkgY29udGV4dCA9IGJ1ZmZlciA9IHBhdGgoKTtcclxuICAgIGN1cnZlKGNvbnRleHQsICt4JCQxLmFwcGx5KHRoaXMsIChhcmd2WzBdID0gcywgYXJndikpLCAreSQkMS5hcHBseSh0aGlzLCBhcmd2KSwgK3gkJDEuYXBwbHkodGhpcywgKGFyZ3ZbMF0gPSB0LCBhcmd2KSksICt5JCQxLmFwcGx5KHRoaXMsIGFyZ3YpKTtcclxuICAgIGlmIChidWZmZXIpIHJldHVybiBjb250ZXh0ID0gbnVsbCwgYnVmZmVyICsgXCJcIiB8fCBudWxsO1xyXG4gIH1cclxuXHJcbiAgbGluay5zb3VyY2UgPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzb3VyY2UgPSBfLCBsaW5rKSA6IHNvdXJjZTtcclxuICB9O1xyXG5cclxuICBsaW5rLnRhcmdldCA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRhcmdldCA9IF8sIGxpbmspIDogdGFyZ2V0O1xyXG4gIH07XHJcblxyXG4gIGxpbmsueCA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHgkJDEgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50JDExKCtfKSwgbGluaykgOiB4JCQxO1xyXG4gIH07XHJcblxyXG4gIGxpbmsueSA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkkJDEgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50JDExKCtfKSwgbGluaykgOiB5JCQxO1xyXG4gIH07XHJcblxyXG4gIGxpbmsuY29udGV4dCA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNvbnRleHQgPSBfID09IG51bGwgPyBudWxsIDogXywgbGluaykgOiBjb250ZXh0O1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBsaW5rO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjdXJ2ZUhvcml6b250YWwoY29udGV4dCwgeDAsIHkwLCB4MSwgeTEpIHtcclxuICBjb250ZXh0Lm1vdmVUbyh4MCwgeTApO1xyXG4gIGNvbnRleHQuYmV6aWVyQ3VydmVUbyh4MCA9ICh4MCArIHgxKSAvIDIsIHkwLCB4MCwgeTEsIHgxLCB5MSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGN1cnZlVmVydGljYWwoY29udGV4dCwgeDAsIHkwLCB4MSwgeTEpIHtcclxuICBjb250ZXh0Lm1vdmVUbyh4MCwgeTApO1xyXG4gIGNvbnRleHQuYmV6aWVyQ3VydmVUbyh4MCwgeTAgPSAoeTAgKyB5MSkgLyAyLCB4MSwgeTAsIHgxLCB5MSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGN1cnZlUmFkaWFsJDEoY29udGV4dCwgeDAsIHkwLCB4MSwgeTEpIHtcclxuICB2YXIgcDAgPSBwb2ludFJhZGlhbCh4MCwgeTApLFxyXG4gICAgICBwMSA9IHBvaW50UmFkaWFsKHgwLCB5MCA9ICh5MCArIHkxKSAvIDIpLFxyXG4gICAgICBwMiA9IHBvaW50UmFkaWFsKHgxLCB5MCksXHJcbiAgICAgIHAzID0gcG9pbnRSYWRpYWwoeDEsIHkxKTtcclxuICBjb250ZXh0Lm1vdmVUbyhwMFswXSwgcDBbMV0pO1xyXG4gIGNvbnRleHQuYmV6aWVyQ3VydmVUbyhwMVswXSwgcDFbMV0sIHAyWzBdLCBwMlsxXSwgcDNbMF0sIHAzWzFdKTtcclxufVxyXG5cclxuZnVuY3Rpb24gbGlua0hvcml6b250YWwoKSB7XHJcbiAgcmV0dXJuIGxpbmskMihjdXJ2ZUhvcml6b250YWwpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBsaW5rVmVydGljYWwoKSB7XHJcbiAgcmV0dXJuIGxpbmskMihjdXJ2ZVZlcnRpY2FsKTtcclxufVxyXG5cclxuZnVuY3Rpb24gbGlua1JhZGlhbCgpIHtcclxuICB2YXIgbCA9IGxpbmskMihjdXJ2ZVJhZGlhbCQxKTtcclxuICBsLmFuZ2xlID0gbC54LCBkZWxldGUgbC54O1xyXG4gIGwucmFkaXVzID0gbC55LCBkZWxldGUgbC55O1xyXG4gIHJldHVybiBsO1xyXG59XHJcblxyXG52YXIgY2lyY2xlJDIgPSB7XHJcbiAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSkge1xyXG4gICAgdmFyIHIgPSBNYXRoLnNxcnQoc2l6ZSAvIHBpJDQpO1xyXG4gICAgY29udGV4dC5tb3ZlVG8ociwgMCk7XHJcbiAgICBjb250ZXh0LmFyYygwLCAwLCByLCAwLCB0YXUkNCk7XHJcbiAgfVxyXG59O1xyXG5cclxudmFyIGNyb3NzJDIgPSB7XHJcbiAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSkge1xyXG4gICAgdmFyIHIgPSBNYXRoLnNxcnQoc2l6ZSAvIDUpIC8gMjtcclxuICAgIGNvbnRleHQubW92ZVRvKC0zICogciwgLXIpO1xyXG4gICAgY29udGV4dC5saW5lVG8oLXIsIC1yKTtcclxuICAgIGNvbnRleHQubGluZVRvKC1yLCAtMyAqIHIpO1xyXG4gICAgY29udGV4dC5saW5lVG8ociwgLTMgKiByKTtcclxuICAgIGNvbnRleHQubGluZVRvKHIsIC1yKTtcclxuICAgIGNvbnRleHQubGluZVRvKDMgKiByLCAtcik7XHJcbiAgICBjb250ZXh0LmxpbmVUbygzICogciwgcik7XHJcbiAgICBjb250ZXh0LmxpbmVUbyhyLCByKTtcclxuICAgIGNvbnRleHQubGluZVRvKHIsIDMgKiByKTtcclxuICAgIGNvbnRleHQubGluZVRvKC1yLCAzICogcik7XHJcbiAgICBjb250ZXh0LmxpbmVUbygtciwgcik7XHJcbiAgICBjb250ZXh0LmxpbmVUbygtMyAqIHIsIHIpO1xyXG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcclxuICB9XHJcbn07XHJcblxyXG52YXIgdGFuMzAgPSBNYXRoLnNxcnQoMSAvIDMpLFxyXG4gICAgdGFuMzBfMiA9IHRhbjMwICogMjtcclxuXHJcbnZhciBkaWFtb25kID0ge1xyXG4gIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUpIHtcclxuICAgIHZhciB5ID0gTWF0aC5zcXJ0KHNpemUgLyB0YW4zMF8yKSxcclxuICAgICAgICB4ID0geSAqIHRhbjMwO1xyXG4gICAgY29udGV4dC5tb3ZlVG8oMCwgLXkpO1xyXG4gICAgY29udGV4dC5saW5lVG8oeCwgMCk7XHJcbiAgICBjb250ZXh0LmxpbmVUbygwLCB5KTtcclxuICAgIGNvbnRleHQubGluZVRvKC14LCAwKTtcclxuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XHJcbiAgfVxyXG59O1xyXG5cclxudmFyIGthID0gMC44OTA4MTMwOTE1MjkyODUyMjgxMCxcclxuICAgIGtyID0gTWF0aC5zaW4ocGkkNCAvIDEwKSAvIE1hdGguc2luKDcgKiBwaSQ0IC8gMTApLFxyXG4gICAga3ggPSBNYXRoLnNpbih0YXUkNCAvIDEwKSAqIGtyLFxyXG4gICAga3kgPSAtTWF0aC5jb3ModGF1JDQgLyAxMCkgKiBrcjtcclxuXHJcbnZhciBzdGFyID0ge1xyXG4gIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUpIHtcclxuICAgIHZhciByID0gTWF0aC5zcXJ0KHNpemUgKiBrYSksXHJcbiAgICAgICAgeCA9IGt4ICogcixcclxuICAgICAgICB5ID0ga3kgKiByO1xyXG4gICAgY29udGV4dC5tb3ZlVG8oMCwgLXIpO1xyXG4gICAgY29udGV4dC5saW5lVG8oeCwgeSk7XHJcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IDU7ICsraSkge1xyXG4gICAgICB2YXIgYSA9IHRhdSQ0ICogaSAvIDUsXHJcbiAgICAgICAgICBjID0gTWF0aC5jb3MoYSksXHJcbiAgICAgICAgICBzID0gTWF0aC5zaW4oYSk7XHJcbiAgICAgIGNvbnRleHQubGluZVRvKHMgKiByLCAtYyAqIHIpO1xyXG4gICAgICBjb250ZXh0LmxpbmVUbyhjICogeCAtIHMgKiB5LCBzICogeCArIGMgKiB5KTtcclxuICAgIH1cclxuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XHJcbiAgfVxyXG59O1xyXG5cclxudmFyIHNxdWFyZSA9IHtcclxuICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBzaXplKSB7XHJcbiAgICB2YXIgdyA9IE1hdGguc3FydChzaXplKSxcclxuICAgICAgICB4ID0gLXcgLyAyO1xyXG4gICAgY29udGV4dC5yZWN0KHgsIHgsIHcsIHcpO1xyXG4gIH1cclxufTtcclxuXHJcbnZhciBzcXJ0MyA9IE1hdGguc3FydCgzKTtcclxuXHJcbnZhciB0cmlhbmdsZSA9IHtcclxuICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBzaXplKSB7XHJcbiAgICB2YXIgeSA9IC1NYXRoLnNxcnQoc2l6ZSAvIChzcXJ0MyAqIDMpKTtcclxuICAgIGNvbnRleHQubW92ZVRvKDAsIHkgKiAyKTtcclxuICAgIGNvbnRleHQubGluZVRvKC1zcXJ0MyAqIHksIC15KTtcclxuICAgIGNvbnRleHQubGluZVRvKHNxcnQzICogeSwgLXkpO1xyXG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcclxuICB9XHJcbn07XHJcblxyXG52YXIgYyQyID0gLTAuNSxcclxuICAgIHMgPSBNYXRoLnNxcnQoMykgLyAyLFxyXG4gICAgayA9IDEgLyBNYXRoLnNxcnQoMTIpLFxyXG4gICAgYSA9IChrIC8gMiArIDEpICogMztcclxuXHJcbnZhciB3eWUgPSB7XHJcbiAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSkge1xyXG4gICAgdmFyIHIgPSBNYXRoLnNxcnQoc2l6ZSAvIGEpLFxyXG4gICAgICAgIHgwID0gciAvIDIsXHJcbiAgICAgICAgeTAgPSByICogayxcclxuICAgICAgICB4MSA9IHgwLFxyXG4gICAgICAgIHkxID0gciAqIGsgKyByLFxyXG4gICAgICAgIHgyID0gLXgxLFxyXG4gICAgICAgIHkyID0geTE7XHJcbiAgICBjb250ZXh0Lm1vdmVUbyh4MCwgeTApO1xyXG4gICAgY29udGV4dC5saW5lVG8oeDEsIHkxKTtcclxuICAgIGNvbnRleHQubGluZVRvKHgyLCB5Mik7XHJcbiAgICBjb250ZXh0LmxpbmVUbyhjJDIgKiB4MCAtIHMgKiB5MCwgcyAqIHgwICsgYyQyICogeTApO1xyXG4gICAgY29udGV4dC5saW5lVG8oYyQyICogeDEgLSBzICogeTEsIHMgKiB4MSArIGMkMiAqIHkxKTtcclxuICAgIGNvbnRleHQubGluZVRvKGMkMiAqIHgyIC0gcyAqIHkyLCBzICogeDIgKyBjJDIgKiB5Mik7XHJcbiAgICBjb250ZXh0LmxpbmVUbyhjJDIgKiB4MCArIHMgKiB5MCwgYyQyICogeTAgLSBzICogeDApO1xyXG4gICAgY29udGV4dC5saW5lVG8oYyQyICogeDEgKyBzICogeTEsIGMkMiAqIHkxIC0gcyAqIHgxKTtcclxuICAgIGNvbnRleHQubGluZVRvKGMkMiAqIHgyICsgcyAqIHkyLCBjJDIgKiB5MiAtIHMgKiB4Mik7XHJcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xyXG4gIH1cclxufTtcclxuXHJcbnZhciBzeW1ib2xzID0gW1xyXG4gIGNpcmNsZSQyLFxyXG4gIGNyb3NzJDIsXHJcbiAgZGlhbW9uZCxcclxuICBzcXVhcmUsXHJcbiAgc3RhcixcclxuICB0cmlhbmdsZSxcclxuICB3eWVcclxuXTtcclxuXHJcbmZ1bmN0aW9uIHN5bWJvbCgpIHtcclxuICB2YXIgdHlwZSA9IGNvbnN0YW50JDExKGNpcmNsZSQyKSxcclxuICAgICAgc2l6ZSA9IGNvbnN0YW50JDExKDY0KSxcclxuICAgICAgY29udGV4dCA9IG51bGw7XHJcblxyXG4gIGZ1bmN0aW9uIHN5bWJvbCgpIHtcclxuICAgIHZhciBidWZmZXI7XHJcbiAgICBpZiAoIWNvbnRleHQpIGNvbnRleHQgPSBidWZmZXIgPSBwYXRoKCk7XHJcbiAgICB0eXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykuZHJhdyhjb250ZXh0LCArc2l6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcclxuICAgIGlmIChidWZmZXIpIHJldHVybiBjb250ZXh0ID0gbnVsbCwgYnVmZmVyICsgXCJcIiB8fCBudWxsO1xyXG4gIH1cclxuXHJcbiAgc3ltYm9sLnR5cGUgPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0eXBlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCQxMShfKSwgc3ltYm9sKSA6IHR5cGU7XHJcbiAgfTtcclxuXHJcbiAgc3ltYm9sLnNpemUgPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzaXplID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCQxMSgrXyksIHN5bWJvbCkgOiBzaXplO1xyXG4gIH07XHJcblxyXG4gIHN5bWJvbC5jb250ZXh0ID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY29udGV4dCA9IF8gPT0gbnVsbCA/IG51bGwgOiBfLCBzeW1ib2wpIDogY29udGV4dDtcclxuICB9O1xyXG5cclxuICByZXR1cm4gc3ltYm9sO1xyXG59XHJcblxyXG5mdW5jdGlvbiBub29wJDMoKSB7fVxyXG5cclxuZnVuY3Rpb24gcG9pbnQkMih0aGF0LCB4LCB5KSB7XHJcbiAgdGhhdC5fY29udGV4dC5iZXppZXJDdXJ2ZVRvKFxyXG4gICAgKDIgKiB0aGF0Ll94MCArIHRoYXQuX3gxKSAvIDMsXHJcbiAgICAoMiAqIHRoYXQuX3kwICsgdGhhdC5feTEpIC8gMyxcclxuICAgICh0aGF0Ll94MCArIDIgKiB0aGF0Ll94MSkgLyAzLFxyXG4gICAgKHRoYXQuX3kwICsgMiAqIHRoYXQuX3kxKSAvIDMsXHJcbiAgICAodGhhdC5feDAgKyA0ICogdGhhdC5feDEgKyB4KSAvIDYsXHJcbiAgICAodGhhdC5feTAgKyA0ICogdGhhdC5feTEgKyB5KSAvIDZcclxuICApO1xyXG59XHJcblxyXG5mdW5jdGlvbiBCYXNpcyhjb250ZXh0KSB7XHJcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XHJcbn1cclxuXHJcbkJhc2lzLnByb3RvdHlwZSA9IHtcclxuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5fbGluZSA9IDA7XHJcbiAgfSxcclxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuX2xpbmUgPSBOYU47XHJcbiAgfSxcclxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9XHJcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gTmFOO1xyXG4gICAgdGhpcy5fcG9pbnQgPSAwO1xyXG4gIH0sXHJcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XHJcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XHJcbiAgICAgIGNhc2UgMzogcG9pbnQkMih0aGlzLCB0aGlzLl94MSwgdGhpcy5feTEpOyAvLyBwcm9jZWVkXHJcbiAgICAgIGNhc2UgMjogdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDEsIHRoaXMuX3kxKTsgYnJlYWs7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMSkpIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XHJcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XHJcbiAgfSxcclxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgeCA9ICt4LCB5ID0gK3k7XHJcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XHJcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4LCB5KTsgYnJlYWs7XHJcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyBicmVhaztcclxuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IHRoaXMuX2NvbnRleHQubGluZVRvKCg1ICogdGhpcy5feDAgKyB0aGlzLl94MSkgLyA2LCAoNSAqIHRoaXMuX3kwICsgdGhpcy5feTEpIC8gNik7IC8vIHByb2NlZWRcclxuICAgICAgZGVmYXVsdDogcG9pbnQkMih0aGlzLCB4LCB5KTsgYnJlYWs7XHJcbiAgICB9XHJcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHg7XHJcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHk7XHJcbiAgfVxyXG59O1xyXG5cclxuZnVuY3Rpb24gYmFzaXMkMihjb250ZXh0KSB7XHJcbiAgcmV0dXJuIG5ldyBCYXNpcyhjb250ZXh0KTtcclxufVxyXG5cclxuZnVuY3Rpb24gQmFzaXNDbG9zZWQoY29udGV4dCkge1xyXG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xyXG59XHJcblxyXG5CYXNpc0Nsb3NlZC5wcm90b3R5cGUgPSB7XHJcbiAgYXJlYVN0YXJ0OiBub29wJDMsXHJcbiAgYXJlYUVuZDogbm9vcCQzLFxyXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID0gdGhpcy5feDIgPSB0aGlzLl94MyA9IHRoaXMuX3g0ID1cclxuICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPSB0aGlzLl95MiA9IHRoaXMuX3kzID0gdGhpcy5feTQgPSBOYU47XHJcbiAgICB0aGlzLl9wb2ludCA9IDA7XHJcbiAgfSxcclxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcclxuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcclxuICAgICAgY2FzZSAxOiB7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDIsIHRoaXMuX3kyKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIGNhc2UgMjoge1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQubW92ZVRvKCh0aGlzLl94MiArIDIgKiB0aGlzLl94MykgLyAzLCAodGhpcy5feTIgKyAyICogdGhpcy5feTMpIC8gMyk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oKHRoaXMuX3gzICsgMiAqIHRoaXMuX3gyKSAvIDMsICh0aGlzLl95MyArIDIgKiB0aGlzLl95MikgLyAzKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIGNhc2UgMzoge1xyXG4gICAgICAgIHRoaXMucG9pbnQodGhpcy5feDIsIHRoaXMuX3kyKTtcclxuICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3gzLCB0aGlzLl95Myk7XHJcbiAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94NCwgdGhpcy5feTQpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgeCA9ICt4LCB5ID0gK3k7XHJcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XHJcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyB0aGlzLl94MiA9IHgsIHRoaXMuX3kyID0geTsgYnJlYWs7XHJcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyB0aGlzLl94MyA9IHgsIHRoaXMuX3kzID0geTsgYnJlYWs7XHJcbiAgICAgIGNhc2UgMjogdGhpcy5fcG9pbnQgPSAzOyB0aGlzLl94NCA9IHgsIHRoaXMuX3k0ID0geTsgdGhpcy5fY29udGV4dC5tb3ZlVG8oKHRoaXMuX3gwICsgNCAqIHRoaXMuX3gxICsgeCkgLyA2LCAodGhpcy5feTAgKyA0ICogdGhpcy5feTEgKyB5KSAvIDYpOyBicmVhaztcclxuICAgICAgZGVmYXVsdDogcG9pbnQkMih0aGlzLCB4LCB5KTsgYnJlYWs7XHJcbiAgICB9XHJcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHg7XHJcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHk7XHJcbiAgfVxyXG59O1xyXG5cclxuZnVuY3Rpb24gYmFzaXNDbG9zZWQkMShjb250ZXh0KSB7XHJcbiAgcmV0dXJuIG5ldyBCYXNpc0Nsb3NlZChjb250ZXh0KTtcclxufVxyXG5cclxuZnVuY3Rpb24gQmFzaXNPcGVuKGNvbnRleHQpIHtcclxuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcclxufVxyXG5cclxuQmFzaXNPcGVuLnByb3RvdHlwZSA9IHtcclxuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5fbGluZSA9IDA7XHJcbiAgfSxcclxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuX2xpbmUgPSBOYU47XHJcbiAgfSxcclxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9XHJcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gTmFOO1xyXG4gICAgdGhpcy5fcG9pbnQgPSAwO1xyXG4gIH0sXHJcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XHJcbiAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMykpIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XHJcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XHJcbiAgfSxcclxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgeCA9ICt4LCB5ID0gK3k7XHJcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XHJcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyBicmVhaztcclxuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IGJyZWFrO1xyXG4gICAgICBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMzsgdmFyIHgwID0gKHRoaXMuX3gwICsgNCAqIHRoaXMuX3gxICsgeCkgLyA2LCB5MCA9ICh0aGlzLl95MCArIDQgKiB0aGlzLl95MSArIHkpIC8gNjsgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHgwLCB5MCkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4MCwgeTApOyBicmVhaztcclxuICAgICAgY2FzZSAzOiB0aGlzLl9wb2ludCA9IDQ7IC8vIHByb2NlZWRcclxuICAgICAgZGVmYXVsdDogcG9pbnQkMih0aGlzLCB4LCB5KTsgYnJlYWs7XHJcbiAgICB9XHJcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHg7XHJcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHk7XHJcbiAgfVxyXG59O1xyXG5cclxuZnVuY3Rpb24gYmFzaXNPcGVuKGNvbnRleHQpIHtcclxuICByZXR1cm4gbmV3IEJhc2lzT3Blbihjb250ZXh0KTtcclxufVxyXG5cclxuZnVuY3Rpb24gQnVuZGxlKGNvbnRleHQsIGJldGEpIHtcclxuICB0aGlzLl9iYXNpcyA9IG5ldyBCYXNpcyhjb250ZXh0KTtcclxuICB0aGlzLl9iZXRhID0gYmV0YTtcclxufVxyXG5cclxuQnVuZGxlLnByb3RvdHlwZSA9IHtcclxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5feCA9IFtdO1xyXG4gICAgdGhpcy5feSA9IFtdO1xyXG4gICAgdGhpcy5fYmFzaXMubGluZVN0YXJ0KCk7XHJcbiAgfSxcclxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcclxuICAgIHZhciB4ID0gdGhpcy5feCxcclxuICAgICAgICB5ID0gdGhpcy5feSxcclxuICAgICAgICBqID0geC5sZW5ndGggLSAxO1xyXG5cclxuICAgIGlmIChqID4gMCkge1xyXG4gICAgICB2YXIgeDAgPSB4WzBdLFxyXG4gICAgICAgICAgeTAgPSB5WzBdLFxyXG4gICAgICAgICAgZHggPSB4W2pdIC0geDAsXHJcbiAgICAgICAgICBkeSA9IHlbal0gLSB5MCxcclxuICAgICAgICAgIGkgPSAtMSxcclxuICAgICAgICAgIHQ7XHJcblxyXG4gICAgICB3aGlsZSAoKytpIDw9IGopIHtcclxuICAgICAgICB0ID0gaSAvIGo7XHJcbiAgICAgICAgdGhpcy5fYmFzaXMucG9pbnQoXHJcbiAgICAgICAgICB0aGlzLl9iZXRhICogeFtpXSArICgxIC0gdGhpcy5fYmV0YSkgKiAoeDAgKyB0ICogZHgpLFxyXG4gICAgICAgICAgdGhpcy5fYmV0YSAqIHlbaV0gKyAoMSAtIHRoaXMuX2JldGEpICogKHkwICsgdCAqIGR5KVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl94ID0gdGhpcy5feSA9IG51bGw7XHJcbiAgICB0aGlzLl9iYXNpcy5saW5lRW5kKCk7XHJcbiAgfSxcclxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgdGhpcy5feC5wdXNoKCt4KTtcclxuICAgIHRoaXMuX3kucHVzaCgreSk7XHJcbiAgfVxyXG59O1xyXG5cclxudmFyIGJ1bmRsZSA9IChmdW5jdGlvbiBjdXN0b20oYmV0YSkge1xyXG5cclxuICBmdW5jdGlvbiBidW5kbGUoY29udGV4dCkge1xyXG4gICAgcmV0dXJuIGJldGEgPT09IDEgPyBuZXcgQmFzaXMoY29udGV4dCkgOiBuZXcgQnVuZGxlKGNvbnRleHQsIGJldGEpO1xyXG4gIH1cclxuXHJcbiAgYnVuZGxlLmJldGEgPSBmdW5jdGlvbihiZXRhKSB7XHJcbiAgICByZXR1cm4gY3VzdG9tKCtiZXRhKTtcclxuICB9O1xyXG5cclxuICByZXR1cm4gYnVuZGxlO1xyXG59KSgwLjg1KTtcclxuXHJcbmZ1bmN0aW9uIHBvaW50JDModGhhdCwgeCwgeSkge1xyXG4gIHRoYXQuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyhcclxuICAgIHRoYXQuX3gxICsgdGhhdC5fayAqICh0aGF0Ll94MiAtIHRoYXQuX3gwKSxcclxuICAgIHRoYXQuX3kxICsgdGhhdC5fayAqICh0aGF0Ll95MiAtIHRoYXQuX3kwKSxcclxuICAgIHRoYXQuX3gyICsgdGhhdC5fayAqICh0aGF0Ll94MSAtIHgpLFxyXG4gICAgdGhhdC5feTIgKyB0aGF0Ll9rICogKHRoYXQuX3kxIC0geSksXHJcbiAgICB0aGF0Ll94MixcclxuICAgIHRoYXQuX3kyXHJcbiAgKTtcclxufVxyXG5cclxuZnVuY3Rpb24gQ2FyZGluYWwoY29udGV4dCwgdGVuc2lvbikge1xyXG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xyXG4gIHRoaXMuX2sgPSAoMSAtIHRlbnNpb24pIC8gNjtcclxufVxyXG5cclxuQ2FyZGluYWwucHJvdG90eXBlID0ge1xyXG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLl9saW5lID0gMDtcclxuICB9LFxyXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5fbGluZSA9IE5hTjtcclxuICB9LFxyXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID0gdGhpcy5feDIgPVxyXG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gTmFOO1xyXG4gICAgdGhpcy5fcG9pbnQgPSAwO1xyXG4gIH0sXHJcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XHJcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XHJcbiAgICAgIGNhc2UgMjogdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDIsIHRoaXMuX3kyKTsgYnJlYWs7XHJcbiAgICAgIGNhc2UgMzogcG9pbnQkMyh0aGlzLCB0aGlzLl94MSwgdGhpcy5feTEpOyBicmVhaztcclxuICAgIH1cclxuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAxKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcclxuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcclxuICB9LFxyXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICB4ID0gK3gsIHkgPSAreTtcclxuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcclxuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHgsIHkpOyBicmVhaztcclxuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IHRoaXMuX3gxID0geCwgdGhpcy5feTEgPSB5OyBicmVhaztcclxuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IC8vIHByb2NlZWRcclxuICAgICAgZGVmYXVsdDogcG9pbnQkMyh0aGlzLCB4LCB5KTsgYnJlYWs7XHJcbiAgICB9XHJcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHRoaXMuX3gyLCB0aGlzLl94MiA9IHg7XHJcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHRoaXMuX3kyLCB0aGlzLl95MiA9IHk7XHJcbiAgfVxyXG59O1xyXG5cclxudmFyIGNhcmRpbmFsID0gKGZ1bmN0aW9uIGN1c3RvbSh0ZW5zaW9uKSB7XHJcblxyXG4gIGZ1bmN0aW9uIGNhcmRpbmFsKGNvbnRleHQpIHtcclxuICAgIHJldHVybiBuZXcgQ2FyZGluYWwoY29udGV4dCwgdGVuc2lvbik7XHJcbiAgfVxyXG5cclxuICBjYXJkaW5hbC50ZW5zaW9uID0gZnVuY3Rpb24odGVuc2lvbikge1xyXG4gICAgcmV0dXJuIGN1c3RvbSgrdGVuc2lvbik7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIGNhcmRpbmFsO1xyXG59KSgwKTtcclxuXHJcbmZ1bmN0aW9uIENhcmRpbmFsQ2xvc2VkKGNvbnRleHQsIHRlbnNpb24pIHtcclxuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcclxuICB0aGlzLl9rID0gKDEgLSB0ZW5zaW9uKSAvIDY7XHJcbn1cclxuXHJcbkNhcmRpbmFsQ2xvc2VkLnByb3RvdHlwZSA9IHtcclxuICBhcmVhU3RhcnQ6IG5vb3AkMyxcclxuICBhcmVhRW5kOiBub29wJDMsXHJcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPSB0aGlzLl94MiA9IHRoaXMuX3gzID0gdGhpcy5feDQgPSB0aGlzLl94NSA9XHJcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gdGhpcy5feTIgPSB0aGlzLl95MyA9IHRoaXMuX3k0ID0gdGhpcy5feTUgPSBOYU47XHJcbiAgICB0aGlzLl9wb2ludCA9IDA7XHJcbiAgfSxcclxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcclxuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcclxuICAgICAgY2FzZSAxOiB7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDMsIHRoaXMuX3kzKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIGNhc2UgMjoge1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gzLCB0aGlzLl95Myk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBjYXNlIDM6IHtcclxuICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3gzLCB0aGlzLl95Myk7XHJcbiAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94NCwgdGhpcy5feTQpO1xyXG4gICAgICAgIHRoaXMucG9pbnQodGhpcy5feDUsIHRoaXMuX3k1KTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgIHggPSAreCwgeSA9ICt5O1xyXG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xyXG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5feDMgPSB4LCB0aGlzLl95MyA9IHk7IGJyZWFrO1xyXG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgdGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDQgPSB4LCB0aGlzLl95NCA9IHkpOyBicmVhaztcclxuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IHRoaXMuX3g1ID0geCwgdGhpcy5feTUgPSB5OyBicmVhaztcclxuICAgICAgZGVmYXVsdDogcG9pbnQkMyh0aGlzLCB4LCB5KTsgYnJlYWs7XHJcbiAgICB9XHJcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHRoaXMuX3gyLCB0aGlzLl94MiA9IHg7XHJcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHRoaXMuX3kyLCB0aGlzLl95MiA9IHk7XHJcbiAgfVxyXG59O1xyXG5cclxudmFyIGNhcmRpbmFsQ2xvc2VkID0gKGZ1bmN0aW9uIGN1c3RvbSh0ZW5zaW9uKSB7XHJcblxyXG4gIGZ1bmN0aW9uIGNhcmRpbmFsJCQxKGNvbnRleHQpIHtcclxuICAgIHJldHVybiBuZXcgQ2FyZGluYWxDbG9zZWQoY29udGV4dCwgdGVuc2lvbik7XHJcbiAgfVxyXG5cclxuICBjYXJkaW5hbCQkMS50ZW5zaW9uID0gZnVuY3Rpb24odGVuc2lvbikge1xyXG4gICAgcmV0dXJuIGN1c3RvbSgrdGVuc2lvbik7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIGNhcmRpbmFsJCQxO1xyXG59KSgwKTtcclxuXHJcbmZ1bmN0aW9uIENhcmRpbmFsT3Blbihjb250ZXh0LCB0ZW5zaW9uKSB7XHJcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XHJcbiAgdGhpcy5fayA9ICgxIC0gdGVuc2lvbikgLyA2O1xyXG59XHJcblxyXG5DYXJkaW5hbE9wZW4ucHJvdG90eXBlID0ge1xyXG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLl9saW5lID0gMDtcclxuICB9LFxyXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5fbGluZSA9IE5hTjtcclxuICB9LFxyXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID0gdGhpcy5feDIgPVxyXG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gTmFOO1xyXG4gICAgdGhpcy5fcG9pbnQgPSAwO1xyXG4gIH0sXHJcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XHJcbiAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMykpIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XHJcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XHJcbiAgfSxcclxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgeCA9ICt4LCB5ID0gK3k7XHJcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XHJcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyBicmVhaztcclxuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IGJyZWFrO1xyXG4gICAgICBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMzsgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gyLCB0aGlzLl95MikgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh0aGlzLl94MiwgdGhpcy5feTIpOyBicmVhaztcclxuICAgICAgY2FzZSAzOiB0aGlzLl9wb2ludCA9IDQ7IC8vIHByb2NlZWRcclxuICAgICAgZGVmYXVsdDogcG9pbnQkMyh0aGlzLCB4LCB5KTsgYnJlYWs7XHJcbiAgICB9XHJcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHRoaXMuX3gyLCB0aGlzLl94MiA9IHg7XHJcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHRoaXMuX3kyLCB0aGlzLl95MiA9IHk7XHJcbiAgfVxyXG59O1xyXG5cclxudmFyIGNhcmRpbmFsT3BlbiA9IChmdW5jdGlvbiBjdXN0b20odGVuc2lvbikge1xyXG5cclxuICBmdW5jdGlvbiBjYXJkaW5hbCQkMShjb250ZXh0KSB7XHJcbiAgICByZXR1cm4gbmV3IENhcmRpbmFsT3Blbihjb250ZXh0LCB0ZW5zaW9uKTtcclxuICB9XHJcblxyXG4gIGNhcmRpbmFsJCQxLnRlbnNpb24gPSBmdW5jdGlvbih0ZW5zaW9uKSB7XHJcbiAgICByZXR1cm4gY3VzdG9tKCt0ZW5zaW9uKTtcclxuICB9O1xyXG5cclxuICByZXR1cm4gY2FyZGluYWwkJDE7XHJcbn0pKDApO1xyXG5cclxuZnVuY3Rpb24gcG9pbnQkNCh0aGF0LCB4LCB5KSB7XHJcbiAgdmFyIHgxID0gdGhhdC5feDEsXHJcbiAgICAgIHkxID0gdGhhdC5feTEsXHJcbiAgICAgIHgyID0gdGhhdC5feDIsXHJcbiAgICAgIHkyID0gdGhhdC5feTI7XHJcblxyXG4gIGlmICh0aGF0Ll9sMDFfYSA+IGVwc2lsb24kMykge1xyXG4gICAgdmFyIGEgPSAyICogdGhhdC5fbDAxXzJhICsgMyAqIHRoYXQuX2wwMV9hICogdGhhdC5fbDEyX2EgKyB0aGF0Ll9sMTJfMmEsXHJcbiAgICAgICAgbiA9IDMgKiB0aGF0Ll9sMDFfYSAqICh0aGF0Ll9sMDFfYSArIHRoYXQuX2wxMl9hKTtcclxuICAgIHgxID0gKHgxICogYSAtIHRoYXQuX3gwICogdGhhdC5fbDEyXzJhICsgdGhhdC5feDIgKiB0aGF0Ll9sMDFfMmEpIC8gbjtcclxuICAgIHkxID0gKHkxICogYSAtIHRoYXQuX3kwICogdGhhdC5fbDEyXzJhICsgdGhhdC5feTIgKiB0aGF0Ll9sMDFfMmEpIC8gbjtcclxuICB9XHJcblxyXG4gIGlmICh0aGF0Ll9sMjNfYSA+IGVwc2lsb24kMykge1xyXG4gICAgdmFyIGIgPSAyICogdGhhdC5fbDIzXzJhICsgMyAqIHRoYXQuX2wyM19hICogdGhhdC5fbDEyX2EgKyB0aGF0Ll9sMTJfMmEsXHJcbiAgICAgICAgbSA9IDMgKiB0aGF0Ll9sMjNfYSAqICh0aGF0Ll9sMjNfYSArIHRoYXQuX2wxMl9hKTtcclxuICAgIHgyID0gKHgyICogYiArIHRoYXQuX3gxICogdGhhdC5fbDIzXzJhIC0geCAqIHRoYXQuX2wxMl8yYSkgLyBtO1xyXG4gICAgeTIgPSAoeTIgKiBiICsgdGhhdC5feTEgKiB0aGF0Ll9sMjNfMmEgLSB5ICogdGhhdC5fbDEyXzJhKSAvIG07XHJcbiAgfVxyXG5cclxuICB0aGF0Ll9jb250ZXh0LmJlemllckN1cnZlVG8oeDEsIHkxLCB4MiwgeTIsIHRoYXQuX3gyLCB0aGF0Ll95Mik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIENhdG11bGxSb20oY29udGV4dCwgYWxwaGEpIHtcclxuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcclxuICB0aGlzLl9hbHBoYSA9IGFscGhhO1xyXG59XHJcblxyXG5DYXRtdWxsUm9tLnByb3RvdHlwZSA9IHtcclxuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5fbGluZSA9IDA7XHJcbiAgfSxcclxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuX2xpbmUgPSBOYU47XHJcbiAgfSxcclxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9IHRoaXMuX3gyID1cclxuICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPSB0aGlzLl95MiA9IE5hTjtcclxuICAgIHRoaXMuX2wwMV9hID0gdGhpcy5fbDEyX2EgPSB0aGlzLl9sMjNfYSA9XHJcbiAgICB0aGlzLl9sMDFfMmEgPSB0aGlzLl9sMTJfMmEgPSB0aGlzLl9sMjNfMmEgPVxyXG4gICAgdGhpcy5fcG9pbnQgPSAwO1xyXG4gIH0sXHJcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XHJcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XHJcbiAgICAgIGNhc2UgMjogdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDIsIHRoaXMuX3kyKTsgYnJlYWs7XHJcbiAgICAgIGNhc2UgMzogdGhpcy5wb2ludCh0aGlzLl94MiwgdGhpcy5feTIpOyBicmVhaztcclxuICAgIH1cclxuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAxKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcclxuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcclxuICB9LFxyXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICB4ID0gK3gsIHkgPSAreTtcclxuXHJcbiAgICBpZiAodGhpcy5fcG9pbnQpIHtcclxuICAgICAgdmFyIHgyMyA9IHRoaXMuX3gyIC0geCxcclxuICAgICAgICAgIHkyMyA9IHRoaXMuX3kyIC0geTtcclxuICAgICAgdGhpcy5fbDIzX2EgPSBNYXRoLnNxcnQodGhpcy5fbDIzXzJhID0gTWF0aC5wb3coeDIzICogeDIzICsgeTIzICogeTIzLCB0aGlzLl9hbHBoYSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcclxuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHgsIHkpOyBicmVhaztcclxuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IGJyZWFrO1xyXG4gICAgICBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMzsgLy8gcHJvY2VlZFxyXG4gICAgICBkZWZhdWx0OiBwb2ludCQ0KHRoaXMsIHgsIHkpOyBicmVhaztcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9sMDFfYSA9IHRoaXMuX2wxMl9hLCB0aGlzLl9sMTJfYSA9IHRoaXMuX2wyM19hO1xyXG4gICAgdGhpcy5fbDAxXzJhID0gdGhpcy5fbDEyXzJhLCB0aGlzLl9sMTJfMmEgPSB0aGlzLl9sMjNfMmE7XHJcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHRoaXMuX3gyLCB0aGlzLl94MiA9IHg7XHJcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHRoaXMuX3kyLCB0aGlzLl95MiA9IHk7XHJcbiAgfVxyXG59O1xyXG5cclxudmFyIGNhdG11bGxSb20gPSAoZnVuY3Rpb24gY3VzdG9tKGFscGhhKSB7XHJcblxyXG4gIGZ1bmN0aW9uIGNhdG11bGxSb20oY29udGV4dCkge1xyXG4gICAgcmV0dXJuIGFscGhhID8gbmV3IENhdG11bGxSb20oY29udGV4dCwgYWxwaGEpIDogbmV3IENhcmRpbmFsKGNvbnRleHQsIDApO1xyXG4gIH1cclxuXHJcbiAgY2F0bXVsbFJvbS5hbHBoYSA9IGZ1bmN0aW9uKGFscGhhKSB7XHJcbiAgICByZXR1cm4gY3VzdG9tKCthbHBoYSk7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIGNhdG11bGxSb207XHJcbn0pKDAuNSk7XHJcblxyXG5mdW5jdGlvbiBDYXRtdWxsUm9tQ2xvc2VkKGNvbnRleHQsIGFscGhhKSB7XHJcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XHJcbiAgdGhpcy5fYWxwaGEgPSBhbHBoYTtcclxufVxyXG5cclxuQ2F0bXVsbFJvbUNsb3NlZC5wcm90b3R5cGUgPSB7XHJcbiAgYXJlYVN0YXJ0OiBub29wJDMsXHJcbiAgYXJlYUVuZDogbm9vcCQzLFxyXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID0gdGhpcy5feDIgPSB0aGlzLl94MyA9IHRoaXMuX3g0ID0gdGhpcy5feDUgPVxyXG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gdGhpcy5feTMgPSB0aGlzLl95NCA9IHRoaXMuX3k1ID0gTmFOO1xyXG4gICAgdGhpcy5fbDAxX2EgPSB0aGlzLl9sMTJfYSA9IHRoaXMuX2wyM19hID1cclxuICAgIHRoaXMuX2wwMV8yYSA9IHRoaXMuX2wxMl8yYSA9IHRoaXMuX2wyM18yYSA9XHJcbiAgICB0aGlzLl9wb2ludCA9IDA7XHJcbiAgfSxcclxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcclxuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcclxuICAgICAgY2FzZSAxOiB7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDMsIHRoaXMuX3kzKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIGNhc2UgMjoge1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gzLCB0aGlzLl95Myk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBjYXNlIDM6IHtcclxuICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3gzLCB0aGlzLl95Myk7XHJcbiAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94NCwgdGhpcy5feTQpO1xyXG4gICAgICAgIHRoaXMucG9pbnQodGhpcy5feDUsIHRoaXMuX3k1KTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgIHggPSAreCwgeSA9ICt5O1xyXG5cclxuICAgIGlmICh0aGlzLl9wb2ludCkge1xyXG4gICAgICB2YXIgeDIzID0gdGhpcy5feDIgLSB4LFxyXG4gICAgICAgICAgeTIzID0gdGhpcy5feTIgLSB5O1xyXG4gICAgICB0aGlzLl9sMjNfYSA9IE1hdGguc3FydCh0aGlzLl9sMjNfMmEgPSBNYXRoLnBvdyh4MjMgKiB4MjMgKyB5MjMgKiB5MjMsIHRoaXMuX2FscGhhKSk7XHJcbiAgICB9XHJcblxyXG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xyXG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5feDMgPSB4LCB0aGlzLl95MyA9IHk7IGJyZWFrO1xyXG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgdGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDQgPSB4LCB0aGlzLl95NCA9IHkpOyBicmVhaztcclxuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IHRoaXMuX3g1ID0geCwgdGhpcy5feTUgPSB5OyBicmVhaztcclxuICAgICAgZGVmYXVsdDogcG9pbnQkNCh0aGlzLCB4LCB5KTsgYnJlYWs7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fbDAxX2EgPSB0aGlzLl9sMTJfYSwgdGhpcy5fbDEyX2EgPSB0aGlzLl9sMjNfYTtcclxuICAgIHRoaXMuX2wwMV8yYSA9IHRoaXMuX2wxMl8yYSwgdGhpcy5fbDEyXzJhID0gdGhpcy5fbDIzXzJhO1xyXG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB0aGlzLl94MiwgdGhpcy5feDIgPSB4O1xyXG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB0aGlzLl95MiwgdGhpcy5feTIgPSB5O1xyXG4gIH1cclxufTtcclxuXHJcbnZhciBjYXRtdWxsUm9tQ2xvc2VkID0gKGZ1bmN0aW9uIGN1c3RvbShhbHBoYSkge1xyXG5cclxuICBmdW5jdGlvbiBjYXRtdWxsUm9tJCQxKGNvbnRleHQpIHtcclxuICAgIHJldHVybiBhbHBoYSA/IG5ldyBDYXRtdWxsUm9tQ2xvc2VkKGNvbnRleHQsIGFscGhhKSA6IG5ldyBDYXJkaW5hbENsb3NlZChjb250ZXh0LCAwKTtcclxuICB9XHJcblxyXG4gIGNhdG11bGxSb20kJDEuYWxwaGEgPSBmdW5jdGlvbihhbHBoYSkge1xyXG4gICAgcmV0dXJuIGN1c3RvbSgrYWxwaGEpO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBjYXRtdWxsUm9tJCQxO1xyXG59KSgwLjUpO1xyXG5cclxuZnVuY3Rpb24gQ2F0bXVsbFJvbU9wZW4oY29udGV4dCwgYWxwaGEpIHtcclxuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcclxuICB0aGlzLl9hbHBoYSA9IGFscGhhO1xyXG59XHJcblxyXG5DYXRtdWxsUm9tT3Blbi5wcm90b3R5cGUgPSB7XHJcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuX2xpbmUgPSAwO1xyXG4gIH0sXHJcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLl9saW5lID0gTmFOO1xyXG4gIH0sXHJcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPSB0aGlzLl94MiA9XHJcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gdGhpcy5feTIgPSBOYU47XHJcbiAgICB0aGlzLl9sMDFfYSA9IHRoaXMuX2wxMl9hID0gdGhpcy5fbDIzX2EgPVxyXG4gICAgdGhpcy5fbDAxXzJhID0gdGhpcy5fbDEyXzJhID0gdGhpcy5fbDIzXzJhID1cclxuICAgIHRoaXMuX3BvaW50ID0gMDtcclxuICB9LFxyXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDMpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xyXG4gICAgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xyXG4gIH0sXHJcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgIHggPSAreCwgeSA9ICt5O1xyXG5cclxuICAgIGlmICh0aGlzLl9wb2ludCkge1xyXG4gICAgICB2YXIgeDIzID0gdGhpcy5feDIgLSB4LFxyXG4gICAgICAgICAgeTIzID0gdGhpcy5feTIgLSB5O1xyXG4gICAgICB0aGlzLl9sMjNfYSA9IE1hdGguc3FydCh0aGlzLl9sMjNfMmEgPSBNYXRoLnBvdyh4MjMgKiB4MjMgKyB5MjMgKiB5MjMsIHRoaXMuX2FscGhhKSk7XHJcbiAgICB9XHJcblxyXG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xyXG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgYnJlYWs7XHJcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyBicmVhaztcclxuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MiwgdGhpcy5feTIpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDIsIHRoaXMuX3kyKTsgYnJlYWs7XHJcbiAgICAgIGNhc2UgMzogdGhpcy5fcG9pbnQgPSA0OyAvLyBwcm9jZWVkXHJcbiAgICAgIGRlZmF1bHQ6IHBvaW50JDQodGhpcywgeCwgeSk7IGJyZWFrO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX2wwMV9hID0gdGhpcy5fbDEyX2EsIHRoaXMuX2wxMl9hID0gdGhpcy5fbDIzX2E7XHJcbiAgICB0aGlzLl9sMDFfMmEgPSB0aGlzLl9sMTJfMmEsIHRoaXMuX2wxMl8yYSA9IHRoaXMuX2wyM18yYTtcclxuICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0gdGhpcy5feDIsIHRoaXMuX3gyID0geDtcclxuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0gdGhpcy5feTIsIHRoaXMuX3kyID0geTtcclxuICB9XHJcbn07XHJcblxyXG52YXIgY2F0bXVsbFJvbU9wZW4gPSAoZnVuY3Rpb24gY3VzdG9tKGFscGhhKSB7XHJcblxyXG4gIGZ1bmN0aW9uIGNhdG11bGxSb20kJDEoY29udGV4dCkge1xyXG4gICAgcmV0dXJuIGFscGhhID8gbmV3IENhdG11bGxSb21PcGVuKGNvbnRleHQsIGFscGhhKSA6IG5ldyBDYXJkaW5hbE9wZW4oY29udGV4dCwgMCk7XHJcbiAgfVxyXG5cclxuICBjYXRtdWxsUm9tJCQxLmFscGhhID0gZnVuY3Rpb24oYWxwaGEpIHtcclxuICAgIHJldHVybiBjdXN0b20oK2FscGhhKTtcclxuICB9O1xyXG5cclxuICByZXR1cm4gY2F0bXVsbFJvbSQkMTtcclxufSkoMC41KTtcclxuXHJcbmZ1bmN0aW9uIExpbmVhckNsb3NlZChjb250ZXh0KSB7XHJcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XHJcbn1cclxuXHJcbkxpbmVhckNsb3NlZC5wcm90b3R5cGUgPSB7XHJcbiAgYXJlYVN0YXJ0OiBub29wJDMsXHJcbiAgYXJlYUVuZDogbm9vcCQzLFxyXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLl9wb2ludCA9IDA7XHJcbiAgfSxcclxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcclxuICAgIGlmICh0aGlzLl9wb2ludCkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcclxuICB9LFxyXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICB4ID0gK3gsIHkgPSAreTtcclxuICAgIGlmICh0aGlzLl9wb2ludCkgdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSk7XHJcbiAgICBlbHNlIHRoaXMuX3BvaW50ID0gMSwgdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7XHJcbiAgfVxyXG59O1xyXG5cclxuZnVuY3Rpb24gbGluZWFyQ2xvc2VkKGNvbnRleHQpIHtcclxuICByZXR1cm4gbmV3IExpbmVhckNsb3NlZChjb250ZXh0KTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2lnbiQxKHgpIHtcclxuICByZXR1cm4geCA8IDAgPyAtMSA6IDE7XHJcbn1cclxuXHJcbi8vIENhbGN1bGF0ZSB0aGUgc2xvcGVzIG9mIHRoZSB0YW5nZW50cyAoSGVybWl0ZS10eXBlIGludGVycG9sYXRpb24pIGJhc2VkIG9uXHJcbi8vIHRoZSBmb2xsb3dpbmcgcGFwZXI6IFN0ZWZmZW4sIE0uIDE5OTAuIEEgU2ltcGxlIE1ldGhvZCBmb3IgTW9ub3RvbmljXHJcbi8vIEludGVycG9sYXRpb24gaW4gT25lIERpbWVuc2lvbi4gQXN0cm9ub215IGFuZCBBc3Ryb3BoeXNpY3MsIFZvbC4gMjM5LCBOTy5cclxuLy8gTk9WKElJKSwgUC4gNDQzLCAxOTkwLlxyXG5mdW5jdGlvbiBzbG9wZTModGhhdCwgeDIsIHkyKSB7XHJcbiAgdmFyIGgwID0gdGhhdC5feDEgLSB0aGF0Ll94MCxcclxuICAgICAgaDEgPSB4MiAtIHRoYXQuX3gxLFxyXG4gICAgICBzMCA9ICh0aGF0Ll95MSAtIHRoYXQuX3kwKSAvIChoMCB8fCBoMSA8IDAgJiYgLTApLFxyXG4gICAgICBzMSA9ICh5MiAtIHRoYXQuX3kxKSAvIChoMSB8fCBoMCA8IDAgJiYgLTApLFxyXG4gICAgICBwID0gKHMwICogaDEgKyBzMSAqIGgwKSAvIChoMCArIGgxKTtcclxuICByZXR1cm4gKHNpZ24kMShzMCkgKyBzaWduJDEoczEpKSAqIE1hdGgubWluKE1hdGguYWJzKHMwKSwgTWF0aC5hYnMoczEpLCAwLjUgKiBNYXRoLmFicyhwKSkgfHwgMDtcclxufVxyXG5cclxuLy8gQ2FsY3VsYXRlIGEgb25lLXNpZGVkIHNsb3BlLlxyXG5mdW5jdGlvbiBzbG9wZTIodGhhdCwgdCkge1xyXG4gIHZhciBoID0gdGhhdC5feDEgLSB0aGF0Ll94MDtcclxuICByZXR1cm4gaCA/ICgzICogKHRoYXQuX3kxIC0gdGhhdC5feTApIC8gaCAtIHQpIC8gMiA6IHQ7XHJcbn1cclxuXHJcbi8vIEFjY29yZGluZyB0byBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DdWJpY19IZXJtaXRlX3NwbGluZSNSZXByZXNlbnRhdGlvbnNcclxuLy8gXCJ5b3UgY2FuIGV4cHJlc3MgY3ViaWMgSGVybWl0ZSBpbnRlcnBvbGF0aW9uIGluIHRlcm1zIG9mIGN1YmljIELDqXppZXIgY3VydmVzXHJcbi8vIHdpdGggcmVzcGVjdCB0byB0aGUgZm91ciB2YWx1ZXMgcDAsIHAwICsgbTAgLyAzLCBwMSAtIG0xIC8gMywgcDFcIi5cclxuZnVuY3Rpb24gcG9pbnQkNSh0aGF0LCB0MCwgdDEpIHtcclxuICB2YXIgeDAgPSB0aGF0Ll94MCxcclxuICAgICAgeTAgPSB0aGF0Ll95MCxcclxuICAgICAgeDEgPSB0aGF0Ll94MSxcclxuICAgICAgeTEgPSB0aGF0Ll95MSxcclxuICAgICAgZHggPSAoeDEgLSB4MCkgLyAzO1xyXG4gIHRoYXQuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyh4MCArIGR4LCB5MCArIGR4ICogdDAsIHgxIC0gZHgsIHkxIC0gZHggKiB0MSwgeDEsIHkxKTtcclxufVxyXG5cclxuZnVuY3Rpb24gTW9ub3RvbmVYKGNvbnRleHQpIHtcclxuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcclxufVxyXG5cclxuTW9ub3RvbmVYLnByb3RvdHlwZSA9IHtcclxuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5fbGluZSA9IDA7XHJcbiAgfSxcclxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuX2xpbmUgPSBOYU47XHJcbiAgfSxcclxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9XHJcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxID1cclxuICAgIHRoaXMuX3QwID0gTmFOO1xyXG4gICAgdGhpcy5fcG9pbnQgPSAwO1xyXG4gIH0sXHJcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XHJcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XHJcbiAgICAgIGNhc2UgMjogdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDEsIHRoaXMuX3kxKTsgYnJlYWs7XHJcbiAgICAgIGNhc2UgMzogcG9pbnQkNSh0aGlzLCB0aGlzLl90MCwgc2xvcGUyKHRoaXMsIHRoaXMuX3QwKSk7IGJyZWFrO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDEpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xyXG4gICAgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xyXG4gIH0sXHJcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgIHZhciB0MSA9IE5hTjtcclxuXHJcbiAgICB4ID0gK3gsIHkgPSAreTtcclxuICAgIGlmICh4ID09PSB0aGlzLl94MSAmJiB5ID09PSB0aGlzLl95MSkgcmV0dXJuOyAvLyBJZ25vcmUgY29pbmNpZGVudCBwb2ludHMuXHJcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XHJcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4LCB5KTsgYnJlYWs7XHJcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyBicmVhaztcclxuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IHBvaW50JDUodGhpcywgc2xvcGUyKHRoaXMsIHQxID0gc2xvcGUzKHRoaXMsIHgsIHkpKSwgdDEpOyBicmVhaztcclxuICAgICAgZGVmYXVsdDogcG9pbnQkNSh0aGlzLCB0aGlzLl90MCwgdDEgPSBzbG9wZTModGhpcywgeCwgeSkpOyBicmVhaztcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHg7XHJcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHk7XHJcbiAgICB0aGlzLl90MCA9IHQxO1xyXG4gIH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIE1vbm90b25lWShjb250ZXh0KSB7XHJcbiAgdGhpcy5fY29udGV4dCA9IG5ldyBSZWZsZWN0Q29udGV4dChjb250ZXh0KTtcclxufVxyXG5cclxuKE1vbm90b25lWS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE1vbm90b25lWC5wcm90b3R5cGUpKS5wb2ludCA9IGZ1bmN0aW9uKHgsIHkpIHtcclxuICBNb25vdG9uZVgucHJvdG90eXBlLnBvaW50LmNhbGwodGhpcywgeSwgeCk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBSZWZsZWN0Q29udGV4dChjb250ZXh0KSB7XHJcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XHJcbn1cclxuXHJcblJlZmxlY3RDb250ZXh0LnByb3RvdHlwZSA9IHtcclxuICBtb3ZlVG86IGZ1bmN0aW9uKHgsIHkpIHsgdGhpcy5fY29udGV4dC5tb3ZlVG8oeSwgeCk7IH0sXHJcbiAgY2xvc2VQYXRoOiBmdW5jdGlvbigpIHsgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTsgfSxcclxuICBsaW5lVG86IGZ1bmN0aW9uKHgsIHkpIHsgdGhpcy5fY29udGV4dC5saW5lVG8oeSwgeCk7IH0sXHJcbiAgYmV6aWVyQ3VydmVUbzogZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIsIHgsIHkpIHsgdGhpcy5fY29udGV4dC5iZXppZXJDdXJ2ZVRvKHkxLCB4MSwgeTIsIHgyLCB5LCB4KTsgfVxyXG59O1xyXG5cclxuZnVuY3Rpb24gbW9ub3RvbmVYKGNvbnRleHQpIHtcclxuICByZXR1cm4gbmV3IE1vbm90b25lWChjb250ZXh0KTtcclxufVxyXG5cclxuZnVuY3Rpb24gbW9ub3RvbmVZKGNvbnRleHQpIHtcclxuICByZXR1cm4gbmV3IE1vbm90b25lWShjb250ZXh0KTtcclxufVxyXG5cclxuZnVuY3Rpb24gTmF0dXJhbChjb250ZXh0KSB7XHJcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XHJcbn1cclxuXHJcbk5hdHVyYWwucHJvdG90eXBlID0ge1xyXG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLl9saW5lID0gMDtcclxuICB9LFxyXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5fbGluZSA9IE5hTjtcclxuICB9LFxyXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLl94ID0gW107XHJcbiAgICB0aGlzLl95ID0gW107XHJcbiAgfSxcclxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcclxuICAgIHZhciB4ID0gdGhpcy5feCxcclxuICAgICAgICB5ID0gdGhpcy5feSxcclxuICAgICAgICBuID0geC5sZW5ndGg7XHJcblxyXG4gICAgaWYgKG4pIHtcclxuICAgICAgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHhbMF0sIHlbMF0pIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeFswXSwgeVswXSk7XHJcbiAgICAgIGlmIChuID09PSAyKSB7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oeFsxXSwgeVsxXSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyIHB4ID0gY29udHJvbFBvaW50cyh4KSxcclxuICAgICAgICAgICAgcHkgPSBjb250cm9sUG9pbnRzKHkpO1xyXG4gICAgICAgIGZvciAodmFyIGkwID0gMCwgaTEgPSAxOyBpMSA8IG47ICsraTAsICsraTEpIHtcclxuICAgICAgICAgIHRoaXMuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyhweFswXVtpMF0sIHB5WzBdW2kwXSwgcHhbMV1baTBdLCBweVsxXVtpMF0sIHhbaTFdLCB5W2kxXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgbiA9PT0gMSkpIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XHJcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XHJcbiAgICB0aGlzLl94ID0gdGhpcy5feSA9IG51bGw7XHJcbiAgfSxcclxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgdGhpcy5feC5wdXNoKCt4KTtcclxuICAgIHRoaXMuX3kucHVzaCgreSk7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gU2VlIGh0dHBzOi8vd3d3LnBhcnRpY2xlaW5jZWxsLmNvbS8yMDEyL2Jlemllci1zcGxpbmVzLyBmb3IgZGVyaXZhdGlvbi5cclxuZnVuY3Rpb24gY29udHJvbFBvaW50cyh4KSB7XHJcbiAgdmFyIGksXHJcbiAgICAgIG4gPSB4Lmxlbmd0aCAtIDEsXHJcbiAgICAgIG0sXHJcbiAgICAgIGEgPSBuZXcgQXJyYXkobiksXHJcbiAgICAgIGIgPSBuZXcgQXJyYXkobiksXHJcbiAgICAgIHIgPSBuZXcgQXJyYXkobik7XHJcbiAgYVswXSA9IDAsIGJbMF0gPSAyLCByWzBdID0geFswXSArIDIgKiB4WzFdO1xyXG4gIGZvciAoaSA9IDE7IGkgPCBuIC0gMTsgKytpKSBhW2ldID0gMSwgYltpXSA9IDQsIHJbaV0gPSA0ICogeFtpXSArIDIgKiB4W2kgKyAxXTtcclxuICBhW24gLSAxXSA9IDIsIGJbbiAtIDFdID0gNywgcltuIC0gMV0gPSA4ICogeFtuIC0gMV0gKyB4W25dO1xyXG4gIGZvciAoaSA9IDE7IGkgPCBuOyArK2kpIG0gPSBhW2ldIC8gYltpIC0gMV0sIGJbaV0gLT0gbSwgcltpXSAtPSBtICogcltpIC0gMV07XHJcbiAgYVtuIC0gMV0gPSByW24gLSAxXSAvIGJbbiAtIDFdO1xyXG4gIGZvciAoaSA9IG4gLSAyOyBpID49IDA7IC0taSkgYVtpXSA9IChyW2ldIC0gYVtpICsgMV0pIC8gYltpXTtcclxuICBiW24gLSAxXSA9ICh4W25dICsgYVtuIC0gMV0pIC8gMjtcclxuICBmb3IgKGkgPSAwOyBpIDwgbiAtIDE7ICsraSkgYltpXSA9IDIgKiB4W2kgKyAxXSAtIGFbaSArIDFdO1xyXG4gIHJldHVybiBbYSwgYl07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5hdHVyYWwoY29udGV4dCkge1xyXG4gIHJldHVybiBuZXcgTmF0dXJhbChjb250ZXh0KTtcclxufVxyXG5cclxuZnVuY3Rpb24gU3RlcChjb250ZXh0LCB0KSB7XHJcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XHJcbiAgdGhpcy5fdCA9IHQ7XHJcbn1cclxuXHJcblN0ZXAucHJvdG90eXBlID0ge1xyXG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLl9saW5lID0gMDtcclxuICB9LFxyXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5fbGluZSA9IE5hTjtcclxuICB9LFxyXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLl94ID0gdGhpcy5feSA9IE5hTjtcclxuICAgIHRoaXMuX3BvaW50ID0gMDtcclxuICB9LFxyXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYgKDAgPCB0aGlzLl90ICYmIHRoaXMuX3QgPCAxICYmIHRoaXMuX3BvaW50ID09PSAyKSB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94LCB0aGlzLl95KTtcclxuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAxKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcclxuICAgIGlmICh0aGlzLl9saW5lID49IDApIHRoaXMuX3QgPSAxIC0gdGhpcy5fdCwgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xyXG4gIH0sXHJcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgIHggPSAreCwgeSA9ICt5O1xyXG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xyXG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7IGJyZWFrO1xyXG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgLy8gcHJvY2VlZFxyXG4gICAgICBkZWZhdWx0OiB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3QgPD0gMCkge1xyXG4gICAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feCwgeSk7XHJcbiAgICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdmFyIHgxID0gdGhpcy5feCAqICgxIC0gdGhpcy5fdCkgKyB4ICogdGhpcy5fdDtcclxuICAgICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHgxLCB0aGlzLl95KTtcclxuICAgICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHgxLCB5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMuX3ggPSB4LCB0aGlzLl95ID0geTtcclxuICB9XHJcbn07XHJcblxyXG5mdW5jdGlvbiBzdGVwKGNvbnRleHQpIHtcclxuICByZXR1cm4gbmV3IFN0ZXAoY29udGV4dCwgMC41KTtcclxufVxyXG5cclxuZnVuY3Rpb24gc3RlcEJlZm9yZShjb250ZXh0KSB7XHJcbiAgcmV0dXJuIG5ldyBTdGVwKGNvbnRleHQsIDApO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzdGVwQWZ0ZXIoY29udGV4dCkge1xyXG4gIHJldHVybiBuZXcgU3RlcChjb250ZXh0LCAxKTtcclxufVxyXG5cclxuZnVuY3Rpb24gbm9uZSQxKHNlcmllcywgb3JkZXIpIHtcclxuICBpZiAoISgobiA9IHNlcmllcy5sZW5ndGgpID4gMSkpIHJldHVybjtcclxuICBmb3IgKHZhciBpID0gMSwgaiwgczAsIHMxID0gc2VyaWVzW29yZGVyWzBdXSwgbiwgbSA9IHMxLmxlbmd0aDsgaSA8IG47ICsraSkge1xyXG4gICAgczAgPSBzMSwgczEgPSBzZXJpZXNbb3JkZXJbaV1dO1xyXG4gICAgZm9yIChqID0gMDsgaiA8IG07ICsraikge1xyXG4gICAgICBzMVtqXVsxXSArPSBzMVtqXVswXSA9IGlzTmFOKHMwW2pdWzFdKSA/IHMwW2pdWzBdIDogczBbal1bMV07XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBub25lJDIoc2VyaWVzKSB7XHJcbiAgdmFyIG4gPSBzZXJpZXMubGVuZ3RoLCBvID0gbmV3IEFycmF5KG4pO1xyXG4gIHdoaWxlICgtLW4gPj0gMCkgb1tuXSA9IG47XHJcbiAgcmV0dXJuIG87XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN0YWNrVmFsdWUoZCwga2V5KSB7XHJcbiAgcmV0dXJuIGRba2V5XTtcclxufVxyXG5cclxuZnVuY3Rpb24gc3RhY2soKSB7XHJcbiAgdmFyIGtleXMgPSBjb25zdGFudCQxMShbXSksXHJcbiAgICAgIG9yZGVyID0gbm9uZSQyLFxyXG4gICAgICBvZmZzZXQgPSBub25lJDEsXHJcbiAgICAgIHZhbHVlID0gc3RhY2tWYWx1ZTtcclxuXHJcbiAgZnVuY3Rpb24gc3RhY2soZGF0YSkge1xyXG4gICAgdmFyIGt6ID0ga2V5cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxyXG4gICAgICAgIGksXHJcbiAgICAgICAgbSA9IGRhdGEubGVuZ3RoLFxyXG4gICAgICAgIG4gPSBrei5sZW5ndGgsXHJcbiAgICAgICAgc3ogPSBuZXcgQXJyYXkobiksXHJcbiAgICAgICAgb3o7XHJcblxyXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xyXG4gICAgICBmb3IgKHZhciBraSA9IGt6W2ldLCBzaSA9IHN6W2ldID0gbmV3IEFycmF5KG0pLCBqID0gMCwgc2lqOyBqIDwgbTsgKytqKSB7XHJcbiAgICAgICAgc2lbal0gPSBzaWogPSBbMCwgK3ZhbHVlKGRhdGFbal0sIGtpLCBqLCBkYXRhKV07XHJcbiAgICAgICAgc2lqLmRhdGEgPSBkYXRhW2pdO1xyXG4gICAgICB9XHJcbiAgICAgIHNpLmtleSA9IGtpO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAoaSA9IDAsIG96ID0gb3JkZXIoc3opOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgIHN6W296W2ldXS5pbmRleCA9IGk7XHJcbiAgICB9XHJcblxyXG4gICAgb2Zmc2V0KHN6LCBveik7XHJcbiAgICByZXR1cm4gc3o7XHJcbiAgfVxyXG5cclxuICBzdGFjay5rZXlzID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoa2V5cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQkMTEoc2xpY2UkNi5jYWxsKF8pKSwgc3RhY2spIDoga2V5cztcclxuICB9O1xyXG5cclxuICBzdGFjay52YWx1ZSA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHZhbHVlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCQxMSgrXyksIHN0YWNrKSA6IHZhbHVlO1xyXG4gIH07XHJcblxyXG4gIHN0YWNrLm9yZGVyID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAob3JkZXIgPSBfID09IG51bGwgPyBub25lJDIgOiB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50JDExKHNsaWNlJDYuY2FsbChfKSksIHN0YWNrKSA6IG9yZGVyO1xyXG4gIH07XHJcblxyXG4gIHN0YWNrLm9mZnNldCA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG9mZnNldCA9IF8gPT0gbnVsbCA/IG5vbmUkMSA6IF8sIHN0YWNrKSA6IG9mZnNldDtcclxuICB9O1xyXG5cclxuICByZXR1cm4gc3RhY2s7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGV4cGFuZChzZXJpZXMsIG9yZGVyKSB7XHJcbiAgaWYgKCEoKG4gPSBzZXJpZXMubGVuZ3RoKSA+IDApKSByZXR1cm47XHJcbiAgZm9yICh2YXIgaSwgbiwgaiA9IDAsIG0gPSBzZXJpZXNbMF0ubGVuZ3RoLCB5OyBqIDwgbTsgKytqKSB7XHJcbiAgICBmb3IgKHkgPSBpID0gMDsgaSA8IG47ICsraSkgeSArPSBzZXJpZXNbaV1bal1bMV0gfHwgMDtcclxuICAgIGlmICh5KSBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSBzZXJpZXNbaV1bal1bMV0gLz0geTtcclxuICB9XHJcbiAgbm9uZSQxKHNlcmllcywgb3JkZXIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkaXZlcmdpbmcoc2VyaWVzLCBvcmRlcikge1xyXG4gIGlmICghKChuID0gc2VyaWVzLmxlbmd0aCkgPiAxKSkgcmV0dXJuO1xyXG4gIGZvciAodmFyIGksIGogPSAwLCBkLCBkeSwgeXAsIHluLCBuLCBtID0gc2VyaWVzW29yZGVyWzBdXS5sZW5ndGg7IGogPCBtOyArK2opIHtcclxuICAgIGZvciAoeXAgPSB5biA9IDAsIGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgIGlmICgoZHkgPSAoZCA9IHNlcmllc1tvcmRlcltpXV1bal0pWzFdIC0gZFswXSkgPj0gMCkge1xyXG4gICAgICAgIGRbMF0gPSB5cCwgZFsxXSA9IHlwICs9IGR5O1xyXG4gICAgICB9IGVsc2UgaWYgKGR5IDwgMCkge1xyXG4gICAgICAgIGRbMV0gPSB5biwgZFswXSA9IHluICs9IGR5O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRbMF0gPSB5cDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gc2lsaG91ZXR0ZShzZXJpZXMsIG9yZGVyKSB7XHJcbiAgaWYgKCEoKG4gPSBzZXJpZXMubGVuZ3RoKSA+IDApKSByZXR1cm47XHJcbiAgZm9yICh2YXIgaiA9IDAsIHMwID0gc2VyaWVzW29yZGVyWzBdXSwgbiwgbSA9IHMwLmxlbmd0aDsgaiA8IG07ICsraikge1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIHkgPSAwOyBpIDwgbjsgKytpKSB5ICs9IHNlcmllc1tpXVtqXVsxXSB8fCAwO1xyXG4gICAgczBbal1bMV0gKz0gczBbal1bMF0gPSAteSAvIDI7XHJcbiAgfVxyXG4gIG5vbmUkMShzZXJpZXMsIG9yZGVyKTtcclxufVxyXG5cclxuZnVuY3Rpb24gd2lnZ2xlKHNlcmllcywgb3JkZXIpIHtcclxuICBpZiAoISgobiA9IHNlcmllcy5sZW5ndGgpID4gMCkgfHwgISgobSA9IChzMCA9IHNlcmllc1tvcmRlclswXV0pLmxlbmd0aCkgPiAwKSkgcmV0dXJuO1xyXG4gIGZvciAodmFyIHkgPSAwLCBqID0gMSwgczAsIG0sIG47IGogPCBtOyArK2opIHtcclxuICAgIGZvciAodmFyIGkgPSAwLCBzMSA9IDAsIHMyID0gMDsgaSA8IG47ICsraSkge1xyXG4gICAgICB2YXIgc2kgPSBzZXJpZXNbb3JkZXJbaV1dLFxyXG4gICAgICAgICAgc2lqMCA9IHNpW2pdWzFdIHx8IDAsXHJcbiAgICAgICAgICBzaWoxID0gc2lbaiAtIDFdWzFdIHx8IDAsXHJcbiAgICAgICAgICBzMyA9IChzaWowIC0gc2lqMSkgLyAyO1xyXG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IGk7ICsraykge1xyXG4gICAgICAgIHZhciBzayA9IHNlcmllc1tvcmRlcltrXV0sXHJcbiAgICAgICAgICAgIHNrajAgPSBza1tqXVsxXSB8fCAwLFxyXG4gICAgICAgICAgICBza2oxID0gc2tbaiAtIDFdWzFdIHx8IDA7XHJcbiAgICAgICAgczMgKz0gc2tqMCAtIHNrajE7XHJcbiAgICAgIH1cclxuICAgICAgczEgKz0gc2lqMCwgczIgKz0gczMgKiBzaWowO1xyXG4gICAgfVxyXG4gICAgczBbaiAtIDFdWzFdICs9IHMwW2ogLSAxXVswXSA9IHk7XHJcbiAgICBpZiAoczEpIHkgLT0gczIgLyBzMTtcclxuICB9XHJcbiAgczBbaiAtIDFdWzFdICs9IHMwW2ogLSAxXVswXSA9IHk7XHJcbiAgbm9uZSQxKHNlcmllcywgb3JkZXIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhc2NlbmRpbmckMyhzZXJpZXMpIHtcclxuICB2YXIgc3VtcyA9IHNlcmllcy5tYXAoc3VtJDIpO1xyXG4gIHJldHVybiBub25lJDIoc2VyaWVzKS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIHN1bXNbYV0gLSBzdW1zW2JdOyB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gc3VtJDIoc2VyaWVzKSB7XHJcbiAgdmFyIHMgPSAwLCBpID0gLTEsIG4gPSBzZXJpZXMubGVuZ3RoLCB2O1xyXG4gIHdoaWxlICgrK2kgPCBuKSBpZiAodiA9ICtzZXJpZXNbaV1bMV0pIHMgKz0gdjtcclxuICByZXR1cm4gcztcclxufVxyXG5cclxuZnVuY3Rpb24gZGVzY2VuZGluZyQyKHNlcmllcykge1xyXG4gIHJldHVybiBhc2NlbmRpbmckMyhzZXJpZXMpLnJldmVyc2UoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaW5zaWRlT3V0KHNlcmllcykge1xyXG4gIHZhciBuID0gc2VyaWVzLmxlbmd0aCxcclxuICAgICAgaSxcclxuICAgICAgaixcclxuICAgICAgc3VtcyA9IHNlcmllcy5tYXAoc3VtJDIpLFxyXG4gICAgICBvcmRlciA9IG5vbmUkMihzZXJpZXMpLnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gc3Vtc1tiXSAtIHN1bXNbYV07IH0pLFxyXG4gICAgICB0b3AgPSAwLFxyXG4gICAgICBib3R0b20gPSAwLFxyXG4gICAgICB0b3BzID0gW10sXHJcbiAgICAgIGJvdHRvbXMgPSBbXTtcclxuXHJcbiAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xyXG4gICAgaiA9IG9yZGVyW2ldO1xyXG4gICAgaWYgKHRvcCA8IGJvdHRvbSkge1xyXG4gICAgICB0b3AgKz0gc3Vtc1tqXTtcclxuICAgICAgdG9wcy5wdXNoKGopO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYm90dG9tICs9IHN1bXNbal07XHJcbiAgICAgIGJvdHRvbXMucHVzaChqKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBib3R0b21zLnJldmVyc2UoKS5jb25jYXQodG9wcyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJldmVyc2Uoc2VyaWVzKSB7XHJcbiAgcmV0dXJuIG5vbmUkMihzZXJpZXMpLnJldmVyc2UoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY29uc3RhbnQkMTIoeCkge1xyXG4gIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB4O1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHgkNChkKSB7XHJcbiAgcmV0dXJuIGRbMF07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHkkNChkKSB7XHJcbiAgcmV0dXJuIGRbMV07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIFJlZEJsYWNrVHJlZSgpIHtcclxuICB0aGlzLl8gPSBudWxsOyAvLyByb290IG5vZGVcclxufVxyXG5cclxuZnVuY3Rpb24gUmVkQmxhY2tOb2RlKG5vZGUpIHtcclxuICBub2RlLlUgPSAvLyBwYXJlbnQgbm9kZVxyXG4gIG5vZGUuQyA9IC8vIGNvbG9yIC0gdHJ1ZSBmb3IgcmVkLCBmYWxzZSBmb3IgYmxhY2tcclxuICBub2RlLkwgPSAvLyBsZWZ0IG5vZGVcclxuICBub2RlLlIgPSAvLyByaWdodCBub2RlXHJcbiAgbm9kZS5QID0gLy8gcHJldmlvdXMgbm9kZVxyXG4gIG5vZGUuTiA9IG51bGw7IC8vIG5leHQgbm9kZVxyXG59XHJcblxyXG5SZWRCbGFja1RyZWUucHJvdG90eXBlID0ge1xyXG4gIGNvbnN0cnVjdG9yOiBSZWRCbGFja1RyZWUsXHJcblxyXG4gIGluc2VydDogZnVuY3Rpb24oYWZ0ZXIsIG5vZGUpIHtcclxuICAgIHZhciBwYXJlbnQsIGdyYW5kcGEsIHVuY2xlO1xyXG5cclxuICAgIGlmIChhZnRlcikge1xyXG4gICAgICBub2RlLlAgPSBhZnRlcjtcclxuICAgICAgbm9kZS5OID0gYWZ0ZXIuTjtcclxuICAgICAgaWYgKGFmdGVyLk4pIGFmdGVyLk4uUCA9IG5vZGU7XHJcbiAgICAgIGFmdGVyLk4gPSBub2RlO1xyXG4gICAgICBpZiAoYWZ0ZXIuUikge1xyXG4gICAgICAgIGFmdGVyID0gYWZ0ZXIuUjtcclxuICAgICAgICB3aGlsZSAoYWZ0ZXIuTCkgYWZ0ZXIgPSBhZnRlci5MO1xyXG4gICAgICAgIGFmdGVyLkwgPSBub2RlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGFmdGVyLlIgPSBub2RlO1xyXG4gICAgICB9XHJcbiAgICAgIHBhcmVudCA9IGFmdGVyO1xyXG4gICAgfSBlbHNlIGlmICh0aGlzLl8pIHtcclxuICAgICAgYWZ0ZXIgPSBSZWRCbGFja0ZpcnN0KHRoaXMuXyk7XHJcbiAgICAgIG5vZGUuUCA9IG51bGw7XHJcbiAgICAgIG5vZGUuTiA9IGFmdGVyO1xyXG4gICAgICBhZnRlci5QID0gYWZ0ZXIuTCA9IG5vZGU7XHJcbiAgICAgIHBhcmVudCA9IGFmdGVyO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbm9kZS5QID0gbm9kZS5OID0gbnVsbDtcclxuICAgICAgdGhpcy5fID0gbm9kZTtcclxuICAgICAgcGFyZW50ID0gbnVsbDtcclxuICAgIH1cclxuICAgIG5vZGUuTCA9IG5vZGUuUiA9IG51bGw7XHJcbiAgICBub2RlLlUgPSBwYXJlbnQ7XHJcbiAgICBub2RlLkMgPSB0cnVlO1xyXG5cclxuICAgIGFmdGVyID0gbm9kZTtcclxuICAgIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50LkMpIHtcclxuICAgICAgZ3JhbmRwYSA9IHBhcmVudC5VO1xyXG4gICAgICBpZiAocGFyZW50ID09PSBncmFuZHBhLkwpIHtcclxuICAgICAgICB1bmNsZSA9IGdyYW5kcGEuUjtcclxuICAgICAgICBpZiAodW5jbGUgJiYgdW5jbGUuQykge1xyXG4gICAgICAgICAgcGFyZW50LkMgPSB1bmNsZS5DID0gZmFsc2U7XHJcbiAgICAgICAgICBncmFuZHBhLkMgPSB0cnVlO1xyXG4gICAgICAgICAgYWZ0ZXIgPSBncmFuZHBhO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpZiAoYWZ0ZXIgPT09IHBhcmVudC5SKSB7XHJcbiAgICAgICAgICAgIFJlZEJsYWNrUm90YXRlTGVmdCh0aGlzLCBwYXJlbnQpO1xyXG4gICAgICAgICAgICBhZnRlciA9IHBhcmVudDtcclxuICAgICAgICAgICAgcGFyZW50ID0gYWZ0ZXIuVTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHBhcmVudC5DID0gZmFsc2U7XHJcbiAgICAgICAgICBncmFuZHBhLkMgPSB0cnVlO1xyXG4gICAgICAgICAgUmVkQmxhY2tSb3RhdGVSaWdodCh0aGlzLCBncmFuZHBhKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdW5jbGUgPSBncmFuZHBhLkw7XHJcbiAgICAgICAgaWYgKHVuY2xlICYmIHVuY2xlLkMpIHtcclxuICAgICAgICAgIHBhcmVudC5DID0gdW5jbGUuQyA9IGZhbHNlO1xyXG4gICAgICAgICAgZ3JhbmRwYS5DID0gdHJ1ZTtcclxuICAgICAgICAgIGFmdGVyID0gZ3JhbmRwYTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaWYgKGFmdGVyID09PSBwYXJlbnQuTCkge1xyXG4gICAgICAgICAgICBSZWRCbGFja1JvdGF0ZVJpZ2h0KHRoaXMsIHBhcmVudCk7XHJcbiAgICAgICAgICAgIGFmdGVyID0gcGFyZW50O1xyXG4gICAgICAgICAgICBwYXJlbnQgPSBhZnRlci5VO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcGFyZW50LkMgPSBmYWxzZTtcclxuICAgICAgICAgIGdyYW5kcGEuQyA9IHRydWU7XHJcbiAgICAgICAgICBSZWRCbGFja1JvdGF0ZUxlZnQodGhpcywgZ3JhbmRwYSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHBhcmVudCA9IGFmdGVyLlU7XHJcbiAgICB9XHJcbiAgICB0aGlzLl8uQyA9IGZhbHNlO1xyXG4gIH0sXHJcblxyXG4gIHJlbW92ZTogZnVuY3Rpb24obm9kZSkge1xyXG4gICAgaWYgKG5vZGUuTikgbm9kZS5OLlAgPSBub2RlLlA7XHJcbiAgICBpZiAobm9kZS5QKSBub2RlLlAuTiA9IG5vZGUuTjtcclxuICAgIG5vZGUuTiA9IG5vZGUuUCA9IG51bGw7XHJcblxyXG4gICAgdmFyIHBhcmVudCA9IG5vZGUuVSxcclxuICAgICAgICBzaWJsaW5nLFxyXG4gICAgICAgIGxlZnQgPSBub2RlLkwsXHJcbiAgICAgICAgcmlnaHQgPSBub2RlLlIsXHJcbiAgICAgICAgbmV4dCxcclxuICAgICAgICByZWQ7XHJcblxyXG4gICAgaWYgKCFsZWZ0KSBuZXh0ID0gcmlnaHQ7XHJcbiAgICBlbHNlIGlmICghcmlnaHQpIG5leHQgPSBsZWZ0O1xyXG4gICAgZWxzZSBuZXh0ID0gUmVkQmxhY2tGaXJzdChyaWdodCk7XHJcblxyXG4gICAgaWYgKHBhcmVudCkge1xyXG4gICAgICBpZiAocGFyZW50LkwgPT09IG5vZGUpIHBhcmVudC5MID0gbmV4dDtcclxuICAgICAgZWxzZSBwYXJlbnQuUiA9IG5leHQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLl8gPSBuZXh0O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChsZWZ0ICYmIHJpZ2h0KSB7XHJcbiAgICAgIHJlZCA9IG5leHQuQztcclxuICAgICAgbmV4dC5DID0gbm9kZS5DO1xyXG4gICAgICBuZXh0LkwgPSBsZWZ0O1xyXG4gICAgICBsZWZ0LlUgPSBuZXh0O1xyXG4gICAgICBpZiAobmV4dCAhPT0gcmlnaHQpIHtcclxuICAgICAgICBwYXJlbnQgPSBuZXh0LlU7XHJcbiAgICAgICAgbmV4dC5VID0gbm9kZS5VO1xyXG4gICAgICAgIG5vZGUgPSBuZXh0LlI7XHJcbiAgICAgICAgcGFyZW50LkwgPSBub2RlO1xyXG4gICAgICAgIG5leHQuUiA9IHJpZ2h0O1xyXG4gICAgICAgIHJpZ2h0LlUgPSBuZXh0O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG5leHQuVSA9IHBhcmVudDtcclxuICAgICAgICBwYXJlbnQgPSBuZXh0O1xyXG4gICAgICAgIG5vZGUgPSBuZXh0LlI7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJlZCA9IG5vZGUuQztcclxuICAgICAgbm9kZSA9IG5leHQ7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG5vZGUpIG5vZGUuVSA9IHBhcmVudDtcclxuICAgIGlmIChyZWQpIHJldHVybjtcclxuICAgIGlmIChub2RlICYmIG5vZGUuQykgeyBub2RlLkMgPSBmYWxzZTsgcmV0dXJuOyB9XHJcblxyXG4gICAgZG8ge1xyXG4gICAgICBpZiAobm9kZSA9PT0gdGhpcy5fKSBicmVhaztcclxuICAgICAgaWYgKG5vZGUgPT09IHBhcmVudC5MKSB7XHJcbiAgICAgICAgc2libGluZyA9IHBhcmVudC5SO1xyXG4gICAgICAgIGlmIChzaWJsaW5nLkMpIHtcclxuICAgICAgICAgIHNpYmxpbmcuQyA9IGZhbHNlO1xyXG4gICAgICAgICAgcGFyZW50LkMgPSB0cnVlO1xyXG4gICAgICAgICAgUmVkQmxhY2tSb3RhdGVMZWZ0KHRoaXMsIHBhcmVudCk7XHJcbiAgICAgICAgICBzaWJsaW5nID0gcGFyZW50LlI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgoc2libGluZy5MICYmIHNpYmxpbmcuTC5DKVxyXG4gICAgICAgICAgICB8fCAoc2libGluZy5SICYmIHNpYmxpbmcuUi5DKSkge1xyXG4gICAgICAgICAgaWYgKCFzaWJsaW5nLlIgfHwgIXNpYmxpbmcuUi5DKSB7XHJcbiAgICAgICAgICAgIHNpYmxpbmcuTC5DID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHNpYmxpbmcuQyA9IHRydWU7XHJcbiAgICAgICAgICAgIFJlZEJsYWNrUm90YXRlUmlnaHQodGhpcywgc2libGluZyk7XHJcbiAgICAgICAgICAgIHNpYmxpbmcgPSBwYXJlbnQuUjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHNpYmxpbmcuQyA9IHBhcmVudC5DO1xyXG4gICAgICAgICAgcGFyZW50LkMgPSBzaWJsaW5nLlIuQyA9IGZhbHNlO1xyXG4gICAgICAgICAgUmVkQmxhY2tSb3RhdGVMZWZ0KHRoaXMsIHBhcmVudCk7XHJcbiAgICAgICAgICBub2RlID0gdGhpcy5fO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNpYmxpbmcgPSBwYXJlbnQuTDtcclxuICAgICAgICBpZiAoc2libGluZy5DKSB7XHJcbiAgICAgICAgICBzaWJsaW5nLkMgPSBmYWxzZTtcclxuICAgICAgICAgIHBhcmVudC5DID0gdHJ1ZTtcclxuICAgICAgICAgIFJlZEJsYWNrUm90YXRlUmlnaHQodGhpcywgcGFyZW50KTtcclxuICAgICAgICAgIHNpYmxpbmcgPSBwYXJlbnQuTDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKChzaWJsaW5nLkwgJiYgc2libGluZy5MLkMpXHJcbiAgICAgICAgICB8fCAoc2libGluZy5SICYmIHNpYmxpbmcuUi5DKSkge1xyXG4gICAgICAgICAgaWYgKCFzaWJsaW5nLkwgfHwgIXNpYmxpbmcuTC5DKSB7XHJcbiAgICAgICAgICAgIHNpYmxpbmcuUi5DID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHNpYmxpbmcuQyA9IHRydWU7XHJcbiAgICAgICAgICAgIFJlZEJsYWNrUm90YXRlTGVmdCh0aGlzLCBzaWJsaW5nKTtcclxuICAgICAgICAgICAgc2libGluZyA9IHBhcmVudC5MO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgc2libGluZy5DID0gcGFyZW50LkM7XHJcbiAgICAgICAgICBwYXJlbnQuQyA9IHNpYmxpbmcuTC5DID0gZmFsc2U7XHJcbiAgICAgICAgICBSZWRCbGFja1JvdGF0ZVJpZ2h0KHRoaXMsIHBhcmVudCk7XHJcbiAgICAgICAgICBub2RlID0gdGhpcy5fO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHNpYmxpbmcuQyA9IHRydWU7XHJcbiAgICAgIG5vZGUgPSBwYXJlbnQ7XHJcbiAgICAgIHBhcmVudCA9IHBhcmVudC5VO1xyXG4gICAgfSB3aGlsZSAoIW5vZGUuQyk7XHJcblxyXG4gICAgaWYgKG5vZGUpIG5vZGUuQyA9IGZhbHNlO1xyXG4gIH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIFJlZEJsYWNrUm90YXRlTGVmdCh0cmVlLCBub2RlKSB7XHJcbiAgdmFyIHAgPSBub2RlLFxyXG4gICAgICBxID0gbm9kZS5SLFxyXG4gICAgICBwYXJlbnQgPSBwLlU7XHJcblxyXG4gIGlmIChwYXJlbnQpIHtcclxuICAgIGlmIChwYXJlbnQuTCA9PT0gcCkgcGFyZW50LkwgPSBxO1xyXG4gICAgZWxzZSBwYXJlbnQuUiA9IHE7XHJcbiAgfSBlbHNlIHtcclxuICAgIHRyZWUuXyA9IHE7XHJcbiAgfVxyXG5cclxuICBxLlUgPSBwYXJlbnQ7XHJcbiAgcC5VID0gcTtcclxuICBwLlIgPSBxLkw7XHJcbiAgaWYgKHAuUikgcC5SLlUgPSBwO1xyXG4gIHEuTCA9IHA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIFJlZEJsYWNrUm90YXRlUmlnaHQodHJlZSwgbm9kZSkge1xyXG4gIHZhciBwID0gbm9kZSxcclxuICAgICAgcSA9IG5vZGUuTCxcclxuICAgICAgcGFyZW50ID0gcC5VO1xyXG5cclxuICBpZiAocGFyZW50KSB7XHJcbiAgICBpZiAocGFyZW50LkwgPT09IHApIHBhcmVudC5MID0gcTtcclxuICAgIGVsc2UgcGFyZW50LlIgPSBxO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0cmVlLl8gPSBxO1xyXG4gIH1cclxuXHJcbiAgcS5VID0gcGFyZW50O1xyXG4gIHAuVSA9IHE7XHJcbiAgcC5MID0gcS5SO1xyXG4gIGlmIChwLkwpIHAuTC5VID0gcDtcclxuICBxLlIgPSBwO1xyXG59XHJcblxyXG5mdW5jdGlvbiBSZWRCbGFja0ZpcnN0KG5vZGUpIHtcclxuICB3aGlsZSAobm9kZS5MKSBub2RlID0gbm9kZS5MO1xyXG4gIHJldHVybiBub2RlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVFZGdlKGxlZnQsIHJpZ2h0LCB2MCwgdjEpIHtcclxuICB2YXIgZWRnZSA9IFtudWxsLCBudWxsXSxcclxuICAgICAgaW5kZXggPSBlZGdlcy5wdXNoKGVkZ2UpIC0gMTtcclxuICBlZGdlLmxlZnQgPSBsZWZ0O1xyXG4gIGVkZ2UucmlnaHQgPSByaWdodDtcclxuICBpZiAodjApIHNldEVkZ2VFbmQoZWRnZSwgbGVmdCwgcmlnaHQsIHYwKTtcclxuICBpZiAodjEpIHNldEVkZ2VFbmQoZWRnZSwgcmlnaHQsIGxlZnQsIHYxKTtcclxuICBjZWxsc1tsZWZ0LmluZGV4XS5oYWxmZWRnZXMucHVzaChpbmRleCk7XHJcbiAgY2VsbHNbcmlnaHQuaW5kZXhdLmhhbGZlZGdlcy5wdXNoKGluZGV4KTtcclxuICByZXR1cm4gZWRnZTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlQm9yZGVyRWRnZShsZWZ0LCB2MCwgdjEpIHtcclxuICB2YXIgZWRnZSA9IFt2MCwgdjFdO1xyXG4gIGVkZ2UubGVmdCA9IGxlZnQ7XHJcbiAgcmV0dXJuIGVkZ2U7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldEVkZ2VFbmQoZWRnZSwgbGVmdCwgcmlnaHQsIHZlcnRleCkge1xyXG4gIGlmICghZWRnZVswXSAmJiAhZWRnZVsxXSkge1xyXG4gICAgZWRnZVswXSA9IHZlcnRleDtcclxuICAgIGVkZ2UubGVmdCA9IGxlZnQ7XHJcbiAgICBlZGdlLnJpZ2h0ID0gcmlnaHQ7XHJcbiAgfSBlbHNlIGlmIChlZGdlLmxlZnQgPT09IHJpZ2h0KSB7XHJcbiAgICBlZGdlWzFdID0gdmVydGV4O1xyXG4gIH0gZWxzZSB7XHJcbiAgICBlZGdlWzBdID0gdmVydGV4O1xyXG4gIH1cclxufVxyXG5cclxuLy8gTGlhbmfigJNCYXJza3kgbGluZSBjbGlwcGluZy5cclxuZnVuY3Rpb24gY2xpcEVkZ2UoZWRnZSwgeDAsIHkwLCB4MSwgeTEpIHtcclxuICB2YXIgYSA9IGVkZ2VbMF0sXHJcbiAgICAgIGIgPSBlZGdlWzFdLFxyXG4gICAgICBheCA9IGFbMF0sXHJcbiAgICAgIGF5ID0gYVsxXSxcclxuICAgICAgYnggPSBiWzBdLFxyXG4gICAgICBieSA9IGJbMV0sXHJcbiAgICAgIHQwID0gMCxcclxuICAgICAgdDEgPSAxLFxyXG4gICAgICBkeCA9IGJ4IC0gYXgsXHJcbiAgICAgIGR5ID0gYnkgLSBheSxcclxuICAgICAgcjtcclxuXHJcbiAgciA9IHgwIC0gYXg7XHJcbiAgaWYgKCFkeCAmJiByID4gMCkgcmV0dXJuO1xyXG4gIHIgLz0gZHg7XHJcbiAgaWYgKGR4IDwgMCkge1xyXG4gICAgaWYgKHIgPCB0MCkgcmV0dXJuO1xyXG4gICAgaWYgKHIgPCB0MSkgdDEgPSByO1xyXG4gIH0gZWxzZSBpZiAoZHggPiAwKSB7XHJcbiAgICBpZiAociA+IHQxKSByZXR1cm47XHJcbiAgICBpZiAociA+IHQwKSB0MCA9IHI7XHJcbiAgfVxyXG5cclxuICByID0geDEgLSBheDtcclxuICBpZiAoIWR4ICYmIHIgPCAwKSByZXR1cm47XHJcbiAgciAvPSBkeDtcclxuICBpZiAoZHggPCAwKSB7XHJcbiAgICBpZiAociA+IHQxKSByZXR1cm47XHJcbiAgICBpZiAociA+IHQwKSB0MCA9IHI7XHJcbiAgfSBlbHNlIGlmIChkeCA+IDApIHtcclxuICAgIGlmIChyIDwgdDApIHJldHVybjtcclxuICAgIGlmIChyIDwgdDEpIHQxID0gcjtcclxuICB9XHJcblxyXG4gIHIgPSB5MCAtIGF5O1xyXG4gIGlmICghZHkgJiYgciA+IDApIHJldHVybjtcclxuICByIC89IGR5O1xyXG4gIGlmIChkeSA8IDApIHtcclxuICAgIGlmIChyIDwgdDApIHJldHVybjtcclxuICAgIGlmIChyIDwgdDEpIHQxID0gcjtcclxuICB9IGVsc2UgaWYgKGR5ID4gMCkge1xyXG4gICAgaWYgKHIgPiB0MSkgcmV0dXJuO1xyXG4gICAgaWYgKHIgPiB0MCkgdDAgPSByO1xyXG4gIH1cclxuXHJcbiAgciA9IHkxIC0gYXk7XHJcbiAgaWYgKCFkeSAmJiByIDwgMCkgcmV0dXJuO1xyXG4gIHIgLz0gZHk7XHJcbiAgaWYgKGR5IDwgMCkge1xyXG4gICAgaWYgKHIgPiB0MSkgcmV0dXJuO1xyXG4gICAgaWYgKHIgPiB0MCkgdDAgPSByO1xyXG4gIH0gZWxzZSBpZiAoZHkgPiAwKSB7XHJcbiAgICBpZiAociA8IHQwKSByZXR1cm47XHJcbiAgICBpZiAociA8IHQxKSB0MSA9IHI7XHJcbiAgfVxyXG5cclxuICBpZiAoISh0MCA+IDApICYmICEodDEgPCAxKSkgcmV0dXJuIHRydWU7IC8vIFRPRE8gQmV0dGVyIGNoZWNrP1xyXG5cclxuICBpZiAodDAgPiAwKSBlZGdlWzBdID0gW2F4ICsgdDAgKiBkeCwgYXkgKyB0MCAqIGR5XTtcclxuICBpZiAodDEgPCAxKSBlZGdlWzFdID0gW2F4ICsgdDEgKiBkeCwgYXkgKyB0MSAqIGR5XTtcclxuICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gY29ubmVjdEVkZ2UoZWRnZSwgeDAsIHkwLCB4MSwgeTEpIHtcclxuICB2YXIgdjEgPSBlZGdlWzFdO1xyXG4gIGlmICh2MSkgcmV0dXJuIHRydWU7XHJcblxyXG4gIHZhciB2MCA9IGVkZ2VbMF0sXHJcbiAgICAgIGxlZnQgPSBlZGdlLmxlZnQsXHJcbiAgICAgIHJpZ2h0ID0gZWRnZS5yaWdodCxcclxuICAgICAgbHggPSBsZWZ0WzBdLFxyXG4gICAgICBseSA9IGxlZnRbMV0sXHJcbiAgICAgIHJ4ID0gcmlnaHRbMF0sXHJcbiAgICAgIHJ5ID0gcmlnaHRbMV0sXHJcbiAgICAgIGZ4ID0gKGx4ICsgcngpIC8gMixcclxuICAgICAgZnkgPSAobHkgKyByeSkgLyAyLFxyXG4gICAgICBmbSxcclxuICAgICAgZmI7XHJcblxyXG4gIGlmIChyeSA9PT0gbHkpIHtcclxuICAgIGlmIChmeCA8IHgwIHx8IGZ4ID49IHgxKSByZXR1cm47XHJcbiAgICBpZiAobHggPiByeCkge1xyXG4gICAgICBpZiAoIXYwKSB2MCA9IFtmeCwgeTBdO1xyXG4gICAgICBlbHNlIGlmICh2MFsxXSA+PSB5MSkgcmV0dXJuO1xyXG4gICAgICB2MSA9IFtmeCwgeTFdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKCF2MCkgdjAgPSBbZngsIHkxXTtcclxuICAgICAgZWxzZSBpZiAodjBbMV0gPCB5MCkgcmV0dXJuO1xyXG4gICAgICB2MSA9IFtmeCwgeTBdO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICBmbSA9IChseCAtIHJ4KSAvIChyeSAtIGx5KTtcclxuICAgIGZiID0gZnkgLSBmbSAqIGZ4O1xyXG4gICAgaWYgKGZtIDwgLTEgfHwgZm0gPiAxKSB7XHJcbiAgICAgIGlmIChseCA+IHJ4KSB7XHJcbiAgICAgICAgaWYgKCF2MCkgdjAgPSBbKHkwIC0gZmIpIC8gZm0sIHkwXTtcclxuICAgICAgICBlbHNlIGlmICh2MFsxXSA+PSB5MSkgcmV0dXJuO1xyXG4gICAgICAgIHYxID0gWyh5MSAtIGZiKSAvIGZtLCB5MV07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKCF2MCkgdjAgPSBbKHkxIC0gZmIpIC8gZm0sIHkxXTtcclxuICAgICAgICBlbHNlIGlmICh2MFsxXSA8IHkwKSByZXR1cm47XHJcbiAgICAgICAgdjEgPSBbKHkwIC0gZmIpIC8gZm0sIHkwXTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKGx5IDwgcnkpIHtcclxuICAgICAgICBpZiAoIXYwKSB2MCA9IFt4MCwgZm0gKiB4MCArIGZiXTtcclxuICAgICAgICBlbHNlIGlmICh2MFswXSA+PSB4MSkgcmV0dXJuO1xyXG4gICAgICAgIHYxID0gW3gxLCBmbSAqIHgxICsgZmJdO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmICghdjApIHYwID0gW3gxLCBmbSAqIHgxICsgZmJdO1xyXG4gICAgICAgIGVsc2UgaWYgKHYwWzBdIDwgeDApIHJldHVybjtcclxuICAgICAgICB2MSA9IFt4MCwgZm0gKiB4MCArIGZiXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZWRnZVswXSA9IHYwO1xyXG4gIGVkZ2VbMV0gPSB2MTtcclxuICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2xpcEVkZ2VzKHgwLCB5MCwgeDEsIHkxKSB7XHJcbiAgdmFyIGkgPSBlZGdlcy5sZW5ndGgsXHJcbiAgICAgIGVkZ2U7XHJcblxyXG4gIHdoaWxlIChpLS0pIHtcclxuICAgIGlmICghY29ubmVjdEVkZ2UoZWRnZSA9IGVkZ2VzW2ldLCB4MCwgeTAsIHgxLCB5MSlcclxuICAgICAgICB8fCAhY2xpcEVkZ2UoZWRnZSwgeDAsIHkwLCB4MSwgeTEpXHJcbiAgICAgICAgfHwgIShNYXRoLmFicyhlZGdlWzBdWzBdIC0gZWRnZVsxXVswXSkgPiBlcHNpbG9uJDRcclxuICAgICAgICAgICAgfHwgTWF0aC5hYnMoZWRnZVswXVsxXSAtIGVkZ2VbMV1bMV0pID4gZXBzaWxvbiQ0KSkge1xyXG4gICAgICBkZWxldGUgZWRnZXNbaV07XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVDZWxsKHNpdGUpIHtcclxuICByZXR1cm4gY2VsbHNbc2l0ZS5pbmRleF0gPSB7XHJcbiAgICBzaXRlOiBzaXRlLFxyXG4gICAgaGFsZmVkZ2VzOiBbXVxyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNlbGxIYWxmZWRnZUFuZ2xlKGNlbGwsIGVkZ2UpIHtcclxuICB2YXIgc2l0ZSA9IGNlbGwuc2l0ZSxcclxuICAgICAgdmEgPSBlZGdlLmxlZnQsXHJcbiAgICAgIHZiID0gZWRnZS5yaWdodDtcclxuICBpZiAoc2l0ZSA9PT0gdmIpIHZiID0gdmEsIHZhID0gc2l0ZTtcclxuICBpZiAodmIpIHJldHVybiBNYXRoLmF0YW4yKHZiWzFdIC0gdmFbMV0sIHZiWzBdIC0gdmFbMF0pO1xyXG4gIGlmIChzaXRlID09PSB2YSkgdmEgPSBlZGdlWzFdLCB2YiA9IGVkZ2VbMF07XHJcbiAgZWxzZSB2YSA9IGVkZ2VbMF0sIHZiID0gZWRnZVsxXTtcclxuICByZXR1cm4gTWF0aC5hdGFuMih2YVswXSAtIHZiWzBdLCB2YlsxXSAtIHZhWzFdKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2VsbEhhbGZlZGdlU3RhcnQoY2VsbCwgZWRnZSkge1xyXG4gIHJldHVybiBlZGdlWysoZWRnZS5sZWZ0ICE9PSBjZWxsLnNpdGUpXTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2VsbEhhbGZlZGdlRW5kKGNlbGwsIGVkZ2UpIHtcclxuICByZXR1cm4gZWRnZVsrKGVkZ2UubGVmdCA9PT0gY2VsbC5zaXRlKV07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNvcnRDZWxsSGFsZmVkZ2VzKCkge1xyXG4gIGZvciAodmFyIGkgPSAwLCBuID0gY2VsbHMubGVuZ3RoLCBjZWxsLCBoYWxmZWRnZXMsIGosIG07IGkgPCBuOyArK2kpIHtcclxuICAgIGlmICgoY2VsbCA9IGNlbGxzW2ldKSAmJiAobSA9IChoYWxmZWRnZXMgPSBjZWxsLmhhbGZlZGdlcykubGVuZ3RoKSkge1xyXG4gICAgICB2YXIgaW5kZXggPSBuZXcgQXJyYXkobSksXHJcbiAgICAgICAgICBhcnJheSA9IG5ldyBBcnJheShtKTtcclxuICAgICAgZm9yIChqID0gMDsgaiA8IG07ICsraikgaW5kZXhbal0gPSBqLCBhcnJheVtqXSA9IGNlbGxIYWxmZWRnZUFuZ2xlKGNlbGwsIGVkZ2VzW2hhbGZlZGdlc1tqXV0pO1xyXG4gICAgICBpbmRleC5zb3J0KGZ1bmN0aW9uKGksIGopIHsgcmV0dXJuIGFycmF5W2pdIC0gYXJyYXlbaV07IH0pO1xyXG4gICAgICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKSBhcnJheVtqXSA9IGhhbGZlZGdlc1tpbmRleFtqXV07XHJcbiAgICAgIGZvciAoaiA9IDA7IGogPCBtOyArK2opIGhhbGZlZGdlc1tqXSA9IGFycmF5W2pdO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gY2xpcENlbGxzKHgwLCB5MCwgeDEsIHkxKSB7XHJcbiAgdmFyIG5DZWxscyA9IGNlbGxzLmxlbmd0aCxcclxuICAgICAgaUNlbGwsXHJcbiAgICAgIGNlbGwsXHJcbiAgICAgIHNpdGUsXHJcbiAgICAgIGlIYWxmZWRnZSxcclxuICAgICAgaGFsZmVkZ2VzLFxyXG4gICAgICBuSGFsZmVkZ2VzLFxyXG4gICAgICBzdGFydCxcclxuICAgICAgc3RhcnRYLFxyXG4gICAgICBzdGFydFksXHJcbiAgICAgIGVuZCxcclxuICAgICAgZW5kWCxcclxuICAgICAgZW5kWSxcclxuICAgICAgY292ZXIgPSB0cnVlO1xyXG5cclxuICBmb3IgKGlDZWxsID0gMDsgaUNlbGwgPCBuQ2VsbHM7ICsraUNlbGwpIHtcclxuICAgIGlmIChjZWxsID0gY2VsbHNbaUNlbGxdKSB7XHJcbiAgICAgIHNpdGUgPSBjZWxsLnNpdGU7XHJcbiAgICAgIGhhbGZlZGdlcyA9IGNlbGwuaGFsZmVkZ2VzO1xyXG4gICAgICBpSGFsZmVkZ2UgPSBoYWxmZWRnZXMubGVuZ3RoO1xyXG5cclxuICAgICAgLy8gUmVtb3ZlIGFueSBkYW5nbGluZyBjbGlwcGVkIGVkZ2VzLlxyXG4gICAgICB3aGlsZSAoaUhhbGZlZGdlLS0pIHtcclxuICAgICAgICBpZiAoIWVkZ2VzW2hhbGZlZGdlc1tpSGFsZmVkZ2VdXSkge1xyXG4gICAgICAgICAgaGFsZmVkZ2VzLnNwbGljZShpSGFsZmVkZ2UsIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSW5zZXJ0IGFueSBib3JkZXIgZWRnZXMgYXMgbmVjZXNzYXJ5LlxyXG4gICAgICBpSGFsZmVkZ2UgPSAwLCBuSGFsZmVkZ2VzID0gaGFsZmVkZ2VzLmxlbmd0aDtcclxuICAgICAgd2hpbGUgKGlIYWxmZWRnZSA8IG5IYWxmZWRnZXMpIHtcclxuICAgICAgICBlbmQgPSBjZWxsSGFsZmVkZ2VFbmQoY2VsbCwgZWRnZXNbaGFsZmVkZ2VzW2lIYWxmZWRnZV1dKSwgZW5kWCA9IGVuZFswXSwgZW5kWSA9IGVuZFsxXTtcclxuICAgICAgICBzdGFydCA9IGNlbGxIYWxmZWRnZVN0YXJ0KGNlbGwsIGVkZ2VzW2hhbGZlZGdlc1srK2lIYWxmZWRnZSAlIG5IYWxmZWRnZXNdXSksIHN0YXJ0WCA9IHN0YXJ0WzBdLCBzdGFydFkgPSBzdGFydFsxXTtcclxuICAgICAgICBpZiAoTWF0aC5hYnMoZW5kWCAtIHN0YXJ0WCkgPiBlcHNpbG9uJDQgfHwgTWF0aC5hYnMoZW5kWSAtIHN0YXJ0WSkgPiBlcHNpbG9uJDQpIHtcclxuICAgICAgICAgIGhhbGZlZGdlcy5zcGxpY2UoaUhhbGZlZGdlLCAwLCBlZGdlcy5wdXNoKGNyZWF0ZUJvcmRlckVkZ2Uoc2l0ZSwgZW5kLFxyXG4gICAgICAgICAgICAgIE1hdGguYWJzKGVuZFggLSB4MCkgPCBlcHNpbG9uJDQgJiYgeTEgLSBlbmRZID4gZXBzaWxvbiQ0ID8gW3gwLCBNYXRoLmFicyhzdGFydFggLSB4MCkgPCBlcHNpbG9uJDQgPyBzdGFydFkgOiB5MV1cclxuICAgICAgICAgICAgICA6IE1hdGguYWJzKGVuZFkgLSB5MSkgPCBlcHNpbG9uJDQgJiYgeDEgLSBlbmRYID4gZXBzaWxvbiQ0ID8gW01hdGguYWJzKHN0YXJ0WSAtIHkxKSA8IGVwc2lsb24kNCA/IHN0YXJ0WCA6IHgxLCB5MV1cclxuICAgICAgICAgICAgICA6IE1hdGguYWJzKGVuZFggLSB4MSkgPCBlcHNpbG9uJDQgJiYgZW5kWSAtIHkwID4gZXBzaWxvbiQ0ID8gW3gxLCBNYXRoLmFicyhzdGFydFggLSB4MSkgPCBlcHNpbG9uJDQgPyBzdGFydFkgOiB5MF1cclxuICAgICAgICAgICAgICA6IE1hdGguYWJzKGVuZFkgLSB5MCkgPCBlcHNpbG9uJDQgJiYgZW5kWCAtIHgwID4gZXBzaWxvbiQ0ID8gW01hdGguYWJzKHN0YXJ0WSAtIHkwKSA8IGVwc2lsb24kNCA/IHN0YXJ0WCA6IHgwLCB5MF1cclxuICAgICAgICAgICAgICA6IG51bGwpKSAtIDEpO1xyXG4gICAgICAgICAgKytuSGFsZmVkZ2VzO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG5IYWxmZWRnZXMpIGNvdmVyID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBJZiB0aGVyZSB3ZXJlbuKAmXQgYW55IGVkZ2VzLCBoYXZlIHRoZSBjbG9zZXN0IHNpdGUgY292ZXIgdGhlIGV4dGVudC5cclxuICAvLyBJdCBkb2VzbuKAmXQgbWF0dGVyIHdoaWNoIGNvcm5lciBvZiB0aGUgZXh0ZW50IHdlIG1lYXN1cmUhXHJcbiAgaWYgKGNvdmVyKSB7XHJcbiAgICB2YXIgZHgsIGR5LCBkMiwgZGMgPSBJbmZpbml0eTtcclxuXHJcbiAgICBmb3IgKGlDZWxsID0gMCwgY292ZXIgPSBudWxsOyBpQ2VsbCA8IG5DZWxsczsgKytpQ2VsbCkge1xyXG4gICAgICBpZiAoY2VsbCA9IGNlbGxzW2lDZWxsXSkge1xyXG4gICAgICAgIHNpdGUgPSBjZWxsLnNpdGU7XHJcbiAgICAgICAgZHggPSBzaXRlWzBdIC0geDA7XHJcbiAgICAgICAgZHkgPSBzaXRlWzFdIC0geTA7XHJcbiAgICAgICAgZDIgPSBkeCAqIGR4ICsgZHkgKiBkeTtcclxuICAgICAgICBpZiAoZDIgPCBkYykgZGMgPSBkMiwgY292ZXIgPSBjZWxsO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNvdmVyKSB7XHJcbiAgICAgIHZhciB2MDAgPSBbeDAsIHkwXSwgdjAxID0gW3gwLCB5MV0sIHYxMSA9IFt4MSwgeTFdLCB2MTAgPSBbeDEsIHkwXTtcclxuICAgICAgY292ZXIuaGFsZmVkZ2VzLnB1c2goXHJcbiAgICAgICAgZWRnZXMucHVzaChjcmVhdGVCb3JkZXJFZGdlKHNpdGUgPSBjb3Zlci5zaXRlLCB2MDAsIHYwMSkpIC0gMSxcclxuICAgICAgICBlZGdlcy5wdXNoKGNyZWF0ZUJvcmRlckVkZ2Uoc2l0ZSwgdjAxLCB2MTEpKSAtIDEsXHJcbiAgICAgICAgZWRnZXMucHVzaChjcmVhdGVCb3JkZXJFZGdlKHNpdGUsIHYxMSwgdjEwKSkgLSAxLFxyXG4gICAgICAgIGVkZ2VzLnB1c2goY3JlYXRlQm9yZGVyRWRnZShzaXRlLCB2MTAsIHYwMCkpIC0gMVxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gTGFzdGx5IGRlbGV0ZSBhbnkgY2VsbHMgd2l0aCBubyBlZGdlczsgdGhlc2Ugd2VyZSBlbnRpcmVseSBjbGlwcGVkLlxyXG4gIGZvciAoaUNlbGwgPSAwOyBpQ2VsbCA8IG5DZWxsczsgKytpQ2VsbCkge1xyXG4gICAgaWYgKGNlbGwgPSBjZWxsc1tpQ2VsbF0pIHtcclxuICAgICAgaWYgKCFjZWxsLmhhbGZlZGdlcy5sZW5ndGgpIHtcclxuICAgICAgICBkZWxldGUgY2VsbHNbaUNlbGxdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG52YXIgY2lyY2xlUG9vbCA9IFtdO1xyXG5cclxudmFyIGZpcnN0Q2lyY2xlO1xyXG5cclxuZnVuY3Rpb24gQ2lyY2xlKCkge1xyXG4gIFJlZEJsYWNrTm9kZSh0aGlzKTtcclxuICB0aGlzLnggPVxyXG4gIHRoaXMueSA9XHJcbiAgdGhpcy5hcmMgPVxyXG4gIHRoaXMuc2l0ZSA9XHJcbiAgdGhpcy5jeSA9IG51bGw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGF0dGFjaENpcmNsZShhcmMpIHtcclxuICB2YXIgbEFyYyA9IGFyYy5QLFxyXG4gICAgICByQXJjID0gYXJjLk47XHJcblxyXG4gIGlmICghbEFyYyB8fCAhckFyYykgcmV0dXJuO1xyXG5cclxuICB2YXIgbFNpdGUgPSBsQXJjLnNpdGUsXHJcbiAgICAgIGNTaXRlID0gYXJjLnNpdGUsXHJcbiAgICAgIHJTaXRlID0gckFyYy5zaXRlO1xyXG5cclxuICBpZiAobFNpdGUgPT09IHJTaXRlKSByZXR1cm47XHJcblxyXG4gIHZhciBieCA9IGNTaXRlWzBdLFxyXG4gICAgICBieSA9IGNTaXRlWzFdLFxyXG4gICAgICBheCA9IGxTaXRlWzBdIC0gYngsXHJcbiAgICAgIGF5ID0gbFNpdGVbMV0gLSBieSxcclxuICAgICAgY3ggPSByU2l0ZVswXSAtIGJ4LFxyXG4gICAgICBjeSA9IHJTaXRlWzFdIC0gYnk7XHJcblxyXG4gIHZhciBkID0gMiAqIChheCAqIGN5IC0gYXkgKiBjeCk7XHJcbiAgaWYgKGQgPj0gLWVwc2lsb24yJDIpIHJldHVybjtcclxuXHJcbiAgdmFyIGhhID0gYXggKiBheCArIGF5ICogYXksXHJcbiAgICAgIGhjID0gY3ggKiBjeCArIGN5ICogY3ksXHJcbiAgICAgIHggPSAoY3kgKiBoYSAtIGF5ICogaGMpIC8gZCxcclxuICAgICAgeSA9IChheCAqIGhjIC0gY3ggKiBoYSkgLyBkO1xyXG5cclxuICB2YXIgY2lyY2xlID0gY2lyY2xlUG9vbC5wb3AoKSB8fCBuZXcgQ2lyY2xlO1xyXG4gIGNpcmNsZS5hcmMgPSBhcmM7XHJcbiAgY2lyY2xlLnNpdGUgPSBjU2l0ZTtcclxuICBjaXJjbGUueCA9IHggKyBieDtcclxuICBjaXJjbGUueSA9IChjaXJjbGUuY3kgPSB5ICsgYnkpICsgTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpOyAvLyB5IGJvdHRvbVxyXG5cclxuICBhcmMuY2lyY2xlID0gY2lyY2xlO1xyXG5cclxuICB2YXIgYmVmb3JlID0gbnVsbCxcclxuICAgICAgbm9kZSA9IGNpcmNsZXMuXztcclxuXHJcbiAgd2hpbGUgKG5vZGUpIHtcclxuICAgIGlmIChjaXJjbGUueSA8IG5vZGUueSB8fCAoY2lyY2xlLnkgPT09IG5vZGUueSAmJiBjaXJjbGUueCA8PSBub2RlLngpKSB7XHJcbiAgICAgIGlmIChub2RlLkwpIG5vZGUgPSBub2RlLkw7XHJcbiAgICAgIGVsc2UgeyBiZWZvcmUgPSBub2RlLlA7IGJyZWFrOyB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAobm9kZS5SKSBub2RlID0gbm9kZS5SO1xyXG4gICAgICBlbHNlIHsgYmVmb3JlID0gbm9kZTsgYnJlYWs7IH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNpcmNsZXMuaW5zZXJ0KGJlZm9yZSwgY2lyY2xlKTtcclxuICBpZiAoIWJlZm9yZSkgZmlyc3RDaXJjbGUgPSBjaXJjbGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRldGFjaENpcmNsZShhcmMpIHtcclxuICB2YXIgY2lyY2xlID0gYXJjLmNpcmNsZTtcclxuICBpZiAoY2lyY2xlKSB7XHJcbiAgICBpZiAoIWNpcmNsZS5QKSBmaXJzdENpcmNsZSA9IGNpcmNsZS5OO1xyXG4gICAgY2lyY2xlcy5yZW1vdmUoY2lyY2xlKTtcclxuICAgIGNpcmNsZVBvb2wucHVzaChjaXJjbGUpO1xyXG4gICAgUmVkQmxhY2tOb2RlKGNpcmNsZSk7XHJcbiAgICBhcmMuY2lyY2xlID0gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbnZhciBiZWFjaFBvb2wgPSBbXTtcclxuXHJcbmZ1bmN0aW9uIEJlYWNoKCkge1xyXG4gIFJlZEJsYWNrTm9kZSh0aGlzKTtcclxuICB0aGlzLmVkZ2UgPVxyXG4gIHRoaXMuc2l0ZSA9XHJcbiAgdGhpcy5jaXJjbGUgPSBudWxsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVCZWFjaChzaXRlKSB7XHJcbiAgdmFyIGJlYWNoID0gYmVhY2hQb29sLnBvcCgpIHx8IG5ldyBCZWFjaDtcclxuICBiZWFjaC5zaXRlID0gc2l0ZTtcclxuICByZXR1cm4gYmVhY2g7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRldGFjaEJlYWNoKGJlYWNoKSB7XHJcbiAgZGV0YWNoQ2lyY2xlKGJlYWNoKTtcclxuICBiZWFjaGVzLnJlbW92ZShiZWFjaCk7XHJcbiAgYmVhY2hQb29sLnB1c2goYmVhY2gpO1xyXG4gIFJlZEJsYWNrTm9kZShiZWFjaCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbW92ZUJlYWNoKGJlYWNoKSB7XHJcbiAgdmFyIGNpcmNsZSA9IGJlYWNoLmNpcmNsZSxcclxuICAgICAgeCA9IGNpcmNsZS54LFxyXG4gICAgICB5ID0gY2lyY2xlLmN5LFxyXG4gICAgICB2ZXJ0ZXggPSBbeCwgeV0sXHJcbiAgICAgIHByZXZpb3VzID0gYmVhY2guUCxcclxuICAgICAgbmV4dCA9IGJlYWNoLk4sXHJcbiAgICAgIGRpc2FwcGVhcmluZyA9IFtiZWFjaF07XHJcblxyXG4gIGRldGFjaEJlYWNoKGJlYWNoKTtcclxuXHJcbiAgdmFyIGxBcmMgPSBwcmV2aW91cztcclxuICB3aGlsZSAobEFyYy5jaXJjbGVcclxuICAgICAgJiYgTWF0aC5hYnMoeCAtIGxBcmMuY2lyY2xlLngpIDwgZXBzaWxvbiQ0XHJcbiAgICAgICYmIE1hdGguYWJzKHkgLSBsQXJjLmNpcmNsZS5jeSkgPCBlcHNpbG9uJDQpIHtcclxuICAgIHByZXZpb3VzID0gbEFyYy5QO1xyXG4gICAgZGlzYXBwZWFyaW5nLnVuc2hpZnQobEFyYyk7XHJcbiAgICBkZXRhY2hCZWFjaChsQXJjKTtcclxuICAgIGxBcmMgPSBwcmV2aW91cztcclxuICB9XHJcblxyXG4gIGRpc2FwcGVhcmluZy51bnNoaWZ0KGxBcmMpO1xyXG4gIGRldGFjaENpcmNsZShsQXJjKTtcclxuXHJcbiAgdmFyIHJBcmMgPSBuZXh0O1xyXG4gIHdoaWxlIChyQXJjLmNpcmNsZVxyXG4gICAgICAmJiBNYXRoLmFicyh4IC0gckFyYy5jaXJjbGUueCkgPCBlcHNpbG9uJDRcclxuICAgICAgJiYgTWF0aC5hYnMoeSAtIHJBcmMuY2lyY2xlLmN5KSA8IGVwc2lsb24kNCkge1xyXG4gICAgbmV4dCA9IHJBcmMuTjtcclxuICAgIGRpc2FwcGVhcmluZy5wdXNoKHJBcmMpO1xyXG4gICAgZGV0YWNoQmVhY2gockFyYyk7XHJcbiAgICByQXJjID0gbmV4dDtcclxuICB9XHJcblxyXG4gIGRpc2FwcGVhcmluZy5wdXNoKHJBcmMpO1xyXG4gIGRldGFjaENpcmNsZShyQXJjKTtcclxuXHJcbiAgdmFyIG5BcmNzID0gZGlzYXBwZWFyaW5nLmxlbmd0aCxcclxuICAgICAgaUFyYztcclxuICBmb3IgKGlBcmMgPSAxOyBpQXJjIDwgbkFyY3M7ICsraUFyYykge1xyXG4gICAgckFyYyA9IGRpc2FwcGVhcmluZ1tpQXJjXTtcclxuICAgIGxBcmMgPSBkaXNhcHBlYXJpbmdbaUFyYyAtIDFdO1xyXG4gICAgc2V0RWRnZUVuZChyQXJjLmVkZ2UsIGxBcmMuc2l0ZSwgckFyYy5zaXRlLCB2ZXJ0ZXgpO1xyXG4gIH1cclxuXHJcbiAgbEFyYyA9IGRpc2FwcGVhcmluZ1swXTtcclxuICByQXJjID0gZGlzYXBwZWFyaW5nW25BcmNzIC0gMV07XHJcbiAgckFyYy5lZGdlID0gY3JlYXRlRWRnZShsQXJjLnNpdGUsIHJBcmMuc2l0ZSwgbnVsbCwgdmVydGV4KTtcclxuXHJcbiAgYXR0YWNoQ2lyY2xlKGxBcmMpO1xyXG4gIGF0dGFjaENpcmNsZShyQXJjKTtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkQmVhY2goc2l0ZSkge1xyXG4gIHZhciB4ID0gc2l0ZVswXSxcclxuICAgICAgZGlyZWN0cml4ID0gc2l0ZVsxXSxcclxuICAgICAgbEFyYyxcclxuICAgICAgckFyYyxcclxuICAgICAgZHhsLFxyXG4gICAgICBkeHIsXHJcbiAgICAgIG5vZGUgPSBiZWFjaGVzLl87XHJcblxyXG4gIHdoaWxlIChub2RlKSB7XHJcbiAgICBkeGwgPSBsZWZ0QnJlYWtQb2ludChub2RlLCBkaXJlY3RyaXgpIC0geDtcclxuICAgIGlmIChkeGwgPiBlcHNpbG9uJDQpIG5vZGUgPSBub2RlLkw7IGVsc2Uge1xyXG4gICAgICBkeHIgPSB4IC0gcmlnaHRCcmVha1BvaW50KG5vZGUsIGRpcmVjdHJpeCk7XHJcbiAgICAgIGlmIChkeHIgPiBlcHNpbG9uJDQpIHtcclxuICAgICAgICBpZiAoIW5vZGUuUikge1xyXG4gICAgICAgICAgbEFyYyA9IG5vZGU7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgbm9kZSA9IG5vZGUuUjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoZHhsID4gLWVwc2lsb24kNCkge1xyXG4gICAgICAgICAgbEFyYyA9IG5vZGUuUDtcclxuICAgICAgICAgIHJBcmMgPSBub2RlO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZHhyID4gLWVwc2lsb24kNCkge1xyXG4gICAgICAgICAgbEFyYyA9IG5vZGU7XHJcbiAgICAgICAgICByQXJjID0gbm9kZS5OO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBsQXJjID0gckFyYyA9IG5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjcmVhdGVDZWxsKHNpdGUpO1xyXG4gIHZhciBuZXdBcmMgPSBjcmVhdGVCZWFjaChzaXRlKTtcclxuICBiZWFjaGVzLmluc2VydChsQXJjLCBuZXdBcmMpO1xyXG5cclxuICBpZiAoIWxBcmMgJiYgIXJBcmMpIHJldHVybjtcclxuXHJcbiAgaWYgKGxBcmMgPT09IHJBcmMpIHtcclxuICAgIGRldGFjaENpcmNsZShsQXJjKTtcclxuICAgIHJBcmMgPSBjcmVhdGVCZWFjaChsQXJjLnNpdGUpO1xyXG4gICAgYmVhY2hlcy5pbnNlcnQobmV3QXJjLCByQXJjKTtcclxuICAgIG5ld0FyYy5lZGdlID0gckFyYy5lZGdlID0gY3JlYXRlRWRnZShsQXJjLnNpdGUsIG5ld0FyYy5zaXRlKTtcclxuICAgIGF0dGFjaENpcmNsZShsQXJjKTtcclxuICAgIGF0dGFjaENpcmNsZShyQXJjKTtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIGlmICghckFyYykgeyAvLyAmJiBsQXJjXHJcbiAgICBuZXdBcmMuZWRnZSA9IGNyZWF0ZUVkZ2UobEFyYy5zaXRlLCBuZXdBcmMuc2l0ZSk7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICAvLyBlbHNlIGxBcmMgIT09IHJBcmNcclxuICBkZXRhY2hDaXJjbGUobEFyYyk7XHJcbiAgZGV0YWNoQ2lyY2xlKHJBcmMpO1xyXG5cclxuICB2YXIgbFNpdGUgPSBsQXJjLnNpdGUsXHJcbiAgICAgIGF4ID0gbFNpdGVbMF0sXHJcbiAgICAgIGF5ID0gbFNpdGVbMV0sXHJcbiAgICAgIGJ4ID0gc2l0ZVswXSAtIGF4LFxyXG4gICAgICBieSA9IHNpdGVbMV0gLSBheSxcclxuICAgICAgclNpdGUgPSByQXJjLnNpdGUsXHJcbiAgICAgIGN4ID0gclNpdGVbMF0gLSBheCxcclxuICAgICAgY3kgPSByU2l0ZVsxXSAtIGF5LFxyXG4gICAgICBkID0gMiAqIChieCAqIGN5IC0gYnkgKiBjeCksXHJcbiAgICAgIGhiID0gYnggKiBieCArIGJ5ICogYnksXHJcbiAgICAgIGhjID0gY3ggKiBjeCArIGN5ICogY3ksXHJcbiAgICAgIHZlcnRleCA9IFsoY3kgKiBoYiAtIGJ5ICogaGMpIC8gZCArIGF4LCAoYnggKiBoYyAtIGN4ICogaGIpIC8gZCArIGF5XTtcclxuXHJcbiAgc2V0RWRnZUVuZChyQXJjLmVkZ2UsIGxTaXRlLCByU2l0ZSwgdmVydGV4KTtcclxuICBuZXdBcmMuZWRnZSA9IGNyZWF0ZUVkZ2UobFNpdGUsIHNpdGUsIG51bGwsIHZlcnRleCk7XHJcbiAgckFyYy5lZGdlID0gY3JlYXRlRWRnZShzaXRlLCByU2l0ZSwgbnVsbCwgdmVydGV4KTtcclxuICBhdHRhY2hDaXJjbGUobEFyYyk7XHJcbiAgYXR0YWNoQ2lyY2xlKHJBcmMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBsZWZ0QnJlYWtQb2ludChhcmMsIGRpcmVjdHJpeCkge1xyXG4gIHZhciBzaXRlID0gYXJjLnNpdGUsXHJcbiAgICAgIHJmb2N4ID0gc2l0ZVswXSxcclxuICAgICAgcmZvY3kgPSBzaXRlWzFdLFxyXG4gICAgICBwYnkyID0gcmZvY3kgLSBkaXJlY3RyaXg7XHJcblxyXG4gIGlmICghcGJ5MikgcmV0dXJuIHJmb2N4O1xyXG5cclxuICB2YXIgbEFyYyA9IGFyYy5QO1xyXG4gIGlmICghbEFyYykgcmV0dXJuIC1JbmZpbml0eTtcclxuXHJcbiAgc2l0ZSA9IGxBcmMuc2l0ZTtcclxuICB2YXIgbGZvY3ggPSBzaXRlWzBdLFxyXG4gICAgICBsZm9jeSA9IHNpdGVbMV0sXHJcbiAgICAgIHBsYnkyID0gbGZvY3kgLSBkaXJlY3RyaXg7XHJcblxyXG4gIGlmICghcGxieTIpIHJldHVybiBsZm9jeDtcclxuXHJcbiAgdmFyIGhsID0gbGZvY3ggLSByZm9jeCxcclxuICAgICAgYWJ5MiA9IDEgLyBwYnkyIC0gMSAvIHBsYnkyLFxyXG4gICAgICBiID0gaGwgLyBwbGJ5MjtcclxuXHJcbiAgaWYgKGFieTIpIHJldHVybiAoLWIgKyBNYXRoLnNxcnQoYiAqIGIgLSAyICogYWJ5MiAqIChobCAqIGhsIC8gKC0yICogcGxieTIpIC0gbGZvY3kgKyBwbGJ5MiAvIDIgKyByZm9jeSAtIHBieTIgLyAyKSkpIC8gYWJ5MiArIHJmb2N4O1xyXG5cclxuICByZXR1cm4gKHJmb2N4ICsgbGZvY3gpIC8gMjtcclxufVxyXG5cclxuZnVuY3Rpb24gcmlnaHRCcmVha1BvaW50KGFyYywgZGlyZWN0cml4KSB7XHJcbiAgdmFyIHJBcmMgPSBhcmMuTjtcclxuICBpZiAockFyYykgcmV0dXJuIGxlZnRCcmVha1BvaW50KHJBcmMsIGRpcmVjdHJpeCk7XHJcbiAgdmFyIHNpdGUgPSBhcmMuc2l0ZTtcclxuICByZXR1cm4gc2l0ZVsxXSA9PT0gZGlyZWN0cml4ID8gc2l0ZVswXSA6IEluZmluaXR5O1xyXG59XHJcblxyXG52YXIgZXBzaWxvbiQ0ID0gMWUtNjtcclxudmFyIGVwc2lsb24yJDIgPSAxZS0xMjtcclxudmFyIGJlYWNoZXM7XHJcbnZhciBjZWxscztcclxudmFyIGNpcmNsZXM7XHJcbnZhciBlZGdlcztcclxuXHJcbmZ1bmN0aW9uIHRyaWFuZ2xlQXJlYShhLCBiLCBjKSB7XHJcbiAgcmV0dXJuIChhWzBdIC0gY1swXSkgKiAoYlsxXSAtIGFbMV0pIC0gKGFbMF0gLSBiWzBdKSAqIChjWzFdIC0gYVsxXSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxleGljb2dyYXBoaWMoYSwgYikge1xyXG4gIHJldHVybiBiWzFdIC0gYVsxXVxyXG4gICAgICB8fCBiWzBdIC0gYVswXTtcclxufVxyXG5cclxuZnVuY3Rpb24gRGlhZ3JhbShzaXRlcywgZXh0ZW50KSB7XHJcbiAgdmFyIHNpdGUgPSBzaXRlcy5zb3J0KGxleGljb2dyYXBoaWMpLnBvcCgpLFxyXG4gICAgICB4LFxyXG4gICAgICB5LFxyXG4gICAgICBjaXJjbGU7XHJcblxyXG4gIGVkZ2VzID0gW107XHJcbiAgY2VsbHMgPSBuZXcgQXJyYXkoc2l0ZXMubGVuZ3RoKTtcclxuICBiZWFjaGVzID0gbmV3IFJlZEJsYWNrVHJlZTtcclxuICBjaXJjbGVzID0gbmV3IFJlZEJsYWNrVHJlZTtcclxuXHJcbiAgd2hpbGUgKHRydWUpIHtcclxuICAgIGNpcmNsZSA9IGZpcnN0Q2lyY2xlO1xyXG4gICAgaWYgKHNpdGUgJiYgKCFjaXJjbGUgfHwgc2l0ZVsxXSA8IGNpcmNsZS55IHx8IChzaXRlWzFdID09PSBjaXJjbGUueSAmJiBzaXRlWzBdIDwgY2lyY2xlLngpKSkge1xyXG4gICAgICBpZiAoc2l0ZVswXSAhPT0geCB8fCBzaXRlWzFdICE9PSB5KSB7XHJcbiAgICAgICAgYWRkQmVhY2goc2l0ZSk7XHJcbiAgICAgICAgeCA9IHNpdGVbMF0sIHkgPSBzaXRlWzFdO1xyXG4gICAgICB9XHJcbiAgICAgIHNpdGUgPSBzaXRlcy5wb3AoKTtcclxuICAgIH0gZWxzZSBpZiAoY2lyY2xlKSB7XHJcbiAgICAgIHJlbW92ZUJlYWNoKGNpcmNsZS5hcmMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzb3J0Q2VsbEhhbGZlZGdlcygpO1xyXG5cclxuICBpZiAoZXh0ZW50KSB7XHJcbiAgICB2YXIgeDAgPSArZXh0ZW50WzBdWzBdLFxyXG4gICAgICAgIHkwID0gK2V4dGVudFswXVsxXSxcclxuICAgICAgICB4MSA9ICtleHRlbnRbMV1bMF0sXHJcbiAgICAgICAgeTEgPSArZXh0ZW50WzFdWzFdO1xyXG4gICAgY2xpcEVkZ2VzKHgwLCB5MCwgeDEsIHkxKTtcclxuICAgIGNsaXBDZWxscyh4MCwgeTAsIHgxLCB5MSk7XHJcbiAgfVxyXG5cclxuICB0aGlzLmVkZ2VzID0gZWRnZXM7XHJcbiAgdGhpcy5jZWxscyA9IGNlbGxzO1xyXG5cclxuICBiZWFjaGVzID1cclxuICBjaXJjbGVzID1cclxuICBlZGdlcyA9XHJcbiAgY2VsbHMgPSBudWxsO1xyXG59XHJcblxyXG5EaWFncmFtLnByb3RvdHlwZSA9IHtcclxuICBjb25zdHJ1Y3RvcjogRGlhZ3JhbSxcclxuXHJcbiAgcG9seWdvbnM6IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGVkZ2VzID0gdGhpcy5lZGdlcztcclxuXHJcbiAgICByZXR1cm4gdGhpcy5jZWxscy5tYXAoZnVuY3Rpb24oY2VsbCkge1xyXG4gICAgICB2YXIgcG9seWdvbiA9IGNlbGwuaGFsZmVkZ2VzLm1hcChmdW5jdGlvbihpKSB7IHJldHVybiBjZWxsSGFsZmVkZ2VTdGFydChjZWxsLCBlZGdlc1tpXSk7IH0pO1xyXG4gICAgICBwb2x5Z29uLmRhdGEgPSBjZWxsLnNpdGUuZGF0YTtcclxuICAgICAgcmV0dXJuIHBvbHlnb247XHJcbiAgICB9KTtcclxuICB9LFxyXG5cclxuICB0cmlhbmdsZXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHRyaWFuZ2xlcyA9IFtdLFxyXG4gICAgICAgIGVkZ2VzID0gdGhpcy5lZGdlcztcclxuXHJcbiAgICB0aGlzLmNlbGxzLmZvckVhY2goZnVuY3Rpb24oY2VsbCwgaSkge1xyXG4gICAgICBpZiAoIShtID0gKGhhbGZlZGdlcyA9IGNlbGwuaGFsZmVkZ2VzKS5sZW5ndGgpKSByZXR1cm47XHJcbiAgICAgIHZhciBzaXRlID0gY2VsbC5zaXRlLFxyXG4gICAgICAgICAgaGFsZmVkZ2VzLFxyXG4gICAgICAgICAgaiA9IC0xLFxyXG4gICAgICAgICAgbSxcclxuICAgICAgICAgIHMwLFxyXG4gICAgICAgICAgZTEgPSBlZGdlc1toYWxmZWRnZXNbbSAtIDFdXSxcclxuICAgICAgICAgIHMxID0gZTEubGVmdCA9PT0gc2l0ZSA/IGUxLnJpZ2h0IDogZTEubGVmdDtcclxuXHJcbiAgICAgIHdoaWxlICgrK2ogPCBtKSB7XHJcbiAgICAgICAgczAgPSBzMTtcclxuICAgICAgICBlMSA9IGVkZ2VzW2hhbGZlZGdlc1tqXV07XHJcbiAgICAgICAgczEgPSBlMS5sZWZ0ID09PSBzaXRlID8gZTEucmlnaHQgOiBlMS5sZWZ0O1xyXG4gICAgICAgIGlmIChzMCAmJiBzMSAmJiBpIDwgczAuaW5kZXggJiYgaSA8IHMxLmluZGV4ICYmIHRyaWFuZ2xlQXJlYShzaXRlLCBzMCwgczEpIDwgMCkge1xyXG4gICAgICAgICAgdHJpYW5nbGVzLnB1c2goW3NpdGUuZGF0YSwgczAuZGF0YSwgczEuZGF0YV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHRyaWFuZ2xlcztcclxuICB9LFxyXG5cclxuICBsaW5rczogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5lZGdlcy5maWx0ZXIoZnVuY3Rpb24oZWRnZSkge1xyXG4gICAgICByZXR1cm4gZWRnZS5yaWdodDtcclxuICAgIH0pLm1hcChmdW5jdGlvbihlZGdlKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgc291cmNlOiBlZGdlLmxlZnQuZGF0YSxcclxuICAgICAgICB0YXJnZXQ6IGVkZ2UucmlnaHQuZGF0YVxyXG4gICAgICB9O1xyXG4gICAgfSk7XHJcbiAgfSxcclxuXHJcbiAgZmluZDogZnVuY3Rpb24oeCwgeSwgcmFkaXVzKSB7XHJcbiAgICB2YXIgdGhhdCA9IHRoaXMsIGkwLCBpMSA9IHRoYXQuX2ZvdW5kIHx8IDAsIG4gPSB0aGF0LmNlbGxzLmxlbmd0aCwgY2VsbDtcclxuXHJcbiAgICAvLyBVc2UgdGhlIHByZXZpb3VzbHktZm91bmQgY2VsbCwgb3Igc3RhcnQgd2l0aCBhbiBhcmJpdHJhcnkgb25lLlxyXG4gICAgd2hpbGUgKCEoY2VsbCA9IHRoYXQuY2VsbHNbaTFdKSkgaWYgKCsraTEgPj0gbikgcmV0dXJuIG51bGw7XHJcbiAgICB2YXIgZHggPSB4IC0gY2VsbC5zaXRlWzBdLCBkeSA9IHkgLSBjZWxsLnNpdGVbMV0sIGQyID0gZHggKiBkeCArIGR5ICogZHk7XHJcblxyXG4gICAgLy8gVHJhdmVyc2UgdGhlIGhhbGYtZWRnZXMgdG8gZmluZCBhIGNsb3NlciBjZWxsLCBpZiBhbnkuXHJcbiAgICBkbyB7XHJcbiAgICAgIGNlbGwgPSB0aGF0LmNlbGxzW2kwID0gaTFdLCBpMSA9IG51bGw7XHJcbiAgICAgIGNlbGwuaGFsZmVkZ2VzLmZvckVhY2goZnVuY3Rpb24oZSkge1xyXG4gICAgICAgIHZhciBlZGdlID0gdGhhdC5lZGdlc1tlXSwgdiA9IGVkZ2UubGVmdDtcclxuICAgICAgICBpZiAoKHYgPT09IGNlbGwuc2l0ZSB8fCAhdikgJiYgISh2ID0gZWRnZS5yaWdodCkpIHJldHVybjtcclxuICAgICAgICB2YXIgdnggPSB4IC0gdlswXSwgdnkgPSB5IC0gdlsxXSwgdjIgPSB2eCAqIHZ4ICsgdnkgKiB2eTtcclxuICAgICAgICBpZiAodjIgPCBkMikgZDIgPSB2MiwgaTEgPSB2LmluZGV4O1xyXG4gICAgICB9KTtcclxuICAgIH0gd2hpbGUgKGkxICE9PSBudWxsKTtcclxuXHJcbiAgICB0aGF0Ll9mb3VuZCA9IGkwO1xyXG5cclxuICAgIHJldHVybiByYWRpdXMgPT0gbnVsbCB8fCBkMiA8PSByYWRpdXMgKiByYWRpdXMgPyBjZWxsLnNpdGUgOiBudWxsO1xyXG4gIH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIHZvcm9ub2koKSB7XHJcbiAgdmFyIHgkJDEgPSB4JDQsXHJcbiAgICAgIHkkJDEgPSB5JDQsXHJcbiAgICAgIGV4dGVudCA9IG51bGw7XHJcblxyXG4gIGZ1bmN0aW9uIHZvcm9ub2koZGF0YSkge1xyXG4gICAgcmV0dXJuIG5ldyBEaWFncmFtKGRhdGEubWFwKGZ1bmN0aW9uKGQsIGkpIHtcclxuICAgICAgdmFyIHMgPSBbTWF0aC5yb3VuZCh4JCQxKGQsIGksIGRhdGEpIC8gZXBzaWxvbiQ0KSAqIGVwc2lsb24kNCwgTWF0aC5yb3VuZCh5JCQxKGQsIGksIGRhdGEpIC8gZXBzaWxvbiQ0KSAqIGVwc2lsb24kNF07XHJcbiAgICAgIHMuaW5kZXggPSBpO1xyXG4gICAgICBzLmRhdGEgPSBkO1xyXG4gICAgICByZXR1cm4gcztcclxuICAgIH0pLCBleHRlbnQpO1xyXG4gIH1cclxuXHJcbiAgdm9yb25vaS5wb2x5Z29ucyA9IGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgIHJldHVybiB2b3Jvbm9pKGRhdGEpLnBvbHlnb25zKCk7XHJcbiAgfTtcclxuXHJcbiAgdm9yb25vaS5saW5rcyA9IGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgIHJldHVybiB2b3Jvbm9pKGRhdGEpLmxpbmtzKCk7XHJcbiAgfTtcclxuXHJcbiAgdm9yb25vaS50cmlhbmdsZXMgPSBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICByZXR1cm4gdm9yb25vaShkYXRhKS50cmlhbmdsZXMoKTtcclxuICB9O1xyXG5cclxuICB2b3Jvbm9pLnggPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4JCQxID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCQxMigrXyksIHZvcm9ub2kpIDogeCQkMTtcclxuICB9O1xyXG5cclxuICB2b3Jvbm9pLnkgPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5JCQxID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCQxMigrXyksIHZvcm9ub2kpIDogeSQkMTtcclxuICB9O1xyXG5cclxuICB2b3Jvbm9pLmV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGV4dGVudCA9IF8gPT0gbnVsbCA/IG51bGwgOiBbWytfWzBdWzBdLCArX1swXVsxXV0sIFsrX1sxXVswXSwgK19bMV1bMV1dXSwgdm9yb25vaSkgOiBleHRlbnQgJiYgW1tleHRlbnRbMF1bMF0sIGV4dGVudFswXVsxXV0sIFtleHRlbnRbMV1bMF0sIGV4dGVudFsxXVsxXV1dO1xyXG4gIH07XHJcblxyXG4gIHZvcm9ub2kuc2l6ZSA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGV4dGVudCA9IF8gPT0gbnVsbCA/IG51bGwgOiBbWzAsIDBdLCBbK19bMF0sICtfWzFdXV0sIHZvcm9ub2kpIDogZXh0ZW50ICYmIFtleHRlbnRbMV1bMF0gLSBleHRlbnRbMF1bMF0sIGV4dGVudFsxXVsxXSAtIGV4dGVudFswXVsxXV07XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIHZvcm9ub2k7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbnN0YW50JDEzKHgpIHtcclxuICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4geDtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBab29tRXZlbnQodGFyZ2V0LCB0eXBlLCB0cmFuc2Zvcm0pIHtcclxuICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gIHRoaXMudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xyXG59XHJcblxyXG5mdW5jdGlvbiBUcmFuc2Zvcm0oaywgeCwgeSkge1xyXG4gIHRoaXMuayA9IGs7XHJcbiAgdGhpcy54ID0geDtcclxuICB0aGlzLnkgPSB5O1xyXG59XHJcblxyXG5UcmFuc2Zvcm0ucHJvdG90eXBlID0ge1xyXG4gIGNvbnN0cnVjdG9yOiBUcmFuc2Zvcm0sXHJcbiAgc2NhbGU6IGZ1bmN0aW9uKGspIHtcclxuICAgIHJldHVybiBrID09PSAxID8gdGhpcyA6IG5ldyBUcmFuc2Zvcm0odGhpcy5rICogaywgdGhpcy54LCB0aGlzLnkpO1xyXG4gIH0sXHJcbiAgdHJhbnNsYXRlOiBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICByZXR1cm4geCA9PT0gMCAmIHkgPT09IDAgPyB0aGlzIDogbmV3IFRyYW5zZm9ybSh0aGlzLmssIHRoaXMueCArIHRoaXMuayAqIHgsIHRoaXMueSArIHRoaXMuayAqIHkpO1xyXG4gIH0sXHJcbiAgYXBwbHk6IGZ1bmN0aW9uKHBvaW50KSB7XHJcbiAgICByZXR1cm4gW3BvaW50WzBdICogdGhpcy5rICsgdGhpcy54LCBwb2ludFsxXSAqIHRoaXMuayArIHRoaXMueV07XHJcbiAgfSxcclxuICBhcHBseVg6IGZ1bmN0aW9uKHgpIHtcclxuICAgIHJldHVybiB4ICogdGhpcy5rICsgdGhpcy54O1xyXG4gIH0sXHJcbiAgYXBwbHlZOiBmdW5jdGlvbih5KSB7XHJcbiAgICByZXR1cm4geSAqIHRoaXMuayArIHRoaXMueTtcclxuICB9LFxyXG4gIGludmVydDogZnVuY3Rpb24obG9jYXRpb24pIHtcclxuICAgIHJldHVybiBbKGxvY2F0aW9uWzBdIC0gdGhpcy54KSAvIHRoaXMuaywgKGxvY2F0aW9uWzFdIC0gdGhpcy55KSAvIHRoaXMua107XHJcbiAgfSxcclxuICBpbnZlcnRYOiBmdW5jdGlvbih4KSB7XHJcbiAgICByZXR1cm4gKHggLSB0aGlzLngpIC8gdGhpcy5rO1xyXG4gIH0sXHJcbiAgaW52ZXJ0WTogZnVuY3Rpb24oeSkge1xyXG4gICAgcmV0dXJuICh5IC0gdGhpcy55KSAvIHRoaXMuaztcclxuICB9LFxyXG4gIHJlc2NhbGVYOiBmdW5jdGlvbih4KSB7XHJcbiAgICByZXR1cm4geC5jb3B5KCkuZG9tYWluKHgucmFuZ2UoKS5tYXAodGhpcy5pbnZlcnRYLCB0aGlzKS5tYXAoeC5pbnZlcnQsIHgpKTtcclxuICB9LFxyXG4gIHJlc2NhbGVZOiBmdW5jdGlvbih5KSB7XHJcbiAgICByZXR1cm4geS5jb3B5KCkuZG9tYWluKHkucmFuZ2UoKS5tYXAodGhpcy5pbnZlcnRZLCB0aGlzKS5tYXAoeS5pbnZlcnQsIHkpKTtcclxuICB9LFxyXG4gIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBcInRyYW5zbGF0ZShcIiArIHRoaXMueCArIFwiLFwiICsgdGhpcy55ICsgXCIpIHNjYWxlKFwiICsgdGhpcy5rICsgXCIpXCI7XHJcbiAgfVxyXG59O1xyXG5cclxudmFyIGlkZW50aXR5JDggPSBuZXcgVHJhbnNmb3JtKDEsIDAsIDApO1xyXG5cclxudHJhbnNmb3JtJDEucHJvdG90eXBlID0gVHJhbnNmb3JtLnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybSQxKG5vZGUpIHtcclxuICByZXR1cm4gbm9kZS5fX3pvb20gfHwgaWRlbnRpdHkkODtcclxufVxyXG5cclxuZnVuY3Rpb24gbm9wcm9wYWdhdGlvbiQyKCkge1xyXG4gIGQzLmV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBub2V2ZW50JDIoKSB7XHJcbiAgZDMuZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICBkMy5ldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcclxufVxyXG5cclxuLy8gSWdub3JlIHJpZ2h0LWNsaWNrLCBzaW5jZSB0aGF0IHNob3VsZCBvcGVuIHRoZSBjb250ZXh0IG1lbnUuXHJcbmZ1bmN0aW9uIGRlZmF1bHRGaWx0ZXIkMigpIHtcclxuICByZXR1cm4gIWQzLmV2ZW50LmJ1dHRvbjtcclxufVxyXG5cclxuZnVuY3Rpb24gZGVmYXVsdEV4dGVudCQxKCkge1xyXG4gIHZhciBlID0gdGhpcywgdywgaDtcclxuICBpZiAoZSBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpIHtcclxuICAgIGUgPSBlLm93bmVyU1ZHRWxlbWVudCB8fCBlO1xyXG4gICAgdyA9IGUud2lkdGguYmFzZVZhbC52YWx1ZTtcclxuICAgIGggPSBlLmhlaWdodC5iYXNlVmFsLnZhbHVlO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB3ID0gZS5jbGllbnRXaWR0aDtcclxuICAgIGggPSBlLmNsaWVudEhlaWdodDtcclxuICB9XHJcbiAgcmV0dXJuIFtbMCwgMF0sIFt3LCBoXV07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlZmF1bHRUcmFuc2Zvcm0oKSB7XHJcbiAgcmV0dXJuIHRoaXMuX196b29tIHx8IGlkZW50aXR5JDg7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlZmF1bHRXaGVlbERlbHRhKCkge1xyXG4gIHJldHVybiAtZDMuZXZlbnQuZGVsdGFZICogKGQzLmV2ZW50LmRlbHRhTW9kZSA/IDEyMCA6IDEpIC8gNTAwO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkZWZhdWx0VG91Y2hhYmxlJDEoKSB7XHJcbiAgcmV0dXJuIFwib250b3VjaHN0YXJ0XCIgaW4gdGhpcztcclxufVxyXG5cclxuZnVuY3Rpb24gZGVmYXVsdENvbnN0cmFpbih0cmFuc2Zvcm0sIGV4dGVudCwgdHJhbnNsYXRlRXh0ZW50KSB7XHJcbiAgdmFyIGR4MCA9IHRyYW5zZm9ybS5pbnZlcnRYKGV4dGVudFswXVswXSkgLSB0cmFuc2xhdGVFeHRlbnRbMF1bMF0sXHJcbiAgICAgIGR4MSA9IHRyYW5zZm9ybS5pbnZlcnRYKGV4dGVudFsxXVswXSkgLSB0cmFuc2xhdGVFeHRlbnRbMV1bMF0sXHJcbiAgICAgIGR5MCA9IHRyYW5zZm9ybS5pbnZlcnRZKGV4dGVudFswXVsxXSkgLSB0cmFuc2xhdGVFeHRlbnRbMF1bMV0sXHJcbiAgICAgIGR5MSA9IHRyYW5zZm9ybS5pbnZlcnRZKGV4dGVudFsxXVsxXSkgLSB0cmFuc2xhdGVFeHRlbnRbMV1bMV07XHJcbiAgcmV0dXJuIHRyYW5zZm9ybS50cmFuc2xhdGUoXHJcbiAgICBkeDEgPiBkeDAgPyAoZHgwICsgZHgxKSAvIDIgOiBNYXRoLm1pbigwLCBkeDApIHx8IE1hdGgubWF4KDAsIGR4MSksXHJcbiAgICBkeTEgPiBkeTAgPyAoZHkwICsgZHkxKSAvIDIgOiBNYXRoLm1pbigwLCBkeTApIHx8IE1hdGgubWF4KDAsIGR5MSlcclxuICApO1xyXG59XHJcblxyXG5mdW5jdGlvbiB6b29tKCkge1xyXG4gIHZhciBmaWx0ZXIgPSBkZWZhdWx0RmlsdGVyJDIsXHJcbiAgICAgIGV4dGVudCA9IGRlZmF1bHRFeHRlbnQkMSxcclxuICAgICAgY29uc3RyYWluID0gZGVmYXVsdENvbnN0cmFpbixcclxuICAgICAgd2hlZWxEZWx0YSA9IGRlZmF1bHRXaGVlbERlbHRhLFxyXG4gICAgICB0b3VjaGFibGUgPSBkZWZhdWx0VG91Y2hhYmxlJDEsXHJcbiAgICAgIHNjYWxlRXh0ZW50ID0gWzAsIEluZmluaXR5XSxcclxuICAgICAgdHJhbnNsYXRlRXh0ZW50ID0gW1stSW5maW5pdHksIC1JbmZpbml0eV0sIFtJbmZpbml0eSwgSW5maW5pdHldXSxcclxuICAgICAgZHVyYXRpb24gPSAyNTAsXHJcbiAgICAgIGludGVycG9sYXRlID0gaW50ZXJwb2xhdGVab29tLFxyXG4gICAgICBnZXN0dXJlcyA9IFtdLFxyXG4gICAgICBsaXN0ZW5lcnMgPSBkaXNwYXRjaChcInN0YXJ0XCIsIFwiem9vbVwiLCBcImVuZFwiKSxcclxuICAgICAgdG91Y2hzdGFydGluZyxcclxuICAgICAgdG91Y2hlbmRpbmcsXHJcbiAgICAgIHRvdWNoRGVsYXkgPSA1MDAsXHJcbiAgICAgIHdoZWVsRGVsYXkgPSAxNTAsXHJcbiAgICAgIGNsaWNrRGlzdGFuY2UyID0gMDtcclxuXHJcbiAgZnVuY3Rpb24gem9vbShzZWxlY3Rpb24kJDEpIHtcclxuICAgIHNlbGVjdGlvbiQkMVxyXG4gICAgICAgIC5wcm9wZXJ0eShcIl9fem9vbVwiLCBkZWZhdWx0VHJhbnNmb3JtKVxyXG4gICAgICAgIC5vbihcIndoZWVsLnpvb21cIiwgd2hlZWxlZClcclxuICAgICAgICAub24oXCJtb3VzZWRvd24uem9vbVwiLCBtb3VzZWRvd25lZClcclxuICAgICAgICAub24oXCJkYmxjbGljay56b29tXCIsIGRibGNsaWNrZWQpXHJcbiAgICAgIC5maWx0ZXIodG91Y2hhYmxlKVxyXG4gICAgICAgIC5vbihcInRvdWNoc3RhcnQuem9vbVwiLCB0b3VjaHN0YXJ0ZWQpXHJcbiAgICAgICAgLm9uKFwidG91Y2htb3ZlLnpvb21cIiwgdG91Y2htb3ZlZClcclxuICAgICAgICAub24oXCJ0b3VjaGVuZC56b29tIHRvdWNoY2FuY2VsLnpvb21cIiwgdG91Y2hlbmRlZClcclxuICAgICAgICAuc3R5bGUoXCJ0b3VjaC1hY3Rpb25cIiwgXCJub25lXCIpXHJcbiAgICAgICAgLnN0eWxlKFwiLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yXCIsIFwicmdiYSgwLDAsMCwwKVwiKTtcclxuICB9XHJcblxyXG4gIHpvb20udHJhbnNmb3JtID0gZnVuY3Rpb24oY29sbGVjdGlvbiwgdHJhbnNmb3JtKSB7XHJcbiAgICB2YXIgc2VsZWN0aW9uJCQxID0gY29sbGVjdGlvbi5zZWxlY3Rpb24gPyBjb2xsZWN0aW9uLnNlbGVjdGlvbigpIDogY29sbGVjdGlvbjtcclxuICAgIHNlbGVjdGlvbiQkMS5wcm9wZXJ0eShcIl9fem9vbVwiLCBkZWZhdWx0VHJhbnNmb3JtKTtcclxuICAgIGlmIChjb2xsZWN0aW9uICE9PSBzZWxlY3Rpb24kJDEpIHtcclxuICAgICAgc2NoZWR1bGUoY29sbGVjdGlvbiwgdHJhbnNmb3JtKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHNlbGVjdGlvbiQkMS5pbnRlcnJ1cHQoKS5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGdlc3R1cmUodGhpcywgYXJndW1lbnRzKVxyXG4gICAgICAgICAgICAuc3RhcnQoKVxyXG4gICAgICAgICAgICAuem9vbShudWxsLCB0eXBlb2YgdHJhbnNmb3JtID09PSBcImZ1bmN0aW9uXCIgPyB0cmFuc2Zvcm0uYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHRyYW5zZm9ybSlcclxuICAgICAgICAgICAgLmVuZCgpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICB6b29tLnNjYWxlQnkgPSBmdW5jdGlvbihzZWxlY3Rpb24kJDEsIGspIHtcclxuICAgIHpvb20uc2NhbGVUbyhzZWxlY3Rpb24kJDEsIGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgazAgPSB0aGlzLl9fem9vbS5rLFxyXG4gICAgICAgICAgazEgPSB0eXBlb2YgayA9PT0gXCJmdW5jdGlvblwiID8gay5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogaztcclxuICAgICAgcmV0dXJuIGswICogazE7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICB6b29tLnNjYWxlVG8gPSBmdW5jdGlvbihzZWxlY3Rpb24kJDEsIGspIHtcclxuICAgIHpvb20udHJhbnNmb3JtKHNlbGVjdGlvbiQkMSwgZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBlID0gZXh0ZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXHJcbiAgICAgICAgICB0MCA9IHRoaXMuX196b29tLFxyXG4gICAgICAgICAgcDAgPSBjZW50cm9pZChlKSxcclxuICAgICAgICAgIHAxID0gdDAuaW52ZXJ0KHAwKSxcclxuICAgICAgICAgIGsxID0gdHlwZW9mIGsgPT09IFwiZnVuY3Rpb25cIiA/IGsuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IGs7XHJcbiAgICAgIHJldHVybiBjb25zdHJhaW4odHJhbnNsYXRlKHNjYWxlKHQwLCBrMSksIHAwLCBwMSksIGUsIHRyYW5zbGF0ZUV4dGVudCk7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICB6b29tLnRyYW5zbGF0ZUJ5ID0gZnVuY3Rpb24oc2VsZWN0aW9uJCQxLCB4LCB5KSB7XHJcbiAgICB6b29tLnRyYW5zZm9ybShzZWxlY3Rpb24kJDEsIGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gY29uc3RyYWluKHRoaXMuX196b29tLnRyYW5zbGF0ZShcclxuICAgICAgICB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8geC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogeCxcclxuICAgICAgICB0eXBlb2YgeSA9PT0gXCJmdW5jdGlvblwiID8geS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogeVxyXG4gICAgICApLCBleHRlbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdHJhbnNsYXRlRXh0ZW50KTtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIHpvb20udHJhbnNsYXRlVG8gPSBmdW5jdGlvbihzZWxlY3Rpb24kJDEsIHgsIHkpIHtcclxuICAgIHpvb20udHJhbnNmb3JtKHNlbGVjdGlvbiQkMSwgZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBlID0gZXh0ZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXHJcbiAgICAgICAgICB0ID0gdGhpcy5fX3pvb20sXHJcbiAgICAgICAgICBwID0gY2VudHJvaWQoZSk7XHJcbiAgICAgIHJldHVybiBjb25zdHJhaW4oaWRlbnRpdHkkOC50cmFuc2xhdGUocFswXSwgcFsxXSkuc2NhbGUodC5rKS50cmFuc2xhdGUoXHJcbiAgICAgICAgdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IC14LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiAteCxcclxuICAgICAgICB0eXBlb2YgeSA9PT0gXCJmdW5jdGlvblwiID8gLXkuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IC15XHJcbiAgICAgICksIGUsIHRyYW5zbGF0ZUV4dGVudCk7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBzY2FsZSh0cmFuc2Zvcm0sIGspIHtcclxuICAgIGsgPSBNYXRoLm1heChzY2FsZUV4dGVudFswXSwgTWF0aC5taW4oc2NhbGVFeHRlbnRbMV0sIGspKTtcclxuICAgIHJldHVybiBrID09PSB0cmFuc2Zvcm0uayA/IHRyYW5zZm9ybSA6IG5ldyBUcmFuc2Zvcm0oaywgdHJhbnNmb3JtLngsIHRyYW5zZm9ybS55KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHRyYW5zbGF0ZSh0cmFuc2Zvcm0sIHAwLCBwMSkge1xyXG4gICAgdmFyIHggPSBwMFswXSAtIHAxWzBdICogdHJhbnNmb3JtLmssIHkgPSBwMFsxXSAtIHAxWzFdICogdHJhbnNmb3JtLms7XHJcbiAgICByZXR1cm4geCA9PT0gdHJhbnNmb3JtLnggJiYgeSA9PT0gdHJhbnNmb3JtLnkgPyB0cmFuc2Zvcm0gOiBuZXcgVHJhbnNmb3JtKHRyYW5zZm9ybS5rLCB4LCB5KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNlbnRyb2lkKGV4dGVudCkge1xyXG4gICAgcmV0dXJuIFsoK2V4dGVudFswXVswXSArICtleHRlbnRbMV1bMF0pIC8gMiwgKCtleHRlbnRbMF1bMV0gKyArZXh0ZW50WzFdWzFdKSAvIDJdO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2NoZWR1bGUodHJhbnNpdGlvbiQkMSwgdHJhbnNmb3JtLCBjZW50ZXIpIHtcclxuICAgIHRyYW5zaXRpb24kJDFcclxuICAgICAgICAub24oXCJzdGFydC56b29tXCIsIGZ1bmN0aW9uKCkgeyBnZXN0dXJlKHRoaXMsIGFyZ3VtZW50cykuc3RhcnQoKTsgfSlcclxuICAgICAgICAub24oXCJpbnRlcnJ1cHQuem9vbSBlbmQuem9vbVwiLCBmdW5jdGlvbigpIHsgZ2VzdHVyZSh0aGlzLCBhcmd1bWVudHMpLmVuZCgpOyB9KVxyXG4gICAgICAgIC50d2VlbihcInpvb21cIiwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXHJcbiAgICAgICAgICAgICAgYXJncyA9IGFyZ3VtZW50cyxcclxuICAgICAgICAgICAgICBnID0gZ2VzdHVyZSh0aGF0LCBhcmdzKSxcclxuICAgICAgICAgICAgICBlID0gZXh0ZW50LmFwcGx5KHRoYXQsIGFyZ3MpLFxyXG4gICAgICAgICAgICAgIHAgPSBjZW50ZXIgfHwgY2VudHJvaWQoZSksXHJcbiAgICAgICAgICAgICAgdyA9IE1hdGgubWF4KGVbMV1bMF0gLSBlWzBdWzBdLCBlWzFdWzFdIC0gZVswXVsxXSksXHJcbiAgICAgICAgICAgICAgYSA9IHRoYXQuX196b29tLFxyXG4gICAgICAgICAgICAgIGIgPSB0eXBlb2YgdHJhbnNmb3JtID09PSBcImZ1bmN0aW9uXCIgPyB0cmFuc2Zvcm0uYXBwbHkodGhhdCwgYXJncykgOiB0cmFuc2Zvcm0sXHJcbiAgICAgICAgICAgICAgaSA9IGludGVycG9sYXRlKGEuaW52ZXJ0KHApLmNvbmNhdCh3IC8gYS5rKSwgYi5pbnZlcnQocCkuY29uY2F0KHcgLyBiLmspKTtcclxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbih0KSB7XHJcbiAgICAgICAgICAgIGlmICh0ID09PSAxKSB0ID0gYjsgLy8gQXZvaWQgcm91bmRpbmcgZXJyb3Igb24gZW5kLlxyXG4gICAgICAgICAgICBlbHNlIHsgdmFyIGwgPSBpKHQpLCBrID0gdyAvIGxbMl07IHQgPSBuZXcgVHJhbnNmb3JtKGssIHBbMF0gLSBsWzBdICogaywgcFsxXSAtIGxbMV0gKiBrKTsgfVxyXG4gICAgICAgICAgICBnLnpvb20obnVsbCwgdCk7XHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2VzdHVyZSh0aGF0LCBhcmdzKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IGdlc3R1cmVzLmxlbmd0aCwgZzsgaSA8IG47ICsraSkge1xyXG4gICAgICBpZiAoKGcgPSBnZXN0dXJlc1tpXSkudGhhdCA9PT0gdGhhdCkge1xyXG4gICAgICAgIHJldHVybiBnO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IEdlc3R1cmUodGhhdCwgYXJncyk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBHZXN0dXJlKHRoYXQsIGFyZ3MpIHtcclxuICAgIHRoaXMudGhhdCA9IHRoYXQ7XHJcbiAgICB0aGlzLmFyZ3MgPSBhcmdzO1xyXG4gICAgdGhpcy5pbmRleCA9IC0xO1xyXG4gICAgdGhpcy5hY3RpdmUgPSAwO1xyXG4gICAgdGhpcy5leHRlbnQgPSBleHRlbnQuYXBwbHkodGhhdCwgYXJncyk7XHJcbiAgfVxyXG5cclxuICBHZXN0dXJlLnByb3RvdHlwZSA9IHtcclxuICAgIHN0YXJ0OiBmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKCsrdGhpcy5hY3RpdmUgPT09IDEpIHtcclxuICAgICAgICB0aGlzLmluZGV4ID0gZ2VzdHVyZXMucHVzaCh0aGlzKSAtIDE7XHJcbiAgICAgICAgdGhpcy5lbWl0KFwic3RhcnRcIik7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG4gICAgem9vbTogZnVuY3Rpb24oa2V5LCB0cmFuc2Zvcm0pIHtcclxuICAgICAgaWYgKHRoaXMubW91c2UgJiYga2V5ICE9PSBcIm1vdXNlXCIpIHRoaXMubW91c2VbMV0gPSB0cmFuc2Zvcm0uaW52ZXJ0KHRoaXMubW91c2VbMF0pO1xyXG4gICAgICBpZiAodGhpcy50b3VjaDAgJiYga2V5ICE9PSBcInRvdWNoXCIpIHRoaXMudG91Y2gwWzFdID0gdHJhbnNmb3JtLmludmVydCh0aGlzLnRvdWNoMFswXSk7XHJcbiAgICAgIGlmICh0aGlzLnRvdWNoMSAmJiBrZXkgIT09IFwidG91Y2hcIikgdGhpcy50b3VjaDFbMV0gPSB0cmFuc2Zvcm0uaW52ZXJ0KHRoaXMudG91Y2gxWzBdKTtcclxuICAgICAgdGhpcy50aGF0Ll9fem9vbSA9IHRyYW5zZm9ybTtcclxuICAgICAgdGhpcy5lbWl0KFwiem9vbVwiKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG4gICAgZW5kOiBmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKC0tdGhpcy5hY3RpdmUgPT09IDApIHtcclxuICAgICAgICBnZXN0dXJlcy5zcGxpY2UodGhpcy5pbmRleCwgMSk7XHJcbiAgICAgICAgdGhpcy5pbmRleCA9IC0xO1xyXG4gICAgICAgIHRoaXMuZW1pdChcImVuZFwiKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcbiAgICBlbWl0OiBmdW5jdGlvbih0eXBlKSB7XHJcbiAgICAgIGN1c3RvbUV2ZW50KG5ldyBab29tRXZlbnQoem9vbSwgdHlwZSwgdGhpcy50aGF0Ll9fem9vbSksIGxpc3RlbmVycy5hcHBseSwgbGlzdGVuZXJzLCBbdHlwZSwgdGhpcy50aGF0LCB0aGlzLmFyZ3NdKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiB3aGVlbGVkKCkge1xyXG4gICAgaWYgKCFmaWx0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgcmV0dXJuO1xyXG4gICAgdmFyIGcgPSBnZXN0dXJlKHRoaXMsIGFyZ3VtZW50cyksXHJcbiAgICAgICAgdCA9IHRoaXMuX196b29tLFxyXG4gICAgICAgIGsgPSBNYXRoLm1heChzY2FsZUV4dGVudFswXSwgTWF0aC5taW4oc2NhbGVFeHRlbnRbMV0sIHQuayAqIE1hdGgucG93KDIsIHdoZWVsRGVsdGEuYXBwbHkodGhpcywgYXJndW1lbnRzKSkpKSxcclxuICAgICAgICBwID0gbW91c2UodGhpcyk7XHJcblxyXG4gICAgLy8gSWYgdGhlIG1vdXNlIGlzIGluIHRoZSBzYW1lIGxvY2F0aW9uIGFzIGJlZm9yZSwgcmV1c2UgaXQuXHJcbiAgICAvLyBJZiB0aGVyZSB3ZXJlIHJlY2VudCB3aGVlbCBldmVudHMsIHJlc2V0IHRoZSB3aGVlbCBpZGxlIHRpbWVvdXQuXHJcbiAgICBpZiAoZy53aGVlbCkge1xyXG4gICAgICBpZiAoZy5tb3VzZVswXVswXSAhPT0gcFswXSB8fCBnLm1vdXNlWzBdWzFdICE9PSBwWzFdKSB7XHJcbiAgICAgICAgZy5tb3VzZVsxXSA9IHQuaW52ZXJ0KGcubW91c2VbMF0gPSBwKTtcclxuICAgICAgfVxyXG4gICAgICBjbGVhclRpbWVvdXQoZy53aGVlbCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgdGhpcyB3aGVlbCBldmVudCB3b27igJl0IHRyaWdnZXIgYSB0cmFuc2Zvcm0gY2hhbmdlLCBpZ25vcmUgaXQuXHJcbiAgICBlbHNlIGlmICh0LmsgPT09IGspIHJldHVybjtcclxuXHJcbiAgICAvLyBPdGhlcndpc2UsIGNhcHR1cmUgdGhlIG1vdXNlIHBvaW50IGFuZCBsb2NhdGlvbiBhdCB0aGUgc3RhcnQuXHJcbiAgICBlbHNlIHtcclxuICAgICAgZy5tb3VzZSA9IFtwLCB0LmludmVydChwKV07XHJcbiAgICAgIGludGVycnVwdCh0aGlzKTtcclxuICAgICAgZy5zdGFydCgpO1xyXG4gICAgfVxyXG5cclxuICAgIG5vZXZlbnQkMigpO1xyXG4gICAgZy53aGVlbCA9IHNldFRpbWVvdXQod2hlZWxpZGxlZCwgd2hlZWxEZWxheSk7XHJcbiAgICBnLnpvb20oXCJtb3VzZVwiLCBjb25zdHJhaW4odHJhbnNsYXRlKHNjYWxlKHQsIGspLCBnLm1vdXNlWzBdLCBnLm1vdXNlWzFdKSwgZy5leHRlbnQsIHRyYW5zbGF0ZUV4dGVudCkpO1xyXG5cclxuICAgIGZ1bmN0aW9uIHdoZWVsaWRsZWQoKSB7XHJcbiAgICAgIGcud2hlZWwgPSBudWxsO1xyXG4gICAgICBnLmVuZCgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gbW91c2Vkb3duZWQoKSB7XHJcbiAgICBpZiAodG91Y2hlbmRpbmcgfHwgIWZpbHRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSByZXR1cm47XHJcbiAgICB2YXIgZyA9IGdlc3R1cmUodGhpcywgYXJndW1lbnRzKSxcclxuICAgICAgICB2ID0gc2VsZWN0KGQzLmV2ZW50LnZpZXcpLm9uKFwibW91c2Vtb3ZlLnpvb21cIiwgbW91c2Vtb3ZlZCwgdHJ1ZSkub24oXCJtb3VzZXVwLnpvb21cIiwgbW91c2V1cHBlZCwgdHJ1ZSksXHJcbiAgICAgICAgcCA9IG1vdXNlKHRoaXMpLFxyXG4gICAgICAgIHgwID0gZDMuZXZlbnQuY2xpZW50WCxcclxuICAgICAgICB5MCA9IGQzLmV2ZW50LmNsaWVudFk7XHJcblxyXG4gICAgZHJhZ0Rpc2FibGUoZDMuZXZlbnQudmlldyk7XHJcbiAgICBub3Byb3BhZ2F0aW9uJDIoKTtcclxuICAgIGcubW91c2UgPSBbcCwgdGhpcy5fX3pvb20uaW52ZXJ0KHApXTtcclxuICAgIGludGVycnVwdCh0aGlzKTtcclxuICAgIGcuc3RhcnQoKTtcclxuXHJcbiAgICBmdW5jdGlvbiBtb3VzZW1vdmVkKCkge1xyXG4gICAgICBub2V2ZW50JDIoKTtcclxuICAgICAgaWYgKCFnLm1vdmVkKSB7XHJcbiAgICAgICAgdmFyIGR4ID0gZDMuZXZlbnQuY2xpZW50WCAtIHgwLCBkeSA9IGQzLmV2ZW50LmNsaWVudFkgLSB5MDtcclxuICAgICAgICBnLm1vdmVkID0gZHggKiBkeCArIGR5ICogZHkgPiBjbGlja0Rpc3RhbmNlMjtcclxuICAgICAgfVxyXG4gICAgICBnLnpvb20oXCJtb3VzZVwiLCBjb25zdHJhaW4odHJhbnNsYXRlKGcudGhhdC5fX3pvb20sIGcubW91c2VbMF0gPSBtb3VzZShnLnRoYXQpLCBnLm1vdXNlWzFdKSwgZy5leHRlbnQsIHRyYW5zbGF0ZUV4dGVudCkpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1vdXNldXBwZWQoKSB7XHJcbiAgICAgIHYub24oXCJtb3VzZW1vdmUuem9vbSBtb3VzZXVwLnpvb21cIiwgbnVsbCk7XHJcbiAgICAgIHllc2RyYWcoZDMuZXZlbnQudmlldywgZy5tb3ZlZCk7XHJcbiAgICAgIG5vZXZlbnQkMigpO1xyXG4gICAgICBnLmVuZCgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZGJsY2xpY2tlZCgpIHtcclxuICAgIGlmICghZmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHJldHVybjtcclxuICAgIHZhciB0MCA9IHRoaXMuX196b29tLFxyXG4gICAgICAgIHAwID0gbW91c2UodGhpcyksXHJcbiAgICAgICAgcDEgPSB0MC5pbnZlcnQocDApLFxyXG4gICAgICAgIGsxID0gdDAuayAqIChkMy5ldmVudC5zaGlmdEtleSA/IDAuNSA6IDIpLFxyXG4gICAgICAgIHQxID0gY29uc3RyYWluKHRyYW5zbGF0ZShzY2FsZSh0MCwgazEpLCBwMCwgcDEpLCBleHRlbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdHJhbnNsYXRlRXh0ZW50KTtcclxuXHJcbiAgICBub2V2ZW50JDIoKTtcclxuICAgIGlmIChkdXJhdGlvbiA+IDApIHNlbGVjdCh0aGlzKS50cmFuc2l0aW9uKCkuZHVyYXRpb24oZHVyYXRpb24pLmNhbGwoc2NoZWR1bGUsIHQxLCBwMCk7XHJcbiAgICBlbHNlIHNlbGVjdCh0aGlzKS5jYWxsKHpvb20udHJhbnNmb3JtLCB0MSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB0b3VjaHN0YXJ0ZWQoKSB7XHJcbiAgICBpZiAoIWZpbHRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSByZXR1cm47XHJcbiAgICB2YXIgZyA9IGdlc3R1cmUodGhpcywgYXJndW1lbnRzKSxcclxuICAgICAgICB0b3VjaGVzJCQxID0gZDMuZXZlbnQuY2hhbmdlZFRvdWNoZXMsXHJcbiAgICAgICAgc3RhcnRlZCxcclxuICAgICAgICBuID0gdG91Y2hlcyQkMS5sZW5ndGgsIGksIHQsIHA7XHJcblxyXG4gICAgbm9wcm9wYWdhdGlvbiQyKCk7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgIHQgPSB0b3VjaGVzJCQxW2ldLCBwID0gdG91Y2godGhpcywgdG91Y2hlcyQkMSwgdC5pZGVudGlmaWVyKTtcclxuICAgICAgcCA9IFtwLCB0aGlzLl9fem9vbS5pbnZlcnQocCksIHQuaWRlbnRpZmllcl07XHJcbiAgICAgIGlmICghZy50b3VjaDApIGcudG91Y2gwID0gcCwgc3RhcnRlZCA9IHRydWU7XHJcbiAgICAgIGVsc2UgaWYgKCFnLnRvdWNoMSkgZy50b3VjaDEgPSBwO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIElmIHRoaXMgaXMgYSBkYmx0YXAsIHJlcm91dGUgdG8gdGhlIChvcHRpb25hbCkgZGJsY2xpY2suem9vbSBoYW5kbGVyLlxyXG4gICAgaWYgKHRvdWNoc3RhcnRpbmcpIHtcclxuICAgICAgdG91Y2hzdGFydGluZyA9IGNsZWFyVGltZW91dCh0b3VjaHN0YXJ0aW5nKTtcclxuICAgICAgaWYgKCFnLnRvdWNoMSkge1xyXG4gICAgICAgIGcuZW5kKCk7XHJcbiAgICAgICAgcCA9IHNlbGVjdCh0aGlzKS5vbihcImRibGNsaWNrLnpvb21cIik7XHJcbiAgICAgICAgaWYgKHApIHAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoc3RhcnRlZCkge1xyXG4gICAgICB0b3VjaHN0YXJ0aW5nID0gc2V0VGltZW91dChmdW5jdGlvbigpIHsgdG91Y2hzdGFydGluZyA9IG51bGw7IH0sIHRvdWNoRGVsYXkpO1xyXG4gICAgICBpbnRlcnJ1cHQodGhpcyk7XHJcbiAgICAgIGcuc3RhcnQoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHRvdWNobW92ZWQoKSB7XHJcbiAgICB2YXIgZyA9IGdlc3R1cmUodGhpcywgYXJndW1lbnRzKSxcclxuICAgICAgICB0b3VjaGVzJCQxID0gZDMuZXZlbnQuY2hhbmdlZFRvdWNoZXMsXHJcbiAgICAgICAgbiA9IHRvdWNoZXMkJDEubGVuZ3RoLCBpLCB0LCBwLCBsO1xyXG5cclxuICAgIG5vZXZlbnQkMigpO1xyXG4gICAgaWYgKHRvdWNoc3RhcnRpbmcpIHRvdWNoc3RhcnRpbmcgPSBjbGVhclRpbWVvdXQodG91Y2hzdGFydGluZyk7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgIHQgPSB0b3VjaGVzJCQxW2ldLCBwID0gdG91Y2godGhpcywgdG91Y2hlcyQkMSwgdC5pZGVudGlmaWVyKTtcclxuICAgICAgaWYgKGcudG91Y2gwICYmIGcudG91Y2gwWzJdID09PSB0LmlkZW50aWZpZXIpIGcudG91Y2gwWzBdID0gcDtcclxuICAgICAgZWxzZSBpZiAoZy50b3VjaDEgJiYgZy50b3VjaDFbMl0gPT09IHQuaWRlbnRpZmllcikgZy50b3VjaDFbMF0gPSBwO1xyXG4gICAgfVxyXG4gICAgdCA9IGcudGhhdC5fX3pvb207XHJcbiAgICBpZiAoZy50b3VjaDEpIHtcclxuICAgICAgdmFyIHAwID0gZy50b3VjaDBbMF0sIGwwID0gZy50b3VjaDBbMV0sXHJcbiAgICAgICAgICBwMSA9IGcudG91Y2gxWzBdLCBsMSA9IGcudG91Y2gxWzFdLFxyXG4gICAgICAgICAgZHAgPSAoZHAgPSBwMVswXSAtIHAwWzBdKSAqIGRwICsgKGRwID0gcDFbMV0gLSBwMFsxXSkgKiBkcCxcclxuICAgICAgICAgIGRsID0gKGRsID0gbDFbMF0gLSBsMFswXSkgKiBkbCArIChkbCA9IGwxWzFdIC0gbDBbMV0pICogZGw7XHJcbiAgICAgIHQgPSBzY2FsZSh0LCBNYXRoLnNxcnQoZHAgLyBkbCkpO1xyXG4gICAgICBwID0gWyhwMFswXSArIHAxWzBdKSAvIDIsIChwMFsxXSArIHAxWzFdKSAvIDJdO1xyXG4gICAgICBsID0gWyhsMFswXSArIGwxWzBdKSAvIDIsIChsMFsxXSArIGwxWzFdKSAvIDJdO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZy50b3VjaDApIHAgPSBnLnRvdWNoMFswXSwgbCA9IGcudG91Y2gwWzFdO1xyXG4gICAgZWxzZSByZXR1cm47XHJcbiAgICBnLnpvb20oXCJ0b3VjaFwiLCBjb25zdHJhaW4odHJhbnNsYXRlKHQsIHAsIGwpLCBnLmV4dGVudCwgdHJhbnNsYXRlRXh0ZW50KSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB0b3VjaGVuZGVkKCkge1xyXG4gICAgdmFyIGcgPSBnZXN0dXJlKHRoaXMsIGFyZ3VtZW50cyksXHJcbiAgICAgICAgdG91Y2hlcyQkMSA9IGQzLmV2ZW50LmNoYW5nZWRUb3VjaGVzLFxyXG4gICAgICAgIG4gPSB0b3VjaGVzJCQxLmxlbmd0aCwgaSwgdDtcclxuXHJcbiAgICBub3Byb3BhZ2F0aW9uJDIoKTtcclxuICAgIGlmICh0b3VjaGVuZGluZykgY2xlYXJUaW1lb3V0KHRvdWNoZW5kaW5nKTtcclxuICAgIHRvdWNoZW5kaW5nID0gc2V0VGltZW91dChmdW5jdGlvbigpIHsgdG91Y2hlbmRpbmcgPSBudWxsOyB9LCB0b3VjaERlbGF5KTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcclxuICAgICAgdCA9IHRvdWNoZXMkJDFbaV07XHJcbiAgICAgIGlmIChnLnRvdWNoMCAmJiBnLnRvdWNoMFsyXSA9PT0gdC5pZGVudGlmaWVyKSBkZWxldGUgZy50b3VjaDA7XHJcbiAgICAgIGVsc2UgaWYgKGcudG91Y2gxICYmIGcudG91Y2gxWzJdID09PSB0LmlkZW50aWZpZXIpIGRlbGV0ZSBnLnRvdWNoMTtcclxuICAgIH1cclxuICAgIGlmIChnLnRvdWNoMSAmJiAhZy50b3VjaDApIGcudG91Y2gwID0gZy50b3VjaDEsIGRlbGV0ZSBnLnRvdWNoMTtcclxuICAgIGlmIChnLnRvdWNoMCkgZy50b3VjaDBbMV0gPSB0aGlzLl9fem9vbS5pbnZlcnQoZy50b3VjaDBbMF0pO1xyXG4gICAgZWxzZSBnLmVuZCgpO1xyXG4gIH1cclxuXHJcbiAgem9vbS53aGVlbERlbHRhID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAod2hlZWxEZWx0YSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQkMTMoK18pLCB6b29tKSA6IHdoZWVsRGVsdGE7XHJcbiAgfTtcclxuXHJcbiAgem9vbS5maWx0ZXIgPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChmaWx0ZXIgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50JDEzKCEhXyksIHpvb20pIDogZmlsdGVyO1xyXG4gIH07XHJcblxyXG4gIHpvb20udG91Y2hhYmxlID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodG91Y2hhYmxlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCQxMyghIV8pLCB6b29tKSA6IHRvdWNoYWJsZTtcclxuICB9O1xyXG5cclxuICB6b29tLmV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGV4dGVudCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQkMTMoW1srX1swXVswXSwgK19bMF1bMV1dLCBbK19bMV1bMF0sICtfWzFdWzFdXV0pLCB6b29tKSA6IGV4dGVudDtcclxuICB9O1xyXG5cclxuICB6b29tLnNjYWxlRXh0ZW50ID0gZnVuY3Rpb24oXykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc2NhbGVFeHRlbnRbMF0gPSArX1swXSwgc2NhbGVFeHRlbnRbMV0gPSArX1sxXSwgem9vbSkgOiBbc2NhbGVFeHRlbnRbMF0sIHNjYWxlRXh0ZW50WzFdXTtcclxuICB9O1xyXG5cclxuICB6b29tLnRyYW5zbGF0ZUV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRyYW5zbGF0ZUV4dGVudFswXVswXSA9ICtfWzBdWzBdLCB0cmFuc2xhdGVFeHRlbnRbMV1bMF0gPSArX1sxXVswXSwgdHJhbnNsYXRlRXh0ZW50WzBdWzFdID0gK19bMF1bMV0sIHRyYW5zbGF0ZUV4dGVudFsxXVsxXSA9ICtfWzFdWzFdLCB6b29tKSA6IFtbdHJhbnNsYXRlRXh0ZW50WzBdWzBdLCB0cmFuc2xhdGVFeHRlbnRbMF1bMV1dLCBbdHJhbnNsYXRlRXh0ZW50WzFdWzBdLCB0cmFuc2xhdGVFeHRlbnRbMV1bMV1dXTtcclxuICB9O1xyXG5cclxuICB6b29tLmNvbnN0cmFpbiA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNvbnN0cmFpbiA9IF8sIHpvb20pIDogY29uc3RyYWluO1xyXG4gIH07XHJcblxyXG4gIHpvb20uZHVyYXRpb24gPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkdXJhdGlvbiA9ICtfLCB6b29tKSA6IGR1cmF0aW9uO1xyXG4gIH07XHJcblxyXG4gIHpvb20uaW50ZXJwb2xhdGUgPSBmdW5jdGlvbihfKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpbnRlcnBvbGF0ZSA9IF8sIHpvb20pIDogaW50ZXJwb2xhdGU7XHJcbiAgfTtcclxuXHJcbiAgem9vbS5vbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHZhbHVlID0gbGlzdGVuZXJzLm9uLmFwcGx5KGxpc3RlbmVycywgYXJndW1lbnRzKTtcclxuICAgIHJldHVybiB2YWx1ZSA9PT0gbGlzdGVuZXJzID8gem9vbSA6IHZhbHVlO1xyXG4gIH07XHJcblxyXG4gIHpvb20uY2xpY2tEaXN0YW5jZSA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNsaWNrRGlzdGFuY2UyID0gKF8gPSArXykgKiBfLCB6b29tKSA6IE1hdGguc3FydChjbGlja0Rpc3RhbmNlMik7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIHpvb207XHJcbn1cclxuXHJcbmQzLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG5kMy5iaXNlY3QgPSBiaXNlY3RSaWdodDtcclxuZDMuYmlzZWN0UmlnaHQgPSBiaXNlY3RSaWdodDtcclxuZDMuYmlzZWN0TGVmdCA9IGJpc2VjdExlZnQ7XHJcbmQzLmFzY2VuZGluZyA9IGFzY2VuZGluZztcclxuZDMuYmlzZWN0b3IgPSBiaXNlY3RvcjtcclxuZDMuY3Jvc3MgPSBjcm9zcztcclxuZDMuZGVzY2VuZGluZyA9IGRlc2NlbmRpbmc7XHJcbmQzLmRldmlhdGlvbiA9IGRldmlhdGlvbjtcclxuZDMuZXh0ZW50ID0gZXh0ZW50O1xyXG5kMy5oaXN0b2dyYW0gPSBoaXN0b2dyYW07XHJcbmQzLnRocmVzaG9sZEZyZWVkbWFuRGlhY29uaXMgPSBmcmVlZG1hbkRpYWNvbmlzO1xyXG5kMy50aHJlc2hvbGRTY290dCA9IHNjb3R0O1xyXG5kMy50aHJlc2hvbGRTdHVyZ2VzID0gdGhyZXNob2xkU3R1cmdlcztcclxuZDMubWF4ID0gbWF4O1xyXG5kMy5tZWFuID0gbWVhbjtcclxuZDMubWVkaWFuID0gbWVkaWFuO1xyXG5kMy5tZXJnZSA9IG1lcmdlO1xyXG5kMy5taW4gPSBtaW47XHJcbmQzLnBhaXJzID0gcGFpcnM7XHJcbmQzLnBlcm11dGUgPSBwZXJtdXRlO1xyXG5kMy5xdWFudGlsZSA9IHRocmVzaG9sZDtcclxuZDMucmFuZ2UgPSBzZXF1ZW5jZTtcclxuZDMuc2NhbiA9IHNjYW47XHJcbmQzLnNodWZmbGUgPSBzaHVmZmxlO1xyXG5kMy5zdW0gPSBzdW07XHJcbmQzLnRpY2tzID0gdGlja3M7XHJcbmQzLnRpY2tJbmNyZW1lbnQgPSB0aWNrSW5jcmVtZW50O1xyXG5kMy50aWNrU3RlcCA9IHRpY2tTdGVwO1xyXG5kMy50cmFuc3Bvc2UgPSB0cmFuc3Bvc2U7XHJcbmQzLnZhcmlhbmNlID0gdmFyaWFuY2U7XHJcbmQzLnppcCA9IHppcDtcclxuZDMuYXhpc1RvcCA9IGF4aXNUb3A7XHJcbmQzLmF4aXNSaWdodCA9IGF4aXNSaWdodDtcclxuZDMuYXhpc0JvdHRvbSA9IGF4aXNCb3R0b207XHJcbmQzLmF4aXNMZWZ0ID0gYXhpc0xlZnQ7XHJcbmQzLmJydXNoID0gYnJ1c2g7XHJcbmQzLmJydXNoWCA9IGJydXNoWDtcclxuZDMuYnJ1c2hZID0gYnJ1c2hZO1xyXG5kMy5icnVzaFNlbGVjdGlvbiA9IGJydXNoU2VsZWN0aW9uO1xyXG5kMy5jaG9yZCA9IGNob3JkO1xyXG5kMy5yaWJib24gPSByaWJib247XHJcbmQzLm5lc3QgPSBuZXN0O1xyXG5kMy5zZXQgPSBzZXQkMjtcclxuZDMubWFwID0gbWFwJDE7XHJcbmQzLmtleXMgPSBrZXlzO1xyXG5kMy52YWx1ZXMgPSB2YWx1ZXM7XHJcbmQzLmVudHJpZXMgPSBlbnRyaWVzO1xyXG5kMy5jb2xvciA9IGNvbG9yO1xyXG5kMy5yZ2IgPSByZ2I7XHJcbmQzLmhzbCA9IGhzbDtcclxuZDMubGFiID0gbGFiO1xyXG5kMy5oY2wgPSBoY2w7XHJcbmQzLmxjaCA9IGxjaDtcclxuZDMuZ3JheSA9IGdyYXk7XHJcbmQzLmN1YmVoZWxpeCA9IGN1YmVoZWxpeDtcclxuZDMuY29udG91cnMgPSBjb250b3VycztcclxuZDMuY29udG91ckRlbnNpdHkgPSBkZW5zaXR5O1xyXG5kMy5kaXNwYXRjaCA9IGRpc3BhdGNoO1xyXG5kMy5kcmFnID0gZHJhZztcclxuZDMuZHJhZ0Rpc2FibGUgPSBkcmFnRGlzYWJsZTtcclxuZDMuZHJhZ0VuYWJsZSA9IHllc2RyYWc7XHJcbmQzLmRzdkZvcm1hdCA9IGRzdkZvcm1hdDtcclxuZDMuY3N2UGFyc2UgPSBjc3ZQYXJzZTtcclxuZDMuY3N2UGFyc2VSb3dzID0gY3N2UGFyc2VSb3dzO1xyXG5kMy5jc3ZGb3JtYXQgPSBjc3ZGb3JtYXQ7XHJcbmQzLmNzdkZvcm1hdFJvd3MgPSBjc3ZGb3JtYXRSb3dzO1xyXG5kMy50c3ZQYXJzZSA9IHRzdlBhcnNlO1xyXG5kMy50c3ZQYXJzZVJvd3MgPSB0c3ZQYXJzZVJvd3M7XHJcbmQzLnRzdkZvcm1hdCA9IHRzdkZvcm1hdDtcclxuZDMudHN2Rm9ybWF0Um93cyA9IHRzdkZvcm1hdFJvd3M7XHJcbmQzLmVhc2VMaW5lYXIgPSBsaW5lYXIkMTtcclxuZDMuZWFzZVF1YWQgPSBxdWFkSW5PdXQ7XHJcbmQzLmVhc2VRdWFkSW4gPSBxdWFkSW47XHJcbmQzLmVhc2VRdWFkT3V0ID0gcXVhZE91dDtcclxuZDMuZWFzZVF1YWRJbk91dCA9IHF1YWRJbk91dDtcclxuZDMuZWFzZUN1YmljID0gY3ViaWNJbk91dDtcclxuZDMuZWFzZUN1YmljSW4gPSBjdWJpY0luO1xyXG5kMy5lYXNlQ3ViaWNPdXQgPSBjdWJpY091dDtcclxuZDMuZWFzZUN1YmljSW5PdXQgPSBjdWJpY0luT3V0O1xyXG5kMy5lYXNlUG9seSA9IHBvbHlJbk91dDtcclxuZDMuZWFzZVBvbHlJbiA9IHBvbHlJbjtcclxuZDMuZWFzZVBvbHlPdXQgPSBwb2x5T3V0O1xyXG5kMy5lYXNlUG9seUluT3V0ID0gcG9seUluT3V0O1xyXG5kMy5lYXNlU2luID0gc2luSW5PdXQ7XHJcbmQzLmVhc2VTaW5JbiA9IHNpbkluO1xyXG5kMy5lYXNlU2luT3V0ID0gc2luT3V0O1xyXG5kMy5lYXNlU2luSW5PdXQgPSBzaW5Jbk91dDtcclxuZDMuZWFzZUV4cCA9IGV4cEluT3V0O1xyXG5kMy5lYXNlRXhwSW4gPSBleHBJbjtcclxuZDMuZWFzZUV4cE91dCA9IGV4cE91dDtcclxuZDMuZWFzZUV4cEluT3V0ID0gZXhwSW5PdXQ7XHJcbmQzLmVhc2VDaXJjbGUgPSBjaXJjbGVJbk91dDtcclxuZDMuZWFzZUNpcmNsZUluID0gY2lyY2xlSW47XHJcbmQzLmVhc2VDaXJjbGVPdXQgPSBjaXJjbGVPdXQ7XHJcbmQzLmVhc2VDaXJjbGVJbk91dCA9IGNpcmNsZUluT3V0O1xyXG5kMy5lYXNlQm91bmNlID0gYm91bmNlT3V0O1xyXG5kMy5lYXNlQm91bmNlSW4gPSBib3VuY2VJbjtcclxuZDMuZWFzZUJvdW5jZU91dCA9IGJvdW5jZU91dDtcclxuZDMuZWFzZUJvdW5jZUluT3V0ID0gYm91bmNlSW5PdXQ7XHJcbmQzLmVhc2VCYWNrID0gYmFja0luT3V0O1xyXG5kMy5lYXNlQmFja0luID0gYmFja0luO1xyXG5kMy5lYXNlQmFja091dCA9IGJhY2tPdXQ7XHJcbmQzLmVhc2VCYWNrSW5PdXQgPSBiYWNrSW5PdXQ7XHJcbmQzLmVhc2VFbGFzdGljID0gZWxhc3RpY091dDtcclxuZDMuZWFzZUVsYXN0aWNJbiA9IGVsYXN0aWNJbjtcclxuZDMuZWFzZUVsYXN0aWNPdXQgPSBlbGFzdGljT3V0O1xyXG5kMy5lYXNlRWxhc3RpY0luT3V0ID0gZWxhc3RpY0luT3V0O1xyXG5kMy5ibG9iID0gYmxvYjtcclxuZDMuYnVmZmVyID0gYnVmZmVyO1xyXG5kMy5kc3YgPSBkc3Y7XHJcbmQzLmNzdiA9IGNzdiQxO1xyXG5kMy50c3YgPSB0c3YkMTtcclxuZDMuaW1hZ2UgPSBpbWFnZTtcclxuZDMuanNvbiA9IGpzb247XHJcbmQzLnRleHQgPSB0ZXh0O1xyXG5kMy54bWwgPSB4bWw7XHJcbmQzLmh0bWwgPSBodG1sO1xyXG5kMy5zdmcgPSBzdmc7XHJcbmQzLmZvcmNlQ2VudGVyID0gY2VudGVyJDE7XHJcbmQzLmZvcmNlQ29sbGlkZSA9IGNvbGxpZGU7XHJcbmQzLmZvcmNlTGluayA9IGxpbms7XHJcbmQzLmZvcmNlTWFueUJvZHkgPSBtYW55Qm9keTtcclxuZDMuZm9yY2VSYWRpYWwgPSByYWRpYWw7XHJcbmQzLmZvcmNlU2ltdWxhdGlvbiA9IHNpbXVsYXRpb247XHJcbmQzLmZvcmNlWCA9IHgkMjtcclxuZDMuZm9yY2VZID0geSQyO1xyXG5kMy5mb3JtYXREZWZhdWx0TG9jYWxlID0gZGVmYXVsdExvY2FsZTtcclxuZDMuZm9ybWF0TG9jYWxlID0gZm9ybWF0TG9jYWxlO1xyXG5kMy5mb3JtYXRTcGVjaWZpZXIgPSBmb3JtYXRTcGVjaWZpZXI7XHJcbmQzLnByZWNpc2lvbkZpeGVkID0gcHJlY2lzaW9uRml4ZWQ7XHJcbmQzLnByZWNpc2lvblByZWZpeCA9IHByZWNpc2lvblByZWZpeDtcclxuZDMucHJlY2lzaW9uUm91bmQgPSBwcmVjaXNpb25Sb3VuZDtcclxuZDMuZ2VvQXJlYSA9IGFyZWEkMTtcclxuZDMuZ2VvQm91bmRzID0gYm91bmRzO1xyXG5kMy5nZW9DZW50cm9pZCA9IGNlbnRyb2lkO1xyXG5kMy5nZW9DaXJjbGUgPSBjaXJjbGU7XHJcbmQzLmdlb0NsaXBBbnRpbWVyaWRpYW4gPSBjbGlwQW50aW1lcmlkaWFuO1xyXG5kMy5nZW9DbGlwQ2lyY2xlID0gY2xpcENpcmNsZTtcclxuZDMuZ2VvQ2xpcEV4dGVudCA9IGV4dGVudCQxO1xyXG5kMy5nZW9DbGlwUmVjdGFuZ2xlID0gY2xpcFJlY3RhbmdsZTtcclxuZDMuZ2VvQ29udGFpbnMgPSBjb250YWlucyQxO1xyXG5kMy5nZW9EaXN0YW5jZSA9IGRpc3RhbmNlO1xyXG5kMy5nZW9HcmF0aWN1bGUgPSBncmF0aWN1bGU7XHJcbmQzLmdlb0dyYXRpY3VsZTEwID0gZ3JhdGljdWxlMTA7XHJcbmQzLmdlb0ludGVycG9sYXRlID0gaW50ZXJwb2xhdGUkMTtcclxuZDMuZ2VvTGVuZ3RoID0gbGVuZ3RoJDE7XHJcbmQzLmdlb1BhdGggPSBpbmRleCQxO1xyXG5kMy5nZW9BbGJlcnMgPSBhbGJlcnM7XHJcbmQzLmdlb0FsYmVyc1VzYSA9IGFsYmVyc1VzYTtcclxuZDMuZ2VvQXppbXV0aGFsRXF1YWxBcmVhID0gYXppbXV0aGFsRXF1YWxBcmVhO1xyXG5kMy5nZW9BemltdXRoYWxFcXVhbEFyZWFSYXcgPSBhemltdXRoYWxFcXVhbEFyZWFSYXc7XHJcbmQzLmdlb0F6aW11dGhhbEVxdWlkaXN0YW50ID0gYXppbXV0aGFsRXF1aWRpc3RhbnQ7XHJcbmQzLmdlb0F6aW11dGhhbEVxdWlkaXN0YW50UmF3ID0gYXppbXV0aGFsRXF1aWRpc3RhbnRSYXc7XHJcbmQzLmdlb0NvbmljQ29uZm9ybWFsID0gY29uaWNDb25mb3JtYWw7XHJcbmQzLmdlb0NvbmljQ29uZm9ybWFsUmF3ID0gY29uaWNDb25mb3JtYWxSYXc7XHJcbmQzLmdlb0NvbmljRXF1YWxBcmVhID0gY29uaWNFcXVhbEFyZWE7XHJcbmQzLmdlb0NvbmljRXF1YWxBcmVhUmF3ID0gY29uaWNFcXVhbEFyZWFSYXc7XHJcbmQzLmdlb0NvbmljRXF1aWRpc3RhbnQgPSBjb25pY0VxdWlkaXN0YW50O1xyXG5kMy5nZW9Db25pY0VxdWlkaXN0YW50UmF3ID0gY29uaWNFcXVpZGlzdGFudFJhdztcclxuZDMuZ2VvRXF1aXJlY3Rhbmd1bGFyID0gZXF1aXJlY3Rhbmd1bGFyO1xyXG5kMy5nZW9FcXVpcmVjdGFuZ3VsYXJSYXcgPSBlcXVpcmVjdGFuZ3VsYXJSYXc7XHJcbmQzLmdlb0dub21vbmljID0gZ25vbW9uaWM7XHJcbmQzLmdlb0dub21vbmljUmF3ID0gZ25vbW9uaWNSYXc7XHJcbmQzLmdlb0lkZW50aXR5ID0gaWRlbnRpdHkkNTtcclxuZDMuZ2VvUHJvamVjdGlvbiA9IHByb2plY3Rpb247XHJcbmQzLmdlb1Byb2plY3Rpb25NdXRhdG9yID0gcHJvamVjdGlvbk11dGF0b3I7XHJcbmQzLmdlb01lcmNhdG9yID0gbWVyY2F0b3I7XHJcbmQzLmdlb01lcmNhdG9yUmF3ID0gbWVyY2F0b3JSYXc7XHJcbmQzLmdlb05hdHVyYWxFYXJ0aDEgPSBuYXR1cmFsRWFydGgxO1xyXG5kMy5nZW9OYXR1cmFsRWFydGgxUmF3ID0gbmF0dXJhbEVhcnRoMVJhdztcclxuZDMuZ2VvT3J0aG9ncmFwaGljID0gb3J0aG9ncmFwaGljO1xyXG5kMy5nZW9PcnRob2dyYXBoaWNSYXcgPSBvcnRob2dyYXBoaWNSYXc7XHJcbmQzLmdlb1N0ZXJlb2dyYXBoaWMgPSBzdGVyZW9ncmFwaGljO1xyXG5kMy5nZW9TdGVyZW9ncmFwaGljUmF3ID0gc3RlcmVvZ3JhcGhpY1JhdztcclxuZDMuZ2VvVHJhbnN2ZXJzZU1lcmNhdG9yID0gdHJhbnN2ZXJzZU1lcmNhdG9yO1xyXG5kMy5nZW9UcmFuc3ZlcnNlTWVyY2F0b3JSYXcgPSB0cmFuc3ZlcnNlTWVyY2F0b3JSYXc7XHJcbmQzLmdlb1JvdGF0aW9uID0gcm90YXRpb247XHJcbmQzLmdlb1N0cmVhbSA9IGdlb1N0cmVhbTtcclxuZDMuZ2VvVHJhbnNmb3JtID0gdHJhbnNmb3JtO1xyXG5kMy5jbHVzdGVyID0gY2x1c3RlcjtcclxuZDMuaGllcmFyY2h5ID0gaGllcmFyY2h5O1xyXG5kMy5wYWNrID0gaW5kZXgkMjtcclxuZDMucGFja1NpYmxpbmdzID0gc2libGluZ3M7XHJcbmQzLnBhY2tFbmNsb3NlID0gZW5jbG9zZTtcclxuZDMucGFydGl0aW9uID0gcGFydGl0aW9uO1xyXG5kMy5zdHJhdGlmeSA9IHN0cmF0aWZ5O1xyXG5kMy50cmVlID0gdHJlZTtcclxuZDMudHJlZW1hcCA9IGluZGV4JDM7XHJcbmQzLnRyZWVtYXBCaW5hcnkgPSBiaW5hcnk7XHJcbmQzLnRyZWVtYXBEaWNlID0gdHJlZW1hcERpY2U7XHJcbmQzLnRyZWVtYXBTbGljZSA9IHRyZWVtYXBTbGljZTtcclxuZDMudHJlZW1hcFNsaWNlRGljZSA9IHNsaWNlRGljZTtcclxuZDMudHJlZW1hcFNxdWFyaWZ5ID0gc3F1YXJpZnk7XHJcbmQzLnRyZWVtYXBSZXNxdWFyaWZ5ID0gcmVzcXVhcmlmeTtcclxuZDMuaW50ZXJwb2xhdGUgPSBpbnRlcnBvbGF0ZVZhbHVlO1xyXG5kMy5pbnRlcnBvbGF0ZUFycmF5ID0gYXJyYXkkMTtcclxuZDMuaW50ZXJwb2xhdGVCYXNpcyA9IGJhc2lzJDE7XHJcbmQzLmludGVycG9sYXRlQmFzaXNDbG9zZWQgPSBiYXNpc0Nsb3NlZDtcclxuZDMuaW50ZXJwb2xhdGVEYXRlID0gZGF0ZTtcclxuZDMuaW50ZXJwb2xhdGVOdW1iZXIgPSByZWludGVycG9sYXRlO1xyXG5kMy5pbnRlcnBvbGF0ZU9iamVjdCA9IG9iamVjdDtcclxuZDMuaW50ZXJwb2xhdGVSb3VuZCA9IGludGVycG9sYXRlUm91bmQ7XHJcbmQzLmludGVycG9sYXRlU3RyaW5nID0gaW50ZXJwb2xhdGVTdHJpbmc7XHJcbmQzLmludGVycG9sYXRlVHJhbnNmb3JtQ3NzID0gaW50ZXJwb2xhdGVUcmFuc2Zvcm1Dc3M7XHJcbmQzLmludGVycG9sYXRlVHJhbnNmb3JtU3ZnID0gaW50ZXJwb2xhdGVUcmFuc2Zvcm1Tdmc7XHJcbmQzLmludGVycG9sYXRlWm9vbSA9IGludGVycG9sYXRlWm9vbTtcclxuZDMuaW50ZXJwb2xhdGVSZ2IgPSBpbnRlcnBvbGF0ZVJnYjtcclxuZDMuaW50ZXJwb2xhdGVSZ2JCYXNpcyA9IHJnYkJhc2lzO1xyXG5kMy5pbnRlcnBvbGF0ZVJnYkJhc2lzQ2xvc2VkID0gcmdiQmFzaXNDbG9zZWQ7XHJcbmQzLmludGVycG9sYXRlSHNsID0gaHNsJDI7XHJcbmQzLmludGVycG9sYXRlSHNsTG9uZyA9IGhzbExvbmc7XHJcbmQzLmludGVycG9sYXRlTGFiID0gbGFiJDE7XHJcbmQzLmludGVycG9sYXRlSGNsID0gaGNsJDI7XHJcbmQzLmludGVycG9sYXRlSGNsTG9uZyA9IGhjbExvbmc7XHJcbmQzLmludGVycG9sYXRlQ3ViZWhlbGl4ID0gY3ViZWhlbGl4JDI7XHJcbmQzLmludGVycG9sYXRlQ3ViZWhlbGl4TG9uZyA9IGN1YmVoZWxpeExvbmc7XHJcbmQzLnBpZWNld2lzZSA9IHBpZWNld2lzZTtcclxuZDMucXVhbnRpemUgPSBxdWFudGl6ZTtcclxuZDMucGF0aCA9IHBhdGg7XHJcbmQzLnBvbHlnb25BcmVhID0gYXJlYSQyO1xyXG5kMy5wb2x5Z29uQ2VudHJvaWQgPSBjZW50cm9pZCQxO1xyXG5kMy5wb2x5Z29uSHVsbCA9IGh1bGw7XHJcbmQzLnBvbHlnb25Db250YWlucyA9IGNvbnRhaW5zJDI7XHJcbmQzLnBvbHlnb25MZW5ndGggPSBsZW5ndGgkMjtcclxuZDMucXVhZHRyZWUgPSBxdWFkdHJlZTtcclxuZDMucmFuZG9tVW5pZm9ybSA9IHVuaWZvcm07XHJcbmQzLnJhbmRvbU5vcm1hbCA9IG5vcm1hbDtcclxuZDMucmFuZG9tTG9nTm9ybWFsID0gbG9nTm9ybWFsO1xyXG5kMy5yYW5kb21CYXRlcyA9IGJhdGVzO1xyXG5kMy5yYW5kb21JcndpbkhhbGwgPSBpcndpbkhhbGw7XHJcbmQzLnJhbmRvbUV4cG9uZW50aWFsID0gZXhwb25lbnRpYWwkMTtcclxuZDMuc2NhbGVCYW5kID0gYmFuZDtcclxuZDMuc2NhbGVQb2ludCA9IHBvaW50JDE7XHJcbmQzLnNjYWxlSWRlbnRpdHkgPSBpZGVudGl0eSQ2O1xyXG5kMy5zY2FsZUxpbmVhciA9IGxpbmVhciQyO1xyXG5kMy5zY2FsZUxvZyA9IGxvZyQxO1xyXG5kMy5zY2FsZU9yZGluYWwgPSBvcmRpbmFsO1xyXG5kMy5zY2FsZUltcGxpY2l0ID0gaW1wbGljaXQ7XHJcbmQzLnNjYWxlUG93ID0gcG93JDE7XHJcbmQzLnNjYWxlU3FydCA9IHNxcnQkMTtcclxuZDMuc2NhbGVRdWFudGlsZSA9IHF1YW50aWxlJCQxO1xyXG5kMy5zY2FsZVF1YW50aXplID0gcXVhbnRpemUkMTtcclxuZDMuc2NhbGVUaHJlc2hvbGQgPSB0aHJlc2hvbGQkMTtcclxuZDMuc2NhbGVUaW1lID0gdGltZTtcclxuZDMuc2NhbGVVdGMgPSB1dGNUaW1lO1xyXG5kMy5zY2FsZVNlcXVlbnRpYWwgPSBzZXF1ZW50aWFsO1xyXG5kMy5zY2hlbWVDYXRlZ29yeTEwID0gY2F0ZWdvcnkxMDtcclxuZDMuc2NoZW1lQWNjZW50ID0gQWNjZW50O1xyXG5kMy5zY2hlbWVEYXJrMiA9IERhcmsyO1xyXG5kMy5zY2hlbWVQYWlyZWQgPSBQYWlyZWQ7XHJcbmQzLnNjaGVtZVBhc3RlbDEgPSBQYXN0ZWwxO1xyXG5kMy5zY2hlbWVQYXN0ZWwyID0gUGFzdGVsMjtcclxuZDMuc2NoZW1lU2V0MSA9IFNldDE7XHJcbmQzLnNjaGVtZVNldDIgPSBTZXQyO1xyXG5kMy5zY2hlbWVTZXQzID0gU2V0MztcclxuZDMuaW50ZXJwb2xhdGVCckJHID0gQnJCRztcclxuZDMuc2NoZW1lQnJCRyA9IHNjaGVtZTtcclxuZDMuaW50ZXJwb2xhdGVQUkduID0gUFJHbjtcclxuZDMuc2NoZW1lUFJHbiA9IHNjaGVtZSQxO1xyXG5kMy5pbnRlcnBvbGF0ZVBpWUcgPSBQaVlHO1xyXG5kMy5zY2hlbWVQaVlHID0gc2NoZW1lJDI7XHJcbmQzLmludGVycG9sYXRlUHVPciA9IFB1T3I7XHJcbmQzLnNjaGVtZVB1T3IgPSBzY2hlbWUkMztcclxuZDMuaW50ZXJwb2xhdGVSZEJ1ID0gUmRCdTtcclxuZDMuc2NoZW1lUmRCdSA9IHNjaGVtZSQ0O1xyXG5kMy5pbnRlcnBvbGF0ZVJkR3kgPSBSZEd5O1xyXG5kMy5zY2hlbWVSZEd5ID0gc2NoZW1lJDU7XHJcbmQzLmludGVycG9sYXRlUmRZbEJ1ID0gUmRZbEJ1O1xyXG5kMy5zY2hlbWVSZFlsQnUgPSBzY2hlbWUkNjtcclxuZDMuaW50ZXJwb2xhdGVSZFlsR24gPSBSZFlsR247XHJcbmQzLnNjaGVtZVJkWWxHbiA9IHNjaGVtZSQ3O1xyXG5kMy5pbnRlcnBvbGF0ZVNwZWN0cmFsID0gU3BlY3RyYWw7XHJcbmQzLnNjaGVtZVNwZWN0cmFsID0gc2NoZW1lJDg7XHJcbmQzLmludGVycG9sYXRlQnVHbiA9IEJ1R247XHJcbmQzLnNjaGVtZUJ1R24gPSBzY2hlbWUkOTtcclxuZDMuaW50ZXJwb2xhdGVCdVB1ID0gQnVQdTtcclxuZDMuc2NoZW1lQnVQdSA9IHNjaGVtZSQxMDtcclxuZDMuaW50ZXJwb2xhdGVHbkJ1ID0gR25CdTtcclxuZDMuc2NoZW1lR25CdSA9IHNjaGVtZSQxMTtcclxuZDMuaW50ZXJwb2xhdGVPclJkID0gT3JSZDtcclxuZDMuc2NoZW1lT3JSZCA9IHNjaGVtZSQxMjtcclxuZDMuaW50ZXJwb2xhdGVQdUJ1R24gPSBQdUJ1R247XHJcbmQzLnNjaGVtZVB1QnVHbiA9IHNjaGVtZSQxMztcclxuZDMuaW50ZXJwb2xhdGVQdUJ1ID0gUHVCdTtcclxuZDMuc2NoZW1lUHVCdSA9IHNjaGVtZSQxNDtcclxuZDMuaW50ZXJwb2xhdGVQdVJkID0gUHVSZDtcclxuZDMuc2NoZW1lUHVSZCA9IHNjaGVtZSQxNTtcclxuZDMuaW50ZXJwb2xhdGVSZFB1ID0gUmRQdTtcclxuZDMuc2NoZW1lUmRQdSA9IHNjaGVtZSQxNjtcclxuZDMuaW50ZXJwb2xhdGVZbEduQnUgPSBZbEduQnU7XHJcbmQzLnNjaGVtZVlsR25CdSA9IHNjaGVtZSQxNztcclxuZDMuaW50ZXJwb2xhdGVZbEduID0gWWxHbjtcclxuZDMuc2NoZW1lWWxHbiA9IHNjaGVtZSQxODtcclxuZDMuaW50ZXJwb2xhdGVZbE9yQnIgPSBZbE9yQnI7XHJcbmQzLnNjaGVtZVlsT3JCciA9IHNjaGVtZSQxOTtcclxuZDMuaW50ZXJwb2xhdGVZbE9yUmQgPSBZbE9yUmQ7XHJcbmQzLnNjaGVtZVlsT3JSZCA9IHNjaGVtZSQyMDtcclxuZDMuaW50ZXJwb2xhdGVCbHVlcyA9IEJsdWVzO1xyXG5kMy5zY2hlbWVCbHVlcyA9IHNjaGVtZSQyMTtcclxuZDMuaW50ZXJwb2xhdGVHcmVlbnMgPSBHcmVlbnM7XHJcbmQzLnNjaGVtZUdyZWVucyA9IHNjaGVtZSQyMjtcclxuZDMuaW50ZXJwb2xhdGVHcmV5cyA9IEdyZXlzO1xyXG5kMy5zY2hlbWVHcmV5cyA9IHNjaGVtZSQyMztcclxuZDMuaW50ZXJwb2xhdGVQdXJwbGVzID0gUHVycGxlcztcclxuZDMuc2NoZW1lUHVycGxlcyA9IHNjaGVtZSQyNDtcclxuZDMuaW50ZXJwb2xhdGVSZWRzID0gUmVkcztcclxuZDMuc2NoZW1lUmVkcyA9IHNjaGVtZSQyNTtcclxuZDMuaW50ZXJwb2xhdGVPcmFuZ2VzID0gT3JhbmdlcztcclxuZDMuc2NoZW1lT3JhbmdlcyA9IHNjaGVtZSQyNjtcclxuZDMuaW50ZXJwb2xhdGVDdWJlaGVsaXhEZWZhdWx0ID0gY3ViZWhlbGl4JDM7XHJcbmQzLmludGVycG9sYXRlUmFpbmJvdyA9IHJhaW5ib3c7XHJcbmQzLmludGVycG9sYXRlV2FybSA9IHdhcm07XHJcbmQzLmludGVycG9sYXRlQ29vbCA9IGNvb2w7XHJcbmQzLmludGVycG9sYXRlU2luZWJvdyA9IHNpbmVib3c7XHJcbmQzLmludGVycG9sYXRlVmlyaWRpcyA9IHZpcmlkaXM7XHJcbmQzLmludGVycG9sYXRlTWFnbWEgPSBtYWdtYTtcclxuZDMuaW50ZXJwb2xhdGVJbmZlcm5vID0gaW5mZXJubztcclxuZDMuaW50ZXJwb2xhdGVQbGFzbWEgPSBwbGFzbWE7XHJcbmQzLmNyZWF0ZSA9IGNyZWF0ZTtcclxuZDMuY3JlYXRvciA9IGNyZWF0b3I7XHJcbmQzLmxvY2FsID0gbG9jYWw7XHJcbmQzLm1hdGNoZXIgPSBtYXRjaGVyJDE7XHJcbmQzLm1vdXNlID0gbW91c2U7XHJcbmQzLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcclxuZDMubmFtZXNwYWNlcyA9IG5hbWVzcGFjZXM7XHJcbmQzLmNsaWVudFBvaW50ID0gcG9pbnQ7XHJcbmQzLnNlbGVjdCA9IHNlbGVjdDtcclxuZDMuc2VsZWN0QWxsID0gc2VsZWN0QWxsO1xyXG5kMy5zZWxlY3Rpb24gPSBzZWxlY3Rpb247XHJcbmQzLnNlbGVjdG9yID0gc2VsZWN0b3I7XHJcbmQzLnNlbGVjdG9yQWxsID0gc2VsZWN0b3JBbGw7XHJcbmQzLnN0eWxlID0gc3R5bGVWYWx1ZTtcclxuZDMudG91Y2ggPSB0b3VjaDtcclxuZDMudG91Y2hlcyA9IHRvdWNoZXM7XHJcbmQzLndpbmRvdyA9IGRlZmF1bHRWaWV3O1xyXG5kMy5jdXN0b21FdmVudCA9IGN1c3RvbUV2ZW50O1xyXG5kMy5hcmMgPSBhcmM7XHJcbmQzLmFyZWEgPSBhcmVhJDM7XHJcbmQzLmxpbmUgPSBsaW5lO1xyXG5kMy5waWUgPSBwaWU7XHJcbmQzLmFyZWFSYWRpYWwgPSBhcmVhUmFkaWFsO1xyXG5kMy5yYWRpYWxBcmVhID0gYXJlYVJhZGlhbDtcclxuZDMubGluZVJhZGlhbCA9IGxpbmVSYWRpYWwkMTtcclxuZDMucmFkaWFsTGluZSA9IGxpbmVSYWRpYWwkMTtcclxuZDMucG9pbnRSYWRpYWwgPSBwb2ludFJhZGlhbDtcclxuZDMubGlua0hvcml6b250YWwgPSBsaW5rSG9yaXpvbnRhbDtcclxuZDMubGlua1ZlcnRpY2FsID0gbGlua1ZlcnRpY2FsO1xyXG5kMy5saW5rUmFkaWFsID0gbGlua1JhZGlhbDtcclxuZDMuc3ltYm9sID0gc3ltYm9sO1xyXG5kMy5zeW1ib2xzID0gc3ltYm9scztcclxuZDMuc3ltYm9sQ2lyY2xlID0gY2lyY2xlJDI7XHJcbmQzLnN5bWJvbENyb3NzID0gY3Jvc3MkMjtcclxuZDMuc3ltYm9sRGlhbW9uZCA9IGRpYW1vbmQ7XHJcbmQzLnN5bWJvbFNxdWFyZSA9IHNxdWFyZTtcclxuZDMuc3ltYm9sU3RhciA9IHN0YXI7XHJcbmQzLnN5bWJvbFRyaWFuZ2xlID0gdHJpYW5nbGU7XHJcbmQzLnN5bWJvbFd5ZSA9IHd5ZTtcclxuZDMuY3VydmVCYXNpc0Nsb3NlZCA9IGJhc2lzQ2xvc2VkJDE7XHJcbmQzLmN1cnZlQmFzaXNPcGVuID0gYmFzaXNPcGVuO1xyXG5kMy5jdXJ2ZUJhc2lzID0gYmFzaXMkMjtcclxuZDMuY3VydmVCdW5kbGUgPSBidW5kbGU7XHJcbmQzLmN1cnZlQ2FyZGluYWxDbG9zZWQgPSBjYXJkaW5hbENsb3NlZDtcclxuZDMuY3VydmVDYXJkaW5hbE9wZW4gPSBjYXJkaW5hbE9wZW47XHJcbmQzLmN1cnZlQ2FyZGluYWwgPSBjYXJkaW5hbDtcclxuZDMuY3VydmVDYXRtdWxsUm9tQ2xvc2VkID0gY2F0bXVsbFJvbUNsb3NlZDtcclxuZDMuY3VydmVDYXRtdWxsUm9tT3BlbiA9IGNhdG11bGxSb21PcGVuO1xyXG5kMy5jdXJ2ZUNhdG11bGxSb20gPSBjYXRtdWxsUm9tO1xyXG5kMy5jdXJ2ZUxpbmVhckNsb3NlZCA9IGxpbmVhckNsb3NlZDtcclxuZDMuY3VydmVMaW5lYXIgPSBjdXJ2ZUxpbmVhcjtcclxuZDMuY3VydmVNb25vdG9uZVggPSBtb25vdG9uZVg7XHJcbmQzLmN1cnZlTW9ub3RvbmVZID0gbW9ub3RvbmVZO1xyXG5kMy5jdXJ2ZU5hdHVyYWwgPSBuYXR1cmFsO1xyXG5kMy5jdXJ2ZVN0ZXAgPSBzdGVwO1xyXG5kMy5jdXJ2ZVN0ZXBBZnRlciA9IHN0ZXBBZnRlcjtcclxuZDMuY3VydmVTdGVwQmVmb3JlID0gc3RlcEJlZm9yZTtcclxuZDMuc3RhY2sgPSBzdGFjaztcclxuZDMuc3RhY2tPZmZzZXRFeHBhbmQgPSBleHBhbmQ7XHJcbmQzLnN0YWNrT2Zmc2V0RGl2ZXJnaW5nID0gZGl2ZXJnaW5nO1xyXG5kMy5zdGFja09mZnNldE5vbmUgPSBub25lJDE7XHJcbmQzLnN0YWNrT2Zmc2V0U2lsaG91ZXR0ZSA9IHNpbGhvdWV0dGU7XHJcbmQzLnN0YWNrT2Zmc2V0V2lnZ2xlID0gd2lnZ2xlO1xyXG5kMy5zdGFja09yZGVyQXNjZW5kaW5nID0gYXNjZW5kaW5nJDM7XHJcbmQzLnN0YWNrT3JkZXJEZXNjZW5kaW5nID0gZGVzY2VuZGluZyQyO1xyXG5kMy5zdGFja09yZGVySW5zaWRlT3V0ID0gaW5zaWRlT3V0O1xyXG5kMy5zdGFja09yZGVyTm9uZSA9IG5vbmUkMjtcclxuZDMuc3RhY2tPcmRlclJldmVyc2UgPSByZXZlcnNlO1xyXG5kMy50aW1lSW50ZXJ2YWwgPSBuZXdJbnRlcnZhbDtcclxuZDMudGltZU1pbGxpc2Vjb25kID0gbWlsbGlzZWNvbmQ7XHJcbmQzLnRpbWVNaWxsaXNlY29uZHMgPSBtaWxsaXNlY29uZHM7XHJcbmQzLnV0Y01pbGxpc2Vjb25kID0gbWlsbGlzZWNvbmQ7XHJcbmQzLnV0Y01pbGxpc2Vjb25kcyA9IG1pbGxpc2Vjb25kcztcclxuZDMudGltZVNlY29uZCA9IHNlY29uZDtcclxuZDMudGltZVNlY29uZHMgPSBzZWNvbmRzO1xyXG5kMy51dGNTZWNvbmQgPSBzZWNvbmQ7XHJcbmQzLnV0Y1NlY29uZHMgPSBzZWNvbmRzO1xyXG5kMy50aW1lTWludXRlID0gbWludXRlO1xyXG5kMy50aW1lTWludXRlcyA9IG1pbnV0ZXM7XHJcbmQzLnRpbWVIb3VyID0gaG91cjtcclxuZDMudGltZUhvdXJzID0gaG91cnM7XHJcbmQzLnRpbWVEYXkgPSBkYXk7XHJcbmQzLnRpbWVEYXlzID0gZGF5cztcclxuZDMudGltZVdlZWsgPSBzdW5kYXk7XHJcbmQzLnRpbWVXZWVrcyA9IHN1bmRheXM7XHJcbmQzLnRpbWVTdW5kYXkgPSBzdW5kYXk7XHJcbmQzLnRpbWVTdW5kYXlzID0gc3VuZGF5cztcclxuZDMudGltZU1vbmRheSA9IG1vbmRheTtcclxuZDMudGltZU1vbmRheXMgPSBtb25kYXlzO1xyXG5kMy50aW1lVHVlc2RheSA9IHR1ZXNkYXk7XHJcbmQzLnRpbWVUdWVzZGF5cyA9IHR1ZXNkYXlzO1xyXG5kMy50aW1lV2VkbmVzZGF5ID0gd2VkbmVzZGF5O1xyXG5kMy50aW1lV2VkbmVzZGF5cyA9IHdlZG5lc2RheXM7XHJcbmQzLnRpbWVUaHVyc2RheSA9IHRodXJzZGF5O1xyXG5kMy50aW1lVGh1cnNkYXlzID0gdGh1cnNkYXlzO1xyXG5kMy50aW1lRnJpZGF5ID0gZnJpZGF5O1xyXG5kMy50aW1lRnJpZGF5cyA9IGZyaWRheXM7XHJcbmQzLnRpbWVTYXR1cmRheSA9IHNhdHVyZGF5O1xyXG5kMy50aW1lU2F0dXJkYXlzID0gc2F0dXJkYXlzO1xyXG5kMy50aW1lTW9udGggPSBtb250aDtcclxuZDMudGltZU1vbnRocyA9IG1vbnRocztcclxuZDMudGltZVllYXIgPSB5ZWFyO1xyXG5kMy50aW1lWWVhcnMgPSB5ZWFycztcclxuZDMudXRjTWludXRlID0gdXRjTWludXRlO1xyXG5kMy51dGNNaW51dGVzID0gdXRjTWludXRlcztcclxuZDMudXRjSG91ciA9IHV0Y0hvdXI7XHJcbmQzLnV0Y0hvdXJzID0gdXRjSG91cnM7XHJcbmQzLnV0Y0RheSA9IHV0Y0RheTtcclxuZDMudXRjRGF5cyA9IHV0Y0RheXM7XHJcbmQzLnV0Y1dlZWsgPSB1dGNTdW5kYXk7XHJcbmQzLnV0Y1dlZWtzID0gdXRjU3VuZGF5cztcclxuZDMudXRjU3VuZGF5ID0gdXRjU3VuZGF5O1xyXG5kMy51dGNTdW5kYXlzID0gdXRjU3VuZGF5cztcclxuZDMudXRjTW9uZGF5ID0gdXRjTW9uZGF5O1xyXG5kMy51dGNNb25kYXlzID0gdXRjTW9uZGF5cztcclxuZDMudXRjVHVlc2RheSA9IHV0Y1R1ZXNkYXk7XHJcbmQzLnV0Y1R1ZXNkYXlzID0gdXRjVHVlc2RheXM7XHJcbmQzLnV0Y1dlZG5lc2RheSA9IHV0Y1dlZG5lc2RheTtcclxuZDMudXRjV2VkbmVzZGF5cyA9IHV0Y1dlZG5lc2RheXM7XHJcbmQzLnV0Y1RodXJzZGF5ID0gdXRjVGh1cnNkYXk7XHJcbmQzLnV0Y1RodXJzZGF5cyA9IHV0Y1RodXJzZGF5cztcclxuZDMudXRjRnJpZGF5ID0gdXRjRnJpZGF5O1xyXG5kMy51dGNGcmlkYXlzID0gdXRjRnJpZGF5cztcclxuZDMudXRjU2F0dXJkYXkgPSB1dGNTYXR1cmRheTtcclxuZDMudXRjU2F0dXJkYXlzID0gdXRjU2F0dXJkYXlzO1xyXG5kMy51dGNNb250aCA9IHV0Y01vbnRoO1xyXG5kMy51dGNNb250aHMgPSB1dGNNb250aHM7XHJcbmQzLnV0Y1llYXIgPSB1dGNZZWFyO1xyXG5kMy51dGNZZWFycyA9IHV0Y1llYXJzO1xyXG5kMy50aW1lRm9ybWF0RGVmYXVsdExvY2FsZSA9IGRlZmF1bHRMb2NhbGUkMTtcclxuZDMudGltZUZvcm1hdExvY2FsZSA9IGZvcm1hdExvY2FsZSQxO1xyXG5kMy5pc29Gb3JtYXQgPSBmb3JtYXRJc287XHJcbmQzLmlzb1BhcnNlID0gcGFyc2VJc287XHJcbmQzLm5vdyA9IG5vdztcclxuZDMudGltZXIgPSB0aW1lcjtcclxuZDMudGltZXJGbHVzaCA9IHRpbWVyRmx1c2g7XHJcbmQzLnRpbWVvdXQgPSB0aW1lb3V0JDE7XHJcbmQzLmludGVydmFsID0gaW50ZXJ2YWwkMTtcclxuZDMudHJhbnNpdGlvbiA9IHRyYW5zaXRpb247XHJcbmQzLmFjdGl2ZSA9IGFjdGl2ZTtcclxuZDMuaW50ZXJydXB0ID0gaW50ZXJydXB0O1xyXG5kMy52b3Jvbm9pID0gdm9yb25vaTtcclxuZDMuem9vbSA9IHpvb207XHJcbmQzLnpvb21UcmFuc2Zvcm0gPSB0cmFuc2Zvcm0kMTtcclxuZDMuem9vbUlkZW50aXR5ID0gaWRlbnRpdHkkODtcclxuXHJcbmV4cG9ydCB7ZDN9Il0sIm1hcHBpbmdzIjoiQUFBQTtBQWlJQTtBQUdBO0FBV0E7QUFHQTtBQXNIQTtBQUdBO0FBR0E7QUFRQTtBQU9BO0FBdURBO0FBR0E7QUFVQTtBQUdBO0FBMEZBO0FBR0E7QUFVQTtBQUdBO0FBNERBO0FBMERBO0FBdUxBO0FBTUE7QUFDQTtBQXVNQTtBQU9BO0FBQ0E7QUFDQTtBQVVBO0FBaUJBO0FBQ0E7QUFZQTtBQUNBO0FBQ0E7QUFZQTtBQWlDQTtBQUNBO0FBQ0E7QUFpTEE7QUFEQTtBQUdBO0FBdVJBO0FBMFRBO0FBc0dBO0FBd0JBO0FBb09BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUEwSkE7QUF3SUE7QUFnT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBR0E7QUFDQTtBQUlBO0FBQUE7QUFHQTtBQU9BO0FBRUE7QUFLQTtBQUNBO0FBZ0dBO0FBeUJBO0FBQ0E7QUFNQTtBQTZCQTtBQUNBO0FBVUE7QUFBQTtBQW1JQTtBQUNBO0FBQ0E7QUFDQTtBQXFEQTtBQUNBO0FBMENBO0FBRUE7QUFpREE7QUFDQTtBQWtDQTtBQUNBO0FBUUE7QUFPQTtBQU9BO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFRQTtBQUNBO0FBVEE7QUFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFTQTtBQUNBO0FBR0E7QUFHQTtBQW1CQTtBQVdBO0FBd0NBO0FBQ0E7QUFDQTtBQXVCQTtBQUNBO0FBQ0E7QUFxUUE7QUFDQTtBQUNBO0FBK2JBO0FBdUtBO0FBVUE7QUFpVEE7QUFtQkE7QUFRQTtBQU9BO0FBSUE7QUFTQTtBQWlCQTtBQU9BO0FBU0E7QUFzRkE7QUFVQTtBQUtBO0FBT0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQXlCQTtBQWlEQTtBQUNBO0FBc0NBO0FBR0E7QUFBQTtBQVFBO0FBQ0E7QUFKQTtBQUtBO0FBaUJBO0FBaUJBO0FBR0E7QUFBQTtBQVVBO0FBR0E7QUFHQTtBQUFBO0FBZ0VBO0FBNEZBO0FBQUE7QUFHQTtBQStHQTtBQUFBO0FBNkdBO0FBY0E7QUFDQTtBQTJCQTtBQUNBO0FBTUE7QUFVQTtBQWNBO0FBK0ZBO0FBQ0E7QUFDQTtBQW9CQTtBQUNBO0FBQ0E7QUFpQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWVBO0FBVUE7QUFnQkE7QUFhQTtBQWtFQTtBQThCQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQVFBO0FBVUE7QUFRQTtBQWtNQTtBQWlCQTtBQUdBO0FBT0E7QUFLQTtBQW9CQTtBQVdBO0FBSUE7QUFHQTtBQVVBO0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFNQTtBQTBGQTtBQU9BO0FBWUE7QUFaQTtBQXVDQTtBQW1CQTtBQUdBO0FBQ0E7QUFTQTtBQUlBO0FBR0E7QUFHQTtBQUdBO0FBaWdCQTtBQUFBO0FBK0JBO0FBQ0E7QUFBQTtBQWVBO0FBOEtBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQXNDQTtBQVFBO0FBNkJBO0FBd0JBO0FBd0RBO0FBQUE7QUFNQTtBQUdBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQWdCQTtBQUlBO0FBR0E7QUFHQTtBQUlBO0FBQ0E7QUFhQTtBQUdBO0FBSUE7QUFHQTtBQStEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFZQTtBQUNBO0FBK0tBO0FBQ0E7QUFDQTtBQUNBO0FBV0E7QUEyQkE7QUFTQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBb0hBO0FBQ0E7QUFDQTtBQW9CQTtBQUlBO0FBV0E7QUFDQTtBQWtCQTtBQUVBO0FBZ0JBO0FBOENBO0FBQ0E7QUErQkE7QUFDQTtBQXVCQTtBQUdBO0FBR0E7QUFvR0E7QUFvQkE7QUE4RUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUE2QkE7QUF1RkE7QUFDQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBZ0dBO0FBWUE7QUFDQTtBQWNBO0FBQ0E7QUFhQTtBQUNBO0FBQ0E7QUFNQTtBQVNBO0FBUUE7QUFDQTtBQWlCQTtBQTZDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWNBO0FBQ0E7QUFZQTtBQUtBO0FBUUE7QUFDQTtBQXlCQTtBQUNBO0FBT0E7QUFLQTtBQUNBO0FBQ0E7QUFHQTtBQUdBO0FBVUE7QUFlQTtBQWVBO0FBWUE7QUFDQTtBQUdBO0FBRUE7QUFBQTtBQUVBO0FBcUVBO0FBRUE7QUF1QkE7QUF1QkE7QUFDQTtBQThCQTtBQWdDQTtBQUNBO0FBQ0E7QUFtYUE7QUE0V0E7QUFFQTtBQWdDQTtBQUFBO0FBR0E7QUFRQTtBQUVBO0FBcUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFnSUE7QUFpQ0E7QUFDQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBMkpBO0FBd0hBO0FBQ0E7QUF3S0E7QUFrQkE7QUEySkE7QUE2R0E7QUFRQTtBQVlBO0FBaUlBO0FBSUE7QUFJQTtBQUdBO0FBTUE7QUFJQTtBQUNBO0FBQ0E7QUFrQkE7QUFHQTtBQVVBO0FBR0E7QUFnTEE7QUEyRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQU1BO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFlQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTRCQTtBQVVBO0FBSUE7QUFHQTtBQUhBO0FBMkJBO0FBQ0E7QUFDQTtBQUNBO0FBb0JBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWdHQTtBQU9BO0FBV0E7QUEwT0E7QUFDQTtBQUNBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFXQTtBQWtCQTtBQUtBO0FBQ0E7QUE0RUE7QUFBQTtBQXVRQTtBQXlCQTtBQUNBO0FBeVJBO0FBaU5BO0FBWUE7QUFFQTtBQTJCQTtBQU9BO0FBcUhBO0FBK0ZBO0FBdUpBO0FBMkNBO0FBR0E7QUFHQTtBQTBCQTtBQUNBO0FBT0E7QUFpSUE7QUE4WEE7QUFDQTtBQUNBO0FBb0NBO0FBc2dCQTtBQVVBO0FBQ0E7QUE0QkE7QUFDQTtBQW1DQTtBQUdBO0FBQUE7QUFHQTtBQTBCQTtBQWVBO0FBT0E7QUFjQTtBQUFBO0FBVUE7QUFBQTtBQVBBO0FBcUJBO0FBQ0E7QUFBQTtBQVVBO0FBQUE7QUFQQTtBQTBGQTtBQWtOQTtBQUlBO0FBaVlBO0FBV0E7QUF3RkE7QUE0R0E7QUEyR0E7QUFtRkE7QUFtSUE7QUFvREE7QUFDQTtBQUNBO0FBQ0E7QUFVQTtBQU1BO0FBQ0E7QUFDQTtBQXVDQTtBQW9GQTtBQWdEQTtBQXFOQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWdRQTtBQTJEQTtBQTJJQTtBQU9BO0FBb0JBO0FBQ0E7QUF5QkE7QUF1REE7QUE0SkE7QUFLQTtBQThLQTtBQUlBO0FBc0lBO0FBNEpBO0FBNkRBO0FBQ0E7QUFBQTtBQVFBO0FBK0VBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/vendor/d3.js\n");

/***/ }),

/***/ "./src/vendor/dc.js":
/*!**************************!*\
  !*** ./src/vendor/dc.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*!\r\n *  dc 3.0.6\r\n *  http://dc-js.github.io/dc.js/\r\n *  Copyright 2012-2016 Nick Zhu & the dc.js Developers\r\n *  https://github.com/dc-js/dc.js/blob/master/AUTHORS\r\n *\r\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n *  you may not use this file except in compliance with the License.\r\n *  You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n *  Unless required by applicable law or agreed to in writing, software\r\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n *  See the License for the specific language governing permissions and\r\n *  limitations under the License.\r\n */\n\n\n\n/**\r\n * The entire dc.js library is scoped under the **dc** name space. It does not introduce\r\n * anything else into the global name space.\r\n *\r\n * Most `dc` functions are designed to allow function chaining, meaning they return the current chart\r\n * instance whenever it is appropriate.  The getter forms of functions do not participate in function\r\n * chaining because they return values that are not the chart, although some,\r\n * such as {@link dc.baseMixin#svg .svg} and {@link dc.coordinateGridMixin#xAxis .xAxis},\r\n * return values that are themselves chainable d3 objects.\r\n * @namespace dc\r\n * @version 3.0.6\r\n * @example\r\n * // Example chaining\r\n * chart.width(300)\r\n *      .height(300)\r\n *      .filter('sunday');\r\n */\n/*jshint -W079*/\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.dc = undefined;\n\nvar _crossfilter = __webpack_require__(/*! ./crossfilter.js */ \"./src/vendor/crossfilter.js\");\n\nvar _d = __webpack_require__(/*! ./d3.js */ \"./src/vendor/d3.js\");\n\nvar dc = {\n    version: '3.0.6',\n    constants: {\n        CHART_CLASS: 'dc-chart',\n        DEBUG_GROUP_CLASS: 'debug',\n        STACK_CLASS: 'stack',\n        DESELECTED_CLASS: 'deselected',\n        SELECTED_CLASS: 'selected',\n        NODE_INDEX_NAME: '__index__',\n        GROUP_INDEX_NAME: '__group_index__',\n        DEFAULT_CHART_GROUP: '__default_chart_group__',\n        EVENT_DELAY: 40,\n        NEGLIGIBLE_NUMBER: 1e-10\n    },\n    _renderlet: null\n};\n/*jshint +W079*/\n\n/**\r\n * The dc.chartRegistry object maintains sets of all instantiated dc.js charts under named groups\r\n * and the default group.\r\n *\r\n * A chart group often corresponds to a crossfilter instance. It specifies\r\n * the set of charts which should be updated when a filter changes on one of the charts or when the\r\n * global functions {@link dc.filterAll dc.filterAll}, {@link dc.refocusAll dc.refocusAll},\r\n * {@link dc.renderAll dc.renderAll}, {@link dc.redrawAll dc.redrawAll}, or chart functions\r\n * {@link dc.baseMixin#renderGroup baseMixin.renderGroup},\r\n * {@link dc.baseMixin#redrawGroup baseMixin.redrawGroup} are called.\r\n *\r\n * @namespace chartRegistry\r\n * @memberof dc\r\n * @type {{has, register, deregister, clear, list}}\r\n */\ndc.chartRegistry = function () {\n    // chartGroup:string => charts:array\n    var _chartMap = {};\n\n    function initializeChartGroup(group) {\n        if (!group) {\n            group = dc.constants.DEFAULT_CHART_GROUP;\n        }\n\n        if (!_chartMap[group]) {\n            _chartMap[group] = [];\n        }\n\n        return group;\n    }\n\n    return {\n        /**\r\n         * Determine if a given chart instance resides in any group in the registry.\r\n         * @method has\r\n         * @memberof dc.chartRegistry\r\n         * @param {Object} chart dc.js chart instance\r\n         * @returns {Boolean}\r\n         */\n        has: function has(chart) {\n            for (var e in _chartMap) {\n                if (_chartMap[e].indexOf(chart) >= 0) {\n                    return true;\n                }\n            }\n            return false;\n        },\n\n        /**\r\n         * Add given chart instance to the given group, creating the group if necessary.\r\n         * If no group is provided, the default group `dc.constants.DEFAULT_CHART_GROUP` will be used.\r\n         * @method register\r\n         * @memberof dc.chartRegistry\r\n         * @param {Object} chart dc.js chart instance\r\n         * @param {String} [group] Group name\r\n         */\n        register: function register(chart, group) {\n            group = initializeChartGroup(group);\n            _chartMap[group].push(chart);\n        },\n\n        /**\r\n         * Remove given chart instance from the given group, creating the group if necessary.\r\n         * If no group is provided, the default group `dc.constants.DEFAULT_CHART_GROUP` will be used.\r\n         * @method deregister\r\n         * @memberof dc.chartRegistry\r\n         * @param {Object} chart dc.js chart instance\r\n         * @param {String} [group] Group name\r\n         */\n        deregister: function deregister(chart, group) {\n            group = initializeChartGroup(group);\n            for (var i = 0; i < _chartMap[group].length; i++) {\n                if (_chartMap[group][i].anchorName() === chart.anchorName()) {\n                    _chartMap[group].splice(i, 1);\n                    break;\n                }\n            }\n        },\n\n        /**\r\n         * Clear given group if one is provided, otherwise clears all groups.\r\n         * @method clear\r\n         * @memberof dc.chartRegistry\r\n         * @param {String} group Group name\r\n         */\n        clear: function clear(group) {\n            if (group) {\n                delete _chartMap[group];\n            } else {\n                _chartMap = {};\n            }\n        },\n\n        /**\r\n         * Get an array of each chart instance in the given group.\r\n         * If no group is provided, the charts in the default group are returned.\r\n         * @method list\r\n         * @memberof dc.chartRegistry\r\n         * @param {String} [group] Group name\r\n         * @returns {Array<Object>}\r\n         */\n        list: function list(group) {\n            group = initializeChartGroup(group);\n            return _chartMap[group];\n        }\n    };\n}();\n\n/**\r\n * Add given chart instance to the given group, creating the group if necessary.\r\n * If no group is provided, the default group `dc.constants.DEFAULT_CHART_GROUP` will be used.\r\n * @memberof dc\r\n * @method registerChart\r\n * @param {Object} chart dc.js chart instance\r\n * @param {String} [group] Group name\r\n */\ndc.registerChart = function (chart, group) {\n    dc.chartRegistry.register(chart, group);\n};\n\n/**\r\n * Remove given chart instance from the given group, creating the group if necessary.\r\n * If no group is provided, the default group `dc.constants.DEFAULT_CHART_GROUP` will be used.\r\n * @memberof dc\r\n * @method deregisterChart\r\n * @param {Object} chart dc.js chart instance\r\n * @param {String} [group] Group name\r\n */\ndc.deregisterChart = function (chart, group) {\n    dc.chartRegistry.deregister(chart, group);\n};\n\n/**\r\n * Determine if a given chart instance resides in any group in the registry.\r\n * @memberof dc\r\n * @method hasChart\r\n * @param {Object} chart dc.js chart instance\r\n * @returns {Boolean}\r\n */\ndc.hasChart = function (chart) {\n    return dc.chartRegistry.has(chart);\n};\n\n/**\r\n * Clear given group if one is provided, otherwise clears all groups.\r\n * @memberof dc\r\n * @method deregisterAllCharts\r\n * @param {String} group Group name\r\n */\ndc.deregisterAllCharts = function (group) {\n    dc.chartRegistry.clear(group);\n};\n\n/**\r\n * Clear all filters on all charts within the given chart group. If the chart group is not given then\r\n * only charts that belong to the default chart group will be reset.\r\n * @memberof dc\r\n * @method filterAll\r\n * @param {String} [group]\r\n */\ndc.filterAll = function (group) {\n    var charts = dc.chartRegistry.list(group);\n    for (var i = 0; i < charts.length; ++i) {\n        charts[i].filterAll();\n    }\n};\n\n/**\r\n * Reset zoom level / focus on all charts that belong to the given chart group. If the chart group is\r\n * not given then only charts that belong to the default chart group will be reset.\r\n * @memberof dc\r\n * @method refocusAll\r\n * @param {String} [group]\r\n */\ndc.refocusAll = function (group) {\n    var charts = dc.chartRegistry.list(group);\n    for (var i = 0; i < charts.length; ++i) {\n        if (charts[i].focus) {\n            charts[i].focus();\n        }\n    }\n};\n\n/**\r\n * Re-render all charts belong to the given chart group. If the chart group is not given then only\r\n * charts that belong to the default chart group will be re-rendered.\r\n * @memberof dc\r\n * @method renderAll\r\n * @param {String} [group]\r\n */\ndc.renderAll = function (group) {\n    var charts = dc.chartRegistry.list(group);\n    for (var i = 0; i < charts.length; ++i) {\n        charts[i].render();\n    }\n\n    if (dc._renderlet !== null) {\n        dc._renderlet(group);\n    }\n};\n\n/**\r\n * Redraw all charts belong to the given chart group. If the chart group is not given then only charts\r\n * that belong to the default chart group will be re-drawn. Redraw is different from re-render since\r\n * when redrawing dc tries to update the graphic incrementally, using transitions, instead of starting\r\n * from scratch.\r\n * @memberof dc\r\n * @method redrawAll\r\n * @param {String} [group]\r\n */\ndc.redrawAll = function (group) {\n    var charts = dc.chartRegistry.list(group);\n    for (var i = 0; i < charts.length; ++i) {\n        charts[i].redraw();\n    }\n\n    if (dc._renderlet !== null) {\n        dc._renderlet(group);\n    }\n};\n\n/**\r\n * If this boolean is set truthy, all transitions will be disabled, and changes to the charts will happen\r\n * immediately.\r\n * @memberof dc\r\n * @member disableTransitions\r\n * @type {Boolean}\r\n * @default false\r\n */\ndc.disableTransitions = false;\n\n/**\r\n * Start a transition on a selection if transitions are globally enabled\r\n * ({@link dc.disableTransitions} is false) and the duration is greater than zero; otherwise return\r\n * the selection. Since most operations are the same on a d3 selection and a d3 transition, this\r\n * allows a common code path for both cases.\r\n * @memberof dc\r\n * @method transition\r\n * @param {d3.selection} selection - the selection to be transitioned\r\n * @param {Number|Function} [duration=250] - the duration of the transition in milliseconds, a\r\n * function returning the duration, or 0 for no transition\r\n * @param {Number|Function} [delay] - the delay of the transition in milliseconds, or a function\r\n * returning the delay, or 0 for no delay\r\n * @param {String} [name] - the name of the transition (if concurrent transitions on the same\r\n * elements are needed)\r\n * @returns {d3.transition|d3.selection}\r\n */\ndc.transition = function (selection, duration, delay, name) {\n    if (dc.disableTransitions || duration <= 0) {\n        return selection;\n    }\n\n    var s = selection.transition(name);\n\n    if (duration >= 0 || duration !== undefined) {\n        s = s.duration(duration);\n    }\n    if (delay >= 0 || delay !== undefined) {\n        s = s.delay(delay);\n    }\n\n    return s;\n};\n\n/* somewhat silly, but to avoid duplicating logic */\ndc.optionalTransition = function (enable, duration, delay, name) {\n    if (enable) {\n        return function (selection) {\n            return dc.transition(selection, duration, delay, name);\n        };\n    } else {\n        return function (selection) {\n            return selection;\n        };\n    }\n};\n\n// See http://stackoverflow.com/a/20773846\ndc.afterTransition = function (transition, callback) {\n    if (transition.empty() || !transition.duration) {\n        callback.call(transition);\n    } else {\n        var n = 0;\n        transition.each(function () {\n            ++n;\n        }).on('end', function () {\n            if (! --n) {\n                callback.call(transition);\n            }\n        });\n    }\n};\n\n/**\r\n * @namespace units\r\n * @memberof dc\r\n * @type {{}}\r\n */\ndc.units = {};\n\n/**\r\n * The default value for {@link dc.coordinateGridMixin#xUnits .xUnits} for the\r\n * {@link dc.coordinateGridMixin Coordinate Grid Chart} and should\r\n * be used when the x values are a sequence of integers.\r\n * It is a function that counts the number of integers in the range supplied in its start and end parameters.\r\n * @method integers\r\n * @memberof dc.units\r\n * @see {@link dc.coordinateGridMixin#xUnits coordinateGridMixin.xUnits}\r\n * @example\r\n * chart.xUnits(dc.units.integers) // already the default\r\n * @param {Number} start\r\n * @param {Number} end\r\n * @returns {Number}\r\n */\ndc.units.integers = function (start, end) {\n    return Math.abs(end - start);\n};\n\n/**\r\n * This argument can be passed to the {@link dc.coordinateGridMixin#xUnits .xUnits} function of a\r\n * coordinate grid chart to specify ordinal units for the x axis. Usually this parameter is used in\r\n * combination with passing\r\n * {@link https://github.com/d3/d3-scale/blob/master/README.md#ordinal-scales d3.scaleOrdinal}\r\n * to {@link dc.coordinateGridMixin#x .x}.\r\n *\r\n * As of dc.js 3.0, this is purely a placeholder or magic value which causes the chart to go into ordinal mode; the\r\n * function is not called.\r\n * @method ordinal\r\n * @memberof dc.units\r\n * @see {@link https://github.com/d3/d3-scale/blob/master/README.md#ordinal-scales d3.scaleOrdinal}\r\n * @see {@link dc.coordinateGridMixin#xUnits coordinateGridMixin.xUnits}\r\n * @see {@link dc.coordinateGridMixin#x coordinateGridMixin.x}\r\n * @example\r\n * chart.xUnits(dc.units.ordinal)\r\n *      .x(d3.scaleOrdinal())\r\n */\ndc.units.ordinal = function () {\n    throw new Error('dc.units.ordinal should not be called - it is a placeholder');\n};\n\n/**\r\n * @namespace fp\r\n * @memberof dc.units\r\n * @type {{}}\r\n */\ndc.units.fp = {};\n/**\r\n * This function generates an argument for the {@link dc.coordinateGridMixin Coordinate Grid Chart}\r\n * {@link dc.coordinateGridMixin#xUnits .xUnits} function specifying that the x values are floating-point\r\n * numbers with the given precision.\r\n * The returned function determines how many values at the given precision will fit into the range\r\n * supplied in its start and end parameters.\r\n * @method precision\r\n * @memberof dc.units.fp\r\n * @see {@link dc.coordinateGridMixin#xUnits coordinateGridMixin.xUnits}\r\n * @example\r\n * // specify values (and ticks) every 0.1 units\r\n * chart.xUnits(dc.units.fp.precision(0.1)\r\n * // there are 500 units between 0.5 and 1 if the precision is 0.001\r\n * var thousandths = dc.units.fp.precision(0.001);\r\n * thousandths(0.5, 1.0) // returns 500\r\n * @param {Number} precision\r\n * @returns {Function} start-end unit function\r\n */\ndc.units.fp.precision = function (precision) {\n    var _f = function _f(s, e) {\n        var d = Math.abs((e - s) / _f.resolution);\n        if (dc.utils.isNegligible(d - Math.floor(d))) {\n            return Math.floor(d);\n        } else {\n            return Math.ceil(d);\n        }\n    };\n    _f.resolution = precision;\n    return _f;\n};\n\ndc.round = {};\ndc.round.floor = function (n) {\n    return Math.floor(n);\n};\ndc.round.ceil = function (n) {\n    return Math.ceil(n);\n};\ndc.round.round = function (n) {\n    return Math.round(n);\n};\n\ndc.override = function (obj, functionName, newFunction) {\n    var existingFunction = obj[functionName];\n    obj['_' + functionName] = existingFunction;\n    obj[functionName] = newFunction;\n};\n\ndc.renderlet = function (_) {\n    if (!arguments.length) {\n        return dc._renderlet;\n    }\n    dc._renderlet = _;\n    return dc;\n};\n\ndc.instanceOfChart = function (o) {\n    return o instanceof Object && o.__dcFlag__ && true;\n};\n\ndc.errors = {};\n\ndc.errors.Exception = function (msg) {\n    var _msg = msg || 'Unexpected internal error';\n\n    this.message = _msg;\n\n    this.toString = function () {\n        return _msg;\n    };\n    this.stack = new Error().stack;\n};\ndc.errors.Exception.prototype = Object.create(Error.prototype);\ndc.errors.Exception.prototype.constructor = dc.errors.Exception;\n\ndc.errors.InvalidStateException = function () {\n    dc.errors.Exception.apply(this, arguments);\n};\n\ndc.errors.InvalidStateException.prototype = Object.create(dc.errors.Exception.prototype);\ndc.errors.InvalidStateException.prototype.constructor = dc.errors.InvalidStateException;\n\ndc.errors.BadArgumentException = function () {\n    dc.errors.Exception.apply(this, arguments);\n};\n\ndc.errors.BadArgumentException.prototype = Object.create(dc.errors.Exception.prototype);\ndc.errors.BadArgumentException.prototype.constructor = dc.errors.BadArgumentException;\n\n/**\r\n * The default date format for dc.js\r\n * @name dateFormat\r\n * @memberof dc\r\n * @type {Function}\r\n * @default d3.timeFormat('%m/%d/%Y')\r\n */\ndc.dateFormat = _d.d3.timeFormat('%m/%d/%Y');\n\n/**\r\n * @namespace printers\r\n * @memberof dc\r\n * @type {{}}\r\n */\ndc.printers = {};\n\n/**\r\n * Converts a list of filters into a readable string.\r\n * @method filters\r\n * @memberof dc.printers\r\n * @param {Array<dc.filters>} filters\r\n * @returns {String}\r\n */\ndc.printers.filters = function (filters) {\n    var s = '';\n\n    for (var i = 0; i < filters.length; ++i) {\n        if (i > 0) {\n            s += ', ';\n        }\n        s += dc.printers.filter(filters[i]);\n    }\n\n    return s;\n};\n\n/**\r\n * Converts a filter into a readable string.\r\n * @method filter\r\n * @memberof dc.printers\r\n * @param {dc.filters|any|Array<any>} filter\r\n * @returns {String}\r\n */\ndc.printers.filter = function (filter) {\n    var s = '';\n\n    if (typeof filter !== 'undefined' && filter !== null) {\n        if (filter instanceof Array) {\n            if (filter.length >= 2) {\n                s = '[' + dc.utils.printSingleValue(filter[0]) + ' -> ' + dc.utils.printSingleValue(filter[1]) + ']';\n            } else if (filter.length >= 1) {\n                s = dc.utils.printSingleValue(filter[0]);\n            }\n        } else {\n            s = dc.utils.printSingleValue(filter);\n        }\n    }\n\n    return s;\n};\n\n/**\r\n * Returns a function that given a string property name, can be used to pluck the property off an object.  A function\r\n * can be passed as the second argument to also alter the data being returned.\r\n *\r\n * This can be a useful shorthand method to create accessor functions.\r\n * @method pluck\r\n * @memberof dc\r\n * @example\r\n * var xPluck = dc.pluck('x');\r\n * var objA = {x: 1};\r\n * xPluck(objA) // 1\r\n * @example\r\n * var xPosition = dc.pluck('x', function (x, i) {\r\n *     // `this` is the original datum,\r\n *     // `x` is the x property of the datum,\r\n *     // `i` is the position in the array\r\n *     return this.radius + x;\r\n * });\r\n * dc.selectAll('.circle').data(...).x(xPosition);\r\n * @param {String} n\r\n * @param {Function} [f]\r\n * @returns {Function}\r\n */\ndc.pluck = function (n, f) {\n    if (!f) {\n        return function (d) {\n            return d[n];\n        };\n    }\n    return function (d, i) {\n        return f.call(d, d[n], i);\n    };\n};\n\n/**\r\n * @namespace utils\r\n * @memberof dc\r\n * @type {{}}\r\n */\ndc.utils = {};\n\n/**\r\n * Print a single value filter.\r\n * @method printSingleValue\r\n * @memberof dc.utils\r\n * @param {any} filter\r\n * @returns {String}\r\n */\ndc.utils.printSingleValue = function (filter) {\n    var s = '' + filter;\n\n    if (filter instanceof Date) {\n        s = dc.dateFormat(filter);\n    } else if (typeof filter === 'string') {\n        s = filter;\n    } else if (dc.utils.isFloat(filter)) {\n        s = dc.utils.printSingleValue.fformat(filter);\n    } else if (dc.utils.isInteger(filter)) {\n        s = Math.round(filter);\n    }\n\n    return s;\n};\ndc.utils.printSingleValue.fformat = _d.d3.format('.2f');\n\n// convert 'day' to 'timeDay' and similar\ndc.utils.toTimeFunc = function (t) {\n    return 'time' + t.charAt(0).toUpperCase() + t.slice(1);\n};\n\n/**\r\n * Arbitrary add one value to another.\r\n *\r\n * If the value l is of type Date, adds r units to it. t becomes the unit.\r\n * For example dc.utils.add(dt, 3, 'week') will add 3 (r = 3) weeks (t= 'week') to dt.\r\n *\r\n * If l is of type numeric, t is ignored. In this case if r is of type string,\r\n * it is assumed to be percentage (whether or not it includes %). For example\r\n * dc.utils.add(30, 10) will give 40 and dc.utils.add(30, '10') will give 33.\r\n *\r\n * They also generate strange results if l is a string.\r\n * @method add\r\n * @memberof dc.utils\r\n * @param {Date|Number} l the value to modify\r\n * @param {String|Number} r the amount by which to modify the value\r\n * @param {Function|String} [t=d3.timeDay] if `l` is a `Date`, then this should be a\r\n * [d3 time interval](https://github.com/d3/d3-time/blob/master/README.md#_interval).\r\n * For backward compatibility with dc.js 2.0, it can also be the name of an interval, i.e.\r\n * 'millis', 'second', 'minute', 'hour', 'day', 'week', 'month', or 'year'\r\n * @returns {Date|Number}\r\n */\ndc.utils.add = function (l, r, t) {\n    if (typeof r === 'string') {\n        r = r.replace('%', '');\n    }\n\n    if (l instanceof Date) {\n        if (typeof r === 'string') {\n            r = +r;\n        }\n        if (t === 'millis') {\n            return new Date(l.getTime() + r);\n        }\n        t = t || _d.d3.timeDay;\n        if (typeof t !== 'function') {\n            t = _d.d3[dc.utils.toTimeFunc(t)];\n        }\n        return t.offset(l, r);\n    } else if (typeof r === 'string') {\n        var percentage = +r / 100;\n        return l > 0 ? l * (1 + percentage) : l * (1 - percentage);\n    } else {\n        return l + r;\n    }\n};\n\n/**\r\n * Arbitrary subtract one value from another.\r\n *\r\n * If the value l is of type Date, subtracts r units from it. t becomes the unit.\r\n * For example dc.utils.subtract(dt, 3, 'week') will subtract 3 (r = 3) weeks (t= 'week') from dt.\r\n *\r\n * If l is of type numeric, t is ignored. In this case if r is of type string,\r\n * it is assumed to be percentage (whether or not it includes %). For example\r\n * dc.utils.subtract(30, 10) will give 20 and dc.utils.subtract(30, '10') will give 27.\r\n *\r\n * They also generate strange results if l is a string.\r\n * @method subtract\r\n * @memberof dc.utils\r\n * @param {Date|Number} l the value to modify\r\n * @param {String|Number} r the amount by which to modify the value\r\n * @param {Function|String} [t=d3.timeDay] if `l` is a `Date`, then this should be a\r\n * [d3 time interval](https://github.com/d3/d3-time/blob/master/README.md#_interval).\r\n * For backward compatibility with dc.js 2.0, it can also be the name of an interval, i.e.\r\n * 'millis', 'second', 'minute', 'hour', 'day', 'week', 'month', or 'year'\r\n * @returns {Date|Number}\r\n */\ndc.utils.subtract = function (l, r, t) {\n    if (typeof r === 'string') {\n        r = r.replace('%', '');\n    }\n\n    if (l instanceof Date) {\n        if (typeof r === 'string') {\n            r = +r;\n        }\n        if (t === 'millis') {\n            return new Date(l.getTime() - r);\n        }\n        t = t || _d.d3.timeDay;\n        if (typeof t !== 'function') {\n            t = _d.d3[dc.utils.toTimeFunc(t)];\n        }\n        return t.offset(l, -r);\n    } else if (typeof r === 'string') {\n        var percentage = +r / 100;\n        return l < 0 ? l * (1 + percentage) : l * (1 - percentage);\n    } else {\n        return l - r;\n    }\n};\n\n/**\r\n * Is the value a number?\r\n * @method isNumber\r\n * @memberof dc.utils\r\n * @param {any} n\r\n * @returns {Boolean}\r\n */\ndc.utils.isNumber = function (n) {\n    return n === +n;\n};\n\n/**\r\n * Is the value a float?\r\n * @method isFloat\r\n * @memberof dc.utils\r\n * @param {any} n\r\n * @returns {Boolean}\r\n */\ndc.utils.isFloat = function (n) {\n    return n === +n && n !== (n | 0);\n};\n\n/**\r\n * Is the value an integer?\r\n * @method isInteger\r\n * @memberof dc.utils\r\n * @param {any} n\r\n * @returns {Boolean}\r\n */\ndc.utils.isInteger = function (n) {\n    return n === +n && n === (n | 0);\n};\n\n/**\r\n * Is the value very close to zero?\r\n * @method isNegligible\r\n * @memberof dc.utils\r\n * @param {any} n\r\n * @returns {Boolean}\r\n */\ndc.utils.isNegligible = function (n) {\n    return !dc.utils.isNumber(n) || n < dc.constants.NEGLIGIBLE_NUMBER && n > -dc.constants.NEGLIGIBLE_NUMBER;\n};\n\n/**\r\n * Ensure the value is no greater or less than the min/max values.  If it is return the boundary value.\r\n * @method clamp\r\n * @memberof dc.utils\r\n * @param {any} val\r\n * @param {any} min\r\n * @param {any} max\r\n * @returns {any}\r\n */\ndc.utils.clamp = function (val, min, max) {\n    return val < min ? min : val > max ? max : val;\n};\n\n/**\r\n * Given `x`, return a function that always returns `x`.\r\n *\r\n * {@link https://github.com/d3/d3/blob/master/CHANGES.md#internals `d3.functor` was removed in d3 version 4}.\r\n * This function helps to implement the replacement,\r\n * `typeof x === \"function\" ? x : dc.utils.constant(x)`\r\n * @method constant\r\n * @memberof dc.utils\r\n * @param {any} x\r\n * @returns {Function}\r\n */\ndc.utils.constant = function (x) {\n    return function () {\n        return x;\n    };\n};\n\n/**\r\n * Using a simple static counter, provide a unique integer id.\r\n * @method uniqueId\r\n * @memberof dc.utils\r\n * @returns {Number}\r\n */\nvar _idCounter = 0;\ndc.utils.uniqueId = function () {\n    return ++_idCounter;\n};\n\n/**\r\n * Convert a name to an ID.\r\n * @method nameToId\r\n * @memberof dc.utils\r\n * @param {String} name\r\n * @returns {String}\r\n */\ndc.utils.nameToId = function (name) {\n    return name.toLowerCase().replace(/[\\s]/g, '_').replace(/[\\.']/g, '');\n};\n\n/**\r\n * Append or select an item on a parent element.\r\n * @method appendOrSelect\r\n * @memberof dc.utils\r\n * @param {d3.selection} parent\r\n * @param {String} selector\r\n * @param {String} tag\r\n * @returns {d3.selection}\r\n */\ndc.utils.appendOrSelect = function (parent, selector, tag) {\n    tag = tag || selector;\n    var element = parent.select(selector);\n    if (element.empty()) {\n        element = parent.append(tag);\n    }\n    return element;\n};\n\n/**\r\n * Return the number if the value is a number; else 0.\r\n * @method safeNumber\r\n * @memberof dc.utils\r\n * @param {Number|any} n\r\n * @returns {Number}\r\n */\ndc.utils.safeNumber = function (n) {\n    return dc.utils.isNumber(+n) ? +n : 0;\n};\n\n/**\r\n * Return true if both arrays are equal, if both array are null these are considered equal\r\n * @method arraysEqual\r\n * @memberof dc.utils\r\n * @param {Array|null} a1\r\n * @param {Array|null} a2\r\n * @returns {Boolean}\r\n */\ndc.utils.arraysEqual = function (a1, a2) {\n    if (!a1 && !a2) {\n        return true;\n    }\n\n    if (!a1 || !a2) {\n        return false;\n    }\n\n    return a1.length === a2.length &&\n    // If elements are not integers/strings, we hope that it will match because of toString\n    // Test cases cover dates as well.\n    a1.every(function (elem, i) {\n        return elem.valueOf() === a2[i].valueOf();\n    });\n};\n\n// ******** Sunburst Chart ********\ndc.utils.allChildren = function (node) {\n    var paths = [];\n    paths.push(node.path);\n    console.log('currentNode', node);\n    if (node.children) {\n        for (var i = 0; i < node.children.length; i++) {\n            paths = paths.concat(dc.utils.allChildren(node.children[i]));\n        }\n    }\n    return paths;\n};\n\n// builds a d3 Hierarchy from a collection\n// TODO: turn this monster method something better.\ndc.utils.toHierarchy = function (list, accessor) {\n    var root = { 'key': 'root', 'children': [] };\n    for (var i = 0; i < list.length; i++) {\n        var data = list[i];\n        var parts = data.key;\n        var value = accessor(data);\n        var currentNode = root;\n        for (var j = 0; j < parts.length; j++) {\n            var currentPath = parts.slice(0, j + 1);\n            var children = currentNode.children;\n            var nodeName = parts[j];\n            var childNode;\n            if (j + 1 < parts.length) {\n                // Not yet at the end of the sequence; move down the tree.\n                childNode = findChild(children, nodeName);\n\n                // If we don't already have a child node for this branch, create it.\n                if (childNode === void 0) {\n                    childNode = { 'key': nodeName, 'children': [], 'path': currentPath };\n                    children.push(childNode);\n                }\n                currentNode = childNode;\n            } else {\n                // Reached the end of the sequence; create a leaf node.\n                childNode = { 'key': nodeName, 'value': value, 'data': data, 'path': currentPath };\n                children.push(childNode);\n            }\n        }\n    }\n    return root;\n};\n\nfunction findChild(children, nodeName) {\n    for (var k = 0; k < children.length; k++) {\n        if (children[k].key === nodeName) {\n            return children[k];\n        }\n    }\n}\n\ndc.utils.getAncestors = function (node) {\n    var path = [];\n    var current = node;\n    while (current.parent) {\n        path.unshift(current.name);\n        current = current.parent;\n    }\n    return path;\n};\n\ndc.utils.arraysIdentical = function (a, b) {\n    var i = a.length;\n    if (i !== b.length) {\n        return false;\n    }\n    while (i--) {\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n    return true;\n};\n\n/**\r\n * Provides basis logging and deprecation utilities\r\n * @class logger\r\n * @memberof dc\r\n * @returns {dc.logger}\r\n */\ndc.logger = function () {\n\n    var _logger = {};\n\n    /**\r\n     * Enable debug level logging. Set to `false` by default.\r\n     * @name enableDebugLog\r\n     * @memberof dc.logger\r\n     * @instance\r\n     */\n    _logger.enableDebugLog = false;\n\n    /**\r\n     * Put a warning message to console\r\n     * @method warn\r\n     * @memberof dc.logger\r\n     * @instance\r\n     * @example\r\n     * dc.logger.warn('Invalid use of .tension on CurveLinear');\r\n     * @param {String} [msg]\r\n     * @returns {dc.logger}\r\n     */\n    _logger.warn = function (msg) {\n        if (console) {\n            if (console.warn) {\n                console.warn(msg);\n            } else if (console.log) {\n                console.log(msg);\n            }\n        }\n\n        return _logger;\n    };\n\n    var _alreadyWarned = {};\n\n    /**\r\n     * Put a warning message to console. It will warn only on unique messages.\r\n     * @method warnOnce\r\n     * @memberof dc.logger\r\n     * @instance\r\n     * @example\r\n     * dc.logger.warnOnce('Invalid use of .tension on CurveLinear');\r\n     * @param {String} [msg]\r\n     * @returns {dc.logger}\r\n     */\n    _logger.warnOnce = function (msg) {\n        if (!_alreadyWarned[msg]) {\n            _alreadyWarned[msg] = true;\n\n            dc.logger.warn(msg);\n        }\n\n        return _logger;\n    };\n\n    /**\r\n     * Put a debug message to console. It is controlled by `dc.logger.enableDebugLog`\r\n     * @method debug\r\n     * @memberof dc.logger\r\n     * @instance\r\n     * @example\r\n     * dc.logger.debug('Total number of slices: ' + numSlices);\r\n     * @param {String} [msg]\r\n     * @returns {dc.logger}\r\n     */\n    _logger.debug = function (msg) {\n        if (_logger.enableDebugLog && console) {\n            if (console.debug) {\n                console.debug(msg);\n            } else if (console.log) {\n                console.log(msg);\n            }\n        }\n\n        return _logger;\n    };\n\n    /**\r\n     * Use it to deprecate a function. It will return a wrapped version of the function, which will\r\n     * will issue a warning when invoked. For each function, warning will be issued only once.\r\n     *\r\n     * @method deprecate\r\n     * @memberof dc.logger\r\n     * @instance\r\n     * @example\r\n     * _chart.interpolate = dc.logger.deprecate(function (interpolate) {\r\n     *    if (!arguments.length) {\r\n     *        return _interpolate;\r\n     *    }\r\n     *    _interpolate = interpolate;\r\n     *    return _chart;\r\n     * }, 'dc.lineChart.interpolate has been deprecated since version 3.0 use dc.lineChart.curve instead');\r\n     * @param {Function} [fn]\r\n     * @param {String} [msg]\r\n     * @returns {Function}\r\n     */\n    _logger.deprecate = function (fn, msg) {\n        // Allow logging of deprecation\n        var warned = false;\n        function deprecated() {\n            if (!warned) {\n                _logger.warn(msg);\n                warned = true;\n            }\n            return fn.apply(this, arguments);\n        }\n        return deprecated;\n    };\n\n    return _logger;\n}();\n\n/**\r\n * General configuration\r\n *\r\n * @class config\r\n * @memberof dc\r\n * @returns {dc.config}\r\n */\ndc.config = function () {\n    var _config = {};\n\n    // D3v5 has removed schemeCategory20c, copied here for backward compatibility\n    var _schemeCategory20c = ['#3182bd', '#6baed6', '#9ecae1', '#c6dbef', '#e6550d', '#fd8d3c', '#fdae6b', '#fdd0a2', '#31a354', '#74c476', '#a1d99b', '#c7e9c0', '#756bb1', '#9e9ac8', '#bcbddc', '#dadaeb', '#636363', '#969696', '#bdbdbd', '#d9d9d9'];\n\n    var _defaultColors = _schemeCategory20c;\n\n    /**\r\n     * Set the default color scheme for ordinal charts. Changing it will impact all ordinal charts.\r\n     *\r\n     * By default it is set to a copy of\r\n     * `d3.schemeCategory20c` for backward compatibility. This color scheme has been\r\n     * [removed from D3v5](https://github.com/d3/d3/blob/master/CHANGES.md#changes-in-d3-50).\r\n     * In DC 3.1 release it will change to a more appropriate default.\r\n     *\r\n     * @example\r\n     * dc.config.defaultColors(d3.schemeSet1)\r\n     * @method defaultColors\r\n     * @memberof dc.config\r\n     * @instance\r\n     * @param {Array} [colors]\r\n     * @returns {Array|dc.config}\r\n     */\n    _config.defaultColors = function (colors) {\n        if (!arguments.length) {\n            // Issue warning if it uses _schemeCategory20c\n            if (_defaultColors === _schemeCategory20c) {\n                dc.logger.warnOnce('You are using d3.schemeCategory20c, which has been removed in D3v5. ' + 'See the explanation at https://github.com/d3/d3/blob/master/CHANGES.md#changes-in-d3-50. ' + 'DC is using it for backward compatibility, however it will be changed in DCv3.1. ' + 'You can change it by calling dc.config.defaultColors(newScheme). ' + 'See https://github.com/d3/d3-scale-chromatic for some alternatives.');\n            }\n            return _defaultColors;\n        }\n        _defaultColors = colors;\n        return _config;\n    };\n\n    return _config;\n}();\n\ndc.events = {\n    current: null\n};\n\n/**\r\n * This function triggers a throttled event function with a specified delay (in milli-seconds).  Events\r\n * that are triggered repetitively due to user interaction such brush dragging might flood the library\r\n * and invoke more renders than can be executed in time. Using this function to wrap your event\r\n * function allows the library to smooth out the rendering by throttling events and only responding to\r\n * the most recent event.\r\n * @name events.trigger\r\n * @memberof dc\r\n * @example\r\n * chart.on('renderlet', function(chart) {\r\n *     // smooth the rendering through event throttling\r\n *     dc.events.trigger(function(){\r\n *         // focus some other chart to the range selected by user on this chart\r\n *         someOtherChart.focus(chart.filter());\r\n *     });\r\n * })\r\n * @param {Function} closure\r\n * @param {Number} [delay]\r\n */\ndc.events.trigger = function (closure, delay) {\n    if (!delay) {\n        closure();\n        return;\n    }\n\n    dc.events.current = closure;\n\n    setTimeout(function () {\n        if (closure === dc.events.current) {\n            closure();\n        }\n    }, delay);\n};\n\n/**\r\n * The dc.js filters are functions which are passed into crossfilter to chose which records will be\r\n * accumulated to produce values for the charts.  In the crossfilter model, any filters applied on one\r\n * dimension will affect all the other dimensions but not that one.  dc always applies a filter\r\n * function to the dimension; the function combines multiple filters and if any of them accept a\r\n * record, it is filtered in.\r\n *\r\n * These filter constructors are used as appropriate by the various charts to implement brushing.  We\r\n * mention below which chart uses which filter.  In some cases, many instances of a filter will be added.\r\n *\r\n * Each of the dc.js filters is an object with the following properties:\r\n * * `isFiltered` - a function that returns true if a value is within the filter\r\n * * `filterType` - a string identifying the filter, here the name of the constructor\r\n *\r\n * Currently these filter objects are also arrays, but this is not a requirement. Custom filters\r\n * can be used as long as they have the properties above.\r\n * @namespace filters\r\n * @memberof dc\r\n * @type {{}}\r\n */\ndc.filters = {};\n\n/**\r\n * RangedFilter is a filter which accepts keys between `low` and `high`.  It is used to implement X\r\n * axis brushing for the {@link dc.coordinateGridMixin coordinate grid charts}.\r\n *\r\n * Its `filterType` is 'RangedFilter'\r\n * @name RangedFilter\r\n * @memberof dc.filters\r\n * @param {Number} low\r\n * @param {Number} high\r\n * @returns {Array<Number>}\r\n * @constructor\r\n */\ndc.filters.RangedFilter = function (low, high) {\n    var range = new Array(low, high);\n    range.isFiltered = function (value) {\n        return value >= this[0] && value < this[1];\n    };\n    range.filterType = 'RangedFilter';\n\n    return range;\n};\n\n/**\r\n * TwoDimensionalFilter is a filter which accepts a single two-dimensional value.  It is used by the\r\n * {@link dc.heatMap heat map chart} to include particular cells as they are clicked.  (Rows and columns are\r\n * filtered by filtering all the cells in the row or column.)\r\n *\r\n * Its `filterType` is 'TwoDimensionalFilter'\r\n * @name TwoDimensionalFilter\r\n * @memberof dc.filters\r\n * @param {Array<Number>} filter\r\n * @returns {Array<Number>}\r\n * @constructor\r\n */\ndc.filters.TwoDimensionalFilter = function (filter) {\n    if (filter === null) {\n        return null;\n    }\n\n    var f = filter;\n    f.isFiltered = function (value) {\n        return value.length && value.length === f.length && value[0] === f[0] && value[1] === f[1];\n    };\n    f.filterType = 'TwoDimensionalFilter';\n\n    return f;\n};\n\n/**\r\n * The RangedTwoDimensionalFilter allows filtering all values which fit within a rectangular\r\n * region. It is used by the {@link dc.scatterPlot scatter plot} to implement rectangular brushing.\r\n *\r\n * It takes two two-dimensional points in the form `[[x1,y1],[x2,y2]]`, and normalizes them so that\r\n * `x1 <= x2` and `y1 <= y2`. It then returns a filter which accepts any points which are in the\r\n * rectangular range including the lower values but excluding the higher values.\r\n *\r\n * If an array of two values are given to the RangedTwoDimensionalFilter, it interprets the values as\r\n * two x coordinates `x1` and `x2` and returns a filter which accepts any points for which `x1 <= x <\r\n * x2`.\r\n *\r\n * Its `filterType` is 'RangedTwoDimensionalFilter'\r\n * @name RangedTwoDimensionalFilter\r\n * @memberof dc.filters\r\n * @param {Array<Array<Number>>} filter\r\n * @returns {Array<Array<Number>>}\r\n * @constructor\r\n */\ndc.filters.RangedTwoDimensionalFilter = function (filter) {\n    if (filter === null) {\n        return null;\n    }\n\n    var f = filter;\n    var fromBottomLeft;\n\n    if (f[0] instanceof Array) {\n        fromBottomLeft = [[Math.min(filter[0][0], filter[1][0]), Math.min(filter[0][1], filter[1][1])], [Math.max(filter[0][0], filter[1][0]), Math.max(filter[0][1], filter[1][1])]];\n    } else {\n        fromBottomLeft = [[filter[0], -Infinity], [filter[1], Infinity]];\n    }\n\n    f.isFiltered = function (value) {\n        var x, y;\n\n        if (value instanceof Array) {\n            x = value[0];\n            y = value[1];\n        } else {\n            x = value;\n            y = fromBottomLeft[0][1];\n        }\n\n        return x >= fromBottomLeft[0][0] && x < fromBottomLeft[1][0] && y >= fromBottomLeft[0][1] && y < fromBottomLeft[1][1];\n    };\n    f.filterType = 'RangedTwoDimensionalFilter';\n\n    return f;\n};\n\n// ******** Sunburst Chart ********\n\n/**\r\n * HierarchyFilter is a filter which accepts a key path as an array. It matches any node at, or\r\n * child of, the given path. It is used by the {@link dc.sunburstChart sunburst chart} to include particular cells and all\r\n * their children as they are clicked.\r\n *\r\n * @name HierarchyFilter\r\n * @memberof dc.filters\r\n * @param {String} path\r\n * @returns {Array<String>}\r\n * @constructor\r\n */\ndc.filters.HierarchyFilter = function (path) {\n    if (path === null) {\n        return null;\n    }\n\n    var filter = path.slice(0);\n    filter.isFiltered = function (value) {\n        if (!(filter.length && value && value.length && value.length >= filter.length)) {\n            return false;\n        }\n\n        for (var i = 0; i < filter.length; i++) {\n            if (value[i] !== filter[i]) {\n                return false;\n            }\n        }\n\n        return true;\n    };\n    return filter;\n};\n\n/**\r\n * `dc.baseMixin` is an abstract functional object representing a basic `dc` chart object\r\n * for all chart and widget implementations. Methods from the {@link #dc.baseMixin dc.baseMixin} are inherited\r\n * and available on all chart implementations in the `dc` library.\r\n * @name baseMixin\r\n * @memberof dc\r\n * @mixin\r\n * @param {Object} _chart\r\n * @returns {dc.baseMixin}\r\n */\ndc.baseMixin = function (_chart) {\n    _chart.__dcFlag__ = dc.utils.uniqueId();\n\n    var _dimension;\n    var _group;\n\n    var _anchor;\n    var _root;\n    var _svg;\n    var _isChild;\n\n    var _minWidth = 200;\n    var _defaultWidthCalc = function _defaultWidthCalc(element) {\n        var width = element && element.getBoundingClientRect && element.getBoundingClientRect().width;\n        return width && width > _minWidth ? width : _minWidth;\n    };\n    var _widthCalc = _defaultWidthCalc;\n\n    var _minHeight = 200;\n    var _defaultHeightCalc = function _defaultHeightCalc(element) {\n        var height = element && element.getBoundingClientRect && element.getBoundingClientRect().height;\n        return height && height > _minHeight ? height : _minHeight;\n    };\n    var _heightCalc = _defaultHeightCalc;\n    var _width, _height;\n    var _useViewBoxResizing = false;\n\n    var _keyAccessor = dc.pluck('key');\n    var _valueAccessor = dc.pluck('value');\n    var _label = dc.pluck('key');\n\n    var _ordering = dc.pluck('key');\n    var _orderSort;\n\n    var _renderLabel = false;\n\n    var _title = function _title(d) {\n        return _chart.keyAccessor()(d) + ': ' + _chart.valueAccessor()(d);\n    };\n    var _renderTitle = true;\n    var _controlsUseVisibility = false;\n\n    var _transitionDuration = 750;\n\n    var _transitionDelay = 0;\n\n    var _filterPrinter = dc.printers.filters;\n\n    var _mandatoryAttributes = ['dimension', 'group'];\n\n    var _chartGroup = dc.constants.DEFAULT_CHART_GROUP;\n\n    var _listeners = _d.d3.dispatch('preRender', 'postRender', 'preRedraw', 'postRedraw', 'filtered', 'zoomed', 'renderlet', 'pretransition');\n\n    var _legend;\n    var _commitHandler;\n\n    var _filters = [];\n    var _filterHandler = function _filterHandler(dimension, filters) {\n        if (filters.length === 0) {\n            dimension.filter(null);\n        } else if (filters.length === 1 && !filters[0].isFiltered) {\n            // single value and not a function-based filter\n            dimension.filterExact(filters[0]);\n        } else if (filters.length === 1 && filters[0].filterType === 'RangedFilter') {\n            // single range-based filter\n            dimension.filterRange(filters[0]);\n        } else {\n            dimension.filterFunction(function (d) {\n                for (var i = 0; i < filters.length; i++) {\n                    var filter = filters[i];\n                    if (filter.isFiltered && filter.isFiltered(d)) {\n                        return true;\n                    } else if (filter <= d && filter >= d) {\n                        return true;\n                    }\n                }\n                return false;\n            });\n        }\n        return filters;\n    };\n\n    var _data = function _data(group) {\n        return group.all();\n    };\n\n    /**\r\n     * Set or get the height attribute of a chart. The height is applied to the SVGElement generated by\r\n     * the chart when rendered (or re-rendered). If a value is given, then it will be used to calculate\r\n     * the new height and the chart returned for method chaining.  The value can either be a numeric, a\r\n     * function, or falsy. If no value is specified then the value of the current height attribute will\r\n     * be returned.\r\n     *\r\n     * By default, without an explicit height being given, the chart will select the width of its\r\n     * anchor element. If that isn't possible it defaults to 200 (provided by the\r\n     * {@link dc.baseMixin#minHeight minHeight} property). Setting the value falsy will return\r\n     * the chart to the default behavior.\r\n     * @method height\r\n     * @memberof dc.baseMixin\r\n     * @instance\r\n     * @see {@link dc.baseMixin#minHeight minHeight}\r\n     * @example\r\n     * // Default height\r\n     * chart.height(function (element) {\r\n     *     var height = element && element.getBoundingClientRect && element.getBoundingClientRect().height;\r\n     *     return (height && height > chart.minHeight()) ? height : chart.minHeight();\r\n     * });\r\n     *\r\n     * chart.height(250); // Set the chart's height to 250px;\r\n     * chart.height(function(anchor) { return doSomethingWith(anchor); }); // set the chart's height with a function\r\n     * chart.height(null); // reset the height to the default auto calculation\r\n     * @param {Number|Function} [height]\r\n     * @returns {Number|dc.baseMixin}\r\n     */\n    _chart.height = function (height) {\n        if (!arguments.length) {\n            if (!dc.utils.isNumber(_height)) {\n                // only calculate once\n                _height = _heightCalc(_root.node());\n            }\n            return _height;\n        }\n        _heightCalc = height ? typeof height === 'function' ? height : dc.utils.constant(height) : _defaultHeightCalc;\n        _height = undefined;\n        return _chart;\n    };\n\n    /**\r\n     * Set or get the width attribute of a chart.\r\n     * @method width\r\n     * @memberof dc.baseMixin\r\n     * @instance\r\n     * @see {@link dc.baseMixin#height height}\r\n     * @see {@link dc.baseMixin#minWidth minWidth}\r\n     * @example\r\n     * // Default width\r\n     * chart.width(function (element) {\r\n     *     var width = element && element.getBoundingClientRect && element.getBoundingClientRect().width;\r\n     *     return (width && width > chart.minWidth()) ? width : chart.minWidth();\r\n     * });\r\n     * @param {Number|Function} [width]\r\n     * @returns {Number|dc.baseMixin}\r\n     */\n    _chart.width = function (width) {\n        if (!arguments.length) {\n            if (!dc.utils.isNumber(_width)) {\n                // only calculate once\n                _width = _widthCalc(_root.node());\n            }\n            return _width;\n        }\n        _widthCalc = width ? typeof width === 'function' ? width : dc.utils.constant(width) : _defaultWidthCalc;\n        _width = undefined;\n        return _chart;\n    };\n\n    /**\r\n     * Set or get the minimum width attribute of a chart. This only has effect when used with the default\r\n     * {@link dc.baseMixin#width width} function.\r\n     * @method minWidth\r\n     * @memberof dc.baseMixin\r\n     * @instance\r\n     * @see {@link dc.baseMixin#width width}\r\n     * @param {Number} [minWidth=200]\r\n     * @returns {Number|dc.baseMixin}\r\n     */\n    _chart.minWidth = function (minWidth) {\n        if (!arguments.length) {\n            return _minWidth;\n        }\n        _minWidth = minWidth;\n        return _chart;\n    };\n\n    /**\r\n     * Set or get the minimum height attribute of a chart. This only has effect when used with the default\r\n     * {@link dc.baseMixin#height height} function.\r\n     * @method minHeight\r\n     * @memberof dc.baseMixin\r\n     * @instance\r\n     * @see {@link dc.baseMixin#height height}\r\n     * @param {Number} [minHeight=200]\r\n     * @returns {Number|dc.baseMixin}\r\n     */\n    _chart.minHeight = function (minHeight) {\n        if (!arguments.length) {\n            return _minHeight;\n        }\n        _minHeight = minHeight;\n        return _chart;\n    };\n\n    /**\r\n     * Turn on/off using the SVG\r\n     * {@link https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/viewBox `viewBox` attribute}.\r\n     * When enabled, `viewBox` will be set on the svg root element instead of `width` and `height`.\r\n     * Requires that the chart aspect ratio be defined using chart.width(w) and chart.height(h).\r\n     *\r\n     * This will maintain the aspect ratio while enabling the chart to resize responsively to the\r\n     * space given to the chart using CSS. For example, the chart can use `width: 100%; height:\r\n     * 100%` or absolute positioning to resize to its parent div.\r\n     *\r\n     * Since the text will be sized as if the chart is drawn according to the width and height, and\r\n     * will be resized if the chart is any other size, you need to set the chart width and height so\r\n     * that the text looks good. In practice, 600x400 seems to work pretty well for most charts.\r\n     *\r\n     * You can see examples of this resizing strategy in the [Chart Resizing\r\n     * Examples](http://dc-js.github.io/dc.js/resizing/); just add `?resize=viewbox` to any of the\r\n     * one-chart examples to enable `useViewBoxResizing`.\r\n     * @method useViewBoxResizing\r\n     * @memberof dc.baseMixin\r\n     * @instance\r\n     * @param {Boolean} [useViewBoxResizing=false]\r\n     * @returns {Boolean|dc.baseMixin}\r\n     */\n    _chart.useViewBoxResizing = function (useViewBoxResizing) {\n        if (!arguments.length) {\n            return _useViewBoxResizing;\n        }\n        _useViewBoxResizing = useViewBoxResizing;\n        return _chart;\n    };\n\n    /**\r\n     * **mandatory**\r\n     *\r\n     * Set or get the dimension attribute of a chart. In `dc`, a dimension can be any valid\r\n     * {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#dimension crossfilter dimension}\r\n     *\r\n     * If a value is given, then it will be used as the new dimension. If no value is specified then\r\n     * the current dimension will be returned.\r\n     * @method dimension\r\n     * @memberof dc.baseMixin\r\n     * @instance\r\n     * @see {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#dimension crossfilter.dimension}\r\n     * @example\r\n     * var index = crossfilter([]);\r\n     * var dimension = index.dimension(dc.pluck('key'));\r\n     * chart.dimension(dimension);\r\n     * @param {crossfilter.dimension} [dimension]\r\n     * @returns {crossfilter.dimension|dc.baseMixin}\r\n     */\n    _chart.dimension = function (dimension) {\n        if (!arguments.length) {\n            return _dimension;\n        }\n        _dimension = dimension;\n        _chart.expireCache();\n        return _chart;\n    };\n\n    /**\r\n     * Set the data callback or retrieve the chart's data set. The data callback is passed the chart's\r\n     * group and by default will return\r\n     * {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#group_all group.all}.\r\n     * This behavior may be modified to, for instance, return only the top 5 groups.\r\n     * @method data\r\n     * @memberof dc.baseMixin\r\n     * @instance\r\n     * @example\r\n     * // Default data function\r\n     * chart.data(function (group) { return group.all(); });\r\n     *\r\n     * chart.data(function (group) { return group.top(5); });\r\n     * @param {Function} [callback]\r\n     * @returns {*|dc.baseMixin}\r\n     */\n    _chart.data = function (callback) {\n        if (!arguments.length) {\n            return _data.call(_chart, _group);\n        }\n        _data = typeof callback === 'function' ? callback : dc.utils.constant(callback);\n        _chart.expireCache();\n        return _chart;\n    };\n\n    /**\r\n     * **mandatory**\r\n     *\r\n     * Set or get the group attribute of a chart. In `dc` a group is a\r\n     * {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#group-map-reduce crossfilter group}.\r\n     * Usually the group should be created from the particular dimension associated with the same chart. If a value is\r\n     * given, then it will be used as the new group.\r\n     *\r\n     * If no value specified then the current group will be returned.\r\n     * If `name` is specified then it will be used to generate legend label.\r\n     * @method group\r\n     * @memberof dc.baseMixin\r\n     * @instance\r\n     * @see {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#group-map-reduce crossfilter.group}\r\n     * @example\r\n     * var index = crossfilter([]);\r\n     * var dimension = index.dimension(dc.pluck('key'));\r\n     * chart.dimension(dimension);\r\n     * chart.group(dimension.group(crossfilter.reduceSum()));\r\n     * @param {crossfilter.group} [group]\r\n     * @param {String} [name]\r\n     * @returns {crossfilter.group|dc.baseMixin}\r\n     */\n    _chart.group = function (group, name) {\n        if (!arguments.length) {\n            return _group;\n        }\n        _group = group;\n        _chart._groupName = name;\n        _chart.expireCache();\n        return _chart;\n    };\n\n    /**\r\n     * Get or set an accessor to order ordinal dimensions.  The chart uses\r\n     * {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#quicksort_by crossfilter.quicksort.by}\r\n     * to sort elements; this accessor returns the value to order on.\r\n     * @method ordering\r\n     * @memberof dc.baseMixin\r\n     * @instance\r\n     * @see {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#quicksort_by crossfilter.quicksort.by}\r\n     * @example\r\n     * // Default ordering accessor\r\n     * _chart.ordering(dc.pluck('key'));\r\n     * @param {Function} [orderFunction]\r\n     * @returns {Function|dc.baseMixin}\r\n     */\n    _chart.ordering = function (orderFunction) {\n        if (!arguments.length) {\n            return _ordering;\n        }\n        _ordering = orderFunction;\n        _orderSort = _crossfilter.crossfilter.quicksort.by(_ordering);\n        _chart.expireCache();\n        return _chart;\n    };\n\n    _chart._computeOrderedGroups = function (data) {\n        var dataCopy = data.slice(0);\n\n        if (dataCopy.length <= 1) {\n            return dataCopy;\n        }\n\n        if (!_orderSort) {\n            _orderSort = _crossfilter.crossfilter.quicksort.by(_ordering);\n        }\n\n        return _orderSort(dataCopy, 0, dataCopy.length);\n    };\n\n    /**\r\n     * Clear all filters associated with this chart. The same effect can be achieved by calling\r\n     * {@link dc.baseMixin#filter chart.filter(null)}.\r\n     * @method filterAll\r\n     * @memberof dc.baseMixin\r\n     * @instance\r\n     * @returns {dc.baseMixin}\r\n     */\n    _chart.filterAll = function () {\n        return _chart.filter(null);\n    };\n\n    /**\r\n     * Execute d3 single selection in the chart's scope using the given selector and return the d3\r\n     * selection.\r\n     *\r\n     * This function is **not chainable** since it does not return a chart instance; however the d3\r\n     * selection result can be chained to d3 function calls.\r\n     * @method select\r\n     * @memberof dc.baseMixin\r\n     * @instance\r\n     * @see {@link https://github.com/d3/d3-selection/blob/master/README.md#select d3.select}\r\n     * @example\r\n     * // Has the same effect as d3.select('#chart-id').select(selector)\r\n     * chart.select(selector)\r\n     * @returns {d3.selection}\r\n     */\n    _chart.select = function (s) {\n        return _root.select(s);\n    };\n\n    /**\r\n     * Execute in scope d3 selectAll using the given selector and return d3 selection result.\r\n     *\r\n     * This function is **not chainable** since it does not return a chart instance; however the d3\r\n     * selection result can be chained to d3 function calls.\r\n     * @method selectAll\r\n     * @memberof dc.baseMixin\r\n     * @instance\r\n     * @see {@link https://github.com/d3/d3-selection/blob/master/README.md#selectAll d3.selectAll}\r\n     * @example\r\n     * // Has the same effect as d3.select('#chart-id').selectAll(selector)\r\n     * chart.selectAll(selector)\r\n     * @returns {d3.selection}\r\n     */\n    _chart.selectAll = function (s) {\n        return _root ? _root.selectAll(s) : null;\n    };\n\n    /**\r\n     * Set the root SVGElement to either be an existing chart's root; or any valid [d3 single\r\n     * selector](https://github.com/d3/d3-selection/blob/master/README.md#selecting-elements) specifying a dom\r\n     * block element such as a div; or a dom element or d3 selection. Optionally registers the chart\r\n     * within the chartGroup. This class is called internally on chart initialization, but be called\r\n     * again to relocate the chart. However, it will orphan any previously created SVGElements.\r\n     * @method anchor\r\n     * @memberof dc.baseMixin\r\n     * @instance\r\n     * @param {anchorChart|anchorSelector|anchorNode} [parent]\r\n     * @param {String} [chartGroup]\r\n     * @returns {String|node|d3.selection|dc.baseMixin}\r\n     */\n    _chart.anchor = function (parent, chartGroup) {\n        if (!arguments.length) {\n            return _anchor;\n        }\n        if (dc.instanceOfChart(parent)) {\n            _anchor = parent.anchor();\n            _root = parent.root();\n            _isChild = true;\n        } else if (parent) {\n            if (parent.select && parent.classed) {\n                // detect d3 selection\n                _anchor = parent.node();\n            } else {\n                _anchor = parent;\n            }\n            _root = _d.d3.select(_anchor);\n            _root.classed(dc.constants.CHART_CLASS, true);\n            dc.registerChart(_chart, chartGroup);\n            _isChild = false;\n        } else {\n            throw new dc.errors.BadArgumentException('parent must be defined');\n        }\n        _chartGroup = chartGroup;\n        return _chart;\n    };\n\n    /**\r\n     * Returns the DOM id for the chart's anchored location.\r\n     * @method anchorName\r\n     * @memberof dc.baseMixin\r\n     * @instance\r\n     * @returns {String}\r\n     */\n    _chart.anchorName = function () {\n        var a = _chart.anchor();\n        if (a && a.id) {\n            return a.id;\n        }\n        if (a && a.replace) {\n            return a.replace('#', '');\n        }\n        return 'dc-chart' + _chart.chartID();\n    };\n\n    /**\r\n     * Returns the root element where a chart resides. Usually it will be the parent div element where\r\n     * the SVGElement was created. You can also pass in a new root element however this is usually handled by\r\n     * dc internally. Resetting the root element on a chart outside of dc internals may have\r\n     * unexpected consequences.\r\n     * @method root\r\n     * @memberof dc.baseMixin\r\n     * @instance\r\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement HTMLElement}\r\n     * @param {HTMLElement} [rootElement]\r\n     * @returns {HTMLElement|dc.baseMixin}\r\n     */\n    _chart.root = function (rootElement) {\n        if (!arguments.length) {\n            return _root;\n        }\n        _root = rootElement;\n        return _chart;\n    };\n\n    /**\r\n     * Returns the top SVGElement for this specific chart. You can also pass in a new SVGElement,\r\n     * however this is usually handled by dc internally. Resetting the SVGElement on a chart outside\r\n     * of dc internals may have unexpected consequences.\r\n     * @method svg\r\n     * @memberof dc.baseMixin\r\n     * @instance\r\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/SVGElement SVGElement}\r\n     * @param {SVGElement|d3.selection} [svgElement]\r\n     * @returns {SVGElement|d3.selection|dc.baseMixin}\r\n     */\n    _chart.svg = function (svgElement) {\n        if (!arguments.length) {\n            return _svg;\n        }\n        _svg = svgElement;\n        return _chart;\n    };\n\n    /**\r\n     * Remove the chart's SVGElements from the dom and recreate the container SVGElement.\r\n     * @method resetSvg\r\n     * @memberof dc.baseMixin\r\n     * @instance\r\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/SVGElement SVGElement}\r\n     * @returns {SVGElement}\r\n     */\n    _chart.resetSvg = function () {\n        _chart.select('svg').remove();\n        return generateSvg();\n    };\n\n    function sizeSvg() {\n        if (_svg) {\n            if (!_useViewBoxResizing) {\n                _svg.attr('width', _chart.width()).attr('height', _chart.height());\n            } else if (!_svg.attr('viewBox')) {\n                _svg.attr('viewBox', '0 0 ' + _chart.width() + ' ' + _chart.height());\n            }\n        }\n    }\n\n    function generateSvg() {\n        _svg = _chart.root().append('svg');\n        sizeSvg();\n        return _svg;\n    }\n\n    /**\r\n     * Set or get the filter printer function. The filter printer function is used to generate human\r\n     * friendly text for filter value(s) associated with the chart instance. The text will get shown\r\n     * in the `.filter element; see {@link dc.baseMixin#turnOnControls turnOnControls}.\r\n     *\r\n     * By default dc charts use a default filter printer {@link dc.printers.filters dc.printers.filters}\r\n     * that provides simple printing support for both single value and ranged filters.\r\n     * @method filterPrinter\r\n     * @memberof dc.baseMixin\r\n     * @instance\r\n     * @example\r\n     * // for a chart with an ordinal brush, print the filters in upper case\r\n     * chart.filterPrinter(function(filters) {\r\n     *   return filters.map(function(f) { return f.toUpperCase(); }).join(', ');\r\n     * });\r\n     * // for a chart with a range brush, print the filter as start and extent\r\n     * chart.filterPrinter(function(filters) {\r\n     *   return 'start ' + dc.utils.printSingleValue(filters[0][0]) +\r\n     *     ' extent ' + dc.utils.printSingleValue(filters[0][1] - filters[0][0]);\r\n     * });\r\n     * @param {Function} [filterPrinterFunction=dc.printers.filters]\r\n     * @returns {Function|dc.baseMixin}\r\n     */\n    _chart.filterPrinter = function (filterPrinterFunction) {\n        if (!arguments.length) {\n            return _filterPrinter;\n        }\n        _filterPrinter = filterPrinterFunction;\n        return _chart;\n    };\n\n    /**\r\n     * If set, use the `visibility` attribute instead of the `display` attribute for showing/hiding\r\n     * chart reset and filter controls, for less disruption to the layout.\r\n     * @method controlsUseVisibility\r\n     * @memberof dc.baseMixin\r\n     * @instance\r\n     * @param {Boolean} [controlsUseVisibility=false]\r\n     * @returns {Boolean|dc.baseMixin}\r\n     **/\n    _chart.controlsUseVisibility = function (useVisibility) {\n        if (!arguments.length) {\n            return _controlsUseVisibility;\n        }\n        _controlsUseVisibility = useVisibility;\n        return _chart;\n    };\n\n    /**\r\n     * Turn on optional control elements within the root element. dc currently supports the\r\n     * following html control elements.\r\n     * * root.selectAll('.reset') - elements are turned on if the chart has an active filter. This type\r\n     * of control element is usually used to store a reset link to allow user to reset filter on a\r\n     * certain chart. This element will be turned off automatically if the filter is cleared.\r\n     * * root.selectAll('.filter') elements are turned on if the chart has an active filter. The text\r\n     * content of this element is then replaced with the current filter value using the filter printer\r\n     * function. This type of element will be turned off automatically if the filter is cleared.\r\n     * @method turnOnControls\r\n     * @memberof dc.baseMixin\r\n     * @instance\r\n     * @returns {dc.baseMixin}\r\n     */\n    _chart.turnOnControls = function () {\n        if (_root) {\n            var attribute = _chart.controlsUseVisibility() ? 'visibility' : 'display';\n            _chart.selectAll('.reset').style(attribute, null);\n            _chart.selectAll('.filter').text(_filterPrinter(_chart.filters())).style(attribute, null);\n        }\n        return _chart;\n    };\n\n    /**\r\n     * Turn off optional control elements within the root element.\r\n     * @method turnOffControls\r\n     * @memberof dc.baseMixin\r\n     * @see {@link dc.baseMixin#turnOnControls turnOnControls}\r\n     * @instance\r\n     * @returns {dc.baseMixin}\r\n     */\n    _chart.turnOffControls = function () {\n        if (_root) {\n            var attribute = _chart.controlsUseVisibility() ? 'visibility' : 'display';\n            var value = _chart.controlsUseVisibility() ? 'hidden' : 'none';\n            _chart.selectAll('.reset').style(attribute, value);\n            _chart.selectAll('.filter').style(attribute, value).text(_chart.filter());\n        }\n        return _chart;\n    };\n\n    /**\r\n     * Set or get the animation transition duration (in milliseconds) for this chart instance.\r\n     * @method transitionDuration\r\n     * @memberof dc.baseMixin\r\n     * @instance\r\n     * @param {Number} [duration=750]\r\n     * @returns {Number|dc.baseMixin}\r\n     */\n    _chart.transitionDuration = function (duration) {\n        if (!arguments.length) {\n            return _transitionDuration;\n        }\n        _transitionDuration = duration;\n        return _chart;\n    };\n\n    /**\r\n     * Set or get the animation transition delay (in milliseconds) for this chart instance.\r\n     * @method transitionDelay\r\n     * @memberof dc.baseMixin\r\n     * @instance\r\n     * @param {Number} [delay=0]\r\n     * @returns {Number|dc.baseMixin}\r\n     */\n    _chart.transitionDelay = function (delay) {\n        if (!arguments.length) {\n            return _transitionDelay;\n        }\n        _transitionDelay = delay;\n        return _chart;\n    };\n\n    _chart._mandatoryAttributes = function (_) {\n        if (!arguments.length) {\n            return _mandatoryAttributes;\n        }\n        _mandatoryAttributes = _;\n        return _chart;\n    };\n\n    function checkForMandatoryAttributes(a) {\n        if (!_chart[a] || !_chart[a]()) {\n            throw new dc.errors.InvalidStateException('Mandatory attribute chart.' + a + ' is missing on chart[#' + _chart.anchorName() + ']');\n        }\n    }\n\n    /**\r\n     * Invoking this method will force the chart to re-render everything from scratch. Generally it\r\n     * should only be used to render the chart for the first time on the page or if you want to make\r\n     * sure everything is redrawn from scratch instead of relying on the default incremental redrawing\r\n     * behaviour.\r\n     * @method render\r\n     * @memberof dc.baseMixin\r\n     * @instance\r\n     * @returns {dc.baseMixin}\r\n     */\n    _chart.render = function () {\n        _height = _width = undefined; // force recalculate\n        _listeners.call('preRender', _chart, _chart);\n\n        if (_mandatoryAttributes) {\n            _mandatoryAttributes.forEach(checkForMandatoryAttributes);\n        }\n\n        var result = _chart._doRender();\n\n        if (_legend) {\n            _legend.render();\n        }\n\n        _chart._activateRenderlets('postRender');\n\n        return result;\n    };\n\n    _chart._activateRenderlets = function (event) {\n        _listeners.call('pretransition', _chart, _chart);\n        if (_chart.transitionDuration() > 0 && _svg) {\n            _svg.transition().duration(_chart.transitionDuration()).delay(_chart.transitionDelay()).on('end', function () {\n                _listeners.call('renderlet', _chart, _chart);\n                if (event) {\n                    _listeners.call(event, _chart, _chart);\n                }\n            });\n        } else {\n            _listeners.call('renderlet', _chart, _chart);\n            if (event) {\n                _listeners.call(event, _chart, _chart);\n            }\n        }\n    };\n\n    /**\r\n     * Calling redraw will cause the chart to re-render data changes incrementally. If there is no\r\n     * change in the underlying data dimension then calling this method will have no effect on the\r\n     * chart. Most chart interaction in dc will automatically trigger this method through internal\r\n     * events (in particular {@link dc.redrawAll dc.redrawAll}); therefore, you only need to\r\n     * manually invoke this function if data is manipulated outside of dc's control (for example if\r\n     * data is loaded in the background using\r\n     * {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#crossfilter_add crossfilter.add}).\r\n     * @method redraw\r\n     * @memberof dc.baseMixin\r\n     * @instance\r\n     * @returns {dc.baseMixin}\r\n     */\n    _chart.redraw = function () {\n        sizeSvg();\n        _listeners.call('preRedraw', _chart, _chart);\n\n        var result = _chart._doRedraw();\n\n        if (_legend) {\n            _legend.render();\n        }\n\n        _chart._activateRenderlets('postRedraw');\n\n        return result;\n    };\n\n    /**\r\n     * Gets/sets the commit handler. If the chart has a commit handler, the handler will be called when\r\n     * the chart's filters have changed, in order to send the filter data asynchronously to a server.\r\n     *\r\n     * Unlike other functions in dc.js, the commit handler is asynchronous. It takes two arguments:\r\n     * a flag indicating whether this is a render (true) or a redraw (false), and a callback to be\r\n     * triggered once the commit is filtered. The callback has the standard node.js continuation signature\r\n     * with error first and result second.\r\n     * @method commitHandler\r\n     * @memberof dc.baseMixin\r\n     * @instance\r\n     * @returns {dc.baseMixin}\r\n     */\n    _chart.commitHandler = function (commitHandler) {\n        if (!arguments.length) {\n            return _commitHandler;\n        }\n        _commitHandler = commitHandler;\n        return _chart;\n    };\n\n    /**\r\n     * Redraws all charts in the same group as this chart, typically in reaction to a filter\r\n     * change. If the chart has a {@link dc.baseMixin.commitFilter commitHandler}, it will\r\n     * be executed and waited for.\r\n     * @method redrawGroup\r\n     * @memberof dc.baseMixin\r\n     * @instance\r\n     * @returns {dc.baseMixin}\r\n     */\n    _chart.redrawGroup = function () {\n        if (_commitHandler) {\n            _commitHandler(false, function (error, result) {\n                if (error) {\n                    console.log(error);\n                } else {\n                    dc.redrawAll(_chart.chartGroup());\n                }\n            });\n        } else {\n            dc.redrawAll(_chart.chartGroup());\n        }\n        return _chart;\n    };\n\n    /**\r\n     * Renders all charts in the same group as this chart. If the chart has a\r\n     * {@link dc.baseMixin.commitFilter commitHandler}, it will be executed and waited for\r\n     * @method renderGroup\r\n     * @memberof dc.baseMixin\r\n     * @instance\r\n     * @returns {dc.baseMixin}\r\n     */\n    _chart.renderGroup = function () {\n        if (_commitHandler) {\n            _commitHandler(false, function (error, result) {\n                if (error) {\n                    console.log(error);\n                } else {\n                    dc.renderAll(_chart.chartGroup());\n                }\n            });\n        } else {\n            dc.renderAll(_chart.chartGroup());\n        }\n        return _chart;\n    };\n\n    _chart._invokeFilteredListener = function (f) {\n        if (f !== undefined) {\n            _listeners.call('filtered', _chart, _chart, f);\n        }\n    };\n\n    _chart._invokeZoomedListener = function () {\n        _listeners.call('zoomed', _chart, _chart);\n    };\n\n    var _hasFilterHandler = function _hasFilterHandler(filters, filter) {\n        if (filter === null || typeof filter === 'undefined') {\n            return filters.length > 0;\n        }\n        return filters.some(function (f) {\n            return filter <= f && filter >= f;\n        });\n    };\n\n    /**\r\n     * Set or get the has-filter handler. The has-filter handler is a function that checks to see if\r\n     * the chart's current filters (first argument) include a specific filter (second argument).  Using a custom has-filter handler allows\r\n     * you to change the way filters are checked for and replaced.\r\n     * @method hasFilterHandler\r\n     * @memberof dc.baseMixin\r\n     * @instance\r\n     * @example\r\n     * // default has-filter handler\r\n     * chart.hasFilterHandler(function (filters, filter) {\r\n     *     if (filter === null || typeof(filter) === 'undefined') {\r\n     *         return filters.length > 0;\r\n     *     }\r\n     *     return filters.some(function (f) {\r\n     *         return filter <= f && filter >= f;\r\n     *     });\r\n     * });\r\n     *\r\n     * // custom filter handler (no-op)\r\n     * chart.hasFilterHandler(function(filters, filter) {\r\n     *     return false;\r\n     * });\r\n     * @param {Function} [hasFilterHandler]\r\n     * @returns {Function|dc.baseMixin}\r\n     */\n    _chart.hasFilterHandler = function (hasFilterHandler) {\n        if (!arguments.length) {\n            return _hasFilterHandler;\n        }\n        _hasFilterHandler = hasFilterHandler;\n        return _chart;\n    };\n\n    /**\r\n     * Check whether any active filter or a specific filter is associated with particular chart instance.\r\n     * This function is **not chainable**.\r\n     * @method hasFilter\r\n     * @memberof dc.baseMixin\r\n     * @instance\r\n     * @see {@link dc.baseMixin#hasFilterHandler hasFilterHandler}\r\n     * @param {*} [filter]\r\n     * @returns {Boolean}\r\n     */\n    _chart.hasFilter = function (filter) {\n        return _hasFilterHandler(_filters, filter);\n    };\n\n    var _removeFilterHandler = function _removeFilterHandler(filters, filter) {\n        for (var i = 0; i < filters.length; i++) {\n            if (filters[i] <= filter && filters[i] >= filter) {\n                filters.splice(i, 1);\n                break;\n            }\n        }\n        return filters;\n    };\n\n    /**\r\n     * Set or get the remove filter handler. The remove filter handler is a function that removes a\r\n     * filter from the chart's current filters. Using a custom remove filter handler allows you to\r\n     * change how filters are removed or perform additional work when removing a filter, e.g. when\r\n     * using a filter server other than crossfilter.\r\n     *\r\n     * The handler should return a new or modified array as the result.\r\n     * @method removeFilterHandler\r\n     * @memberof dc.baseMixin\r\n     * @instance\r\n     * @example\r\n     * // default remove filter handler\r\n     * chart.removeFilterHandler(function (filters, filter) {\r\n     *     for (var i = 0; i < filters.length; i++) {\r\n     *         if (filters[i] <= filter && filters[i] >= filter) {\r\n     *             filters.splice(i, 1);\r\n     *             break;\r\n     *         }\r\n     *     }\r\n     *     return filters;\r\n     * });\r\n     *\r\n     * // custom filter handler (no-op)\r\n     * chart.removeFilterHandler(function(filters, filter) {\r\n     *     return filters;\r\n     * });\r\n     * @param {Function} [removeFilterHandler]\r\n     * @returns {Function|dc.baseMixin}\r\n     */\n    _chart.removeFilterHandler = function (removeFilterHandler) {\n        if (!arguments.length) {\n            return _removeFilterHandler;\n        }\n        _removeFilterHandler = removeFilterHandler;\n        return _chart;\n    };\n\n    var _addFilterHandler = function _addFilterHandler(filters, filter) {\n        filters.push(filter);\n        return filters;\n    };\n\n    /**\r\n     * Set or get the add filter handler. The add filter handler is a function that adds a filter to\r\n     * the chart's filter list. Using a custom add filter handler allows you to change the way filters\r\n     * are added or perform additional work when adding a filter, e.g. when using a filter server other\r\n     * than crossfilter.\r\n     *\r\n     * The handler should return a new or modified array as the result.\r\n     * @method addFilterHandler\r\n     * @memberof dc.baseMixin\r\n     * @instance\r\n     * @example\r\n     * // default add filter handler\r\n     * chart.addFilterHandler(function (filters, filter) {\r\n     *     filters.push(filter);\r\n     *     return filters;\r\n     * });\r\n     *\r\n     * // custom filter handler (no-op)\r\n     * chart.addFilterHandler(function(filters, filter) {\r\n     *     return filters;\r\n     * });\r\n     * @param {Function} [addFilterHandler]\r\n     * @returns {Function|dc.baseMixin}\r\n     */\n    _chart.addFilterHandler = function (addFilterHandler) {\n        if (!arguments.length) {\n            return _addFilterHandler;\n        }\n        _addFilterHandler = addFilterHandler;\n        return _chart;\n    };\n\n    var _resetFilterHandler = function _resetFilterHandler(filters) {\n        return [];\n    };\n\n    /**\r\n     * Set or get the reset filter handler. The reset filter handler is a function that resets the\r\n     * chart's filter list by returning a new list. Using a custom reset filter handler allows you to\r\n     * change the way filters are reset, or perform additional work when resetting the filters,\r\n     * e.g. when using a filter server other than crossfilter.\r\n     *\r\n     * The handler should return a new or modified array as the result.\r\n     * @method resetFilterHandler\r\n     * @memberof dc.baseMixin\r\n     * @instance\r\n     * @example\r\n     * // default remove filter handler\r\n     * function (filters) {\r\n     *     return [];\r\n     * }\r\n     *\r\n     * // custom filter handler (no-op)\r\n     * chart.resetFilterHandler(function(filters) {\r\n     *     return filters;\r\n     * });\r\n     * @param {Function} [resetFilterHandler]\r\n     * @returns {dc.baseMixin}\r\n     */\n    _chart.resetFilterHandler = function (resetFilterHandler) {\n        if (!arguments.length) {\n            return _resetFilterHandler;\n        }\n        _resetFilterHandler = resetFilterHandler;\n        return _chart;\n    };\n\n    function applyFilters(filters) {\n        if (_chart.dimension() && _chart.dimension().filter) {\n            var fs = _filterHandler(_chart.dimension(), filters);\n            if (fs) {\n                filters = fs;\n            }\n        }\n        return filters;\n    }\n\n    /**\r\n     * Replace the chart filter. This is equivalent to calling `chart.filter(null).filter(filter)`\r\n     * but more efficient because the filter is only applied once.\r\n     *\r\n     * @method replaceFilter\r\n     * @memberof dc.baseMixin\r\n     * @instance\r\n     * @param {*} [filter]\r\n     * @returns {dc.baseMixin}\r\n     **/\n    _chart.replaceFilter = function (filter) {\n        _filters = _resetFilterHandler(_filters);\n        _chart.filter(filter);\n        return _chart;\n    };\n\n    /**\r\n     * Filter the chart by the given parameter, or return the current filter if no input parameter\r\n     * is given.\r\n     *\r\n     * The filter parameter can take one of these forms:\r\n     * * A single value: the value will be toggled (added if it is not present in the current\r\n     * filters, removed if it is present)\r\n     * * An array containing a single array of values (`[[value,value,value]]`): each value is\r\n     * toggled\r\n     * * When appropriate for the chart, a {@link dc.filters dc filter object} such as\r\n     *   * {@link dc.filters.RangedFilter `dc.filters.RangedFilter`} for the\r\n     * {@link dc.coordinateGridMixin dc.coordinateGridMixin} charts\r\n     *   * {@link dc.filters.TwoDimensionalFilter `dc.filters.TwoDimensionalFilter`} for the\r\n     * {@link dc.heatMap heat map}\r\n     *   * {@link dc.filters.RangedTwoDimensionalFilter `dc.filters.RangedTwoDimensionalFilter`}\r\n     * for the {@link dc.scatterPlot scatter plot}\r\n     * * `null`: the filter will be reset using the\r\n     * {@link dc.baseMixin#resetFilterHandler resetFilterHandler}\r\n     *\r\n     * Note that this is always a toggle (even when it doesn't make sense for the filter type). If\r\n     * you wish to replace the current filter, either call `chart.filter(null)` first - or it's more\r\n     * efficient to call {@link dc.baseMixin#replaceFilter `chart.replaceFilter(filter)`} instead.\r\n     *\r\n     * Each toggle is executed by checking if the value is already present using the\r\n     * {@link dc.baseMixin#hasFilterHandler hasFilterHandler}; if it is not present, it is added\r\n     * using the {@link dc.baseMixin#addFilterHandler addFilterHandler}; if it is already present,\r\n     * it is removed using the {@link dc.baseMixin#removeFilterHandler removeFilterHandler}.\r\n     *\r\n     * Once the filters array has been updated, the filters are applied to the\r\n     * crossfilter dimension, using the {@link dc.baseMixin#filterHandler filterHandler}.\r\n     *\r\n     * Once you have set the filters, call {@link dc.baseMixin#redrawGroup `chart.redrawGroup()`}\r\n     * (or {@link dc.redrawAll `dc.redrawAll()`}) to redraw the chart's group.\r\n     * @method filter\r\n     * @memberof dc.baseMixin\r\n     * @instance\r\n     * @see {@link dc.baseMixin#addFilterHandler addFilterHandler}\r\n     * @see {@link dc.baseMixin#removeFilterHandler removeFilterHandler}\r\n     * @see {@link dc.baseMixin#resetFilterHandler resetFilterHandler}\r\n     * @see {@link dc.baseMixin#filterHandler filterHandler}\r\n     * @example\r\n     * // filter by a single string\r\n     * chart.filter('Sunday');\r\n     * // filter by a single age\r\n     * chart.filter(18);\r\n     * // filter by a set of states\r\n     * chart.filter([['MA', 'TX', 'ND', 'WA']]);\r\n     * // filter by range -- note the use of dc.filters.RangedFilter, which is different\r\n     * // from the syntax for filtering a crossfilter dimension directly, dimension.filter([15,20])\r\n     * chart.filter(dc.filters.RangedFilter(15,20));\r\n     * @param {*} [filter]\r\n     * @returns {dc.baseMixin}\r\n     */\n    _chart.filter = function (filter) {\n        if (!arguments.length) {\n            return _filters.length > 0 ? _filters[0] : null;\n        }\n        var filters = _filters;\n        if (filter instanceof Array && filter[0] instanceof Array && !filter.isFiltered) {\n            // toggle each filter\n            filter[0].forEach(function (f) {\n                if (_hasFilterHandler(filters, f)) {\n                    filters = _removeFilterHandler(filters, f);\n                } else {\n                    filters = _addFilterHandler(filters, f);\n                }\n            });\n        } else if (filter === null) {\n            filters = _resetFilterHandler(filters);\n        } else {\n            if (_hasFilterHandler(filters, filter)) {\n                filters = _removeFilterHandler(filters, filter);\n            } else {\n                filters = _addFilterHandler(filters, filter);\n            }\n        }\n        _filters = applyFilters(filters);\n        _chart._invokeFilteredListener(filter);\n\n        if (_root !== null && _chart.hasFilter()) {\n            _chart.turnOnControls();\n        } else {\n            _chart.turnOffControls();\n        }\n\n        return _chart;\n    };\n\n    /**\r\n     * Returns all current filters. This method does not perform defensive cloning of the internal\r\n     * filter array before returning, therefore any modification of the returned array will effect the\r\n     * chart's internal filter storage.\r\n     * @method filters\r\n     * @memberof dc.baseMixin\r\n     * @instance\r\n     * @returns {Array<*>}\r\n     */\n    _chart.filters = function () {\n        return _filters;\n    };\n\n    _chart.highlightSelected = function (e) {\n        _d.d3.select(e).classed(dc.constants.SELECTED_CLASS, true);\n        _d.d3.select(e).classed(dc.constants.DESELECTED_CLASS, false);\n    };\n\n    _chart.fadeDeselected = function (e) {\n        _d.d3.select(e).classed(dc.constants.SELECTED_CLASS, false);\n        _d.d3.select(e).classed(dc.constants.DESELECTED_CLASS, true);\n    };\n\n    _chart.resetHighlight = function (e) {\n        _d.d3.select(e).classed(dc.constants.SELECTED_CLASS, false);\n        _d.d3.select(e).classed(dc.constants.DESELECTED_CLASS, false);\n    };\n\n    /**\r\n     * This function is passed to d3 as the onClick handler for each chart. The default behavior is to\r\n     * filter on the clicked datum (passed to the callback) and redraw the chart group.\r\n     * @method onClick\r\n     * @memberof dc.baseMixin\r\n     * @instance\r\n     * @param {*} datum\r\n     */\n    _chart.onClick = function (datum) {\n        var filter = _chart.keyAccessor()(datum);\n        dc.events.trigger(function () {\n            _chart.filter(filter);\n            _chart.redrawGroup();\n        });\n    };\n\n    /**\r\n     * Set or get the filter handler. The filter handler is a function that performs the filter action\r\n     * on a specific dimension. Using a custom filter handler allows you to perform additional logic\r\n     * before or after filtering.\r\n     * @method filterHandler\r\n     * @memberof dc.baseMixin\r\n     * @instance\r\n     * @see {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#dimension_filter crossfilter.dimension.filter}\r\n     * @example\r\n     * // the default filter handler handles all possible cases for the charts in dc.js\r\n     * // you can replace it with something more specialized for your own chart\r\n     * chart.filterHandler(function (dimension, filters) {\r\n     *     if (filters.length === 0) {\r\n     *         // the empty case (no filtering)\r\n     *         dimension.filter(null);\r\n     *     } else if (filters.length === 1 && !filters[0].isFiltered) {\r\n     *         // single value and not a function-based filter\r\n     *         dimension.filterExact(filters[0]);\r\n     *     } else if (filters.length === 1 && filters[0].filterType === 'RangedFilter') {\r\n     *         // single range-based filter\r\n     *         dimension.filterRange(filters[0]);\r\n     *     } else {\r\n     *         // an array of values, or an array of filter objects\r\n     *         dimension.filterFunction(function (d) {\r\n     *             for (var i = 0; i < filters.length; i++) {\r\n     *                 var filter = filters[i];\r\n     *                 if (filter.isFiltered && filter.isFiltered(d)) {\r\n     *                     return true;\r\n     *                 } else if (filter <= d && filter >= d) {\r\n     *                     return true;\r\n     *                 }\r\n     *             }\r\n     *             return false;\r\n     *         });\r\n     *     }\r\n     *     return filters;\r\n     * });\r\n     *\r\n     * // custom filter handler\r\n     * chart.filterHandler(function(dimension, filter){\r\n     *     var newFilter = filter + 10;\r\n     *     dimension.filter(newFilter);\r\n     *     return newFilter; // set the actual filter value to the new value\r\n     * });\r\n     * @param {Function} [filterHandler]\r\n     * @returns {Function|dc.baseMixin}\r\n     */\n    _chart.filterHandler = function (filterHandler) {\n        if (!arguments.length) {\n            return _filterHandler;\n        }\n        _filterHandler = filterHandler;\n        return _chart;\n    };\n\n    // abstract function stub\n    _chart._doRender = function () {\n        // do nothing in base, should be overridden by sub-function\n        return _chart;\n    };\n\n    _chart._doRedraw = function () {\n        // do nothing in base, should be overridden by sub-function\n        return _chart;\n    };\n\n    _chart.legendables = function () {\n        // do nothing in base, should be overridden by sub-function\n        return [];\n    };\n\n    _chart.legendHighlight = function () {\n        // do nothing in base, should be overridden by sub-function\n    };\n\n    _chart.legendReset = function () {\n        // do nothing in base, should be overridden by sub-function\n    };\n\n    _chart.legendToggle = function () {\n        // do nothing in base, should be overriden by sub-function\n    };\n\n    _chart.isLegendableHidden = function () {\n        // do nothing in base, should be overridden by sub-function\n        return false;\n    };\n\n    /**\r\n     * Set or get the key accessor function. The key accessor function is used to retrieve the key\r\n     * value from the crossfilter group. Key values are used differently in different charts, for\r\n     * example keys correspond to slices in a pie chart and x axis positions in a grid coordinate chart.\r\n     * @method keyAccessor\r\n     * @memberof dc.baseMixin\r\n     * @instance\r\n     * @example\r\n     * // default key accessor\r\n     * chart.keyAccessor(function(d) { return d.key; });\r\n     * // custom key accessor for a multi-value crossfilter reduction\r\n     * chart.keyAccessor(function(p) { return p.value.absGain; });\r\n     * @param {Function} [keyAccessor]\r\n     * @returns {Function|dc.baseMixin}\r\n     */\n    _chart.keyAccessor = function (keyAccessor) {\n        if (!arguments.length) {\n            return _keyAccessor;\n        }\n        _keyAccessor = keyAccessor;\n        return _chart;\n    };\n\n    /**\r\n     * Set or get the value accessor function. The value accessor function is used to retrieve the\r\n     * value from the crossfilter group. Group values are used differently in different charts, for\r\n     * example values correspond to slice sizes in a pie chart and y axis positions in a grid\r\n     * coordinate chart.\r\n     * @method valueAccessor\r\n     * @memberof dc.baseMixin\r\n     * @instance\r\n     * @example\r\n     * // default value accessor\r\n     * chart.valueAccessor(function(d) { return d.value; });\r\n     * // custom value accessor for a multi-value crossfilter reduction\r\n     * chart.valueAccessor(function(p) { return p.value.percentageGain; });\r\n     * @param {Function} [valueAccessor]\r\n     * @returns {Function|dc.baseMixin}\r\n     */\n    _chart.valueAccessor = function (valueAccessor) {\n        if (!arguments.length) {\n            return _valueAccessor;\n        }\n        _valueAccessor = valueAccessor;\n        return _chart;\n    };\n\n    /**\r\n     * Set or get the label function. The chart class will use this function to render labels for each\r\n     * child element in the chart, e.g. slices in a pie chart or bubbles in a bubble chart. Not every\r\n     * chart supports the label function, for example line chart does not use this function\r\n     * at all. By default, enables labels; pass false for the second parameter if this is not desired.\r\n     * @method label\r\n     * @memberof dc.baseMixin\r\n     * @instance\r\n     * @example\r\n     * // default label function just return the key\r\n     * chart.label(function(d) { return d.key; });\r\n     * // label function has access to the standard d3 data binding and can get quite complicated\r\n     * chart.label(function(d) { return d.data.key + '(' + Math.floor(d.data.value / all.value() * 100) + '%)'; });\r\n     * @param {Function} [labelFunction]\r\n     * @param {Boolean} [enableLabels=true]\r\n     * @returns {Function|dc.baseMixin}\r\n     */\n    _chart.label = function (labelFunction, enableLabels) {\n        if (!arguments.length) {\n            return _label;\n        }\n        _label = labelFunction;\n        if (enableLabels === undefined || enableLabels) {\n            _renderLabel = true;\n        }\n        return _chart;\n    };\n\n    /**\r\n     * Turn on/off label rendering\r\n     * @method renderLabel\r\n     * @memberof dc.baseMixin\r\n     * @instance\r\n     * @param {Boolean} [renderLabel=false]\r\n     * @returns {Boolean|dc.baseMixin}\r\n     */\n    _chart.renderLabel = function (renderLabel) {\n        if (!arguments.length) {\n            return _renderLabel;\n        }\n        _renderLabel = renderLabel;\n        return _chart;\n    };\n\n    /**\r\n     * Set or get the title function. The chart class will use this function to render the SVGElement title\r\n     * (usually interpreted by browser as tooltips) for each child element in the chart, e.g. a slice\r\n     * in a pie chart or a bubble in a bubble chart. Almost every chart supports the title function;\r\n     * however in grid coordinate charts you need to turn off the brush in order to see titles, because\r\n     * otherwise the brush layer will block tooltip triggering.\r\n     * @method title\r\n     * @memberof dc.baseMixin\r\n     * @instance\r\n     * @example\r\n     * // default title function shows \"key: value\"\r\n     * chart.title(function(d) { return d.key + ': ' + d.value; });\r\n     * // title function has access to the standard d3 data binding and can get quite complicated\r\n     * chart.title(function(p) {\r\n     *    return p.key.getFullYear()\r\n     *        + '\\n'\r\n     *        + 'Index Gain: ' + numberFormat(p.value.absGain) + '\\n'\r\n     *        + 'Index Gain in Percentage: ' + numberFormat(p.value.percentageGain) + '%\\n'\r\n     *        + 'Fluctuation / Index Ratio: ' + numberFormat(p.value.fluctuationPercentage) + '%';\r\n     * });\r\n     * @param {Function} [titleFunction]\r\n     * @returns {Function|dc.baseMixin}\r\n     */\n    _chart.title = function (titleFunction) {\n        if (!arguments.length) {\n            return _title;\n        }\n        _title = titleFunction;\n        return _chart;\n    };\n\n    /**\r\n     * Turn on/off title rendering, or return the state of the render title flag if no arguments are\r\n     * given.\r\n     * @method renderTitle\r\n     * @memberof dc.baseMixin\r\n     * @instance\r\n     * @param {Boolean} [renderTitle=true]\r\n     * @returns {Boolean|dc.baseMixin}\r\n     */\n    _chart.renderTitle = function (renderTitle) {\n        if (!arguments.length) {\n            return _renderTitle;\n        }\n        _renderTitle = renderTitle;\n        return _chart;\n    };\n\n    /**\r\n     * A renderlet is similar to an event listener on rendering event. Multiple renderlets can be added\r\n     * to an individual chart.  Each time a chart is rerendered or redrawn the renderlets are invoked\r\n     * right after the chart finishes its transitions, giving you a way to modify the SVGElements.\r\n     * Renderlet functions take the chart instance as the only input parameter and you can\r\n     * use the dc API or use raw d3 to achieve pretty much any effect.\r\n     *\r\n     * Use {@link dc.baseMixin#on on} with a 'renderlet' prefix.\r\n     * Generates a random key for the renderlet, which makes it hard to remove.\r\n     * @method renderlet\r\n     * @memberof dc.baseMixin\r\n     * @instance\r\n     * @deprecated\r\n     * @example\r\n     * // do this instead of .renderlet(function(chart) { ... })\r\n     * chart.on(\"renderlet\", function(chart){\r\n     *     // mix of dc API and d3 manipulation\r\n     *     chart.select('g.y').style('display', 'none');\r\n     *     // its a closure so you can also access other chart variable available in the closure scope\r\n     *     moveChart.filter(chart.filter());\r\n     * });\r\n     * @param {Function} renderletFunction\r\n     * @returns {dc.baseMixin}\r\n     */\n    _chart.renderlet = dc.logger.deprecate(function (renderletFunction) {\n        _chart.on('renderlet.' + dc.utils.uniqueId(), renderletFunction);\n        return _chart;\n    }, 'chart.renderlet has been deprecated.  Please use chart.on(\"renderlet.<renderletKey>\", renderletFunction)');\n\n    /**\r\n     * Get or set the chart group to which this chart belongs. Chart groups are rendered or redrawn\r\n     * together since it is expected they share the same underlying crossfilter data set.\r\n     * @method chartGroup\r\n     * @memberof dc.baseMixin\r\n     * @instance\r\n     * @param {String} [chartGroup]\r\n     * @returns {String|dc.baseMixin}\r\n     */\n    _chart.chartGroup = function (chartGroup) {\n        if (!arguments.length) {\n            return _chartGroup;\n        }\n        if (!_isChild) {\n            dc.deregisterChart(_chart, _chartGroup);\n        }\n        _chartGroup = chartGroup;\n        if (!_isChild) {\n            dc.registerChart(_chart, _chartGroup);\n        }\n        return _chart;\n    };\n\n    /**\r\n     * Expire the internal chart cache. dc charts cache some data internally on a per chart basis to\r\n     * speed up rendering and avoid unnecessary calculation; however it might be useful to clear the\r\n     * cache if you have changed state which will affect rendering.  For example, if you invoke\r\n     * {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#crossfilter_add crossfilter.add}\r\n     * function or reset group or dimension after rendering, it is a good idea to\r\n     * clear the cache to make sure charts are rendered properly.\r\n     * @method expireCache\r\n     * @memberof dc.baseMixin\r\n     * @instance\r\n     * @returns {dc.baseMixin}\r\n     */\n    _chart.expireCache = function () {\n        // do nothing in base, should be overridden by sub-function\n        return _chart;\n    };\n\n    /**\r\n     * Attach a dc.legend widget to this chart. The legend widget will automatically draw legend labels\r\n     * based on the color setting and names associated with each group.\r\n     * @method legend\r\n     * @memberof dc.baseMixin\r\n     * @instance\r\n     * @example\r\n     * chart.legend(dc.legend().x(400).y(10).itemHeight(13).gap(5))\r\n     * @param {dc.legend} [legend]\r\n     * @returns {dc.legend|dc.baseMixin}\r\n     */\n    _chart.legend = function (legend) {\n        if (!arguments.length) {\n            return _legend;\n        }\n        _legend = legend;\n        _legend.parent(_chart);\n        return _chart;\n    };\n\n    /**\r\n     * Returns the internal numeric ID of the chart.\r\n     * @method chartID\r\n     * @memberof dc.baseMixin\r\n     * @instance\r\n     * @returns {String}\r\n     */\n    _chart.chartID = function () {\n        return _chart.__dcFlag__;\n    };\n\n    /**\r\n     * Set chart options using a configuration object. Each key in the object will cause the method of\r\n     * the same name to be called with the value to set that attribute for the chart.\r\n     * @method options\r\n     * @memberof dc.baseMixin\r\n     * @instance\r\n     * @example\r\n     * chart.options({dimension: myDimension, group: myGroup});\r\n     * @param {{}} opts\r\n     * @returns {dc.baseMixin}\r\n     */\n    _chart.options = function (opts) {\n        var applyOptions = ['anchor', 'group', 'xAxisLabel', 'yAxisLabel', 'stack', 'title', 'point', 'getColor', 'overlayGeoJson'];\n\n        for (var o in opts) {\n            if (typeof _chart[o] === 'function') {\n                if (opts[o] instanceof Array && applyOptions.indexOf(o) !== -1) {\n                    _chart[o].apply(_chart, opts[o]);\n                } else {\n                    _chart[o].call(_chart, opts[o]);\n                }\n            } else {\n                dc.logger.debug('Not a valid option setter name: ' + o);\n            }\n        }\n        return _chart;\n    };\n\n    /**\r\n     * All dc chart instance supports the following listeners.\r\n     * Supports the following events:\r\n     * * `renderlet` - This listener function will be invoked after transitions after redraw and render. Replaces the\r\n     * deprecated {@link dc.baseMixin#renderlet renderlet} method.\r\n     * * `pretransition` - Like `.on('renderlet', ...)` but the event is fired before transitions start.\r\n     * * `preRender` - This listener function will be invoked before chart rendering.\r\n     * * `postRender` - This listener function will be invoked after chart finish rendering including\r\n     * all renderlets' logic.\r\n     * * `preRedraw` - This listener function will be invoked before chart redrawing.\r\n     * * `postRedraw` - This listener function will be invoked after chart finish redrawing\r\n     * including all renderlets' logic.\r\n     * * `filtered` - This listener function will be invoked after a filter is applied, added or removed.\r\n     * * `zoomed` - This listener function will be invoked after a zoom is triggered.\r\n     * @method on\r\n     * @memberof dc.baseMixin\r\n     * @instance\r\n     * @see {@link https://github.com/d3/d3-dispatch/blob/master/README.md#dispatch_on d3.dispatch.on}\r\n     * @example\r\n     * .on('renderlet', function(chart, filter){...})\r\n     * .on('pretransition', function(chart, filter){...})\r\n     * .on('preRender', function(chart){...})\r\n     * .on('postRender', function(chart){...})\r\n     * .on('preRedraw', function(chart){...})\r\n     * .on('postRedraw', function(chart){...})\r\n     * .on('filtered', function(chart, filter){...})\r\n     * .on('zoomed', function(chart, filter){...})\r\n     * @param {String} event\r\n     * @param {Function} listener\r\n     * @returns {dc.baseMixin}\r\n     */\n    _chart.on = function (event, listener) {\n        _listeners.on(event, listener);\n        return _chart;\n    };\n\n    return _chart;\n};\n\n/**\r\n * Margin is a mixin that provides margin utility functions for both the Row Chart and Coordinate Grid\r\n * Charts.\r\n * @name marginMixin\r\n * @memberof dc\r\n * @mixin\r\n * @param {Object} _chart\r\n * @returns {dc.marginMixin}\r\n */\ndc.marginMixin = function (_chart) {\n    var _margin = { top: 10, right: 50, bottom: 30, left: 30 };\n\n    /**\r\n     * Get or set the margins for a particular coordinate grid chart instance. The margins is stored as\r\n     * an associative Javascript array.\r\n     * @method margins\r\n     * @memberof dc.marginMixin\r\n     * @instance\r\n     * @example\r\n     * var leftMargin = chart.margins().left; // 30 by default\r\n     * chart.margins().left = 50;\r\n     * leftMargin = chart.margins().left; // now 50\r\n     * @param {{top: Number, right: Number, left: Number, bottom: Number}} [margins={top: 10, right: 50, bottom: 30, left: 30}]\r\n     * @returns {{top: Number, right: Number, left: Number, bottom: Number}|dc.marginMixin}\r\n     */\n    _chart.margins = function (margins) {\n        if (!arguments.length) {\n            return _margin;\n        }\n        _margin = margins;\n        return _chart;\n    };\n\n    _chart.effectiveWidth = function () {\n        return _chart.width() - _chart.margins().left - _chart.margins().right;\n    };\n\n    _chart.effectiveHeight = function () {\n        return _chart.height() - _chart.margins().top - _chart.margins().bottom;\n    };\n\n    return _chart;\n};\n\n/**\r\n * The Color Mixin is an abstract chart functional class providing universal coloring support\r\n * as a mix-in for any concrete chart implementation.\r\n * @name colorMixin\r\n * @memberof dc\r\n * @mixin\r\n * @param {Object} _chart\r\n * @returns {dc.colorMixin}\r\n */\ndc.colorMixin = function (_chart) {\n    var _colors = _d.d3.scaleOrdinal(dc.config.defaultColors());\n    var _defaultAccessor = true;\n\n    var _colorAccessor = function _colorAccessor(d) {\n        return _chart.keyAccessor()(d);\n    };\n\n    /**\r\n     * Retrieve current color scale or set a new color scale. This methods accepts any function that\r\n     * operates like a d3 scale.\r\n     * @method colors\r\n     * @memberof dc.colorMixin\r\n     * @instance\r\n     * @see {@link https://github.com/d3/d3-scale/blob/master/README.md d3.scale}\r\n     * @example\r\n     * // alternate categorical scale\r\n     * chart.colors(d3.scale.category20b());\r\n     * // ordinal scale\r\n     * chart.colors(d3.scaleOrdinal().range(['red','green','blue']));\r\n     * // convenience method, the same as above\r\n     * chart.ordinalColors(['red','green','blue']);\r\n     * // set a linear scale\r\n     * chart.linearColors([\"#4575b4\", \"#ffffbf\", \"#a50026\"]);\r\n     * @param {d3.scale} [colorScale=d3.scaleOrdinal(d3.schemeCategory20c)]\r\n     * @returns {d3.scale|dc.colorMixin}\r\n     */\n    _chart.colors = function (colorScale) {\n        if (!arguments.length) {\n            return _colors;\n        }\n        if (colorScale instanceof Array) {\n            _colors = _d.d3.scaleQuantize().range(colorScale); // deprecated legacy support, note: this fails for ordinal domains\n        } else {\n            _colors = typeof colorScale === 'function' ? colorScale : dc.utils.constant(colorScale);\n        }\n        return _chart;\n    };\n\n    /**\r\n     * Convenience method to set the color scale to\r\n     * {@link https://github.com/d3/d3-scale/blob/master/README.md#ordinal-scales d3.scaleOrdinal} with\r\n     * range `r`.\r\n     * @method ordinalColors\r\n     * @memberof dc.colorMixin\r\n     * @instance\r\n     * @param {Array<String>} r\r\n     * @returns {dc.colorMixin}\r\n     */\n    _chart.ordinalColors = function (r) {\n        return _chart.colors(_d.d3.scaleOrdinal().range(r));\n    };\n\n    /**\r\n     * Convenience method to set the color scale to an Hcl interpolated linear scale with range `r`.\r\n     * @method linearColors\r\n     * @memberof dc.colorMixin\r\n     * @instance\r\n     * @param {Array<Number>} r\r\n     * @returns {dc.colorMixin}\r\n     */\n    _chart.linearColors = function (r) {\n        return _chart.colors(_d.d3.scaleLinear().range(r).interpolate(_d.d3.interpolateHcl));\n    };\n\n    /**\r\n     * Set or the get color accessor function. This function will be used to map a data point in a\r\n     * crossfilter group to a color value on the color scale. The default function uses the key\r\n     * accessor.\r\n     * @method colorAccessor\r\n     * @memberof dc.colorMixin\r\n     * @instance\r\n     * @example\r\n     * // default index based color accessor\r\n     * .colorAccessor(function (d, i){return i;})\r\n     * // color accessor for a multi-value crossfilter reduction\r\n     * .colorAccessor(function (d){return d.value.absGain;})\r\n     * @param {Function} [colorAccessor]\r\n     * @returns {Function|dc.colorMixin}\r\n     */\n    _chart.colorAccessor = function (colorAccessor) {\n        if (!arguments.length) {\n            return _colorAccessor;\n        }\n        _colorAccessor = colorAccessor;\n        _defaultAccessor = false;\n        return _chart;\n    };\n\n    // what is this?\n    _chart.defaultColorAccessor = function () {\n        return _defaultAccessor;\n    };\n\n    /**\r\n     * Set or get the current domain for the color mapping function. The domain must be supplied as an\r\n     * array.\r\n     *\r\n     * Note: previously this method accepted a callback function. Instead you may use a custom scale\r\n     * set by {@link dc.colorMixin#colors .colors}.\r\n     * @method colorDomain\r\n     * @memberof dc.colorMixin\r\n     * @instance\r\n     * @param {Array<String>} [domain]\r\n     * @returns {Array<String>|dc.colorMixin}\r\n     */\n    _chart.colorDomain = function (domain) {\n        if (!arguments.length) {\n            return _colors.domain();\n        }\n        _colors.domain(domain);\n        return _chart;\n    };\n\n    /**\r\n     * Set the domain by determining the min and max values as retrieved by\r\n     * {@link dc.colorMixin#colorAccessor .colorAccessor} over the chart's dataset.\r\n     * @method calculateColorDomain\r\n     * @memberof dc.colorMixin\r\n     * @instance\r\n     * @returns {dc.colorMixin}\r\n     */\n    _chart.calculateColorDomain = function () {\n        var newDomain = [_d.d3.min(_chart.data(), _chart.colorAccessor()), _d.d3.max(_chart.data(), _chart.colorAccessor())];\n        _colors.domain(newDomain);\n        return _chart;\n    };\n\n    /**\r\n     * Get the color for the datum d and counter i. This is used internally by charts to retrieve a color.\r\n     * @method getColor\r\n     * @memberof dc.colorMixin\r\n     * @instance\r\n     * @param {*} d\r\n     * @param {Number} [i]\r\n     * @returns {String}\r\n     */\n    _chart.getColor = function (d, i) {\n        return _colors(_colorAccessor.call(this, d, i));\n    };\n\n    /**\r\n     * **Deprecated.** Get/set the color calculator. This actually replaces the\r\n     * {@link dc.colorMixin#getColor getColor} method!\r\n     *\r\n     * This is not recommended, since using a {@link dc.colorMixin#colorAccessor colorAccessor} and\r\n     * color scale ({@link dc.colorMixin#colors .colors}) is more powerful and idiomatic d3.\r\n     * @method colorCalculator\r\n     * @memberof dc.colorMixin\r\n     * @instance\r\n     * @param {*} [colorCalculator]\r\n     * @returns {Function|dc.colorMixin}\r\n     */\n    _chart.colorCalculator = dc.logger.deprecate(function (colorCalculator) {\n        if (!arguments.length) {\n            return _chart.getColor;\n        }\n        _chart.getColor = colorCalculator;\n        return _chart;\n    }, 'colorMixin.colorCalculator has been deprecated. Please colorMixin.colors and colorMixin.colorAccessor instead');\n\n    return _chart;\n};\n\n/**\r\n * Coordinate Grid is an abstract base chart designed to support a number of coordinate grid based\r\n * concrete chart types, e.g. bar chart, line chart, and bubble chart.\r\n * @name coordinateGridMixin\r\n * @memberof dc\r\n * @mixin\r\n * @mixes dc.colorMixin\r\n * @mixes dc.marginMixin\r\n * @mixes dc.baseMixin\r\n * @param {Object} _chart\r\n * @returns {dc.coordinateGridMixin}\r\n */\ndc.coordinateGridMixin = function (_chart) {\n    var GRID_LINE_CLASS = 'grid-line';\n    var HORIZONTAL_CLASS = 'horizontal';\n    var VERTICAL_CLASS = 'vertical';\n    var Y_AXIS_LABEL_CLASS = 'y-axis-label';\n    var X_AXIS_LABEL_CLASS = 'x-axis-label';\n    var CUSTOM_BRUSH_HANDLE_CLASS = 'custom-brush-handle';\n    var DEFAULT_AXIS_LABEL_PADDING = 12;\n\n    _chart = dc.colorMixin(dc.marginMixin(dc.baseMixin(_chart)));\n\n    _chart.colors(_d.d3.scaleOrdinal(_d.d3.schemeCategory10));\n    _chart._mandatoryAttributes().push('x');\n    var _parent;\n    var _g;\n    var _chartBodyG;\n\n    var _x;\n    var _origX; // Will hold orginial scale in case of zoom\n    var _xOriginalDomain;\n    var _xAxis = _d.d3.axisBottom();\n    var _xUnits = dc.units.integers;\n    var _xAxisPadding = 0;\n    var _xAxisPaddingUnit = _d.d3.timeDay;\n    var _xElasticity = false;\n    var _xAxisLabel;\n    var _xAxisLabelPadding = 0;\n    var _lastXDomain;\n\n    var _y;\n    var _yAxis = null;\n    var _yAxisPadding = 0;\n    var _yElasticity = false;\n    var _yAxisLabel;\n    var _yAxisLabelPadding = 0;\n\n    var _brush = _d.d3.brushX();\n    var _gBrush;\n    var _brushOn = true;\n    var _parentBrushOn = false;\n    var _round;\n\n    var _renderHorizontalGridLine = false;\n    var _renderVerticalGridLine = false;\n\n    var _resizing = false;\n    var _unitCount;\n\n    var _zoomScale = [1, Infinity];\n    var _zoomOutRestrict = true;\n\n    var _zoom = _d.d3.zoom().on('zoom', onZoom);\n    var _nullZoom = _d.d3.zoom().on('zoom', null);\n    var _hasBeenMouseZoomable = false;\n\n    var _rangeChart;\n    var _focusChart;\n\n    var _mouseZoomable = false;\n    var _clipPadding = 0;\n\n    var _outerRangeBandPadding = 0.5;\n    var _rangeBandPadding = 0;\n\n    var _useRightYAxis = false;\n\n    /**\r\n     * When changing the domain of the x or y scale, it is necessary to tell the chart to recalculate\r\n     * and redraw the axes. (`.rescale()` is called automatically when the x or y scale is replaced\r\n     * with {@link dc.coordinateGridMixin+x .x()} or {@link dc.coordinateGridMixin#y .y()}, and has\r\n     * no effect on elastic scales.)\r\n     * @method rescale\r\n     * @memberof dc.coordinateGridMixin\r\n     * @instance\r\n     * @returns {dc.coordinateGridMixin}\r\n     */\n    _chart.rescale = function () {\n        _unitCount = undefined;\n        _resizing = true;\n        return _chart;\n    };\n\n    _chart.resizing = function () {\n        return _resizing;\n    };\n\n    /**\r\n     * Get or set the range selection chart associated with this instance. Setting the range selection\r\n     * chart using this function will automatically update its selection brush when the current chart\r\n     * zooms in. In return the given range chart will also automatically attach this chart as its focus\r\n     * chart hence zoom in when range brush updates.\r\n     *\r\n     * Usually the range and focus charts will share a dimension. The range chart will set the zoom\r\n     * boundaries for the focus chart, so its dimension values must be compatible with the domain of\r\n     * the focus chart.\r\n     *\r\n     * See the [Nasdaq 100 Index](http://dc-js.github.com/dc.js/) example for this effect in action.\r\n     * @method rangeChart\r\n     * @memberof dc.coordinateGridMixin\r\n     * @instance\r\n     * @param {dc.coordinateGridMixin} [rangeChart]\r\n     * @returns {dc.coordinateGridMixin}\r\n     */\n    _chart.rangeChart = function (rangeChart) {\n        if (!arguments.length) {\n            return _rangeChart;\n        }\n        _rangeChart = rangeChart;\n        _rangeChart.focusChart(_chart);\n        return _chart;\n    };\n\n    /**\r\n     * Get or set the scale extent for mouse zooms.\r\n     * @method zoomScale\r\n     * @memberof dc.coordinateGridMixin\r\n     * @instance\r\n     * @param {Array<Number|Date>} [extent=[1, Infinity]]\r\n     * @returns {Array<Number|Date>|dc.coordinateGridMixin}\r\n     */\n    _chart.zoomScale = function (extent) {\n        if (!arguments.length) {\n            return _zoomScale;\n        }\n        _zoomScale = extent;\n        return _chart;\n    };\n\n    /**\r\n     * Get or set the zoom restriction for the chart. If true limits the zoom to origional domain of the chart.\r\n     * @method zoomOutRestrict\r\n     * @memberof dc.coordinateGridMixin\r\n     * @instance\r\n     * @param {Boolean} [zoomOutRestrict=true]\r\n     * @returns {Boolean|dc.coordinateGridMixin}\r\n     */\n    _chart.zoomOutRestrict = function (zoomOutRestrict) {\n        if (!arguments.length) {\n            return _zoomOutRestrict;\n        }\n        _zoomOutRestrict = zoomOutRestrict;\n        return _chart;\n    };\n\n    _chart._generateG = function (parent) {\n        if (parent === undefined) {\n            _parent = _chart.svg();\n        } else {\n            _parent = parent;\n        }\n\n        var href = window.location.href.split('#')[0];\n\n        _g = _parent.append('g');\n\n        _chartBodyG = _g.append('g').attr('class', 'chart-body').attr('transform', 'translate(' + _chart.margins().left + ', ' + _chart.margins().top + ')').attr('clip-path', 'url(' + href + '#' + getClipPathId() + ')');\n\n        return _g;\n    };\n\n    /**\r\n     * Get or set the root g element. This method is usually used to retrieve the g element in order to\r\n     * overlay custom svg drawing programatically. **Caution**: The root g element is usually generated\r\n     * by dc.js internals, and resetting it might produce unpredictable result.\r\n     * @method g\r\n     * @memberof dc.coordinateGridMixin\r\n     * @instance\r\n     * @param {SVGElement} [gElement]\r\n     * @returns {SVGElement|dc.coordinateGridMixin}\r\n     */\n    _chart.g = function (gElement) {\n        if (!arguments.length) {\n            return _g;\n        }\n        _g = gElement;\n        return _chart;\n    };\n\n    /**\r\n     * Set or get mouse zoom capability flag (default: false). When turned on the chart will be\r\n     * zoomable using the mouse wheel. If the range selector chart is attached zooming will also update\r\n     * the range selection brush on the associated range selector chart.\r\n     * @method mouseZoomable\r\n     * @memberof dc.coordinateGridMixin\r\n     * @instance\r\n     * @param {Boolean} [mouseZoomable=false]\r\n     * @returns {Boolean|dc.coordinateGridMixin}\r\n     */\n    _chart.mouseZoomable = function (mouseZoomable) {\n        if (!arguments.length) {\n            return _mouseZoomable;\n        }\n        _mouseZoomable = mouseZoomable;\n        return _chart;\n    };\n\n    /**\r\n     * Retrieve the svg group for the chart body.\r\n     * @method chartBodyG\r\n     * @memberof dc.coordinateGridMixin\r\n     * @instance\r\n     * @param {SVGElement} [chartBodyG]\r\n     * @returns {SVGElement}\r\n     */\n    _chart.chartBodyG = function (chartBodyG) {\n        if (!arguments.length) {\n            return _chartBodyG;\n        }\n        _chartBodyG = chartBodyG;\n        return _chart;\n    };\n\n    /**\r\n     * **mandatory**\r\n     *\r\n     * Get or set the x scale. The x scale can be any d3\r\n     * {@link https://github.com/d3/d3-scale/blob/master/README.md d3.scale} or\r\n     * {@link https://github.com/d3/d3-scale/blob/master/README.md#ordinal-scales ordinal scale}\r\n     * @method x\r\n     * @memberof dc.coordinateGridMixin\r\n     * @instance\r\n     * @see {@link https://github.com/d3/d3-scale/blob/master/README.md d3.scale}\r\n     * @example\r\n     * // set x to a linear scale\r\n     * chart.x(d3.scaleLinear().domain([-2500, 2500]))\r\n     * // set x to a time scale to generate histogram\r\n     * chart.x(d3.scaleTime().domain([new Date(1985, 0, 1), new Date(2012, 11, 31)]))\r\n     * @param {d3.scale} [xScale]\r\n     * @returns {d3.scale|dc.coordinateGridMixin}\r\n     */\n    _chart.x = function (xScale) {\n        if (!arguments.length) {\n            return _x;\n        }\n        _x = xScale;\n        _xOriginalDomain = _x.domain();\n        _chart.rescale();\n        return _chart;\n    };\n\n    _chart.xOriginalDomain = function () {\n        return _xOriginalDomain;\n    };\n\n    /**\r\n     * Set or get the xUnits function. The coordinate grid chart uses the xUnits function to calculate\r\n     * the number of data projections on the x axis such as the number of bars for a bar chart or the\r\n     * number of dots for a line chart.\r\n     *\r\n     * This function is expected to return a Javascript array of all data points on the x axis, or\r\n     * the number of points on the axis. d3 time range functions [d3.timeDays, d3.timeMonths, and\r\n     * d3.timeYears](https://github.com/d3/d3-time/blob/master/README.md#intervals) are all valid\r\n     * xUnits functions.\r\n     *\r\n     * dc.js also provides a few units function, see the {@link dc.units Units Namespace} for\r\n     * a list of built-in units functions.\r\n     *\r\n     * Note that as of dc.js 3.0, `dc.units.ordinal` is not a real function, because it is not\r\n     * possible to define this function compliant with the d3 range functions. It was already a\r\n     * magic value which caused charts to behave differently, and now it is completely so.\r\n     * @method xUnits\r\n     * @memberof dc.coordinateGridMixin\r\n     * @instance\r\n     * @example\r\n     * // set x units to count days\r\n     * chart.xUnits(d3.timeDays);\r\n     * // set x units to count months\r\n     * chart.xUnits(d3.timeMonths);\r\n     *\r\n     * // A custom xUnits function can be used as long as it follows the following interface:\r\n     * // units in integer\r\n     * function(start, end) {\r\n     *      // simply calculates how many integers in the domain\r\n     *      return Math.abs(end - start);\r\n     * }\r\n     *\r\n     * // fixed units\r\n     * function(start, end) {\r\n     *      // be aware using fixed units will disable the focus/zoom ability on the chart\r\n     *      return 1000;\r\n     * }\r\n     * @param {Function} [xUnits=dc.units.integers]\r\n     * @returns {Function|dc.coordinateGridMixin}\r\n     */\n    _chart.xUnits = function (xUnits) {\n        if (!arguments.length) {\n            return _xUnits;\n        }\n        _xUnits = xUnits;\n        return _chart;\n    };\n\n    /**\r\n     * Set or get the x axis used by a particular coordinate grid chart instance. This function is most\r\n     * useful when x axis customization is required. The x axis in dc.js is an instance of a\r\n     * {@link https://github.com/d3/d3-axis/blob/master/README.md#axisBottom d3 bottom axis object};\r\n     * therefore it supports any valid d3 axisBottom manipulation.\r\n     *\r\n     * **Caution**: The x axis is usually generated internally by dc; resetting it may cause\r\n     * unexpected results. Note also that when used as a getter, this function is not chainable:\r\n     * it returns the axis, not the chart,\r\n     * {@link https://github.com/dc-js/dc.js/wiki/FAQ#why-does-everything-break-after-a-call-to-xaxis-or-yaxis\r\n     * so attempting to call chart functions after calling `.xAxis()` will fail}.\r\n     * @method xAxis\r\n     * @memberof dc.coordinateGridMixin\r\n     * @instance\r\n     * @see {@link https://github.com/d3/d3-axis/blob/master/README.md#axisBottom d3.axisBottom}\r\n     * @example\r\n     * // customize x axis tick format\r\n     * chart.xAxis().tickFormat(function(v) {return v + '%';});\r\n     * // customize x axis tick values\r\n     * chart.xAxis().tickValues([0, 100, 200, 300]);\r\n     * @param {d3.axis} [xAxis=d3.axisBottom()]\r\n     * @returns {d3.axis|dc.coordinateGridMixin}\r\n     */\n    _chart.xAxis = function (xAxis) {\n        if (!arguments.length) {\n            return _xAxis;\n        }\n        _xAxis = xAxis;\n        return _chart;\n    };\n\n    /**\r\n     * Turn on/off elastic x axis behavior. If x axis elasticity is turned on, then the grid chart will\r\n     * attempt to recalculate the x axis range whenever a redraw event is triggered.\r\n     * @method elasticX\r\n     * @memberof dc.coordinateGridMixin\r\n     * @instance\r\n     * @param {Boolean} [elasticX=false]\r\n     * @returns {Boolean|dc.coordinateGridMixin}\r\n     */\n    _chart.elasticX = function (elasticX) {\n        if (!arguments.length) {\n            return _xElasticity;\n        }\n        _xElasticity = elasticX;\n        return _chart;\n    };\n\n    /**\r\n     * Set or get x axis padding for the elastic x axis. The padding will be added to both end of the x\r\n     * axis if elasticX is turned on; otherwise it is ignored.\r\n     *\r\n     * Padding can be an integer or percentage in string (e.g. '10%'). Padding can be applied to\r\n     * number or date x axes.  When padding a date axis, an integer represents number of units being padded\r\n     * and a percentage string will be treated the same as an integer. The unit will be determined by the\r\n     * xAxisPaddingUnit variable.\r\n     * @method xAxisPadding\r\n     * @memberof dc.coordinateGridMixin\r\n     * @instance\r\n     * @param {Number|String} [padding=0]\r\n     * @returns {Number|String|dc.coordinateGridMixin}\r\n     */\n    _chart.xAxisPadding = function (padding) {\n        if (!arguments.length) {\n            return _xAxisPadding;\n        }\n        _xAxisPadding = padding;\n        return _chart;\n    };\n\n    /**\r\n     * Set or get x axis padding unit for the elastic x axis. The padding unit will determine which unit to\r\n     * use when applying xAxis padding if elasticX is turned on and if x-axis uses a time dimension;\r\n     * otherwise it is ignored.\r\n     *\r\n     * The padding unit should be a\r\n     * [d3 time interval](https://github.com/d3/d3-time/blob/master/README.md#_interval).\r\n     * For backward compatibility with dc.js 2.0, it can also be the name of a d3 time interval\r\n     * ('day', 'hour', etc). Available arguments are the\r\n     * [d3 time intervals](https://github.com/d3/d3-time/blob/master/README.md#intervals d3.timeInterval).\r\n     * @method xAxisPaddingUnit\r\n     * @memberof dc.coordinateGridMixin\r\n     * @instance\r\n     * @param {String} [unit=d3.timeDay]\r\n     * @returns {String|dc.coordinateGridMixin}\r\n     */\n    _chart.xAxisPaddingUnit = function (unit) {\n        if (!arguments.length) {\n            return _xAxisPaddingUnit;\n        }\n        _xAxisPaddingUnit = unit;\n        return _chart;\n    };\n\n    /**\r\n     * Returns the number of units displayed on the x axis. If the x axis is ordinal (`xUnits` is\r\n     * `dc.units.ordinal`), this is the number of items in the domain of the x scale. Otherwise, the\r\n     * x unit count is calculated using the {@link dc.coordinateGridMixin#xUnits xUnits} function.\r\n     * @method xUnitCount\r\n     * @memberof dc.coordinateGridMixin\r\n     * @instance\r\n     * @returns {Number}\r\n     */\n    _chart.xUnitCount = function () {\n        if (_unitCount === undefined) {\n            if (_chart.isOrdinal()) {\n                // In this case it number of items in domain\n                _unitCount = _chart.x().domain().length;\n            } else {\n                _unitCount = _chart.xUnits()(_chart.x().domain()[0], _chart.x().domain()[1]);\n\n                // Sometimes xUnits() may return an array while sometimes directly the count\n                if (_unitCount instanceof Array) {\n                    _unitCount = _unitCount.length;\n                }\n            }\n        }\n\n        return _unitCount;\n    };\n\n    /**\r\n     * Gets or sets whether the chart should be drawn with a right axis instead of a left axis. When\r\n     * used with a chart in a composite chart, allows both left and right Y axes to be shown on a\r\n     * chart.\r\n     * @method useRightYAxis\r\n     * @memberof dc.coordinateGridMixin\r\n     * @instance\r\n     * @param {Boolean} [useRightYAxis=false]\r\n     * @returns {Boolean|dc.coordinateGridMixin}\r\n     */\n    _chart.useRightYAxis = function (useRightYAxis) {\n        if (!arguments.length) {\n            return _useRightYAxis;\n        }\n\n        // We need to warn if value is changing after _yAxis was created\n        if (_useRightYAxis !== useRightYAxis && _yAxis) {\n            dc.logger.warn('Value of useRightYAxis has been altered, after yAxis was created. ' + 'You might get unexpected yAxis behavior. ' + 'Make calls to useRightYAxis sooner in your chart creation process.');\n        }\n\n        _useRightYAxis = useRightYAxis;\n        return _chart;\n    };\n\n    /**\r\n     * Returns true if the chart is using ordinal xUnits ({@link dc.units.ordinal dc.units.ordinal}, or false\r\n     * otherwise. Most charts behave differently with ordinal data and use the result of this method to\r\n     * trigger the appropriate logic.\r\n     * @method isOrdinal\r\n     * @memberof dc.coordinateGridMixin\r\n     * @instance\r\n     * @returns {Boolean}\r\n     */\n    _chart.isOrdinal = function () {\n        return _chart.xUnits() === dc.units.ordinal;\n    };\n\n    _chart._useOuterPadding = function () {\n        return true;\n    };\n\n    _chart._ordinalXDomain = function () {\n        var groups = _chart._computeOrderedGroups(_chart.data());\n        return groups.map(_chart.keyAccessor());\n    };\n\n    function prepareXAxis(g, render) {\n        if (!_chart.isOrdinal()) {\n            if (_chart.elasticX()) {\n                _x.domain([_chart.xAxisMin(), _chart.xAxisMax()]);\n            }\n        } else {\n            // _chart.isOrdinal()\n            // D3v4 - Ordinal charts would need scaleBand\n            // bandwidth is a method in scaleBand\n            // (https://github.com/d3/d3-scale/blob/master/README.md#scaleBand)\n            if (!_x.bandwidth) {\n                // If _x is not a scaleBand create a new scale and\n                // copy the original domain to the new scale\n                dc.logger.warn('For compatibility with d3v4+, dc.js d3.0 ordinal bar/line/bubble charts need ' + 'd3.scaleBand() for the x scale, instead of d3.scaleOrdinal(). ' + 'Replacing .x() with a d3.scaleBand with the same domain - ' + 'make the same change in your code to avoid this warning!');\n                _x = _d.d3.scaleBand().domain(_x.domain());\n            }\n\n            if (_chart.elasticX() || _x.domain().length === 0) {\n                _x.domain(_chart._ordinalXDomain());\n            }\n        }\n\n        // has the domain changed?\n        var xdom = _x.domain();\n        if (render || !dc.utils.arraysEqual(_lastXDomain, xdom)) {\n            _chart.rescale();\n        }\n        _lastXDomain = xdom;\n\n        // please can't we always use rangeBands for bar charts?\n        if (_chart.isOrdinal()) {\n            _x.range([0, _chart.xAxisLength()]).paddingInner(_rangeBandPadding).paddingOuter(_chart._useOuterPadding() ? _outerRangeBandPadding : 0);\n        } else {\n            _x.range([0, _chart.xAxisLength()]);\n        }\n\n        _xAxis = _xAxis.scale(_chart.x());\n\n        renderVerticalGridLines(g);\n    }\n\n    _chart.renderXAxis = function (g) {\n        var axisXG = g.select('g.x');\n\n        if (axisXG.empty()) {\n            axisXG = g.append('g').attr('class', 'axis x').attr('transform', 'translate(' + _chart.margins().left + ',' + _chart._xAxisY() + ')');\n        }\n\n        var axisXLab = g.select('text.' + X_AXIS_LABEL_CLASS);\n        if (axisXLab.empty() && _chart.xAxisLabel()) {\n            axisXLab = g.append('text').attr('class', X_AXIS_LABEL_CLASS).attr('transform', 'translate(' + (_chart.margins().left + _chart.xAxisLength() / 2) + ',' + (_chart.height() - _xAxisLabelPadding) + ')').attr('text-anchor', 'middle');\n        }\n        if (_chart.xAxisLabel() && axisXLab.text() !== _chart.xAxisLabel()) {\n            axisXLab.text(_chart.xAxisLabel());\n        }\n\n        dc.transition(axisXG, _chart.transitionDuration(), _chart.transitionDelay()).attr('transform', 'translate(' + _chart.margins().left + ',' + _chart._xAxisY() + ')').call(_xAxis);\n        dc.transition(axisXLab, _chart.transitionDuration(), _chart.transitionDelay()).attr('transform', 'translate(' + (_chart.margins().left + _chart.xAxisLength() / 2) + ',' + (_chart.height() - _xAxisLabelPadding) + ')');\n    };\n\n    function renderVerticalGridLines(g) {\n        var gridLineG = g.select('g.' + VERTICAL_CLASS);\n\n        if (_renderVerticalGridLine) {\n            if (gridLineG.empty()) {\n                gridLineG = g.insert('g', ':first-child').attr('class', GRID_LINE_CLASS + ' ' + VERTICAL_CLASS).attr('transform', 'translate(' + _chart.margins().left + ',' + _chart.margins().top + ')');\n            }\n\n            var ticks = _xAxis.tickValues() ? _xAxis.tickValues() : typeof _x.ticks === 'function' ? _x.ticks.apply(_x, _xAxis.tickArguments()) : _x.domain();\n\n            var lines = gridLineG.selectAll('line').data(ticks);\n\n            // enter\n            var linesGEnter = lines.enter().append('line').attr('x1', function (d) {\n                return _x(d);\n            }).attr('y1', _chart._xAxisY() - _chart.margins().top).attr('x2', function (d) {\n                return _x(d);\n            }).attr('y2', 0).attr('opacity', 0);\n            dc.transition(linesGEnter, _chart.transitionDuration(), _chart.transitionDelay()).attr('opacity', 1);\n\n            // update\n            var linesGEnterUpdate = linesGEnter.merge(lines);\n            dc.transition(linesGEnterUpdate, _chart.transitionDuration(), _chart.transitionDelay()).attr('x1', function (d) {\n                return _x(d);\n            }).attr('y1', _chart._xAxisY() - _chart.margins().top).attr('x2', function (d) {\n                return _x(d);\n            }).attr('y2', 0);\n\n            // exit\n            lines.exit().remove();\n        } else {\n            gridLineG.selectAll('line').remove();\n        }\n    }\n\n    _chart._xAxisY = function () {\n        return _chart.height() - _chart.margins().bottom;\n    };\n\n    _chart.xAxisLength = function () {\n        return _chart.effectiveWidth();\n    };\n\n    /**\r\n     * Set or get the x axis label. If setting the label, you may optionally include additional padding to\r\n     * the margin to make room for the label. By default the padded is set to 12 to accomodate the text height.\r\n     * @method xAxisLabel\r\n     * @memberof dc.coordinateGridMixin\r\n     * @instance\r\n     * @param {String} [labelText]\r\n     * @param {Number} [padding=12]\r\n     * @returns {String}\r\n     */\n    _chart.xAxisLabel = function (labelText, padding) {\n        if (!arguments.length) {\n            return _xAxisLabel;\n        }\n        _xAxisLabel = labelText;\n        _chart.margins().bottom -= _xAxisLabelPadding;\n        _xAxisLabelPadding = padding === undefined ? DEFAULT_AXIS_LABEL_PADDING : padding;\n        _chart.margins().bottom += _xAxisLabelPadding;\n        return _chart;\n    };\n\n    function createYAxis() {\n        return _useRightYAxis ? _d.d3.axisRight() : _d.d3.axisLeft();\n    }\n\n    _chart._prepareYAxis = function (g) {\n        if (_y === undefined || _chart.elasticY()) {\n            if (_y === undefined) {\n                _y = _d.d3.scaleLinear();\n            }\n            var min = _chart.yAxisMin() || 0,\n                max = _chart.yAxisMax() || 0;\n            _y.domain([min, max]).rangeRound([_chart.yAxisHeight(), 0]);\n        }\n\n        _y.range([_chart.yAxisHeight(), 0]);\n\n        if (!_yAxis) {\n            _yAxis = createYAxis();\n        }\n\n        _yAxis.scale(_y);\n\n        _chart._renderHorizontalGridLinesForAxis(g, _y, _yAxis);\n    };\n\n    _chart.renderYAxisLabel = function (axisClass, text, rotation, labelXPosition) {\n        labelXPosition = labelXPosition || _yAxisLabelPadding;\n\n        var axisYLab = _chart.g().select('text.' + Y_AXIS_LABEL_CLASS + '.' + axisClass + '-label');\n        var labelYPosition = _chart.margins().top + _chart.yAxisHeight() / 2;\n        if (axisYLab.empty() && text) {\n            axisYLab = _chart.g().append('text').attr('transform', 'translate(' + labelXPosition + ',' + labelYPosition + '),rotate(' + rotation + ')').attr('class', Y_AXIS_LABEL_CLASS + ' ' + axisClass + '-label').attr('text-anchor', 'middle').text(text);\n        }\n        if (text && axisYLab.text() !== text) {\n            axisYLab.text(text);\n        }\n        dc.transition(axisYLab, _chart.transitionDuration(), _chart.transitionDelay()).attr('transform', 'translate(' + labelXPosition + ',' + labelYPosition + '),rotate(' + rotation + ')');\n    };\n\n    _chart.renderYAxisAt = function (axisClass, axis, position) {\n        var axisYG = _chart.g().select('g.' + axisClass);\n        if (axisYG.empty()) {\n            axisYG = _chart.g().append('g').attr('class', 'axis ' + axisClass).attr('transform', 'translate(' + position + ',' + _chart.margins().top + ')');\n        }\n\n        dc.transition(axisYG, _chart.transitionDuration(), _chart.transitionDelay()).attr('transform', 'translate(' + position + ',' + _chart.margins().top + ')').call(axis);\n    };\n\n    _chart.renderYAxis = function () {\n        var axisPosition = _useRightYAxis ? _chart.width() - _chart.margins().right : _chart._yAxisX();\n        _chart.renderYAxisAt('y', _yAxis, axisPosition);\n        var labelPosition = _useRightYAxis ? _chart.width() - _yAxisLabelPadding : _yAxisLabelPadding;\n        var rotation = _useRightYAxis ? 90 : -90;\n        _chart.renderYAxisLabel('y', _chart.yAxisLabel(), rotation, labelPosition);\n    };\n\n    _chart._renderHorizontalGridLinesForAxis = function (g, scale, axis) {\n        var gridLineG = g.select('g.' + HORIZONTAL_CLASS);\n\n        if (_renderHorizontalGridLine) {\n            // see https://github.com/d3/d3-axis/blob/master/src/axis.js#L48\n            var ticks = axis.tickValues() ? axis.tickValues() : scale.ticks ? scale.ticks.apply(scale, axis.tickArguments()) : scale.domain();\n\n            if (gridLineG.empty()) {\n                gridLineG = g.insert('g', ':first-child').attr('class', GRID_LINE_CLASS + ' ' + HORIZONTAL_CLASS).attr('transform', 'translate(' + _chart.margins().left + ',' + _chart.margins().top + ')');\n            }\n\n            var lines = gridLineG.selectAll('line').data(ticks);\n\n            // enter\n            var linesGEnter = lines.enter().append('line').attr('x1', 1).attr('y1', function (d) {\n                return scale(d);\n            }).attr('x2', _chart.xAxisLength()).attr('y2', function (d) {\n                return scale(d);\n            }).attr('opacity', 0);\n            dc.transition(linesGEnter, _chart.transitionDuration(), _chart.transitionDelay()).attr('opacity', 1);\n\n            // update\n            var linesGEnterUpdate = linesGEnter.merge(lines);\n            dc.transition(linesGEnterUpdate, _chart.transitionDuration(), _chart.transitionDelay()).attr('x1', 1).attr('y1', function (d) {\n                return scale(d);\n            }).attr('x2', _chart.xAxisLength()).attr('y2', function (d) {\n                return scale(d);\n            });\n\n            // exit\n            lines.exit().remove();\n        } else {\n            gridLineG.selectAll('line').remove();\n        }\n    };\n\n    _chart._yAxisX = function () {\n        return _chart.useRightYAxis() ? _chart.width() - _chart.margins().right : _chart.margins().left;\n    };\n\n    /**\r\n     * Set or get the y axis label. If setting the label, you may optionally include additional padding\r\n     * to the margin to make room for the label. By default the padding is set to 12 to accommodate the\r\n     * text height.\r\n     * @method yAxisLabel\r\n     * @memberof dc.coordinateGridMixin\r\n     * @instance\r\n     * @param {String} [labelText]\r\n     * @param {Number} [padding=12]\r\n     * @returns {String|dc.coordinateGridMixin}\r\n     */\n    _chart.yAxisLabel = function (labelText, padding) {\n        if (!arguments.length) {\n            return _yAxisLabel;\n        }\n        _yAxisLabel = labelText;\n        _chart.margins().left -= _yAxisLabelPadding;\n        _yAxisLabelPadding = padding === undefined ? DEFAULT_AXIS_LABEL_PADDING : padding;\n        _chart.margins().left += _yAxisLabelPadding;\n        return _chart;\n    };\n\n    /**\r\n     * Get or set the y scale. The y scale is typically automatically determined by the chart implementation.\r\n     * @method y\r\n     * @memberof dc.coordinateGridMixin\r\n     * @instance\r\n     * @see {@link https://github.com/d3/d3-scale/blob/master/README.md d3.scale}\r\n     * @param {d3.scale} [yScale]\r\n     * @returns {d3.scale|dc.coordinateGridMixin}\r\n     */\n    _chart.y = function (yScale) {\n        if (!arguments.length) {\n            return _y;\n        }\n        _y = yScale;\n        _chart.rescale();\n        return _chart;\n    };\n\n    /**\r\n     * Set or get the y axis used by the coordinate grid chart instance. This function is most useful\r\n     * when y axis customization is required. Depending on `useRightYAxis` the y axis in dc.js is an instance of\r\n     * either [d3.axisLeft](https://github.com/d3/d3-axis/blob/master/README.md#axisLeft) or\r\n     * [d3.axisRight](https://github.com/d3/d3-axis/blob/master/README.md#axisRight); therefore it supports any\r\n     * valid d3 axis manipulation.\r\n     *\r\n     * **Caution**: The y axis is usually generated internally by dc; resetting it may cause\r\n     * unexpected results.  Note also that when used as a getter, this function is not chainable: it\r\n     * returns the axis, not the chart,\r\n     * {@link https://github.com/dc-js/dc.js/wiki/FAQ#why-does-everything-break-after-a-call-to-xaxis-or-yaxis\r\n     * so attempting to call chart functions after calling `.yAxis()` will fail}.\r\n     * In addition, depending on whether you are going to use the axis on left or right\r\n     * you need to appropriately pass [d3.axisLeft](https://github.com/d3/d3-axis/blob/master/README.md#axisLeft)\r\n     * or [d3.axisRight](https://github.com/d3/d3-axis/blob/master/README.md#axisRight)\r\n     * @method yAxis\r\n     * @memberof dc.coordinateGridMixin\r\n     * @instance\r\n     * @see {@link https://github.com/d3/d3-axis/blob/master/README.md d3.axis}\r\n     * @example\r\n     * // customize y axis tick format\r\n     * chart.yAxis().tickFormat(function(v) {return v + '%';});\r\n     * // customize y axis tick values\r\n     * chart.yAxis().tickValues([0, 100, 200, 300]);\r\n     * @param {d3.axisLeft|d3.axisRight} [yAxis]\r\n     * @returns {d3.axisLeft|d3.axisRight|dc.coordinateGridMixin}\r\n     */\n    _chart.yAxis = function (yAxis) {\n        if (!arguments.length) {\n            if (!_yAxis) {\n                _yAxis = createYAxis();\n            }\n            return _yAxis;\n        }\n        _yAxis = yAxis;\n        return _chart;\n    };\n\n    /**\r\n     * Turn on/off elastic y axis behavior. If y axis elasticity is turned on, then the grid chart will\r\n     * attempt to recalculate the y axis range whenever a redraw event is triggered.\r\n     * @method elasticY\r\n     * @memberof dc.coordinateGridMixin\r\n     * @instance\r\n     * @param {Boolean} [elasticY=false]\r\n     * @returns {Boolean|dc.coordinateGridMixin}\r\n     */\n    _chart.elasticY = function (elasticY) {\n        if (!arguments.length) {\n            return _yElasticity;\n        }\n        _yElasticity = elasticY;\n        return _chart;\n    };\n\n    /**\r\n     * Turn on/off horizontal grid lines.\r\n     * @method renderHorizontalGridLines\r\n     * @memberof dc.coordinateGridMixin\r\n     * @instance\r\n     * @param {Boolean} [renderHorizontalGridLines=false]\r\n     * @returns {Boolean|dc.coordinateGridMixin}\r\n     */\n    _chart.renderHorizontalGridLines = function (renderHorizontalGridLines) {\n        if (!arguments.length) {\n            return _renderHorizontalGridLine;\n        }\n        _renderHorizontalGridLine = renderHorizontalGridLines;\n        return _chart;\n    };\n\n    /**\r\n     * Turn on/off vertical grid lines.\r\n     * @method renderVerticalGridLines\r\n     * @memberof dc.coordinateGridMixin\r\n     * @instance\r\n     * @param {Boolean} [renderVerticalGridLines=false]\r\n     * @returns {Boolean|dc.coordinateGridMixin}\r\n     */\n    _chart.renderVerticalGridLines = function (renderVerticalGridLines) {\n        if (!arguments.length) {\n            return _renderVerticalGridLine;\n        }\n        _renderVerticalGridLine = renderVerticalGridLines;\n        return _chart;\n    };\n\n    /**\r\n     * Calculates the minimum x value to display in the chart. Includes xAxisPadding if set.\r\n     * @method xAxisMin\r\n     * @memberof dc.coordinateGridMixin\r\n     * @instance\r\n     * @returns {*}\r\n     */\n    _chart.xAxisMin = function () {\n        var min = _d.d3.min(_chart.data(), function (e) {\n            return _chart.keyAccessor()(e);\n        });\n        return dc.utils.subtract(min, _xAxisPadding, _xAxisPaddingUnit);\n    };\n\n    /**\r\n     * Calculates the maximum x value to display in the chart. Includes xAxisPadding if set.\r\n     * @method xAxisMax\r\n     * @memberof dc.coordinateGridMixin\r\n     * @instance\r\n     * @returns {*}\r\n     */\n    _chart.xAxisMax = function () {\n        var max = _d.d3.max(_chart.data(), function (e) {\n            return _chart.keyAccessor()(e);\n        });\n        return dc.utils.add(max, _xAxisPadding, _xAxisPaddingUnit);\n    };\n\n    /**\r\n     * Calculates the minimum y value to display in the chart. Includes yAxisPadding if set.\r\n     * @method yAxisMin\r\n     * @memberof dc.coordinateGridMixin\r\n     * @instance\r\n     * @returns {*}\r\n     */\n    _chart.yAxisMin = function () {\n        var min = _d.d3.min(_chart.data(), function (e) {\n            return _chart.valueAccessor()(e);\n        });\n        return dc.utils.subtract(min, _yAxisPadding);\n    };\n\n    /**\r\n     * Calculates the maximum y value to display in the chart. Includes yAxisPadding if set.\r\n     * @method yAxisMax\r\n     * @memberof dc.coordinateGridMixin\r\n     * @instance\r\n     * @returns {*}\r\n     */\n    _chart.yAxisMax = function () {\n        var max = _d.d3.max(_chart.data(), function (e) {\n            return _chart.valueAccessor()(e);\n        });\n        return dc.utils.add(max, _yAxisPadding);\n    };\n\n    /**\r\n     * Set or get y axis padding for the elastic y axis. The padding will be added to the top and\r\n     * bottom of the y axis if elasticY is turned on; otherwise it is ignored.\r\n     *\r\n     * Padding can be an integer or percentage in string (e.g. '10%'). Padding can be applied to\r\n     * number or date axes. When padding a date axis, an integer represents number of days being padded\r\n     * and a percentage string will be treated the same as an integer.\r\n     * @method yAxisPadding\r\n     * @memberof dc.coordinateGridMixin\r\n     * @instance\r\n     * @param {Number|String} [padding=0]\r\n     * @returns {Number|dc.coordinateGridMixin}\r\n     */\n    _chart.yAxisPadding = function (padding) {\n        if (!arguments.length) {\n            return _yAxisPadding;\n        }\n        _yAxisPadding = padding;\n        return _chart;\n    };\n\n    _chart.yAxisHeight = function () {\n        return _chart.effectiveHeight();\n    };\n\n    /**\r\n     * Set or get the rounding function used to quantize the selection when brushing is enabled.\r\n     * @method round\r\n     * @memberof dc.coordinateGridMixin\r\n     * @instance\r\n     * @example\r\n     * // set x unit round to by month, this will make sure range selection brush will\r\n     * // select whole months\r\n     * chart.round(d3.timeMonth.round);\r\n     * @param {Function} [round]\r\n     * @returns {Function|dc.coordinateGridMixin}\r\n     */\n    _chart.round = function (round) {\n        if (!arguments.length) {\n            return _round;\n        }\n        _round = round;\n        return _chart;\n    };\n\n    _chart._rangeBandPadding = function (_) {\n        if (!arguments.length) {\n            return _rangeBandPadding;\n        }\n        _rangeBandPadding = _;\n        return _chart;\n    };\n\n    _chart._outerRangeBandPadding = function (_) {\n        if (!arguments.length) {\n            return _outerRangeBandPadding;\n        }\n        _outerRangeBandPadding = _;\n        return _chart;\n    };\n\n    dc.override(_chart, 'filter', function (_) {\n        if (!arguments.length) {\n            return _chart._filter();\n        }\n\n        _chart._filter(_);\n\n        _chart.redrawBrush(_, false);\n\n        return _chart;\n    });\n\n    /**\r\n     * Get or set the brush. Brush must be an instance of d3 brushes\r\n     * https://github.com/d3/d3-brush/blob/master/README.md\r\n     * You will use this only if you are writing a new chart type that supports brushing.\r\n     *\r\n     * **Caution**: dc creates and manages brushes internally. Go through and understand the source code\r\n     * if you want to pass a new brush object. Even if you are only using the getter,\r\n     * the brush object may not behave the way you expect.\r\n     *\r\n     * @method brush\r\n     * @memberof dc.coordinateGridMixin\r\n     * @instance\r\n     * @param {d3.brush} [_]\r\n     * @returns {d3.brush|dc.coordinateGridMixin}\r\n     */\n    _chart.brush = function (_) {\n        if (!arguments.length) {\n            return _brush;\n        }\n        _brush = _;\n        return _chart;\n    };\n\n    _chart.renderBrush = function (g, doTransition) {\n        if (_brushOn) {\n            _brush.on('start brush end', _chart._brushing);\n\n            // To retrieve selection we need _gBrush\n            _gBrush = g.append('g').attr('class', 'brush').attr('transform', 'translate(' + _chart.margins().left + ',' + _chart.margins().top + ')');\n\n            _chart.setBrushExtents();\n\n            _chart.createBrushHandlePaths(_gBrush, doTransition);\n\n            _chart.redrawBrush(_chart.filter(), doTransition);\n        }\n    };\n\n    _chart.createBrushHandlePaths = function (gBrush) {\n        var brushHandles = gBrush.selectAll('path.' + CUSTOM_BRUSH_HANDLE_CLASS).data([{ type: 'w' }, { type: 'e' }]);\n\n        brushHandles = brushHandles.enter().append('path').attr('class', CUSTOM_BRUSH_HANDLE_CLASS).merge(brushHandles);\n\n        brushHandles.attr('d', _chart.resizeHandlePath);\n    };\n\n    _chart.extendBrush = function (brushSelection) {\n        if (brushSelection && _chart.round()) {\n            brushSelection[0] = _chart.round()(brushSelection[0]);\n            brushSelection[1] = _chart.round()(brushSelection[1]);\n        }\n        return brushSelection;\n    };\n\n    _chart.brushIsEmpty = function (brushSelection) {\n        return !brushSelection || brushSelection[1] <= brushSelection[0];\n    };\n\n    _chart._brushing = function () {\n        // Avoids infinite recursion (mutual recursion between range and focus operations)\n        // Source Event will be null when brush.move is called programmatically (see below as well).\n        if (!_d.d3.event.sourceEvent) {\n            return;\n        }\n\n        // Ignore event if recursive event - i.e. not directly generated by user action (like mouse/touch etc.)\n        // In this case we are more worried about this handler causing brush move programmatically which will\n        // cause this handler to be invoked again with a new d3.event (and current event set as sourceEvent)\n        // This check avoids recursive calls\n        if (_d.d3.event.sourceEvent.type && ['start', 'brush', 'end'].indexOf(_d.d3.event.sourceEvent.type) !== -1) {\n            return;\n        }\n\n        var brushSelection = _d.d3.event.selection;\n        if (brushSelection) {\n            brushSelection = brushSelection.map(_chart.x().invert);\n        }\n\n        brushSelection = _chart.extendBrush(brushSelection);\n\n        _chart.redrawBrush(brushSelection, false);\n\n        var rangedFilter = _chart.brushIsEmpty(brushSelection) ? null : dc.filters.RangedFilter(brushSelection[0], brushSelection[1]);\n\n        dc.events.trigger(function () {\n            _chart.applyBrushSelection(rangedFilter);\n        }, dc.constants.EVENT_DELAY);\n    };\n\n    // This can be overridden in a derived chart. For example Composite chart overrides it\n    _chart.applyBrushSelection = function (rangedFilter) {\n        _chart.replaceFilter(rangedFilter);\n        _chart.redrawGroup();\n    };\n\n    _chart.setBrushExtents = function (doTransition) {\n        // Set boundaries of the brush, must set it before applying to _gBrush\n        _brush.extent([[0, 0], [_chart.effectiveWidth(), _chart.effectiveHeight()]]);\n\n        _gBrush.call(_brush);\n    };\n\n    _chart.redrawBrush = function (brushSelection, doTransition) {\n        if (_brushOn && _gBrush) {\n            if (_resizing) {\n                _chart.setBrushExtents(doTransition);\n            }\n\n            if (!brushSelection) {\n                _gBrush.call(_brush.move, null);\n\n                _gBrush.selectAll('path.' + CUSTOM_BRUSH_HANDLE_CLASS).attr('display', 'none');\n            } else {\n                var scaledSelection = [_x(brushSelection[0]), _x(brushSelection[1])];\n\n                var gBrush = dc.optionalTransition(doTransition, _chart.transitionDuration(), _chart.transitionDelay())(_gBrush);\n\n                gBrush.call(_brush.move, scaledSelection);\n\n                gBrush.selectAll('path.' + CUSTOM_BRUSH_HANDLE_CLASS).attr('display', null).attr('transform', function (d, i) {\n                    return 'translate(' + _x(brushSelection[i]) + ', 0)';\n                }).attr('d', _chart.resizeHandlePath);\n            }\n        }\n        _chart.fadeDeselectedArea(brushSelection);\n    };\n\n    _chart.fadeDeselectedArea = function (brushSelection) {\n        // do nothing, sub-chart should override this function\n    };\n\n    // borrowed from Crossfilter example\n    _chart.resizeHandlePath = function (d) {\n        d = d.type;\n        var e = +(d === 'e'),\n            x = e ? 1 : -1,\n            y = _chart.effectiveHeight() / 3;\n        return 'M' + 0.5 * x + ',' + y + 'A6,6 0 0 ' + e + ' ' + 6.5 * x + ',' + (y + 6) + 'V' + (2 * y - 6) + 'A6,6 0 0 ' + e + ' ' + 0.5 * x + ',' + 2 * y + 'Z' + 'M' + 2.5 * x + ',' + (y + 8) + 'V' + (2 * y - 8) + 'M' + 4.5 * x + ',' + (y + 8) + 'V' + (2 * y - 8);\n    };\n\n    function getClipPathId() {\n        return _chart.anchorName().replace(/[ .#=\\[\\]\"]/g, '-') + '-clip';\n    }\n\n    /**\r\n     * Get or set the padding in pixels for the clip path. Once set padding will be applied evenly to\r\n     * the top, left, right, and bottom when the clip path is generated. If set to zero, the clip area\r\n     * will be exactly the chart body area minus the margins.\r\n     * @method clipPadding\r\n     * @memberof dc.coordinateGridMixin\r\n     * @instance\r\n     * @param {Number} [padding=5]\r\n     * @returns {Number|dc.coordinateGridMixin}\r\n     */\n    _chart.clipPadding = function (padding) {\n        if (!arguments.length) {\n            return _clipPadding;\n        }\n        _clipPadding = padding;\n        return _chart;\n    };\n\n    function generateClipPath() {\n        var defs = dc.utils.appendOrSelect(_parent, 'defs');\n        // cannot select <clippath> elements; bug in WebKit, must select by id\n        // https://groups.google.com/forum/#!topic/d3-js/6EpAzQ2gU9I\n        var id = getClipPathId();\n        var chartBodyClip = dc.utils.appendOrSelect(defs, '#' + id, 'clipPath').attr('id', id);\n\n        var padding = _clipPadding * 2;\n\n        dc.utils.appendOrSelect(chartBodyClip, 'rect').attr('width', _chart.xAxisLength() + padding).attr('height', _chart.yAxisHeight() + padding).attr('transform', 'translate(-' + _clipPadding + ', -' + _clipPadding + ')');\n    }\n\n    _chart._preprocessData = function () {};\n\n    _chart._doRender = function () {\n        _chart.resetSvg();\n\n        _chart._preprocessData();\n\n        _chart._generateG();\n        generateClipPath();\n\n        drawChart(true);\n\n        configureMouseZoom();\n\n        return _chart;\n    };\n\n    _chart._doRedraw = function () {\n        _chart._preprocessData();\n\n        drawChart(false);\n        generateClipPath();\n\n        return _chart;\n    };\n\n    function drawChart(render) {\n        if (_chart.isOrdinal()) {\n            _brushOn = false;\n        }\n\n        prepareXAxis(_chart.g(), render);\n        _chart._prepareYAxis(_chart.g());\n\n        _chart.plotData();\n\n        if (_chart.elasticX() || _resizing || render) {\n            _chart.renderXAxis(_chart.g());\n        }\n\n        if (_chart.elasticY() || _resizing || render) {\n            _chart.renderYAxis(_chart.g());\n        }\n\n        if (render) {\n            _chart.renderBrush(_chart.g(), false);\n        } else {\n            // Animate the brush only while resizing\n            _chart.redrawBrush(_chart.filter(), _resizing);\n        }\n        _chart.fadeDeselectedArea(_chart.filter());\n        _resizing = false;\n    }\n\n    function configureMouseZoom() {\n        // Save a copy of original x scale\n        _origX = _x.copy();\n\n        if (_mouseZoomable) {\n            _chart._enableMouseZoom();\n        } else if (_hasBeenMouseZoomable) {\n            _chart._disableMouseZoom();\n        }\n    }\n\n    _chart._enableMouseZoom = function () {\n        _hasBeenMouseZoomable = true;\n\n        var extent = [[0, 0], [_chart.effectiveWidth(), _chart.effectiveHeight()]];\n\n        _zoom.scaleExtent(_zoomScale).extent(extent).duration(_chart.transitionDuration());\n\n        if (_zoomOutRestrict) {\n            // Ensure minimum zoomScale is at least 1\n            var zoomScaleMin = Math.max(_zoomScale[0], 1);\n            _zoom.translateExtent(extent).scaleExtent([zoomScaleMin, _zoomScale[1]]);\n        }\n\n        _chart.root().call(_zoom);\n\n        // Tell D3 zoom our current zoom/pan status\n        updateD3zoomTransform();\n    };\n\n    _chart._disableMouseZoom = function () {\n        _chart.root().call(_nullZoom);\n    };\n\n    function zoomHandler(newDomain, noRaiseEvents) {\n        var domFilter;\n\n        if (hasRangeSelected(newDomain)) {\n            _chart.x().domain(newDomain);\n            domFilter = dc.filters.RangedFilter(newDomain[0], newDomain[1]);\n        } else {\n            _chart.x().domain(_xOriginalDomain);\n            domFilter = null;\n        }\n\n        _chart.replaceFilter(domFilter);\n        _chart.rescale();\n        _chart.redraw();\n\n        if (!noRaiseEvents) {\n            if (_rangeChart && !dc.utils.arraysEqual(_chart.filter(), _rangeChart.filter())) {\n                dc.events.trigger(function () {\n                    _rangeChart.replaceFilter(domFilter);\n                    _rangeChart.redraw();\n                });\n            }\n\n            _chart._invokeZoomedListener();\n            dc.events.trigger(function () {\n                _chart.redrawGroup();\n            }, dc.constants.EVENT_DELAY);\n        }\n    }\n\n    // event.transform.rescaleX(_origX).domain() should give back newDomain\n    function domainToZoomTransform(newDomain, origDomain, xScale) {\n        var k = (origDomain[1] - origDomain[0]) / (newDomain[1] - newDomain[0]);\n        var xt = -1 * xScale(newDomain[0]);\n\n        return _d.d3.zoomIdentity.scale(k).translate(xt, 0);\n    }\n\n    // If we changing zoom status (for example by calling focus), tell D3 zoom about it\n    function updateD3zoomTransform() {\n        if (_zoom) {\n            _zoom.transform(_chart.root(), domainToZoomTransform(_chart.x().domain(), _xOriginalDomain, _origX));\n        }\n    }\n\n    function onZoom() {\n        // Avoids infinite recursion (mutual recursion between range and focus operations)\n        // Source Event will be null when zoom is called programmatically (see below as well).\n        if (!_d.d3.event.sourceEvent) {\n            return;\n        }\n\n        // Ignore event if recursive event - i.e. not directly generated by user action (like mouse/touch etc.)\n        // In this case we are more worried about this handler causing zoom programmatically which will\n        // cause this handler to be invoked again with a new d3.event (and current event set as sourceEvent)\n        // This check avoids recursive calls\n        if (_d.d3.event.sourceEvent.type && ['start', 'zoom', 'end'].indexOf(_d.d3.event.sourceEvent.type) !== -1) {\n            return;\n        }\n\n        var newDomain = _d.d3.event.transform.rescaleX(_origX).domain();\n        _chart.focus(newDomain, false);\n    }\n\n    function checkExtents(ext, outerLimits) {\n        if (!ext || ext.length !== 2 || !outerLimits || outerLimits.length !== 2) {\n            return ext;\n        }\n\n        if (ext[0] > outerLimits[1] || ext[1] < outerLimits[0]) {\n            console.warn('Could not intersect extents, will reset');\n        }\n        // Math.max does not work (as the values may be dates as well)\n        return [ext[0] > outerLimits[0] ? ext[0] : outerLimits[0], ext[1] < outerLimits[1] ? ext[1] : outerLimits[1]];\n    }\n\n    /**\r\n     * Zoom this chart to focus on the given range. The given range should be an array containing only\r\n     * 2 elements (`[start, end]`) defining a range in the x domain. If the range is not given or set\r\n     * to null, then the zoom will be reset. _For focus to work elasticX has to be turned off;\r\n     * otherwise focus will be ignored.\r\n     *\r\n     * To avoid ping-pong volley of events between a pair of range and focus charts please set\r\n     * `noRaiseEvents` to `true`. In that case it will update this chart but will not fire `zoom` event\r\n     * and not try to update back the associated range chart.\r\n     * If you are calling it manually - typically you will leave it to `false` (the default).\r\n     *\r\n     * @method focus\r\n     * @memberof dc.coordinateGridMixin\r\n     * @instance\r\n     * @example\r\n     * chart.on('renderlet', function(chart) {\r\n     *     // smooth the rendering through event throttling\r\n     *     dc.events.trigger(function(){\r\n     *          // focus some other chart to the range selected by user on this chart\r\n     *          someOtherChart.focus(chart.filter());\r\n     *     });\r\n     * })\r\n     * @param {Array<Number>} [range]\r\n     * @param {Boolean} [noRaiseEvents = false]\r\n     */\n    _chart.focus = function (range, noRaiseEvents) {\n        if (_zoomOutRestrict) {\n            // ensure range is within _xOriginalDomain\n            range = checkExtents(range, _xOriginalDomain);\n\n            // If it has an associated range chart ensure range is within domain of that rangeChart\n            if (_rangeChart) {\n                range = checkExtents(range, _rangeChart.x().domain());\n            }\n        }\n\n        zoomHandler(range, noRaiseEvents);\n        updateD3zoomTransform();\n    };\n\n    _chart.refocused = function () {\n        return !dc.utils.arraysEqual(_chart.x().domain(), _xOriginalDomain);\n    };\n\n    _chart.focusChart = function (c) {\n        if (!arguments.length) {\n            return _focusChart;\n        }\n        _focusChart = c;\n        _chart.on('filtered.dcjs-range-chart', function (chart) {\n            if (!chart.filter()) {\n                dc.events.trigger(function () {\n                    _focusChart.x().domain(_focusChart.xOriginalDomain(), true);\n                });\n            } else if (!dc.utils.arraysEqual(chart.filter(), _focusChart.filter())) {\n                dc.events.trigger(function () {\n                    _focusChart.focus(chart.filter(), true);\n                });\n            }\n        });\n        return _chart;\n    };\n\n    /**\r\n     * Turn on/off the brush-based range filter. When brushing is on then user can drag the mouse\r\n     * across a chart with a quantitative scale to perform range filtering based on the extent of the\r\n     * brush, or click on the bars of an ordinal bar chart or slices of a pie chart to filter and\r\n     * un-filter them. However turning on the brush filter will disable other interactive elements on\r\n     * the chart such as highlighting, tool tips, and reference lines. Zooming will still be possible\r\n     * if enabled, but only via scrolling (panning will be disabled.)\r\n     * @method brushOn\r\n     * @memberof dc.coordinateGridMixin\r\n     * @instance\r\n     * @param {Boolean} [brushOn=true]\r\n     * @returns {Boolean|dc.coordinateGridMixin}\r\n     */\n    _chart.brushOn = function (brushOn) {\n        if (!arguments.length) {\n            return _brushOn;\n        }\n        _brushOn = brushOn;\n        return _chart;\n    };\n\n    /**\r\n     * This will be internally used by composite chart onto children. Please go not invoke directly.\r\n     *\r\n     * @method parentBrushOn\r\n     * @memberof dc.coordinateGridMixin\r\n     * @protected\r\n     * @instance\r\n     * @param {Boolean} [brushOn=false]\r\n     * @returns {Boolean|dc.coordinateGridMixin}\r\n     */\n    _chart.parentBrushOn = function (brushOn) {\n        if (!arguments.length) {\n            return _parentBrushOn;\n        }\n        _parentBrushOn = brushOn;\n        return _chart;\n    };\n\n    // Get the SVG rendered brush\n    _chart.gBrush = function () {\n        return _gBrush;\n    };\n\n    function hasRangeSelected(range) {\n        return range instanceof Array && range.length > 1;\n    }\n\n    return _chart;\n};\n\n/**\r\n * Stack Mixin is an mixin that provides cross-chart support of stackability using d3.stackD3v3.\r\n * @name stackMixin\r\n * @memberof dc\r\n * @mixin\r\n * @param {Object} _chart\r\n * @returns {dc.stackMixin}\r\n */\ndc.stackMixin = function (_chart) {\n\n    function prepareValues(layer, layerIdx) {\n        var valAccessor = layer.accessor || _chart.valueAccessor();\n        layer.name = String(layer.name || layerIdx);\n        var allValues = layer.group.all().map(function (d, i) {\n            return {\n                x: _chart.keyAccessor()(d, i),\n                y: layer.hidden ? null : valAccessor(d, i),\n                data: d,\n                layer: layer.name,\n                hidden: layer.hidden\n            };\n        });\n\n        layer.domainValues = allValues.filter(domainFilter());\n        layer.values = _chart.evadeDomainFilter() ? allValues : layer.domainValues;\n    }\n\n    var _stackLayout = _d.d3.stack();\n\n    var _stack = [];\n    var _titles = {};\n\n    var _hidableStacks = false;\n    var _evadeDomainFilter = false;\n\n    function domainFilter() {\n        if (!_chart.x()) {\n            return dc.utils.constant(true);\n        }\n        var xDomain = _chart.x().domain();\n        if (_chart.isOrdinal()) {\n            // TODO #416\n            //var domainSet = d3.set(xDomain);\n            return function () {\n                return true; //domainSet.has(p.x);\n            };\n        }\n        if (_chart.elasticX()) {\n            return function () {\n                return true;\n            };\n        }\n        return function (p) {\n            //return true;\n            return p.x >= xDomain[0] && p.x <= xDomain[xDomain.length - 1];\n        };\n    }\n\n    /**\r\n     * Stack a new crossfilter group onto this chart with an optional custom value accessor. All stacks\r\n     * in the same chart will share the same key accessor and therefore the same set of keys.\r\n     *\r\n     * For example, in a stacked bar chart, the bars of each stack will be positioned using the same set\r\n     * of keys on the x axis, while stacked vertically. If name is specified then it will be used to\r\n     * generate the legend label.\r\n     * @method stack\r\n     * @memberof dc.stackMixin\r\n     * @instance\r\n     * @see {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#group-map-reduce crossfilter.group}\r\n     * @example\r\n     * // stack group using default accessor\r\n     * chart.stack(valueSumGroup)\r\n     * // stack group using custom accessor\r\n     * .stack(avgByDayGroup, function(d){return d.value.avgByDay;});\r\n     * @param {crossfilter.group} group\r\n     * @param {String} [name]\r\n     * @param {Function} [accessor]\r\n     * @returns {Array<{group: crossfilter.group, name: String, accessor: Function}>|dc.stackMixin}\r\n     */\n    _chart.stack = function (group, name, accessor) {\n        if (!arguments.length) {\n            return _stack;\n        }\n\n        if (arguments.length <= 2) {\n            accessor = name;\n        }\n\n        var layer = { group: group };\n        if (typeof name === 'string') {\n            layer.name = name;\n        }\n        if (typeof accessor === 'function') {\n            layer.accessor = accessor;\n        }\n        _stack.push(layer);\n\n        return _chart;\n    };\n\n    dc.override(_chart, 'group', function (g, n, f) {\n        if (!arguments.length) {\n            return _chart._group();\n        }\n        _stack = [];\n        _titles = {};\n        _chart.stack(g, n);\n        if (f) {\n            _chart.valueAccessor(f);\n        }\n        return _chart._group(g, n);\n    });\n\n    /**\r\n     * Allow named stacks to be hidden or shown by clicking on legend items.\r\n     * This does not affect the behavior of hideStack or showStack.\r\n     * @method hidableStacks\r\n     * @memberof dc.stackMixin\r\n     * @instance\r\n     * @param {Boolean} [hidableStacks=false]\r\n     * @returns {Boolean|dc.stackMixin}\r\n     */\n    _chart.hidableStacks = function (hidableStacks) {\n        if (!arguments.length) {\n            return _hidableStacks;\n        }\n        _hidableStacks = hidableStacks;\n        return _chart;\n    };\n\n    function findLayerByName(n) {\n        var i = _stack.map(dc.pluck('name')).indexOf(n);\n        return _stack[i];\n    }\n\n    /**\r\n     * Hide all stacks on the chart with the given name.\r\n     * The chart must be re-rendered for this change to appear.\r\n     * @method hideStack\r\n     * @memberof dc.stackMixin\r\n     * @instance\r\n     * @param {String} stackName\r\n     * @returns {dc.stackMixin}\r\n     */\n    _chart.hideStack = function (stackName) {\n        var layer = findLayerByName(stackName);\n        if (layer) {\n            layer.hidden = true;\n        }\n        return _chart;\n    };\n\n    /**\r\n     * Show all stacks on the chart with the given name.\r\n     * The chart must be re-rendered for this change to appear.\r\n     * @method showStack\r\n     * @memberof dc.stackMixin\r\n     * @instance\r\n     * @param {String} stackName\r\n     * @returns {dc.stackMixin}\r\n     */\n    _chart.showStack = function (stackName) {\n        var layer = findLayerByName(stackName);\n        if (layer) {\n            layer.hidden = false;\n        }\n        return _chart;\n    };\n\n    _chart.getValueAccessorByIndex = function (index) {\n        return _stack[index].accessor || _chart.valueAccessor();\n    };\n\n    _chart.yAxisMin = function () {\n        var min = _d.d3.min(flattenStack(), function (p) {\n            return p.y < 0 ? p.y + p.y0 : p.y0;\n        });\n\n        return dc.utils.subtract(min, _chart.yAxisPadding());\n    };\n\n    _chart.yAxisMax = function () {\n        var max = _d.d3.max(flattenStack(), function (p) {\n            return p.y > 0 ? p.y + p.y0 : p.y0;\n        });\n\n        return dc.utils.add(max, _chart.yAxisPadding());\n    };\n\n    function flattenStack() {\n        var valueses = _chart.data().map(function (layer) {\n            return layer.domainValues;\n        });\n        return Array.prototype.concat.apply([], valueses);\n    }\n\n    _chart.xAxisMin = function () {\n        var min = _d.d3.min(flattenStack(), dc.pluck('x'));\n        return dc.utils.subtract(min, _chart.xAxisPadding(), _chart.xAxisPaddingUnit());\n    };\n\n    _chart.xAxisMax = function () {\n        var max = _d.d3.max(flattenStack(), dc.pluck('x'));\n        return dc.utils.add(max, _chart.xAxisPadding(), _chart.xAxisPaddingUnit());\n    };\n\n    /**\r\n     * Set or get the title function. Chart class will use this function to render svg title (usually interpreted by\r\n     * browser as tooltips) for each child element in the chart, i.e. a slice in a pie chart or a bubble in a bubble chart.\r\n     * Almost every chart supports title function however in grid coordinate chart you need to turn off brush in order to\r\n     * use title otherwise the brush layer will block tooltip trigger.\r\n     *\r\n     * If the first argument is a stack name, the title function will get or set the title for that stack. If stackName\r\n     * is not provided, the first stack is implied.\r\n     * @method title\r\n     * @memberof dc.stackMixin\r\n     * @instance\r\n     * @example\r\n     * // set a title function on 'first stack'\r\n     * chart.title('first stack', function(d) { return d.key + ': ' + d.value; });\r\n     * // get a title function from 'second stack'\r\n     * var secondTitleFunction = chart.title('second stack');\r\n     * @param {String} [stackName]\r\n     * @param {Function} [titleAccessor]\r\n     * @returns {String|dc.stackMixin}\r\n     */\n    dc.override(_chart, 'title', function (stackName, titleAccessor) {\n        if (!stackName) {\n            return _chart._title();\n        }\n\n        if (typeof stackName === 'function') {\n            return _chart._title(stackName);\n        }\n        if (stackName === _chart._groupName && typeof titleAccessor === 'function') {\n            return _chart._title(titleAccessor);\n        }\n\n        if (typeof titleAccessor !== 'function') {\n            return _titles[stackName] || _chart._title();\n        }\n\n        _titles[stackName] = titleAccessor;\n\n        return _chart;\n    });\n\n    /**\r\n     * Gets or sets the stack layout algorithm, which computes a baseline for each stack and\r\n     * propagates it to the next.\r\n     * @method stackLayout\r\n     * @memberof dc.stackMixin\r\n     * @instance\r\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Stack-Layout.md d3.stackD3v3}\r\n     * @param {Function} [stack=d3.stackD3v3]\r\n     * @returns {Function|dc.stackMixin}\r\n     */\n    _chart.stackLayout = function (stack) {\n        if (!arguments.length) {\n            return _stackLayout;\n        }\n        _stackLayout = stack;\n        return _chart;\n    };\n\n    /**\r\n     * Since dc.js 2.0, there has been {@link https://github.com/dc-js/dc.js/issues/949 an issue}\r\n     * where points are filtered to the current domain. While this is a useful optimization, it is\r\n     * incorrectly implemented: the next point outside the domain is required in order to draw lines\r\n     * that are clipped to the bounds, as well as bars that are partly clipped.\r\n     *\r\n     * A fix will be included in dc.js 2.1.x, but a workaround is needed for dc.js 2.0 and until\r\n     * that fix is published, so set this flag to skip any filtering of points.\r\n     *\r\n     * Once the bug is fixed, this flag will have no effect, and it will be deprecated.\r\n     * @method evadeDomainFilter\r\n     * @memberof dc.stackMixin\r\n     * @instance\r\n     * @param {Boolean} [evadeDomainFilter=false]\r\n     * @returns {Boolean|dc.stackMixin}\r\n     */\n    _chart.evadeDomainFilter = function (evadeDomainFilter) {\n        if (!arguments.length) {\n            return _evadeDomainFilter;\n        }\n        _evadeDomainFilter = evadeDomainFilter;\n        return _chart;\n    };\n\n    function visibility(l) {\n        return !l.hidden;\n    }\n\n    _chart.data(function () {\n        var layers = _stack.filter(visibility);\n        if (!layers.length) {\n            return [];\n        }\n        layers.forEach(prepareValues);\n        var v4data = layers[0].values.map(function (v, i) {\n            var col = { x: v.x };\n            layers.forEach(function (layer) {\n                col[layer.name] = layer.values[i].y;\n            });\n            return col;\n        });\n        var keys = layers.map(function (layer) {\n            return layer.name;\n        });\n        var v4result = _chart.stackLayout().keys(keys)(v4data);\n        v4result.forEach(function (series, i) {\n            series.forEach(function (ys, j) {\n                layers[i].values[j].y0 = ys[0];\n                layers[i].values[j].y1 = ys[1];\n            });\n        });\n        return layers;\n    });\n\n    _chart._ordinalXDomain = function () {\n        var flat = flattenStack().map(dc.pluck('data'));\n        var ordered = _chart._computeOrderedGroups(flat);\n        return ordered.map(_chart.keyAccessor());\n    };\n\n    _chart.colorAccessor(function (d) {\n        var layer = this.layer || this.name || d.name || d.layer;\n        return layer;\n    });\n\n    _chart.legendables = function () {\n        return _stack.map(function (layer, i) {\n            return {\n                chart: _chart,\n                name: layer.name,\n                hidden: layer.hidden || false,\n                color: _chart.getColor.call(layer, layer.values, i)\n            };\n        });\n    };\n\n    _chart.isLegendableHidden = function (d) {\n        var layer = findLayerByName(d.name);\n        return layer ? layer.hidden : false;\n    };\n\n    _chart.legendToggle = function (d) {\n        if (_hidableStacks) {\n            if (_chart.isLegendableHidden(d)) {\n                _chart.showStack(d.name);\n            } else {\n                _chart.hideStack(d.name);\n            }\n            //_chart.redraw();\n            _chart.renderGroup();\n        }\n    };\n\n    return _chart;\n};\n\n/**\r\n * Cap is a mixin that groups small data elements below a _cap_ into an *others* grouping for both the\r\n * Row and Pie Charts.\r\n *\r\n * The top ordered elements in the group up to the cap amount will be kept in the chart, and the rest\r\n * will be replaced with an *others* element, with value equal to the sum of the replaced values. The\r\n * keys of the elements below the cap limit are recorded in order to filter by those keys when the\r\n * others* element is clicked.\r\n * @name capMixin\r\n * @memberof dc\r\n * @mixin\r\n * @param {Object} _chart\r\n * @returns {dc.capMixin}\r\n */\ndc.capMixin = function (_chart) {\n    var _cap = Infinity,\n        _takeFront = true;\n    var _othersLabel = 'Others';\n\n    // emulate old group.top(N) ordering\n    _chart.ordering(function (kv) {\n        return -kv.value;\n    });\n\n    var _othersGrouper = function _othersGrouper(topItems, restItems) {\n        var restItemsSum = _d.d3.sum(restItems, _chart.valueAccessor()),\n            restKeys = restItems.map(_chart.keyAccessor());\n        if (restItemsSum > 0) {\n            return topItems.concat([{\n                others: restKeys,\n                key: _chart.othersLabel(),\n                value: restItemsSum\n            }]);\n        }\n        return topItems;\n    };\n\n    _chart.cappedKeyAccessor = function (d, i) {\n        if (d.others) {\n            return d.key;\n        }\n        return _chart.keyAccessor()(d, i);\n    };\n\n    _chart.cappedValueAccessor = function (d, i) {\n        if (d.others) {\n            return d.value;\n        }\n        return _chart.valueAccessor()(d, i);\n    };\n\n    // return N \"top\" groups, where N is the cap, sorted by baseMixin.ordering\n    // whether top means front or back depends on takeFront\n    _chart.data(function (group) {\n        if (_cap === Infinity) {\n            return _chart._computeOrderedGroups(group.all());\n        } else {\n            var items = group.all(),\n                rest;\n            items = _chart._computeOrderedGroups(items); // sort by baseMixin.ordering\n\n            if (_cap) {\n                if (_takeFront) {\n                    rest = items.slice(_cap);\n                    items = items.slice(0, _cap);\n                } else {\n                    var start = Math.max(0, items.length - _cap);\n                    rest = items.slice(0, start);\n                    items = items.slice(start);\n                }\n            }\n\n            if (_othersGrouper) {\n                return _othersGrouper(items, rest);\n            }\n            return items;\n        }\n    });\n\n    /**\r\n     * Get or set the count of elements to that will be included in the cap. If there is an\r\n     * {@link dc.capMixin#othersGrouper othersGrouper}, any further elements will be combined in an\r\n     * extra element with its name determined by {@link dc.capMixin#othersLabel othersLabel}.\r\n     *\r\n     * As of dc.js 2.1 and onward, the capped charts use\r\n     * {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#group_all group.all()}\r\n     * and {@link dc.baseMixin#ordering baseMixin.ordering()} to determine the order of\r\n     * elements. Then `cap` and {@link dc.capMixin#takeFront takeFront} determine how many elements\r\n     * to keep, from which end of the resulting array.\r\n     *\r\n     * **Migration note:** Up through dc.js 2.0.*, capping used\r\n     * {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#group_top group.top(N)},\r\n     * which selects the largest items according to\r\n     * {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#group_order group.order()}.\r\n     * The chart then sorted the items according to {@link dc.baseMixin#ordering baseMixin.ordering()}.\r\n     * So the two values essentially had to agree, but if the `group.order()` was incorrect (it's\r\n     * easy to forget about), the wrong rows or slices would be displayed, in the correct order.\r\n     *\r\n     * If your chart previously relied on `group.order()`, use `chart.ordering()` instead. As of\r\n     * 2.1.5, the ordering defaults to sorting from greatest to least like `group.top(N)` did.\r\n     *\r\n     * If you want to cap by one ordering but sort by another, please\r\n     * [file an issue](https://github.com/dc-js/dc.js/issues/new) - it's still possible but we'll\r\n     * need to work up an example.\r\n     * @method cap\r\n     * @memberof dc.capMixin\r\n     * @instance\r\n     * @param {Number} [count=Infinity]\r\n     * @returns {Number|dc.capMixin}\r\n     */\n    _chart.cap = function (count) {\n        if (!arguments.length) {\n            return _cap;\n        }\n        _cap = count;\n        return _chart;\n    };\n\n    /**\r\n     * Get or set the direction of capping. If set, the chart takes the first\r\n     * {@link dc.capMixin#cap cap} elements from the sorted array of elements; otherwise\r\n     * it takes the last `cap` elements.\r\n     * @method takeFront\r\n     * @memberof dc.capMixin\r\n     * @instance\r\n     * @param {Boolean} [takeFront=true]\r\n     * @returns {Boolean|dc.capMixin}\r\n     */\n    _chart.takeFront = function (takeFront) {\n        if (!arguments.length) {\n            return _takeFront;\n        }\n        _takeFront = takeFront;\n        return _chart;\n    };\n\n    /**\r\n     * Get or set the label for *Others* slice when slices cap is specified.\r\n     * @method othersLabel\r\n     * @memberof dc.capMixin\r\n     * @instance\r\n     * @param {String} [label=\"Others\"]\r\n     * @returns {String|dc.capMixin}\r\n     */\n    _chart.othersLabel = function (label) {\n        if (!arguments.length) {\n            return _othersLabel;\n        }\n        _othersLabel = label;\n        return _chart;\n    };\n\n    /**\r\n     * Get or set the grouper function that will perform the insertion of data for the *Others* slice\r\n     * if the slices cap is specified. If set to a falsy value, no others will be added.\r\n     *\r\n     * The grouper function takes an array of included (\"top\") items, and an array of the rest of\r\n     * the items. By default the grouper function computes the sum of the rest.\r\n     * @method othersGrouper\r\n     * @memberof dc.capMixin\r\n     * @instance\r\n     * @example\r\n     * // Do not show others\r\n     * chart.othersGrouper(null);\r\n     * // Default others grouper\r\n     * chart.othersGrouper(function (topItems, restItems) {\r\n     *     var restItemsSum = d3.sum(restItems, _chart.valueAccessor()),\r\n     *         restKeys = restItems.map(_chart.keyAccessor());\r\n     *     if (restItemsSum > 0) {\r\n     *         return topItems.concat([{\r\n     *             others: restKeys,\r\n     *             key: _chart.othersLabel(),\r\n     *             value: restItemsSum\r\n     *         }]);\r\n     *     }\r\n     *     return topItems;\r\n     * });\r\n     * @param {Function} [grouperFunction]\r\n     * @returns {Function|dc.capMixin}\r\n     */\n    _chart.othersGrouper = function (grouperFunction) {\n        if (!arguments.length) {\n            return _othersGrouper;\n        }\n        _othersGrouper = grouperFunction;\n        return _chart;\n    };\n\n    dc.override(_chart, 'onClick', function (d) {\n        if (d.others) {\n            _chart.filter([d.others]);\n        }\n        _chart._onClick(d);\n    });\n\n    return _chart;\n};\n\n/**\r\n * This Mixin provides reusable functionalities for any chart that needs to visualize data using bubbles.\r\n * @name bubbleMixin\r\n * @memberof dc\r\n * @mixin\r\n * @mixes dc.colorMixin\r\n * @param {Object} _chart\r\n * @returns {dc.bubbleMixin}\r\n */\ndc.bubbleMixin = function (_chart) {\n    var _maxBubbleRelativeSize = 0.3;\n    var _minRadiusWithLabel = 10;\n    var _sortBubbleSize = false;\n    var _elasticRadius = false;\n\n    _chart.BUBBLE_NODE_CLASS = 'node';\n    _chart.BUBBLE_CLASS = 'bubble';\n    _chart.MIN_RADIUS = 10;\n\n    _chart = dc.colorMixin(_chart);\n\n    _chart.renderLabel(true);\n\n    _chart.data(function (group) {\n        var data = group.all();\n        if (_sortBubbleSize) {\n            // sort descending so smaller bubbles are on top\n            var radiusAccessor = _chart.radiusValueAccessor();\n            data.sort(function (a, b) {\n                return _d.d3.descending(radiusAccessor(a), radiusAccessor(b));\n            });\n        }\n        return data;\n    });\n\n    var _r = _d.d3.scaleLinear().domain([0, 100]);\n\n    var _rValueAccessor = function _rValueAccessor(d) {\n        return d.r;\n    };\n\n    /**\r\n     * Get or set the bubble radius scale. By default the bubble chart uses\r\n     * {@link https://github.com/d3/d3-scale/blob/master/README.md#scaleLinear d3.scaleLinear().domain([0, 100])}\r\n     * as its radius scale.\r\n     * @method r\r\n     * @memberof dc.bubbleMixin\r\n     * @instance\r\n     * @see {@link https://github.com/d3/d3-scale/blob/master/README.md d3.scale}\r\n     * @param {d3.scale} [bubbleRadiusScale=d3.scaleLinear().domain([0, 100])]\r\n     * @returns {d3.scale|dc.bubbleMixin}\r\n     */\n    _chart.r = function (bubbleRadiusScale) {\n        if (!arguments.length) {\n            return _r;\n        }\n        _r = bubbleRadiusScale;\n        return _chart;\n    };\n\n    /**\r\n     * Turn on or off the elastic bubble radius feature, or return the value of the flag. If this\r\n     * feature is turned on, then bubble radii will be automatically rescaled to fit the chart better.\r\n     * @method elasticRadius\r\n     * @memberof dc.bubbleChart\r\n     * @instance\r\n     * @param {Boolean} [elasticRadius=false]\r\n     * @returns {Boolean|dc.bubbleChart}\r\n     */\n    _chart.elasticRadius = function (elasticRadius) {\n        if (!arguments.length) {\n            return _elasticRadius;\n        }\n        _elasticRadius = elasticRadius;\n        return _chart;\n    };\n\n    _chart.calculateRadiusDomain = function () {\n        if (_elasticRadius) {\n            _chart.r().domain([_chart.rMin(), _chart.rMax()]);\n        }\n    };\n\n    /**\r\n     * Get or set the radius value accessor function. If set, the radius value accessor function will\r\n     * be used to retrieve a data value for each bubble. The data retrieved then will be mapped using\r\n     * the r scale to the actual bubble radius. This allows you to encode a data dimension using bubble\r\n     * size.\r\n     * @method radiusValueAccessor\r\n     * @memberof dc.bubbleMixin\r\n     * @instance\r\n     * @param {Function} [radiusValueAccessor]\r\n     * @returns {Function|dc.bubbleMixin}\r\n     */\n    _chart.radiusValueAccessor = function (radiusValueAccessor) {\n        if (!arguments.length) {\n            return _rValueAccessor;\n        }\n        _rValueAccessor = radiusValueAccessor;\n        return _chart;\n    };\n\n    _chart.rMin = function () {\n        var min = _d.d3.min(_chart.data(), function (e) {\n            return _chart.radiusValueAccessor()(e);\n        });\n        return min;\n    };\n\n    _chart.rMax = function () {\n        var max = _d.d3.max(_chart.data(), function (e) {\n            return _chart.radiusValueAccessor()(e);\n        });\n        return max;\n    };\n\n    _chart.bubbleR = function (d) {\n        var value = _chart.radiusValueAccessor()(d);\n        var r = _chart.r()(value);\n        if (isNaN(r) || value <= 0) {\n            r = 0;\n        }\n        return r;\n    };\n\n    var labelFunction = function labelFunction(d) {\n        return _chart.label()(d);\n    };\n\n    var shouldLabel = function shouldLabel(d) {\n        return _chart.bubbleR(d) > _minRadiusWithLabel;\n    };\n\n    var labelOpacity = function labelOpacity(d) {\n        return shouldLabel(d) ? 1 : 0;\n    };\n\n    var labelPointerEvent = function labelPointerEvent(d) {\n        return shouldLabel(d) ? 'all' : 'none';\n    };\n\n    _chart._doRenderLabel = function (bubbleGEnter) {\n        if (_chart.renderLabel()) {\n            var label = bubbleGEnter.select('text');\n\n            if (label.empty()) {\n                label = bubbleGEnter.append('text').attr('text-anchor', 'middle').attr('dy', '.3em').on('click', _chart.onClick);\n            }\n\n            label.attr('opacity', 0).attr('pointer-events', labelPointerEvent).text(labelFunction);\n            dc.transition(label, _chart.transitionDuration(), _chart.transitionDelay()).attr('opacity', labelOpacity);\n        }\n    };\n\n    _chart.doUpdateLabels = function (bubbleGEnter) {\n        if (_chart.renderLabel()) {\n            var labels = bubbleGEnter.select('text').attr('pointer-events', labelPointerEvent).text(labelFunction);\n            dc.transition(labels, _chart.transitionDuration(), _chart.transitionDelay()).attr('opacity', labelOpacity);\n        }\n    };\n\n    var titleFunction = function titleFunction(d) {\n        return _chart.title()(d);\n    };\n\n    _chart._doRenderTitles = function (g) {\n        if (_chart.renderTitle()) {\n            var title = g.select('title');\n\n            if (title.empty()) {\n                g.append('title').text(titleFunction);\n            }\n        }\n    };\n\n    _chart.doUpdateTitles = function (g) {\n        if (_chart.renderTitle()) {\n            g.select('title').text(titleFunction);\n        }\n    };\n\n    /**\r\n     * Turn on or off the bubble sorting feature, or return the value of the flag. If enabled,\r\n     * bubbles will be sorted by their radius, with smaller bubbles in front.\r\n     * @method sortBubbleSize\r\n     * @memberof dc.bubbleChart\r\n     * @instance\r\n     * @param {Boolean} [sortBubbleSize=false]\r\n     * @returns {Boolean|dc.bubbleChart}\r\n     */\n    _chart.sortBubbleSize = function (sortBubbleSize) {\n        if (!arguments.length) {\n            return _sortBubbleSize;\n        }\n        _sortBubbleSize = sortBubbleSize;\n        return _chart;\n    };\n\n    /**\r\n     * Get or set the minimum radius. This will be used to initialize the radius scale's range.\r\n     * @method minRadius\r\n     * @memberof dc.bubbleMixin\r\n     * @instance\r\n     * @param {Number} [radius=10]\r\n     * @returns {Number|dc.bubbleMixin}\r\n     */\n    _chart.minRadius = function (radius) {\n        if (!arguments.length) {\n            return _chart.MIN_RADIUS;\n        }\n        _chart.MIN_RADIUS = radius;\n        return _chart;\n    };\n\n    /**\r\n     * Get or set the minimum radius for label rendering. If a bubble's radius is less than this value\r\n     * then no label will be rendered.\r\n     * @method minRadiusWithLabel\r\n     * @memberof dc.bubbleMixin\r\n     * @instance\r\n     * @param {Number} [radius=10]\r\n     * @returns {Number|dc.bubbleMixin}\r\n     */\n\n    _chart.minRadiusWithLabel = function (radius) {\n        if (!arguments.length) {\n            return _minRadiusWithLabel;\n        }\n        _minRadiusWithLabel = radius;\n        return _chart;\n    };\n\n    /**\r\n     * Get or set the maximum relative size of a bubble to the length of x axis. This value is useful\r\n     * when the difference in radius between bubbles is too great.\r\n     * @method maxBubbleRelativeSize\r\n     * @memberof dc.bubbleMixin\r\n     * @instance\r\n     * @param {Number} [relativeSize=0.3]\r\n     * @returns {Number|dc.bubbleMixin}\r\n     */\n    _chart.maxBubbleRelativeSize = function (relativeSize) {\n        if (!arguments.length) {\n            return _maxBubbleRelativeSize;\n        }\n        _maxBubbleRelativeSize = relativeSize;\n        return _chart;\n    };\n\n    _chart.fadeDeselectedArea = function (selection) {\n        if (_chart.hasFilter()) {\n            _chart.selectAll('g.' + _chart.BUBBLE_NODE_CLASS).each(function (d) {\n                if (_chart.isSelectedNode(d)) {\n                    _chart.highlightSelected(this);\n                } else {\n                    _chart.fadeDeselected(this);\n                }\n            });\n        } else {\n            _chart.selectAll('g.' + _chart.BUBBLE_NODE_CLASS).each(function () {\n                _chart.resetHighlight(this);\n            });\n        }\n    };\n\n    _chart.isSelectedNode = function (d) {\n        return _chart.hasFilter(d.key);\n    };\n\n    _chart.onClick = function (d) {\n        var filter = d.key;\n        dc.events.trigger(function () {\n            _chart.filter(filter);\n            _chart.redrawGroup();\n        });\n    };\n\n    return _chart;\n};\n\n/**\r\n * The pie chart implementation is usually used to visualize a small categorical distribution.  The pie\r\n * chart uses keyAccessor to determine the slices, and valueAccessor to calculate the size of each\r\n * slice relative to the sum of all values. Slices are ordered by {@link dc.baseMixin#ordering ordering}\r\n * which defaults to sorting by key.\r\n *\r\n * Examples:\r\n * - {@link http://dc-js.github.com/dc.js/ Nasdaq 100 Index}\r\n * @class pieChart\r\n * @memberof dc\r\n * @mixes dc.capMixin\r\n * @mixes dc.colorMixin\r\n * @mixes dc.baseMixin\r\n * @example\r\n * // create a pie chart under #chart-container1 element using the default global chart group\r\n * var chart1 = dc.pieChart('#chart-container1');\r\n * // create a pie chart under #chart-container2 element using chart group A\r\n * var chart2 = dc.pieChart('#chart-container2', 'chartGroupA');\r\n * @param {String|node|d3.selection} parent - Any valid\r\n * {@link https://github.com/d3/d3-selection/blob/master/README.md#select d3 single selector} specifying\r\n * a dom block element such as a div; or a dom element or d3 selection.\r\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\r\n * Interaction with a chart will only trigger events and redraws within the chart's group.\r\n * @returns {dc.pieChart}\r\n */\ndc.pieChart = function (parent, chartGroup) {\n    var DEFAULT_MIN_ANGLE_FOR_LABEL = 0.5;\n\n    var _sliceCssClass = 'pie-slice';\n    var _labelCssClass = 'pie-label';\n    var _sliceGroupCssClass = 'pie-slice-group';\n    var _labelGroupCssClass = 'pie-label-group';\n    var _emptyCssClass = 'empty-chart';\n    var _emptyTitle = 'empty';\n\n    var _radius,\n        _givenRadius,\n        // specified radius, if any\n    _innerRadius = 0,\n        _externalRadiusPadding = 0;\n\n    var _g;\n    var _cx;\n    var _cy;\n    var _minAngleForLabel = DEFAULT_MIN_ANGLE_FOR_LABEL;\n    var _externalLabelRadius;\n    var _drawPaths = false;\n    var _chart = dc.capMixin(dc.colorMixin(dc.baseMixin({})));\n\n    _chart.colorAccessor(_chart.cappedKeyAccessor);\n\n    _chart.title(function (d) {\n        return _chart.cappedKeyAccessor(d) + ': ' + _chart.cappedValueAccessor(d);\n    });\n\n    /**\r\n     * Get or set the maximum number of slices the pie chart will generate. The top slices are determined by\r\n     * value from high to low. Other slices exeeding the cap will be rolled up into one single *Others* slice.\r\n     * @method slicesCap\r\n     * @memberof dc.pieChart\r\n     * @instance\r\n     * @param {Number} [cap]\r\n     * @returns {Number|dc.pieChart}\r\n     */\n    _chart.slicesCap = _chart.cap;\n\n    _chart.label(_chart.cappedKeyAccessor);\n    _chart.renderLabel(true);\n\n    _chart.transitionDuration(350);\n    _chart.transitionDelay(0);\n\n    _chart._doRender = function () {\n        _chart.resetSvg();\n\n        _g = _chart.svg().append('g').attr('transform', 'translate(' + _chart.cx() + ',' + _chart.cy() + ')');\n\n        _g.append('g').attr('class', _sliceGroupCssClass);\n        _g.append('g').attr('class', _labelGroupCssClass);\n\n        drawChart();\n\n        return _chart;\n    };\n\n    function drawChart() {\n        // set radius from chart size if none given, or if given radius is too large\n        var maxRadius = _d.d3.min([_chart.width(), _chart.height()]) / 2;\n        _radius = _givenRadius && _givenRadius < maxRadius ? _givenRadius : maxRadius;\n\n        var arc = buildArcs();\n\n        var pie = pieLayout();\n        var pieData;\n        // if we have data...\n        if (_d.d3.sum(_chart.data(), _chart.valueAccessor())) {\n            pieData = pie(_chart.data());\n            _g.classed(_emptyCssClass, false);\n        } else {\n            // otherwise we'd be getting NaNs, so override\n            // note: abuse others for its ignoring the value accessor\n            pieData = pie([{ key: _emptyTitle, value: 1, others: [_emptyTitle] }]);\n            _g.classed(_emptyCssClass, true);\n        }\n\n        if (_g) {\n            var slices = _g.select('g.' + _sliceGroupCssClass).selectAll('g.' + _sliceCssClass).data(pieData);\n\n            var labels = _g.select('g.' + _labelGroupCssClass).selectAll('text.' + _labelCssClass).data(pieData);\n\n            removeElements(slices, labels);\n\n            createElements(slices, labels, arc, pieData);\n\n            updateElements(pieData, arc);\n\n            highlightFilter();\n\n            dc.transition(_g, _chart.transitionDuration(), _chart.transitionDelay()).attr('transform', 'translate(' + _chart.cx() + ',' + _chart.cy() + ')');\n        }\n    }\n\n    function createElements(slices, labels, arc, pieData) {\n        var slicesEnter = createSliceNodes(slices);\n\n        createSlicePath(slicesEnter, arc);\n\n        createTitles(slicesEnter);\n\n        createLabels(labels, pieData, arc);\n    }\n\n    function createSliceNodes(slices) {\n        var slicesEnter = slices.enter().append('g').attr('class', function (d, i) {\n            return _sliceCssClass + ' _' + i;\n        });\n        return slicesEnter;\n    }\n\n    function createSlicePath(slicesEnter, arc) {\n        var slicePath = slicesEnter.append('path').attr('fill', fill).on('click', onClick).attr('d', function (d, i) {\n            return safeArc(d, i, arc);\n        });\n\n        var transition = dc.transition(slicePath, _chart.transitionDuration(), _chart.transitionDelay());\n        if (transition.attrTween) {\n            transition.attrTween('d', tweenPie);\n        }\n    }\n\n    function createTitles(slicesEnter) {\n        if (_chart.renderTitle()) {\n            slicesEnter.append('title').text(function (d) {\n                return _chart.title()(d.data);\n            });\n        }\n    }\n\n    _chart._applyLabelText = function (labels) {\n        labels.text(function (d) {\n            var data = d.data;\n            if ((sliceHasNoData(data) || sliceTooSmall(d)) && !isSelectedSlice(d)) {\n                return '';\n            }\n            return _chart.label()(d.data);\n        });\n    };\n\n    function positionLabels(labels, arc) {\n        _chart._applyLabelText(labels);\n        dc.transition(labels, _chart.transitionDuration(), _chart.transitionDelay()).attr('transform', function (d) {\n            return labelPosition(d, arc);\n        }).attr('text-anchor', 'middle');\n    }\n\n    function highlightSlice(i, whether) {\n        _chart.select('g.pie-slice._' + i).classed('highlight', whether);\n    }\n\n    function createLabels(labels, pieData, arc) {\n        if (_chart.renderLabel()) {\n            var labelsEnter = labels.enter().append('text').attr('class', function (d, i) {\n                var classes = _sliceCssClass + ' ' + _labelCssClass + ' _' + i;\n                if (_externalLabelRadius) {\n                    classes += ' external';\n                }\n                return classes;\n            }).on('click', onClick).on('mouseover', function (d, i) {\n                highlightSlice(i, true);\n            }).on('mouseout', function (d, i) {\n                highlightSlice(i, false);\n            });\n            positionLabels(labelsEnter, arc);\n            if (_externalLabelRadius && _drawPaths) {\n                updateLabelPaths(pieData, arc);\n            }\n        }\n    }\n\n    function updateLabelPaths(pieData, arc) {\n        var polyline = _g.selectAll('polyline.' + _sliceCssClass).data(pieData);\n\n        polyline.exit().remove();\n\n        polyline = polyline.enter().append('polyline').attr('class', function (d, i) {\n            return 'pie-path _' + i + ' ' + _sliceCssClass;\n        }).on('click', onClick).on('mouseover', function (d, i) {\n            highlightSlice(i, true);\n        }).on('mouseout', function (d, i) {\n            highlightSlice(i, false);\n        }).merge(polyline);\n\n        var arc2 = _d.d3.arc().outerRadius(_radius - _externalRadiusPadding + _externalLabelRadius).innerRadius(_radius - _externalRadiusPadding);\n        var transition = dc.transition(polyline, _chart.transitionDuration(), _chart.transitionDelay());\n        // this is one rare case where d3.selection differs from d3.transition\n        if (transition.attrTween) {\n            transition.attrTween('points', function (d) {\n                var current = this._current || d;\n                current = { startAngle: current.startAngle, endAngle: current.endAngle };\n                var interpolate = _d.d3.interpolate(current, d);\n                this._current = interpolate(0);\n                return function (t) {\n                    var d2 = interpolate(t);\n                    return [arc.centroid(d2), arc2.centroid(d2)];\n                };\n            });\n        } else {\n            transition.attr('points', function (d) {\n                return [arc.centroid(d), arc2.centroid(d)];\n            });\n        }\n        transition.style('visibility', function (d) {\n            return d.endAngle - d.startAngle < 0.0001 ? 'hidden' : 'visible';\n        });\n    }\n\n    function updateElements(pieData, arc) {\n        updateSlicePaths(pieData, arc);\n        updateLabels(pieData, arc);\n        updateTitles(pieData);\n    }\n\n    function updateSlicePaths(pieData, arc) {\n        var slicePaths = _g.selectAll('g.' + _sliceCssClass).data(pieData).select('path').attr('d', function (d, i) {\n            return safeArc(d, i, arc);\n        });\n        var transition = dc.transition(slicePaths, _chart.transitionDuration(), _chart.transitionDelay());\n        if (transition.attrTween) {\n            transition.attrTween('d', tweenPie);\n        }\n        transition.attr('fill', fill);\n    }\n\n    function updateLabels(pieData, arc) {\n        if (_chart.renderLabel()) {\n            var labels = _g.selectAll('text.' + _labelCssClass).data(pieData);\n            positionLabels(labels, arc);\n            if (_externalLabelRadius && _drawPaths) {\n                updateLabelPaths(pieData, arc);\n            }\n        }\n    }\n\n    function updateTitles(pieData) {\n        if (_chart.renderTitle()) {\n            _g.selectAll('g.' + _sliceCssClass).data(pieData).select('title').text(function (d) {\n                return _chart.title()(d.data);\n            });\n        }\n    }\n\n    function removeElements(slices, labels) {\n        slices.exit().remove();\n        labels.exit().remove();\n    }\n\n    function highlightFilter() {\n        if (_chart.hasFilter()) {\n            _chart.selectAll('g.' + _sliceCssClass).each(function (d) {\n                if (isSelectedSlice(d)) {\n                    _chart.highlightSelected(this);\n                } else {\n                    _chart.fadeDeselected(this);\n                }\n            });\n        } else {\n            _chart.selectAll('g.' + _sliceCssClass).each(function () {\n                _chart.resetHighlight(this);\n            });\n        }\n    }\n\n    /**\r\n     * Get or set the external radius padding of the pie chart. This will force the radius of the\r\n     * pie chart to become smaller or larger depending on the value.\r\n     * @method externalRadiusPadding\r\n     * @memberof dc.pieChart\r\n     * @instance\r\n     * @param {Number} [externalRadiusPadding=0]\r\n     * @returns {Number|dc.pieChart}\r\n     */\n    _chart.externalRadiusPadding = function (externalRadiusPadding) {\n        if (!arguments.length) {\n            return _externalRadiusPadding;\n        }\n        _externalRadiusPadding = externalRadiusPadding;\n        return _chart;\n    };\n\n    /**\r\n     * Get or set the inner radius of the pie chart. If the inner radius is greater than 0px then the\r\n     * pie chart will be rendered as a doughnut chart.\r\n     * @method innerRadius\r\n     * @memberof dc.pieChart\r\n     * @instance\r\n     * @param {Number} [innerRadius=0]\r\n     * @returns {Number|dc.pieChart}\r\n     */\n    _chart.innerRadius = function (innerRadius) {\n        if (!arguments.length) {\n            return _innerRadius;\n        }\n        _innerRadius = innerRadius;\n        return _chart;\n    };\n\n    /**\r\n     * Get or set the outer radius. If the radius is not set, it will be half of the minimum of the\r\n     * chart width and height.\r\n     * @method radius\r\n     * @memberof dc.pieChart\r\n     * @instance\r\n     * @param {Number} [radius]\r\n     * @returns {Number|dc.pieChart}\r\n     */\n    _chart.radius = function (radius) {\n        if (!arguments.length) {\n            return _givenRadius;\n        }\n        _givenRadius = radius;\n        return _chart;\n    };\n\n    /**\r\n     * Get or set center x coordinate position. Default is center of svg.\r\n     * @method cx\r\n     * @memberof dc.pieChart\r\n     * @instance\r\n     * @param {Number} [cx]\r\n     * @returns {Number|dc.pieChart}\r\n     */\n    _chart.cx = function (cx) {\n        if (!arguments.length) {\n            return _cx || _chart.width() / 2;\n        }\n        _cx = cx;\n        return _chart;\n    };\n\n    /**\r\n     * Get or set center y coordinate position. Default is center of svg.\r\n     * @method cy\r\n     * @memberof dc.pieChart\r\n     * @instance\r\n     * @param {Number} [cy]\r\n     * @returns {Number|dc.pieChart}\r\n     */\n    _chart.cy = function (cy) {\n        if (!arguments.length) {\n            return _cy || _chart.height() / 2;\n        }\n        _cy = cy;\n        return _chart;\n    };\n\n    function buildArcs() {\n        return _d.d3.arc().outerRadius(_radius - _externalRadiusPadding).innerRadius(_innerRadius);\n    }\n\n    function isSelectedSlice(d) {\n        return _chart.hasFilter(_chart.cappedKeyAccessor(d.data));\n    }\n\n    _chart._doRedraw = function () {\n        drawChart();\n        return _chart;\n    };\n\n    /**\r\n     * Get or set the minimal slice angle for label rendering. Any slice with a smaller angle will not\r\n     * display a slice label.\r\n     * @method minAngleForLabel\r\n     * @memberof dc.pieChart\r\n     * @instance\r\n     * @param {Number} [minAngleForLabel=0.5]\r\n     * @returns {Number|dc.pieChart}\r\n     */\n    _chart.minAngleForLabel = function (minAngleForLabel) {\n        if (!arguments.length) {\n            return _minAngleForLabel;\n        }\n        _minAngleForLabel = minAngleForLabel;\n        return _chart;\n    };\n\n    function pieLayout() {\n        return _d.d3.pie().sort(null).value(_chart.cappedValueAccessor);\n    }\n\n    function sliceTooSmall(d) {\n        var angle = d.endAngle - d.startAngle;\n        return isNaN(angle) || angle < _minAngleForLabel;\n    }\n\n    function sliceHasNoData(d) {\n        return _chart.cappedValueAccessor(d) === 0;\n    }\n\n    function tweenPie(b) {\n        b.innerRadius = _innerRadius;\n        var current = this._current;\n        if (isOffCanvas(current)) {\n            current = { startAngle: 0, endAngle: 0 };\n        } else {\n            // only interpolate startAngle & endAngle, not the whole data object\n            current = { startAngle: current.startAngle, endAngle: current.endAngle };\n        }\n        var i = _d.d3.interpolate(current, b);\n        this._current = i(0);\n        return function (t) {\n            return safeArc(i(t), 0, buildArcs());\n        };\n    }\n\n    function isOffCanvas(current) {\n        return !current || isNaN(current.startAngle) || isNaN(current.endAngle);\n    }\n\n    function fill(d, i) {\n        return _chart.getColor(d.data, i);\n    }\n\n    function onClick(d, i) {\n        if (_g.attr('class') !== _emptyCssClass) {\n            _chart.onClick(d.data, i);\n        }\n    }\n\n    function safeArc(d, i, arc) {\n        var path = arc(d, i);\n        if (path.indexOf('NaN') >= 0) {\n            path = 'M0,0';\n        }\n        return path;\n    }\n\n    /**\r\n     * Title to use for the only slice when there is no data.\r\n     * @method emptyTitle\r\n     * @memberof dc.pieChart\r\n     * @instance\r\n     * @param {String} [title]\r\n     * @returns {String|dc.pieChart}\r\n     */\n    _chart.emptyTitle = function (title) {\n        if (arguments.length === 0) {\n            return _emptyTitle;\n        }\n        _emptyTitle = title;\n        return _chart;\n    };\n\n    /**\r\n     * Position slice labels offset from the outer edge of the chart.\r\n     *\r\n     * The argument specifies the extra radius to be added for slice labels.\r\n     * @method externalLabels\r\n     * @memberof dc.pieChart\r\n     * @instance\r\n     * @param {Number} [externalLabelRadius]\r\n     * @returns {Number|dc.pieChart}\r\n     */\n    _chart.externalLabels = function (externalLabelRadius) {\n        if (arguments.length === 0) {\n            return _externalLabelRadius;\n        } else if (externalLabelRadius) {\n            _externalLabelRadius = externalLabelRadius;\n        } else {\n            _externalLabelRadius = undefined;\n        }\n\n        return _chart;\n    };\n\n    /**\r\n     * Get or set whether to draw lines from pie slices to their labels.\r\n     *\r\n     * @method drawPaths\r\n     * @memberof dc.pieChart\r\n     * @instance\r\n     * @param {Boolean} [drawPaths]\r\n     * @returns {Boolean|dc.pieChart}\r\n     */\n    _chart.drawPaths = function (drawPaths) {\n        if (arguments.length === 0) {\n            return _drawPaths;\n        }\n        _drawPaths = drawPaths;\n        return _chart;\n    };\n\n    function labelPosition(d, arc) {\n        var centroid;\n        if (_externalLabelRadius) {\n            centroid = _d.d3.arc().outerRadius(_radius - _externalRadiusPadding + _externalLabelRadius).innerRadius(_radius - _externalRadiusPadding + _externalLabelRadius).centroid(d);\n        } else {\n            centroid = arc.centroid(d);\n        }\n        if (isNaN(centroid[0]) || isNaN(centroid[1])) {\n            return 'translate(0,0)';\n        } else {\n            return 'translate(' + centroid + ')';\n        }\n    }\n\n    _chart.legendables = function () {\n        return _chart.data().map(function (d, i) {\n            var legendable = { name: d.key, data: d.value, others: d.others, chart: _chart };\n            legendable.color = _chart.getColor(d, i);\n            return legendable;\n        });\n    };\n\n    _chart.legendHighlight = function (d) {\n        highlightSliceFromLegendable(d, true);\n    };\n\n    _chart.legendReset = function (d) {\n        highlightSliceFromLegendable(d, false);\n    };\n\n    _chart.legendToggle = function (d) {\n        _chart.onClick({ key: d.name, others: d.others });\n    };\n\n    function highlightSliceFromLegendable(legendable, highlighted) {\n        _chart.selectAll('g.pie-slice').each(function (d) {\n            if (legendable.name === d.data.key) {\n                _d.d3.select(this).classed('highlight', highlighted);\n            }\n        });\n    }\n\n    return _chart.anchor(parent, chartGroup);\n};\n\n/**\r\n * The sunburst chart implementation is usually used to visualize a small tree distribution.  The sunburst\r\n * chart uses keyAccessor to determine the slices, and valueAccessor to calculate the size of each\r\n * slice relative to the sum of all values. Slices are ordered by {@link dc.baseMixin#ordering ordering} which defaults to sorting\r\n * by key.\r\n *\r\n * The keys used in the sunburst chart should be arrays, representing paths in the tree.\r\n *\r\n * When filtering, the sunburst chart creates instances of {@link dc.filters.HierarchyFilter HierarchyFilter}.\r\n *\r\n * @class sunburstChart\r\n * @memberof dc\r\n * @mixes dc.capMixin\r\n * @mixes dc.colorMixin\r\n * @mixes dc.baseMixin\r\n * @example\r\n * // create a sunburst chart under #chart-container1 element using the default global chart group\r\n * var chart1 = dc.sunburstChart('#chart-container1');\r\n * // create a sunburst chart under #chart-container2 element using chart group A\r\n * var chart2 = dc.sunburstChart('#chart-container2', 'chartGroupA');\r\n *\r\n * @param {String|node|d3.selection} parent - Any valid\r\n * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements d3 single selector} specifying\r\n * a dom block element such as a div; or a dom element or d3 selection.\r\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\r\n * Interaction with a chart will only trigger events and redraws within the chart's group.\r\n * @returns {dc.sunburstChart}\r\n **/\ndc.sunburstChart = function (parent, chartGroup) {\n    var DEFAULT_MIN_ANGLE_FOR_LABEL = 0.5;\n\n    var _sliceCssClass = 'pie-slice';\n    var _emptyCssClass = 'empty-chart';\n    var _emptyTitle = 'empty';\n\n    var _radius,\n        _innerRadius = 0;\n\n    var _g;\n    var _cx;\n    var _cy;\n    var _minAngleForLabel = DEFAULT_MIN_ANGLE_FOR_LABEL;\n    var _externalLabelRadius;\n    var _chart = dc.capMixin(dc.colorMixin(dc.baseMixin({})));\n\n    _chart.colorAccessor(_chart.cappedKeyAccessor);\n\n    // Handle cases if value corresponds to generated parent nodes\n    function extendedValueAccessor(d) {\n        if (d.path) {\n            return d.value;\n        }\n        return _chart.cappedValueAccessor(d);\n    }\n\n    _chart.title(function (d) {\n        return _chart.cappedKeyAccessor(d) + ': ' + extendedValueAccessor(d);\n    });\n\n    _chart.label(_chart.cappedKeyAccessor);\n    _chart.renderLabel(true);\n\n    _chart.transitionDuration(350);\n\n    _chart.filterHandler(function (dimension, filters) {\n        if (filters.length === 0) {\n            dimension.filter(null);\n        } else {\n            dimension.filterFunction(function (d) {\n                for (var i = 0; i < filters.length; i++) {\n                    var filter = filters[i];\n                    if (filter.isFiltered && filter.isFiltered(d)) {\n                        return true;\n                    }\n                }\n                return false;\n            });\n        }\n        return filters;\n    });\n\n    _chart._doRender = function () {\n        _chart.resetSvg();\n\n        _g = _chart.svg().append('g').attr('transform', 'translate(' + _chart.cx() + ',' + _chart.cy() + ')');\n\n        drawChart();\n\n        return _chart;\n    };\n\n    function drawChart() {\n        // set radius on basis of chart dimension if missing\n        _radius = _radius ? _radius : _d.d3.min([_chart.width(), _chart.height()]) / 2;\n\n        var arc = buildArcs();\n\n        var sunburstData, cdata;\n        // if we have data...\n        if (_d.d3.sum(_chart.data(), _chart.valueAccessor())) {\n            cdata = dc.utils.toHierarchy(_chart.data(), _chart.valueAccessor());\n            sunburstData = partitionNodes(cdata);\n            // First one is the root, which is not needed\n            sunburstData.shift();\n            _g.classed(_emptyCssClass, false);\n        } else {\n            // otherwise we'd be getting NaNs, so override\n            // note: abuse others for its ignoring the value accessor\n            cdata = dc.utils.toHierarchy([], function (d) {\n                return d.value;\n            });\n            sunburstData = partitionNodes(cdata);\n            _g.classed(_emptyCssClass, true);\n        }\n\n        if (_g) {\n            var slices = _g.selectAll('g.' + _sliceCssClass).data(sunburstData);\n            createElements(slices, arc, sunburstData);\n\n            updateElements(sunburstData, arc);\n\n            removeElements(slices);\n\n            highlightFilter();\n        }\n    }\n\n    function createElements(slices, arc, sunburstData) {\n        var slicesEnter = createSliceNodes(slices);\n\n        createSlicePath(slicesEnter, arc);\n        createTitles(slicesEnter);\n        createLabels(sunburstData, arc);\n    }\n\n    function createSliceNodes(slices) {\n        var slicesEnter = slices.enter().append('g').attr('class', function (d, i) {\n            return _sliceCssClass + ' _' + i + ' ' + _sliceCssClass + '-level-' + d.depth;\n        });\n        return slicesEnter;\n    }\n\n    function createSlicePath(slicesEnter, arc) {\n        var slicePath = slicesEnter.append('path').attr('fill', fill).on('click', onClick).attr('d', function (d, i) {\n            return safeArc(d, i, arc);\n        });\n\n        var transition = dc.transition(slicePath, _chart.transitionDuration());\n        if (transition.attrTween) {\n            transition.attrTween('d', tweenSlice);\n        }\n    }\n\n    function createTitles(slicesEnter) {\n        if (_chart.renderTitle()) {\n            slicesEnter.append('title').text(function (d) {\n                return _chart.title()(d);\n            });\n        }\n    }\n\n    function positionLabels(labelsEnter, arc) {\n        dc.transition(labelsEnter, _chart.transitionDuration()).attr('transform', function (d) {\n            return labelPosition(d, arc);\n        }).attr('text-anchor', 'middle').text(function (d) {\n            // position label...\n            if (sliceHasNoData(d) || sliceTooSmall(d)) {\n                return '';\n            }\n            return _chart.label()(d);\n        });\n    }\n\n    function createLabels(sunburstData, arc) {\n        if (_chart.renderLabel()) {\n            var labels = _g.selectAll('text.' + _sliceCssClass).data(sunburstData);\n\n            labels.exit().remove();\n\n            var labelsEnter = labels.enter().append('text').attr('class', function (d, i) {\n                var classes = _sliceCssClass + ' _' + i;\n                if (_externalLabelRadius) {\n                    classes += ' external';\n                }\n                return classes;\n            }).on('click', onClick);\n            positionLabels(labelsEnter, arc);\n        }\n    }\n\n    function updateElements(sunburstData, arc) {\n        updateSlicePaths(sunburstData, arc);\n        updateLabels(sunburstData, arc);\n        updateTitles(sunburstData);\n    }\n\n    function updateSlicePaths(sunburstData, arc) {\n        var slicePaths = _g.selectAll('g.' + _sliceCssClass).data(sunburstData).select('path').attr('d', function (d, i) {\n            return safeArc(d, i, arc);\n        });\n        var transition = dc.transition(slicePaths, _chart.transitionDuration());\n        if (transition.attrTween) {\n            transition.attrTween('d', tweenSlice);\n        }\n        transition.attr('fill', fill);\n    }\n\n    function updateLabels(sunburstData, arc) {\n        if (_chart.renderLabel()) {\n            var labels = _g.selectAll('text.' + _sliceCssClass).data(sunburstData);\n            positionLabels(labels, arc);\n        }\n    }\n\n    function updateTitles(sunburstData) {\n        if (_chart.renderTitle()) {\n            _g.selectAll('g.' + _sliceCssClass).data(sunburstData).select('title').text(function (d) {\n                return _chart.title()(d);\n            });\n        }\n    }\n\n    function removeElements(slices) {\n        slices.exit().remove();\n    }\n\n    function highlightFilter() {\n        if (_chart.hasFilter()) {\n            _chart.selectAll('g.' + _sliceCssClass).each(function (d) {\n                if (isSelectedSlice(d)) {\n                    _chart.highlightSelected(this);\n                } else {\n                    _chart.fadeDeselected(this);\n                }\n            });\n        } else {\n            _chart.selectAll('g.' + _sliceCssClass).each(function (d) {\n                _chart.resetHighlight(this);\n            });\n        }\n    }\n\n    /**\r\n     * Get or set the inner radius of the sunburst chart. If the inner radius is greater than 0px then the\r\n     * sunburst chart will be rendered as a doughnut chart. Default inner radius is 0px.\r\n     * @method innerRadius\r\n     * @memberof dc.sunburstChart\r\n     * @instance\r\n     * @param {Number} [innerRadius=0]\r\n     * @returns {Number|dc.sunburstChart}\r\n     */\n    _chart.innerRadius = function (innerRadius) {\n        if (!arguments.length) {\n            return _innerRadius;\n        }\n        _innerRadius = innerRadius;\n        return _chart;\n    };\n\n    /**\r\n     * Get or set the outer radius. If the radius is not set, it will be half of the minimum of the\r\n     * chart width and height.\r\n     * @method radius\r\n     * @memberof dc.sunburstChart\r\n     * @instance\r\n     * @param {Number} [radius]\r\n     * @returns {Number|dc.sunburstChart}\r\n     */\n    _chart.radius = function (radius) {\n        if (!arguments.length) {\n            return _radius;\n        }\n        _radius = radius;\n        return _chart;\n    };\n\n    /**\r\n     * Get or set center x coordinate position. Default is center of svg.\r\n     * @method cx\r\n     * @memberof dc.sunburstChart\r\n     * @instance\r\n     * @param {Number} [cx]\r\n     * @returns {Number|dc.sunburstChart}\r\n     */\n    _chart.cx = function (cx) {\n        if (!arguments.length) {\n            return _cx || _chart.width() / 2;\n        }\n        _cx = cx;\n        return _chart;\n    };\n\n    /**\r\n     * Get or set center y coordinate position. Default is center of svg.\r\n     * @method cy\r\n     * @memberof dc.sunburstChart\r\n     * @instance\r\n     * @param {Number} [cy]\r\n     * @returns {Number|dc.sunburstChart}\r\n     */\n    _chart.cy = function (cy) {\n        if (!arguments.length) {\n            return _cy || _chart.height() / 2;\n        }\n        _cy = cy;\n        return _chart;\n    };\n\n    /**\r\n     * Get or set the minimal slice angle for label rendering. Any slice with a smaller angle will not\r\n     * display a slice label.\r\n     * @method minAngleForLabel\r\n     * @memberof dc.sunburstChart\r\n     * @instance\r\n     * @param {Number} [minAngleForLabel=0.5]\r\n     * @returns {Number|dc.sunburstChart}\r\n     */\n    _chart.minAngleForLabel = function (minAngleForLabel) {\n        if (!arguments.length) {\n            return _minAngleForLabel;\n        }\n        _minAngleForLabel = minAngleForLabel;\n        return _chart;\n    };\n\n    /**\r\n     * Title to use for the only slice when there is no data.\r\n     * @method emptyTitle\r\n     * @memberof dc.sunburstChart\r\n     * @instance\r\n     * @param {String} [title]\r\n     * @returns {String|dc.sunburstChart}\r\n     */\n    _chart.emptyTitle = function (title) {\n        if (arguments.length === 0) {\n            return _emptyTitle;\n        }\n        _emptyTitle = title;\n        return _chart;\n    };\n\n    /**\r\n     * Position slice labels offset from the outer edge of the chart.\r\n     *\r\n     * The argument specifies the extra radius to be added for slice labels.\r\n     * @method externalLabels\r\n     * @memberof dc.sunburstChart\r\n     * @instance\r\n     * @param {Number} [externalLabelRadius]\r\n     * @returns {Number|dc.sunburstChart}\r\n     */\n    _chart.externalLabels = function (externalLabelRadius) {\n        if (arguments.length === 0) {\n            return _externalLabelRadius;\n        } else if (externalLabelRadius) {\n            _externalLabelRadius = externalLabelRadius;\n        } else {\n            _externalLabelRadius = undefined;\n        }\n\n        return _chart;\n    };\n\n    function buildArcs() {\n        return _d.d3.arc().startAngle(function (d) {\n            return d.x0;\n        }).endAngle(function (d) {\n            return d.x1;\n        }).innerRadius(function (d) {\n            return d.data.path && d.data.path.length === 1 ? _innerRadius : Math.sqrt(d.y0);\n        }).outerRadius(function (d) {\n            return Math.sqrt(d.y1);\n        });\n    }\n\n    function isSelectedSlice(d) {\n        return isPathFiltered(d.path);\n    }\n\n    function isPathFiltered(path) {\n        for (var i = 0; i < _chart.filters().length; i++) {\n            var currentFilter = _chart.filters()[i];\n            if (currentFilter.isFiltered(path)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // returns all filters that are a parent or child of the path\n    function filtersForPath(path) {\n        var pathFilter = dc.filters.HierarchyFilter(path);\n        var filters = [];\n        for (var i = 0; i < _chart.filters().length; i++) {\n            var currentFilter = _chart.filters()[i];\n            if (currentFilter.isFiltered(path) || pathFilter.isFiltered(currentFilter)) {\n                filters.push(currentFilter);\n            }\n        }\n        return filters;\n    }\n\n    _chart._doRedraw = function () {\n        drawChart();\n        return _chart;\n    };\n\n    function partitionNodes(data) {\n        // The changes picked up from https://github.com/d3/d3-hierarchy/issues/50\n        var hierarchy = _d.d3.hierarchy(data).sum(function (d) {\n            return d.children ? 0 : extendedValueAccessor(d);\n        }).sort(function (a, b) {\n            return _d.d3.ascending(a.data.path, b.data.path);\n        });\n\n        var partition = _d.d3.partition().size([2 * Math.PI, _radius * _radius]);\n\n        partition(hierarchy);\n\n        // In D3v4 the returned data is slightly different, change it enough to suit our purposes.\n        var nodes = hierarchy.descendants().map(function (d) {\n            d.key = d.data.key;\n            d.path = d.data.path;\n            return d;\n        });\n\n        return nodes;\n    }\n\n    function sliceTooSmall(d) {\n        var angle = d.x1 - d.x0;\n        return isNaN(angle) || angle < _minAngleForLabel;\n    }\n\n    function sliceHasNoData(d) {\n        return extendedValueAccessor(d) === 0;\n    }\n\n    function tweenSlice(b) {\n        b.innerRadius = _innerRadius; //?\n        var current = this._current;\n        if (isOffCanvas(current)) {\n            current = { x: 0, y: 0, dx: 0, dy: 0 };\n        }\n        // unfortunally, we can't tween an entire hierarchy since it has 2 way links.\n        var tweenTarget = { x: b.x, y: b.y, dx: b.dx, dy: b.dy };\n        var i = _d.d3.interpolate(current, tweenTarget);\n        this._current = i(0);\n        return function (t) {\n            return safeArc(Object.assign({}, b, i(t)), 0, buildArcs());\n        };\n    }\n\n    function isOffCanvas(current) {\n        return !current || isNaN(current.dx) || isNaN(current.dy);\n    }\n\n    function fill(d, i) {\n        return _chart.getColor(d, i);\n    }\n\n    function _onClick(d) {\n        // Clicking on Legends do not filter, it throws exception\n        // Must be better way to handle this, in legends we need to access `d.key`\n        var path = d.path || d.key;\n        var filter = dc.filters.HierarchyFilter(path);\n\n        // filters are equal to, parents or children of the path.\n        var filters = filtersForPath(path);\n        var exactMatch = false;\n        // clear out any filters that cover the path filtered.\n        for (var i = filters.length - 1; i >= 0; i--) {\n            var currentFilter = filters[i];\n            if (dc.utils.arraysIdentical(currentFilter, path)) {\n                exactMatch = true;\n            }\n            _chart.filter(filters[i]);\n        }\n        dc.events.trigger(function () {\n            // if it is a new filter - put it in.\n            if (!exactMatch) {\n                _chart.filter(filter);\n            }\n            _chart.redrawGroup();\n        });\n    }\n\n    _chart.onClick = onClick;\n\n    function onClick(d, i) {\n        if (_g.attr('class') !== _emptyCssClass) {\n            _onClick(d, i);\n        }\n    }\n\n    function safeArc(d, i, arc) {\n        var path = arc(d, i);\n        if (path.indexOf('NaN') >= 0) {\n            path = 'M0,0';\n        }\n        return path;\n    }\n\n    function labelPosition(d, arc) {\n        var centroid;\n        if (_externalLabelRadius) {\n            centroid = _d.d3.svg.arc().outerRadius(_radius + _externalLabelRadius).innerRadius(_radius + _externalLabelRadius).centroid(d);\n        } else {\n            centroid = arc.centroid(d);\n        }\n        if (isNaN(centroid[0]) || isNaN(centroid[1])) {\n            return 'translate(0,0)';\n        } else {\n            return 'translate(' + centroid + ')';\n        }\n    }\n\n    _chart.legendables = function () {\n        return _chart.data().map(function (d, i) {\n            var legendable = { name: d.key, data: d.value, others: d.others, chart: _chart };\n            legendable.color = _chart.getColor(d, i);\n            return legendable;\n        });\n    };\n\n    _chart.legendHighlight = function (d) {\n        highlightSliceFromLegendable(d, true);\n    };\n\n    _chart.legendReset = function (d) {\n        highlightSliceFromLegendable(d, false);\n    };\n\n    _chart.legendToggle = function (d) {\n        _chart.onClick({ key: d.name, others: d.others });\n    };\n\n    function highlightSliceFromLegendable(legendable, highlighted) {\n        _chart.selectAll('g.pie-slice').each(function (d) {\n            if (legendable.name === d.key) {\n                _d.d3.select(this).classed('highlight', highlighted);\n            }\n        });\n    }\n\n    return _chart.anchor(parent, chartGroup);\n};\n\n/**\r\n * Concrete bar chart/histogram implementation.\r\n *\r\n * Examples:\r\n * - {@link http://dc-js.github.com/dc.js/ Nasdaq 100 Index}\r\n * - {@link http://dc-js.github.com/dc.js/crime/index.html Canadian City Crime Stats}\r\n * @class barChart\r\n * @memberof dc\r\n * @mixes dc.stackMixin\r\n * @mixes dc.coordinateGridMixin\r\n * @example\r\n * // create a bar chart under #chart-container1 element using the default global chart group\r\n * var chart1 = dc.barChart('#chart-container1');\r\n * // create a bar chart under #chart-container2 element using chart group A\r\n * var chart2 = dc.barChart('#chart-container2', 'chartGroupA');\r\n * // create a sub-chart under a composite parent chart\r\n * var chart3 = dc.barChart(compositeChart);\r\n * @param {String|node|d3.selection|dc.compositeChart} parent - Any valid\r\n * {@link https://github.com/d3/d3-selection/blob/master/README.md#select d3 single selector}\r\n * specifying a dom block element such as a div; or a dom element or d3 selection.  If the bar\r\n * chart is a sub-chart in a {@link dc.compositeChart Composite Chart} then pass in the parent\r\n * composite chart instance instead.\r\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\r\n * Interaction with a chart will only trigger events and redraws within the chart's group.\r\n * @returns {dc.barChart}\r\n */\ndc.barChart = function (parent, chartGroup) {\n    var MIN_BAR_WIDTH = 1;\n    var DEFAULT_GAP_BETWEEN_BARS = 2;\n    var LABEL_PADDING = 3;\n\n    var _chart = dc.stackMixin(dc.coordinateGridMixin({}));\n\n    var _gap = DEFAULT_GAP_BETWEEN_BARS;\n    var _centerBar = false;\n    var _alwaysUseRounding = false;\n\n    var _barWidth;\n\n    dc.override(_chart, 'rescale', function () {\n        _chart._rescale();\n        _barWidth = undefined;\n        return _chart;\n    });\n\n    dc.override(_chart, 'render', function () {\n        if (_chart.round() && _centerBar && !_alwaysUseRounding) {\n            dc.logger.warn('By default, brush rounding is disabled if bars are centered. ' + 'See dc.js bar chart API documentation for details.');\n        }\n\n        return _chart._render();\n    });\n\n    _chart.label(function (d) {\n        return dc.utils.printSingleValue(d.y0 + d.y);\n    }, false);\n\n    _chart.plotData = function () {\n        var layers = _chart.chartBodyG().selectAll('g.stack').data(_chart.data());\n\n        calculateBarWidth();\n\n        layers = layers.enter().append('g').attr('class', function (d, i) {\n            return 'stack ' + '_' + i;\n        }).merge(layers);\n\n        var last = layers.size() - 1;\n        layers.each(function (d, i) {\n            var layer = _d.d3.select(this);\n\n            renderBars(layer, i, d);\n\n            if (_chart.renderLabel() && last === i) {\n                renderLabels(layer, i, d);\n            }\n        });\n    };\n\n    function barHeight(d) {\n        return dc.utils.safeNumber(Math.abs(_chart.y()(d.y + d.y0) - _chart.y()(d.y0)));\n    }\n\n    function labelXPos(d) {\n        var x = _chart.x()(d.x);\n        if (!_centerBar) {\n            x += _barWidth / 2;\n        }\n        if (_chart.isOrdinal() && _gap !== undefined) {\n            x += _gap / 2;\n        }\n        return dc.utils.safeNumber(x);\n    }\n\n    function labelYPos(d) {\n        var y = _chart.y()(d.y + d.y0);\n\n        if (d.y < 0) {\n            y -= barHeight(d);\n        }\n\n        return dc.utils.safeNumber(y - LABEL_PADDING);\n    }\n\n    function renderLabels(layer, layerIndex, d) {\n        var labels = layer.selectAll('text.barLabel').data(d.values, dc.pluck('x'));\n\n        var labelsEnterUpdate = labels.enter().append('text').attr('class', 'barLabel').attr('text-anchor', 'middle').attr('x', labelXPos).attr('y', labelYPos).merge(labels);\n\n        if (_chart.isOrdinal()) {\n            labelsEnterUpdate.on('click', _chart.onClick);\n            labelsEnterUpdate.attr('cursor', 'pointer');\n        }\n\n        dc.transition(labelsEnterUpdate, _chart.transitionDuration(), _chart.transitionDelay()).attr('x', labelXPos).attr('y', labelYPos).text(function (d) {\n            return _chart.label()(d);\n        });\n\n        dc.transition(labels.exit(), _chart.transitionDuration(), _chart.transitionDelay()).attr('height', 0).remove();\n    }\n\n    function barXPos(d) {\n        var x = _chart.x()(d.x);\n        if (_centerBar) {\n            x -= _barWidth / 2;\n        }\n        if (_chart.isOrdinal() && _gap !== undefined) {\n            x += _gap / 2;\n        }\n        return dc.utils.safeNumber(x);\n    }\n\n    function renderBars(layer, layerIndex, d) {\n        var bars = layer.selectAll('rect.bar').data(d.values, dc.pluck('x'));\n\n        var enter = bars.enter().append('rect').attr('class', 'bar').attr('fill', dc.pluck('data', _chart.getColor)).attr('x', barXPos).attr('y', _chart.yAxisHeight()).attr('height', 0);\n\n        var barsEnterUpdate = enter.merge(bars);\n\n        if (_chart.renderTitle()) {\n            enter.append('title').text(dc.pluck('data', _chart.title(d.name)));\n        }\n\n        if (_chart.isOrdinal()) {\n            barsEnterUpdate.on('click', _chart.onClick);\n        }\n\n        dc.transition(barsEnterUpdate, _chart.transitionDuration(), _chart.transitionDelay()).attr('x', barXPos).attr('y', function (d) {\n            var y = _chart.y()(d.y + d.y0);\n\n            if (d.y < 0) {\n                y -= barHeight(d);\n            }\n\n            return dc.utils.safeNumber(y);\n        }).attr('width', _barWidth).attr('height', function (d) {\n            return barHeight(d);\n        }).attr('fill', dc.pluck('data', _chart.getColor)).select('title').text(dc.pluck('data', _chart.title(d.name)));\n\n        dc.transition(bars.exit(), _chart.transitionDuration(), _chart.transitionDelay()).attr('x', function (d) {\n            return _chart.x()(d.x);\n        }).attr('width', _barWidth * 0.9).remove();\n    }\n\n    function calculateBarWidth() {\n        if (_barWidth === undefined) {\n            var numberOfBars = _chart.xUnitCount();\n\n            // please can't we always use rangeBands for bar charts?\n            if (_chart.isOrdinal() && _gap === undefined) {\n                _barWidth = Math.floor(_chart.x().bandwidth());\n            } else if (_gap) {\n                _barWidth = Math.floor((_chart.xAxisLength() - (numberOfBars - 1) * _gap) / numberOfBars);\n            } else {\n                _barWidth = Math.floor(_chart.xAxisLength() / (1 + _chart.barPadding()) / numberOfBars);\n            }\n\n            if (_barWidth === Infinity || isNaN(_barWidth) || _barWidth < MIN_BAR_WIDTH) {\n                _barWidth = MIN_BAR_WIDTH;\n            }\n        }\n    }\n\n    _chart.fadeDeselectedArea = function (brushSelection) {\n        var bars = _chart.chartBodyG().selectAll('rect.bar');\n\n        if (_chart.isOrdinal()) {\n            if (_chart.hasFilter()) {\n                bars.classed(dc.constants.SELECTED_CLASS, function (d) {\n                    return _chart.hasFilter(d.x);\n                });\n                bars.classed(dc.constants.DESELECTED_CLASS, function (d) {\n                    return !_chart.hasFilter(d.x);\n                });\n            } else {\n                bars.classed(dc.constants.SELECTED_CLASS, false);\n                bars.classed(dc.constants.DESELECTED_CLASS, false);\n            }\n        } else if (_chart.brushOn() || _chart.parentBrushOn()) {\n            if (!_chart.brushIsEmpty(brushSelection)) {\n                var start = brushSelection[0];\n                var end = brushSelection[1];\n\n                bars.classed(dc.constants.DESELECTED_CLASS, function (d) {\n                    return d.x < start || d.x >= end;\n                });\n            } else {\n                bars.classed(dc.constants.DESELECTED_CLASS, false);\n            }\n        }\n    };\n\n    /**\r\n     * Whether the bar chart will render each bar centered around the data position on the x-axis.\r\n     * @method centerBar\r\n     * @memberof dc.barChart\r\n     * @instance\r\n     * @param {Boolean} [centerBar=false]\r\n     * @returns {Boolean|dc.barChart}\r\n     */\n    _chart.centerBar = function (centerBar) {\n        if (!arguments.length) {\n            return _centerBar;\n        }\n        _centerBar = centerBar;\n        return _chart;\n    };\n\n    dc.override(_chart, 'onClick', function (d) {\n        _chart._onClick(d.data);\n    });\n\n    /**\r\n     * Get or set the spacing between bars as a fraction of bar size. Valid values are between 0-1.\r\n     * Setting this value will also remove any previously set {@link dc.barChart#gap gap}. See the\r\n     * {@link https://github.com/d3/d3-scale/blob/master/README.md#scaleBand d3 docs}\r\n     * for a visual description of how the padding is applied.\r\n     * @method barPadding\r\n     * @memberof dc.barChart\r\n     * @instance\r\n     * @param {Number} [barPadding=0]\r\n     * @returns {Number|dc.barChart}\r\n     */\n    _chart.barPadding = function (barPadding) {\n        if (!arguments.length) {\n            return _chart._rangeBandPadding();\n        }\n        _chart._rangeBandPadding(barPadding);\n        _gap = undefined;\n        return _chart;\n    };\n\n    _chart._useOuterPadding = function () {\n        return _gap === undefined;\n    };\n\n    /**\r\n     * Get or set the outer padding on an ordinal bar chart. This setting has no effect on non-ordinal charts.\r\n     * Will pad the width by `padding * barWidth` on each side of the chart.\r\n     * @method outerPadding\r\n     * @memberof dc.barChart\r\n     * @instance\r\n     * @param {Number} [padding=0.5]\r\n     * @returns {Number|dc.barChart}\r\n     */\n    _chart.outerPadding = _chart._outerRangeBandPadding;\n\n    /**\r\n     * Manually set fixed gap (in px) between bars instead of relying on the default auto-generated\r\n     * gap.  By default the bar chart implementation will calculate and set the gap automatically\r\n     * based on the number of data points and the length of the x axis.\r\n     * @method gap\r\n     * @memberof dc.barChart\r\n     * @instance\r\n     * @param {Number} [gap=2]\r\n     * @returns {Number|dc.barChart}\r\n     */\n    _chart.gap = function (gap) {\n        if (!arguments.length) {\n            return _gap;\n        }\n        _gap = gap;\n        return _chart;\n    };\n\n    _chart.extendBrush = function (brushSelection) {\n        if (brushSelection && _chart.round() && (!_centerBar || _alwaysUseRounding)) {\n            brushSelection[0] = _chart.round()(brushSelection[0]);\n            brushSelection[1] = _chart.round()(brushSelection[1]);\n        }\n        return brushSelection;\n    };\n\n    /**\r\n     * Set or get whether rounding is enabled when bars are centered. If false, using\r\n     * rounding with centered bars will result in a warning and rounding will be ignored.  This flag\r\n     * has no effect if bars are not {@link dc.barChart#centerBar centered}.\r\n     * When using standard d3.js rounding methods, the brush often doesn't align correctly with\r\n     * centered bars since the bars are offset.  The rounding function must add an offset to\r\n     * compensate, such as in the following example.\r\n     * @method alwaysUseRounding\r\n     * @memberof dc.barChart\r\n     * @instance\r\n     * @example\r\n     * chart.round(function(n) { return Math.floor(n) + 0.5; });\r\n     * @param {Boolean} [alwaysUseRounding=false]\r\n     * @returns {Boolean|dc.barChart}\r\n     */\n    _chart.alwaysUseRounding = function (alwaysUseRounding) {\n        if (!arguments.length) {\n            return _alwaysUseRounding;\n        }\n        _alwaysUseRounding = alwaysUseRounding;\n        return _chart;\n    };\n\n    function colorFilter(color, inv) {\n        return function () {\n            var item = _d.d3.select(this);\n            var match = item.attr('fill') === color;\n            return inv ? !match : match;\n        };\n    }\n\n    _chart.legendHighlight = function (d) {\n        if (!_chart.isLegendableHidden(d)) {\n            _chart.g().selectAll('rect.bar').classed('highlight', colorFilter(d.color)).classed('fadeout', colorFilter(d.color, true));\n        }\n    };\n\n    _chart.legendReset = function () {\n        _chart.g().selectAll('rect.bar').classed('highlight', false).classed('fadeout', false);\n    };\n\n    dc.override(_chart, 'xAxisMax', function () {\n        var max = this._xAxisMax();\n        if ('resolution' in _chart.xUnits()) {\n            var res = _chart.xUnits().resolution;\n            max += res;\n        }\n        return max;\n    });\n\n    return _chart.anchor(parent, chartGroup);\n};\n\n/**\r\n * Concrete line/area chart implementation.\r\n *\r\n * Examples:\r\n * - {@link http://dc-js.github.com/dc.js/ Nasdaq 100 Index}\r\n * - {@link http://dc-js.github.com/dc.js/crime/index.html Canadian City Crime Stats}\r\n * @class lineChart\r\n * @memberof dc\r\n * @mixes dc.stackMixin\r\n * @mixes dc.coordinateGridMixin\r\n * @example\r\n * // create a line chart under #chart-container1 element using the default global chart group\r\n * var chart1 = dc.lineChart('#chart-container1');\r\n * // create a line chart under #chart-container2 element using chart group A\r\n * var chart2 = dc.lineChart('#chart-container2', 'chartGroupA');\r\n * // create a sub-chart under a composite parent chart\r\n * var chart3 = dc.lineChart(compositeChart);\r\n * @param {String|node|d3.selection|dc.compositeChart} parent - Any valid\r\n * {@link https://github.com/d3/d3-selection/blob/master/README.md#select d3 single selector}\r\n * specifying a dom block element such as a div; or a dom element or d3 selection.  If the line\r\n * chart is a sub-chart in a {@link dc.compositeChart Composite Chart} then pass in the parent\r\n * composite chart instance instead.\r\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\r\n * Interaction with a chart will only trigger events and redraws within the chart's group.\r\n * @returns {dc.lineChart}\r\n */\ndc.lineChart = function (parent, chartGroup) {\n    var DEFAULT_DOT_RADIUS = 5;\n    var TOOLTIP_G_CLASS = 'dc-tooltip';\n    var DOT_CIRCLE_CLASS = 'dot';\n    var Y_AXIS_REF_LINE_CLASS = 'yRef';\n    var X_AXIS_REF_LINE_CLASS = 'xRef';\n    var DEFAULT_DOT_OPACITY = 1e-6;\n    var LABEL_PADDING = 3;\n\n    var _chart = dc.stackMixin(dc.coordinateGridMixin({}));\n    var _renderArea = false;\n    var _dotRadius = DEFAULT_DOT_RADIUS;\n    var _dataPointRadius = null;\n    var _dataPointFillOpacity = DEFAULT_DOT_OPACITY;\n    var _dataPointStrokeOpacity = DEFAULT_DOT_OPACITY;\n    var _curve = null;\n    var _interpolate = null; // d3.curveLinear;  // deprecated in 3.0\n    var _tension = null; // deprecated in 3.0\n    var _defined;\n    var _dashStyle;\n    var _xyTipsOn = true;\n\n    _chart.transitionDuration(500);\n    _chart.transitionDelay(0);\n    _chart._rangeBandPadding(1);\n\n    _chart.plotData = function () {\n        var chartBody = _chart.chartBodyG();\n        var layersList = chartBody.select('g.stack-list');\n\n        if (layersList.empty()) {\n            layersList = chartBody.append('g').attr('class', 'stack-list');\n        }\n\n        var layers = layersList.selectAll('g.stack').data(_chart.data());\n\n        var layersEnter = layers.enter().append('g').attr('class', function (d, i) {\n            return 'stack ' + '_' + i;\n        });\n\n        layers = layersEnter.merge(layers);\n\n        drawLine(layersEnter, layers);\n\n        drawArea(layersEnter, layers);\n\n        drawDots(chartBody, layers);\n\n        if (_chart.renderLabel()) {\n            drawLabels(layers);\n        }\n    };\n\n    /**\r\n     * Gets or sets the curve factory to use for lines and areas drawn, allowing e.g. step\r\n     * functions, splines, and cubic interpolation. Typically you would use one of the interpolator functions\r\n     * provided by {@link https://github.com/d3/d3-shape/blob/master/README.md#curves d3 curves}.\r\n     *\r\n     * Replaces the use of {@link dc.lineChart#interpolate} and {@link dc.lineChart#tension}\r\n     * in dc.js < 3.0\r\n     *\r\n     * This is passed to\r\n     * {@link https://github.com/d3/d3-shape/blob/master/README.md#line_curve line.curve} and\r\n     * {@link https://github.com/d3/d3-shape/blob/master/README.md#area_curve area.curve}.\r\n     * @example\r\n     * // default\r\n     * chart\r\n     *     .curve(d3.curveLinear);\r\n     * // Add tension to curves that support it\r\n     * chart\r\n     *     .curve(d3.curveCardinal.tension(0.5));\r\n     * // You can use some specialized variation like\r\n     * // https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline\r\n     * chart\r\n     *     .curve(d3.curveCatmullRom.alpha(0.5));\r\n     * @method curve\r\n     * @memberof dc.lineChart\r\n     * @instance\r\n     * @see {@link https://github.com/d3/d3-shape/blob/master/README.md#line_curve line.curve}\r\n     * @see {@link https://github.com/d3/d3-shape/blob/master/README.md#area_curve area.curve}\r\n     * @param  {d3.curve} [curve=d3.curveLinear]\r\n     * @returns {d3.curve|dc.lineChart}\r\n     */\n    _chart.curve = function (curve) {\n        if (!arguments.length) {\n            return _curve;\n        }\n        _curve = curve;\n        return _chart;\n    };\n\n    /**\r\n     * Gets or sets the interpolator to use for lines drawn, by string name, allowing e.g. step\r\n     * functions, splines, and cubic interpolation.\r\n     *\r\n     * Possible values are: 'linear', 'linear-closed', 'step', 'step-before', 'step-after', 'basis',\r\n     * 'basis-open', 'basis-closed', 'bundle', 'cardinal', 'cardinal-open', 'cardinal-closed', and\r\n     * 'monotone'.\r\n     *\r\n     * This function exists for backward compatibility. Use {@link dc.lineChart#curve}\r\n     * which is generic and provides more options.\r\n     * Value set through `.curve` takes precedence over `.interpolate` and `.tension`.\r\n     * @method interpolate\r\n     * @memberof dc.lineChart\r\n     * @instance\r\n     * @deprecated since version 3.0 use {@link dc.lineChart#curve} instead\r\n     * @see {@link dc.lineChart#curve}\r\n     * @param  {d3.curve} [interpolate=d3.curveLinear]\r\n     * @returns {d3.curve|dc.lineChart}\r\n     */\n    _chart.interpolate = dc.logger.deprecate(function (interpolate) {\n        if (!arguments.length) {\n            return _interpolate;\n        }\n        _interpolate = interpolate;\n        return _chart;\n    }, 'dc.lineChart.interpolate has been deprecated since version 3.0 use dc.lineChart.curve instead');\n\n    /**\r\n     * Gets or sets the tension to use for lines drawn, in the range 0 to 1.\r\n     *\r\n     * Passed to the {@link https://github.com/d3/d3-shape/blob/master/README.md#curves d3 curve function}\r\n     * if it provides a `.tension` function. Example:\r\n     * {@link https://github.com/d3/d3-shape/blob/master/README.md#curveCardinal_tension curveCardinal.tension}.\r\n     *\r\n     * This function exists for backward compatibility. Use {@link dc.lineChart#curve}\r\n     * which is generic and provides more options.\r\n     * Value set through `.curve` takes precedence over `.interpolate` and `.tension`.\r\n     * @method tension\r\n     * @memberof dc.lineChart\r\n     * @instance\r\n     * @deprecated since version 3.0 use {@link dc.lineChart#curve} instead\r\n     * @see {@link dc.lineChart#curve}\r\n     * @param  {Number} [tension=0]\r\n     * @returns {Number|dc.lineChart}\r\n     */\n    _chart.tension = dc.logger.deprecate(function (tension) {\n        if (!arguments.length) {\n            return _tension;\n        }\n        _tension = tension;\n        return _chart;\n    }, 'dc.lineChart.tension has been deprecated since version 3.0 use dc.lineChart.curve instead');\n\n    /**\r\n     * Gets or sets a function that will determine discontinuities in the line which should be\r\n     * skipped: the path will be broken into separate subpaths if some points are undefined.\r\n     * This function is passed to\r\n     * {@link https://github.com/d3/d3-shape/blob/master/README.md#line_defined line.defined}\r\n     *\r\n     * Note: crossfilter will sometimes coerce nulls to 0, so you may need to carefully write\r\n     * custom reduce functions to get this to work, depending on your data. See\r\n     * {@link https://github.com/dc-js/dc.js/issues/615#issuecomment-49089248 this GitHub comment}\r\n     * for more details and an example.\r\n     * @method defined\r\n     * @memberof dc.lineChart\r\n     * @instance\r\n     * @see {@link https://github.com/d3/d3-shape/blob/master/README.md#line_defined line.defined}\r\n     * @param  {Function} [defined]\r\n     * @returns {Function|dc.lineChart}\r\n     */\n    _chart.defined = function (defined) {\n        if (!arguments.length) {\n            return _defined;\n        }\n        _defined = defined;\n        return _chart;\n    };\n\n    /**\r\n     * Set the line's d3 dashstyle. This value becomes the 'stroke-dasharray' of line. Defaults to empty\r\n     * array (solid line).\r\n     * @method dashStyle\r\n     * @memberof dc.lineChart\r\n     * @instance\r\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dasharray stroke-dasharray}\r\n     * @example\r\n     * // create a Dash Dot Dot Dot\r\n     * chart.dashStyle([3,1,1,1]);\r\n     * @param  {Array<Number>} [dashStyle=[]]\r\n     * @returns {Array<Number>|dc.lineChart}\r\n     */\n    _chart.dashStyle = function (dashStyle) {\n        if (!arguments.length) {\n            return _dashStyle;\n        }\n        _dashStyle = dashStyle;\n        return _chart;\n    };\n\n    /**\r\n     * Get or set render area flag. If the flag is set to true then the chart will render the area\r\n     * beneath each line and the line chart effectively becomes an area chart.\r\n     * @method renderArea\r\n     * @memberof dc.lineChart\r\n     * @instance\r\n     * @param  {Boolean} [renderArea=false]\r\n     * @returns {Boolean|dc.lineChart}\r\n     */\n    _chart.renderArea = function (renderArea) {\n        if (!arguments.length) {\n            return _renderArea;\n        }\n        _renderArea = renderArea;\n        return _chart;\n    };\n\n    function colors(d, i) {\n        return _chart.getColor.call(d, d.values, i);\n    }\n\n    // To keep it backward compatible, this covers multiple cases\n    // See https://github.com/dc-js/dc.js/issues/1376\n    // It will be removed when interpolate and tension are removed.\n    function getCurveFactory() {\n        var curve = null;\n\n        // _curve takes precedence\n        if (_curve) {\n            return _curve;\n        }\n\n        // Approximate the D3v3 behavior\n        if (typeof _interpolate === 'function') {\n            curve = _interpolate;\n        } else {\n            // If _interpolate is string\n            var mapping = {\n                'linear': _d.d3.curveLinear,\n                'linear-closed': _d.d3.curveLinearClosed,\n                'step': _d.d3.curveStep,\n                'step-before': _d.d3.curveStepBefore,\n                'step-after': _d.d3.curveStepAfter,\n                'basis': _d.d3.curveBasis,\n                'basis-open': _d.d3.curveBasisOpen,\n                'basis-closed': _d.d3.curveBasisClosed,\n                'bundle': _d.d3.curveBundle,\n                'cardinal': _d.d3.curveCardinal,\n                'cardinal-open': _d.d3.curveCardinalOpen,\n                'cardinal-closed': _d.d3.curveCardinalClosed,\n                'monotone': _d.d3.curveMonotoneX\n            };\n            curve = mapping[_interpolate];\n        }\n\n        // Default value\n        if (!curve) {\n            curve = _d.d3.curveLinear;\n        }\n\n        if (_tension !== null) {\n            if (typeof curve.tension !== 'function') {\n                dc.logger.warn('tension was specified but the curve/interpolate does not support it.');\n            } else {\n                curve = curve.tension(_tension);\n            }\n        }\n        return curve;\n    }\n\n    function drawLine(layersEnter, layers) {\n        var line = _d.d3.line().x(function (d) {\n            return _chart.x()(d.x);\n        }).y(function (d) {\n            return _chart.y()(d.y + d.y0);\n        }).curve(getCurveFactory());\n        if (_defined) {\n            line.defined(_defined);\n        }\n\n        var path = layersEnter.append('path').attr('class', 'line').attr('stroke', colors);\n        if (_dashStyle) {\n            path.attr('stroke-dasharray', _dashStyle);\n        }\n\n        dc.transition(layers.select('path.line'), _chart.transitionDuration(), _chart.transitionDelay())\n        //.ease('linear')\n        .attr('stroke', colors).attr('d', function (d) {\n            return safeD(line(d.values));\n        });\n    }\n\n    function drawArea(layersEnter, layers) {\n        if (_renderArea) {\n            var area = _d.d3.area().x(function (d) {\n                return _chart.x()(d.x);\n            }).y1(function (d) {\n                return _chart.y()(d.y + d.y0);\n            }).y0(function (d) {\n                return _chart.y()(d.y0);\n            }).curve(getCurveFactory());\n            if (_defined) {\n                area.defined(_defined);\n            }\n\n            layersEnter.append('path').attr('class', 'area').attr('fill', colors).attr('d', function (d) {\n                return safeD(area(d.values));\n            });\n\n            dc.transition(layers.select('path.area'), _chart.transitionDuration(), _chart.transitionDelay())\n            //.ease('linear')\n            .attr('fill', colors).attr('d', function (d) {\n                return safeD(area(d.values));\n            });\n        }\n    }\n\n    function safeD(d) {\n        return !d || d.indexOf('NaN') >= 0 ? 'M0,0' : d;\n    }\n\n    function drawDots(chartBody, layers) {\n        if (_chart.xyTipsOn() === 'always' || !(_chart.brushOn() || _chart.parentBrushOn()) && _chart.xyTipsOn()) {\n            var tooltipListClass = TOOLTIP_G_CLASS + '-list';\n            var tooltips = chartBody.select('g.' + tooltipListClass);\n\n            if (tooltips.empty()) {\n                tooltips = chartBody.append('g').attr('class', tooltipListClass);\n            }\n\n            layers.each(function (d, layerIndex) {\n                var points = d.values;\n                if (_defined) {\n                    points = points.filter(_defined);\n                }\n\n                var g = tooltips.select('g.' + TOOLTIP_G_CLASS + '._' + layerIndex);\n                if (g.empty()) {\n                    g = tooltips.append('g').attr('class', TOOLTIP_G_CLASS + ' _' + layerIndex);\n                }\n\n                createRefLines(g);\n\n                var dots = g.selectAll('circle.' + DOT_CIRCLE_CLASS).data(points, dc.pluck('x'));\n\n                var dotsEnterModify = dots.enter().append('circle').attr('class', DOT_CIRCLE_CLASS).attr('cx', function (d) {\n                    return dc.utils.safeNumber(_chart.x()(d.x));\n                }).attr('cy', function (d) {\n                    return dc.utils.safeNumber(_chart.y()(d.y + d.y0));\n                }).attr('r', getDotRadius()).style('fill-opacity', _dataPointFillOpacity).style('stroke-opacity', _dataPointStrokeOpacity).attr('fill', _chart.getColor).attr('stroke', _chart.getColor).on('mousemove', function () {\n                    var dot = _d.d3.select(this);\n                    showDot(dot);\n                    showRefLines(dot, g);\n                }).on('mouseout', function () {\n                    var dot = _d.d3.select(this);\n                    hideDot(dot);\n                    hideRefLines(g);\n                }).merge(dots);\n\n                dotsEnterModify.call(renderTitle, d);\n\n                dc.transition(dotsEnterModify, _chart.transitionDuration()).attr('cx', function (d) {\n                    return dc.utils.safeNumber(_chart.x()(d.x));\n                }).attr('cy', function (d) {\n                    return dc.utils.safeNumber(_chart.y()(d.y + d.y0));\n                }).attr('fill', _chart.getColor);\n\n                dots.exit().remove();\n            });\n        }\n    }\n\n    _chart.label(function (d) {\n        return dc.utils.printSingleValue(d.y0 + d.y);\n    }, false);\n\n    function drawLabels(layers) {\n        layers.each(function (d, layerIndex) {\n            var layer = _d.d3.select(this);\n            var labels = layer.selectAll('text.lineLabel').data(d.values, dc.pluck('x'));\n\n            var labelsEnterModify = labels.enter().append('text').attr('class', 'lineLabel').attr('text-anchor', 'middle').merge(labels);\n\n            dc.transition(labelsEnterModify, _chart.transitionDuration()).attr('x', function (d) {\n                return dc.utils.safeNumber(_chart.x()(d.x));\n            }).attr('y', function (d) {\n                var y = _chart.y()(d.y + d.y0) - LABEL_PADDING;\n                return dc.utils.safeNumber(y);\n            }).text(function (d) {\n                return _chart.label()(d);\n            });\n\n            dc.transition(labels.exit(), _chart.transitionDuration()).attr('height', 0).remove();\n        });\n    }\n\n    function createRefLines(g) {\n        var yRefLine = g.select('path.' + Y_AXIS_REF_LINE_CLASS).empty() ? g.append('path').attr('class', Y_AXIS_REF_LINE_CLASS) : g.select('path.' + Y_AXIS_REF_LINE_CLASS);\n        yRefLine.style('display', 'none').attr('stroke-dasharray', '5,5');\n\n        var xRefLine = g.select('path.' + X_AXIS_REF_LINE_CLASS).empty() ? g.append('path').attr('class', X_AXIS_REF_LINE_CLASS) : g.select('path.' + X_AXIS_REF_LINE_CLASS);\n        xRefLine.style('display', 'none').attr('stroke-dasharray', '5,5');\n    }\n\n    function showDot(dot) {\n        dot.style('fill-opacity', 0.8);\n        dot.style('stroke-opacity', 0.8);\n        dot.attr('r', _dotRadius);\n        return dot;\n    }\n\n    function showRefLines(dot, g) {\n        var x = dot.attr('cx');\n        var y = dot.attr('cy');\n        var yAxisX = _chart._yAxisX() - _chart.margins().left;\n        var yAxisRefPathD = 'M' + yAxisX + ' ' + y + 'L' + x + ' ' + y;\n        var xAxisRefPathD = 'M' + x + ' ' + _chart.yAxisHeight() + 'L' + x + ' ' + y;\n        g.select('path.' + Y_AXIS_REF_LINE_CLASS).style('display', '').attr('d', yAxisRefPathD);\n        g.select('path.' + X_AXIS_REF_LINE_CLASS).style('display', '').attr('d', xAxisRefPathD);\n    }\n\n    function getDotRadius() {\n        return _dataPointRadius || _dotRadius;\n    }\n\n    function hideDot(dot) {\n        dot.style('fill-opacity', _dataPointFillOpacity).style('stroke-opacity', _dataPointStrokeOpacity).attr('r', getDotRadius());\n    }\n\n    function hideRefLines(g) {\n        g.select('path.' + Y_AXIS_REF_LINE_CLASS).style('display', 'none');\n        g.select('path.' + X_AXIS_REF_LINE_CLASS).style('display', 'none');\n    }\n\n    function renderTitle(dot, d) {\n        if (_chart.renderTitle()) {\n            dot.select('title').remove();\n            dot.append('title').text(dc.pluck('data', _chart.title(d.name)));\n        }\n    }\n\n    /**\r\n     * Turn on/off the mouseover behavior of an individual data point which renders a circle and x/y axis\r\n     * dashed lines back to each respective axis.  This is ignored if the chart\r\n     * {@link dc.coordinateGridMixin#brushOn brush} is on\r\n     * @method xyTipsOn\r\n     * @memberof dc.lineChart\r\n     * @instance\r\n     * @param  {Boolean} [xyTipsOn=false]\r\n     * @returns {Boolean|dc.lineChart}\r\n     */\n    _chart.xyTipsOn = function (xyTipsOn) {\n        if (!arguments.length) {\n            return _xyTipsOn;\n        }\n        _xyTipsOn = xyTipsOn;\n        return _chart;\n    };\n\n    /**\r\n     * Get or set the radius (in px) for dots displayed on the data points.\r\n     * @method dotRadius\r\n     * @memberof dc.lineChart\r\n     * @instance\r\n     * @param  {Number} [dotRadius=5]\r\n     * @returns {Number|dc.lineChart}\r\n     */\n    _chart.dotRadius = function (dotRadius) {\n        if (!arguments.length) {\n            return _dotRadius;\n        }\n        _dotRadius = dotRadius;\n        return _chart;\n    };\n\n    /**\r\n     * Always show individual dots for each datapoint.\r\n     *\r\n     * If `options` is falsy, it disables data point rendering. If no `options` are provided, the\r\n     * current `options` values are instead returned.\r\n     * @method renderDataPoints\r\n     * @memberof dc.lineChart\r\n     * @instance\r\n     * @example\r\n     * chart.renderDataPoints({radius: 2, fillOpacity: 0.8, strokeOpacity: 0.0})\r\n     * @param  {{fillOpacity: Number, strokeOpacity: Number, radius: Number}} [options={fillOpacity: 0.8, strokeOpacity: 0.0, radius: 2}]\r\n     * @returns {{fillOpacity: Number, strokeOpacity: Number, radius: Number}|dc.lineChart}\r\n     */\n    _chart.renderDataPoints = function (options) {\n        if (!arguments.length) {\n            return {\n                fillOpacity: _dataPointFillOpacity,\n                strokeOpacity: _dataPointStrokeOpacity,\n                radius: _dataPointRadius\n            };\n        } else if (!options) {\n            _dataPointFillOpacity = DEFAULT_DOT_OPACITY;\n            _dataPointStrokeOpacity = DEFAULT_DOT_OPACITY;\n            _dataPointRadius = null;\n        } else {\n            _dataPointFillOpacity = options.fillOpacity || 0.8;\n            _dataPointStrokeOpacity = options.strokeOpacity || 0.0;\n            _dataPointRadius = options.radius || 2;\n        }\n        return _chart;\n    };\n\n    function colorFilter(color, dashstyle, inv) {\n        return function () {\n            var item = _d.d3.select(this);\n            var match = item.attr('stroke') === color && item.attr('stroke-dasharray') === (dashstyle instanceof Array ? dashstyle.join(',') : null) || item.attr('fill') === color;\n            return inv ? !match : match;\n        };\n    }\n\n    _chart.legendHighlight = function (d) {\n        if (!_chart.isLegendableHidden(d)) {\n            _chart.g().selectAll('path.line, path.area').classed('highlight', colorFilter(d.color, d.dashstyle)).classed('fadeout', colorFilter(d.color, d.dashstyle, true));\n        }\n    };\n\n    _chart.legendReset = function () {\n        _chart.g().selectAll('path.line, path.area').classed('highlight', false).classed('fadeout', false);\n    };\n\n    dc.override(_chart, 'legendables', function () {\n        var legendables = _chart._legendables();\n        if (!_dashStyle) {\n            return legendables;\n        }\n        return legendables.map(function (l) {\n            l.dashstyle = _dashStyle;\n            return l;\n        });\n    });\n\n    return _chart.anchor(parent, chartGroup);\n};\n\n/**\r\n * The data count widget is a simple widget designed to display the number of records selected by the\r\n * current filters out of the total number of records in the data set. Once created the data count widget\r\n * will automatically update the text content of child elements with the following classes:\r\n *\r\n * * `.total-count` - total number of records\r\n * * `.filter-count` - number of records matched by the current filters\r\n *\r\n * Note: this widget works best for the specific case of showing the number of records out of a\r\n * total. If you want a more general-purpose numeric display, please use the\r\n * {@link dc.numberDisplay} widget instead.\r\n *\r\n * Examples:\r\n * - {@link http://dc-js.github.com/dc.js/ Nasdaq 100 Index}\r\n * @class dataCount\r\n * @memberof dc\r\n * @mixes dc.baseMixin\r\n * @example\r\n * var ndx = crossfilter(data);\r\n * var all = ndx.groupAll();\r\n *\r\n * dc.dataCount('.dc-data-count')\r\n *     .dimension(ndx)\r\n *     .group(all);\r\n * @param {String|node|d3.selection} parent - Any valid\r\n * {@link https://github.com/d3/d3-selection/blob/master/README.md#select d3 single selector} specifying\r\n * a dom block element such as a div; or a dom element or d3 selection.\r\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\r\n * Interaction with a chart will only trigger events and redraws within the chart's group.\r\n * @returns {dc.dataCount}\r\n */\ndc.dataCount = function (parent, chartGroup) {\n    var _formatNumber = _d.d3.format(',d');\n    var _chart = dc.baseMixin({});\n    var _html = { some: '', all: '' };\n\n    /**\r\n     * Gets or sets an optional object specifying HTML templates to use depending how many items are\r\n     * selected. The text `%total-count` will replaced with the total number of records, and the text\r\n     * `%filter-count` will be replaced with the number of selected records.\r\n     * - all: HTML template to use if all items are selected\r\n     * - some: HTML template to use if not all items are selected\r\n     * @method html\r\n     * @memberof dc.dataCount\r\n     * @instance\r\n     * @example\r\n     * counter.html({\r\n     *      some: '%filter-count out of %total-count records selected',\r\n     *      all: 'All records selected. Click on charts to apply filters'\r\n     * })\r\n     * @param {{some:String, all: String}} [options]\r\n     * @returns {{some:String, all: String}|dc.dataCount}\r\n     */\n    _chart.html = function (options) {\n        if (!arguments.length) {\n            return _html;\n        }\n        if (options.all) {\n            _html.all = options.all;\n        }\n        if (options.some) {\n            _html.some = options.some;\n        }\n        return _chart;\n    };\n\n    /**\r\n     * Gets or sets an optional function to format the filter count and total count.\r\n     * @method formatNumber\r\n     * @memberof dc.dataCount\r\n     * @instance\r\n     * @see {@link https://github.com/d3/d3-format/blob/master/README.md#format d3.format}\r\n     * @example\r\n     * counter.formatNumber(d3.format('.2g'))\r\n     * @param {Function} [formatter=d3.format('.2g')]\r\n     * @returns {Function|dc.dataCount}\r\n     */\n    _chart.formatNumber = function (formatter) {\n        if (!arguments.length) {\n            return _formatNumber;\n        }\n        _formatNumber = formatter;\n        return _chart;\n    };\n\n    _chart._doRender = function () {\n        var tot = _chart.dimension().size(),\n            val = _chart.group().value();\n        var all = _formatNumber(tot);\n        var selected = _formatNumber(val);\n\n        if (tot === val && _html.all !== '') {\n            _chart.root().html(_html.all.replace('%total-count', all).replace('%filter-count', selected));\n        } else if (_html.some !== '') {\n            _chart.root().html(_html.some.replace('%total-count', all).replace('%filter-count', selected));\n        } else {\n            _chart.selectAll('.total-count').text(all);\n            _chart.selectAll('.filter-count').text(selected);\n        }\n        return _chart;\n    };\n\n    _chart._doRedraw = function () {\n        return _chart._doRender();\n    };\n\n    return _chart.anchor(parent, chartGroup);\n};\n\n/**\r\n * The data table is a simple widget designed to list crossfilter focused data set (rows being\r\n * filtered) in a good old tabular fashion.\r\n *\r\n * Note: Unlike other charts, the data table (and data grid chart) use the {@link dc.dataTable#group group} attribute as a\r\n * keying function for {@link https://github.com/d3/d3-collection/blob/master/README.md#nest nesting} the data\r\n * together in groups.  Do not pass in a crossfilter group as this will not work.\r\n *\r\n * Another interesting feature of the data table is that you can pass a crossfilter group to the `dimension`, as\r\n * long as you specify the {@link dc.dataTable#order order} as `d3.descending`, since the data\r\n * table will use `dimension.top()` to fetch the data in that case, and the method is equally\r\n * supported on the crossfilter group as the crossfilter dimension.\r\n *\r\n * Examples:\r\n * - {@link http://dc-js.github.com/dc.js/ Nasdaq 100 Index}\r\n * - {@link http://dc-js.github.io/dc.js/examples/table-on-aggregated-data.html dataTable on a crossfilter group}\r\n * ({@link https://github.com/dc-js/dc.js/blob/develop/web/examples/table-on-aggregated-data.html source})\r\n * @class dataTable\r\n * @memberof dc\r\n * @mixes dc.baseMixin\r\n * @param {String|node|d3.selection} parent - Any valid\r\n * {@link https://github.com/d3/d3-selection/blob/master/README.md#select d3 single selector} specifying\r\n * a dom block element such as a div; or a dom element or d3 selection.\r\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\r\n * Interaction with a chart will only trigger events and redraws within the chart's group.\r\n * @returns {dc.dataTable}\r\n */\ndc.dataTable = function (parent, chartGroup) {\n    var LABEL_CSS_CLASS = 'dc-table-label';\n    var ROW_CSS_CLASS = 'dc-table-row';\n    var COLUMN_CSS_CLASS = 'dc-table-column';\n    var GROUP_CSS_CLASS = 'dc-table-group';\n    var HEAD_CSS_CLASS = 'dc-table-head';\n\n    var _chart = dc.baseMixin({});\n\n    var _size = 25;\n    var _columns = [];\n    var _sortBy = function _sortBy(d) {\n        return d;\n    };\n    var _order = _d.d3.ascending;\n    var _beginSlice = 0;\n    var _endSlice;\n    var _showGroups = true;\n\n    _chart._doRender = function () {\n        _chart.selectAll('tbody').remove();\n\n        renderRows(renderGroups());\n\n        return _chart;\n    };\n\n    _chart._doColumnValueFormat = function (v, d) {\n        return typeof v === 'function' ? v(d) : // v as function\n        typeof v === 'string' ? d[v] : // v is field name string\n        v.format(d) // v is Object, use fn (element 2)\n        ;\n    };\n\n    _chart._doColumnHeaderFormat = function (d) {\n        // if 'function', convert to string representation\n        // show a string capitalized\n        // if an object then display its label string as-is.\n        return typeof d === 'function' ? _chart._doColumnHeaderFnToString(d) : typeof d === 'string' ? _chart._doColumnHeaderCapitalize(d) : String(d.label);\n    };\n\n    _chart._doColumnHeaderCapitalize = function (s) {\n        // capitalize\n        return s.charAt(0).toUpperCase() + s.slice(1);\n    };\n\n    _chart._doColumnHeaderFnToString = function (f) {\n        // columnString(f) {\n        var s = String(f);\n        var i1 = s.indexOf('return ');\n        if (i1 >= 0) {\n            var i2 = s.lastIndexOf(';');\n            if (i2 >= 0) {\n                s = s.substring(i1 + 7, i2);\n                var i3 = s.indexOf('numberFormat');\n                if (i3 >= 0) {\n                    s = s.replace('numberFormat', '');\n                }\n            }\n        }\n        return s;\n    };\n\n    function renderGroups() {\n        // The 'original' example uses all 'functions'.\n        // If all 'functions' are used, then don't remove/add a header, and leave\n        // the html alone. This preserves the functionality of earlier releases.\n        // A 2nd option is a string representing a field in the data.\n        // A third option is to supply an Object such as an array of 'information', and\n        // supply your own _doColumnHeaderFormat and _doColumnValueFormat functions to\n        // create what you need.\n        var bAllFunctions = true;\n        _columns.forEach(function (f) {\n            bAllFunctions = bAllFunctions & typeof f === 'function';\n        });\n\n        if (!bAllFunctions) {\n            // ensure one thead\n            var thead = _chart.selectAll('thead').data([0]);\n            thead.exit().remove();\n            thead = thead.enter().append('thead').merge(thead);\n\n            // with one tr\n            var headrow = thead.selectAll('tr').data([0]);\n            headrow.exit().remove();\n            headrow = headrow.enter().append('tr').merge(headrow);\n\n            // with a th for each column\n            var headcols = headrow.selectAll('th').data(_columns);\n            headcols.exit().remove();\n            headcols.enter().append('th').merge(headcols).attr('class', HEAD_CSS_CLASS).html(function (d) {\n                return _chart._doColumnHeaderFormat(d);\n            });\n        }\n\n        var groups = _chart.root().selectAll('tbody').data(nestEntries(), function (d) {\n            return _chart.keyAccessor()(d);\n        });\n\n        var rowGroup = groups.enter().append('tbody');\n\n        if (_showGroups === true) {\n            rowGroup.append('tr').attr('class', GROUP_CSS_CLASS).append('td').attr('class', LABEL_CSS_CLASS).attr('colspan', _columns.length).html(function (d) {\n                return _chart.keyAccessor()(d);\n            });\n        }\n\n        groups.exit().remove();\n\n        return rowGroup;\n    }\n\n    function nestEntries() {\n        var entries;\n        if (_order === _d.d3.ascending) {\n            entries = _chart.dimension().bottom(_size);\n        } else {\n            entries = _chart.dimension().top(_size);\n        }\n\n        return _d.d3.nest().key(_chart.group()).sortKeys(_order).entries(entries.sort(function (a, b) {\n            return _order(_sortBy(a), _sortBy(b));\n        }).slice(_beginSlice, _endSlice));\n    }\n\n    function renderRows(groups) {\n        var rows = groups.order().selectAll('tr.' + ROW_CSS_CLASS).data(function (d) {\n            return d.values;\n        });\n\n        var rowEnter = rows.enter().append('tr').attr('class', ROW_CSS_CLASS);\n\n        _columns.forEach(function (v, i) {\n            rowEnter.append('td').attr('class', COLUMN_CSS_CLASS + ' _' + i).html(function (d) {\n                return _chart._doColumnValueFormat(v, d);\n            });\n        });\n\n        rows.exit().remove();\n\n        return rows;\n    }\n\n    _chart._doRedraw = function () {\n        return _chart._doRender();\n    };\n\n    /**\r\n     * Get or set the group function for the data table. The group function takes a data row and\r\n     * returns the key to specify to {@link https://github.com/d3/d3-collection/blob/master/README.md#nest d3.nest}\r\n     * to split rows into groups.\r\n     *\r\n     * Do not pass in a crossfilter group as this will not work.\r\n     * @method group\r\n     * @memberof dc.dataTable\r\n     * @instance\r\n     * @example\r\n     * // group rows by the value of their field\r\n     * chart\r\n     *     .group(function(d) { return d.field; })\r\n     * @param {Function} groupFunction Function taking a row of data and returning the nest key.\r\n     * @returns {Function|dc.dataTable}\r\n     */\n\n    /**\r\n     * Get or set the table size which determines the number of rows displayed by the widget.\r\n     * @method size\r\n     * @memberof dc.dataTable\r\n     * @instance\r\n     * @param {Number} [size=25]\r\n     * @returns {Number|dc.dataTable}\r\n     */\n    _chart.size = function (size) {\n        if (!arguments.length) {\n            return _size;\n        }\n        _size = size;\n        return _chart;\n    };\n\n    /**\r\n     * Get or set the index of the beginning slice which determines which entries get displayed\r\n     * by the widget. Useful when implementing pagination.\r\n     *\r\n     * Note: the sortBy function will determine how the rows are ordered for pagination purposes.\r\n       * See the {@link http://dc-js.github.io/dc.js/examples/table-pagination.html table pagination example}\r\n     * to see how to implement the pagination user interface using `beginSlice` and `endSlice`.\r\n     * @method beginSlice\r\n     * @memberof dc.dataTable\r\n     * @instance\r\n     * @param {Number} [beginSlice=0]\r\n     * @returns {Number|dc.dataTable}\r\n     */\n    _chart.beginSlice = function (beginSlice) {\n        if (!arguments.length) {\n            return _beginSlice;\n        }\n        _beginSlice = beginSlice;\n        return _chart;\n    };\n\n    /**\r\n     * Get or set the index of the end slice which determines which entries get displayed by the\r\n     * widget. Useful when implementing pagination. See {@link dc.dataTable#beginSlice `beginSlice`} for more information.\r\n     * @method endSlice\r\n     * @memberof dc.dataTable\r\n     * @instance\r\n     * @param {Number|undefined} [endSlice=undefined]\r\n     * @returns {Number|dc.dataTable}\r\n     */\n    _chart.endSlice = function (endSlice) {\n        if (!arguments.length) {\n            return _endSlice;\n        }\n        _endSlice = endSlice;\n        return _chart;\n    };\n\n    /**\r\n     * Get or set column functions. The data table widget supports several methods of specifying the\r\n     * columns to display.\r\n     *\r\n     * The original method uses an array of functions to generate dynamic columns. Column functions\r\n     * are simple javascript functions with only one input argument `d` which represents a row in\r\n     * the data set. The return value of these functions will be used to generate the content for\r\n     * each cell. However, this method requires the HTML for the table to have a fixed set of column\r\n     * headers.\r\n     *\r\n     * <pre><code>chart.columns([\r\n     *     function(d) { return d.date; },\r\n     *     function(d) { return d.open; },\r\n     *     function(d) { return d.close; },\r\n     *     function(d) { return numberFormat(d.close - d.open); },\r\n     *     function(d) { return d.volume; }\r\n     * ]);\r\n     * </code></pre>\r\n     *\r\n     * In the second method, you can list the columns to read from the data without specifying it as\r\n     * a function, except where necessary (ie, computed columns).  Note the data element name is\r\n     * capitalized when displayed in the table header. You can also mix in functions as necessary,\r\n     * using the third `{label, format}` form, as shown below.\r\n     *\r\n     * <pre><code>chart.columns([\r\n     *     \"date\",    // d[\"date\"], ie, a field accessor; capitalized automatically\r\n     *     \"open\",    // ...\r\n     *     \"close\",   // ...\r\n     *     {\r\n     *         label: \"Change\",\r\n     *         format: function (d) {\r\n     *             return numberFormat(d.close - d.open);\r\n     *         }\r\n     *     },\r\n     *     \"volume\"   // d[\"volume\"], ie, a field accessor; capitalized automatically\r\n     * ]);\r\n     * </code></pre>\r\n     *\r\n     * In the third example, we specify all fields using the `{label, format}` method:\r\n     * <pre><code>chart.columns([\r\n     *     {\r\n     *         label: \"Date\",\r\n     *         format: function (d) { return d.date; }\r\n     *     },\r\n     *     {\r\n     *         label: \"Open\",\r\n     *         format: function (d) { return numberFormat(d.open); }\r\n     *     },\r\n     *     {\r\n     *         label: \"Close\",\r\n     *         format: function (d) { return numberFormat(d.close); }\r\n     *     },\r\n     *     {\r\n     *         label: \"Change\",\r\n     *         format: function (d) { return numberFormat(d.close - d.open); }\r\n     *     },\r\n     *     {\r\n     *         label: \"Volume\",\r\n     *         format: function (d) { return d.volume; }\r\n     *     }\r\n     * ]);\r\n     * </code></pre>\r\n     *\r\n     * You may wish to override the dataTable functions `_doColumnHeaderCapitalize` and\r\n     * `_doColumnHeaderFnToString`, which are used internally to translate the column information or\r\n     * function into a displayed header. The first one is used on the \"string\" column specifier; the\r\n     * second is used to transform a stringified function into something displayable. For the Stock\r\n     * example, the function for Change becomes the table header **d.close - d.open**.\r\n     *\r\n     * Finally, you can even specify a completely different form of column definition. To do this,\r\n     * override `_chart._doColumnHeaderFormat` and `_chart._doColumnValueFormat` Be aware that\r\n     * fields without numberFormat specification will be displayed just as they are stored in the\r\n     * data, unformatted.\r\n     * @method columns\r\n     * @memberof dc.dataTable\r\n     * @instance\r\n     * @param {Array<Function>} [columns=[]]\r\n     * @returns {Array<Function>}|dc.dataTable}\r\n     */\n    _chart.columns = function (columns) {\n        if (!arguments.length) {\n            return _columns;\n        }\n        _columns = columns;\n        return _chart;\n    };\n\n    /**\r\n     * Get or set sort-by function. This function works as a value accessor at row level and returns a\r\n     * particular field to be sorted by.\r\n     * @method sortBy\r\n     * @memberof dc.dataTable\r\n     * @instance\r\n     * @example\r\n     * chart.sortBy(function(d) {\r\n     *     return d.date;\r\n     * });\r\n     * @param {Function} [sortBy=identity function]\r\n     * @returns {Function|dc.dataTable}\r\n     */\n    _chart.sortBy = function (sortBy) {\n        if (!arguments.length) {\n            return _sortBy;\n        }\n        _sortBy = sortBy;\n        return _chart;\n    };\n\n    /**\r\n     * Get or set sort order. If the order is `d3.ascending`, the data table will use\r\n     * `dimension().bottom()` to fetch the data; otherwise it will use `dimension().top()`\r\n     * @method order\r\n     * @memberof dc.dataTable\r\n     * @instance\r\n     * @see {@link https://github.com/d3/d3-array/blob/master/README.md#ascending d3.ascending}\r\n     * @see {@link https://github.com/d3/d3-array/blob/master/README.md#descending d3.descending}\r\n     * @example\r\n     * chart.order(d3.descending);\r\n     * @param {Function} [order=d3.ascending]\r\n     * @returns {Function|dc.dataTable}\r\n     */\n    _chart.order = function (order) {\n        if (!arguments.length) {\n            return _order;\n        }\n        _order = order;\n        return _chart;\n    };\n\n    /**\r\n     * Get or set if group rows will be shown. The dataTable {@link dc.dataTable#group group}\r\n     * function must be specified even if groups are not shown.\r\n     * @method showGroups\r\n     * @memberof dc.dataTable\r\n     * @instance\r\n     * @example\r\n     * chart\r\n     *     .group([value], [name])\r\n     *     .showGroups(true|false);\r\n     * @param {Boolean} [showGroups=true]\r\n     * @returns {Boolean|dc.dataTable}\r\n     */\n    _chart.showGroups = function (showGroups) {\n        if (!arguments.length) {\n            return _showGroups;\n        }\n        _showGroups = showGroups;\n        return _chart;\n    };\n\n    return _chart.anchor(parent, chartGroup);\n};\n\n/**\r\n * Data grid is a simple widget designed to list the filtered records, providing\r\n * a simple way to define how the items are displayed.\r\n *\r\n * Note: Unlike other charts, the data grid chart (and data table) use the {@link dc.dataGrid#group group} attribute as a keying function\r\n * for {@link https://github.com/d3/d3-collection/blob/master/README.md#nest nesting} the data together in groups.\r\n * Do not pass in a crossfilter group as this will not work.\r\n *\r\n * Examples:\r\n * - {@link http://europarl.me/dc.js/web/ep/index.html List of members of the european parliament}\r\n * @class dataGrid\r\n * @memberof dc\r\n * @mixes dc.baseMixin\r\n * @param {String|node|d3.selection} parent - Any valid\r\n * {@link https://github.com/d3/d3-selection/blob/master/README.md#select d3 single selector} specifying\r\n * a dom block element such as a div; or a dom element or d3 selection.\r\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\r\n * Interaction with a chart will only trigger events and redraws within the chart's group.\r\n * @returns {dc.dataGrid}\r\n */\ndc.dataGrid = function (parent, chartGroup) {\n    var LABEL_CSS_CLASS = 'dc-grid-label';\n    var ITEM_CSS_CLASS = 'dc-grid-item';\n    var GROUP_CSS_CLASS = 'dc-grid-group';\n    var GRID_CSS_CLASS = 'dc-grid-top';\n\n    var _chart = dc.baseMixin({});\n\n    var _size = 999; // shouldn't be needed, but you might\n    var _html = function _html(d) {\n        return 'you need to provide an html() handling param:  ' + JSON.stringify(d);\n    };\n    var _sortBy = function _sortBy(d) {\n        return d;\n    };\n    var _order = _d.d3.ascending;\n    var _beginSlice = 0,\n        _endSlice;\n\n    var _htmlGroup = function _htmlGroup(d) {\n        return '<div class=\\'' + GROUP_CSS_CLASS + '\\'><h1 class=\\'' + LABEL_CSS_CLASS + '\\'>' + _chart.keyAccessor()(d) + '</h1></div>';\n    };\n\n    _chart._doRender = function () {\n        _chart.selectAll('div.' + GRID_CSS_CLASS).remove();\n\n        renderItems(renderGroups());\n\n        return _chart;\n    };\n\n    function renderGroups() {\n        var groups = _chart.root().selectAll('div.' + GRID_CSS_CLASS).data(nestEntries(), function (d) {\n            return _chart.keyAccessor()(d);\n        });\n\n        var itemGroup = groups.enter().append('div').attr('class', GRID_CSS_CLASS);\n\n        if (_htmlGroup) {\n            itemGroup.html(function (d) {\n                return _htmlGroup(d);\n            });\n        }\n\n        groups.exit().remove();\n        return itemGroup;\n    }\n\n    function nestEntries() {\n        var entries = _chart.dimension().top(_size);\n\n        return _d.d3.nest().key(_chart.group()).sortKeys(_order).entries(entries.sort(function (a, b) {\n            return _order(_sortBy(a), _sortBy(b));\n        }).slice(_beginSlice, _endSlice));\n    }\n\n    function renderItems(groups) {\n        var items = groups.order().selectAll('div.' + ITEM_CSS_CLASS).data(function (d) {\n            return d.values;\n        });\n\n        items.exit().remove();\n\n        items = items.enter().append('div').attr('class', ITEM_CSS_CLASS).html(function (d) {\n            return _html(d);\n        }).merge(items);\n\n        return items;\n    }\n\n    _chart._doRedraw = function () {\n        return _chart._doRender();\n    };\n\n    /**\r\n     * Get or set the group function for the data grid. The group function takes a data row and\r\n     * returns the key to specify to {@link https://github.com/d3/d3-collection/blob/master/README.md#nest d3.nest}\r\n     * to split rows into groups.\r\n     *\r\n     * Do not pass in a crossfilter group as this will not work.\r\n     * @method group\r\n     * @memberof dc.dataGrid\r\n     * @instance\r\n     * @example\r\n     * // group rows by the value of their field\r\n     * chart\r\n     *     .group(function(d) { return d.field; })\r\n     * @param {Function} groupFunction Function taking a row of data and returning the nest key.\r\n     * @returns {Function|dc.dataTable}\r\n     */\n\n    /**\r\n     * Get or set the index of the beginning slice which determines which entries get displayed by the widget.\r\n     * Useful when implementing pagination.\r\n     * @method beginSlice\r\n     * @memberof dc.dataGrid\r\n     * @instance\r\n     * @param {Number} [beginSlice=0]\r\n     * @returns {Number|dc.dataGrid}\r\n     */\n    _chart.beginSlice = function (beginSlice) {\n        if (!arguments.length) {\n            return _beginSlice;\n        }\n        _beginSlice = beginSlice;\n        return _chart;\n    };\n\n    /**\r\n     * Get or set the index of the end slice which determines which entries get displayed by the widget.\r\n     * Useful when implementing pagination.\r\n     * @method endSlice\r\n     * @memberof dc.dataGrid\r\n     * @instance\r\n     * @param {Number} [endSlice]\r\n     * @returns {Number|dc.dataGrid}\r\n     */\n    _chart.endSlice = function (endSlice) {\n        if (!arguments.length) {\n            return _endSlice;\n        }\n        _endSlice = endSlice;\n        return _chart;\n    };\n\n    /**\r\n     * Get or set the grid size which determines the number of items displayed by the widget.\r\n     * @method size\r\n     * @memberof dc.dataGrid\r\n     * @instance\r\n     * @param {Number} [size=999]\r\n     * @returns {Number|dc.dataGrid}\r\n     */\n    _chart.size = function (size) {\n        if (!arguments.length) {\n            return _size;\n        }\n        _size = size;\n        return _chart;\n    };\n\n    /**\r\n     * Get or set the function that formats an item. The data grid widget uses a\r\n     * function to generate dynamic html. Use your favourite templating engine or\r\n     * generate the string directly.\r\n     * @method html\r\n     * @memberof dc.dataGrid\r\n     * @instance\r\n     * @example\r\n     * chart.html(function (d) { return '<div class='item '+data.exampleCategory+''>'+data.exampleString+'</div>';});\r\n     * @param {Function} [html]\r\n     * @returns {Function|dc.dataGrid}\r\n     */\n    _chart.html = function (html) {\n        if (!arguments.length) {\n            return _html;\n        }\n        _html = html;\n        return _chart;\n    };\n\n    /**\r\n     * Get or set the function that formats a group label.\r\n     * @method htmlGroup\r\n     * @memberof dc.dataGrid\r\n     * @instance\r\n     * @example\r\n     * chart.htmlGroup (function (d) { return '<h2>'.d.key . 'with ' . d.values.length .' items</h2>'});\r\n     * @param {Function} [htmlGroup]\r\n     * @returns {Function|dc.dataGrid}\r\n     */\n    _chart.htmlGroup = function (htmlGroup) {\n        if (!arguments.length) {\n            return _htmlGroup;\n        }\n        _htmlGroup = htmlGroup;\n        return _chart;\n    };\n\n    /**\r\n     * Get or set sort-by function. This function works as a value accessor at the item\r\n     * level and returns a particular field to be sorted.\r\n     * @method sortBy\r\n     * @memberof dc.dataGrid\r\n     * @instance\r\n     * @example\r\n     * chart.sortBy(function(d) {\r\n     *     return d.date;\r\n     * });\r\n     * @param {Function} [sortByFunction]\r\n     * @returns {Function|dc.dataGrid}\r\n     */\n    _chart.sortBy = function (sortByFunction) {\n        if (!arguments.length) {\n            return _sortBy;\n        }\n        _sortBy = sortByFunction;\n        return _chart;\n    };\n\n    /**\r\n     * Get or set sort the order function.\r\n     * @method order\r\n     * @memberof dc.dataGrid\r\n     * @instance\r\n     * @see {@link https://github.com/d3/d3-array/blob/master/README.md#ascending d3.ascending}\r\n     * @see {@link https://github.com/d3/d3-array/blob/master/README.md#descending d3.descending}\r\n     * @example\r\n     * chart.order(d3.descending);\r\n     * @param {Function} [order=d3.ascending]\r\n     * @returns {Function|dc.dataGrid}\r\n     */\n    _chart.order = function (order) {\n        if (!arguments.length) {\n            return _order;\n        }\n        _order = order;\n        return _chart;\n    };\n\n    return _chart.anchor(parent, chartGroup);\n};\n\n/**\r\n * A concrete implementation of a general purpose bubble chart that allows data visualization using the\r\n * following dimensions:\r\n * - x axis position\r\n * - y axis position\r\n * - bubble radius\r\n * - color\r\n *\r\n * Examples:\r\n * - {@link http://dc-js.github.com/dc.js/ Nasdaq 100 Index}\r\n * - {@link http://dc-js.github.com/dc.js/vc/index.html US Venture Capital Landscape 2011}\r\n * @class bubbleChart\r\n * @memberof dc\r\n * @mixes dc.bubbleMixin\r\n * @mixes dc.coordinateGridMixin\r\n * @example\r\n * // create a bubble chart under #chart-container1 element using the default global chart group\r\n * var bubbleChart1 = dc.bubbleChart('#chart-container1');\r\n * // create a bubble chart under #chart-container2 element using chart group A\r\n * var bubbleChart2 = dc.bubbleChart('#chart-container2', 'chartGroupA');\r\n * @param {String|node|d3.selection} parent - Any valid\r\n * {@link https://github.com/d3/d3-selection/blob/master/README.md#select d3 single selector} specifying\r\n * a dom block element such as a div; or a dom element or d3 selection.\r\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\r\n * Interaction with a chart will only trigger events and redraws within the chart's group.\r\n * @returns {dc.bubbleChart}\r\n */\ndc.bubbleChart = function (parent, chartGroup) {\n    var _chart = dc.bubbleMixin(dc.coordinateGridMixin({}));\n\n    _chart.transitionDuration(750);\n\n    _chart.transitionDelay(0);\n\n    var bubbleLocator = function bubbleLocator(d) {\n        return 'translate(' + bubbleX(d) + ',' + bubbleY(d) + ')';\n    };\n\n    _chart.plotData = function () {\n        _chart.calculateRadiusDomain();\n        _chart.r().range([_chart.MIN_RADIUS, _chart.xAxisLength() * _chart.maxBubbleRelativeSize()]);\n\n        var data = _chart.data();\n        var bubbleG = _chart.chartBodyG().selectAll('g.' + _chart.BUBBLE_NODE_CLASS).data(data, function (d) {\n            return d.key;\n        });\n        if (_chart.sortBubbleSize()) {\n            // update dom order based on sort\n            bubbleG.order();\n        }\n\n        removeNodes(bubbleG);\n\n        bubbleG = renderNodes(bubbleG);\n\n        updateNodes(bubbleG);\n\n        _chart.fadeDeselectedArea(_chart.filter());\n    };\n\n    function renderNodes(bubbleG) {\n        var bubbleGEnter = bubbleG.enter().append('g');\n\n        bubbleGEnter.attr('class', _chart.BUBBLE_NODE_CLASS).attr('transform', bubbleLocator).append('circle').attr('class', function (d, i) {\n            return _chart.BUBBLE_CLASS + ' _' + i;\n        }).on('click', _chart.onClick).attr('fill', _chart.getColor).attr('r', 0);\n\n        bubbleG = bubbleGEnter.merge(bubbleG);\n\n        dc.transition(bubbleG, _chart.transitionDuration(), _chart.transitionDelay()).select('circle.' + _chart.BUBBLE_CLASS).attr('r', function (d) {\n            return _chart.bubbleR(d);\n        }).attr('opacity', function (d) {\n            return _chart.bubbleR(d) > 0 ? 1 : 0;\n        });\n\n        _chart._doRenderLabel(bubbleGEnter);\n\n        _chart._doRenderTitles(bubbleGEnter);\n\n        return bubbleG;\n    }\n\n    function updateNodes(bubbleG) {\n        dc.transition(bubbleG, _chart.transitionDuration(), _chart.transitionDelay()).attr('transform', bubbleLocator).select('circle.' + _chart.BUBBLE_CLASS).attr('fill', _chart.getColor).attr('r', function (d) {\n            return _chart.bubbleR(d);\n        }).attr('opacity', function (d) {\n            return _chart.bubbleR(d) > 0 ? 1 : 0;\n        });\n\n        _chart.doUpdateLabels(bubbleG);\n        _chart.doUpdateTitles(bubbleG);\n    }\n\n    function removeNodes(bubbleG) {\n        bubbleG.exit().remove();\n    }\n\n    function bubbleX(d) {\n        var x = _chart.x()(_chart.keyAccessor()(d));\n        if (isNaN(x) || !isFinite(x)) {\n            x = 0;\n        }\n        return x;\n    }\n\n    function bubbleY(d) {\n        var y = _chart.y()(_chart.valueAccessor()(d));\n        if (isNaN(y) || !isFinite(y)) {\n            y = 0;\n        }\n        return y;\n    }\n\n    _chart.renderBrush = function () {\n        // override default x axis brush from parent chart\n    };\n\n    _chart.redrawBrush = function (brushSelection, doTransition) {\n        // override default x axis brush from parent chart\n        _chart.fadeDeselectedArea(brushSelection);\n    };\n\n    return _chart.anchor(parent, chartGroup);\n};\n\n/**\r\n * Composite charts are a special kind of chart that render multiple charts on the same Coordinate\r\n * Grid. You can overlay (compose) different bar/line/area charts in a single composite chart to\r\n * achieve some quite flexible charting effects.\r\n * @class compositeChart\r\n * @memberof dc\r\n * @mixes dc.coordinateGridMixin\r\n * @example\r\n * // create a composite chart under #chart-container1 element using the default global chart group\r\n * var compositeChart1 = dc.compositeChart('#chart-container1');\r\n * // create a composite chart under #chart-container2 element using chart group A\r\n * var compositeChart2 = dc.compositeChart('#chart-container2', 'chartGroupA');\r\n * @param {String|node|d3.selection} parent - Any valid\r\n * {@link https://github.com/d3/d3-selection/blob/master/README.md#select d3 single selector} specifying\r\n * a dom block element such as a div; or a dom element or d3 selection.\r\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\r\n * Interaction with a chart will only trigger events and redraws within the chart's group.\r\n * @returns {dc.compositeChart}\r\n */\ndc.compositeChart = function (parent, chartGroup) {\n\n    var SUB_CHART_CLASS = 'sub';\n    var DEFAULT_RIGHT_Y_AXIS_LABEL_PADDING = 12;\n\n    var _chart = dc.coordinateGridMixin({});\n    var _children = [];\n\n    var _childOptions = {};\n\n    var _shareColors = false,\n        _shareTitle = true,\n        _alignYAxes = false;\n\n    var _rightYAxis = _d.d3.axisRight(),\n        _rightYAxisLabel = 0,\n        _rightYAxisLabelPadding = DEFAULT_RIGHT_Y_AXIS_LABEL_PADDING,\n        _rightY,\n        _rightAxisGridLines = false;\n\n    _chart._mandatoryAttributes([]);\n    _chart.transitionDuration(500);\n    _chart.transitionDelay(0);\n\n    dc.override(_chart, '_generateG', function () {\n        var g = this.__generateG();\n\n        for (var i = 0; i < _children.length; ++i) {\n            var child = _children[i];\n\n            generateChildG(child, i);\n\n            if (!child.dimension()) {\n                child.dimension(_chart.dimension());\n            }\n            if (!child.group()) {\n                child.group(_chart.group());\n            }\n\n            child.chartGroup(_chart.chartGroup());\n            child.svg(_chart.svg());\n            child.xUnits(_chart.xUnits());\n            child.transitionDuration(_chart.transitionDuration(), _chart.transitionDelay());\n            child.parentBrushOn(_chart.brushOn());\n            child.brushOn(false);\n            child.renderTitle(_chart.renderTitle());\n            child.elasticX(_chart.elasticX());\n        }\n\n        return g;\n    });\n\n    _chart.on('filtered.dcjs-composite-chart', function (chart) {\n        // Propagate the filters onto the children\n        // Notice that on children the call is .replaceFilter and not .filter\n        //   the reason is that _chart.filter() returns the entire current set of filters not just the last added one\n        for (var i = 0; i < _children.length; ++i) {\n            _children[i].replaceFilter(_chart.filter());\n        }\n    });\n\n    _chart._prepareYAxis = function () {\n        var left = leftYAxisChildren().length !== 0;\n        var right = rightYAxisChildren().length !== 0;\n        var ranges = calculateYAxisRanges(left, right);\n\n        if (left) {\n            prepareLeftYAxis(ranges);\n        }\n        if (right) {\n            prepareRightYAxis(ranges);\n        }\n\n        if (leftYAxisChildren().length > 0 && !_rightAxisGridLines) {\n            _chart._renderHorizontalGridLinesForAxis(_chart.g(), _chart.y(), _chart.yAxis());\n        } else if (rightYAxisChildren().length > 0) {\n            _chart._renderHorizontalGridLinesForAxis(_chart.g(), _rightY, _rightYAxis);\n        }\n    };\n\n    _chart.renderYAxis = function () {\n        if (leftYAxisChildren().length !== 0) {\n            _chart.renderYAxisAt('y', _chart.yAxis(), _chart.margins().left);\n            _chart.renderYAxisLabel('y', _chart.yAxisLabel(), -90);\n        }\n\n        if (rightYAxisChildren().length !== 0) {\n            _chart.renderYAxisAt('yr', _chart.rightYAxis(), _chart.width() - _chart.margins().right);\n            _chart.renderYAxisLabel('yr', _chart.rightYAxisLabel(), 90, _chart.width() - _rightYAxisLabelPadding);\n        }\n    };\n\n    function calculateYAxisRanges(left, right) {\n        var lyAxisMin, lyAxisMax, ryAxisMin, ryAxisMax;\n        var ranges;\n\n        if (left) {\n            lyAxisMin = yAxisMin();\n            lyAxisMax = yAxisMax();\n        }\n\n        if (right) {\n            ryAxisMin = rightYAxisMin();\n            ryAxisMax = rightYAxisMax();\n        }\n\n        if (_chart.alignYAxes() && left && right) {\n            ranges = alignYAxisRanges(lyAxisMin, lyAxisMax, ryAxisMin, ryAxisMax);\n        }\n\n        return ranges || {\n            lyAxisMin: lyAxisMin,\n            lyAxisMax: lyAxisMax,\n            ryAxisMin: ryAxisMin,\n            ryAxisMax: ryAxisMax\n        };\n    }\n\n    function alignYAxisRanges(lyAxisMin, lyAxisMax, ryAxisMin, ryAxisMax) {\n        // since the two series will share a zero, each Y is just a multiple\n        // of the other. and the ratio should be the ratio of the ranges of the\n        // input data, so that they come out the same height. so we just min/max\n\n        // note: both ranges already include zero due to the stack mixin (#667)\n        // if #667 changes, we can reconsider whether we want data height or\n        // height from zero to be equal. and it will be possible for the axes\n        // to be aligned but not visible.\n        var extentRatio = (ryAxisMax - ryAxisMin) / (lyAxisMax - lyAxisMin);\n\n        return {\n            lyAxisMin: Math.min(lyAxisMin, ryAxisMin / extentRatio),\n            lyAxisMax: Math.max(lyAxisMax, ryAxisMax / extentRatio),\n            ryAxisMin: Math.min(ryAxisMin, lyAxisMin * extentRatio),\n            ryAxisMax: Math.max(ryAxisMax, lyAxisMax * extentRatio)\n        };\n    }\n\n    function prepareRightYAxis(ranges) {\n        var needDomain = _chart.rightY() === undefined || _chart.elasticY(),\n            needRange = needDomain || _chart.resizing();\n        if (_chart.rightY() === undefined) {\n            _chart.rightY(_d.d3.scaleLinear());\n        }\n        if (needDomain) {\n            _chart.rightY().domain([ranges.ryAxisMin, ranges.ryAxisMax]);\n        }\n        if (needRange) {\n            _chart.rightY().rangeRound([_chart.yAxisHeight(), 0]);\n        }\n\n        _chart.rightY().range([_chart.yAxisHeight(), 0]);\n        _chart.rightYAxis(_chart.rightYAxis().scale(_chart.rightY()));\n\n        // In D3v4 create a RightAxis\n        // _chart.rightYAxis().orient('right');\n    }\n\n    function prepareLeftYAxis(ranges) {\n        var needDomain = _chart.y() === undefined || _chart.elasticY(),\n            needRange = needDomain || _chart.resizing();\n        if (_chart.y() === undefined) {\n            _chart.y(_d.d3.scaleLinear());\n        }\n        if (needDomain) {\n            _chart.y().domain([ranges.lyAxisMin, ranges.lyAxisMax]);\n        }\n        if (needRange) {\n            _chart.y().rangeRound([_chart.yAxisHeight(), 0]);\n        }\n\n        _chart.y().range([_chart.yAxisHeight(), 0]);\n        _chart.yAxis(_chart.yAxis().scale(_chart.y()));\n\n        // In D3v4 create a LeftAxis\n        // _chart.yAxis().orient('left');\n    }\n\n    function generateChildG(child, i) {\n        child._generateG(_chart.g());\n        child.g().attr('class', SUB_CHART_CLASS + ' _' + i);\n    }\n\n    _chart.plotData = function () {\n        for (var i = 0; i < _children.length; ++i) {\n            var child = _children[i];\n\n            if (!child.g()) {\n                generateChildG(child, i);\n            }\n\n            if (_shareColors) {\n                child.colors(_chart.colors());\n            }\n\n            child.x(_chart.x());\n\n            child.xAxis(_chart.xAxis());\n\n            if (child.useRightYAxis()) {\n                child.y(_chart.rightY());\n                child.yAxis(_chart.rightYAxis());\n            } else {\n                child.y(_chart.y());\n                child.yAxis(_chart.yAxis());\n            }\n\n            child.plotData();\n\n            child._activateRenderlets();\n        }\n    };\n\n    /**\r\n     * Get or set whether to draw gridlines from the right y axis.  Drawing from the left y axis is the\r\n     * default behavior. This option is only respected when subcharts with both left and right y-axes\r\n     * are present.\r\n     * @method useRightAxisGridLines\r\n     * @memberof dc.compositeChart\r\n     * @instance\r\n     * @param {Boolean} [useRightAxisGridLines=false]\r\n     * @returns {Boolean|dc.compositeChart}\r\n     */\n    _chart.useRightAxisGridLines = function (useRightAxisGridLines) {\n        if (!arguments) {\n            return _rightAxisGridLines;\n        }\n\n        _rightAxisGridLines = useRightAxisGridLines;\n        return _chart;\n    };\n\n    /**\r\n     * Get or set chart-specific options for all child charts. This is equivalent to calling\r\n     * {@link dc.baseMixin#options .options} on each child chart.\r\n     *\r\n     * Note: currently you must call this before `compose` in order for the options to be propagated.\r\n     * @method childOptions\r\n     * @memberof dc.compositeChart\r\n     * @instance\r\n     * @param {Object} [childOptions]\r\n     * @returns {Object|dc.compositeChart}\r\n     */\n    _chart.childOptions = function (childOptions) {\n        if (!arguments.length) {\n            return _childOptions;\n        }\n        _childOptions = childOptions;\n        _children.forEach(function (child) {\n            child.options(_childOptions);\n        });\n        return _chart;\n    };\n\n    _chart.fadeDeselectedArea = function (brushSelection) {\n        if (_chart.brushOn()) {\n            for (var i = 0; i < _children.length; ++i) {\n                var child = _children[i];\n                child.fadeDeselectedArea(brushSelection);\n            }\n        }\n    };\n\n    /**\r\n     * Set or get the right y axis label.\r\n     * @method rightYAxisLabel\r\n     * @memberof dc.compositeChart\r\n     * @instance\r\n     * @param {String} [rightYAxisLabel]\r\n     * @param {Number} [padding]\r\n     * @returns {String|dc.compositeChart}\r\n     */\n    _chart.rightYAxisLabel = function (rightYAxisLabel, padding) {\n        if (!arguments.length) {\n            return _rightYAxisLabel;\n        }\n        _rightYAxisLabel = rightYAxisLabel;\n        _chart.margins().right -= _rightYAxisLabelPadding;\n        _rightYAxisLabelPadding = padding === undefined ? DEFAULT_RIGHT_Y_AXIS_LABEL_PADDING : padding;\n        _chart.margins().right += _rightYAxisLabelPadding;\n        return _chart;\n    };\n\n    /**\r\n     * Combine the given charts into one single composite coordinate grid chart.\r\n     *\r\n     * Note: currently due to the way it is implemented, you must call this function at the end of\r\n     * initialization of the composite chart, in particular after `shareTitle`, `childOptions`,\r\n     * `width`, `height`, and `margins`, in order for the settings to get propagated to the children\r\n     * correctly.\r\n     * @method compose\r\n     * @memberof dc.compositeChart\r\n     * @instance\r\n     * @example\r\n     * moveChart.compose([\r\n     *     // when creating sub-chart you need to pass in the parent chart\r\n     *     dc.lineChart(moveChart)\r\n     *         .group(indexAvgByMonthGroup) // if group is missing then parent's group will be used\r\n     *         .valueAccessor(function (d){return d.value.avg;})\r\n     *         // most of the normal functions will continue to work in a composed chart\r\n     *         .renderArea(true)\r\n     *         .stack(monthlyMoveGroup, function (d){return d.value;})\r\n     *         .title(function (d){\r\n     *             var value = d.value.avg?d.value.avg:d.value;\r\n     *             if(isNaN(value)) value = 0;\r\n     *             return dateFormat(d.key) + '\\n' + numberFormat(value);\r\n     *         }),\r\n     *     dc.barChart(moveChart)\r\n     *         .group(volumeByMonthGroup)\r\n     *         .centerBar(true)\r\n     * ]);\r\n     * @param {Array<Chart>} [subChartArray]\r\n     * @returns {dc.compositeChart}\r\n     */\n    _chart.compose = function (subChartArray) {\n        _children = subChartArray;\n        _children.forEach(function (child) {\n            child.height(_chart.height());\n            child.width(_chart.width());\n            child.margins(_chart.margins());\n\n            if (_shareTitle) {\n                child.title(_chart.title());\n            }\n\n            child.options(_childOptions);\n        });\n        return _chart;\n    };\n\n    /**\r\n     * Returns the child charts which are composed into the composite chart.\r\n     * @method children\r\n     * @memberof dc.compositeChart\r\n     * @instance\r\n     * @returns {Array<dc.baseMixin>}\r\n     */\n    _chart.children = function () {\n        return _children;\n    };\n\n    /**\r\n     * Get or set color sharing for the chart. If set, the {@link dc.colorMixin#colors .colors()} value from this chart\r\n     * will be shared with composed children. Additionally if the child chart implements\r\n     * Stackable and has not set a custom .colorAccessor, then it will generate a color\r\n     * specific to its order in the composition.\r\n     * @method shareColors\r\n     * @memberof dc.compositeChart\r\n     * @instance\r\n     * @param {Boolean} [shareColors=false]\r\n     * @returns {Boolean|dc.compositeChart}\r\n     */\n    _chart.shareColors = function (shareColors) {\n        if (!arguments.length) {\n            return _shareColors;\n        }\n        _shareColors = shareColors;\n        return _chart;\n    };\n\n    /**\r\n     * Get or set title sharing for the chart. If set, the {@link dc.baseMixin#title .title()} value from\r\n     * this chart will be shared with composed children.\r\n     *\r\n     * Note: currently you must call this before `compose` or the child will still get the parent's\r\n     * `title` function!\r\n     * @method shareTitle\r\n     * @memberof dc.compositeChart\r\n     * @instance\r\n     * @param {Boolean} [shareTitle=true]\r\n     * @returns {Boolean|dc.compositeChart}\r\n     */\n    _chart.shareTitle = function (shareTitle) {\n        if (!arguments.length) {\n            return _shareTitle;\n        }\n        _shareTitle = shareTitle;\n        return _chart;\n    };\n\n    /**\r\n     * Get or set the y scale for the right axis. The right y scale is typically automatically\r\n     * generated by the chart implementation.\r\n     * @method rightY\r\n     * @memberof dc.compositeChart\r\n     * @instance\r\n     * @see {@link https://github.com/d3/d3-scale/blob/master/README.md d3.scale}\r\n     * @param {d3.scale} [yScale]\r\n     * @returns {d3.scale|dc.compositeChart}\r\n     */\n    _chart.rightY = function (yScale) {\n        if (!arguments.length) {\n            return _rightY;\n        }\n        _rightY = yScale;\n        _chart.rescale();\n        return _chart;\n    };\n\n    /**\r\n     * Get or set alignment between left and right y axes. A line connecting '0' on both y axis\r\n     * will be parallel to x axis. This only has effect when {@link #dc.coordinateGridMixin+elasticY elasticY} is true.\r\n     * @method alignYAxes\r\n     * @memberof dc.compositeChart\r\n     * @instance\r\n     * @param {Boolean} [alignYAxes=false]\r\n     * @returns {Chart}\r\n     */\n    _chart.alignYAxes = function (alignYAxes) {\n        if (!arguments.length) {\n            return _alignYAxes;\n        }\n        _alignYAxes = alignYAxes;\n        _chart.rescale();\n        return _chart;\n    };\n\n    function leftYAxisChildren() {\n        return _children.filter(function (child) {\n            return !child.useRightYAxis();\n        });\n    }\n\n    function rightYAxisChildren() {\n        return _children.filter(function (child) {\n            return child.useRightYAxis();\n        });\n    }\n\n    function getYAxisMin(charts) {\n        return charts.map(function (c) {\n            return c.yAxisMin();\n        });\n    }\n\n    delete _chart.yAxisMin;\n    function yAxisMin() {\n        return _d.d3.min(getYAxisMin(leftYAxisChildren()));\n    }\n\n    function rightYAxisMin() {\n        return _d.d3.min(getYAxisMin(rightYAxisChildren()));\n    }\n\n    function getYAxisMax(charts) {\n        return charts.map(function (c) {\n            return c.yAxisMax();\n        });\n    }\n\n    delete _chart.yAxisMax;\n    function yAxisMax() {\n        return dc.utils.add(_d.d3.max(getYAxisMax(leftYAxisChildren())), _chart.yAxisPadding());\n    }\n\n    function rightYAxisMax() {\n        return dc.utils.add(_d.d3.max(getYAxisMax(rightYAxisChildren())), _chart.yAxisPadding());\n    }\n\n    function getAllXAxisMinFromChildCharts() {\n        return _children.map(function (c) {\n            return c.xAxisMin();\n        });\n    }\n\n    dc.override(_chart, 'xAxisMin', function () {\n        return dc.utils.subtract(_d.d3.min(getAllXAxisMinFromChildCharts()), _chart.xAxisPadding(), _chart.xAxisPaddingUnit());\n    });\n\n    function getAllXAxisMaxFromChildCharts() {\n        return _children.map(function (c) {\n            return c.xAxisMax();\n        });\n    }\n\n    dc.override(_chart, 'xAxisMax', function () {\n        return dc.utils.add(_d.d3.max(getAllXAxisMaxFromChildCharts()), _chart.xAxisPadding(), _chart.xAxisPaddingUnit());\n    });\n\n    _chart.legendables = function () {\n        return _children.reduce(function (items, child) {\n            if (_shareColors) {\n                child.colors(_chart.colors());\n            }\n            items.push.apply(items, child.legendables());\n            return items;\n        }, []);\n    };\n\n    _chart.legendHighlight = function (d) {\n        for (var j = 0; j < _children.length; ++j) {\n            var child = _children[j];\n            child.legendHighlight(d);\n        }\n    };\n\n    _chart.legendReset = function (d) {\n        for (var j = 0; j < _children.length; ++j) {\n            var child = _children[j];\n            child.legendReset(d);\n        }\n    };\n\n    _chart.legendToggle = function () {\n        console.log('composite should not be getting legendToggle itself');\n    };\n\n    /**\r\n     * Set or get the right y axis used by the composite chart. This function is most useful when y\r\n     * axis customization is required. The y axis in dc.js is an instance of a\r\n     * [d3.axisRight](https://github.com/d3/d3-axis/blob/master/README.md#axisRight) therefore it supports any valid\r\n     * d3 axis manipulation.\r\n     *\r\n     * **Caution**: The right y axis is usually generated internally by dc; resetting it may cause\r\n     * unexpected results.  Note also that when used as a getter, this function is not chainable: it\r\n     * returns the axis, not the chart,\r\n     * {@link https://github.com/dc-js/dc.js/wiki/FAQ#why-does-everything-break-after-a-call-to-xaxis-or-yaxis\r\n     * so attempting to call chart functions after calling `.yAxis()` will fail}.\r\n     * @method rightYAxis\r\n     * @memberof dc.compositeChart\r\n     * @instance\r\n     * @see {@link https://github.com/d3/d3-axis/blob/master/README.md#axisRight}\r\n     * @example\r\n     * // customize y axis tick format\r\n     * chart.rightYAxis().tickFormat(function (v) {return v + '%';});\r\n     * // customize y axis tick values\r\n     * chart.rightYAxis().tickValues([0, 100, 200, 300]);\r\n     * @param {d3.axisRight} [rightYAxis]\r\n     * @returns {d3.axisRight|dc.compositeChart}\r\n     */\n    _chart.rightYAxis = function (rightYAxis) {\n        if (!arguments.length) {\n            return _rightYAxis;\n        }\n        _rightYAxis = rightYAxis;\n        return _chart;\n    };\n\n    return _chart.anchor(parent, chartGroup);\n};\n\n/**\r\n * A series chart is a chart that shows multiple series of data overlaid on one chart, where the\r\n * series is specified in the data. It is a specialization of Composite Chart and inherits all\r\n * composite features other than recomposing the chart.\r\n *\r\n * Examples:\r\n * - {@link http://dc-js.github.io/dc.js/examples/series.html Series Chart}\r\n * @class seriesChart\r\n * @memberof dc\r\n * @mixes dc.compositeChart\r\n * @example\r\n * // create a series chart under #chart-container1 element using the default global chart group\r\n * var seriesChart1 = dc.seriesChart(\"#chart-container1\");\r\n * // create a series chart under #chart-container2 element using chart group A\r\n * var seriesChart2 = dc.seriesChart(\"#chart-container2\", \"chartGroupA\");\r\n * @param {String|node|d3.selection} parent - Any valid\r\n * {@link https://github.com/d3/d3-selection/blob/master/README.md#select d3 single selector} specifying\r\n * a dom block element such as a div; or a dom element or d3 selection.\r\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\r\n * Interaction with a chart will only trigger events and redraws within the chart's group.\r\n * @returns {dc.seriesChart}\r\n */\ndc.seriesChart = function (parent, chartGroup) {\n    var _chart = dc.compositeChart(parent, chartGroup);\n\n    function keySort(a, b) {\n        return _d.d3.ascending(_chart.keyAccessor()(a), _chart.keyAccessor()(b));\n    }\n\n    var _charts = {};\n    var _chartFunction = dc.lineChart;\n    var _seriesAccessor;\n    var _seriesSort = _d.d3.ascending;\n    var _valueSort = keySort;\n\n    _chart._mandatoryAttributes().push('seriesAccessor', 'chart');\n    _chart.shareColors(true);\n\n    _chart._preprocessData = function () {\n        var keep = [];\n        var childrenChanged;\n        var nester = _d.d3.nest().key(_seriesAccessor);\n        if (_seriesSort) {\n            nester.sortKeys(_seriesSort);\n        }\n        if (_valueSort) {\n            nester.sortValues(_valueSort);\n        }\n        var nesting = nester.entries(_chart.data());\n        var children = nesting.map(function (sub, i) {\n            var subChart = _charts[sub.key] || _chartFunction.call(_chart, _chart, chartGroup, sub.key, i);\n            if (!_charts[sub.key]) {\n                childrenChanged = true;\n            }\n            _charts[sub.key] = subChart;\n            keep.push(sub.key);\n            return subChart.dimension(_chart.dimension()).group({\n                all: typeof sub.values === 'function' ? sub.values : dc.utils.constant(sub.values)\n            }, sub.key).keyAccessor(_chart.keyAccessor()).valueAccessor(_chart.valueAccessor()).brushOn(false);\n        });\n        // this works around the fact compositeChart doesn't really\n        // have a removal interface\n        Object.keys(_charts).filter(function (c) {\n            return keep.indexOf(c) === -1;\n        }).forEach(function (c) {\n            clearChart(c);\n            childrenChanged = true;\n        });\n        _chart._compose(children);\n        if (childrenChanged && _chart.legend()) {\n            _chart.legend().render();\n        }\n    };\n\n    function clearChart(c) {\n        if (_charts[c].g()) {\n            _charts[c].g().remove();\n        }\n        delete _charts[c];\n    }\n\n    function resetChildren() {\n        Object.keys(_charts).map(clearChart);\n        _charts = {};\n    }\n\n    /**\r\n     * Get or set the chart function, which generates the child charts.\r\n     * @method chart\r\n     * @memberof dc.seriesChart\r\n     * @instance\r\n     * @example\r\n     * // put curve on the line charts used for the series\r\n     * chart.chart(function(c) { return dc.lineChart(c).curve(d3.curveBasis); })\r\n     * // do a scatter series chart\r\n     * chart.chart(dc.scatterPlot)\r\n     * @param {Function} [chartFunction=dc.lineChart]\r\n     * @returns {Function|dc.seriesChart}\r\n     */\n    _chart.chart = function (chartFunction) {\n        if (!arguments.length) {\n            return _chartFunction;\n        }\n        _chartFunction = chartFunction;\n        resetChildren();\n        return _chart;\n    };\n\n    /**\r\n     * **mandatory**\r\n     *\r\n     * Get or set accessor function for the displayed series. Given a datum, this function\r\n     * should return the series that datum belongs to.\r\n     * @method seriesAccessor\r\n     * @memberof dc.seriesChart\r\n     * @instance\r\n     * @example\r\n     * // simple series accessor\r\n     * chart.seriesAccessor(function(d) { return \"Expt: \" + d.key[0]; })\r\n     * @param {Function} [accessor]\r\n     * @returns {Function|dc.seriesChart}\r\n     */\n    _chart.seriesAccessor = function (accessor) {\n        if (!arguments.length) {\n            return _seriesAccessor;\n        }\n        _seriesAccessor = accessor;\n        resetChildren();\n        return _chart;\n    };\n\n    /**\r\n     * Get or set a function to sort the list of series by, given series values.\r\n     * @method seriesSort\r\n     * @memberof dc.seriesChart\r\n     * @instance\r\n     * @see {@link https://github.com/d3/d3-array/blob/master/README.md#ascending d3.ascending}\r\n     * @see {@link https://github.com/d3/d3-array/blob/master/README.md#descending d3.descending}\r\n     * @example\r\n     * chart.seriesSort(d3.descending);\r\n     * @param {Function} [sortFunction=d3.ascending]\r\n     * @returns {Function|dc.seriesChart}\r\n     */\n    _chart.seriesSort = function (sortFunction) {\n        if (!arguments.length) {\n            return _seriesSort;\n        }\n        _seriesSort = sortFunction;\n        resetChildren();\n        return _chart;\n    };\n\n    /**\r\n     * Get or set a function to sort each series values by. By default this is the key accessor which,\r\n     * for example, will ensure a lineChart series connects its points in increasing key/x order,\r\n     * rather than haphazardly.\r\n     * @method valueSort\r\n     * @memberof dc.seriesChart\r\n     * @instance\r\n     * @see {@link https://github.com/d3/d3-array/blob/master/README.md#ascending d3.ascending}\r\n     * @see {@link https://github.com/d3/d3-array/blob/master/README.md#descending d3.descending}\r\n     * @example\r\n     * // Default value sort\r\n     * _chart.valueSort(function keySort (a, b) {\r\n     *     return d3.ascending(_chart.keyAccessor()(a), _chart.keyAccessor()(b));\r\n     * });\r\n     * @param {Function} [sortFunction]\r\n     * @returns {Function|dc.seriesChart}\r\n     */\n    _chart.valueSort = function (sortFunction) {\n        if (!arguments.length) {\n            return _valueSort;\n        }\n        _valueSort = sortFunction;\n        resetChildren();\n        return _chart;\n    };\n\n    // make compose private\n    _chart._compose = _chart.compose;\n    delete _chart.compose;\n\n    return _chart;\n};\n\n/**\r\n * The geo choropleth chart is designed as an easy way to create a crossfilter driven choropleth map\r\n * from GeoJson data. This chart implementation was inspired by\r\n * {@link http://bl.ocks.org/4060606 the great d3 choropleth example}.\r\n *\r\n * Examples:\r\n * - {@link http://dc-js.github.com/dc.js/vc/index.html US Venture Capital Landscape 2011}\r\n * @class geoChoroplethChart\r\n * @memberof dc\r\n * @mixes dc.colorMixin\r\n * @mixes dc.baseMixin\r\n * @example\r\n * // create a choropleth chart under '#us-chart' element using the default global chart group\r\n * var chart1 = dc.geoChoroplethChart('#us-chart');\r\n * // create a choropleth chart under '#us-chart2' element using chart group A\r\n * var chart2 = dc.compositeChart('#us-chart2', 'chartGroupA');\r\n * @param {String|node|d3.selection} parent - Any valid\r\n * {@link https://github.com/d3/d3-selection/blob/master/README.md#select d3 single selector} specifying\r\n * a dom block element such as a div; or a dom element or d3 selection.\r\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\r\n * Interaction with a chart will only trigger events and redraws within the chart's group.\r\n * @returns {dc.geoChoroplethChart}\r\n */\ndc.geoChoroplethChart = function (parent, chartGroup) {\n    var _chart = dc.colorMixin(dc.baseMixin({}));\n\n    _chart.colorAccessor(function (d) {\n        return d || 0;\n    });\n\n    var _geoPath = _d.d3.geoPath();\n    var _projectionFlag;\n    var _projection;\n\n    var _geoJsons = [];\n\n    _chart._doRender = function () {\n        _chart.resetSvg();\n        for (var layerIndex = 0; layerIndex < _geoJsons.length; ++layerIndex) {\n            var states = _chart.svg().append('g').attr('class', 'layer' + layerIndex);\n\n            var regionG = states.selectAll('g.' + geoJson(layerIndex).name).data(geoJson(layerIndex).data);\n\n            regionG = regionG.enter().append('g').attr('class', geoJson(layerIndex).name).merge(regionG);\n\n            regionG.append('path').attr('fill', 'white').attr('d', _getGeoPath());\n\n            regionG.append('title');\n\n            plotData(layerIndex);\n        }\n        _projectionFlag = false;\n    };\n\n    function plotData(layerIndex) {\n        var data = generateLayeredData();\n\n        if (isDataLayer(layerIndex)) {\n            var regionG = renderRegionG(layerIndex);\n\n            renderPaths(regionG, layerIndex, data);\n\n            renderTitle(regionG, layerIndex, data);\n        }\n    }\n\n    function generateLayeredData() {\n        var data = {};\n        var groupAll = _chart.data();\n        for (var i = 0; i < groupAll.length; ++i) {\n            data[_chart.keyAccessor()(groupAll[i])] = _chart.valueAccessor()(groupAll[i]);\n        }\n        return data;\n    }\n\n    function isDataLayer(layerIndex) {\n        return geoJson(layerIndex).keyAccessor;\n    }\n\n    function renderRegionG(layerIndex) {\n        var regionG = _chart.svg().selectAll(layerSelector(layerIndex)).classed('selected', function (d) {\n            return isSelected(layerIndex, d);\n        }).classed('deselected', function (d) {\n            return isDeselected(layerIndex, d);\n        }).attr('class', function (d) {\n            var layerNameClass = geoJson(layerIndex).name;\n            var regionClass = dc.utils.nameToId(geoJson(layerIndex).keyAccessor(d));\n            var baseClasses = layerNameClass + ' ' + regionClass;\n            if (isSelected(layerIndex, d)) {\n                baseClasses += ' selected';\n            }\n            if (isDeselected(layerIndex, d)) {\n                baseClasses += ' deselected';\n            }\n            return baseClasses;\n        });\n        return regionG;\n    }\n\n    function layerSelector(layerIndex) {\n        return 'g.layer' + layerIndex + ' g.' + geoJson(layerIndex).name;\n    }\n\n    function isSelected(layerIndex, d) {\n        return _chart.hasFilter() && _chart.hasFilter(getKey(layerIndex, d));\n    }\n\n    function isDeselected(layerIndex, d) {\n        return _chart.hasFilter() && !_chart.hasFilter(getKey(layerIndex, d));\n    }\n\n    function getKey(layerIndex, d) {\n        return geoJson(layerIndex).keyAccessor(d);\n    }\n\n    function geoJson(index) {\n        return _geoJsons[index];\n    }\n\n    function renderPaths(regionG, layerIndex, data) {\n        var paths = regionG.select('path').attr('fill', function () {\n            var currentFill = _d.d3.select(this).attr('fill');\n            if (currentFill) {\n                return currentFill;\n            }\n            return 'none';\n        }).on('click', function (d) {\n            return _chart.onClick(d, layerIndex);\n        });\n\n        dc.transition(paths, _chart.transitionDuration(), _chart.transitionDelay()).attr('fill', function (d, i) {\n            return _chart.getColor(data[geoJson(layerIndex).keyAccessor(d)], i);\n        });\n    }\n\n    _chart.onClick = function (d, layerIndex) {\n        var selectedRegion = geoJson(layerIndex).keyAccessor(d);\n        dc.events.trigger(function () {\n            _chart.filter(selectedRegion);\n            _chart.redrawGroup();\n        });\n    };\n\n    function renderTitle(regionG, layerIndex, data) {\n        if (_chart.renderTitle()) {\n            regionG.selectAll('title').text(function (d) {\n                var key = getKey(layerIndex, d);\n                var value = data[key];\n                return _chart.title()({ key: key, value: value });\n            });\n        }\n    }\n\n    _chart._doRedraw = function () {\n        for (var layerIndex = 0; layerIndex < _geoJsons.length; ++layerIndex) {\n            plotData(layerIndex);\n            if (_projectionFlag) {\n                _chart.svg().selectAll('g.' + geoJson(layerIndex).name + ' path').attr('d', _getGeoPath());\n            }\n        }\n        _projectionFlag = false;\n    };\n\n    /**\r\n     * **mandatory**\r\n     *\r\n     * Use this function to insert a new GeoJson map layer. This function can be invoked multiple times\r\n     * if you have multiple GeoJson data layers to render on top of each other. If you overlay multiple\r\n     * layers with the same name the new overlay will override the existing one.\r\n     * @method overlayGeoJson\r\n     * @memberof dc.geoChoroplethChart\r\n     * @instance\r\n     * @see {@link http://geojson.org/ GeoJSON}\r\n     * @see {@link https://github.com/topojson/topojson/wiki TopoJSON}\r\n     * @see {@link https://github.com/topojson/topojson-1.x-api-reference/blob/master/API-Reference.md#wiki-feature topojson.feature}\r\n     * @example\r\n     * // insert a layer for rendering US states\r\n     * chart.overlayGeoJson(statesJson.features, 'state', function(d) {\r\n     *      return d.properties.name;\r\n     * });\r\n     * @param {geoJson} json - a geojson feed\r\n     * @param {String} name - name of the layer\r\n     * @param {Function} keyAccessor - accessor function used to extract 'key' from the GeoJson data. The key extracted by\r\n     * this function should match the keys returned by the crossfilter groups.\r\n     * @returns {dc.geoChoroplethChart}\r\n     */\n    _chart.overlayGeoJson = function (json, name, keyAccessor) {\n        for (var i = 0; i < _geoJsons.length; ++i) {\n            if (_geoJsons[i].name === name) {\n                _geoJsons[i].data = json;\n                _geoJsons[i].keyAccessor = keyAccessor;\n                return _chart;\n            }\n        }\n        _geoJsons.push({ name: name, data: json, keyAccessor: keyAccessor });\n        return _chart;\n    };\n\n    /**\r\n     * Gets or sets a custom geo projection function. See the available\r\n     * {@link https://github.com/d3/d3-geo/blob/master/README.md#projections d3 geo projection functions}.\r\n     *\r\n     * Starting version 3.0 it has been deprecated to rely on the default projection being\r\n     * {@link https://github.com/d3/d3-geo/blob/master/README.md#geoAlbersUsa d3.geoAlbersUsa()}. Please\r\n     * set it explicitly. {@link https://bl.ocks.org/mbostock/5557726\r\n     * Considering that `null` is also a valid value for projection}, if you need\r\n     * projection to be `null` please set it explicitly to `null`.\r\n     * @method projection\r\n     * @memberof dc.geoChoroplethChart\r\n     * @instance\r\n     * @see {@link https://github.com/d3/d3-geo/blob/master/README.md#projections d3.projection}\r\n     * @see {@link https://github.com/d3/d3-geo-projection d3-geo-projection}\r\n     * @param {d3.projection} [projection=d3.geoAlbersUsa()]\r\n     * @returns {d3.projection|dc.geoChoroplethChart}\r\n     */\n    _chart.projection = function (projection) {\n        if (!arguments.length) {\n            return _projection;\n        }\n\n        _projection = projection;\n        _projectionFlag = true;\n        return _chart;\n    };\n\n    var _getGeoPath = function _getGeoPath() {\n        if (_projection === undefined) {\n            dc.logger.warn('choropleth projection default of geoAlbers is deprecated,' + ' in next version projection will need to be set explicitly');\n            return _geoPath.projection(_d.d3.geoAlbersUsa());\n        }\n\n        return _geoPath.projection(_projection);\n    };\n\n    /**\r\n     * Returns all GeoJson layers currently registered with this chart. The returned array is a\r\n     * reference to this chart's internal data structure, so any modification to this array will also\r\n     * modify this chart's internal registration.\r\n     * @method geoJsons\r\n     * @memberof dc.geoChoroplethChart\r\n     * @instance\r\n     * @returns {Array<{name:String, data: Object, accessor: Function}>}\r\n     */\n    _chart.geoJsons = function () {\n        return _geoJsons;\n    };\n\n    /**\r\n     * Returns the {@link https://github.com/d3/d3-geo/blob/master/README.md#paths d3.geoPath} object used to\r\n     * render the projection and features.  Can be useful for figuring out the bounding box of the\r\n     * feature set and thus a way to calculate scale and translation for the projection.\r\n     * @method geoPath\r\n     * @memberof dc.geoChoroplethChart\r\n     * @instance\r\n     * @see {@link https://github.com/d3/d3-geo/blob/master/README.md#paths d3.geoPath}\r\n     * @returns {d3.geoPath}\r\n     */\n    _chart.geoPath = function () {\n        return _geoPath;\n    };\n\n    /**\r\n     * Remove a GeoJson layer from this chart by name\r\n     * @method removeGeoJson\r\n     * @memberof dc.geoChoroplethChart\r\n     * @instance\r\n     * @param {String} name\r\n     * @returns {dc.geoChoroplethChart}\r\n     */\n    _chart.removeGeoJson = function (name) {\n        var geoJsons = [];\n\n        for (var i = 0; i < _geoJsons.length; ++i) {\n            var layer = _geoJsons[i];\n            if (layer.name !== name) {\n                geoJsons.push(layer);\n            }\n        }\n\n        _geoJsons = geoJsons;\n\n        return _chart;\n    };\n\n    return _chart.anchor(parent, chartGroup);\n};\n\n/**\r\n * The bubble overlay chart is quite different from the typical bubble chart. With the bubble overlay\r\n * chart you can arbitrarily place bubbles on an existing svg or bitmap image, thus changing the\r\n * typical x and y positioning while retaining the capability to visualize data using bubble radius\r\n * and coloring.\r\n *\r\n * Examples:\r\n * - {@link http://dc-js.github.com/dc.js/crime/index.html Canadian City Crime Stats}\r\n * @class bubbleOverlay\r\n * @memberof dc\r\n * @mixes dc.bubbleMixin\r\n * @mixes dc.baseMixin\r\n * @example\r\n * // create a bubble overlay chart on top of the '#chart-container1 svg' element using the default global chart group\r\n * var bubbleChart1 = dc.bubbleOverlayChart('#chart-container1').svg(d3.select('#chart-container1 svg'));\r\n * // create a bubble overlay chart on top of the '#chart-container2 svg' element using chart group A\r\n * var bubbleChart2 = dc.compositeChart('#chart-container2', 'chartGroupA').svg(d3.select('#chart-container2 svg'));\r\n * @param {String|node|d3.selection} parent - Any valid\r\n * {@link https://github.com/d3/d3-selection/blob/master/README.md#select d3 single selector} specifying\r\n * a dom block element such as a div; or a dom element or d3 selection.\r\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\r\n * Interaction with a chart will only trigger events and redraws within the chart's group.\r\n * @returns {dc.bubbleOverlay}\r\n */\ndc.bubbleOverlay = function (parent, chartGroup) {\n    var BUBBLE_OVERLAY_CLASS = 'bubble-overlay';\n    var BUBBLE_NODE_CLASS = 'node';\n    var BUBBLE_CLASS = 'bubble';\n\n    /**\r\n     * **mandatory**\r\n     *\r\n     * Set the underlying svg image element. Unlike other dc charts this chart will not generate a svg\r\n     * element; therefore the bubble overlay chart will not work if this function is not invoked. If the\r\n     * underlying image is a bitmap, then an empty svg will need to be created on top of the image.\r\n     * @method svg\r\n     * @memberof dc.bubbleOverlay\r\n     * @instance\r\n     * @example\r\n     * // set up underlying svg element\r\n     * chart.svg(d3.select('#chart svg'));\r\n     * @param {SVGElement|d3.selection} [imageElement]\r\n     * @returns {dc.bubbleOverlay}\r\n     */\n    var _chart = dc.bubbleMixin(dc.baseMixin({}));\n    var _g;\n    var _points = [];\n\n    _chart.transitionDuration(750);\n\n    _chart.transitionDelay(0);\n\n    _chart.radiusValueAccessor(function (d) {\n        return d.value;\n    });\n\n    /**\r\n     * **mandatory**\r\n     *\r\n     * Set up a data point on the overlay. The name of a data point should match a specific 'key' among\r\n     * data groups generated using keyAccessor.  If a match is found (point name <-> data group key)\r\n     * then a bubble will be generated at the position specified by the function. x and y\r\n     * value specified here are relative to the underlying svg.\r\n     * @method point\r\n     * @memberof dc.bubbleOverlay\r\n     * @instance\r\n     * @param {String} name\r\n     * @param {Number} x\r\n     * @param {Number} y\r\n     * @returns {dc.bubbleOverlay}\r\n     */\n    _chart.point = function (name, x, y) {\n        _points.push({ name: name, x: x, y: y });\n        return _chart;\n    };\n\n    _chart._doRender = function () {\n        _g = initOverlayG();\n\n        _chart.r().range([_chart.MIN_RADIUS, _chart.width() * _chart.maxBubbleRelativeSize()]);\n\n        initializeBubbles();\n\n        _chart.fadeDeselectedArea(_chart.filter());\n\n        return _chart;\n    };\n\n    function initOverlayG() {\n        _g = _chart.select('g.' + BUBBLE_OVERLAY_CLASS);\n        if (_g.empty()) {\n            _g = _chart.svg().append('g').attr('class', BUBBLE_OVERLAY_CLASS);\n        }\n        return _g;\n    }\n\n    function initializeBubbles() {\n        var data = mapData();\n        _chart.calculateRadiusDomain();\n\n        _points.forEach(function (point) {\n            var nodeG = getNodeG(point, data);\n\n            var circle = nodeG.select('circle.' + BUBBLE_CLASS);\n\n            if (circle.empty()) {\n                circle = nodeG.append('circle').attr('class', BUBBLE_CLASS).attr('r', 0).attr('fill', _chart.getColor).on('click', _chart.onClick);\n            }\n\n            dc.transition(circle, _chart.transitionDuration(), _chart.transitionDelay()).attr('r', function (d) {\n                return _chart.bubbleR(d);\n            });\n\n            _chart._doRenderLabel(nodeG);\n\n            _chart._doRenderTitles(nodeG);\n        });\n    }\n\n    function mapData() {\n        var data = {};\n        _chart.data().forEach(function (datum) {\n            data[_chart.keyAccessor()(datum)] = datum;\n        });\n        return data;\n    }\n\n    function getNodeG(point, data) {\n        var bubbleNodeClass = BUBBLE_NODE_CLASS + ' ' + dc.utils.nameToId(point.name);\n\n        var nodeG = _g.select('g.' + dc.utils.nameToId(point.name));\n\n        if (nodeG.empty()) {\n            nodeG = _g.append('g').attr('class', bubbleNodeClass).attr('transform', 'translate(' + point.x + ',' + point.y + ')');\n        }\n\n        nodeG.datum(data[point.name]);\n\n        return nodeG;\n    }\n\n    _chart._doRedraw = function () {\n        updateBubbles();\n\n        _chart.fadeDeselectedArea(_chart.filter());\n\n        return _chart;\n    };\n\n    function updateBubbles() {\n        var data = mapData();\n        _chart.calculateRadiusDomain();\n\n        _points.forEach(function (point) {\n            var nodeG = getNodeG(point, data);\n\n            var circle = nodeG.select('circle.' + BUBBLE_CLASS);\n\n            dc.transition(circle, _chart.transitionDuration(), _chart.transitionDelay()).attr('r', function (d) {\n                return _chart.bubbleR(d);\n            }).attr('fill', _chart.getColor);\n\n            _chart.doUpdateLabels(nodeG);\n\n            _chart.doUpdateTitles(nodeG);\n        });\n    }\n\n    _chart.debug = function (flag) {\n        if (flag) {\n            var debugG = _chart.select('g.' + dc.constants.DEBUG_GROUP_CLASS);\n\n            if (debugG.empty()) {\n                debugG = _chart.svg().append('g').attr('class', dc.constants.DEBUG_GROUP_CLASS);\n            }\n\n            var debugText = debugG.append('text').attr('x', 10).attr('y', 20);\n\n            debugG.append('rect').attr('width', _chart.width()).attr('height', _chart.height()).on('mousemove', function () {\n                var position = _d.d3.mouse(debugG.node());\n                var msg = position[0] + ', ' + position[1];\n                debugText.text(msg);\n            });\n        } else {\n            _chart.selectAll('.debug').remove();\n        }\n\n        return _chart;\n    };\n\n    _chart.anchor(parent, chartGroup);\n\n    return _chart;\n};\n\n/**\r\n * Concrete row chart implementation.\r\n *\r\n * Examples:\r\n * - {@link http://dc-js.github.com/dc.js/ Nasdaq 100 Index}\r\n * @class rowChart\r\n * @memberof dc\r\n * @mixes dc.capMixin\r\n * @mixes dc.marginMixin\r\n * @mixes dc.colorMixin\r\n * @mixes dc.baseMixin\r\n * @example\r\n * // create a row chart under #chart-container1 element using the default global chart group\r\n * var chart1 = dc.rowChart('#chart-container1');\r\n * // create a row chart under #chart-container2 element using chart group A\r\n * var chart2 = dc.rowChart('#chart-container2', 'chartGroupA');\r\n * @param {String|node|d3.selection} parent - Any valid\r\n * {@link https://github.com/d3/d3-selection/blob/master/README.md#select d3 single selector} specifying\r\n * a dom block element such as a div; or a dom element or d3 selection.\r\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\r\n * Interaction with a chart will only trigger events and redraws within the chart's group.\r\n * @returns {dc.rowChart}\r\n */\ndc.rowChart = function (parent, chartGroup) {\n\n    var _g;\n\n    var _labelOffsetX = 10;\n    var _labelOffsetY = 15;\n    var _hasLabelOffsetY = false;\n    var _dyOffset = '0.35em'; // this helps center labels https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#svg_text\n    var _titleLabelOffsetX = 2;\n\n    var _gap = 5;\n\n    var _fixedBarHeight = false;\n    var _rowCssClass = 'row';\n    var _titleRowCssClass = 'titlerow';\n    var _renderTitleLabel = false;\n\n    var _chart = dc.capMixin(dc.marginMixin(dc.colorMixin(dc.baseMixin({}))));\n\n    var _x;\n\n    var _elasticX;\n\n    var _xAxis = _d.d3.axisBottom();\n\n    var _rowData;\n\n    _chart.rowsCap = _chart.cap;\n\n    function calculateAxisScale() {\n        if (!_x || _elasticX) {\n            var extent = _d.d3.extent(_rowData, _chart.cappedValueAccessor);\n            if (extent[0] > 0) {\n                extent[0] = 0;\n            }\n            if (extent[1] < 0) {\n                extent[1] = 0;\n            }\n            _x = _d.d3.scaleLinear().domain(extent).range([0, _chart.effectiveWidth()]);\n        }\n        _xAxis.scale(_x);\n    }\n\n    function drawAxis() {\n        var axisG = _g.select('g.axis');\n\n        calculateAxisScale();\n\n        if (axisG.empty()) {\n            axisG = _g.append('g').attr('class', 'axis');\n        }\n        axisG.attr('transform', 'translate(0, ' + _chart.effectiveHeight() + ')');\n\n        dc.transition(axisG, _chart.transitionDuration(), _chart.transitionDelay()).call(_xAxis);\n    }\n\n    _chart._doRender = function () {\n        _chart.resetSvg();\n\n        _g = _chart.svg().append('g').attr('transform', 'translate(' + _chart.margins().left + ',' + _chart.margins().top + ')');\n\n        drawChart();\n\n        return _chart;\n    };\n\n    _chart.title(function (d) {\n        return _chart.cappedKeyAccessor(d) + ': ' + _chart.cappedValueAccessor(d);\n    });\n\n    _chart.label(_chart.cappedKeyAccessor);\n\n    /**\r\n     * Gets or sets the x scale. The x scale can be any d3\r\n     * {@link https://github.com/d3/d3-scale/blob/master/README.md d3.scale}.\r\n     * @method x\r\n     * @memberof dc.rowChart\r\n     * @instance\r\n     * @see {@link https://github.com/d3/d3-scale/blob/master/README.md d3.scale}\r\n     * @param {d3.scale} [scale]\r\n     * @returns {d3.scale|dc.rowChart}\r\n     */\n    _chart.x = function (scale) {\n        if (!arguments.length) {\n            return _x;\n        }\n        _x = scale;\n        return _chart;\n    };\n\n    function drawGridLines() {\n        _g.selectAll('g.tick').select('line.grid-line').remove();\n\n        _g.selectAll('g.tick').append('line').attr('class', 'grid-line').attr('x1', 0).attr('y1', 0).attr('x2', 0).attr('y2', function () {\n            return -_chart.effectiveHeight();\n        });\n    }\n\n    function drawChart() {\n        _rowData = _chart.data();\n\n        drawAxis();\n        drawGridLines();\n\n        var rows = _g.selectAll('g.' + _rowCssClass).data(_rowData);\n\n        removeElements(rows);\n        rows = createElements(rows).merge(rows);\n        updateElements(rows);\n    }\n\n    function createElements(rows) {\n        var rowEnter = rows.enter().append('g').attr('class', function (d, i) {\n            return _rowCssClass + ' _' + i;\n        });\n\n        rowEnter.append('rect').attr('width', 0);\n\n        createLabels(rowEnter);\n\n        return rowEnter;\n    }\n\n    function removeElements(rows) {\n        rows.exit().remove();\n    }\n\n    function rootValue() {\n        var root = _x(0);\n        return root === -Infinity || root !== root ? _x(1) : root;\n    }\n\n    function updateElements(rows) {\n        var n = _rowData.length;\n\n        var height;\n        if (!_fixedBarHeight) {\n            height = (_chart.effectiveHeight() - (n + 1) * _gap) / n;\n        } else {\n            height = _fixedBarHeight;\n        }\n\n        // vertically align label in center unless they override the value via property setter\n        if (!_hasLabelOffsetY) {\n            _labelOffsetY = height / 2;\n        }\n\n        var rect = rows.attr('transform', function (d, i) {\n            return 'translate(0,' + ((i + 1) * _gap + i * height) + ')';\n        }).select('rect').attr('height', height).attr('fill', _chart.getColor).on('click', onClick).classed('deselected', function (d) {\n            return _chart.hasFilter() ? !isSelectedRow(d) : false;\n        }).classed('selected', function (d) {\n            return _chart.hasFilter() ? isSelectedRow(d) : false;\n        });\n\n        dc.transition(rect, _chart.transitionDuration(), _chart.transitionDelay()).attr('width', function (d) {\n            return Math.abs(rootValue() - _x(_chart.valueAccessor()(d)));\n        }).attr('transform', translateX);\n\n        createTitles(rows);\n        updateLabels(rows);\n    }\n\n    function createTitles(rows) {\n        if (_chart.renderTitle()) {\n            rows.select('title').remove();\n            rows.append('title').text(_chart.title());\n        }\n    }\n\n    function createLabels(rowEnter) {\n        if (_chart.renderLabel()) {\n            rowEnter.append('text').on('click', onClick);\n        }\n        if (_chart.renderTitleLabel()) {\n            rowEnter.append('text').attr('class', _titleRowCssClass).on('click', onClick);\n        }\n    }\n\n    function updateLabels(rows) {\n        if (_chart.renderLabel()) {\n            var lab = rows.select('text').attr('x', _labelOffsetX).attr('y', _labelOffsetY).attr('dy', _dyOffset).on('click', onClick).attr('class', function (d, i) {\n                return _rowCssClass + ' _' + i;\n            }).text(function (d) {\n                return _chart.label()(d);\n            });\n            dc.transition(lab, _chart.transitionDuration(), _chart.transitionDelay()).attr('transform', translateX);\n        }\n        if (_chart.renderTitleLabel()) {\n            var titlelab = rows.select('.' + _titleRowCssClass).attr('x', _chart.effectiveWidth() - _titleLabelOffsetX).attr('y', _labelOffsetY).attr('dy', _dyOffset).attr('text-anchor', 'end').on('click', onClick).attr('class', function (d, i) {\n                return _titleRowCssClass + ' _' + i;\n            }).text(function (d) {\n                return _chart.title()(d);\n            });\n            dc.transition(titlelab, _chart.transitionDuration(), _chart.transitionDelay()).attr('transform', translateX);\n        }\n    }\n\n    /**\r\n     * Turn on/off Title label rendering (values) using SVG style of text-anchor 'end'.\r\n     * @method renderTitleLabel\r\n     * @memberof dc.rowChart\r\n     * @instance\r\n     * @param {Boolean} [renderTitleLabel=false]\r\n     * @returns {Boolean|dc.rowChart}\r\n     */\n    _chart.renderTitleLabel = function (renderTitleLabel) {\n        if (!arguments.length) {\n            return _renderTitleLabel;\n        }\n        _renderTitleLabel = renderTitleLabel;\n        return _chart;\n    };\n\n    function onClick(d) {\n        _chart.onClick(d);\n    }\n\n    function translateX(d) {\n        var x = _x(_chart.cappedValueAccessor(d)),\n            x0 = rootValue(),\n            s = x > x0 ? x0 : x;\n        return 'translate(' + s + ',0)';\n    }\n\n    _chart._doRedraw = function () {\n        drawChart();\n        return _chart;\n    };\n\n    /**\r\n     * Get or sets the x axis for the row chart instance.\r\n     * See the {@link https://github.com/d3/d3-axis/blob/master/README.md d3.axis}\r\n     * documention for more information.\r\n     * @method xAxis\r\n     * @memberof dc.rowChart\r\n     * @instance\r\n     * @example\r\n     * // customize x axis tick format\r\n     * chart.xAxis().tickFormat(function (v) {return v + '%';});\r\n     * // customize x axis tick values\r\n     * chart.xAxis().tickValues([0, 100, 200, 300]);\r\n     * // use a top-oriented axis. Note: position of the axis and grid lines will need to\r\n     * // be set manually, see https://dc-js.github.io/dc.js/examples/row-top-axis.html\r\n     * chart.xAxis(d3.axisTop())\r\n     * @returns {d3.axis}\r\n     */\n    _chart.xAxis = function (xAxis) {\n        if (!arguments.length) {\n            return _xAxis;\n        }\n        _xAxis = xAxis;\n        return this;\n    };\n\n    /**\r\n     * Get or set the fixed bar height. Default is [false] which will auto-scale bars.\r\n     * For example, if you want to fix the height for a specific number of bars (useful in TopN charts)\r\n     * you could fix height as follows (where count = total number of bars in your TopN and gap is\r\n     * your vertical gap space).\r\n     * @method fixedBarHeight\r\n     * @memberof dc.rowChart\r\n     * @instance\r\n     * @example\r\n     * chart.fixedBarHeight( chartheight - (count + 1) * gap / count);\r\n     * @param {Boolean|Number} [fixedBarHeight=false]\r\n     * @returns {Boolean|Number|dc.rowChart}\r\n     */\n    _chart.fixedBarHeight = function (fixedBarHeight) {\n        if (!arguments.length) {\n            return _fixedBarHeight;\n        }\n        _fixedBarHeight = fixedBarHeight;\n        return _chart;\n    };\n\n    /**\r\n     * Get or set the vertical gap space between rows on a particular row chart instance.\r\n     * @method gap\r\n     * @memberof dc.rowChart\r\n     * @instance\r\n     * @param {Number} [gap=5]\r\n     * @returns {Number|dc.rowChart}\r\n     */\n    _chart.gap = function (gap) {\n        if (!arguments.length) {\n            return _gap;\n        }\n        _gap = gap;\n        return _chart;\n    };\n\n    /**\r\n     * Get or set the elasticity on x axis. If this attribute is set to true, then the x axis will rescle to auto-fit the\r\n     * data range when filtered.\r\n     * @method elasticX\r\n     * @memberof dc.rowChart\r\n     * @instance\r\n     * @param {Boolean} [elasticX]\r\n     * @returns {Boolean|dc.rowChart}\r\n     */\n    _chart.elasticX = function (elasticX) {\n        if (!arguments.length) {\n            return _elasticX;\n        }\n        _elasticX = elasticX;\n        return _chart;\n    };\n\n    /**\r\n     * Get or set the x offset (horizontal space to the top left corner of a row) for labels on a particular row chart.\r\n     * @method labelOffsetX\r\n     * @memberof dc.rowChart\r\n     * @instance\r\n     * @param {Number} [labelOffsetX=10]\r\n     * @returns {Number|dc.rowChart}\r\n     */\n    _chart.labelOffsetX = function (labelOffsetX) {\n        if (!arguments.length) {\n            return _labelOffsetX;\n        }\n        _labelOffsetX = labelOffsetX;\n        return _chart;\n    };\n\n    /**\r\n     * Get or set the y offset (vertical space to the top left corner of a row) for labels on a particular row chart.\r\n     * @method labelOffsetY\r\n     * @memberof dc.rowChart\r\n     * @instance\r\n     * @param {Number} [labelOffsety=15]\r\n     * @returns {Number|dc.rowChart}\r\n     */\n    _chart.labelOffsetY = function (labelOffsety) {\n        if (!arguments.length) {\n            return _labelOffsetY;\n        }\n        _labelOffsetY = labelOffsety;\n        _hasLabelOffsetY = true;\n        return _chart;\n    };\n\n    /**\r\n     * Get of set the x offset (horizontal space between right edge of row and right edge or text.\r\n     * @method titleLabelOffsetX\r\n     * @memberof dc.rowChart\r\n     * @instance\r\n     * @param {Number} [titleLabelOffsetX=2]\r\n     * @returns {Number|dc.rowChart}\r\n     */\n    _chart.titleLabelOffsetX = function (titleLabelOffsetX) {\n        if (!arguments.length) {\n            return _titleLabelOffsetX;\n        }\n        _titleLabelOffsetX = titleLabelOffsetX;\n        return _chart;\n    };\n\n    function isSelectedRow(d) {\n        return _chart.hasFilter(_chart.cappedKeyAccessor(d));\n    }\n\n    return _chart.anchor(parent, chartGroup);\n};\n\n/**\r\n * Legend is a attachable widget that can be added to other dc charts to render horizontal legend\r\n * labels.\r\n *\r\n * Examples:\r\n * - {@link http://dc-js.github.com/dc.js/ Nasdaq 100 Index}\r\n * - {@link http://dc-js.github.com/dc.js/crime/index.html Canadian City Crime Stats}\r\n * @class legend\r\n * @memberof dc\r\n * @example\r\n * chart.legend(dc.legend().x(400).y(10).itemHeight(13).gap(5))\r\n * @returns {dc.legend}\r\n */\ndc.legend = function () {\n    var LABEL_GAP = 2;\n\n    var _legend = {},\n        _parent,\n        _x = 0,\n        _y = 0,\n        _itemHeight = 12,\n        _gap = 5,\n        _horizontal = false,\n        _legendWidth = 560,\n        _itemWidth = 70,\n        _autoItemWidth = false,\n        _legendText = dc.pluck('name'),\n        _maxItems;\n\n    var _g;\n\n    _legend.parent = function (p) {\n        if (!arguments.length) {\n            return _parent;\n        }\n        _parent = p;\n        return _legend;\n    };\n\n    _legend.render = function () {\n        _parent.svg().select('g.dc-legend').remove();\n        _g = _parent.svg().append('g').attr('class', 'dc-legend').attr('transform', 'translate(' + _x + ',' + _y + ')');\n        var legendables = _parent.legendables();\n\n        if (_maxItems !== undefined) {\n            legendables = legendables.slice(0, _maxItems);\n        }\n\n        var itemEnter = _g.selectAll('g.dc-legend-item').data(legendables).enter().append('g').attr('class', 'dc-legend-item').on('mouseover', function (d) {\n            _parent.legendHighlight(d);\n        }).on('mouseout', function (d) {\n            _parent.legendReset(d);\n        }).on('click', function (d) {\n            d.chart.legendToggle(d);\n        });\n\n        _g.selectAll('g.dc-legend-item').classed('fadeout', function (d) {\n            return d.chart.isLegendableHidden(d);\n        });\n\n        if (legendables.some(dc.pluck('dashstyle'))) {\n            itemEnter.append('line').attr('x1', 0).attr('y1', _itemHeight / 2).attr('x2', _itemHeight).attr('y2', _itemHeight / 2).attr('stroke-width', 2).attr('stroke-dasharray', dc.pluck('dashstyle')).attr('stroke', dc.pluck('color'));\n        } else {\n            itemEnter.append('rect').attr('width', _itemHeight).attr('height', _itemHeight).attr('fill', function (d) {\n                return d ? d.color : 'blue';\n            });\n        }\n\n        itemEnter.append('text').text(_legendText).attr('x', _itemHeight + LABEL_GAP).attr('y', function () {\n            return _itemHeight / 2 + (this.clientHeight ? this.clientHeight : 13) / 2 - 2;\n        });\n\n        var _cumulativeLegendTextWidth = 0;\n        var row = 0;\n        itemEnter.attr('transform', function (d, i) {\n            if (_horizontal) {\n                var itemWidth = _autoItemWidth === true ? this.getBBox().width + _gap : _itemWidth;\n                if (_cumulativeLegendTextWidth + itemWidth > _legendWidth && _cumulativeLegendTextWidth > 0) {\n                    ++row;\n                    _cumulativeLegendTextWidth = 0;\n                }\n                var translateBy = 'translate(' + _cumulativeLegendTextWidth + ',' + row * legendItemHeight() + ')';\n                _cumulativeLegendTextWidth += itemWidth;\n                return translateBy;\n            } else {\n                return 'translate(0,' + i * legendItemHeight() + ')';\n            }\n        });\n    };\n\n    function legendItemHeight() {\n        return _gap + _itemHeight;\n    }\n\n    /**\r\n     * Set or get x coordinate for legend widget.\r\n     * @method x\r\n     * @memberof dc.legend\r\n     * @instance\r\n     * @param  {Number} [x=0]\r\n     * @returns {Number|dc.legend}\r\n     */\n    _legend.x = function (x) {\n        if (!arguments.length) {\n            return _x;\n        }\n        _x = x;\n        return _legend;\n    };\n\n    /**\r\n     * Set or get y coordinate for legend widget.\r\n     * @method y\r\n     * @memberof dc.legend\r\n     * @instance\r\n     * @param  {Number} [y=0]\r\n     * @returns {Number|dc.legend}\r\n     */\n    _legend.y = function (y) {\n        if (!arguments.length) {\n            return _y;\n        }\n        _y = y;\n        return _legend;\n    };\n\n    /**\r\n     * Set or get gap between legend items.\r\n     * @method gap\r\n     * @memberof dc.legend\r\n     * @instance\r\n     * @param  {Number} [gap=5]\r\n     * @returns {Number|dc.legend}\r\n     */\n    _legend.gap = function (gap) {\n        if (!arguments.length) {\n            return _gap;\n        }\n        _gap = gap;\n        return _legend;\n    };\n\n    /**\r\n     * Set or get legend item height.\r\n     * @method itemHeight\r\n     * @memberof dc.legend\r\n     * @instance\r\n     * @param  {Number} [itemHeight=12]\r\n     * @returns {Number|dc.legend}\r\n     */\n    _legend.itemHeight = function (itemHeight) {\n        if (!arguments.length) {\n            return _itemHeight;\n        }\n        _itemHeight = itemHeight;\n        return _legend;\n    };\n\n    /**\r\n     * Position legend horizontally instead of vertically.\r\n     * @method horizontal\r\n     * @memberof dc.legend\r\n     * @instance\r\n     * @param  {Boolean} [horizontal=false]\r\n     * @returns {Boolean|dc.legend}\r\n     */\n    _legend.horizontal = function (horizontal) {\n        if (!arguments.length) {\n            return _horizontal;\n        }\n        _horizontal = horizontal;\n        return _legend;\n    };\n\n    /**\r\n     * Maximum width for horizontal legend.\r\n     * @method legendWidth\r\n     * @memberof dc.legend\r\n     * @instance\r\n     * @param  {Number} [legendWidth=500]\r\n     * @returns {Number|dc.legend}\r\n     */\n    _legend.legendWidth = function (legendWidth) {\n        if (!arguments.length) {\n            return _legendWidth;\n        }\n        _legendWidth = legendWidth;\n        return _legend;\n    };\n\n    /**\r\n     * Legend item width for horizontal legend.\r\n     * @method itemWidth\r\n     * @memberof dc.legend\r\n     * @instance\r\n     * @param  {Number} [itemWidth=70]\r\n     * @returns {Number|dc.legend}\r\n     */\n    _legend.itemWidth = function (itemWidth) {\n        if (!arguments.length) {\n            return _itemWidth;\n        }\n        _itemWidth = itemWidth;\n        return _legend;\n    };\n\n    /**\r\n     * Turn automatic width for legend items on or off. If true, {@link dc.legend#itemWidth itemWidth} is ignored.\r\n     * This setting takes into account the {@link dc.legend#gap gap}.\r\n     * @method autoItemWidth\r\n     * @memberof dc.legend\r\n     * @instance\r\n     * @param  {Boolean} [autoItemWidth=false]\r\n     * @returns {Boolean|dc.legend}\r\n     */\n    _legend.autoItemWidth = function (autoItemWidth) {\n        if (!arguments.length) {\n            return _autoItemWidth;\n        }\n        _autoItemWidth = autoItemWidth;\n        return _legend;\n    };\n\n    /**\r\n     * Set or get the legend text function. The legend widget uses this function to render the legend\r\n     * text for each item. If no function is specified the legend widget will display the names\r\n     * associated with each group.\r\n     * @method legendText\r\n     * @memberof dc.legend\r\n     * @instance\r\n     * @param  {Function} [legendText]\r\n     * @returns {Function|dc.legend}\r\n     * @example\r\n     * // default legendText\r\n     * legend.legendText(dc.pluck('name'))\r\n     *\r\n     * // create numbered legend items\r\n     * chart.legend(dc.legend().legendText(function(d, i) { return i + '. ' + d.name; }))\r\n     *\r\n     * // create legend displaying group counts\r\n     * chart.legend(dc.legend().legendText(function(d) { return d.name + ': ' d.data; }))\r\n     **/\n    _legend.legendText = function (legendText) {\n        if (!arguments.length) {\n            return _legendText;\n        }\n        _legendText = legendText;\n        return _legend;\n    };\n\n    /**\r\n     * Maximum number of legend items to display\r\n     * @method maxItems\r\n     * @memberof dc.legend\r\n     * @instance\r\n     * @param  {Number} [maxItems]\r\n     * @return {dc.legend}\r\n     */\n    _legend.maxItems = function (maxItems) {\n        if (!arguments.length) {\n            return _maxItems;\n        }\n        _maxItems = dc.utils.isNumber(maxItems) ? maxItems : undefined;\n        return _legend;\n    };\n\n    return _legend;\n};\n\n/**\r\n * htmlLegend is a attachable widget that can be added to other dc charts to render horizontal/vertical legend\r\n * labels.\r\n *\r\n * @class htmlLegend\r\n * @memberof dc\r\n * @example\r\n * chart.legend(dc.htmlLegend().container(legendContainerElement).horizontal(false))\r\n * @returns {dc.htmlLegend}\r\n */\ndc.htmlLegend = function () {\n    var _legend = {},\n        _htmlLegendDivCssClass = 'dc-html-legend',\n        _legendItemCssClassHorizontal = 'dc-legend-item-horizontal',\n        _legendItemCssClassVertical = 'dc-legend-item-vertical',\n        _parent,\n        _container,\n        _legendText = dc.pluck('name'),\n        _maxItems,\n        _horizontal = false,\n        _legendItemClass,\n        _highlightSelected = false;\n\n    _legend.parent = function (p) {\n        if (!arguments.length) {\n            return _parent;\n        }\n        _parent = p;\n        return _legend;\n    };\n\n    _legend.render = function () {\n        var _defaultLegendItemCssClass = _horizontal ? _legendItemCssClassHorizontal : _legendItemCssClassVertical;\n        _container.select('div.dc-html-legend').remove();\n\n        var _l = _container.append('div').attr('class', _htmlLegendDivCssClass);\n        _l.attr('style', 'max-width:' + _container.nodes()[0].style.width);\n\n        var legendables = _parent.legendables();\n        var filters = _parent.filters();\n\n        if (_maxItems !== undefined) {\n            legendables = legendables.slice(0, _maxItems);\n        }\n\n        var legendItemClassName = _legendItemClass ? _legendItemClass : _defaultLegendItemCssClass;\n\n        var itemEnter = _l.selectAll('div.' + legendItemClassName).data(legendables).enter().append('div').classed(legendItemClassName, true).on('mouseover', _parent.legendHighlight).on('mouseout', _parent.legendReset).on('click', _parent.legendToggle);\n\n        if (_highlightSelected) {\n            itemEnter.classed(dc.constants.SELECTED_CLASS, function (d) {\n                return filters.indexOf(d.name) !== -1;\n            });\n        }\n\n        itemEnter.append('span').attr('class', 'dc-legend-item-color').style('background-color', dc.pluck('color'));\n\n        itemEnter.append('span').attr('class', 'dc-legend-item-label').attr('title', _legendText).text(_legendText);\n    };\n\n    /**\r\n     #### .container([selector])\r\n     Set the container selector for the legend widget. Required.\r\n     **/\n    _legend.container = function (c) {\n        if (!arguments.length) {\n            return _container;\n        }\n        _container = _d.d3.select(c);\n        return _legend;\n    };\n\n    /**\r\n     #### .legendItemClass([selector])\r\n     This can be optionally used to override class for legenditem and just use this class style.\r\n     The reason to have this is so this can be done for a particular chart rather than overriding the style for all charts\r\n     Setting this will disable the highlighting of selected items also.\r\n     **/\n    _legend.legendItemClass = function (c) {\n        if (!arguments.length) {\n            return _legendItemClass;\n        }\n        _legendItemClass = c;\n        return _legend;\n    };\n\n    /**\r\n     #### .highlightSelected([boolean])\r\n     This can be optionally used to enable highlighting legends for the selections/filters for the chart.\r\n     **/\n    _legend.highlightSelected = function (c) {\n        if (!arguments.length) {\n            return _highlightSelected;\n        }\n        _highlightSelected = c;\n        return _legend;\n    };\n\n    /**\r\n     #### .horizontal([boolean])\r\n     Display the legend horizontally instead of horizontally\r\n     **/\n    _legend.horizontal = function (b) {\n        if (!arguments.length) {\n            return _horizontal;\n        }\n        _horizontal = b;\n        return _legend;\n    };\n\n    /**\r\n     * Set or get the legend text function. The legend widget uses this function to render the legend\r\n     * text for each item. If no function is specified the legend widget will display the names\r\n     * associated with each group.\r\n     * @method legendText\r\n     * @memberof dc.htmlLegend\r\n     * @instance\r\n     * @param  {Function} [legendText]\r\n     * @returns {Function|dc.htmlLegend}\r\n     * @example\r\n     * // default legendText\r\n     * legend.legendText(dc.pluck('name'))\r\n     *\r\n     * // create numbered legend items\r\n     * chart.legend(dc.htmlLegend().legendText(function(d, i) { return i + '. ' + d.name; }))\r\n     *\r\n     * // create legend displaying group counts\r\n     * chart.legend(dc.htmlLegend().legendText(function(d) { return d.name + ': ' d.data; }))\r\n     **/\n    _legend.legendText = function (legendText) {\n        if (!arguments.length) {\n            return _legendText;\n        }\n        _legendText = legendText;\n        return _legend;\n    };\n\n    /**\r\n     * Maximum number of legend items to display\r\n     * @method maxItems\r\n     * @memberof dc.htmlLegend\r\n     * @instance\r\n     * @param  {Number} [maxItems]\r\n     * @return {dc.htmlLegend}\r\n     */\n    _legend.maxItems = function (maxItems) {\n        if (!arguments.length) {\n            return _maxItems;\n        }\n        _maxItems = dc.utils.isNumber(maxItems) ? maxItems : undefined;\n        return _legend;\n    };\n\n    return _legend;\n};\n\n/**\r\n * A scatter plot chart\r\n *\r\n * Examples:\r\n * - {@link http://dc-js.github.io/dc.js/examples/scatter.html Scatter Chart}\r\n * - {@link http://dc-js.github.io/dc.js/examples/multi-scatter.html Multi-Scatter Chart}\r\n * @class scatterPlot\r\n * @memberof dc\r\n * @mixes dc.coordinateGridMixin\r\n * @example\r\n * // create a scatter plot under #chart-container1 element using the default global chart group\r\n * var chart1 = dc.scatterPlot('#chart-container1');\r\n * // create a scatter plot under #chart-container2 element using chart group A\r\n * var chart2 = dc.scatterPlot('#chart-container2', 'chartGroupA');\r\n * // create a sub-chart under a composite parent chart\r\n * var chart3 = dc.scatterPlot(compositeChart);\r\n * @param {String|node|d3.selection} parent - Any valid\r\n * {@link https://github.com/d3/d3-selection/blob/master/README.md#select d3 single selector} specifying\r\n * a dom block element such as a div; or a dom element or d3 selection.\r\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\r\n * Interaction with a chart will only trigger events and redraws within the chart's group.\r\n * @returns {dc.scatterPlot}\r\n */\ndc.scatterPlot = function (parent, chartGroup) {\n    var _chart = dc.coordinateGridMixin({});\n    var _symbol = _d.d3.symbol();\n\n    var _existenceAccessor = function _existenceAccessor(d) {\n        return d.value;\n    };\n\n    var originalKeyAccessor = _chart.keyAccessor();\n    _chart.keyAccessor(function (d) {\n        return originalKeyAccessor(d)[0];\n    });\n    _chart.valueAccessor(function (d) {\n        return originalKeyAccessor(d)[1];\n    });\n    _chart.colorAccessor(function () {\n        return _chart._groupName;\n    });\n\n    _chart.title(function (d) {\n        // this basically just counteracts the setting of its own key/value accessors\n        // see https://github.com/dc-js/dc.js/issues/702\n        return _chart.keyAccessor()(d) + ',' + _chart.valueAccessor()(d) + ': ' + _chart.existenceAccessor()(d);\n    });\n\n    var _locator = function _locator(d) {\n        return 'translate(' + _chart.x()(_chart.keyAccessor()(d)) + ',' + _chart.y()(_chart.valueAccessor()(d)) + ')';\n    };\n\n    var _highlightedSize = 7;\n    var _symbolSize = 5;\n    var _excludedSize = 3;\n    var _excludedColor = null;\n    var _excludedOpacity = 1.0;\n    var _emptySize = 0;\n    var _emptyOpacity = 0;\n    var _nonemptyOpacity = 1;\n    var _emptyColor = null;\n    var _filtered = [];\n\n    // Use a 2 dimensional brush\n    _chart.brush(_d.d3.brush());\n\n    function elementSize(d, i) {\n        if (!_existenceAccessor(d)) {\n            return Math.pow(_emptySize, 2);\n        } else if (_filtered[i]) {\n            return Math.pow(_symbolSize, 2);\n        } else {\n            return Math.pow(_excludedSize, 2);\n        }\n    }\n    _symbol.size(elementSize);\n\n    dc.override(_chart, '_filter', function (filter) {\n        if (!arguments.length) {\n            return _chart.__filter();\n        }\n\n        return _chart.__filter(dc.filters.RangedTwoDimensionalFilter(filter));\n    });\n\n    _chart.plotData = function () {\n        var symbols = _chart.chartBodyG().selectAll('path.symbol').data(_chart.data());\n\n        dc.transition(symbols.exit(), _chart.transitionDuration(), _chart.transitionDelay()).attr('opacity', 0).remove();\n\n        symbols = symbols.enter().append('path').attr('class', 'symbol').attr('opacity', 0).attr('fill', \"_chart.getColor\").attr('transform', _locator).merge(symbols);\n\n        symbols.call(renderTitles, _chart.data());\n\n        symbols.each(function (d, i) {\n            _filtered[i] = !_chart.filter() || _chart.filter().isFiltered([_chart.keyAccessor()(d), _chart.valueAccessor()(d)]);\n        });\n\n        dc.transition(symbols, _chart.transitionDuration(), _chart.transitionDelay()).attr('opacity', function (d, i) {\n            if (!_existenceAccessor(d)) {\n                return _emptyOpacity;\n            } else if (_filtered[i]) {\n                return _nonemptyOpacity;\n            } else {\n                return _chart.excludedOpacity();\n            }\n        }).attr('fill', function (d, i) {\n            if (_emptyColor && !_existenceAccessor(d)) {\n                return _emptyColor;\n            } else if (_chart.excludedColor() && !_filtered[i]) {\n                return _chart.excludedColor();\n            } else {\n                return _chart.getColor(d);\n            }\n        }).attr('transform', _locator).attr('d', _symbol);\n    };\n\n    function renderTitles(symbol, d) {\n        if (_chart.renderTitle()) {\n            symbol.selectAll('title').remove();\n            symbol.append('title').text(function (d) {\n                return _chart.title()(d);\n            });\n        }\n    }\n\n    /**\r\n     * Get or set the existence accessor.  If a point exists, it is drawn with\r\n     * {@link dc.scatterPlot#symbolSize symbolSize} radius and\r\n     * opacity 1; if it does not exist, it is drawn with\r\n     * {@link dc.scatterPlot#emptySize emptySize} radius and opacity 0. By default,\r\n     * the existence accessor checks if the reduced value is truthy.\r\n     * @method existenceAccessor\r\n     * @memberof dc.scatterPlot\r\n     * @instance\r\n     * @see {@link dc.scatterPlot#symbolSize symbolSize}\r\n     * @see {@link dc.scatterPlot#emptySize emptySize}\r\n     * @example\r\n     * // default accessor\r\n     * chart.existenceAccessor(function (d) { return d.value; });\r\n     * @param {Function} [accessor]\r\n     * @returns {Function|dc.scatterPlot}\r\n     */\n    _chart.existenceAccessor = function (accessor) {\n        if (!arguments.length) {\n            return _existenceAccessor;\n        }\n        _existenceAccessor = accessor;\n        return this;\n    };\n\n    /**\r\n     * Get or set the symbol type used for each point. By default the symbol is a circle (d3.symbolCircle).\r\n     * Type can be a constant or an accessor.\r\n     * @method symbol\r\n     * @memberof dc.scatterPlot\r\n     * @instance\r\n     * @see {@link https://github.com/d3/d3-shape/blob/master/README.md#symbol_type symbol.type}\r\n     * @example\r\n     * // Circle type\r\n     * chart.symbol(d3.symbolCircle);\r\n     * // Square type\r\n     * chart.symbol(d3.symbolSquare);\r\n     * @param {Function} [type=d3.symbolCircle]\r\n     * @returns {Function|dc.scatterPlot}\r\n     */\n    _chart.symbol = function (type) {\n        if (!arguments.length) {\n            return _symbol.type();\n        }\n        _symbol.type(type);\n        return _chart;\n    };\n\n    /**\r\n     * Get or set the symbol generator. By default `dc.scatterPlot` will use\r\n     * {@link https://github.com/d3/d3-shape/blob/master/README.md#symbol d3.symbol()}\r\n     * to generate symbols. `dc.scatterPlot` will set the\r\n     * {@link https://github.com/d3/d3-shape/blob/master/README.md#symbol_size symbol size accessor}\r\n     * on the symbol generator.\r\n     * @method customSymbol\r\n     * @memberof dc.scatterPlot\r\n     * @instance\r\n     * @see {@link https://github.com/d3/d3-shape/blob/master/README.md#symbol d3.symbol}\r\n     * @see {@link https://stackoverflow.com/questions/25332120/create-additional-d3-js-symbols Create additional D3.js symbols}\r\n     * @param {String|Function} [customSymbol=d3.symbol()]\r\n     * @returns {String|Function|dc.scatterPlot}\r\n     */\n    _chart.customSymbol = function (customSymbol) {\n        if (!arguments.length) {\n            return _symbol;\n        }\n        _symbol = customSymbol;\n        _symbol.size(elementSize);\n        return _chart;\n    };\n\n    /**\r\n     * Set or get radius for symbols.\r\n     * @method symbolSize\r\n     * @memberof dc.scatterPlot\r\n     * @instance\r\n     * @see {@link https://github.com/d3/d3-shape/blob/master/README.md#symbol_size d3.symbol.size}\r\n     * @param {Number} [symbolSize=3]\r\n     * @returns {Number|dc.scatterPlot}\r\n     */\n    _chart.symbolSize = function (symbolSize) {\n        if (!arguments.length) {\n            return _symbolSize;\n        }\n        _symbolSize = symbolSize;\n        return _chart;\n    };\n\n    /**\r\n     * Set or get radius for highlighted symbols.\r\n     * @method highlightedSize\r\n     * @memberof dc.scatterPlot\r\n     * @instance\r\n     * @see {@link https://github.com/d3/d3-shape/blob/master/README.md#symbol_size d3.symbol.size}\r\n     * @param {Number} [highlightedSize=5]\r\n     * @returns {Number|dc.scatterPlot}\r\n     */\n    _chart.highlightedSize = function (highlightedSize) {\n        if (!arguments.length) {\n            return _highlightedSize;\n        }\n        _highlightedSize = highlightedSize;\n        return _chart;\n    };\n\n    /**\r\n     * Set or get size for symbols excluded from this chart's filter. If null, no\r\n     * special size is applied for symbols based on their filter status.\r\n     * @method excludedSize\r\n     * @memberof dc.scatterPlot\r\n     * @instance\r\n     * @see {@link https://github.com/d3/d3-shape/blob/master/README.md#symbol_size d3.symbol.size}\r\n     * @param {Number} [excludedSize=null]\r\n     * @returns {Number|dc.scatterPlot}\r\n     */\n    _chart.excludedSize = function (excludedSize) {\n        if (!arguments.length) {\n            return _excludedSize;\n        }\n        _excludedSize = excludedSize;\n        return _chart;\n    };\n\n    /**\r\n     * Set or get color for symbols excluded from this chart's filter. If null, no\r\n     * special color is applied for symbols based on their filter status.\r\n     * @method excludedColor\r\n     * @memberof dc.scatterPlot\r\n     * @instance\r\n     * @param {Number} [excludedColor=null]\r\n     * @returns {Number|dc.scatterPlot}\r\n     */\n    _chart.excludedColor = function (excludedColor) {\n        if (!arguments.length) {\n            return _excludedColor;\n        }\n        _excludedColor = excludedColor;\n        return _chart;\n    };\n\n    /**\r\n     * Set or get opacity for symbols excluded from this chart's filter.\r\n     * @method excludedOpacity\r\n     * @memberof dc.scatterPlot\r\n     * @instance\r\n     * @param {Number} [excludedOpacity=1.0]\r\n     * @returns {Number|dc.scatterPlot}\r\n     */\n    _chart.excludedOpacity = function (excludedOpacity) {\n        if (!arguments.length) {\n            return _excludedOpacity;\n        }\n        _excludedOpacity = excludedOpacity;\n        return _chart;\n    };\n\n    /**\r\n     * Set or get radius for symbols when the group is empty.\r\n     * @method emptySize\r\n     * @memberof dc.scatterPlot\r\n     * @instance\r\n     * @see {@link https://github.com/d3/d3-shape/blob/master/README.md#symbol_size d3.symbol.size}\r\n     * @param {Number} [emptySize=0]\r\n     * @returns {Number|dc.scatterPlot}\r\n     */\n    _chart.hiddenSize = _chart.emptySize = function (emptySize) {\n        if (!arguments.length) {\n            return _emptySize;\n        }\n        _emptySize = emptySize;\n        return _chart;\n    };\n\n    /**\r\n     * Set or get color for symbols when the group is empty. If null, just use the\r\n     * {@link dc.colorMixin#colors colorMixin.colors} color scale zero value.\r\n     * @name emptyColor\r\n     * @memberof dc.scatterPlot\r\n     * @instance\r\n     * @param {String} [emptyColor=null]\r\n     * @return {String}\r\n     * @return {dc.scatterPlot}/\r\n     */\n    _chart.emptyColor = function (emptyColor) {\n        if (!arguments.length) {\n            return _emptyColor;\n        }\n        _emptyColor = emptyColor;\n        return _chart;\n    };\n\n    /**\r\n     * Set or get opacity for symbols when the group is empty.\r\n     * @name emptyOpacity\r\n     * @memberof dc.scatterPlot\r\n     * @instance\r\n     * @param {Number} [emptyOpacity=0]\r\n     * @return {Number}\r\n     * @return {dc.scatterPlot}\r\n     */\n    _chart.emptyOpacity = function (emptyOpacity) {\n        if (!arguments.length) {\n            return _emptyOpacity;\n        }\n        _emptyOpacity = emptyOpacity;\n        return _chart;\n    };\n\n    /**\r\n     * Set or get opacity for symbols when the group is not empty.\r\n     * @name nonemptyOpacity\r\n     * @memberof dc.scatterPlot\r\n     * @instance\r\n     * @param {Number} [nonemptyOpacity=1]\r\n     * @return {Number}\r\n     * @return {dc.scatterPlot}\r\n     */\n    _chart.nonemptyOpacity = function (nonemptyOpacity) {\n        if (!arguments.length) {\n            return _emptyOpacity;\n        }\n        _nonemptyOpacity = nonemptyOpacity;\n        return _chart;\n    };\n\n    _chart.legendables = function () {\n        return [{ chart: _chart, name: _chart._groupName, color: _chart.getColor() }];\n    };\n\n    _chart.legendHighlight = function (d) {\n        resizeSymbolsWhere(function (symbol) {\n            return symbol.attr('fill') === d.color;\n        }, _highlightedSize);\n        _chart.chartBodyG().selectAll('.chart-body path.symbol').filter(function () {\n            return _d.d3.select(this).attr('fill') !== d.color;\n        }).classed('fadeout', true);\n    };\n\n    _chart.legendReset = function (d) {\n        resizeSymbolsWhere(function (symbol) {\n            return symbol.attr('fill') === d.color;\n        }, _symbolSize);\n        _chart.chartBodyG().selectAll('.chart-body path.symbol').filter(function () {\n            return _d.d3.select(this).attr('fill') !== d.color;\n        }).classed('fadeout', false);\n    };\n\n    function resizeSymbolsWhere(condition, size) {\n        var symbols = _chart.chartBodyG().selectAll('.chart-body path.symbol').filter(function () {\n            return condition(_d.d3.select(this));\n        });\n        var oldSize = _symbol.size();\n        _symbol.size(Math.pow(size, 2));\n        dc.transition(symbols, _chart.transitionDuration(), _chart.transitionDelay()).attr('d', _symbol);\n        _symbol.size(oldSize);\n    }\n\n    _chart.createBrushHandlePaths = function () {\n        // no handle paths for poly-brushes\n    };\n\n    _chart.extendBrush = function (brushSelection) {\n        if (_chart.round()) {\n            brushSelection[0] = brushSelection[0].map(_chart.round());\n            brushSelection[1] = brushSelection[1].map(_chart.round());\n        }\n        return brushSelection;\n    };\n\n    _chart.brushIsEmpty = function (brushSelection) {\n        return !brushSelection || brushSelection[0][0] >= brushSelection[1][0] || brushSelection[0][1] >= brushSelection[1][1];\n    };\n\n    _chart._brushing = function () {\n        // Avoids infinite recursion (mutual recursion between range and focus operations)\n        // Source Event will be null when brush.move is called programmatically (see below as well).\n        if (!_d.d3.event.sourceEvent) {\n            return;\n        }\n\n        // Ignore event if recursive event - i.e. not directly generated by user action (like mouse/touch etc.)\n        // In this case we are more worried about this handler causing brush move programmatically which will\n        // cause this handler to be invoked again with a new d3.event (and current event set as sourceEvent)\n        // This check avoids recursive calls\n        if (_d.d3.event.sourceEvent.type && ['start', 'brush', 'end'].indexOf(_d.d3.event.sourceEvent.type) !== -1) {\n            return;\n        }\n\n        var brushSelection = _d.d3.event.selection;\n\n        // Testing with pixels is more reliable\n        var brushIsEmpty = _chart.brushIsEmpty(brushSelection);\n\n        if (brushSelection) {\n            brushSelection = brushSelection.map(function (point) {\n                return point.map(function (coord, i) {\n                    var scale = i === 0 ? _chart.x() : _chart.y();\n                    return scale.invert(coord);\n                });\n            });\n\n            brushSelection = _chart.extendBrush(brushSelection);\n\n            // The rounding process might have made brushSelection empty, so we need to recheck\n            brushIsEmpty = brushIsEmpty && _chart.brushIsEmpty(brushSelection);\n        }\n\n        _chart.redrawBrush(brushSelection, false);\n\n        var ranged2DFilter = brushIsEmpty ? null : dc.filters.RangedTwoDimensionalFilter(brushSelection);\n\n        dc.events.trigger(function () {\n            _chart.replaceFilter(ranged2DFilter);\n            _chart.redrawGroup();\n        }, dc.constants.EVENT_DELAY);\n    };\n\n    _chart.redrawBrush = function (brushSelection, doTransition) {\n        // override default x axis brush from parent chart\n        var _brush = _chart.brush();\n        var _gBrush = _chart.gBrush();\n\n        if (_chart.brushOn() && _gBrush) {\n            if (_chart.resizing()) {\n                _chart.setBrushExtents(doTransition);\n            }\n\n            if (!brushSelection) {\n                _gBrush.call(_brush.move, brushSelection);\n            } else {\n                brushSelection = brushSelection.map(function (point) {\n                    return point.map(function (coord, i) {\n                        var scale = i === 0 ? _chart.x() : _chart.y();\n                        return scale(coord);\n                    });\n                });\n\n                var gBrush = dc.optionalTransition(doTransition, _chart.transitionDuration(), _chart.transitionDelay())(_gBrush);\n\n                gBrush.call(_brush.move, brushSelection);\n            }\n        }\n\n        _chart.fadeDeselectedArea(brushSelection);\n    };\n\n    _chart.setBrushY = function (gBrush) {\n        gBrush.call(_chart.brush().y(_chart.y()));\n    };\n\n    return _chart.anchor(parent, chartGroup);\n};\n\n/**\r\n * A display of a single numeric value.\r\n * Unlike other charts, you do not need to set a dimension. Instead a group object must be provided and\r\n * a valueAccessor that returns a single value.\r\n * @class numberDisplay\r\n * @memberof dc\r\n * @mixes dc.baseMixin\r\n * @example\r\n * // create a number display under #chart-container1 element using the default global chart group\r\n * var display1 = dc.numberDisplay('#chart-container1');\r\n * @param {String|node|d3.selection} parent - Any valid\r\n * {@link https://github.com/d3/d3-selection/blob/master/README.md#select d3 single selector} specifying\r\n * a dom block element such as a div; or a dom element or d3 selection.\r\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\r\n * Interaction with a chart will only trigger events and redraws within the chart's group.\r\n * @returns {dc.numberDisplay}\r\n */\ndc.numberDisplay = function (parent, chartGroup) {\n    var SPAN_CLASS = 'number-display';\n    var _formatNumber = _d.d3.format('.2s');\n    var _chart = dc.baseMixin({});\n    var _html = { one: '', some: '', none: '' };\n    var _lastValue;\n\n    // dimension not required\n    _chart._mandatoryAttributes(['group']);\n\n    // default to ordering by value, to emulate old group.top(1) behavior when multiple groups\n    _chart.ordering(function (kv) {\n        return kv.value;\n    });\n\n    /**\r\n     * Gets or sets an optional object specifying HTML templates to use depending on the number\r\n     * displayed.  The text `%number` will be replaced with the current value.\r\n     * - one: HTML template to use if the number is 1\r\n     * - zero: HTML template to use if the number is 0\r\n     * - some: HTML template to use otherwise\r\n     * @method html\r\n     * @memberof dc.numberDisplay\r\n     * @instance\r\n     * @example\r\n     * numberWidget.html({\r\n     *      one:'%number record',\r\n     *      some:'%number records',\r\n     *      none:'no records'})\r\n     * @param {{one:String, some:String, none:String}} [html={one: '', some: '', none: ''}]\r\n     * @returns {{one:String, some:String, none:String}|dc.numberDisplay}\r\n     */\n    _chart.html = function (html) {\n        if (!arguments.length) {\n            return _html;\n        }\n        if (html.none) {\n            _html.none = html.none; //if none available\n        } else if (html.one) {\n            _html.none = html.one; //if none not available use one\n        } else if (html.some) {\n            _html.none = html.some; //if none and one not available use some\n        }\n        if (html.one) {\n            _html.one = html.one; //if one available\n        } else if (html.some) {\n            _html.one = html.some; //if one not available use some\n        }\n        if (html.some) {\n            _html.some = html.some; //if some available\n        } else if (html.one) {\n            _html.some = html.one; //if some not available use one\n        }\n        return _chart;\n    };\n\n    /**\r\n     * Calculate and return the underlying value of the display.\r\n     * @method value\r\n     * @memberof dc.numberDisplay\r\n     * @instance\r\n     * @returns {Number}\r\n     */\n    _chart.value = function () {\n        return _chart.data();\n    };\n\n    function maxBin(all) {\n        if (!all.length) {\n            return null;\n        }\n        var sorted = _chart._computeOrderedGroups(all);\n        return sorted[sorted.length - 1];\n    }\n    _chart.data(function (group) {\n        var valObj = group.value ? group.value() : maxBin(group.all());\n        return _chart.valueAccessor()(valObj);\n    });\n\n    _chart.transitionDuration(250); // good default\n    _chart.transitionDelay(0);\n\n    _chart._doRender = function () {\n        var newValue = _chart.value(),\n            span = _chart.selectAll('.' + SPAN_CLASS);\n\n        if (span.empty()) {\n            span = span.data([0]).enter().append('span').attr('class', SPAN_CLASS).merge(span);\n        }\n\n        span.transition().duration(_chart.transitionDuration()).delay(_chart.transitionDelay()).ease(_d.d3.easeQuad).tween('text', function () {\n            // [XA] don't try and interpolate from Infinity, else this breaks.\n            var interpStart = isFinite(_lastValue) ? _lastValue : 0;\n            var interp = _d.d3.interpolateNumber(interpStart || 0, newValue);\n            _lastValue = newValue;\n\n            // need to save it in D3v4\n            var node = this;\n            return function (t) {\n                var html = null,\n                    num = _chart.formatNumber()(interp(t));\n                if (newValue === 0 && _html.none !== '') {\n                    html = _html.none;\n                } else if (newValue === 1 && _html.one !== '') {\n                    html = _html.one;\n                } else if (_html.some !== '') {\n                    html = _html.some;\n                }\n                node.innerHTML = html ? html.replace('%number', num) : num;\n            };\n        });\n    };\n\n    _chart._doRedraw = function () {\n        return _chart._doRender();\n    };\n\n    /**\r\n     * Get or set a function to format the value for the display.\r\n     * @method formatNumber\r\n     * @memberof dc.numberDisplay\r\n     * @instance\r\n     * @see {@link https://github.com/d3/d3-format/blob/master/README.md#format d3.format}\r\n     * @param {Function} [formatter=d3.format('.2s')]\r\n     * @returns {Function|dc.numberDisplay}\r\n     */\n    _chart.formatNumber = function (formatter) {\n        if (!arguments.length) {\n            return _formatNumber;\n        }\n        _formatNumber = formatter;\n        return _chart;\n    };\n\n    return _chart.anchor(parent, chartGroup);\n};\n\n/**\r\n * A heat map is matrix that represents the values of two dimensions of data using colors.\r\n * @class heatMap\r\n * @memberof dc\r\n * @mixes dc.colorMixin\r\n * @mixes dc.marginMixin\r\n * @mixes dc.baseMixin\r\n * @example\r\n * // create a heat map under #chart-container1 element using the default global chart group\r\n * var heatMap1 = dc.heatMap('#chart-container1');\r\n * // create a heat map under #chart-container2 element using chart group A\r\n * var heatMap2 = dc.heatMap('#chart-container2', 'chartGroupA');\r\n * @param {String|node|d3.selection} parent - Any valid\r\n * {@link https://github.com/d3/d3-selection/blob/master/README.md#select d3 single selector} specifying\r\n * a dom block element such as a div; or a dom element or d3 selection.\r\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\r\n * Interaction with a chart will only trigger events and redraws within the chart's group.\r\n * @returns {dc.heatMap}\r\n */\ndc.heatMap = function (parent, chartGroup) {\n\n    var DEFAULT_BORDER_RADIUS = 6.75;\n\n    var _chartBody;\n\n    var _cols;\n    var _rows;\n    var _colOrdering = _d.d3.ascending;\n    var _rowOrdering = _d.d3.ascending;\n    var _colScale = _d.d3.scaleBand();\n    var _rowScale = _d.d3.scaleBand();\n\n    var _xBorderRadius = DEFAULT_BORDER_RADIUS;\n    var _yBorderRadius = DEFAULT_BORDER_RADIUS;\n\n    var _chart = dc.colorMixin(dc.marginMixin(dc.baseMixin({})));\n    _chart._mandatoryAttributes(['group']);\n    _chart.title(_chart.colorAccessor());\n\n    var _colsLabel = function _colsLabel(d) {\n        return d;\n    };\n    var _rowsLabel = function _rowsLabel(d) {\n        return d;\n    };\n\n    /**\r\n     * Set or get the column label function. The chart class uses this function to render\r\n     * column labels on the X axis. It is passed the column name.\r\n     * @method colsLabel\r\n     * @memberof dc.heatMap\r\n     * @instance\r\n     * @example\r\n     * // the default label function just returns the name\r\n     * chart.colsLabel(function(d) { return d; });\r\n     * @param  {Function} [labelFunction=function(d) { return d; }]\r\n     * @returns {Function|dc.heatMap}\r\n     */\n    _chart.colsLabel = function (labelFunction) {\n        if (!arguments.length) {\n            return _colsLabel;\n        }\n        _colsLabel = labelFunction;\n        return _chart;\n    };\n\n    /**\r\n     * Set or get the row label function. The chart class uses this function to render\r\n     * row labels on the Y axis. It is passed the row name.\r\n     * @method rowsLabel\r\n     * @memberof dc.heatMap\r\n     * @instance\r\n     * @example\r\n     * // the default label function just returns the name\r\n     * chart.rowsLabel(function(d) { return d; });\r\n     * @param  {Function} [labelFunction=function(d) { return d; }]\r\n     * @returns {Function|dc.heatMap}\r\n     */\n    _chart.rowsLabel = function (labelFunction) {\n        if (!arguments.length) {\n            return _rowsLabel;\n        }\n        _rowsLabel = labelFunction;\n        return _chart;\n    };\n\n    var _xAxisOnClick = function _xAxisOnClick(d) {\n        filterAxis(0, d);\n    };\n    var _yAxisOnClick = function _yAxisOnClick(d) {\n        filterAxis(1, d);\n    };\n    var _boxOnClick = function _boxOnClick(d) {\n        var filter = d.key;\n        dc.events.trigger(function () {\n            _chart.filter(filter);\n            _chart.redrawGroup();\n        });\n    };\n\n    function filterAxis(axis, value) {\n        var cellsOnAxis = _chart.selectAll('.box-group').filter(function (d) {\n            return d.key[axis] === value;\n        });\n        var unfilteredCellsOnAxis = cellsOnAxis.filter(function (d) {\n            return !_chart.hasFilter(d.key);\n        });\n        dc.events.trigger(function () {\n            var selection = unfilteredCellsOnAxis.empty() ? cellsOnAxis : unfilteredCellsOnAxis;\n            var filters = selection.data().map(function (kv) {\n                return dc.filters.TwoDimensionalFilter(kv.key);\n            });\n            _chart._filter([filters]);\n            _chart.redrawGroup();\n        });\n    }\n\n    dc.override(_chart, 'filter', function (filter) {\n        if (!arguments.length) {\n            return _chart._filter();\n        }\n\n        return _chart._filter(dc.filters.TwoDimensionalFilter(filter));\n    });\n\n    /**\r\n     * Gets or sets the values used to create the rows of the heatmap, as an array. By default, all\r\n     * the values will be fetched from the data using the value accessor.\r\n     * @method rows\r\n     * @memberof dc.heatMap\r\n     * @instance\r\n     * @param  {Array<String|Number>} [rows]\r\n     * @returns {Array<String|Number>|dc.heatMap}\r\n     */\n\n    _chart.rows = function (rows) {\n        if (!arguments.length) {\n            return _rows;\n        }\n        _rows = rows;\n        return _chart;\n    };\n\n    /**\r\n     #### .rowOrdering([orderFunction])\r\n     Get or set an accessor to order the rows.  Default is d3.ascending.\r\n     */\n    _chart.rowOrdering = function (_) {\n        if (!arguments.length) {\n            return _rowOrdering;\n        }\n        _rowOrdering = _;\n        return _chart;\n    };\n\n    /**\r\n     * Gets or sets the keys used to create the columns of the heatmap, as an array. By default, all\r\n     * the values will be fetched from the data using the key accessor.\r\n     * @method cols\r\n     * @memberof dc.heatMap\r\n     * @instance\r\n     * @param  {Array<String|Number>} [cols]\r\n     * @returns {Array<String|Number>|dc.heatMap}\r\n     */\n    _chart.cols = function (cols) {\n        if (!arguments.length) {\n            return _cols;\n        }\n        _cols = cols;\n        return _chart;\n    };\n\n    /**\r\n     #### .colOrdering([orderFunction])\r\n     Get or set an accessor to order the cols.  Default is ascending.\r\n     */\n    _chart.colOrdering = function (_) {\n        if (!arguments.length) {\n            return _colOrdering;\n        }\n        _colOrdering = _;\n        return _chart;\n    };\n\n    _chart._doRender = function () {\n        _chart.resetSvg();\n\n        _chartBody = _chart.svg().append('g').attr('class', 'heatmap').attr('transform', 'translate(' + _chart.margins().left + ',' + _chart.margins().top + ')');\n\n        return _chart._doRedraw();\n    };\n\n    _chart._doRedraw = function () {\n        var data = _chart.data(),\n            rows = _chart.rows() || data.map(_chart.valueAccessor()),\n            cols = _chart.cols() || data.map(_chart.keyAccessor());\n        if (_rowOrdering) {\n            rows = rows.sort(_rowOrdering);\n        }\n        if (_colOrdering) {\n            cols = cols.sort(_colOrdering);\n        }\n        rows = _rowScale.domain(rows);\n        cols = _colScale.domain(cols);\n\n        var rowCount = rows.domain().length,\n            colCount = cols.domain().length,\n            boxWidth = Math.floor(_chart.effectiveWidth() / colCount),\n            boxHeight = Math.floor(_chart.effectiveHeight() / rowCount);\n\n        cols.rangeRound([0, _chart.effectiveWidth()]);\n        rows.rangeRound([_chart.effectiveHeight(), 0]);\n\n        var boxes = _chartBody.selectAll('g.box-group').data(_chart.data(), function (d, i) {\n            return _chart.keyAccessor()(d, i) + '\\0' + _chart.valueAccessor()(d, i);\n        });\n\n        boxes.exit().remove();\n\n        var gEnter = boxes.enter().append('g').attr('class', 'box-group');\n\n        gEnter.append('rect').attr('class', 'heat-box').attr('fill', 'white').attr('x', function (d, i) {\n            return cols(_chart.keyAccessor()(d, i));\n        }).attr('y', function (d, i) {\n            return rows(_chart.valueAccessor()(d, i));\n        }).on('click', _chart.boxOnClick());\n\n        if (_chart.renderTitle()) {\n            gEnter.append('title');\n            boxes.select('title').text(_chart.title());\n        }\n\n        boxes = gEnter.merge(boxes);\n\n        dc.transition(boxes.select('rect'), _chart.transitionDuration(), _chart.transitionDelay()).attr('x', function (d, i) {\n            return cols(_chart.keyAccessor()(d, i));\n        }).attr('y', function (d, i) {\n            return rows(_chart.valueAccessor()(d, i));\n        }).attr('rx', _xBorderRadius).attr('ry', _yBorderRadius).attr('fill', _chart.getColor).attr('width', boxWidth).attr('height', boxHeight);\n\n        var gCols = _chartBody.select('g.cols');\n        if (gCols.empty()) {\n            gCols = _chartBody.append('g').attr('class', 'cols axis');\n        }\n        var gColsText = gCols.selectAll('text').data(cols.domain());\n\n        gColsText.exit().remove();\n\n        gColsText = gColsText.enter().append('text').attr('x', function (d) {\n            return cols(d) + boxWidth / 2;\n        }).style('text-anchor', 'middle').attr('y', _chart.effectiveHeight()).attr('dy', 12).on('click', _chart.xAxisOnClick()).text(_chart.colsLabel()).merge(gColsText);\n\n        dc.transition(gColsText, _chart.transitionDuration(), _chart.transitionDelay()).text(_chart.colsLabel()).attr('x', function (d) {\n            return cols(d) + boxWidth / 2;\n        }).attr('y', _chart.effectiveHeight());\n\n        var gRows = _chartBody.select('g.rows');\n        if (gRows.empty()) {\n            gRows = _chartBody.append('g').attr('class', 'rows axis');\n        }\n\n        var gRowsText = gRows.selectAll('text').data(rows.domain());\n\n        gRowsText.exit().remove();\n\n        gRowsText = gRowsText.enter().append('text').style('text-anchor', 'end').attr('x', 0).attr('dx', -2).attr('y', function (d) {\n            return rows(d) + boxHeight / 2;\n        }).attr('dy', 6).on('click', _chart.yAxisOnClick()).text(_chart.rowsLabel()).merge(gRowsText);\n\n        dc.transition(gRowsText, _chart.transitionDuration(), _chart.transitionDelay()).text(_chart.rowsLabel()).attr('y', function (d) {\n            return rows(d) + boxHeight / 2;\n        });\n\n        if (_chart.hasFilter()) {\n            _chart.selectAll('g.box-group').each(function (d) {\n                if (_chart.isSelectedNode(d)) {\n                    _chart.highlightSelected(this);\n                } else {\n                    _chart.fadeDeselected(this);\n                }\n            });\n        } else {\n            _chart.selectAll('g.box-group').each(function () {\n                _chart.resetHighlight(this);\n            });\n        }\n        return _chart;\n    };\n\n    /**\r\n     * Gets or sets the handler that fires when an individual cell is clicked in the heatmap.\r\n     * By default, filtering of the cell will be toggled.\r\n     * @method boxOnClick\r\n     * @memberof dc.heatMap\r\n     * @instance\r\n     * @example\r\n     * // default box on click handler\r\n     * chart.boxOnClick(function (d) {\r\n     *     var filter = d.key;\r\n     *     dc.events.trigger(function () {\r\n     *         _chart.filter(filter);\r\n     *         _chart.redrawGroup();\r\n     *     });\r\n     * });\r\n     * @param  {Function} [handler]\r\n     * @returns {Function|dc.heatMap}\r\n     */\n    _chart.boxOnClick = function (handler) {\n        if (!arguments.length) {\n            return _boxOnClick;\n        }\n        _boxOnClick = handler;\n        return _chart;\n    };\n\n    /**\r\n     * Gets or sets the handler that fires when a column tick is clicked in the x axis.\r\n     * By default, if any cells in the column are unselected, the whole column will be selected,\r\n     * otherwise the whole column will be unselected.\r\n     * @method xAxisOnClick\r\n     * @memberof dc.heatMap\r\n     * @instance\r\n     * @param  {Function} [handler]\r\n     * @returns {Function|dc.heatMap}\r\n     */\n    _chart.xAxisOnClick = function (handler) {\n        if (!arguments.length) {\n            return _xAxisOnClick;\n        }\n        _xAxisOnClick = handler;\n        return _chart;\n    };\n\n    /**\r\n     * Gets or sets the handler that fires when a row tick is clicked in the y axis.\r\n     * By default, if any cells in the row are unselected, the whole row will be selected,\r\n     * otherwise the whole row will be unselected.\r\n     * @method yAxisOnClick\r\n     * @memberof dc.heatMap\r\n     * @instance\r\n     * @param  {Function} [handler]\r\n     * @returns {Function|dc.heatMap}\r\n     */\n    _chart.yAxisOnClick = function (handler) {\n        if (!arguments.length) {\n            return _yAxisOnClick;\n        }\n        _yAxisOnClick = handler;\n        return _chart;\n    };\n\n    /**\r\n     * Gets or sets the X border radius.  Set to 0 to get full rectangles.\r\n     * @method xBorderRadius\r\n     * @memberof dc.heatMap\r\n     * @instance\r\n     * @param  {Number} [xBorderRadius=6.75]\r\n     * @returns {Number|dc.heatMap}\r\n     */\n    _chart.xBorderRadius = function (xBorderRadius) {\n        if (!arguments.length) {\n            return _xBorderRadius;\n        }\n        _xBorderRadius = xBorderRadius;\n        return _chart;\n    };\n\n    /**\r\n     * Gets or sets the Y border radius.  Set to 0 to get full rectangles.\r\n     * @method yBorderRadius\r\n     * @memberof dc.heatMap\r\n     * @instance\r\n     * @param  {Number} [yBorderRadius=6.75]\r\n     * @returns {Number|dc.heatMap}\r\n     */\n    _chart.yBorderRadius = function (yBorderRadius) {\n        if (!arguments.length) {\n            return _yBorderRadius;\n        }\n        _yBorderRadius = yBorderRadius;\n        return _chart;\n    };\n\n    _chart.isSelectedNode = function (d) {\n        return _chart.hasFilter(d.key);\n    };\n\n    return _chart.anchor(parent, chartGroup);\n};\n\n// https://github.com/d3/d3-plugins/blob/master/box/box.js\n// * Original source March 22, 2013\n// * Enhancements integrated on May 13, 2018 for dc.js library only\n\n// https://github.com/d3/d3-plugins/blob/master/LICENSE\n// Copyright (c) 2012-2015, Michael Bostock\n// All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// * Redistributions of source code must retain the above copyright notice, this\n//   list of conditions and the following disclaimer.\n//\n// * Redistributions in binary form must reproduce the above copyright notice,\n//   this list of conditions and the following disclaimer in the documentation\n//   and/or other materials provided with the distribution.\n//\n// * The name Michael Bostock may not be used to endorse or promote products\n//   derived from this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL MICHAEL BOSTOCK BE LIABLE FOR ANY DIRECT,\n// INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n// EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n(function () {\n\n    // Inspired by http://informationandvisualization.de/blog/box-plot\n    _d.d3.box = function () {\n        var width = 1,\n            height = 1,\n            duration = 0,\n            delay = 0,\n            domain = null,\n            value = Number,\n            whiskers = boxWhiskers,\n            quartiles = boxQuartiles,\n            tickFormat = null,\n\n\n        // Enhanced attributes\n        renderDataPoints = false,\n            dataRadius = 3,\n            dataOpacity = 0.3,\n            dataWidthPortion = 0.8,\n            renderTitle = false,\n            showOutliers = true,\n            boldOutlier = false;\n\n        // For each small multiple…\n        function box(g) {\n            /* jshint -W074 */\n            g.each(function (d, i) {\n                d = d.map(value).sort(_d.d3.ascending);\n                var g = _d.d3.select(this),\n                    n = d.length,\n                    min,\n                    max;\n\n                // Leave if there are no items.\n                if (n === 0) {\n                    return;\n                }\n\n                // Compute quartiles. Must return exactly 3 elements.\n                var quartileData = d.quartiles = quartiles(d);\n\n                // Compute whiskers. Must return exactly 2 elements, or null.\n                var whiskerIndices = whiskers && whiskers.call(this, d, i),\n                    whiskerData = whiskerIndices && whiskerIndices.map(function (i) {\n                    return d[i];\n                });\n\n                // Compute outliers. If no whiskers are specified, all data are 'outliers'.\n                // We compute the outliers as indices, so that we can join across transitions!\n                var outlierIndices = whiskerIndices ? _d.d3.range(0, whiskerIndices[0]).concat(_d.d3.range(whiskerIndices[1] + 1, n)) : _d.d3.range(n);\n\n                // Determine the maximum value based on if outliers are shown\n                if (showOutliers) {\n                    min = d[0];\n                    max = d[n - 1];\n                } else {\n                    min = d[whiskerIndices[0]];\n                    max = d[whiskerIndices[1]];\n                }\n                var pointIndices = _d.d3.range(whiskerIndices[0], whiskerIndices[1] + 1);\n\n                // Compute the new x-scale.\n                var x1 = _d.d3.scaleLinear().domain(domain && domain.call(this, d, i) || [min, max]).range([height, 0]);\n\n                // Retrieve the old x-scale, if this is an update.\n                var x0 = this.__chart__ || _d.d3.scaleLinear().domain([0, Infinity]).range(x1.range());\n\n                // Stash the new scale.\n                this.__chart__ = x1;\n\n                // Note: the box, median, and box tick elements are fixed in number,\n                // so we only have to handle enter and update. In contrast, the outliers\n                // and other elements are variable, so we need to exit them! Variable\n                // elements also fade in and out.\n\n                // Update center line: the vertical line spanning the whiskers.\n                var center = g.selectAll('line.center').data(whiskerData ? [whiskerData] : []);\n\n                center.enter().insert('line', 'rect').attr('class', 'center').attr('x1', width / 2).attr('y1', function (d) {\n                    return x0(d[0]);\n                }).attr('x2', width / 2).attr('y2', function (d) {\n                    return x0(d[1]);\n                }).style('opacity', 1e-6).transition().duration(duration).delay(delay).style('opacity', 1).attr('y1', function (d) {\n                    return x1(d[0]);\n                }).attr('y2', function (d) {\n                    return x1(d[1]);\n                });\n\n                center.transition().duration(duration).delay(delay).style('opacity', 1).attr('x1', width / 2).attr('x2', width / 2).attr('y1', function (d) {\n                    return x1(d[0]);\n                }).attr('y2', function (d) {\n                    return x1(d[1]);\n                });\n\n                center.exit().transition().duration(duration).delay(delay).style('opacity', 1e-6).attr('y1', function (d) {\n                    return x1(d[0]);\n                }).attr('y2', function (d) {\n                    return x1(d[1]);\n                }).remove();\n\n                // Update innerquartile box.\n                var box = g.selectAll('rect.box').data([quartileData]);\n\n                box.enter().append('rect').attr('class', 'box').attr('x', 0).attr('y', function (d) {\n                    return x0(d[2]);\n                }).attr('width', width).attr('height', function (d) {\n                    return x0(d[0]) - x0(d[2]);\n                }).style('fill-opacity', renderDataPoints ? 0.1 : 1).transition().duration(duration).delay(delay).attr('y', function (d) {\n                    return x1(d[2]);\n                }).attr('height', function (d) {\n                    return x1(d[0]) - x1(d[2]);\n                });\n\n                box.transition().duration(duration).delay(delay).attr('width', width).attr('y', function (d) {\n                    return x1(d[2]);\n                }).attr('height', function (d) {\n                    return x1(d[0]) - x1(d[2]);\n                });\n\n                // Update median line.\n                var medianLine = g.selectAll('line.median').data([quartileData[1]]);\n\n                medianLine.enter().append('line').attr('class', 'median').attr('x1', 0).attr('y1', x0).attr('x2', width).attr('y2', x0).transition().duration(duration).delay(delay).attr('y1', x1).attr('y2', x1);\n\n                medianLine.transition().duration(duration).delay(delay).attr('x1', 0).attr('x2', width).attr('y1', x1).attr('y2', x1);\n\n                // Update whiskers.\n                var whisker = g.selectAll('line.whisker').data(whiskerData || []);\n\n                whisker.enter().insert('line', 'circle, text').attr('class', 'whisker').attr('x1', 0).attr('y1', x0).attr('x2', width).attr('y2', x0).style('opacity', 1e-6).transition().duration(duration).delay(delay).attr('y1', x1).attr('y2', x1).style('opacity', 1);\n\n                whisker.transition().duration(duration).delay(delay).attr('x1', 0).attr('x2', width).attr('y1', x1).attr('y2', x1).style('opacity', 1);\n\n                whisker.exit().transition().duration(duration).delay(delay).attr('y1', x1).attr('y2', x1).style('opacity', 1e-6).remove();\n\n                // Update outliers.\n                if (showOutliers) {\n                    var outlierClass = boldOutlier ? 'outlierBold' : 'outlier';\n                    var outlierSize = boldOutlier ? 3 : 5;\n                    var outlierX = boldOutlier ? function () {\n                        return Math.floor(Math.random() * (width * dataWidthPortion) + 1 + (width - width * dataWidthPortion) / 2);\n                    } : function () {\n                        return width / 2;\n                    };\n\n                    var outlier = g.selectAll('circle.' + outlierClass).data(outlierIndices, Number);\n\n                    outlier.enter().insert('circle', 'text').attr('class', outlierClass).attr('r', outlierSize).attr('cx', outlierX).attr('cy', function (i) {\n                        return x0(d[i]);\n                    }).style('opacity', 1e-6).transition().duration(duration).delay(delay).attr('cy', function (i) {\n                        return x1(d[i]);\n                    }).style('opacity', 0.6);\n\n                    if (renderTitle) {\n                        outlier.selectAll('title').remove();\n                        outlier.append('title').text(function (i) {\n                            return d[i];\n                        });\n                    }\n\n                    outlier.transition().duration(duration).delay(delay).attr('cx', outlierX).attr('cy', function (i) {\n                        return x1(d[i]);\n                    }).style('opacity', 0.6);\n\n                    outlier.exit().transition().duration(duration).delay(delay).attr('cy', 0) //function (i) { return x1(d[i]); })\n                    .style('opacity', 1e-6).remove();\n                }\n\n                // Update Values\n                if (renderDataPoints) {\n                    var point = g.selectAll('circle.data').data(pointIndices);\n\n                    point.enter().insert('circle', 'text').attr('class', 'data').attr('r', dataRadius).attr('cx', function () {\n                        return Math.floor(Math.random() * (width * dataWidthPortion) + 1 + (width - width * dataWidthPortion) / 2);\n                    }).attr('cy', function (i) {\n                        return x0(d[i]);\n                    }).style('opacity', 1e-6).transition().duration(duration).delay(delay).attr('cy', function (i) {\n                        return x1(d[i]);\n                    }).style('opacity', dataOpacity);\n\n                    if (renderTitle) {\n                        point.selectAll('title').remove();\n                        point.append('title').text(function (i) {\n                            return d[i];\n                        });\n                    }\n\n                    point.transition().duration(duration).delay(delay).attr('cx', function () {\n                        return Math.floor(Math.random() * (width * dataWidthPortion) + 1 + (width - width * dataWidthPortion) / 2);\n                    }).attr('cy', function (i) {\n                        return x1(d[i]);\n                    }).style('opacity', dataOpacity);\n\n                    point.exit().transition().duration(duration).delay(delay).attr('cy', 0).style('opacity', 1e-6).remove();\n                }\n\n                // Compute the tick format.\n                var format = tickFormat || x1.tickFormat(8);\n\n                // Update box ticks.\n                var boxTick = g.selectAll('text.box').data(quartileData);\n\n                boxTick.enter().append('text').attr('class', 'box').attr('dy', '.3em').attr('dx', function (d, i) {\n                    return i & 1 ? 6 : -6;\n                }).attr('x', function (d, i) {\n                    return i & 1 ? width : 0;\n                }).attr('y', x0).attr('text-anchor', function (d, i) {\n                    return i & 1 ? 'start' : 'end';\n                }).text(format).transition().duration(duration).delay(delay).attr('y', x1);\n\n                boxTick.transition().duration(duration).delay(delay).text(format).attr('x', function (d, i) {\n                    return i & 1 ? width : 0;\n                }).attr('y', x1);\n\n                // Update whisker ticks. These are handled separately from the box\n                // ticks because they may or may not exist, and we want don't want\n                // to join box ticks pre-transition with whisker ticks post-.\n                var whiskerTick = g.selectAll('text.whisker').data(whiskerData || []);\n\n                whiskerTick.enter().append('text').attr('class', 'whisker').attr('dy', '.3em').attr('dx', 6).attr('x', width).attr('y', x0).text(format).style('opacity', 1e-6).transition().duration(duration).delay(delay).attr('y', x1).style('opacity', 1);\n\n                whiskerTick.transition().duration(duration).delay(delay).text(format).attr('x', width).attr('y', x1).style('opacity', 1);\n\n                whiskerTick.exit().transition().duration(duration).delay(delay).attr('y', x1).style('opacity', 1e-6).remove();\n\n                // Remove temporary quartiles element from within data array.\n                delete d.quartiles;\n            });\n            /* jshint +W074 */\n            _d.d3.timerFlush();\n        }\n\n        box.width = function (x) {\n            if (!arguments.length) {\n                return width;\n            }\n            width = x;\n            return box;\n        };\n\n        box.height = function (x) {\n            if (!arguments.length) {\n                return height;\n            }\n            height = x;\n            return box;\n        };\n\n        box.tickFormat = function (x) {\n            if (!arguments.length) {\n                return tickFormat;\n            }\n            tickFormat = x;\n            return box;\n        };\n\n        box.showOutliers = function (x) {\n            if (!arguments.length) {\n                return showOutliers;\n            }\n            showOutliers = x;\n            return box;\n        };\n\n        box.boldOutlier = function (x) {\n            if (!arguments.length) {\n                return boldOutlier;\n            }\n            boldOutlier = x;\n            return box;\n        };\n\n        box.renderDataPoints = function (x) {\n            if (!arguments.length) {\n                return renderDataPoints;\n            }\n            renderDataPoints = x;\n            return box;\n        };\n\n        box.renderTitle = function (x) {\n            if (!arguments.length) {\n                return renderTitle;\n            }\n            renderTitle = x;\n            return box;\n        };\n\n        box.dataOpacity = function (x) {\n            if (!arguments.length) {\n                return dataOpacity;\n            }\n            dataOpacity = x;\n            return box;\n        };\n\n        box.dataWidthPortion = function (x) {\n            if (!arguments.length) {\n                return dataWidthPortion;\n            }\n            dataWidthPortion = x;\n            return box;\n        };\n\n        box.duration = function (x) {\n            if (!arguments.length) {\n                return duration;\n            }\n            duration = x;\n            return box;\n        };\n\n        box.domain = function (x) {\n            if (!arguments.length) {\n                return domain;\n            }\n            domain = x === null ? x : typeof x === 'function' ? x : dc.utils.constant(x);\n            return box;\n        };\n\n        box.value = function (x) {\n            if (!arguments.length) {\n                return value;\n            }\n            value = x;\n            return box;\n        };\n\n        box.whiskers = function (x) {\n            if (!arguments.length) {\n                return whiskers;\n            }\n            whiskers = x;\n            return box;\n        };\n\n        box.quartiles = function (x) {\n            if (!arguments.length) {\n                return quartiles;\n            }\n            quartiles = x;\n            return box;\n        };\n\n        return box;\n    };\n\n    function boxWhiskers(d) {\n        return [0, d.length - 1];\n    }\n\n    function boxQuartiles(d) {\n        return [_d.d3.quantile(d, 0.25), _d.d3.quantile(d, 0.5), _d.d3.quantile(d, 0.75)];\n    }\n})();\n\n/**\r\n * A box plot is a chart that depicts numerical data via their quartile ranges.\r\n *\r\n * Examples:\r\n * - {@link http://dc-js.github.io/dc.js/examples/boxplot-basic.html Boxplot Basic example}\r\n * - {@link http://dc-js.github.io/dc.js/examples/boxplot-enhanced.html Boxplot Enhanced example}\r\n * - {@link http://dc-js.github.io/dc.js/examples/boxplot-render-data.html Boxplot Render Data example}\r\n * - {@link http://dc-js.github.io/dc.js/examples/boxplot-time.html Boxplot time example}\r\n * @class boxPlot\r\n * @memberof dc\r\n * @mixes dc.coordinateGridMixin\r\n * @example\r\n * // create a box plot under #chart-container1 element using the default global chart group\r\n * var boxPlot1 = dc.boxPlot('#chart-container1');\r\n * // create a box plot under #chart-container2 element using chart group A\r\n * var boxPlot2 = dc.boxPlot('#chart-container2', 'chartGroupA');\r\n * @param {String|node|d3.selection} parent - Any valid\r\n * {@link https://github.com/d3/d3-selection/blob/master/README.md#select d3 single selector} specifying\r\n * a dom block element such as a div; or a dom element or d3 selection.\r\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\r\n * Interaction with a chart will only trigger events and redraws within the chart's group.\r\n * @returns {dc.boxPlot}\r\n */\ndc.boxPlot = function (parent, chartGroup) {\n    var _chart = dc.coordinateGridMixin({});\n\n    // Returns a function to compute the interquartile range.\n    function DEFAULT_WHISKERS_IQR(k) {\n        return function (d) {\n            var q1 = d.quartiles[0],\n                q3 = d.quartiles[2],\n                iqr = (q3 - q1) * k,\n                i = -1,\n                j = d.length;\n            do {\n                ++i;\n            } while (d[i] < q1 - iqr);\n            do {\n                --j;\n            } while (d[j] > q3 + iqr);\n            return [i, j];\n        };\n    }\n\n    var _whiskerIqrFactor = 1.5;\n    var _whiskersIqr = DEFAULT_WHISKERS_IQR;\n    var _whiskers = _whiskersIqr(_whiskerIqrFactor);\n\n    var _box = _d.d3.box();\n    var _tickFormat = null;\n    var _renderDataPoints = false;\n    var _dataOpacity = 0.3;\n    var _dataWidthPortion = 0.8;\n    var _showOutliers = true;\n    var _boldOutlier = false;\n\n    // Used in yAxisMin and yAxisMax to add padding in pixel coordinates\n    // so the min and max data points/whiskers are within the chart\n    var _yRangePadding = 8;\n\n    var _boxWidth = function _boxWidth(innerChartWidth, xUnits) {\n        if (_chart.isOrdinal()) {\n            return _chart.x().bandwidth();\n        } else {\n            return innerChartWidth / (1 + _chart.boxPadding()) / xUnits;\n        }\n    };\n\n    // default to ordinal\n    _chart.x(_d.d3.scaleBand());\n    _chart.xUnits(dc.units.ordinal);\n\n    // valueAccessor should return an array of values that can be coerced into numbers\n    // or if data is overloaded for a static array of arrays, it should be `Number`.\n    // Empty arrays are not included.\n    _chart.data(function (group) {\n        return group.all().map(function (d) {\n            d.map = function (accessor) {\n                return accessor.call(d, d);\n            };\n            return d;\n        }).filter(function (d) {\n            var values = _chart.valueAccessor()(d);\n            return values.length !== 0;\n        });\n    });\n\n    /**\r\n     * Get or set the spacing between boxes as a fraction of box size. Valid values are within 0-1.\r\n     * See the {@link https://github.com/d3/d3-scale/blob/master/README.md#scaleBand d3 docs}\r\n     * for a visual description of how the padding is applied.\r\n     * @method boxPadding\r\n     * @memberof dc.boxPlot\r\n     * @instance\r\n     * @see {@link https://github.com/d3/d3-scale/blob/master/README.md#scaleBand d3.scaleBand}\r\n     * @param {Number} [padding=0.8]\r\n     * @returns {Number|dc.boxPlot}\r\n     */\n    _chart.boxPadding = _chart._rangeBandPadding;\n    _chart.boxPadding(0.8);\n\n    /**\r\n     * Get or set the outer padding on an ordinal box chart. This setting has no effect on non-ordinal charts\r\n     * or on charts with a custom {@link dc.boxPlot#boxWidth .boxWidth}. Will pad the width by\r\n     * `padding * barWidth` on each side of the chart.\r\n     * @method outerPadding\r\n     * @memberof dc.boxPlot\r\n     * @instance\r\n     * @param {Number} [padding=0.5]\r\n     * @returns {Number|dc.boxPlot}\r\n     */\n    _chart.outerPadding = _chart._outerRangeBandPadding;\n    _chart.outerPadding(0.5);\n\n    /**\r\n     * Get or set the numerical width of the boxplot box. The width may also be a function taking as\r\n     * parameters the chart width excluding the right and left margins, as well as the number of x\r\n     * units.\r\n     * @example\r\n     * // Using numerical parameter\r\n     * chart.boxWidth(10);\r\n     * // Using function\r\n     * chart.boxWidth((innerChartWidth, xUnits) { ... });\r\n     * @method boxWidth\r\n     * @memberof dc.boxPlot\r\n     * @instance\r\n     * @param {Number|Function} [boxWidth=0.5]\r\n     * @returns {Number|Function|dc.boxPlot}\r\n     */\n    _chart.boxWidth = function (boxWidth) {\n        if (!arguments.length) {\n            return _boxWidth;\n        }\n        _boxWidth = typeof boxWidth === 'function' ? boxWidth : dc.utils.constant(boxWidth);\n        return _chart;\n    };\n\n    var boxTransform = function boxTransform(d, i) {\n        var xOffset = _chart.x()(_chart.keyAccessor()(d, i));\n        return 'translate(' + xOffset + ', 0)';\n    };\n\n    _chart._preprocessData = function () {\n        if (_chart.elasticX()) {\n            _chart.x().domain([]);\n        }\n    };\n\n    _chart.plotData = function () {\n        var _calculatedBoxWidth = _boxWidth(_chart.effectiveWidth(), _chart.xUnitCount());\n\n        _box.whiskers(_whiskers).width(_calculatedBoxWidth).height(_chart.effectiveHeight()).value(_chart.valueAccessor()).domain(_chart.y().domain()).duration(_chart.transitionDuration()).tickFormat(_tickFormat).renderDataPoints(_renderDataPoints).dataOpacity(_dataOpacity).dataWidthPortion(_dataWidthPortion).renderTitle(_chart.renderTitle()).showOutliers(_showOutliers).boldOutlier(_boldOutlier);\n\n        var boxesG = _chart.chartBodyG().selectAll('g.box').data(_chart.data(), _chart.keyAccessor());\n\n        var boxesGEnterUpdate = renderBoxes(boxesG);\n        updateBoxes(boxesGEnterUpdate);\n        removeBoxes(boxesG);\n\n        _chart.fadeDeselectedArea(_chart.filter());\n    };\n\n    function renderBoxes(boxesG) {\n        var boxesGEnter = boxesG.enter().append('g');\n\n        boxesGEnter.attr('class', 'box').attr('transform', boxTransform).call(_box).on('click', function (d) {\n            _chart.filter(_chart.keyAccessor()(d));\n            _chart.redrawGroup();\n        });\n        return boxesGEnter.merge(boxesG);\n    }\n\n    function updateBoxes(boxesG) {\n        dc.transition(boxesG, _chart.transitionDuration(), _chart.transitionDelay()).attr('transform', boxTransform).call(_box).each(function (d) {\n            var color = _chart.getColor(d, 0);\n            _d.d3.select(this).select('rect.box').attr('fill', color);\n            _d.d3.select(this).selectAll('circle.data').attr('fill', color);\n        });\n    }\n\n    function removeBoxes(boxesG) {\n        boxesG.exit().remove().call(_box);\n    }\n\n    function minDataValue() {\n        return _d.d3.min(_chart.data(), function (e) {\n            return _d.d3.min(_chart.valueAccessor()(e));\n        });\n    }\n\n    function maxDataValue() {\n        return _d.d3.max(_chart.data(), function (e) {\n            return _d.d3.max(_chart.valueAccessor()(e));\n        });\n    }\n\n    function yAxisRangeRatio() {\n        return (maxDataValue() - minDataValue()) / _chart.effectiveHeight();\n    }\n\n    _chart.fadeDeselectedArea = function (brushSelection) {\n        if (_chart.hasFilter()) {\n            if (_chart.isOrdinal()) {\n                _chart.g().selectAll('g.box').each(function (d) {\n                    if (_chart.isSelectedNode(d)) {\n                        _chart.highlightSelected(this);\n                    } else {\n                        _chart.fadeDeselected(this);\n                    }\n                });\n            } else {\n                if (!(_chart.brushOn() || _chart.parentBrushOn())) {\n                    return;\n                }\n                var start = brushSelection[0];\n                var end = brushSelection[1];\n                var keyAccessor = _chart.keyAccessor();\n                _chart.g().selectAll('g.box').each(function (d) {\n                    var key = keyAccessor(d);\n                    if (key < start || key >= end) {\n                        _chart.fadeDeselected(this);\n                    } else {\n                        _chart.highlightSelected(this);\n                    }\n                });\n            }\n        } else {\n            _chart.g().selectAll('g.box').each(function () {\n                _chart.resetHighlight(this);\n            });\n        }\n    };\n\n    _chart.isSelectedNode = function (d) {\n        return _chart.hasFilter(_chart.keyAccessor()(d));\n    };\n\n    _chart.yAxisMin = function () {\n        var padding = _yRangePadding * yAxisRangeRatio();\n        return dc.utils.subtract(minDataValue() - padding, _chart.yAxisPadding());\n    };\n\n    _chart.yAxisMax = function () {\n        var padding = _yRangePadding * yAxisRangeRatio();\n        return dc.utils.add(maxDataValue() + padding, _chart.yAxisPadding());\n    };\n\n    /**\r\n     * Get or set the numerical format of the boxplot median, whiskers and quartile labels. Defaults\r\n     * to integer formatting.\r\n     * @example\r\n     * // format ticks to 2 decimal places\r\n     * chart.tickFormat(d3.format('.2f'));\r\n     * @method tickFormat\r\n     * @memberof dc.boxPlot\r\n     * @instance\r\n     * @param {Function} [tickFormat]\r\n     * @returns {Number|Function|dc.boxPlot}\r\n     */\n    _chart.tickFormat = function (tickFormat) {\n        if (!arguments.length) {\n            return _tickFormat;\n        }\n        _tickFormat = tickFormat;\n        return _chart;\n    };\n\n    /**\r\n     * Get or set the amount of padding to add, in pixel coordinates, to the top and\r\n     * bottom of the chart to accommodate box/whisker labels.\r\n     * @example\r\n     * // allow more space for a bigger whisker font\r\n     * chart.yRangePadding(12);\r\n     * @method yRangePadding\r\n     * @memberof dc.boxPlot\r\n     * @instance\r\n     * @param {Function} [yRangePadding = 8]\r\n     * @returns {Number|Function|dc.boxPlot}\r\n     */\n    _chart.yRangePadding = function (yRangePadding) {\n        if (!arguments.length) {\n            return _yRangePadding;\n        }\n        _yRangePadding = yRangePadding;\n        return _chart;\n    };\n\n    /**\r\n     * Get or set whether individual data points will be rendered.\r\n     * @example\r\n     * // Enable rendering of individual data points\r\n     * chart.renderDataPoints(true);\r\n     * @method renderDataPoints\r\n     * @memberof dc.boxPlot\r\n     * @instance\r\n     * @param {Boolean} [show=false]\r\n     * @returns {Boolean|dc.boxPlot}\r\n     */\n    _chart.renderDataPoints = function (show) {\n        if (!arguments.length) {\n            return _renderDataPoints;\n        }\n        _renderDataPoints = show;\n        return _chart;\n    };\n\n    /**\r\n     * Get or set the opacity when rendering data.\r\n     * @example\r\n     * // If individual data points are rendered increase the opacity.\r\n     * chart.dataOpacity(0.7);\r\n     * @method dataOpacity\r\n     * @memberof dc.boxPlot\r\n     * @instance\r\n     * @param {Number} [opacity=0.3]\r\n     * @returns {Number|dc.boxPlot}\r\n     */\n    _chart.dataOpacity = function (opacity) {\n        if (!arguments.length) {\n            return _dataOpacity;\n        }\n        _dataOpacity = opacity;\n        return _chart;\n    };\n\n    /**\r\n     * Get or set the portion of the width of the box to show data points.\r\n     * @example\r\n     * // If individual data points are rendered increase the data box.\r\n     * chart.dataWidthPortion(0.9);\r\n     * @method dataWidthPortion\r\n     * @memberof dc.boxPlot\r\n     * @instance\r\n     * @param {Number} [percentage=0.8]\r\n     * @returns {Number|dc.boxPlot}\r\n     */\n    _chart.dataWidthPortion = function (percentage) {\n        if (!arguments.length) {\n            return _dataWidthPortion;\n        }\n        _dataWidthPortion = percentage;\n        return _chart;\n    };\n\n    /**\r\n     * Get or set whether outliers will be rendered.\r\n     * @example\r\n     * // Disable rendering of outliers\r\n     * chart.showOutliers(false);\r\n     * @method showOutliers\r\n     * @memberof dc.boxPlot\r\n     * @instance\r\n     * @param {Boolean} [show=true]\r\n     * @returns {Boolean|dc.boxPlot}\r\n     */\n    _chart.showOutliers = function (show) {\n        if (!arguments.length) {\n            return _showOutliers;\n        }\n        _showOutliers = show;\n        return _chart;\n    };\n\n    /**\r\n     * Get or set whether outliers will be drawn bold.\r\n     * @example\r\n     * // If outliers are rendered display as bold\r\n     * chart.boldOutlier(true);\r\n     * @method boldOutlier\r\n     * @memberof dc.boxPlot\r\n     * @instance\r\n     * @param {Boolean} [show=false]\r\n     * @returns {Boolean|dc.boxPlot}\r\n     */\n    _chart.boldOutlier = function (show) {\n        if (!arguments.length) {\n            return _boldOutlier;\n        }\n        _boldOutlier = show;\n        return _chart;\n    };\n\n    return _chart.anchor(parent, chartGroup);\n};\n\n/**\r\n * The select menu is a simple widget designed to filter a dimension by selecting an option from\r\n * an HTML `<select/>` menu. The menu can be optionally turned into a multiselect.\r\n * @class selectMenu\r\n * @memberof dc\r\n * @mixes dc.baseMixin\r\n * @example\r\n * // create a select menu under #select-container using the default global chart group\r\n * var select = dc.selectMenu('#select-container')\r\n *                .dimension(states)\r\n *                .group(stateGroup);\r\n * // the option text can be set via the title() function\r\n * // by default the option text is '`key`: `value`'\r\n * select.title(function (d){\r\n *     return 'STATE: ' + d.key;\r\n * })\r\n * @param {String|node|d3.selection|dc.compositeChart} parent - Any valid\r\n * [d3 single selector](https://github.com/mbostock/d3/wiki/Selections#selecting-elements) specifying\r\n * a dom block element such as a div; or a dom element or d3 selection.\r\n * @param {String} [chartGroup] - The name of the chart group this widget should be placed in.\r\n * Interaction with the widget will only trigger events and redraws within its group.\r\n * @returns {selectMenu}\r\n **/\ndc.selectMenu = function (parent, chartGroup) {\n    var SELECT_CSS_CLASS = 'dc-select-menu';\n    var OPTION_CSS_CLASS = 'dc-select-option';\n\n    var _chart = dc.baseMixin({});\n\n    var _select;\n    var _promptText = 'Select all';\n    var _multiple = false;\n    var _promptValue = null;\n    var _numberVisible = null;\n    var _order = function _order(a, b) {\n        return _chart.keyAccessor()(a) > _chart.keyAccessor()(b) ? 1 : _chart.keyAccessor()(b) > _chart.keyAccessor()(a) ? -1 : 0;\n    };\n\n    var _filterDisplayed = function _filterDisplayed(d) {\n        return _chart.valueAccessor()(d) > 0;\n    };\n\n    _chart.data(function (group) {\n        return group.all().filter(_filterDisplayed);\n    });\n\n    _chart._doRender = function () {\n        _chart.select('select').remove();\n        _select = _chart.root().append('select').classed(SELECT_CSS_CLASS, true);\n        _select.append('option').text(_promptText).attr('value', '');\n\n        _chart._doRedraw();\n        return _chart;\n    };\n    // Fixing IE 11 crash when redrawing the chart\n    // see here for list of IE user Agents :\n    // http://www.useragentstring.com/pages/useragentstring.php?name=Internet+Explorer\n    var ua = window.navigator.userAgent;\n    // test for IE 11 but not a lower version (which contains MSIE in UA)\n    if (ua.indexOf('Trident/') > 0 && ua.indexOf('MSIE') === -1) {\n        _chart.redraw = _chart.render;\n    }\n\n    _chart._doRedraw = function () {\n        setAttributes();\n        renderOptions();\n        // select the option(s) corresponding to current filter(s)\n        if (_chart.hasFilter() && _multiple) {\n            _select.selectAll('option').property('selected', function (d) {\n                return typeof d !== 'undefined' && _chart.filters().indexOf(String(_chart.keyAccessor()(d))) >= 0;\n            });\n        } else if (_chart.hasFilter()) {\n            _select.property('value', _chart.filter());\n        } else {\n            _select.property('value', '');\n        }\n        return _chart;\n    };\n\n    function renderOptions() {\n        var options = _select.selectAll('option.' + OPTION_CSS_CLASS).data(_chart.data(), function (d) {\n            return _chart.keyAccessor()(d);\n        });\n\n        options.exit().remove();\n\n        options.enter().append('option').classed(OPTION_CSS_CLASS, true).attr('value', function (d) {\n            return _chart.keyAccessor()(d);\n        }).merge(options).text(_chart.title());\n\n        _select.selectAll('option.' + OPTION_CSS_CLASS).sort(_order);\n\n        _select.on('change', onChange);\n    }\n\n    function onChange(d, i) {\n        var values;\n        var target = _d.d3.event.target;\n        if (target.selectedOptions) {\n            var selectedOptions = Array.prototype.slice.call(target.selectedOptions);\n            values = selectedOptions.map(function (d) {\n                return d.value;\n            });\n        } else {\n            // IE and other browsers do not support selectedOptions\n            // adapted from this polyfill: https://gist.github.com/brettz9/4212217\n            var options = [].slice.call(_d.d3.event.target.options);\n            values = options.filter(function (option) {\n                return option.selected;\n            }).map(function (option) {\n                return option.value;\n            });\n        }\n        // console.log(values);\n        // check if only prompt option is selected\n        if (values.length === 1 && values[0] === '') {\n            values = _promptValue || null;\n        } else if (!_multiple && values.length === 1) {\n            values = values[0];\n        }\n        _chart.onChange(values);\n    }\n\n    _chart.onChange = function (val) {\n        if (val && _multiple) {\n            _chart.replaceFilter([val]);\n        } else if (val) {\n            _chart.replaceFilter(val);\n        } else {\n            _chart.filterAll();\n        }\n        dc.events.trigger(function () {\n            _chart.redrawGroup();\n        });\n    };\n\n    function setAttributes() {\n        if (_multiple) {\n            _select.attr('multiple', true);\n        } else {\n            _select.attr('multiple', null);\n        }\n        if (_numberVisible !== null) {\n            _select.attr('size', _numberVisible);\n        } else {\n            _select.attr('size', null);\n        }\n    }\n\n    /**\r\n     * Get or set the function that controls the ordering of option tags in the\r\n     * select menu. By default options are ordered by the group key in ascending\r\n     * order.\r\n     * @name order\r\n     * @memberof dc.selectMenu\r\n     * @instance\r\n     * @param {Function} [order]\r\n     * @example\r\n     * // order by the group's value\r\n     * chart.order(function (a,b) {\r\n     *     return a.value > b.value ? 1 : b.value > a.value ? -1 : 0;\r\n     * });\r\n     **/\n    _chart.order = function (order) {\n        if (!arguments.length) {\n            return _order;\n        }\n        _order = order;\n        return _chart;\n    };\n\n    /**\r\n     * Get or set the text displayed in the options used to prompt selection.\r\n     * @name promptText\r\n     * @memberof dc.selectMenu\r\n     * @instance\r\n     * @param {String} [promptText='Select all']\r\n     * @example\r\n     * chart.promptText('All states');\r\n     **/\n    _chart.promptText = function (_) {\n        if (!arguments.length) {\n            return _promptText;\n        }\n        _promptText = _;\n        return _chart;\n    };\n\n    /**\r\n     * Get or set the function that filters option tags prior to display. By default options\r\n     * with a value of < 1 are not displayed.\r\n     * @name filterDisplayed\r\n     * @memberof dc.selectMenu\r\n     * @instance\r\n     * @param {function} [filterDisplayed]\r\n     * @example\r\n     * // display all options override the `filterDisplayed` function:\r\n     * chart.filterDisplayed(function () {\r\n     *     return true;\r\n     * });\r\n     **/\n    _chart.filterDisplayed = function (filterDisplayed) {\n        if (!arguments.length) {\n            return _filterDisplayed;\n        }\n        _filterDisplayed = filterDisplayed;\n        return _chart;\n    };\n\n    /**\r\n     * Controls the type of select menu. Setting it to true converts the underlying\r\n     * HTML tag into a multiple select.\r\n     * @name multiple\r\n     * @memberof dc.selectMenu\r\n     * @instance\r\n     * @param {boolean} [multiple=false]\r\n     * @example\r\n     * chart.multiple(true);\r\n     **/\n    _chart.multiple = function (multiple) {\n        if (!arguments.length) {\n            return _multiple;\n        }\n        _multiple = multiple;\n\n        return _chart;\n    };\n\n    /**\r\n     * Controls the default value to be used for\r\n     * [dimension.filter](https://github.com/crossfilter/crossfilter/wiki/API-Reference#dimension_filter)\r\n     * when only the prompt value is selected. If `null` (the default), no filtering will occur when\r\n     * just the prompt is selected.\r\n     * @name promptValue\r\n     * @memberof dc.selectMenu\r\n     * @instance\r\n     * @param {?*} [promptValue=null]\r\n     **/\n    _chart.promptValue = function (promptValue) {\n        if (!arguments.length) {\n            return _promptValue;\n        }\n        _promptValue = promptValue;\n\n        return _chart;\n    };\n\n    /**\r\n     * Controls the number of items to show in the select menu, when `.multiple()` is true. This\r\n     * controls the [`size` attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/select#Attributes) of\r\n     * the `select` element. If `null` (the default), uses the browser's default height.\r\n     * @name numberItems\r\n     * @memberof dc.selectMenu\r\n     * @instance\r\n     * @param {?number} [numberVisible=null]\r\n     * @example\r\n     * chart.numberVisible(10);\r\n     **/\n    _chart.numberVisible = function (numberVisible) {\n        if (!arguments.length) {\n            return _numberVisible;\n        }\n        _numberVisible = numberVisible;\n\n        return _chart;\n    };\n\n    _chart.size = dc.logger.deprecate(_chart.numberVisible, 'selectMenu.size is ambiguous - use numberVisible instead');\n\n    return _chart.anchor(parent, chartGroup);\n};\n\n/**\r\n * Text Filter Widget\r\n *\r\n * The text filter widget is a simple widget designed to display an input field allowing to filter\r\n * data that matches the text typed.\r\n * As opposed to the other charts, this doesn't display any result and doesn't update its display,\r\n * it's just to input an filter other charts.\r\n *\r\n * @class textFilterWidget\r\n * @memberof dc\r\n * @mixes dc.baseMixin\r\n * @example\r\n *\r\n * var data = [{\"firstName\":\"John\",\"lastName\":\"Coltrane\"}{\"firstName\":\"Miles\",lastName:\"Davis\"}]\r\n * var ndx = crossfilter(data);\r\n * var dimension = ndx.dimension(function(d) {\r\n *     return d.lastName.toLowerCase() + ' ' + d.firstName.toLowerCase();\r\n * });\r\n *\r\n * dc.textFilterWidget('#search')\r\n *     .dimension(dimension);\r\n *     // you don't need the group() function\r\n *\r\n * @param {String|node|d3.selection|dc.compositeChart} parent - Any valid\r\n * {@link https://github.com/d3/d3-selection/blob/master/README.md#select d3 single selector}\r\n * specifying a dom block element such as a div; or a dom element or d3 selection.\r\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\r\n * Interaction with a chart will only trigger events and redraws within the chart's group.\r\n * @returns {dc.textFilterWidget}\r\n **/\n\ndc.textFilterWidget = function (parent, chartGroup) {\n    var INPUT_CSS_CLASS = 'dc-text-filter-input';\n\n    var _chart = dc.baseMixin({});\n\n    var _normalize = function _normalize(s) {\n        return s.toLowerCase();\n    };\n\n    var _filterFunctionFactory = function _filterFunctionFactory(query) {\n        query = _normalize(query);\n        return function (d) {\n            return _normalize(d).indexOf(query) !== -1;\n        };\n    };\n\n    var _placeHolder = 'search';\n\n    _chart.group(function () {\n        throw 'the group function on textFilterWidget should never be called, please report the issue';\n    });\n\n    _chart._doRender = function () {\n        _chart.select('input').remove();\n\n        var _input = _chart.root().append('input').classed(INPUT_CSS_CLASS, true);\n\n        _input.on('input', function () {\n            _chart.dimension().filterFunction(_filterFunctionFactory(this.value));\n            dc.events.trigger(function () {\n                dc.redrawAll();\n            }, dc.constants.EVENT_DELAY);\n        });\n\n        _chart._doRedraw();\n\n        return _chart;\n    };\n\n    _chart._doRedraw = function () {\n        _chart.root().selectAll('input').attr('placeholder', _placeHolder);\n\n        return _chart;\n    };\n\n    /**\r\n     * This function will be called on values before calling the filter function.\r\n     * @name normalize\r\n     * @memberof dc.textFilterWidget\r\n     * @instance\r\n     * @example\r\n     * // This is the default\r\n     * chart.normalize(function (s) {\r\n     *   return s.toLowerCase();\r\n     * });\r\n     * @param {function} [normalize]\r\n     * @returns {dc.textFilterWidget|function}\r\n     **/\n    _chart.normalize = function (normalize) {\n        if (!arguments.length) {\n            return _normalize;\n        }\n        _normalize = normalize;\n        return _chart;\n    };\n\n    /**\r\n     * Placeholder text in the search box.\r\n     * @name placeHolder\r\n     * @memberof dc.textFilterWidget\r\n     * @instance\r\n     * @example\r\n     * // This is the default\r\n     * chart.placeHolder('type to filter');\r\n     * @param {function} [placeHolder='search']\r\n     * @returns {dc.textFilterWidget|string}\r\n     **/\n    _chart.placeHolder = function (placeHolder) {\n        if (!arguments.length) {\n            return _placeHolder;\n        }\n        _placeHolder = placeHolder;\n        return _chart;\n    };\n\n    /**\r\n     * This function will be called with the search text, it needs to return a function that will be used to\r\n     * filter the data. The default function checks presence of the search text.\r\n     * @name filterFunctionFactory\r\n     * @memberof dc.textFilterWidget\r\n     * @instance\r\n     * @example\r\n     * // This is the default\r\n     * function (query) {\r\n     *     query = _normalize(query);\r\n     *     return function (d) {\r\n     *         return _normalize(d).indexOf(query) !== -1;\r\n     *     };\r\n     * };\r\n     * @param {function} [filterFunctionFactory]\r\n     * @returns {dc.textFilterWidget|function}\r\n     **/\n    _chart.filterFunctionFactory = function (filterFunctionFactory) {\n        if (!arguments.length) {\n            return _filterFunctionFactory;\n        }\n        _filterFunctionFactory = filterFunctionFactory;\n        return _chart;\n    };\n\n    return _chart.anchor(parent, chartGroup);\n};\n\n/**\r\n * The cboxMenu is a simple widget designed to filter a dimension by\r\n * selecting option(s) from a set of HTML `<input />` elements. The menu can be\r\n * made into a set of radio buttons (single select) or checkboxes (multiple).\r\n * @class cboxMenu\r\n * @memberof dc\r\n * @mixes dc.baseMixin\r\n * @example\r\n * // create a cboxMenu under #cbox-container using the default global chart group\r\n * var cbox = dc.cboxMenu('#cbox-container')\r\n *                .dimension(states)\r\n *                .group(stateGroup);\r\n * // the option text can be set via the title() function\r\n * // by default the option text is '`key`: `value`'\r\n * cbox.title(function (d){\r\n *     return 'STATE: ' + d.key;\r\n * })\r\n * @param {String|node|d3.selection|dc.compositeChart} parent - Any valid\r\n * [d3 single selector](https://github.com/mbostock/d3/wiki/Selections#selecting-elements) specifying\r\n * a dom block element such as a div; or a dom element or d3 selection.\r\n * @param {String} [chartGroup] - The name of the chart group this widget should be placed in.\r\n * Interaction with the widget will only trigger events and redraws within its group.\r\n * @returns {cboxMenu}\r\n **/\ndc.cboxMenu = function (parent, chartGroup) {\n    var GROUP_CSS_CLASS = 'dc-cbox-group';\n    var ITEM_CSS_CLASS = 'dc-cbox-item';\n\n    var _chart = dc.baseMixin({});\n\n    var _cbox;\n    var _promptText = 'Select all';\n    var _multiple = false;\n    var _inputType = 'radio';\n    var _promptValue = null;\n    // generate a random number to use as an ID\n    var _randVal = Math.floor(Math.random() * 100000) + 1;\n    var _order = function _order(a, b) {\n        return _chart.keyAccessor()(a) > _chart.keyAccessor()(b) ? 1 : _chart.keyAccessor()(b) > _chart.keyAccessor()(a) ? -1 : 0;\n    };\n\n    var _filterDisplayed = function _filterDisplayed(d) {\n        return _chart.valueAccessor()(d) > 0;\n    };\n\n    _chart.data(function (group) {\n        return group.all().filter(_filterDisplayed);\n    });\n\n    _chart._doRender = function () {\n        return _chart._doRedraw();\n    };\n    /*\r\n    // IS THIS NEEDED?\r\n    // Fixing IE 11 crash when redrawing the chart\r\n    // see here for list of IE user Agents :\r\n    // http://www.useragentstring.com/pages/useragentstring.php?name=Internet+Explorer\r\n    var ua = window.navigator.userAgent;\r\n    // test for IE 11 but not a lower version (which contains MSIE in UA)\r\n    if (ua.indexOf('Trident/') > 0 && ua.indexOf('MSIE') === -1) {\r\n        _chart.redraw = _chart.render;\r\n    }\r\n    */\n    _chart._doRedraw = function () {\n        _chart.select('ul').remove();\n        _cbox = _chart.root().append('ul').classed(GROUP_CSS_CLASS, true);\n        renderOptions();\n\n        if (_chart.hasFilter() && _multiple) {\n            _cbox.selectAll('input').property('checked', function (d) {\n                // adding `false` avoids failing test cases in phantomjs\n                return d && _chart.filters().indexOf(String(_chart.keyAccessor()(d))) >= 0 || false;\n            });\n        } else if (_chart.hasFilter()) {\n            _cbox.selectAll('input').property('checked', function (d) {\n                if (!d) {\n                    return false;\n                }\n                return _chart.keyAccessor()(d) === _chart.filter();\n            });\n        }\n        return _chart;\n    };\n\n    function renderOptions() {\n        var options = _cbox.selectAll('li.' + ITEM_CSS_CLASS).data(_chart.data(), function (d) {\n            return _chart.keyAccessor()(d);\n        });\n\n        options.exit().remove();\n\n        options = options.enter().append('li').classed(ITEM_CSS_CLASS, true).merge(options);\n\n        options.append('input').attr('type', _inputType).attr('value', function (d) {\n            return _chart.keyAccessor()(d);\n        }).attr('name', 'domain_' + _randVal).attr('id', function (d, i) {\n            return 'input_' + _randVal + '_' + i;\n        });\n        options.append('label').attr('for', function (d, i) {\n            return 'input_' + _randVal + '_' + i;\n        }).text(_chart.title());\n\n        // 'all' option\n        if (_multiple) {\n            _cbox.append('li').append('input').attr('type', 'reset').text(_promptText).on('click', onChange);\n        } else {\n            var li = _cbox.append('li');\n            li.append('input').attr('type', _inputType).attr('value', _promptValue).attr('name', 'domain_' + _randVal).attr('id', function (d, i) {\n                return 'input_' + _randVal + '_all';\n            }).property('checked', true);\n            li.append('label').attr('for', function (d, i) {\n                return 'input_' + _randVal + '_all';\n            }).text(_promptText);\n        }\n\n        _cbox.selectAll('li.' + ITEM_CSS_CLASS).sort(_order);\n\n        _cbox.on('change', onChange);\n        return options;\n    }\n\n    function onChange(d, i) {\n        var values,\n            target = _d.d3.select(_d.d3.event.target),\n            options;\n\n        if (!target.datum()) {\n            values = _promptValue || null;\n        } else {\n            options = _d.d3.select(this).selectAll('input').filter(function (o) {\n                if (o) {\n                    return this.checked;\n                }\n            });\n            values = options.nodes().map(function (option) {\n                return option.value;\n            });\n            // check if only prompt option is selected\n            if (!_multiple && values.length === 1) {\n                values = values[0];\n            }\n        }\n        _chart.onChange(values);\n    }\n\n    _chart.onChange = function (val) {\n        if (val && _multiple) {\n            _chart.replaceFilter([val]);\n        } else if (val) {\n            _chart.replaceFilter(val);\n        } else {\n            _chart.filterAll();\n        }\n        dc.events.trigger(function () {\n            _chart.redrawGroup();\n        });\n    };\n\n    /**\r\n     * Get or set the function that controls the ordering of option tags in the\r\n     * cbox menu. By default options are ordered by the group key in ascending\r\n     * order.\r\n     * @name order\r\n     * @memberof dc.cboxMenu\r\n     * @instance\r\n     * @param {Function} [order]\r\n     * @example\r\n     * // order by the group's value\r\n     * chart.order(function (a,b) {\r\n     *     return a.value > b.value ? 1 : b.value > a.value ? -1 : 0;\r\n     * });\r\n     **/\n    _chart.order = function (order) {\n        if (!arguments.length) {\n            return _order;\n        }\n        _order = order;\n        return _chart;\n    };\n\n    /**\r\n     * Get or set the text displayed in the options used to prompt selection.\r\n     * @name promptText\r\n     * @memberof dc.cboxMenu\r\n     * @instance\r\n     * @param {String} [promptText='Select all']\r\n     * @example\r\n     * chart.promptText('All states');\r\n     **/\n    _chart.promptText = function (_) {\n        if (!arguments.length) {\n            return _promptText;\n        }\n        _promptText = _;\n        return _chart;\n    };\n\n    /**\r\n     * Get or set the function that filters options prior to display. By default options\r\n     * with a value of < 1 are not displayed.\r\n     * @name filterDisplayed\r\n     * @memberof dc.cboxMenu\r\n     * @instance\r\n     * @param {function} [filterDisplayed]\r\n     * @example\r\n     * // display all options override the `filterDisplayed` function:\r\n     * chart.filterDisplayed(function () {\r\n     *     return true;\r\n     * });\r\n     **/\n    _chart.filterDisplayed = function (filterDisplayed) {\n        if (!arguments.length) {\n            return _filterDisplayed;\n        }\n        _filterDisplayed = filterDisplayed;\n        return _chart;\n    };\n\n    /**\r\n     * Controls the type of input element. Setting it to true converts\r\n     * the HTML `input` tags from radio buttons to checkboxes.\r\n     * @name multiple\r\n     * @memberof dc.cboxMenu\r\n     * @instance\r\n     * @param {boolean} [multiple=false]\r\n     * @example\r\n     * chart.multiple(true);\r\n     **/\n    _chart.multiple = function (multiple) {\n        if (!arguments.length) {\n            return _multiple;\n        }\n        _multiple = multiple;\n        if (_multiple) {\n            _inputType = 'checkbox';\n        } else {\n            _inputType = 'radio';\n        }\n        return _chart;\n    };\n\n    /**\r\n     * Controls the default value to be used for\r\n     * [dimension.filter](https://github.com/crossfilter/crossfilter/wiki/API-Reference#dimension_filter)\r\n     * when only the prompt value is selected. If `null` (the default), no filtering will occur when\r\n     * just the prompt is selected.\r\n     * @name promptValue\r\n     * @memberof dc.cboxMenu\r\n     * @instance\r\n     * @param {?*} [promptValue=null]\r\n     **/\n    _chart.promptValue = function (promptValue) {\n        if (!arguments.length) {\n            return _promptValue;\n        }\n        _promptValue = promptValue;\n\n        return _chart;\n    };\n\n    return _chart.anchor(parent, chartGroup);\n};\n\n// Renamed functions\n\ndc.abstractBubbleChart = dc.bubbleMixin;\ndc.baseChart = dc.baseMixin;\ndc.capped = dc.capMixin;\ndc.colorChart = dc.colorMixin;\ndc.coordinateGridChart = dc.coordinateGridMixin;\ndc.marginable = dc.marginMixin;\ndc.stackableChart = dc.stackMixin;\n\n// Expose d3 and crossfilter, so that clients in browserify\n// case can obtain them if they need them.\ndc.d3 = _d.d3;\ndc.crossfilter = _crossfilter.crossfilter;\n\nexports.dc = dc;\n\n//# sourceMappingURL=dc.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdmVuZG9yL2RjLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3NyYy92ZW5kb3IvZGMuanM/NjU1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcclxuICogIGRjIDMuMC42XHJcbiAqICBodHRwOi8vZGMtanMuZ2l0aHViLmlvL2RjLmpzL1xyXG4gKiAgQ29weXJpZ2h0IDIwMTItMjAxNiBOaWNrIFpodSAmIHRoZSBkYy5qcyBEZXZlbG9wZXJzXHJcbiAqICBodHRwczovL2dpdGh1Yi5jb20vZGMtanMvZGMuanMvYmxvYi9tYXN0ZXIvQVVUSE9SU1xyXG4gKlxyXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiAgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG4vKipcclxuICogVGhlIGVudGlyZSBkYy5qcyBsaWJyYXJ5IGlzIHNjb3BlZCB1bmRlciB0aGUgKipkYyoqIG5hbWUgc3BhY2UuIEl0IGRvZXMgbm90IGludHJvZHVjZVxyXG4gKiBhbnl0aGluZyBlbHNlIGludG8gdGhlIGdsb2JhbCBuYW1lIHNwYWNlLlxyXG4gKlxyXG4gKiBNb3N0IGBkY2AgZnVuY3Rpb25zIGFyZSBkZXNpZ25lZCB0byBhbGxvdyBmdW5jdGlvbiBjaGFpbmluZywgbWVhbmluZyB0aGV5IHJldHVybiB0aGUgY3VycmVudCBjaGFydFxyXG4gKiBpbnN0YW5jZSB3aGVuZXZlciBpdCBpcyBhcHByb3ByaWF0ZS4gIFRoZSBnZXR0ZXIgZm9ybXMgb2YgZnVuY3Rpb25zIGRvIG5vdCBwYXJ0aWNpcGF0ZSBpbiBmdW5jdGlvblxyXG4gKiBjaGFpbmluZyBiZWNhdXNlIHRoZXkgcmV0dXJuIHZhbHVlcyB0aGF0IGFyZSBub3QgdGhlIGNoYXJ0LCBhbHRob3VnaCBzb21lLFxyXG4gKiBzdWNoIGFzIHtAbGluayBkYy5iYXNlTWl4aW4jc3ZnIC5zdmd9IGFuZCB7QGxpbmsgZGMuY29vcmRpbmF0ZUdyaWRNaXhpbiN4QXhpcyAueEF4aXN9LFxyXG4gKiByZXR1cm4gdmFsdWVzIHRoYXQgYXJlIHRoZW1zZWx2ZXMgY2hhaW5hYmxlIGQzIG9iamVjdHMuXHJcbiAqIEBuYW1lc3BhY2UgZGNcclxuICogQHZlcnNpb24gMy4wLjZcclxuICogQGV4YW1wbGVcclxuICogLy8gRXhhbXBsZSBjaGFpbmluZ1xyXG4gKiBjaGFydC53aWR0aCgzMDApXHJcbiAqICAgICAgLmhlaWdodCgzMDApXHJcbiAqICAgICAgLmZpbHRlcignc3VuZGF5Jyk7XHJcbiAqL1xyXG4vKmpzaGludCAtVzA3OSovXHJcbmltcG9ydCB7Y3Jvc3NmaWx0ZXJ9IGZyb20gXCIuL2Nyb3NzZmlsdGVyLmpzXCI7XHJcbmltcG9ydCB7ZDN9IGZyb20gXCIuL2QzLmpzXCI7XHJcblxyXG52YXIgZGMgPSB7XHJcbiAgICB2ZXJzaW9uOiAnMy4wLjYnLFxyXG4gICAgY29uc3RhbnRzOiB7XHJcbiAgICAgICAgQ0hBUlRfQ0xBU1M6ICdkYy1jaGFydCcsXHJcbiAgICAgICAgREVCVUdfR1JPVVBfQ0xBU1M6ICdkZWJ1ZycsXHJcbiAgICAgICAgU1RBQ0tfQ0xBU1M6ICdzdGFjaycsXHJcbiAgICAgICAgREVTRUxFQ1RFRF9DTEFTUzogJ2Rlc2VsZWN0ZWQnLFxyXG4gICAgICAgIFNFTEVDVEVEX0NMQVNTOiAnc2VsZWN0ZWQnLFxyXG4gICAgICAgIE5PREVfSU5ERVhfTkFNRTogJ19faW5kZXhfXycsXHJcbiAgICAgICAgR1JPVVBfSU5ERVhfTkFNRTogJ19fZ3JvdXBfaW5kZXhfXycsXHJcbiAgICAgICAgREVGQVVMVF9DSEFSVF9HUk9VUDogJ19fZGVmYXVsdF9jaGFydF9ncm91cF9fJyxcclxuICAgICAgICBFVkVOVF9ERUxBWTogNDAsXHJcbiAgICAgICAgTkVHTElHSUJMRV9OVU1CRVI6IDFlLTEwXHJcbiAgICB9LFxyXG4gICAgX3JlbmRlcmxldDogbnVsbFxyXG59O1xyXG4vKmpzaGludCArVzA3OSovXHJcblxyXG4vKipcclxuICogVGhlIGRjLmNoYXJ0UmVnaXN0cnkgb2JqZWN0IG1haW50YWlucyBzZXRzIG9mIGFsbCBpbnN0YW50aWF0ZWQgZGMuanMgY2hhcnRzIHVuZGVyIG5hbWVkIGdyb3Vwc1xyXG4gKiBhbmQgdGhlIGRlZmF1bHQgZ3JvdXAuXHJcbiAqXHJcbiAqIEEgY2hhcnQgZ3JvdXAgb2Z0ZW4gY29ycmVzcG9uZHMgdG8gYSBjcm9zc2ZpbHRlciBpbnN0YW5jZS4gSXQgc3BlY2lmaWVzXHJcbiAqIHRoZSBzZXQgb2YgY2hhcnRzIHdoaWNoIHNob3VsZCBiZSB1cGRhdGVkIHdoZW4gYSBmaWx0ZXIgY2hhbmdlcyBvbiBvbmUgb2YgdGhlIGNoYXJ0cyBvciB3aGVuIHRoZVxyXG4gKiBnbG9iYWwgZnVuY3Rpb25zIHtAbGluayBkYy5maWx0ZXJBbGwgZGMuZmlsdGVyQWxsfSwge0BsaW5rIGRjLnJlZm9jdXNBbGwgZGMucmVmb2N1c0FsbH0sXHJcbiAqIHtAbGluayBkYy5yZW5kZXJBbGwgZGMucmVuZGVyQWxsfSwge0BsaW5rIGRjLnJlZHJhd0FsbCBkYy5yZWRyYXdBbGx9LCBvciBjaGFydCBmdW5jdGlvbnNcclxuICoge0BsaW5rIGRjLmJhc2VNaXhpbiNyZW5kZXJHcm91cCBiYXNlTWl4aW4ucmVuZGVyR3JvdXB9LFxyXG4gKiB7QGxpbmsgZGMuYmFzZU1peGluI3JlZHJhd0dyb3VwIGJhc2VNaXhpbi5yZWRyYXdHcm91cH0gYXJlIGNhbGxlZC5cclxuICpcclxuICogQG5hbWVzcGFjZSBjaGFydFJlZ2lzdHJ5XHJcbiAqIEBtZW1iZXJvZiBkY1xyXG4gKiBAdHlwZSB7e2hhcywgcmVnaXN0ZXIsIGRlcmVnaXN0ZXIsIGNsZWFyLCBsaXN0fX1cclxuICovXHJcbmRjLmNoYXJ0UmVnaXN0cnkgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gY2hhcnRHcm91cDpzdHJpbmcgPT4gY2hhcnRzOmFycmF5XHJcbiAgICB2YXIgX2NoYXJ0TWFwID0ge307XHJcblxyXG4gICAgZnVuY3Rpb24gaW5pdGlhbGl6ZUNoYXJ0R3JvdXAgKGdyb3VwKSB7XHJcbiAgICAgICAgaWYgKCFncm91cCkge1xyXG4gICAgICAgICAgICBncm91cCA9IGRjLmNvbnN0YW50cy5ERUZBVUxUX0NIQVJUX0dST1VQO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFfY2hhcnRNYXBbZ3JvdXBdKSB7XHJcbiAgICAgICAgICAgIF9jaGFydE1hcFtncm91cF0gPSBbXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBncm91cDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERldGVybWluZSBpZiBhIGdpdmVuIGNoYXJ0IGluc3RhbmNlIHJlc2lkZXMgaW4gYW55IGdyb3VwIGluIHRoZSByZWdpc3RyeS5cclxuICAgICAgICAgKiBAbWV0aG9kIGhhc1xyXG4gICAgICAgICAqIEBtZW1iZXJvZiBkYy5jaGFydFJlZ2lzdHJ5XHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNoYXJ0IGRjLmpzIGNoYXJ0IGluc3RhbmNlXHJcbiAgICAgICAgICogQHJldHVybnMge0Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaGFzOiBmdW5jdGlvbiAoY2hhcnQpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgZSBpbiBfY2hhcnRNYXApIHtcclxuICAgICAgICAgICAgICAgIGlmIChfY2hhcnRNYXBbZV0uaW5kZXhPZihjaGFydCkgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGQgZ2l2ZW4gY2hhcnQgaW5zdGFuY2UgdG8gdGhlIGdpdmVuIGdyb3VwLCBjcmVhdGluZyB0aGUgZ3JvdXAgaWYgbmVjZXNzYXJ5LlxyXG4gICAgICAgICAqIElmIG5vIGdyb3VwIGlzIHByb3ZpZGVkLCB0aGUgZGVmYXVsdCBncm91cCBgZGMuY29uc3RhbnRzLkRFRkFVTFRfQ0hBUlRfR1JPVVBgIHdpbGwgYmUgdXNlZC5cclxuICAgICAgICAgKiBAbWV0aG9kIHJlZ2lzdGVyXHJcbiAgICAgICAgICogQG1lbWJlcm9mIGRjLmNoYXJ0UmVnaXN0cnlcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2hhcnQgZGMuanMgY2hhcnQgaW5zdGFuY2VcclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2dyb3VwXSBHcm91cCBuYW1lXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmVnaXN0ZXI6IGZ1bmN0aW9uIChjaGFydCwgZ3JvdXApIHtcclxuICAgICAgICAgICAgZ3JvdXAgPSBpbml0aWFsaXplQ2hhcnRHcm91cChncm91cCk7XHJcbiAgICAgICAgICAgIF9jaGFydE1hcFtncm91cF0ucHVzaChjaGFydCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVtb3ZlIGdpdmVuIGNoYXJ0IGluc3RhbmNlIGZyb20gdGhlIGdpdmVuIGdyb3VwLCBjcmVhdGluZyB0aGUgZ3JvdXAgaWYgbmVjZXNzYXJ5LlxyXG4gICAgICAgICAqIElmIG5vIGdyb3VwIGlzIHByb3ZpZGVkLCB0aGUgZGVmYXVsdCBncm91cCBgZGMuY29uc3RhbnRzLkRFRkFVTFRfQ0hBUlRfR1JPVVBgIHdpbGwgYmUgdXNlZC5cclxuICAgICAgICAgKiBAbWV0aG9kIGRlcmVnaXN0ZXJcclxuICAgICAgICAgKiBAbWVtYmVyb2YgZGMuY2hhcnRSZWdpc3RyeVxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjaGFydCBkYy5qcyBjaGFydCBpbnN0YW5jZVxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbZ3JvdXBdIEdyb3VwIG5hbWVcclxuICAgICAgICAgKi9cclxuICAgICAgICBkZXJlZ2lzdGVyOiBmdW5jdGlvbiAoY2hhcnQsIGdyb3VwKSB7XHJcbiAgICAgICAgICAgIGdyb3VwID0gaW5pdGlhbGl6ZUNoYXJ0R3JvdXAoZ3JvdXApO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9jaGFydE1hcFtncm91cF0ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChfY2hhcnRNYXBbZ3JvdXBdW2ldLmFuY2hvck5hbWUoKSA9PT0gY2hhcnQuYW5jaG9yTmFtZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2NoYXJ0TWFwW2dyb3VwXS5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDbGVhciBnaXZlbiBncm91cCBpZiBvbmUgaXMgcHJvdmlkZWQsIG90aGVyd2lzZSBjbGVhcnMgYWxsIGdyb3Vwcy5cclxuICAgICAgICAgKiBAbWV0aG9kIGNsZWFyXHJcbiAgICAgICAgICogQG1lbWJlcm9mIGRjLmNoYXJ0UmVnaXN0cnlcclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZ3JvdXAgR3JvdXAgbmFtZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsZWFyOiBmdW5jdGlvbiAoZ3JvdXApIHtcclxuICAgICAgICAgICAgaWYgKGdyb3VwKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgX2NoYXJ0TWFwW2dyb3VwXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIF9jaGFydE1hcCA9IHt9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IGFuIGFycmF5IG9mIGVhY2ggY2hhcnQgaW5zdGFuY2UgaW4gdGhlIGdpdmVuIGdyb3VwLlxyXG4gICAgICAgICAqIElmIG5vIGdyb3VwIGlzIHByb3ZpZGVkLCB0aGUgY2hhcnRzIGluIHRoZSBkZWZhdWx0IGdyb3VwIGFyZSByZXR1cm5lZC5cclxuICAgICAgICAgKiBAbWV0aG9kIGxpc3RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgZGMuY2hhcnRSZWdpc3RyeVxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbZ3JvdXBdIEdyb3VwIG5hbWVcclxuICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXk8T2JqZWN0Pn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBsaXN0OiBmdW5jdGlvbiAoZ3JvdXApIHtcclxuICAgICAgICAgICAgZ3JvdXAgPSBpbml0aWFsaXplQ2hhcnRHcm91cChncm91cCk7XHJcbiAgICAgICAgICAgIHJldHVybiBfY2hhcnRNYXBbZ3JvdXBdO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn0pKCk7XHJcblxyXG4vKipcclxuICogQWRkIGdpdmVuIGNoYXJ0IGluc3RhbmNlIHRvIHRoZSBnaXZlbiBncm91cCwgY3JlYXRpbmcgdGhlIGdyb3VwIGlmIG5lY2Vzc2FyeS5cclxuICogSWYgbm8gZ3JvdXAgaXMgcHJvdmlkZWQsIHRoZSBkZWZhdWx0IGdyb3VwIGBkYy5jb25zdGFudHMuREVGQVVMVF9DSEFSVF9HUk9VUGAgd2lsbCBiZSB1c2VkLlxyXG4gKiBAbWVtYmVyb2YgZGNcclxuICogQG1ldGhvZCByZWdpc3RlckNoYXJ0XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBjaGFydCBkYy5qcyBjaGFydCBpbnN0YW5jZVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gW2dyb3VwXSBHcm91cCBuYW1lXHJcbiAqL1xyXG5kYy5yZWdpc3RlckNoYXJ0ID0gZnVuY3Rpb24gKGNoYXJ0LCBncm91cCkge1xyXG4gICAgZGMuY2hhcnRSZWdpc3RyeS5yZWdpc3RlcihjaGFydCwgZ3JvdXApO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSBnaXZlbiBjaGFydCBpbnN0YW5jZSBmcm9tIHRoZSBnaXZlbiBncm91cCwgY3JlYXRpbmcgdGhlIGdyb3VwIGlmIG5lY2Vzc2FyeS5cclxuICogSWYgbm8gZ3JvdXAgaXMgcHJvdmlkZWQsIHRoZSBkZWZhdWx0IGdyb3VwIGBkYy5jb25zdGFudHMuREVGQVVMVF9DSEFSVF9HUk9VUGAgd2lsbCBiZSB1c2VkLlxyXG4gKiBAbWVtYmVyb2YgZGNcclxuICogQG1ldGhvZCBkZXJlZ2lzdGVyQ2hhcnRcclxuICogQHBhcmFtIHtPYmplY3R9IGNoYXJ0IGRjLmpzIGNoYXJ0IGluc3RhbmNlXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbZ3JvdXBdIEdyb3VwIG5hbWVcclxuICovXHJcbmRjLmRlcmVnaXN0ZXJDaGFydCA9IGZ1bmN0aW9uIChjaGFydCwgZ3JvdXApIHtcclxuICAgIGRjLmNoYXJ0UmVnaXN0cnkuZGVyZWdpc3RlcihjaGFydCwgZ3JvdXApO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIERldGVybWluZSBpZiBhIGdpdmVuIGNoYXJ0IGluc3RhbmNlIHJlc2lkZXMgaW4gYW55IGdyb3VwIGluIHRoZSByZWdpc3RyeS5cclxuICogQG1lbWJlcm9mIGRjXHJcbiAqIEBtZXRob2QgaGFzQ2hhcnRcclxuICogQHBhcmFtIHtPYmplY3R9IGNoYXJ0IGRjLmpzIGNoYXJ0IGluc3RhbmNlXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gKi9cclxuZGMuaGFzQ2hhcnQgPSBmdW5jdGlvbiAoY2hhcnQpIHtcclxuICAgIHJldHVybiBkYy5jaGFydFJlZ2lzdHJ5LmhhcyhjaGFydCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2xlYXIgZ2l2ZW4gZ3JvdXAgaWYgb25lIGlzIHByb3ZpZGVkLCBvdGhlcndpc2UgY2xlYXJzIGFsbCBncm91cHMuXHJcbiAqIEBtZW1iZXJvZiBkY1xyXG4gKiBAbWV0aG9kIGRlcmVnaXN0ZXJBbGxDaGFydHNcclxuICogQHBhcmFtIHtTdHJpbmd9IGdyb3VwIEdyb3VwIG5hbWVcclxuICovXHJcbmRjLmRlcmVnaXN0ZXJBbGxDaGFydHMgPSBmdW5jdGlvbiAoZ3JvdXApIHtcclxuICAgIGRjLmNoYXJ0UmVnaXN0cnkuY2xlYXIoZ3JvdXApO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENsZWFyIGFsbCBmaWx0ZXJzIG9uIGFsbCBjaGFydHMgd2l0aGluIHRoZSBnaXZlbiBjaGFydCBncm91cC4gSWYgdGhlIGNoYXJ0IGdyb3VwIGlzIG5vdCBnaXZlbiB0aGVuXHJcbiAqIG9ubHkgY2hhcnRzIHRoYXQgYmVsb25nIHRvIHRoZSBkZWZhdWx0IGNoYXJ0IGdyb3VwIHdpbGwgYmUgcmVzZXQuXHJcbiAqIEBtZW1iZXJvZiBkY1xyXG4gKiBAbWV0aG9kIGZpbHRlckFsbFxyXG4gKiBAcGFyYW0ge1N0cmluZ30gW2dyb3VwXVxyXG4gKi9cclxuZGMuZmlsdGVyQWxsID0gZnVuY3Rpb24gKGdyb3VwKSB7XHJcbiAgICB2YXIgY2hhcnRzID0gZGMuY2hhcnRSZWdpc3RyeS5saXN0KGdyb3VwKTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgY2hhcnRzW2ldLmZpbHRlckFsbCgpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlc2V0IHpvb20gbGV2ZWwgLyBmb2N1cyBvbiBhbGwgY2hhcnRzIHRoYXQgYmVsb25nIHRvIHRoZSBnaXZlbiBjaGFydCBncm91cC4gSWYgdGhlIGNoYXJ0IGdyb3VwIGlzXHJcbiAqIG5vdCBnaXZlbiB0aGVuIG9ubHkgY2hhcnRzIHRoYXQgYmVsb25nIHRvIHRoZSBkZWZhdWx0IGNoYXJ0IGdyb3VwIHdpbGwgYmUgcmVzZXQuXHJcbiAqIEBtZW1iZXJvZiBkY1xyXG4gKiBAbWV0aG9kIHJlZm9jdXNBbGxcclxuICogQHBhcmFtIHtTdHJpbmd9IFtncm91cF1cclxuICovXHJcbmRjLnJlZm9jdXNBbGwgPSBmdW5jdGlvbiAoZ3JvdXApIHtcclxuICAgIHZhciBjaGFydHMgPSBkYy5jaGFydFJlZ2lzdHJ5Lmxpc3QoZ3JvdXApO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFydHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBpZiAoY2hhcnRzW2ldLmZvY3VzKSB7XHJcbiAgICAgICAgICAgIGNoYXJ0c1tpXS5mb2N1cygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZS1yZW5kZXIgYWxsIGNoYXJ0cyBiZWxvbmcgdG8gdGhlIGdpdmVuIGNoYXJ0IGdyb3VwLiBJZiB0aGUgY2hhcnQgZ3JvdXAgaXMgbm90IGdpdmVuIHRoZW4gb25seVxyXG4gKiBjaGFydHMgdGhhdCBiZWxvbmcgdG8gdGhlIGRlZmF1bHQgY2hhcnQgZ3JvdXAgd2lsbCBiZSByZS1yZW5kZXJlZC5cclxuICogQG1lbWJlcm9mIGRjXHJcbiAqIEBtZXRob2QgcmVuZGVyQWxsXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbZ3JvdXBdXHJcbiAqL1xyXG5kYy5yZW5kZXJBbGwgPSBmdW5jdGlvbiAoZ3JvdXApIHtcclxuICAgIHZhciBjaGFydHMgPSBkYy5jaGFydFJlZ2lzdHJ5Lmxpc3QoZ3JvdXApO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFydHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBjaGFydHNbaV0ucmVuZGVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGRjLl9yZW5kZXJsZXQgIT09IG51bGwpIHtcclxuICAgICAgICBkYy5fcmVuZGVybGV0KGdyb3VwKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZWRyYXcgYWxsIGNoYXJ0cyBiZWxvbmcgdG8gdGhlIGdpdmVuIGNoYXJ0IGdyb3VwLiBJZiB0aGUgY2hhcnQgZ3JvdXAgaXMgbm90IGdpdmVuIHRoZW4gb25seSBjaGFydHNcclxuICogdGhhdCBiZWxvbmcgdG8gdGhlIGRlZmF1bHQgY2hhcnQgZ3JvdXAgd2lsbCBiZSByZS1kcmF3bi4gUmVkcmF3IGlzIGRpZmZlcmVudCBmcm9tIHJlLXJlbmRlciBzaW5jZVxyXG4gKiB3aGVuIHJlZHJhd2luZyBkYyB0cmllcyB0byB1cGRhdGUgdGhlIGdyYXBoaWMgaW5jcmVtZW50YWxseSwgdXNpbmcgdHJhbnNpdGlvbnMsIGluc3RlYWQgb2Ygc3RhcnRpbmdcclxuICogZnJvbSBzY3JhdGNoLlxyXG4gKiBAbWVtYmVyb2YgZGNcclxuICogQG1ldGhvZCByZWRyYXdBbGxcclxuICogQHBhcmFtIHtTdHJpbmd9IFtncm91cF1cclxuICovXHJcbmRjLnJlZHJhd0FsbCA9IGZ1bmN0aW9uIChncm91cCkge1xyXG4gICAgdmFyIGNoYXJ0cyA9IGRjLmNoYXJ0UmVnaXN0cnkubGlzdChncm91cCk7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJ0cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGNoYXJ0c1tpXS5yZWRyYXcoKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZGMuX3JlbmRlcmxldCAhPT0gbnVsbCkge1xyXG4gICAgICAgIGRjLl9yZW5kZXJsZXQoZ3JvdXApO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIElmIHRoaXMgYm9vbGVhbiBpcyBzZXQgdHJ1dGh5LCBhbGwgdHJhbnNpdGlvbnMgd2lsbCBiZSBkaXNhYmxlZCwgYW5kIGNoYW5nZXMgdG8gdGhlIGNoYXJ0cyB3aWxsIGhhcHBlblxyXG4gKiBpbW1lZGlhdGVseS5cclxuICogQG1lbWJlcm9mIGRjXHJcbiAqIEBtZW1iZXIgZGlzYWJsZVRyYW5zaXRpb25zXHJcbiAqIEB0eXBlIHtCb29sZWFufVxyXG4gKiBAZGVmYXVsdCBmYWxzZVxyXG4gKi9cclxuZGMuZGlzYWJsZVRyYW5zaXRpb25zID0gZmFsc2U7XHJcblxyXG4vKipcclxuICogU3RhcnQgYSB0cmFuc2l0aW9uIG9uIGEgc2VsZWN0aW9uIGlmIHRyYW5zaXRpb25zIGFyZSBnbG9iYWxseSBlbmFibGVkXHJcbiAqICh7QGxpbmsgZGMuZGlzYWJsZVRyYW5zaXRpb25zfSBpcyBmYWxzZSkgYW5kIHRoZSBkdXJhdGlvbiBpcyBncmVhdGVyIHRoYW4gemVybzsgb3RoZXJ3aXNlIHJldHVyblxyXG4gKiB0aGUgc2VsZWN0aW9uLiBTaW5jZSBtb3N0IG9wZXJhdGlvbnMgYXJlIHRoZSBzYW1lIG9uIGEgZDMgc2VsZWN0aW9uIGFuZCBhIGQzIHRyYW5zaXRpb24sIHRoaXNcclxuICogYWxsb3dzIGEgY29tbW9uIGNvZGUgcGF0aCBmb3IgYm90aCBjYXNlcy5cclxuICogQG1lbWJlcm9mIGRjXHJcbiAqIEBtZXRob2QgdHJhbnNpdGlvblxyXG4gKiBAcGFyYW0ge2QzLnNlbGVjdGlvbn0gc2VsZWN0aW9uIC0gdGhlIHNlbGVjdGlvbiB0byBiZSB0cmFuc2l0aW9uZWRcclxuICogQHBhcmFtIHtOdW1iZXJ8RnVuY3Rpb259IFtkdXJhdGlvbj0yNTBdIC0gdGhlIGR1cmF0aW9uIG9mIHRoZSB0cmFuc2l0aW9uIGluIG1pbGxpc2Vjb25kcywgYVxyXG4gKiBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIGR1cmF0aW9uLCBvciAwIGZvciBubyB0cmFuc2l0aW9uXHJcbiAqIEBwYXJhbSB7TnVtYmVyfEZ1bmN0aW9ufSBbZGVsYXldIC0gdGhlIGRlbGF5IG9mIHRoZSB0cmFuc2l0aW9uIGluIG1pbGxpc2Vjb25kcywgb3IgYSBmdW5jdGlvblxyXG4gKiByZXR1cm5pbmcgdGhlIGRlbGF5LCBvciAwIGZvciBubyBkZWxheVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gW25hbWVdIC0gdGhlIG5hbWUgb2YgdGhlIHRyYW5zaXRpb24gKGlmIGNvbmN1cnJlbnQgdHJhbnNpdGlvbnMgb24gdGhlIHNhbWVcclxuICogZWxlbWVudHMgYXJlIG5lZWRlZClcclxuICogQHJldHVybnMge2QzLnRyYW5zaXRpb258ZDMuc2VsZWN0aW9ufVxyXG4gKi9cclxuZGMudHJhbnNpdGlvbiA9IGZ1bmN0aW9uIChzZWxlY3Rpb24sIGR1cmF0aW9uLCBkZWxheSwgbmFtZSkge1xyXG4gICAgaWYgKGRjLmRpc2FibGVUcmFuc2l0aW9ucyB8fCBkdXJhdGlvbiA8PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlbGVjdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcyA9IHNlbGVjdGlvbi50cmFuc2l0aW9uKG5hbWUpO1xyXG5cclxuICAgIGlmIChkdXJhdGlvbiA+PSAwIHx8IGR1cmF0aW9uICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBzID0gcy5kdXJhdGlvbihkdXJhdGlvbik7XHJcbiAgICB9XHJcbiAgICBpZiAoZGVsYXkgPj0gMCB8fCBkZWxheSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcyA9IHMuZGVsYXkoZGVsYXkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzO1xyXG59O1xyXG5cclxuLyogc29tZXdoYXQgc2lsbHksIGJ1dCB0byBhdm9pZCBkdXBsaWNhdGluZyBsb2dpYyAqL1xyXG5kYy5vcHRpb25hbFRyYW5zaXRpb24gPSBmdW5jdGlvbiAoZW5hYmxlLCBkdXJhdGlvbiwgZGVsYXksIG5hbWUpIHtcclxuICAgIGlmIChlbmFibGUpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHNlbGVjdGlvbikge1xyXG4gICAgICAgICAgICByZXR1cm4gZGMudHJhbnNpdGlvbihzZWxlY3Rpb24sIGR1cmF0aW9uLCBkZWxheSwgbmFtZSk7XHJcbiAgICAgICAgfTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzZWxlY3Rpb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGlvbjtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59O1xyXG5cclxuLy8gU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIwNzczODQ2XHJcbmRjLmFmdGVyVHJhbnNpdGlvbiA9IGZ1bmN0aW9uICh0cmFuc2l0aW9uLCBjYWxsYmFjaykge1xyXG4gICAgaWYgKHRyYW5zaXRpb24uZW1wdHkoKSB8fCAhdHJhbnNpdGlvbi5kdXJhdGlvbikge1xyXG4gICAgICAgIGNhbGxiYWNrLmNhbGwodHJhbnNpdGlvbik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhciBuID0gMDtcclxuICAgICAgICB0cmFuc2l0aW9uXHJcbiAgICAgICAgICAgIC5lYWNoKGZ1bmN0aW9uICgpIHsgKytuOyB9KVxyXG4gICAgICAgICAgICAub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmICghLS1uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0cmFuc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogQG5hbWVzcGFjZSB1bml0c1xyXG4gKiBAbWVtYmVyb2YgZGNcclxuICogQHR5cGUge3t9fVxyXG4gKi9cclxuZGMudW5pdHMgPSB7fTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgZGVmYXVsdCB2YWx1ZSBmb3Ige0BsaW5rIGRjLmNvb3JkaW5hdGVHcmlkTWl4aW4jeFVuaXRzIC54VW5pdHN9IGZvciB0aGVcclxuICoge0BsaW5rIGRjLmNvb3JkaW5hdGVHcmlkTWl4aW4gQ29vcmRpbmF0ZSBHcmlkIENoYXJ0fSBhbmQgc2hvdWxkXHJcbiAqIGJlIHVzZWQgd2hlbiB0aGUgeCB2YWx1ZXMgYXJlIGEgc2VxdWVuY2Ugb2YgaW50ZWdlcnMuXHJcbiAqIEl0IGlzIGEgZnVuY3Rpb24gdGhhdCBjb3VudHMgdGhlIG51bWJlciBvZiBpbnRlZ2VycyBpbiB0aGUgcmFuZ2Ugc3VwcGxpZWQgaW4gaXRzIHN0YXJ0IGFuZCBlbmQgcGFyYW1ldGVycy5cclxuICogQG1ldGhvZCBpbnRlZ2Vyc1xyXG4gKiBAbWVtYmVyb2YgZGMudW5pdHNcclxuICogQHNlZSB7QGxpbmsgZGMuY29vcmRpbmF0ZUdyaWRNaXhpbiN4VW5pdHMgY29vcmRpbmF0ZUdyaWRNaXhpbi54VW5pdHN9XHJcbiAqIEBleGFtcGxlXHJcbiAqIGNoYXJ0LnhVbml0cyhkYy51bml0cy5pbnRlZ2VycykgLy8gYWxyZWFkeSB0aGUgZGVmYXVsdFxyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhcnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IGVuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gKi9cclxuZGMudW5pdHMuaW50ZWdlcnMgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xyXG4gICAgcmV0dXJuIE1hdGguYWJzKGVuZCAtIHN0YXJ0KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGFyZ3VtZW50IGNhbiBiZSBwYXNzZWQgdG8gdGhlIHtAbGluayBkYy5jb29yZGluYXRlR3JpZE1peGluI3hVbml0cyAueFVuaXRzfSBmdW5jdGlvbiBvZiBhXHJcbiAqIGNvb3JkaW5hdGUgZ3JpZCBjaGFydCB0byBzcGVjaWZ5IG9yZGluYWwgdW5pdHMgZm9yIHRoZSB4IGF4aXMuIFVzdWFsbHkgdGhpcyBwYXJhbWV0ZXIgaXMgdXNlZCBpblxyXG4gKiBjb21iaW5hdGlvbiB3aXRoIHBhc3NpbmdcclxuICoge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1zY2FsZS9ibG9iL21hc3Rlci9SRUFETUUubWQjb3JkaW5hbC1zY2FsZXMgZDMuc2NhbGVPcmRpbmFsfVxyXG4gKiB0byB7QGxpbmsgZGMuY29vcmRpbmF0ZUdyaWRNaXhpbiN4IC54fS5cclxuICpcclxuICogQXMgb2YgZGMuanMgMy4wLCB0aGlzIGlzIHB1cmVseSBhIHBsYWNlaG9sZGVyIG9yIG1hZ2ljIHZhbHVlIHdoaWNoIGNhdXNlcyB0aGUgY2hhcnQgdG8gZ28gaW50byBvcmRpbmFsIG1vZGU7IHRoZVxyXG4gKiBmdW5jdGlvbiBpcyBub3QgY2FsbGVkLlxyXG4gKiBAbWV0aG9kIG9yZGluYWxcclxuICogQG1lbWJlcm9mIGRjLnVuaXRzXHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1zY2FsZS9ibG9iL21hc3Rlci9SRUFETUUubWQjb3JkaW5hbC1zY2FsZXMgZDMuc2NhbGVPcmRpbmFsfVxyXG4gKiBAc2VlIHtAbGluayBkYy5jb29yZGluYXRlR3JpZE1peGluI3hVbml0cyBjb29yZGluYXRlR3JpZE1peGluLnhVbml0c31cclxuICogQHNlZSB7QGxpbmsgZGMuY29vcmRpbmF0ZUdyaWRNaXhpbiN4IGNvb3JkaW5hdGVHcmlkTWl4aW4ueH1cclxuICogQGV4YW1wbGVcclxuICogY2hhcnQueFVuaXRzKGRjLnVuaXRzLm9yZGluYWwpXHJcbiAqICAgICAgLngoZDMuc2NhbGVPcmRpbmFsKCkpXHJcbiAqL1xyXG5kYy51bml0cy5vcmRpbmFsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdkYy51bml0cy5vcmRpbmFsIHNob3VsZCBub3QgYmUgY2FsbGVkIC0gaXQgaXMgYSBwbGFjZWhvbGRlcicpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBuYW1lc3BhY2UgZnBcclxuICogQG1lbWJlcm9mIGRjLnVuaXRzXHJcbiAqIEB0eXBlIHt7fX1cclxuICovXHJcbmRjLnVuaXRzLmZwID0ge307XHJcbi8qKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIGdlbmVyYXRlcyBhbiBhcmd1bWVudCBmb3IgdGhlIHtAbGluayBkYy5jb29yZGluYXRlR3JpZE1peGluIENvb3JkaW5hdGUgR3JpZCBDaGFydH1cclxuICoge0BsaW5rIGRjLmNvb3JkaW5hdGVHcmlkTWl4aW4jeFVuaXRzIC54VW5pdHN9IGZ1bmN0aW9uIHNwZWNpZnlpbmcgdGhhdCB0aGUgeCB2YWx1ZXMgYXJlIGZsb2F0aW5nLXBvaW50XHJcbiAqIG51bWJlcnMgd2l0aCB0aGUgZ2l2ZW4gcHJlY2lzaW9uLlxyXG4gKiBUaGUgcmV0dXJuZWQgZnVuY3Rpb24gZGV0ZXJtaW5lcyBob3cgbWFueSB2YWx1ZXMgYXQgdGhlIGdpdmVuIHByZWNpc2lvbiB3aWxsIGZpdCBpbnRvIHRoZSByYW5nZVxyXG4gKiBzdXBwbGllZCBpbiBpdHMgc3RhcnQgYW5kIGVuZCBwYXJhbWV0ZXJzLlxyXG4gKiBAbWV0aG9kIHByZWNpc2lvblxyXG4gKiBAbWVtYmVyb2YgZGMudW5pdHMuZnBcclxuICogQHNlZSB7QGxpbmsgZGMuY29vcmRpbmF0ZUdyaWRNaXhpbiN4VW5pdHMgY29vcmRpbmF0ZUdyaWRNaXhpbi54VW5pdHN9XHJcbiAqIEBleGFtcGxlXHJcbiAqIC8vIHNwZWNpZnkgdmFsdWVzIChhbmQgdGlja3MpIGV2ZXJ5IDAuMSB1bml0c1xyXG4gKiBjaGFydC54VW5pdHMoZGMudW5pdHMuZnAucHJlY2lzaW9uKDAuMSlcclxuICogLy8gdGhlcmUgYXJlIDUwMCB1bml0cyBiZXR3ZWVuIDAuNSBhbmQgMSBpZiB0aGUgcHJlY2lzaW9uIGlzIDAuMDAxXHJcbiAqIHZhciB0aG91c2FuZHRocyA9IGRjLnVuaXRzLmZwLnByZWNpc2lvbigwLjAwMSk7XHJcbiAqIHRob3VzYW5kdGhzKDAuNSwgMS4wKSAvLyByZXR1cm5zIDUwMFxyXG4gKiBAcGFyYW0ge051bWJlcn0gcHJlY2lzaW9uXHJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gc3RhcnQtZW5kIHVuaXQgZnVuY3Rpb25cclxuICovXHJcbmRjLnVuaXRzLmZwLnByZWNpc2lvbiA9IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuICAgIHZhciBfZiA9IGZ1bmN0aW9uIChzLCBlKSB7XHJcbiAgICAgICAgdmFyIGQgPSBNYXRoLmFicygoZSAtIHMpIC8gX2YucmVzb2x1dGlvbik7XHJcbiAgICAgICAgaWYgKGRjLnV0aWxzLmlzTmVnbGlnaWJsZShkIC0gTWF0aC5mbG9vcihkKSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoZCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChkKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgX2YucmVzb2x1dGlvbiA9IHByZWNpc2lvbjtcclxuICAgIHJldHVybiBfZjtcclxufTtcclxuXHJcbmRjLnJvdW5kID0ge307XHJcbmRjLnJvdW5kLmZsb29yID0gZnVuY3Rpb24gKG4pIHtcclxuICAgIHJldHVybiBNYXRoLmZsb29yKG4pO1xyXG59O1xyXG5kYy5yb3VuZC5jZWlsID0gZnVuY3Rpb24gKG4pIHtcclxuICAgIHJldHVybiBNYXRoLmNlaWwobik7XHJcbn07XHJcbmRjLnJvdW5kLnJvdW5kID0gZnVuY3Rpb24gKG4pIHtcclxuICAgIHJldHVybiBNYXRoLnJvdW5kKG4pO1xyXG59O1xyXG5cclxuZGMub3ZlcnJpZGUgPSBmdW5jdGlvbiAob2JqLCBmdW5jdGlvbk5hbWUsIG5ld0Z1bmN0aW9uKSB7XHJcbiAgICB2YXIgZXhpc3RpbmdGdW5jdGlvbiA9IG9ialtmdW5jdGlvbk5hbWVdO1xyXG4gICAgb2JqWydfJyArIGZ1bmN0aW9uTmFtZV0gPSBleGlzdGluZ0Z1bmN0aW9uO1xyXG4gICAgb2JqW2Z1bmN0aW9uTmFtZV0gPSBuZXdGdW5jdGlvbjtcclxufTtcclxuXHJcbmRjLnJlbmRlcmxldCA9IGZ1bmN0aW9uIChfKSB7XHJcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gZGMuX3JlbmRlcmxldDtcclxuICAgIH1cclxuICAgIGRjLl9yZW5kZXJsZXQgPSBfO1xyXG4gICAgcmV0dXJuIGRjO1xyXG59O1xyXG5cclxuZGMuaW5zdGFuY2VPZkNoYXJ0ID0gZnVuY3Rpb24gKG8pIHtcclxuICAgIHJldHVybiBvIGluc3RhbmNlb2YgT2JqZWN0ICYmIG8uX19kY0ZsYWdfXyAmJiB0cnVlO1xyXG59O1xyXG5cclxuZGMuZXJyb3JzID0ge307XHJcblxyXG5kYy5lcnJvcnMuRXhjZXB0aW9uID0gZnVuY3Rpb24gKG1zZykge1xyXG4gICAgdmFyIF9tc2cgPSBtc2cgfHwgJ1VuZXhwZWN0ZWQgaW50ZXJuYWwgZXJyb3InO1xyXG5cclxuICAgIHRoaXMubWVzc2FnZSA9IF9tc2c7XHJcblxyXG4gICAgdGhpcy50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX21zZztcclxuICAgIH07XHJcbiAgICB0aGlzLnN0YWNrID0gKG5ldyBFcnJvcigpKS5zdGFjaztcclxufTtcclxuZGMuZXJyb3JzLkV4Y2VwdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XHJcbmRjLmVycm9ycy5FeGNlcHRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gZGMuZXJyb3JzLkV4Y2VwdGlvbjtcclxuXHJcbmRjLmVycm9ycy5JbnZhbGlkU3RhdGVFeGNlcHRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBkYy5lcnJvcnMuRXhjZXB0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn07XHJcblxyXG5kYy5lcnJvcnMuSW52YWxpZFN0YXRlRXhjZXB0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZGMuZXJyb3JzLkV4Y2VwdGlvbi5wcm90b3R5cGUpO1xyXG5kYy5lcnJvcnMuSW52YWxpZFN0YXRlRXhjZXB0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGRjLmVycm9ycy5JbnZhbGlkU3RhdGVFeGNlcHRpb247XHJcblxyXG5kYy5lcnJvcnMuQmFkQXJndW1lbnRFeGNlcHRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBkYy5lcnJvcnMuRXhjZXB0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn07XHJcblxyXG5kYy5lcnJvcnMuQmFkQXJndW1lbnRFeGNlcHRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShkYy5lcnJvcnMuRXhjZXB0aW9uLnByb3RvdHlwZSk7XHJcbmRjLmVycm9ycy5CYWRBcmd1bWVudEV4Y2VwdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBkYy5lcnJvcnMuQmFkQXJndW1lbnRFeGNlcHRpb247XHJcblxyXG4vKipcclxuICogVGhlIGRlZmF1bHQgZGF0ZSBmb3JtYXQgZm9yIGRjLmpzXHJcbiAqIEBuYW1lIGRhdGVGb3JtYXRcclxuICogQG1lbWJlcm9mIGRjXHJcbiAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICogQGRlZmF1bHQgZDMudGltZUZvcm1hdCgnJW0vJWQvJVknKVxyXG4gKi9cclxuZGMuZGF0ZUZvcm1hdCA9IGQzLnRpbWVGb3JtYXQoJyVtLyVkLyVZJyk7XHJcblxyXG4vKipcclxuICogQG5hbWVzcGFjZSBwcmludGVyc1xyXG4gKiBAbWVtYmVyb2YgZGNcclxuICogQHR5cGUge3t9fVxyXG4gKi9cclxuZGMucHJpbnRlcnMgPSB7fTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBhIGxpc3Qgb2YgZmlsdGVycyBpbnRvIGEgcmVhZGFibGUgc3RyaW5nLlxyXG4gKiBAbWV0aG9kIGZpbHRlcnNcclxuICogQG1lbWJlcm9mIGRjLnByaW50ZXJzXHJcbiAqIEBwYXJhbSB7QXJyYXk8ZGMuZmlsdGVycz59IGZpbHRlcnNcclxuICogQHJldHVybnMge1N0cmluZ31cclxuICovXHJcbmRjLnByaW50ZXJzLmZpbHRlcnMgPSBmdW5jdGlvbiAoZmlsdGVycykge1xyXG4gICAgdmFyIHMgPSAnJztcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbHRlcnMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBpZiAoaSA+IDApIHtcclxuICAgICAgICAgICAgcyArPSAnLCAnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzICs9IGRjLnByaW50ZXJzLmZpbHRlcihmaWx0ZXJzW2ldKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBhIGZpbHRlciBpbnRvIGEgcmVhZGFibGUgc3RyaW5nLlxyXG4gKiBAbWV0aG9kIGZpbHRlclxyXG4gKiBAbWVtYmVyb2YgZGMucHJpbnRlcnNcclxuICogQHBhcmFtIHtkYy5maWx0ZXJzfGFueXxBcnJheTxhbnk+fSBmaWx0ZXJcclxuICogQHJldHVybnMge1N0cmluZ31cclxuICovXHJcbmRjLnByaW50ZXJzLmZpbHRlciA9IGZ1bmN0aW9uIChmaWx0ZXIpIHtcclxuICAgIHZhciBzID0gJyc7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBmaWx0ZXIgIT09ICd1bmRlZmluZWQnICYmIGZpbHRlciAhPT0gbnVsbCkge1xyXG4gICAgICAgIGlmIChmaWx0ZXIgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAgICAgICBpZiAoZmlsdGVyLmxlbmd0aCA+PSAyKSB7XHJcbiAgICAgICAgICAgICAgICBzID0gJ1snICsgZGMudXRpbHMucHJpbnRTaW5nbGVWYWx1ZShmaWx0ZXJbMF0pICsgJyAtPiAnICsgZGMudXRpbHMucHJpbnRTaW5nbGVWYWx1ZShmaWx0ZXJbMV0pICsgJ10nO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZpbHRlci5sZW5ndGggPj0gMSkge1xyXG4gICAgICAgICAgICAgICAgcyA9IGRjLnV0aWxzLnByaW50U2luZ2xlVmFsdWUoZmlsdGVyWzBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHMgPSBkYy51dGlscy5wcmludFNpbmdsZVZhbHVlKGZpbHRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGdpdmVuIGEgc3RyaW5nIHByb3BlcnR5IG5hbWUsIGNhbiBiZSB1c2VkIHRvIHBsdWNrIHRoZSBwcm9wZXJ0eSBvZmYgYW4gb2JqZWN0LiAgQSBmdW5jdGlvblxyXG4gKiBjYW4gYmUgcGFzc2VkIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYWxzbyBhbHRlciB0aGUgZGF0YSBiZWluZyByZXR1cm5lZC5cclxuICpcclxuICogVGhpcyBjYW4gYmUgYSB1c2VmdWwgc2hvcnRoYW5kIG1ldGhvZCB0byBjcmVhdGUgYWNjZXNzb3IgZnVuY3Rpb25zLlxyXG4gKiBAbWV0aG9kIHBsdWNrXHJcbiAqIEBtZW1iZXJvZiBkY1xyXG4gKiBAZXhhbXBsZVxyXG4gKiB2YXIgeFBsdWNrID0gZGMucGx1Y2soJ3gnKTtcclxuICogdmFyIG9iakEgPSB7eDogMX07XHJcbiAqIHhQbHVjayhvYmpBKSAvLyAxXHJcbiAqIEBleGFtcGxlXHJcbiAqIHZhciB4UG9zaXRpb24gPSBkYy5wbHVjaygneCcsIGZ1bmN0aW9uICh4LCBpKSB7XHJcbiAqICAgICAvLyBgdGhpc2AgaXMgdGhlIG9yaWdpbmFsIGRhdHVtLFxyXG4gKiAgICAgLy8gYHhgIGlzIHRoZSB4IHByb3BlcnR5IG9mIHRoZSBkYXR1bSxcclxuICogICAgIC8vIGBpYCBpcyB0aGUgcG9zaXRpb24gaW4gdGhlIGFycmF5XHJcbiAqICAgICByZXR1cm4gdGhpcy5yYWRpdXMgKyB4O1xyXG4gKiB9KTtcclxuICogZGMuc2VsZWN0QWxsKCcuY2lyY2xlJykuZGF0YSguLi4pLngoeFBvc2l0aW9uKTtcclxuICogQHBhcmFtIHtTdHJpbmd9IG5cclxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZdXHJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cclxuICovXHJcbmRjLnBsdWNrID0gZnVuY3Rpb24gKG4sIGYpIHtcclxuICAgIGlmICghZikge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFtuXTsgfTtcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgaSkgeyByZXR1cm4gZi5jYWxsKGQsIGRbbl0sIGkpOyB9O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBuYW1lc3BhY2UgdXRpbHNcclxuICogQG1lbWJlcm9mIGRjXHJcbiAqIEB0eXBlIHt7fX1cclxuICovXHJcbmRjLnV0aWxzID0ge307XHJcblxyXG4vKipcclxuICogUHJpbnQgYSBzaW5nbGUgdmFsdWUgZmlsdGVyLlxyXG4gKiBAbWV0aG9kIHByaW50U2luZ2xlVmFsdWVcclxuICogQG1lbWJlcm9mIGRjLnV0aWxzXHJcbiAqIEBwYXJhbSB7YW55fSBmaWx0ZXJcclxuICogQHJldHVybnMge1N0cmluZ31cclxuICovXHJcbmRjLnV0aWxzLnByaW50U2luZ2xlVmFsdWUgPSBmdW5jdGlvbiAoZmlsdGVyKSB7XHJcbiAgICB2YXIgcyA9ICcnICsgZmlsdGVyO1xyXG5cclxuICAgIGlmIChmaWx0ZXIgaW5zdGFuY2VvZiBEYXRlKSB7XHJcbiAgICAgICAgcyA9IGRjLmRhdGVGb3JtYXQoZmlsdGVyKTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mKGZpbHRlcikgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcyA9IGZpbHRlcjtcclxuICAgIH0gZWxzZSBpZiAoZGMudXRpbHMuaXNGbG9hdChmaWx0ZXIpKSB7XHJcbiAgICAgICAgcyA9IGRjLnV0aWxzLnByaW50U2luZ2xlVmFsdWUuZmZvcm1hdChmaWx0ZXIpO1xyXG4gICAgfSBlbHNlIGlmIChkYy51dGlscy5pc0ludGVnZXIoZmlsdGVyKSkge1xyXG4gICAgICAgIHMgPSBNYXRoLnJvdW5kKGZpbHRlcik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHM7XHJcbn07XHJcbmRjLnV0aWxzLnByaW50U2luZ2xlVmFsdWUuZmZvcm1hdCA9IGQzLmZvcm1hdCgnLjJmJyk7XHJcblxyXG4vLyBjb252ZXJ0ICdkYXknIHRvICd0aW1lRGF5JyBhbmQgc2ltaWxhclxyXG5kYy51dGlscy50b1RpbWVGdW5jID0gZnVuY3Rpb24gKHQpIHtcclxuICAgIHJldHVybiAndGltZScgKyB0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdC5zbGljZSgxKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBcmJpdHJhcnkgYWRkIG9uZSB2YWx1ZSB0byBhbm90aGVyLlxyXG4gKlxyXG4gKiBJZiB0aGUgdmFsdWUgbCBpcyBvZiB0eXBlIERhdGUsIGFkZHMgciB1bml0cyB0byBpdC4gdCBiZWNvbWVzIHRoZSB1bml0LlxyXG4gKiBGb3IgZXhhbXBsZSBkYy51dGlscy5hZGQoZHQsIDMsICd3ZWVrJykgd2lsbCBhZGQgMyAociA9IDMpIHdlZWtzICh0PSAnd2VlaycpIHRvIGR0LlxyXG4gKlxyXG4gKiBJZiBsIGlzIG9mIHR5cGUgbnVtZXJpYywgdCBpcyBpZ25vcmVkLiBJbiB0aGlzIGNhc2UgaWYgciBpcyBvZiB0eXBlIHN0cmluZyxcclxuICogaXQgaXMgYXNzdW1lZCB0byBiZSBwZXJjZW50YWdlICh3aGV0aGVyIG9yIG5vdCBpdCBpbmNsdWRlcyAlKS4gRm9yIGV4YW1wbGVcclxuICogZGMudXRpbHMuYWRkKDMwLCAxMCkgd2lsbCBnaXZlIDQwIGFuZCBkYy51dGlscy5hZGQoMzAsICcxMCcpIHdpbGwgZ2l2ZSAzMy5cclxuICpcclxuICogVGhleSBhbHNvIGdlbmVyYXRlIHN0cmFuZ2UgcmVzdWx0cyBpZiBsIGlzIGEgc3RyaW5nLlxyXG4gKiBAbWV0aG9kIGFkZFxyXG4gKiBAbWVtYmVyb2YgZGMudXRpbHNcclxuICogQHBhcmFtIHtEYXRlfE51bWJlcn0gbCB0aGUgdmFsdWUgdG8gbW9kaWZ5XHJcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gciB0aGUgYW1vdW50IGJ5IHdoaWNoIHRvIG1vZGlmeSB0aGUgdmFsdWVcclxuICogQHBhcmFtIHtGdW5jdGlvbnxTdHJpbmd9IFt0PWQzLnRpbWVEYXldIGlmIGBsYCBpcyBhIGBEYXRlYCwgdGhlbiB0aGlzIHNob3VsZCBiZSBhXHJcbiAqIFtkMyB0aW1lIGludGVydmFsXShodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtdGltZS9ibG9iL21hc3Rlci9SRUFETUUubWQjX2ludGVydmFsKS5cclxuICogRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgd2l0aCBkYy5qcyAyLjAsIGl0IGNhbiBhbHNvIGJlIHRoZSBuYW1lIG9mIGFuIGludGVydmFsLCBpLmUuXHJcbiAqICdtaWxsaXMnLCAnc2Vjb25kJywgJ21pbnV0ZScsICdob3VyJywgJ2RheScsICd3ZWVrJywgJ21vbnRoJywgb3IgJ3llYXInXHJcbiAqIEByZXR1cm5zIHtEYXRlfE51bWJlcn1cclxuICovXHJcbmRjLnV0aWxzLmFkZCA9IGZ1bmN0aW9uIChsLCByLCB0KSB7XHJcbiAgICBpZiAodHlwZW9mIHIgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgciA9IHIucmVwbGFjZSgnJScsICcnKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobCBpbnN0YW5jZW9mIERhdGUpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHIgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHIgPSArcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHQgPT09ICdtaWxsaXMnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShsLmdldFRpbWUoKSArIHIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0ID0gdCB8fCBkMy50aW1lRGF5O1xyXG4gICAgICAgIGlmICh0eXBlb2YgdCAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0ID0gZDNbZGMudXRpbHMudG9UaW1lRnVuYyh0KV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0Lm9mZnNldChsLCByKTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHIgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgdmFyIHBlcmNlbnRhZ2UgPSAoK3IgLyAxMDApO1xyXG4gICAgICAgIHJldHVybiBsID4gMCA/IGwgKiAoMSArIHBlcmNlbnRhZ2UpIDogbCAqICgxIC0gcGVyY2VudGFnZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBsICsgcjtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBBcmJpdHJhcnkgc3VidHJhY3Qgb25lIHZhbHVlIGZyb20gYW5vdGhlci5cclxuICpcclxuICogSWYgdGhlIHZhbHVlIGwgaXMgb2YgdHlwZSBEYXRlLCBzdWJ0cmFjdHMgciB1bml0cyBmcm9tIGl0LiB0IGJlY29tZXMgdGhlIHVuaXQuXHJcbiAqIEZvciBleGFtcGxlIGRjLnV0aWxzLnN1YnRyYWN0KGR0LCAzLCAnd2VlaycpIHdpbGwgc3VidHJhY3QgMyAociA9IDMpIHdlZWtzICh0PSAnd2VlaycpIGZyb20gZHQuXHJcbiAqXHJcbiAqIElmIGwgaXMgb2YgdHlwZSBudW1lcmljLCB0IGlzIGlnbm9yZWQuIEluIHRoaXMgY2FzZSBpZiByIGlzIG9mIHR5cGUgc3RyaW5nLFxyXG4gKiBpdCBpcyBhc3N1bWVkIHRvIGJlIHBlcmNlbnRhZ2UgKHdoZXRoZXIgb3Igbm90IGl0IGluY2x1ZGVzICUpLiBGb3IgZXhhbXBsZVxyXG4gKiBkYy51dGlscy5zdWJ0cmFjdCgzMCwgMTApIHdpbGwgZ2l2ZSAyMCBhbmQgZGMudXRpbHMuc3VidHJhY3QoMzAsICcxMCcpIHdpbGwgZ2l2ZSAyNy5cclxuICpcclxuICogVGhleSBhbHNvIGdlbmVyYXRlIHN0cmFuZ2UgcmVzdWx0cyBpZiBsIGlzIGEgc3RyaW5nLlxyXG4gKiBAbWV0aG9kIHN1YnRyYWN0XHJcbiAqIEBtZW1iZXJvZiBkYy51dGlsc1xyXG4gKiBAcGFyYW0ge0RhdGV8TnVtYmVyfSBsIHRoZSB2YWx1ZSB0byBtb2RpZnlcclxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSByIHRoZSBhbW91bnQgYnkgd2hpY2ggdG8gbW9kaWZ5IHRoZSB2YWx1ZVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufFN0cmluZ30gW3Q9ZDMudGltZURheV0gaWYgYGxgIGlzIGEgYERhdGVgLCB0aGVuIHRoaXMgc2hvdWxkIGJlIGFcclxuICogW2QzIHRpbWUgaW50ZXJ2YWxdKGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy10aW1lL2Jsb2IvbWFzdGVyL1JFQURNRS5tZCNfaW50ZXJ2YWwpLlxyXG4gKiBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoIGRjLmpzIDIuMCwgaXQgY2FuIGFsc28gYmUgdGhlIG5hbWUgb2YgYW4gaW50ZXJ2YWwsIGkuZS5cclxuICogJ21pbGxpcycsICdzZWNvbmQnLCAnbWludXRlJywgJ2hvdXInLCAnZGF5JywgJ3dlZWsnLCAnbW9udGgnLCBvciAneWVhcidcclxuICogQHJldHVybnMge0RhdGV8TnVtYmVyfVxyXG4gKi9cclxuZGMudXRpbHMuc3VidHJhY3QgPSBmdW5jdGlvbiAobCwgciwgdCkge1xyXG4gICAgaWYgKHR5cGVvZiByID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHIgPSByLnJlcGxhY2UoJyUnLCAnJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGwgaW5zdGFuY2VvZiBEYXRlKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiByID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICByID0gK3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0ID09PSAnbWlsbGlzJykge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUobC5nZXRUaW1lKCkgLSByKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdCA9IHQgfHwgZDMudGltZURheTtcclxuICAgICAgICBpZiAodHlwZW9mIHQgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdCA9IGQzW2RjLnV0aWxzLnRvVGltZUZ1bmModCldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdC5vZmZzZXQobCwgLXIpO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgciA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICB2YXIgcGVyY2VudGFnZSA9ICgrciAvIDEwMCk7XHJcbiAgICAgICAgcmV0dXJuIGwgPCAwID8gbCAqICgxICsgcGVyY2VudGFnZSkgOiBsICogKDEgLSBwZXJjZW50YWdlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGwgLSByO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIElzIHRoZSB2YWx1ZSBhIG51bWJlcj9cclxuICogQG1ldGhvZCBpc051bWJlclxyXG4gKiBAbWVtYmVyb2YgZGMudXRpbHNcclxuICogQHBhcmFtIHthbnl9IG5cclxuICogQHJldHVybnMge0Jvb2xlYW59XHJcbiAqL1xyXG5kYy51dGlscy5pc051bWJlciA9IGZ1bmN0aW9uIChuKSB7XHJcbiAgICByZXR1cm4gbiA9PT0gK247XHJcbn07XHJcblxyXG4vKipcclxuICogSXMgdGhlIHZhbHVlIGEgZmxvYXQ/XHJcbiAqIEBtZXRob2QgaXNGbG9hdFxyXG4gKiBAbWVtYmVyb2YgZGMudXRpbHNcclxuICogQHBhcmFtIHthbnl9IG5cclxuICogQHJldHVybnMge0Jvb2xlYW59XHJcbiAqL1xyXG5kYy51dGlscy5pc0Zsb2F0ID0gZnVuY3Rpb24gKG4pIHtcclxuICAgIHJldHVybiBuID09PSArbiAmJiBuICE9PSAobiB8IDApO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIElzIHRoZSB2YWx1ZSBhbiBpbnRlZ2VyP1xyXG4gKiBAbWV0aG9kIGlzSW50ZWdlclxyXG4gKiBAbWVtYmVyb2YgZGMudXRpbHNcclxuICogQHBhcmFtIHthbnl9IG5cclxuICogQHJldHVybnMge0Jvb2xlYW59XHJcbiAqL1xyXG5kYy51dGlscy5pc0ludGVnZXIgPSBmdW5jdGlvbiAobikge1xyXG4gICAgcmV0dXJuIG4gPT09ICtuICYmIG4gPT09IChuIHwgMCk7XHJcbn07XHJcblxyXG4vKipcclxuICogSXMgdGhlIHZhbHVlIHZlcnkgY2xvc2UgdG8gemVybz9cclxuICogQG1ldGhvZCBpc05lZ2xpZ2libGVcclxuICogQG1lbWJlcm9mIGRjLnV0aWxzXHJcbiAqIEBwYXJhbSB7YW55fSBuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gKi9cclxuZGMudXRpbHMuaXNOZWdsaWdpYmxlID0gZnVuY3Rpb24gKG4pIHtcclxuICAgIHJldHVybiAhZGMudXRpbHMuaXNOdW1iZXIobikgfHwgKG4gPCBkYy5jb25zdGFudHMuTkVHTElHSUJMRV9OVU1CRVIgJiYgbiA+IC1kYy5jb25zdGFudHMuTkVHTElHSUJMRV9OVU1CRVIpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEVuc3VyZSB0aGUgdmFsdWUgaXMgbm8gZ3JlYXRlciBvciBsZXNzIHRoYW4gdGhlIG1pbi9tYXggdmFsdWVzLiAgSWYgaXQgaXMgcmV0dXJuIHRoZSBib3VuZGFyeSB2YWx1ZS5cclxuICogQG1ldGhvZCBjbGFtcFxyXG4gKiBAbWVtYmVyb2YgZGMudXRpbHNcclxuICogQHBhcmFtIHthbnl9IHZhbFxyXG4gKiBAcGFyYW0ge2FueX0gbWluXHJcbiAqIEBwYXJhbSB7YW55fSBtYXhcclxuICogQHJldHVybnMge2FueX1cclxuICovXHJcbmRjLnV0aWxzLmNsYW1wID0gZnVuY3Rpb24gKHZhbCwgbWluLCBtYXgpIHtcclxuICAgIHJldHVybiB2YWwgPCBtaW4gPyBtaW4gOiAodmFsID4gbWF4ID8gbWF4IDogdmFsKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHaXZlbiBgeGAsIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgYWx3YXlzIHJldHVybnMgYHhgLlxyXG4gKlxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzL2Jsb2IvbWFzdGVyL0NIQU5HRVMubWQjaW50ZXJuYWxzIGBkMy5mdW5jdG9yYCB3YXMgcmVtb3ZlZCBpbiBkMyB2ZXJzaW9uIDR9LlxyXG4gKiBUaGlzIGZ1bmN0aW9uIGhlbHBzIHRvIGltcGxlbWVudCB0aGUgcmVwbGFjZW1lbnQsXHJcbiAqIGB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8geCA6IGRjLnV0aWxzLmNvbnN0YW50KHgpYFxyXG4gKiBAbWV0aG9kIGNvbnN0YW50XHJcbiAqIEBtZW1iZXJvZiBkYy51dGlsc1xyXG4gKiBAcGFyYW0ge2FueX0geFxyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XHJcbiAqL1xyXG5kYy51dGlscy5jb25zdGFudCA9IGZ1bmN0aW9uICh4KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB4O1xyXG4gICAgfTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBVc2luZyBhIHNpbXBsZSBzdGF0aWMgY291bnRlciwgcHJvdmlkZSBhIHVuaXF1ZSBpbnRlZ2VyIGlkLlxyXG4gKiBAbWV0aG9kIHVuaXF1ZUlkXHJcbiAqIEBtZW1iZXJvZiBkYy51dGlsc1xyXG4gKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gKi9cclxudmFyIF9pZENvdW50ZXIgPSAwO1xyXG5kYy51dGlscy51bmlxdWVJZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiArK19pZENvdW50ZXI7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydCBhIG5hbWUgdG8gYW4gSUQuXHJcbiAqIEBtZXRob2QgbmFtZVRvSWRcclxuICogQG1lbWJlcm9mIGRjLnV0aWxzXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XHJcbiAqL1xyXG5kYy51dGlscy5uYW1lVG9JZCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICByZXR1cm4gbmFtZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1tcXHNdL2csICdfJykucmVwbGFjZSgvW1xcLiddL2csICcnKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBcHBlbmQgb3Igc2VsZWN0IGFuIGl0ZW0gb24gYSBwYXJlbnQgZWxlbWVudC5cclxuICogQG1ldGhvZCBhcHBlbmRPclNlbGVjdFxyXG4gKiBAbWVtYmVyb2YgZGMudXRpbHNcclxuICogQHBhcmFtIHtkMy5zZWxlY3Rpb259IHBhcmVudFxyXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3JcclxuICogQHBhcmFtIHtTdHJpbmd9IHRhZ1xyXG4gKiBAcmV0dXJucyB7ZDMuc2VsZWN0aW9ufVxyXG4gKi9cclxuZGMudXRpbHMuYXBwZW5kT3JTZWxlY3QgPSBmdW5jdGlvbiAocGFyZW50LCBzZWxlY3RvciwgdGFnKSB7XHJcbiAgICB0YWcgPSB0YWcgfHwgc2VsZWN0b3I7XHJcbiAgICB2YXIgZWxlbWVudCA9IHBhcmVudC5zZWxlY3Qoc2VsZWN0b3IpO1xyXG4gICAgaWYgKGVsZW1lbnQuZW1wdHkoKSkge1xyXG4gICAgICAgIGVsZW1lbnQgPSBwYXJlbnQuYXBwZW5kKHRhZyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZWxlbWVudDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gdGhlIG51bWJlciBpZiB0aGUgdmFsdWUgaXMgYSBudW1iZXI7IGVsc2UgMC5cclxuICogQG1ldGhvZCBzYWZlTnVtYmVyXHJcbiAqIEBtZW1iZXJvZiBkYy51dGlsc1xyXG4gKiBAcGFyYW0ge051bWJlcnxhbnl9IG5cclxuICogQHJldHVybnMge051bWJlcn1cclxuICovXHJcbmRjLnV0aWxzLnNhZmVOdW1iZXIgPSBmdW5jdGlvbiAobikgeyByZXR1cm4gZGMudXRpbHMuaXNOdW1iZXIoK24pID8gK24gOiAwO307XHJcblxyXG4vKipcclxuICogUmV0dXJuIHRydWUgaWYgYm90aCBhcnJheXMgYXJlIGVxdWFsLCBpZiBib3RoIGFycmF5IGFyZSBudWxsIHRoZXNlIGFyZSBjb25zaWRlcmVkIGVxdWFsXHJcbiAqIEBtZXRob2QgYXJyYXlzRXF1YWxcclxuICogQG1lbWJlcm9mIGRjLnV0aWxzXHJcbiAqIEBwYXJhbSB7QXJyYXl8bnVsbH0gYTFcclxuICogQHBhcmFtIHtBcnJheXxudWxsfSBhMlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cclxuICovXHJcbmRjLnV0aWxzLmFycmF5c0VxdWFsID0gZnVuY3Rpb24gKGExLCBhMikge1xyXG4gICAgaWYgKCFhMSAmJiAhYTIpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWExIHx8ICFhMikge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYTEubGVuZ3RoID09PSBhMi5sZW5ndGggJiZcclxuICAgICAgICAvLyBJZiBlbGVtZW50cyBhcmUgbm90IGludGVnZXJzL3N0cmluZ3MsIHdlIGhvcGUgdGhhdCBpdCB3aWxsIG1hdGNoIGJlY2F1c2Ugb2YgdG9TdHJpbmdcclxuICAgICAgICAvLyBUZXN0IGNhc2VzIGNvdmVyIGRhdGVzIGFzIHdlbGwuXHJcbiAgICAgICAgYTEuZXZlcnkoZnVuY3Rpb24gKGVsZW0sIGkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVsZW0udmFsdWVPZigpID09PSBhMltpXS52YWx1ZU9mKCk7XHJcbiAgICAgICAgfSk7XHJcbn07XHJcblxyXG4vLyAqKioqKioqKiBTdW5idXJzdCBDaGFydCAqKioqKioqKlxyXG5kYy51dGlscy5hbGxDaGlsZHJlbiA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICB2YXIgcGF0aHMgPSBbXTtcclxuICAgIHBhdGhzLnB1c2gobm9kZS5wYXRoKTtcclxuICAgIGNvbnNvbGUubG9nKCdjdXJyZW50Tm9kZScsIG5vZGUpO1xyXG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcGF0aHMgPSBwYXRocy5jb25jYXQoZGMudXRpbHMuYWxsQ2hpbGRyZW4obm9kZS5jaGlsZHJlbltpXSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBwYXRocztcclxufTtcclxuXHJcbi8vIGJ1aWxkcyBhIGQzIEhpZXJhcmNoeSBmcm9tIGEgY29sbGVjdGlvblxyXG4vLyBUT0RPOiB0dXJuIHRoaXMgbW9uc3RlciBtZXRob2Qgc29tZXRoaW5nIGJldHRlci5cclxuZGMudXRpbHMudG9IaWVyYXJjaHkgPSBmdW5jdGlvbiAobGlzdCwgYWNjZXNzb3IpIHtcclxuICAgIHZhciByb290ID0geydrZXknOiAncm9vdCcsICdjaGlsZHJlbic6IFtdfTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBkYXRhID0gbGlzdFtpXTtcclxuICAgICAgICB2YXIgcGFydHMgPSBkYXRhLmtleTtcclxuICAgICAgICB2YXIgdmFsdWUgPSBhY2Nlc3NvcihkYXRhKTtcclxuICAgICAgICB2YXIgY3VycmVudE5vZGUgPSByb290O1xyXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGFydHMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRQYXRoID0gcGFydHMuc2xpY2UoMCwgaiArIDEpO1xyXG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBjdXJyZW50Tm9kZS5jaGlsZHJlbjtcclxuICAgICAgICAgICAgdmFyIG5vZGVOYW1lID0gcGFydHNbal07XHJcbiAgICAgICAgICAgIHZhciBjaGlsZE5vZGU7XHJcbiAgICAgICAgICAgIGlmIChqICsgMSA8IHBhcnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgLy8gTm90IHlldCBhdCB0aGUgZW5kIG9mIHRoZSBzZXF1ZW5jZTsgbW92ZSBkb3duIHRoZSB0cmVlLlxyXG4gICAgICAgICAgICAgICAgY2hpbGROb2RlID0gZmluZENoaWxkKGNoaWxkcmVuLCBub2RlTmFtZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgZG9uJ3QgYWxyZWFkeSBoYXZlIGEgY2hpbGQgbm9kZSBmb3IgdGhpcyBicmFuY2gsIGNyZWF0ZSBpdC5cclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZE5vZGUgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZSA9IHsna2V5Jzogbm9kZU5hbWUsICdjaGlsZHJlbic6IFtdLCAncGF0aCc6IGN1cnJlbnRQYXRofTtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkTm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZSA9IGNoaWxkTm9kZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgc2VxdWVuY2U7IGNyZWF0ZSBhIGxlYWYgbm9kZS5cclxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZSA9IHsna2V5Jzogbm9kZU5hbWUsICd2YWx1ZSc6IHZhbHVlLCAnZGF0YSc6IGRhdGEsICdwYXRoJzogY3VycmVudFBhdGh9O1xyXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChjaGlsZE5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJvb3Q7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBmaW5kQ2hpbGQgKGNoaWxkcmVuLCBub2RlTmFtZSkge1xyXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBjaGlsZHJlbi5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgIGlmIChjaGlsZHJlbltrXS5rZXkgPT09IG5vZGVOYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjaGlsZHJlbltrXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmRjLnV0aWxzLmdldEFuY2VzdG9ycyA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICB2YXIgcGF0aCA9IFtdO1xyXG4gICAgdmFyIGN1cnJlbnQgPSBub2RlO1xyXG4gICAgd2hpbGUgKGN1cnJlbnQucGFyZW50KSB7XHJcbiAgICAgICAgcGF0aC51bnNoaWZ0KGN1cnJlbnQubmFtZSk7XHJcbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBhdGg7XHJcbn07XHJcblxyXG5kYy51dGlscy5hcnJheXNJZGVudGljYWwgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgdmFyIGkgPSBhLmxlbmd0aDtcclxuICAgIGlmIChpICE9PSBiLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG4vKipcclxuICogUHJvdmlkZXMgYmFzaXMgbG9nZ2luZyBhbmQgZGVwcmVjYXRpb24gdXRpbGl0aWVzXHJcbiAqIEBjbGFzcyBsb2dnZXJcclxuICogQG1lbWJlcm9mIGRjXHJcbiAqIEByZXR1cm5zIHtkYy5sb2dnZXJ9XHJcbiAqL1xyXG5kYy5sb2dnZXIgPSAoZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBfbG9nZ2VyID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmFibGUgZGVidWcgbGV2ZWwgbG9nZ2luZy4gU2V0IHRvIGBmYWxzZWAgYnkgZGVmYXVsdC5cclxuICAgICAqIEBuYW1lIGVuYWJsZURlYnVnTG9nXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMubG9nZ2VyXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgX2xvZ2dlci5lbmFibGVEZWJ1Z0xvZyA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHV0IGEgd2FybmluZyBtZXNzYWdlIHRvIGNvbnNvbGVcclxuICAgICAqIEBtZXRob2Qgd2FyblxyXG4gICAgICogQG1lbWJlcm9mIGRjLmxvZ2dlclxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogZGMubG9nZ2VyLndhcm4oJ0ludmFsaWQgdXNlIG9mIC50ZW5zaW9uIG9uIEN1cnZlTGluZWFyJyk7XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW21zZ11cclxuICAgICAqIEByZXR1cm5zIHtkYy5sb2dnZXJ9XHJcbiAgICAgKi9cclxuICAgIF9sb2dnZXIud2FybiA9IGZ1bmN0aW9uIChtc2cpIHtcclxuICAgICAgICBpZiAoY29uc29sZSkge1xyXG4gICAgICAgICAgICBpZiAoY29uc29sZS53YXJuKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4obXNnKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChjb25zb2xlLmxvZykge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cobXNnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIF9sb2dnZXI7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBfYWxyZWFkeVdhcm5lZCA9IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHV0IGEgd2FybmluZyBtZXNzYWdlIHRvIGNvbnNvbGUuIEl0IHdpbGwgd2FybiBvbmx5IG9uIHVuaXF1ZSBtZXNzYWdlcy5cclxuICAgICAqIEBtZXRob2Qgd2Fybk9uY2VcclxuICAgICAqIEBtZW1iZXJvZiBkYy5sb2dnZXJcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGRjLmxvZ2dlci53YXJuT25jZSgnSW52YWxpZCB1c2Ugb2YgLnRlbnNpb24gb24gQ3VydmVMaW5lYXInKTtcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbbXNnXVxyXG4gICAgICogQHJldHVybnMge2RjLmxvZ2dlcn1cclxuICAgICAqL1xyXG4gICAgX2xvZ2dlci53YXJuT25jZSA9IGZ1bmN0aW9uIChtc2cpIHtcclxuICAgICAgICBpZiAoIV9hbHJlYWR5V2FybmVkW21zZ10pIHtcclxuICAgICAgICAgICAgX2FscmVhZHlXYXJuZWRbbXNnXSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICBkYy5sb2dnZXIud2Fybihtc2cpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIF9sb2dnZXI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHV0IGEgZGVidWcgbWVzc2FnZSB0byBjb25zb2xlLiBJdCBpcyBjb250cm9sbGVkIGJ5IGBkYy5sb2dnZXIuZW5hYmxlRGVidWdMb2dgXHJcbiAgICAgKiBAbWV0aG9kIGRlYnVnXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMubG9nZ2VyXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBkYy5sb2dnZXIuZGVidWcoJ1RvdGFsIG51bWJlciBvZiBzbGljZXM6ICcgKyBudW1TbGljZXMpO1xyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFttc2ddXHJcbiAgICAgKiBAcmV0dXJucyB7ZGMubG9nZ2VyfVxyXG4gICAgICovXHJcbiAgICBfbG9nZ2VyLmRlYnVnID0gZnVuY3Rpb24gKG1zZykge1xyXG4gICAgICAgIGlmIChfbG9nZ2VyLmVuYWJsZURlYnVnTG9nICYmIGNvbnNvbGUpIHtcclxuICAgICAgICAgICAgaWYgKGNvbnNvbGUuZGVidWcpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcobXNnKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChjb25zb2xlLmxvZykge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cobXNnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIF9sb2dnZXI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXNlIGl0IHRvIGRlcHJlY2F0ZSBhIGZ1bmN0aW9uLiBJdCB3aWxsIHJldHVybiBhIHdyYXBwZWQgdmVyc2lvbiBvZiB0aGUgZnVuY3Rpb24sIHdoaWNoIHdpbGxcclxuICAgICAqIHdpbGwgaXNzdWUgYSB3YXJuaW5nIHdoZW4gaW52b2tlZC4gRm9yIGVhY2ggZnVuY3Rpb24sIHdhcm5pbmcgd2lsbCBiZSBpc3N1ZWQgb25seSBvbmNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZXRob2QgZGVwcmVjYXRlXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMubG9nZ2VyXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBfY2hhcnQuaW50ZXJwb2xhdGUgPSBkYy5sb2dnZXIuZGVwcmVjYXRlKGZ1bmN0aW9uIChpbnRlcnBvbGF0ZSkge1xyXG4gICAgICogICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgKiAgICAgICAgcmV0dXJuIF9pbnRlcnBvbGF0ZTtcclxuICAgICAqICAgIH1cclxuICAgICAqICAgIF9pbnRlcnBvbGF0ZSA9IGludGVycG9sYXRlO1xyXG4gICAgICogICAgcmV0dXJuIF9jaGFydDtcclxuICAgICAqIH0sICdkYy5saW5lQ2hhcnQuaW50ZXJwb2xhdGUgaGFzIGJlZW4gZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDMuMCB1c2UgZGMubGluZUNoYXJ0LmN1cnZlIGluc3RlYWQnKTtcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbbXNnXVxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufVxyXG4gICAgICovXHJcbiAgICBfbG9nZ2VyLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uIChmbiwgbXNnKSB7XHJcbiAgICAgICAgLy8gQWxsb3cgbG9nZ2luZyBvZiBkZXByZWNhdGlvblxyXG4gICAgICAgIHZhciB3YXJuZWQgPSBmYWxzZTtcclxuICAgICAgICBmdW5jdGlvbiBkZXByZWNhdGVkICgpIHtcclxuICAgICAgICAgICAgaWYgKCF3YXJuZWQpIHtcclxuICAgICAgICAgICAgICAgIF9sb2dnZXIud2Fybihtc2cpO1xyXG4gICAgICAgICAgICAgICAgd2FybmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRlcHJlY2F0ZWQ7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBfbG9nZ2VyO1xyXG59KSgpO1xyXG5cclxuLyoqXHJcbiAqIEdlbmVyYWwgY29uZmlndXJhdGlvblxyXG4gKlxyXG4gKiBAY2xhc3MgY29uZmlnXHJcbiAqIEBtZW1iZXJvZiBkY1xyXG4gKiBAcmV0dXJucyB7ZGMuY29uZmlnfVxyXG4gKi9cclxuZGMuY29uZmlnID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBfY29uZmlnID0ge307XHJcblxyXG4gICAgLy8gRDN2NSBoYXMgcmVtb3ZlZCBzY2hlbWVDYXRlZ29yeTIwYywgY29waWVkIGhlcmUgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcclxuICAgIHZhciBfc2NoZW1lQ2F0ZWdvcnkyMGMgPSBbXHJcbiAgICAgICAgJyMzMTgyYmQnLCAnIzZiYWVkNicsICcjOWVjYWUxJywgJyNjNmRiZWYnLCAnI2U2NTUwZCcsXHJcbiAgICAgICAgJyNmZDhkM2MnLCAnI2ZkYWU2YicsICcjZmRkMGEyJywgJyMzMWEzNTQnLCAnIzc0YzQ3NicsXHJcbiAgICAgICAgJyNhMWQ5OWInLCAnI2M3ZTljMCcsICcjNzU2YmIxJywgJyM5ZTlhYzgnLCAnI2JjYmRkYycsXHJcbiAgICAgICAgJyNkYWRhZWInLCAnIzYzNjM2MycsICcjOTY5Njk2JywgJyNiZGJkYmQnLCAnI2Q5ZDlkOSddO1xyXG5cclxuICAgIHZhciBfZGVmYXVsdENvbG9ycyA9IF9zY2hlbWVDYXRlZ29yeTIwYztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgZGVmYXVsdCBjb2xvciBzY2hlbWUgZm9yIG9yZGluYWwgY2hhcnRzLiBDaGFuZ2luZyBpdCB3aWxsIGltcGFjdCBhbGwgb3JkaW5hbCBjaGFydHMuXHJcbiAgICAgKlxyXG4gICAgICogQnkgZGVmYXVsdCBpdCBpcyBzZXQgdG8gYSBjb3B5IG9mXHJcbiAgICAgKiBgZDMuc2NoZW1lQ2F0ZWdvcnkyMGNgIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LiBUaGlzIGNvbG9yIHNjaGVtZSBoYXMgYmVlblxyXG4gICAgICogW3JlbW92ZWQgZnJvbSBEM3Y1XShodHRwczovL2dpdGh1Yi5jb20vZDMvZDMvYmxvYi9tYXN0ZXIvQ0hBTkdFUy5tZCNjaGFuZ2VzLWluLWQzLTUwKS5cclxuICAgICAqIEluIERDIDMuMSByZWxlYXNlIGl0IHdpbGwgY2hhbmdlIHRvIGEgbW9yZSBhcHByb3ByaWF0ZSBkZWZhdWx0LlxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBkYy5jb25maWcuZGVmYXVsdENvbG9ycyhkMy5zY2hlbWVTZXQxKVxyXG4gICAgICogQG1ldGhvZCBkZWZhdWx0Q29sb3JzXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuY29uZmlnXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb2xvcnNdXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8ZGMuY29uZmlnfVxyXG4gICAgICovXHJcbiAgICBfY29uZmlnLmRlZmF1bHRDb2xvcnMgPSBmdW5jdGlvbiAoY29sb3JzKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIC8vIElzc3VlIHdhcm5pbmcgaWYgaXQgdXNlcyBfc2NoZW1lQ2F0ZWdvcnkyMGNcclxuICAgICAgICAgICAgaWYgKF9kZWZhdWx0Q29sb3JzID09PSBfc2NoZW1lQ2F0ZWdvcnkyMGMpIHtcclxuICAgICAgICAgICAgICAgIGRjLmxvZ2dlci53YXJuT25jZSgnWW91IGFyZSB1c2luZyBkMy5zY2hlbWVDYXRlZ29yeTIwYywgd2hpY2ggaGFzIGJlZW4gcmVtb3ZlZCBpbiBEM3Y1LiAnICtcclxuICAgICAgICAgICAgICAgICAgICAnU2VlIHRoZSBleHBsYW5hdGlvbiBhdCBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMvYmxvYi9tYXN0ZXIvQ0hBTkdFUy5tZCNjaGFuZ2VzLWluLWQzLTUwLiAnICtcclxuICAgICAgICAgICAgICAgICAgICAnREMgaXMgdXNpbmcgaXQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIGhvd2V2ZXIgaXQgd2lsbCBiZSBjaGFuZ2VkIGluIERDdjMuMS4gJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ1lvdSBjYW4gY2hhbmdlIGl0IGJ5IGNhbGxpbmcgZGMuY29uZmlnLmRlZmF1bHRDb2xvcnMobmV3U2NoZW1lKS4gJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ1NlZSBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2NhbGUtY2hyb21hdGljIGZvciBzb21lIGFsdGVybmF0aXZlcy4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gX2RlZmF1bHRDb2xvcnM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9kZWZhdWx0Q29sb3JzID0gY29sb3JzO1xyXG4gICAgICAgIHJldHVybiBfY29uZmlnO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gX2NvbmZpZztcclxufSkoKTtcclxuXHJcbmRjLmV2ZW50cyA9IHtcclxuICAgIGN1cnJlbnQ6IG51bGxcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIHRyaWdnZXJzIGEgdGhyb3R0bGVkIGV2ZW50IGZ1bmN0aW9uIHdpdGggYSBzcGVjaWZpZWQgZGVsYXkgKGluIG1pbGxpLXNlY29uZHMpLiAgRXZlbnRzXHJcbiAqIHRoYXQgYXJlIHRyaWdnZXJlZCByZXBldGl0aXZlbHkgZHVlIHRvIHVzZXIgaW50ZXJhY3Rpb24gc3VjaCBicnVzaCBkcmFnZ2luZyBtaWdodCBmbG9vZCB0aGUgbGlicmFyeVxyXG4gKiBhbmQgaW52b2tlIG1vcmUgcmVuZGVycyB0aGFuIGNhbiBiZSBleGVjdXRlZCBpbiB0aW1lLiBVc2luZyB0aGlzIGZ1bmN0aW9uIHRvIHdyYXAgeW91ciBldmVudFxyXG4gKiBmdW5jdGlvbiBhbGxvd3MgdGhlIGxpYnJhcnkgdG8gc21vb3RoIG91dCB0aGUgcmVuZGVyaW5nIGJ5IHRocm90dGxpbmcgZXZlbnRzIGFuZCBvbmx5IHJlc3BvbmRpbmcgdG9cclxuICogdGhlIG1vc3QgcmVjZW50IGV2ZW50LlxyXG4gKiBAbmFtZSBldmVudHMudHJpZ2dlclxyXG4gKiBAbWVtYmVyb2YgZGNcclxuICogQGV4YW1wbGVcclxuICogY2hhcnQub24oJ3JlbmRlcmxldCcsIGZ1bmN0aW9uKGNoYXJ0KSB7XHJcbiAqICAgICAvLyBzbW9vdGggdGhlIHJlbmRlcmluZyB0aHJvdWdoIGV2ZW50IHRocm90dGxpbmdcclxuICogICAgIGRjLmV2ZW50cy50cmlnZ2VyKGZ1bmN0aW9uKCl7XHJcbiAqICAgICAgICAgLy8gZm9jdXMgc29tZSBvdGhlciBjaGFydCB0byB0aGUgcmFuZ2Ugc2VsZWN0ZWQgYnkgdXNlciBvbiB0aGlzIGNoYXJ0XHJcbiAqICAgICAgICAgc29tZU90aGVyQ2hhcnQuZm9jdXMoY2hhcnQuZmlsdGVyKCkpO1xyXG4gKiAgICAgfSk7XHJcbiAqIH0pXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNsb3N1cmVcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtkZWxheV1cclxuICovXHJcbmRjLmV2ZW50cy50cmlnZ2VyID0gZnVuY3Rpb24gKGNsb3N1cmUsIGRlbGF5KSB7XHJcbiAgICBpZiAoIWRlbGF5KSB7XHJcbiAgICAgICAgY2xvc3VyZSgpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBkYy5ldmVudHMuY3VycmVudCA9IGNsb3N1cmU7XHJcblxyXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKGNsb3N1cmUgPT09IGRjLmV2ZW50cy5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIGNsb3N1cmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9LCBkZWxheSk7XHJcbn07XHJcblxyXG4vKipcclxuICogVGhlIGRjLmpzIGZpbHRlcnMgYXJlIGZ1bmN0aW9ucyB3aGljaCBhcmUgcGFzc2VkIGludG8gY3Jvc3NmaWx0ZXIgdG8gY2hvc2Ugd2hpY2ggcmVjb3JkcyB3aWxsIGJlXHJcbiAqIGFjY3VtdWxhdGVkIHRvIHByb2R1Y2UgdmFsdWVzIGZvciB0aGUgY2hhcnRzLiAgSW4gdGhlIGNyb3NzZmlsdGVyIG1vZGVsLCBhbnkgZmlsdGVycyBhcHBsaWVkIG9uIG9uZVxyXG4gKiBkaW1lbnNpb24gd2lsbCBhZmZlY3QgYWxsIHRoZSBvdGhlciBkaW1lbnNpb25zIGJ1dCBub3QgdGhhdCBvbmUuICBkYyBhbHdheXMgYXBwbGllcyBhIGZpbHRlclxyXG4gKiBmdW5jdGlvbiB0byB0aGUgZGltZW5zaW9uOyB0aGUgZnVuY3Rpb24gY29tYmluZXMgbXVsdGlwbGUgZmlsdGVycyBhbmQgaWYgYW55IG9mIHRoZW0gYWNjZXB0IGFcclxuICogcmVjb3JkLCBpdCBpcyBmaWx0ZXJlZCBpbi5cclxuICpcclxuICogVGhlc2UgZmlsdGVyIGNvbnN0cnVjdG9ycyBhcmUgdXNlZCBhcyBhcHByb3ByaWF0ZSBieSB0aGUgdmFyaW91cyBjaGFydHMgdG8gaW1wbGVtZW50IGJydXNoaW5nLiAgV2VcclxuICogbWVudGlvbiBiZWxvdyB3aGljaCBjaGFydCB1c2VzIHdoaWNoIGZpbHRlci4gIEluIHNvbWUgY2FzZXMsIG1hbnkgaW5zdGFuY2VzIG9mIGEgZmlsdGVyIHdpbGwgYmUgYWRkZWQuXHJcbiAqXHJcbiAqIEVhY2ggb2YgdGhlIGRjLmpzIGZpbHRlcnMgaXMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxyXG4gKiAqIGBpc0ZpbHRlcmVkYCAtIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydWUgaWYgYSB2YWx1ZSBpcyB3aXRoaW4gdGhlIGZpbHRlclxyXG4gKiAqIGBmaWx0ZXJUeXBlYCAtIGEgc3RyaW5nIGlkZW50aWZ5aW5nIHRoZSBmaWx0ZXIsIGhlcmUgdGhlIG5hbWUgb2YgdGhlIGNvbnN0cnVjdG9yXHJcbiAqXHJcbiAqIEN1cnJlbnRseSB0aGVzZSBmaWx0ZXIgb2JqZWN0cyBhcmUgYWxzbyBhcnJheXMsIGJ1dCB0aGlzIGlzIG5vdCBhIHJlcXVpcmVtZW50LiBDdXN0b20gZmlsdGVyc1xyXG4gKiBjYW4gYmUgdXNlZCBhcyBsb25nIGFzIHRoZXkgaGF2ZSB0aGUgcHJvcGVydGllcyBhYm92ZS5cclxuICogQG5hbWVzcGFjZSBmaWx0ZXJzXHJcbiAqIEBtZW1iZXJvZiBkY1xyXG4gKiBAdHlwZSB7e319XHJcbiAqL1xyXG5kYy5maWx0ZXJzID0ge307XHJcblxyXG4vKipcclxuICogUmFuZ2VkRmlsdGVyIGlzIGEgZmlsdGVyIHdoaWNoIGFjY2VwdHMga2V5cyBiZXR3ZWVuIGBsb3dgIGFuZCBgaGlnaGAuICBJdCBpcyB1c2VkIHRvIGltcGxlbWVudCBYXHJcbiAqIGF4aXMgYnJ1c2hpbmcgZm9yIHRoZSB7QGxpbmsgZGMuY29vcmRpbmF0ZUdyaWRNaXhpbiBjb29yZGluYXRlIGdyaWQgY2hhcnRzfS5cclxuICpcclxuICogSXRzIGBmaWx0ZXJUeXBlYCBpcyAnUmFuZ2VkRmlsdGVyJ1xyXG4gKiBAbmFtZSBSYW5nZWRGaWx0ZXJcclxuICogQG1lbWJlcm9mIGRjLmZpbHRlcnNcclxuICogQHBhcmFtIHtOdW1iZXJ9IGxvd1xyXG4gKiBAcGFyYW0ge051bWJlcn0gaGlnaFxyXG4gKiBAcmV0dXJucyB7QXJyYXk8TnVtYmVyPn1cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5kYy5maWx0ZXJzLlJhbmdlZEZpbHRlciA9IGZ1bmN0aW9uIChsb3csIGhpZ2gpIHtcclxuICAgIHZhciByYW5nZSA9IG5ldyBBcnJheShsb3csIGhpZ2gpO1xyXG4gICAgcmFuZ2UuaXNGaWx0ZXJlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZSA+PSB0aGlzWzBdICYmIHZhbHVlIDwgdGhpc1sxXTtcclxuICAgIH07XHJcbiAgICByYW5nZS5maWx0ZXJUeXBlID0gJ1JhbmdlZEZpbHRlcic7XHJcblxyXG4gICAgcmV0dXJuIHJhbmdlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFR3b0RpbWVuc2lvbmFsRmlsdGVyIGlzIGEgZmlsdGVyIHdoaWNoIGFjY2VwdHMgYSBzaW5nbGUgdHdvLWRpbWVuc2lvbmFsIHZhbHVlLiAgSXQgaXMgdXNlZCBieSB0aGVcclxuICoge0BsaW5rIGRjLmhlYXRNYXAgaGVhdCBtYXAgY2hhcnR9IHRvIGluY2x1ZGUgcGFydGljdWxhciBjZWxscyBhcyB0aGV5IGFyZSBjbGlja2VkLiAgKFJvd3MgYW5kIGNvbHVtbnMgYXJlXHJcbiAqIGZpbHRlcmVkIGJ5IGZpbHRlcmluZyBhbGwgdGhlIGNlbGxzIGluIHRoZSByb3cgb3IgY29sdW1uLilcclxuICpcclxuICogSXRzIGBmaWx0ZXJUeXBlYCBpcyAnVHdvRGltZW5zaW9uYWxGaWx0ZXInXHJcbiAqIEBuYW1lIFR3b0RpbWVuc2lvbmFsRmlsdGVyXHJcbiAqIEBtZW1iZXJvZiBkYy5maWx0ZXJzXHJcbiAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gZmlsdGVyXHJcbiAqIEByZXR1cm5zIHtBcnJheTxOdW1iZXI+fVxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmRjLmZpbHRlcnMuVHdvRGltZW5zaW9uYWxGaWx0ZXIgPSBmdW5jdGlvbiAoZmlsdGVyKSB7XHJcbiAgICBpZiAoZmlsdGVyID09PSBudWxsKSB7IHJldHVybiBudWxsOyB9XHJcblxyXG4gICAgdmFyIGYgPSBmaWx0ZXI7XHJcbiAgICBmLmlzRmlsdGVyZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoICYmIHZhbHVlLmxlbmd0aCA9PT0gZi5sZW5ndGggJiZcclxuICAgICAgICAgICAgICAgdmFsdWVbMF0gPT09IGZbMF0gJiYgdmFsdWVbMV0gPT09IGZbMV07XHJcbiAgICB9O1xyXG4gICAgZi5maWx0ZXJUeXBlID0gJ1R3b0RpbWVuc2lvbmFsRmlsdGVyJztcclxuXHJcbiAgICByZXR1cm4gZjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgUmFuZ2VkVHdvRGltZW5zaW9uYWxGaWx0ZXIgYWxsb3dzIGZpbHRlcmluZyBhbGwgdmFsdWVzIHdoaWNoIGZpdCB3aXRoaW4gYSByZWN0YW5ndWxhclxyXG4gKiByZWdpb24uIEl0IGlzIHVzZWQgYnkgdGhlIHtAbGluayBkYy5zY2F0dGVyUGxvdCBzY2F0dGVyIHBsb3R9IHRvIGltcGxlbWVudCByZWN0YW5ndWxhciBicnVzaGluZy5cclxuICpcclxuICogSXQgdGFrZXMgdHdvIHR3by1kaW1lbnNpb25hbCBwb2ludHMgaW4gdGhlIGZvcm0gYFtbeDEseTFdLFt4Mix5Ml1dYCwgYW5kIG5vcm1hbGl6ZXMgdGhlbSBzbyB0aGF0XHJcbiAqIGB4MSA8PSB4MmAgYW5kIGB5MSA8PSB5MmAuIEl0IHRoZW4gcmV0dXJucyBhIGZpbHRlciB3aGljaCBhY2NlcHRzIGFueSBwb2ludHMgd2hpY2ggYXJlIGluIHRoZVxyXG4gKiByZWN0YW5ndWxhciByYW5nZSBpbmNsdWRpbmcgdGhlIGxvd2VyIHZhbHVlcyBidXQgZXhjbHVkaW5nIHRoZSBoaWdoZXIgdmFsdWVzLlxyXG4gKlxyXG4gKiBJZiBhbiBhcnJheSBvZiB0d28gdmFsdWVzIGFyZSBnaXZlbiB0byB0aGUgUmFuZ2VkVHdvRGltZW5zaW9uYWxGaWx0ZXIsIGl0IGludGVycHJldHMgdGhlIHZhbHVlcyBhc1xyXG4gKiB0d28geCBjb29yZGluYXRlcyBgeDFgIGFuZCBgeDJgIGFuZCByZXR1cm5zIGEgZmlsdGVyIHdoaWNoIGFjY2VwdHMgYW55IHBvaW50cyBmb3Igd2hpY2ggYHgxIDw9IHggPFxyXG4gKiB4MmAuXHJcbiAqXHJcbiAqIEl0cyBgZmlsdGVyVHlwZWAgaXMgJ1JhbmdlZFR3b0RpbWVuc2lvbmFsRmlsdGVyJ1xyXG4gKiBAbmFtZSBSYW5nZWRUd29EaW1lbnNpb25hbEZpbHRlclxyXG4gKiBAbWVtYmVyb2YgZGMuZmlsdGVyc1xyXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PE51bWJlcj4+fSBmaWx0ZXJcclxuICogQHJldHVybnMge0FycmF5PEFycmF5PE51bWJlcj4+fVxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmRjLmZpbHRlcnMuUmFuZ2VkVHdvRGltZW5zaW9uYWxGaWx0ZXIgPSBmdW5jdGlvbiAoZmlsdGVyKSB7XHJcbiAgICBpZiAoZmlsdGVyID09PSBudWxsKSB7IHJldHVybiBudWxsOyB9XHJcblxyXG4gICAgdmFyIGYgPSBmaWx0ZXI7XHJcbiAgICB2YXIgZnJvbUJvdHRvbUxlZnQ7XHJcblxyXG4gICAgaWYgKGZbMF0gaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAgIGZyb21Cb3R0b21MZWZ0ID0gW1xyXG4gICAgICAgICAgICBbTWF0aC5taW4oZmlsdGVyWzBdWzBdLCBmaWx0ZXJbMV1bMF0pLCBNYXRoLm1pbihmaWx0ZXJbMF1bMV0sIGZpbHRlclsxXVsxXSldLFxyXG4gICAgICAgICAgICBbTWF0aC5tYXgoZmlsdGVyWzBdWzBdLCBmaWx0ZXJbMV1bMF0pLCBNYXRoLm1heChmaWx0ZXJbMF1bMV0sIGZpbHRlclsxXVsxXSldXHJcbiAgICAgICAgXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZnJvbUJvdHRvbUxlZnQgPSBbW2ZpbHRlclswXSwgLUluZmluaXR5XSwgW2ZpbHRlclsxXSwgSW5maW5pdHldXTtcclxuICAgIH1cclxuXHJcbiAgICBmLmlzRmlsdGVyZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICB2YXIgeCwgeTtcclxuXHJcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgICAgICAgeCA9IHZhbHVlWzBdO1xyXG4gICAgICAgICAgICB5ID0gdmFsdWVbMV07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgeCA9IHZhbHVlO1xyXG4gICAgICAgICAgICB5ID0gZnJvbUJvdHRvbUxlZnRbMF1bMV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4geCA+PSBmcm9tQm90dG9tTGVmdFswXVswXSAmJiB4IDwgZnJvbUJvdHRvbUxlZnRbMV1bMF0gJiZcclxuICAgICAgICAgICAgICAgeSA+PSBmcm9tQm90dG9tTGVmdFswXVsxXSAmJiB5IDwgZnJvbUJvdHRvbUxlZnRbMV1bMV07XHJcbiAgICB9O1xyXG4gICAgZi5maWx0ZXJUeXBlID0gJ1JhbmdlZFR3b0RpbWVuc2lvbmFsRmlsdGVyJztcclxuXHJcbiAgICByZXR1cm4gZjtcclxufTtcclxuXHJcbi8vICoqKioqKioqIFN1bmJ1cnN0IENoYXJ0ICoqKioqKioqXHJcblxyXG4vKipcclxuICogSGllcmFyY2h5RmlsdGVyIGlzIGEgZmlsdGVyIHdoaWNoIGFjY2VwdHMgYSBrZXkgcGF0aCBhcyBhbiBhcnJheS4gSXQgbWF0Y2hlcyBhbnkgbm9kZSBhdCwgb3JcclxuICogY2hpbGQgb2YsIHRoZSBnaXZlbiBwYXRoLiBJdCBpcyB1c2VkIGJ5IHRoZSB7QGxpbmsgZGMuc3VuYnVyc3RDaGFydCBzdW5idXJzdCBjaGFydH0gdG8gaW5jbHVkZSBwYXJ0aWN1bGFyIGNlbGxzIGFuZCBhbGxcclxuICogdGhlaXIgY2hpbGRyZW4gYXMgdGhleSBhcmUgY2xpY2tlZC5cclxuICpcclxuICogQG5hbWUgSGllcmFyY2h5RmlsdGVyXHJcbiAqIEBtZW1iZXJvZiBkYy5maWx0ZXJzXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXHJcbiAqIEByZXR1cm5zIHtBcnJheTxTdHJpbmc+fVxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmRjLmZpbHRlcnMuSGllcmFyY2h5RmlsdGVyID0gZnVuY3Rpb24gKHBhdGgpIHtcclxuICAgIGlmIChwYXRoID09PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGZpbHRlciA9IHBhdGguc2xpY2UoMCk7XHJcbiAgICBmaWx0ZXIuaXNGaWx0ZXJlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIGlmICghKGZpbHRlci5sZW5ndGggJiYgdmFsdWUgJiYgdmFsdWUubGVuZ3RoICYmIHZhbHVlLmxlbmd0aCA+PSBmaWx0ZXIubGVuZ3RoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbHRlci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodmFsdWVbaV0gIT09IGZpbHRlcltpXSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZmlsdGVyO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIGBkYy5iYXNlTWl4aW5gIGlzIGFuIGFic3RyYWN0IGZ1bmN0aW9uYWwgb2JqZWN0IHJlcHJlc2VudGluZyBhIGJhc2ljIGBkY2AgY2hhcnQgb2JqZWN0XHJcbiAqIGZvciBhbGwgY2hhcnQgYW5kIHdpZGdldCBpbXBsZW1lbnRhdGlvbnMuIE1ldGhvZHMgZnJvbSB0aGUge0BsaW5rICNkYy5iYXNlTWl4aW4gZGMuYmFzZU1peGlufSBhcmUgaW5oZXJpdGVkXHJcbiAqIGFuZCBhdmFpbGFibGUgb24gYWxsIGNoYXJ0IGltcGxlbWVudGF0aW9ucyBpbiB0aGUgYGRjYCBsaWJyYXJ5LlxyXG4gKiBAbmFtZSBiYXNlTWl4aW5cclxuICogQG1lbWJlcm9mIGRjXHJcbiAqIEBtaXhpblxyXG4gKiBAcGFyYW0ge09iamVjdH0gX2NoYXJ0XHJcbiAqIEByZXR1cm5zIHtkYy5iYXNlTWl4aW59XHJcbiAqL1xyXG5kYy5iYXNlTWl4aW4gPSBmdW5jdGlvbiAoX2NoYXJ0KSB7XHJcbiAgICBfY2hhcnQuX19kY0ZsYWdfXyA9IGRjLnV0aWxzLnVuaXF1ZUlkKCk7XHJcblxyXG4gICAgdmFyIF9kaW1lbnNpb247XHJcbiAgICB2YXIgX2dyb3VwO1xyXG5cclxuICAgIHZhciBfYW5jaG9yO1xyXG4gICAgdmFyIF9yb290O1xyXG4gICAgdmFyIF9zdmc7XHJcbiAgICB2YXIgX2lzQ2hpbGQ7XHJcblxyXG4gICAgdmFyIF9taW5XaWR0aCA9IDIwMDtcclxuICAgIHZhciBfZGVmYXVsdFdpZHRoQ2FsYyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gZWxlbWVudCAmJiBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCAmJiBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xyXG4gICAgICAgIHJldHVybiAod2lkdGggJiYgd2lkdGggPiBfbWluV2lkdGgpID8gd2lkdGggOiBfbWluV2lkdGg7XHJcbiAgICB9O1xyXG4gICAgdmFyIF93aWR0aENhbGMgPSBfZGVmYXVsdFdpZHRoQ2FsYztcclxuXHJcbiAgICB2YXIgX21pbkhlaWdodCA9IDIwMDtcclxuICAgIHZhciBfZGVmYXVsdEhlaWdodENhbGMgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSBlbGVtZW50ICYmIGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICYmIGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xyXG4gICAgICAgIHJldHVybiAoaGVpZ2h0ICYmIGhlaWdodCA+IF9taW5IZWlnaHQpID8gaGVpZ2h0IDogX21pbkhlaWdodDtcclxuICAgIH07XHJcbiAgICB2YXIgX2hlaWdodENhbGMgPSBfZGVmYXVsdEhlaWdodENhbGM7XHJcbiAgICB2YXIgX3dpZHRoLCBfaGVpZ2h0O1xyXG4gICAgdmFyIF91c2VWaWV3Qm94UmVzaXppbmcgPSBmYWxzZTtcclxuXHJcbiAgICB2YXIgX2tleUFjY2Vzc29yID0gZGMucGx1Y2soJ2tleScpO1xyXG4gICAgdmFyIF92YWx1ZUFjY2Vzc29yID0gZGMucGx1Y2soJ3ZhbHVlJyk7XHJcbiAgICB2YXIgX2xhYmVsID0gZGMucGx1Y2soJ2tleScpO1xyXG5cclxuICAgIHZhciBfb3JkZXJpbmcgPSBkYy5wbHVjaygna2V5Jyk7XHJcbiAgICB2YXIgX29yZGVyU29ydDtcclxuXHJcbiAgICB2YXIgX3JlbmRlckxhYmVsID0gZmFsc2U7XHJcblxyXG4gICAgdmFyIF90aXRsZSA9IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydC5rZXlBY2Nlc3NvcigpKGQpICsgJzogJyArIF9jaGFydC52YWx1ZUFjY2Vzc29yKCkoZCk7XHJcbiAgICB9O1xyXG4gICAgdmFyIF9yZW5kZXJUaXRsZSA9IHRydWU7XHJcbiAgICB2YXIgX2NvbnRyb2xzVXNlVmlzaWJpbGl0eSA9IGZhbHNlO1xyXG5cclxuICAgIHZhciBfdHJhbnNpdGlvbkR1cmF0aW9uID0gNzUwO1xyXG5cclxuICAgIHZhciBfdHJhbnNpdGlvbkRlbGF5ID0gMDtcclxuXHJcbiAgICB2YXIgX2ZpbHRlclByaW50ZXIgPSBkYy5wcmludGVycy5maWx0ZXJzO1xyXG5cclxuICAgIHZhciBfbWFuZGF0b3J5QXR0cmlidXRlcyA9IFsnZGltZW5zaW9uJywgJ2dyb3VwJ107XHJcblxyXG4gICAgdmFyIF9jaGFydEdyb3VwID0gZGMuY29uc3RhbnRzLkRFRkFVTFRfQ0hBUlRfR1JPVVA7XHJcblxyXG4gICAgdmFyIF9saXN0ZW5lcnMgPSBkMy5kaXNwYXRjaChcclxuICAgICAgICAncHJlUmVuZGVyJyxcclxuICAgICAgICAncG9zdFJlbmRlcicsXHJcbiAgICAgICAgJ3ByZVJlZHJhdycsXHJcbiAgICAgICAgJ3Bvc3RSZWRyYXcnLFxyXG4gICAgICAgICdmaWx0ZXJlZCcsXHJcbiAgICAgICAgJ3pvb21lZCcsXHJcbiAgICAgICAgJ3JlbmRlcmxldCcsXHJcbiAgICAgICAgJ3ByZXRyYW5zaXRpb24nKTtcclxuXHJcbiAgICB2YXIgX2xlZ2VuZDtcclxuICAgIHZhciBfY29tbWl0SGFuZGxlcjtcclxuXHJcbiAgICB2YXIgX2ZpbHRlcnMgPSBbXTtcclxuICAgIHZhciBfZmlsdGVySGFuZGxlciA9IGZ1bmN0aW9uIChkaW1lbnNpb24sIGZpbHRlcnMpIHtcclxuICAgICAgICBpZiAoZmlsdGVycy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgZGltZW5zaW9uLmZpbHRlcihudWxsKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGZpbHRlcnMubGVuZ3RoID09PSAxICYmICFmaWx0ZXJzWzBdLmlzRmlsdGVyZWQpIHtcclxuICAgICAgICAgICAgLy8gc2luZ2xlIHZhbHVlIGFuZCBub3QgYSBmdW5jdGlvbi1iYXNlZCBmaWx0ZXJcclxuICAgICAgICAgICAgZGltZW5zaW9uLmZpbHRlckV4YWN0KGZpbHRlcnNbMF0pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZmlsdGVycy5sZW5ndGggPT09IDEgJiYgZmlsdGVyc1swXS5maWx0ZXJUeXBlID09PSAnUmFuZ2VkRmlsdGVyJykge1xyXG4gICAgICAgICAgICAvLyBzaW5nbGUgcmFuZ2UtYmFzZWQgZmlsdGVyXHJcbiAgICAgICAgICAgIGRpbWVuc2lvbi5maWx0ZXJSYW5nZShmaWx0ZXJzWzBdKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBkaW1lbnNpb24uZmlsdGVyRnVuY3Rpb24oZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsdGVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWx0ZXIgPSBmaWx0ZXJzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXIuaXNGaWx0ZXJlZCAmJiBmaWx0ZXIuaXNGaWx0ZXJlZChkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZpbHRlciA8PSBkICYmIGZpbHRlciA+PSBkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmaWx0ZXJzO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgX2RhdGEgPSBmdW5jdGlvbiAoZ3JvdXApIHtcclxuICAgICAgICByZXR1cm4gZ3JvdXAuYWxsKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IG9yIGdldCB0aGUgaGVpZ2h0IGF0dHJpYnV0ZSBvZiBhIGNoYXJ0LiBUaGUgaGVpZ2h0IGlzIGFwcGxpZWQgdG8gdGhlIFNWR0VsZW1lbnQgZ2VuZXJhdGVkIGJ5XHJcbiAgICAgKiB0aGUgY2hhcnQgd2hlbiByZW5kZXJlZCAob3IgcmUtcmVuZGVyZWQpLiBJZiBhIHZhbHVlIGlzIGdpdmVuLCB0aGVuIGl0IHdpbGwgYmUgdXNlZCB0byBjYWxjdWxhdGVcclxuICAgICAqIHRoZSBuZXcgaGVpZ2h0IGFuZCB0aGUgY2hhcnQgcmV0dXJuZWQgZm9yIG1ldGhvZCBjaGFpbmluZy4gIFRoZSB2YWx1ZSBjYW4gZWl0aGVyIGJlIGEgbnVtZXJpYywgYVxyXG4gICAgICogZnVuY3Rpb24sIG9yIGZhbHN5LiBJZiBubyB2YWx1ZSBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgdmFsdWUgb2YgdGhlIGN1cnJlbnQgaGVpZ2h0IGF0dHJpYnV0ZSB3aWxsXHJcbiAgICAgKiBiZSByZXR1cm5lZC5cclxuICAgICAqXHJcbiAgICAgKiBCeSBkZWZhdWx0LCB3aXRob3V0IGFuIGV4cGxpY2l0IGhlaWdodCBiZWluZyBnaXZlbiwgdGhlIGNoYXJ0IHdpbGwgc2VsZWN0IHRoZSB3aWR0aCBvZiBpdHNcclxuICAgICAqIGFuY2hvciBlbGVtZW50LiBJZiB0aGF0IGlzbid0IHBvc3NpYmxlIGl0IGRlZmF1bHRzIHRvIDIwMCAocHJvdmlkZWQgYnkgdGhlXHJcbiAgICAgKiB7QGxpbmsgZGMuYmFzZU1peGluI21pbkhlaWdodCBtaW5IZWlnaHR9IHByb3BlcnR5KS4gU2V0dGluZyB0aGUgdmFsdWUgZmFsc3kgd2lsbCByZXR1cm5cclxuICAgICAqIHRoZSBjaGFydCB0byB0aGUgZGVmYXVsdCBiZWhhdmlvci5cclxuICAgICAqIEBtZXRob2QgaGVpZ2h0XHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuYmFzZU1peGluXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBzZWUge0BsaW5rIGRjLmJhc2VNaXhpbiNtaW5IZWlnaHQgbWluSGVpZ2h0fVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIERlZmF1bHQgaGVpZ2h0XHJcbiAgICAgKiBjaGFydC5oZWlnaHQoZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAqICAgICB2YXIgaGVpZ2h0ID0gZWxlbWVudCAmJiBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCAmJiBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcclxuICAgICAqICAgICByZXR1cm4gKGhlaWdodCAmJiBoZWlnaHQgPiBjaGFydC5taW5IZWlnaHQoKSkgPyBoZWlnaHQgOiBjaGFydC5taW5IZWlnaHQoKTtcclxuICAgICAqIH0pO1xyXG4gICAgICpcclxuICAgICAqIGNoYXJ0LmhlaWdodCgyNTApOyAvLyBTZXQgdGhlIGNoYXJ0J3MgaGVpZ2h0IHRvIDI1MHB4O1xyXG4gICAgICogY2hhcnQuaGVpZ2h0KGZ1bmN0aW9uKGFuY2hvcikgeyByZXR1cm4gZG9Tb21ldGhpbmdXaXRoKGFuY2hvcik7IH0pOyAvLyBzZXQgdGhlIGNoYXJ0J3MgaGVpZ2h0IHdpdGggYSBmdW5jdGlvblxyXG4gICAgICogY2hhcnQuaGVpZ2h0KG51bGwpOyAvLyByZXNldCB0aGUgaGVpZ2h0IHRvIHRoZSBkZWZhdWx0IGF1dG8gY2FsY3VsYXRpb25cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfEZ1bmN0aW9ufSBbaGVpZ2h0XVxyXG4gICAgICogQHJldHVybnMge051bWJlcnxkYy5iYXNlTWl4aW59XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5oZWlnaHQgPSBmdW5jdGlvbiAoaGVpZ2h0KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGlmICghZGMudXRpbHMuaXNOdW1iZXIoX2hlaWdodCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIG9ubHkgY2FsY3VsYXRlIG9uY2VcclxuICAgICAgICAgICAgICAgIF9oZWlnaHQgPSBfaGVpZ2h0Q2FsYyhfcm9vdC5ub2RlKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBfaGVpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBfaGVpZ2h0Q2FsYyA9IGhlaWdodCA/ICh0eXBlb2YgaGVpZ2h0ID09PSAnZnVuY3Rpb24nID8gaGVpZ2h0IDogZGMudXRpbHMuY29uc3RhbnQoaGVpZ2h0KSkgOiBfZGVmYXVsdEhlaWdodENhbGM7XHJcbiAgICAgICAgX2hlaWdodCA9IHVuZGVmaW5lZDtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBvciBnZXQgdGhlIHdpZHRoIGF0dHJpYnV0ZSBvZiBhIGNoYXJ0LlxyXG4gICAgICogQG1ldGhvZCB3aWR0aFxyXG4gICAgICogQG1lbWJlcm9mIGRjLmJhc2VNaXhpblxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAc2VlIHtAbGluayBkYy5iYXNlTWl4aW4jaGVpZ2h0IGhlaWdodH1cclxuICAgICAqIEBzZWUge0BsaW5rIGRjLmJhc2VNaXhpbiNtaW5XaWR0aCBtaW5XaWR0aH1cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBEZWZhdWx0IHdpZHRoXHJcbiAgICAgKiBjaGFydC53aWR0aChmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICogICAgIHZhciB3aWR0aCA9IGVsZW1lbnQgJiYgZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgJiYgZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcclxuICAgICAqICAgICByZXR1cm4gKHdpZHRoICYmIHdpZHRoID4gY2hhcnQubWluV2lkdGgoKSkgPyB3aWR0aCA6IGNoYXJ0Lm1pbldpZHRoKCk7XHJcbiAgICAgKiB9KTtcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfEZ1bmN0aW9ufSBbd2lkdGhdXHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfGRjLmJhc2VNaXhpbn1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LndpZHRoID0gZnVuY3Rpb24gKHdpZHRoKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGlmICghZGMudXRpbHMuaXNOdW1iZXIoX3dpZHRoKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gb25seSBjYWxjdWxhdGUgb25jZVxyXG4gICAgICAgICAgICAgICAgX3dpZHRoID0gX3dpZHRoQ2FsYyhfcm9vdC5ub2RlKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBfd2lkdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF93aWR0aENhbGMgPSB3aWR0aCA/ICh0eXBlb2Ygd2lkdGggPT09ICdmdW5jdGlvbicgPyB3aWR0aCA6IGRjLnV0aWxzLmNvbnN0YW50KHdpZHRoKSkgOiBfZGVmYXVsdFdpZHRoQ2FsYztcclxuICAgICAgICBfd2lkdGggPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgb3IgZ2V0IHRoZSBtaW5pbXVtIHdpZHRoIGF0dHJpYnV0ZSBvZiBhIGNoYXJ0LiBUaGlzIG9ubHkgaGFzIGVmZmVjdCB3aGVuIHVzZWQgd2l0aCB0aGUgZGVmYXVsdFxyXG4gICAgICoge0BsaW5rIGRjLmJhc2VNaXhpbiN3aWR0aCB3aWR0aH0gZnVuY3Rpb24uXHJcbiAgICAgKiBAbWV0aG9kIG1pbldpZHRoXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuYmFzZU1peGluXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBzZWUge0BsaW5rIGRjLmJhc2VNaXhpbiN3aWR0aCB3aWR0aH1cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbbWluV2lkdGg9MjAwXVxyXG4gICAgICogQHJldHVybnMge051bWJlcnxkYy5iYXNlTWl4aW59XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5taW5XaWR0aCA9IGZ1bmN0aW9uIChtaW5XaWR0aCkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX21pbldpZHRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfbWluV2lkdGggPSBtaW5XaWR0aDtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBvciBnZXQgdGhlIG1pbmltdW0gaGVpZ2h0IGF0dHJpYnV0ZSBvZiBhIGNoYXJ0LiBUaGlzIG9ubHkgaGFzIGVmZmVjdCB3aGVuIHVzZWQgd2l0aCB0aGUgZGVmYXVsdFxyXG4gICAgICoge0BsaW5rIGRjLmJhc2VNaXhpbiNoZWlnaHQgaGVpZ2h0fSBmdW5jdGlvbi5cclxuICAgICAqIEBtZXRob2QgbWluSGVpZ2h0XHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuYmFzZU1peGluXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBzZWUge0BsaW5rIGRjLmJhc2VNaXhpbiNoZWlnaHQgaGVpZ2h0fVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFttaW5IZWlnaHQ9MjAwXVxyXG4gICAgICogQHJldHVybnMge051bWJlcnxkYy5iYXNlTWl4aW59XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5taW5IZWlnaHQgPSBmdW5jdGlvbiAobWluSGVpZ2h0KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfbWluSGVpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBfbWluSGVpZ2h0ID0gbWluSGVpZ2h0O1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHVybiBvbi9vZmYgdXNpbmcgdGhlIFNWR1xyXG4gICAgICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvdmlld0JveCBgdmlld0JveGAgYXR0cmlidXRlfS5cclxuICAgICAqIFdoZW4gZW5hYmxlZCwgYHZpZXdCb3hgIHdpbGwgYmUgc2V0IG9uIHRoZSBzdmcgcm9vdCBlbGVtZW50IGluc3RlYWQgb2YgYHdpZHRoYCBhbmQgYGhlaWdodGAuXHJcbiAgICAgKiBSZXF1aXJlcyB0aGF0IHRoZSBjaGFydCBhc3BlY3QgcmF0aW8gYmUgZGVmaW5lZCB1c2luZyBjaGFydC53aWR0aCh3KSBhbmQgY2hhcnQuaGVpZ2h0KGgpLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgd2lsbCBtYWludGFpbiB0aGUgYXNwZWN0IHJhdGlvIHdoaWxlIGVuYWJsaW5nIHRoZSBjaGFydCB0byByZXNpemUgcmVzcG9uc2l2ZWx5IHRvIHRoZVxyXG4gICAgICogc3BhY2UgZ2l2ZW4gdG8gdGhlIGNoYXJ0IHVzaW5nIENTUy4gRm9yIGV4YW1wbGUsIHRoZSBjaGFydCBjYW4gdXNlIGB3aWR0aDogMTAwJTsgaGVpZ2h0OlxyXG4gICAgICogMTAwJWAgb3IgYWJzb2x1dGUgcG9zaXRpb25pbmcgdG8gcmVzaXplIHRvIGl0cyBwYXJlbnQgZGl2LlxyXG4gICAgICpcclxuICAgICAqIFNpbmNlIHRoZSB0ZXh0IHdpbGwgYmUgc2l6ZWQgYXMgaWYgdGhlIGNoYXJ0IGlzIGRyYXduIGFjY29yZGluZyB0byB0aGUgd2lkdGggYW5kIGhlaWdodCwgYW5kXHJcbiAgICAgKiB3aWxsIGJlIHJlc2l6ZWQgaWYgdGhlIGNoYXJ0IGlzIGFueSBvdGhlciBzaXplLCB5b3UgbmVlZCB0byBzZXQgdGhlIGNoYXJ0IHdpZHRoIGFuZCBoZWlnaHQgc29cclxuICAgICAqIHRoYXQgdGhlIHRleHQgbG9va3MgZ29vZC4gSW4gcHJhY3RpY2UsIDYwMHg0MDAgc2VlbXMgdG8gd29yayBwcmV0dHkgd2VsbCBmb3IgbW9zdCBjaGFydHMuXHJcbiAgICAgKlxyXG4gICAgICogWW91IGNhbiBzZWUgZXhhbXBsZXMgb2YgdGhpcyByZXNpemluZyBzdHJhdGVneSBpbiB0aGUgW0NoYXJ0IFJlc2l6aW5nXHJcbiAgICAgKiBFeGFtcGxlc10oaHR0cDovL2RjLWpzLmdpdGh1Yi5pby9kYy5qcy9yZXNpemluZy8pOyBqdXN0IGFkZCBgP3Jlc2l6ZT12aWV3Ym94YCB0byBhbnkgb2YgdGhlXHJcbiAgICAgKiBvbmUtY2hhcnQgZXhhbXBsZXMgdG8gZW5hYmxlIGB1c2VWaWV3Qm94UmVzaXppbmdgLlxyXG4gICAgICogQG1ldGhvZCB1c2VWaWV3Qm94UmVzaXppbmdcclxuICAgICAqIEBtZW1iZXJvZiBkYy5iYXNlTWl4aW5cclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbdXNlVmlld0JveFJlc2l6aW5nPWZhbHNlXVxyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW58ZGMuYmFzZU1peGlufVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQudXNlVmlld0JveFJlc2l6aW5nID0gZnVuY3Rpb24gKHVzZVZpZXdCb3hSZXNpemluZykge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3VzZVZpZXdCb3hSZXNpemluZztcclxuICAgICAgICB9XHJcbiAgICAgICAgX3VzZVZpZXdCb3hSZXNpemluZyA9IHVzZVZpZXdCb3hSZXNpemluZztcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqICoqbWFuZGF0b3J5KipcclxuICAgICAqXHJcbiAgICAgKiBTZXQgb3IgZ2V0IHRoZSBkaW1lbnNpb24gYXR0cmlidXRlIG9mIGEgY2hhcnQuIEluIGBkY2AsIGEgZGltZW5zaW9uIGNhbiBiZSBhbnkgdmFsaWRcclxuICAgICAqIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vY3Jvc3NmaWx0ZXIvY3Jvc3NmaWx0ZXIvd2lraS9BUEktUmVmZXJlbmNlI2RpbWVuc2lvbiBjcm9zc2ZpbHRlciBkaW1lbnNpb259XHJcbiAgICAgKlxyXG4gICAgICogSWYgYSB2YWx1ZSBpcyBnaXZlbiwgdGhlbiBpdCB3aWxsIGJlIHVzZWQgYXMgdGhlIG5ldyBkaW1lbnNpb24uIElmIG5vIHZhbHVlIGlzIHNwZWNpZmllZCB0aGVuXHJcbiAgICAgKiB0aGUgY3VycmVudCBkaW1lbnNpb24gd2lsbCBiZSByZXR1cm5lZC5cclxuICAgICAqIEBtZXRob2QgZGltZW5zaW9uXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuYmFzZU1peGluXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9jcm9zc2ZpbHRlci9jcm9zc2ZpbHRlci93aWtpL0FQSS1SZWZlcmVuY2UjZGltZW5zaW9uIGNyb3NzZmlsdGVyLmRpbWVuc2lvbn1cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiB2YXIgaW5kZXggPSBjcm9zc2ZpbHRlcihbXSk7XHJcbiAgICAgKiB2YXIgZGltZW5zaW9uID0gaW5kZXguZGltZW5zaW9uKGRjLnBsdWNrKCdrZXknKSk7XHJcbiAgICAgKiBjaGFydC5kaW1lbnNpb24oZGltZW5zaW9uKTtcclxuICAgICAqIEBwYXJhbSB7Y3Jvc3NmaWx0ZXIuZGltZW5zaW9ufSBbZGltZW5zaW9uXVxyXG4gICAgICogQHJldHVybnMge2Nyb3NzZmlsdGVyLmRpbWVuc2lvbnxkYy5iYXNlTWl4aW59XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5kaW1lbnNpb24gPSBmdW5jdGlvbiAoZGltZW5zaW9uKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfZGltZW5zaW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfZGltZW5zaW9uID0gZGltZW5zaW9uO1xyXG4gICAgICAgIF9jaGFydC5leHBpcmVDYWNoZSgpO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBkYXRhIGNhbGxiYWNrIG9yIHJldHJpZXZlIHRoZSBjaGFydCdzIGRhdGEgc2V0LiBUaGUgZGF0YSBjYWxsYmFjayBpcyBwYXNzZWQgdGhlIGNoYXJ0J3NcclxuICAgICAqIGdyb3VwIGFuZCBieSBkZWZhdWx0IHdpbGwgcmV0dXJuXHJcbiAgICAgKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Nyb3NzZmlsdGVyL2Nyb3NzZmlsdGVyL3dpa2kvQVBJLVJlZmVyZW5jZSNncm91cF9hbGwgZ3JvdXAuYWxsfS5cclxuICAgICAqIFRoaXMgYmVoYXZpb3IgbWF5IGJlIG1vZGlmaWVkIHRvLCBmb3IgaW5zdGFuY2UsIHJldHVybiBvbmx5IHRoZSB0b3AgNSBncm91cHMuXHJcbiAgICAgKiBAbWV0aG9kIGRhdGFcclxuICAgICAqIEBtZW1iZXJvZiBkYy5iYXNlTWl4aW5cclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIERlZmF1bHQgZGF0YSBmdW5jdGlvblxyXG4gICAgICogY2hhcnQuZGF0YShmdW5jdGlvbiAoZ3JvdXApIHsgcmV0dXJuIGdyb3VwLmFsbCgpOyB9KTtcclxuICAgICAqXHJcbiAgICAgKiBjaGFydC5kYXRhKGZ1bmN0aW9uIChncm91cCkgeyByZXR1cm4gZ3JvdXAudG9wKDUpOyB9KTtcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja11cclxuICAgICAqIEByZXR1cm5zIHsqfGRjLmJhc2VNaXhpbn1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LmRhdGEgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9kYXRhLmNhbGwoX2NoYXJ0LCBfZ3JvdXApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfZGF0YSA9IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyA/IGNhbGxiYWNrIDogZGMudXRpbHMuY29uc3RhbnQoY2FsbGJhY2spO1xyXG4gICAgICAgIF9jaGFydC5leHBpcmVDYWNoZSgpO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogKiptYW5kYXRvcnkqKlxyXG4gICAgICpcclxuICAgICAqIFNldCBvciBnZXQgdGhlIGdyb3VwIGF0dHJpYnV0ZSBvZiBhIGNoYXJ0LiBJbiBgZGNgIGEgZ3JvdXAgaXMgYVxyXG4gICAgICoge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9jcm9zc2ZpbHRlci9jcm9zc2ZpbHRlci93aWtpL0FQSS1SZWZlcmVuY2UjZ3JvdXAtbWFwLXJlZHVjZSBjcm9zc2ZpbHRlciBncm91cH0uXHJcbiAgICAgKiBVc3VhbGx5IHRoZSBncm91cCBzaG91bGQgYmUgY3JlYXRlZCBmcm9tIHRoZSBwYXJ0aWN1bGFyIGRpbWVuc2lvbiBhc3NvY2lhdGVkIHdpdGggdGhlIHNhbWUgY2hhcnQuIElmIGEgdmFsdWUgaXNcclxuICAgICAqIGdpdmVuLCB0aGVuIGl0IHdpbGwgYmUgdXNlZCBhcyB0aGUgbmV3IGdyb3VwLlxyXG4gICAgICpcclxuICAgICAqIElmIG5vIHZhbHVlIHNwZWNpZmllZCB0aGVuIHRoZSBjdXJyZW50IGdyb3VwIHdpbGwgYmUgcmV0dXJuZWQuXHJcbiAgICAgKiBJZiBgbmFtZWAgaXMgc3BlY2lmaWVkIHRoZW4gaXQgd2lsbCBiZSB1c2VkIHRvIGdlbmVyYXRlIGxlZ2VuZCBsYWJlbC5cclxuICAgICAqIEBtZXRob2QgZ3JvdXBcclxuICAgICAqIEBtZW1iZXJvZiBkYy5iYXNlTWl4aW5cclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Nyb3NzZmlsdGVyL2Nyb3NzZmlsdGVyL3dpa2kvQVBJLVJlZmVyZW5jZSNncm91cC1tYXAtcmVkdWNlIGNyb3NzZmlsdGVyLmdyb3VwfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIHZhciBpbmRleCA9IGNyb3NzZmlsdGVyKFtdKTtcclxuICAgICAqIHZhciBkaW1lbnNpb24gPSBpbmRleC5kaW1lbnNpb24oZGMucGx1Y2soJ2tleScpKTtcclxuICAgICAqIGNoYXJ0LmRpbWVuc2lvbihkaW1lbnNpb24pO1xyXG4gICAgICogY2hhcnQuZ3JvdXAoZGltZW5zaW9uLmdyb3VwKGNyb3NzZmlsdGVyLnJlZHVjZVN1bSgpKSk7XHJcbiAgICAgKiBAcGFyYW0ge2Nyb3NzZmlsdGVyLmdyb3VwfSBbZ3JvdXBdXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW25hbWVdXHJcbiAgICAgKiBAcmV0dXJucyB7Y3Jvc3NmaWx0ZXIuZ3JvdXB8ZGMuYmFzZU1peGlufVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQuZ3JvdXAgPSBmdW5jdGlvbiAoZ3JvdXAsIG5hbWUpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9ncm91cDtcclxuICAgICAgICB9XHJcbiAgICAgICAgX2dyb3VwID0gZ3JvdXA7XHJcbiAgICAgICAgX2NoYXJ0Ll9ncm91cE5hbWUgPSBuYW1lO1xyXG4gICAgICAgIF9jaGFydC5leHBpcmVDYWNoZSgpO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IG9yIHNldCBhbiBhY2Nlc3NvciB0byBvcmRlciBvcmRpbmFsIGRpbWVuc2lvbnMuICBUaGUgY2hhcnQgdXNlc1xyXG4gICAgICoge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9jcm9zc2ZpbHRlci9jcm9zc2ZpbHRlci93aWtpL0FQSS1SZWZlcmVuY2UjcXVpY2tzb3J0X2J5IGNyb3NzZmlsdGVyLnF1aWNrc29ydC5ieX1cclxuICAgICAqIHRvIHNvcnQgZWxlbWVudHM7IHRoaXMgYWNjZXNzb3IgcmV0dXJucyB0aGUgdmFsdWUgdG8gb3JkZXIgb24uXHJcbiAgICAgKiBAbWV0aG9kIG9yZGVyaW5nXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuYmFzZU1peGluXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9jcm9zc2ZpbHRlci9jcm9zc2ZpbHRlci93aWtpL0FQSS1SZWZlcmVuY2UjcXVpY2tzb3J0X2J5IGNyb3NzZmlsdGVyLnF1aWNrc29ydC5ieX1cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBEZWZhdWx0IG9yZGVyaW5nIGFjY2Vzc29yXHJcbiAgICAgKiBfY2hhcnQub3JkZXJpbmcoZGMucGx1Y2soJ2tleScpKTtcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcmRlckZ1bmN0aW9uXVxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufGRjLmJhc2VNaXhpbn1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0Lm9yZGVyaW5nID0gZnVuY3Rpb24gKG9yZGVyRnVuY3Rpb24pIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9vcmRlcmluZztcclxuICAgICAgICB9XHJcbiAgICAgICAgX29yZGVyaW5nID0gb3JkZXJGdW5jdGlvbjtcclxuICAgICAgICBfb3JkZXJTb3J0ID0gY3Jvc3NmaWx0ZXIucXVpY2tzb3J0LmJ5KF9vcmRlcmluZyk7XHJcbiAgICAgICAgX2NoYXJ0LmV4cGlyZUNhY2hlKCk7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgX2NoYXJ0Ll9jb21wdXRlT3JkZXJlZEdyb3VwcyA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgdmFyIGRhdGFDb3B5ID0gZGF0YS5zbGljZSgwKTtcclxuXHJcbiAgICAgICAgaWYgKGRhdGFDb3B5Lmxlbmd0aCA8PSAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhQ29weTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghX29yZGVyU29ydCkge1xyXG4gICAgICAgICAgICBfb3JkZXJTb3J0ID0gY3Jvc3NmaWx0ZXIucXVpY2tzb3J0LmJ5KF9vcmRlcmluZyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gX29yZGVyU29ydChkYXRhQ29weSwgMCwgZGF0YUNvcHkubGVuZ3RoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhciBhbGwgZmlsdGVycyBhc3NvY2lhdGVkIHdpdGggdGhpcyBjaGFydC4gVGhlIHNhbWUgZWZmZWN0IGNhbiBiZSBhY2hpZXZlZCBieSBjYWxsaW5nXHJcbiAgICAgKiB7QGxpbmsgZGMuYmFzZU1peGluI2ZpbHRlciBjaGFydC5maWx0ZXIobnVsbCl9LlxyXG4gICAgICogQG1ldGhvZCBmaWx0ZXJBbGxcclxuICAgICAqIEBtZW1iZXJvZiBkYy5iYXNlTWl4aW5cclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHJldHVybnMge2RjLmJhc2VNaXhpbn1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LmZpbHRlckFsbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0LmZpbHRlcihudWxsKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFeGVjdXRlIGQzIHNpbmdsZSBzZWxlY3Rpb24gaW4gdGhlIGNoYXJ0J3Mgc2NvcGUgdXNpbmcgdGhlIGdpdmVuIHNlbGVjdG9yIGFuZCByZXR1cm4gdGhlIGQzXHJcbiAgICAgKiBzZWxlY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyAqKm5vdCBjaGFpbmFibGUqKiBzaW5jZSBpdCBkb2VzIG5vdCByZXR1cm4gYSBjaGFydCBpbnN0YW5jZTsgaG93ZXZlciB0aGUgZDNcclxuICAgICAqIHNlbGVjdGlvbiByZXN1bHQgY2FuIGJlIGNoYWluZWQgdG8gZDMgZnVuY3Rpb24gY2FsbHMuXHJcbiAgICAgKiBAbWV0aG9kIHNlbGVjdFxyXG4gICAgICogQG1lbWJlcm9mIGRjLmJhc2VNaXhpblxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2VsZWN0aW9uL2Jsb2IvbWFzdGVyL1JFQURNRS5tZCNzZWxlY3QgZDMuc2VsZWN0fVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIEhhcyB0aGUgc2FtZSBlZmZlY3QgYXMgZDMuc2VsZWN0KCcjY2hhcnQtaWQnKS5zZWxlY3Qoc2VsZWN0b3IpXHJcbiAgICAgKiBjaGFydC5zZWxlY3Qoc2VsZWN0b3IpXHJcbiAgICAgKiBAcmV0dXJucyB7ZDMuc2VsZWN0aW9ufVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQuc2VsZWN0ID0gZnVuY3Rpb24gKHMpIHtcclxuICAgICAgICByZXR1cm4gX3Jvb3Quc2VsZWN0KHMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEV4ZWN1dGUgaW4gc2NvcGUgZDMgc2VsZWN0QWxsIHVzaW5nIHRoZSBnaXZlbiBzZWxlY3RvciBhbmQgcmV0dXJuIGQzIHNlbGVjdGlvbiByZXN1bHQuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyAqKm5vdCBjaGFpbmFibGUqKiBzaW5jZSBpdCBkb2VzIG5vdCByZXR1cm4gYSBjaGFydCBpbnN0YW5jZTsgaG93ZXZlciB0aGUgZDNcclxuICAgICAqIHNlbGVjdGlvbiByZXN1bHQgY2FuIGJlIGNoYWluZWQgdG8gZDMgZnVuY3Rpb24gY2FsbHMuXHJcbiAgICAgKiBAbWV0aG9kIHNlbGVjdEFsbFxyXG4gICAgICogQG1lbWJlcm9mIGRjLmJhc2VNaXhpblxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2VsZWN0aW9uL2Jsb2IvbWFzdGVyL1JFQURNRS5tZCNzZWxlY3RBbGwgZDMuc2VsZWN0QWxsfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIEhhcyB0aGUgc2FtZSBlZmZlY3QgYXMgZDMuc2VsZWN0KCcjY2hhcnQtaWQnKS5zZWxlY3RBbGwoc2VsZWN0b3IpXHJcbiAgICAgKiBjaGFydC5zZWxlY3RBbGwoc2VsZWN0b3IpXHJcbiAgICAgKiBAcmV0dXJucyB7ZDMuc2VsZWN0aW9ufVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQuc2VsZWN0QWxsID0gZnVuY3Rpb24gKHMpIHtcclxuICAgICAgICByZXR1cm4gX3Jvb3QgPyBfcm9vdC5zZWxlY3RBbGwocykgOiBudWxsO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgcm9vdCBTVkdFbGVtZW50IHRvIGVpdGhlciBiZSBhbiBleGlzdGluZyBjaGFydCdzIHJvb3Q7IG9yIGFueSB2YWxpZCBbZDMgc2luZ2xlXHJcbiAgICAgKiBzZWxlY3Rvcl0oaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNlbGVjdGlvbi9ibG9iL21hc3Rlci9SRUFETUUubWQjc2VsZWN0aW5nLWVsZW1lbnRzKSBzcGVjaWZ5aW5nIGEgZG9tXHJcbiAgICAgKiBibG9jayBlbGVtZW50IHN1Y2ggYXMgYSBkaXY7IG9yIGEgZG9tIGVsZW1lbnQgb3IgZDMgc2VsZWN0aW9uLiBPcHRpb25hbGx5IHJlZ2lzdGVycyB0aGUgY2hhcnRcclxuICAgICAqIHdpdGhpbiB0aGUgY2hhcnRHcm91cC4gVGhpcyBjbGFzcyBpcyBjYWxsZWQgaW50ZXJuYWxseSBvbiBjaGFydCBpbml0aWFsaXphdGlvbiwgYnV0IGJlIGNhbGxlZFxyXG4gICAgICogYWdhaW4gdG8gcmVsb2NhdGUgdGhlIGNoYXJ0LiBIb3dldmVyLCBpdCB3aWxsIG9ycGhhbiBhbnkgcHJldmlvdXNseSBjcmVhdGVkIFNWR0VsZW1lbnRzLlxyXG4gICAgICogQG1ldGhvZCBhbmNob3JcclxuICAgICAqIEBtZW1iZXJvZiBkYy5iYXNlTWl4aW5cclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHthbmNob3JDaGFydHxhbmNob3JTZWxlY3RvcnxhbmNob3JOb2RlfSBbcGFyZW50XVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjaGFydEdyb3VwXVxyXG4gICAgICogQHJldHVybnMge1N0cmluZ3xub2RlfGQzLnNlbGVjdGlvbnxkYy5iYXNlTWl4aW59XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5hbmNob3IgPSBmdW5jdGlvbiAocGFyZW50LCBjaGFydEdyb3VwKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfYW5jaG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGMuaW5zdGFuY2VPZkNoYXJ0KHBhcmVudCkpIHtcclxuICAgICAgICAgICAgX2FuY2hvciA9IHBhcmVudC5hbmNob3IoKTtcclxuICAgICAgICAgICAgX3Jvb3QgPSBwYXJlbnQucm9vdCgpO1xyXG4gICAgICAgICAgICBfaXNDaGlsZCA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIGlmIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgaWYgKHBhcmVudC5zZWxlY3QgJiYgcGFyZW50LmNsYXNzZWQpIHsgLy8gZGV0ZWN0IGQzIHNlbGVjdGlvblxyXG4gICAgICAgICAgICAgICAgX2FuY2hvciA9IHBhcmVudC5ub2RlKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBfYW5jaG9yID0gcGFyZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF9yb290ID0gZDMuc2VsZWN0KF9hbmNob3IpO1xyXG4gICAgICAgICAgICBfcm9vdC5jbGFzc2VkKGRjLmNvbnN0YW50cy5DSEFSVF9DTEFTUywgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGRjLnJlZ2lzdGVyQ2hhcnQoX2NoYXJ0LCBjaGFydEdyb3VwKTtcclxuICAgICAgICAgICAgX2lzQ2hpbGQgPSBmYWxzZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZGMuZXJyb3JzLkJhZEFyZ3VtZW50RXhjZXB0aW9uKCdwYXJlbnQgbXVzdCBiZSBkZWZpbmVkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9jaGFydEdyb3VwID0gY2hhcnRHcm91cDtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIERPTSBpZCBmb3IgdGhlIGNoYXJ0J3MgYW5jaG9yZWQgbG9jYXRpb24uXHJcbiAgICAgKiBAbWV0aG9kIGFuY2hvck5hbWVcclxuICAgICAqIEBtZW1iZXJvZiBkYy5iYXNlTWl4aW5cclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHJldHVybnMge1N0cmluZ31cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LmFuY2hvck5hbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGEgPSBfY2hhcnQuYW5jaG9yKCk7XHJcbiAgICAgICAgaWYgKGEgJiYgYS5pZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYS5pZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGEgJiYgYS5yZXBsYWNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhLnJlcGxhY2UoJyMnLCAnJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAnZGMtY2hhcnQnICsgX2NoYXJ0LmNoYXJ0SUQoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSByb290IGVsZW1lbnQgd2hlcmUgYSBjaGFydCByZXNpZGVzLiBVc3VhbGx5IGl0IHdpbGwgYmUgdGhlIHBhcmVudCBkaXYgZWxlbWVudCB3aGVyZVxyXG4gICAgICogdGhlIFNWR0VsZW1lbnQgd2FzIGNyZWF0ZWQuIFlvdSBjYW4gYWxzbyBwYXNzIGluIGEgbmV3IHJvb3QgZWxlbWVudCBob3dldmVyIHRoaXMgaXMgdXN1YWxseSBoYW5kbGVkIGJ5XHJcbiAgICAgKiBkYyBpbnRlcm5hbGx5LiBSZXNldHRpbmcgdGhlIHJvb3QgZWxlbWVudCBvbiBhIGNoYXJ0IG91dHNpZGUgb2YgZGMgaW50ZXJuYWxzIG1heSBoYXZlXHJcbiAgICAgKiB1bmV4cGVjdGVkIGNvbnNlcXVlbmNlcy5cclxuICAgICAqIEBtZXRob2Qgcm9vdFxyXG4gICAgICogQG1lbWJlcm9mIGRjLmJhc2VNaXhpblxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTEVsZW1lbnQgSFRNTEVsZW1lbnR9XHJcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBbcm9vdEVsZW1lbnRdXHJcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR8ZGMuYmFzZU1peGlufVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQucm9vdCA9IGZ1bmN0aW9uIChyb290RWxlbWVudCkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3Jvb3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9yb290ID0gcm9vdEVsZW1lbnQ7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB0b3AgU1ZHRWxlbWVudCBmb3IgdGhpcyBzcGVjaWZpYyBjaGFydC4gWW91IGNhbiBhbHNvIHBhc3MgaW4gYSBuZXcgU1ZHRWxlbWVudCxcclxuICAgICAqIGhvd2V2ZXIgdGhpcyBpcyB1c3VhbGx5IGhhbmRsZWQgYnkgZGMgaW50ZXJuYWxseS4gUmVzZXR0aW5nIHRoZSBTVkdFbGVtZW50IG9uIGEgY2hhcnQgb3V0c2lkZVxyXG4gICAgICogb2YgZGMgaW50ZXJuYWxzIG1heSBoYXZlIHVuZXhwZWN0ZWQgY29uc2VxdWVuY2VzLlxyXG4gICAgICogQG1ldGhvZCBzdmdcclxuICAgICAqIEBtZW1iZXJvZiBkYy5iYXNlTWl4aW5cclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NWR0VsZW1lbnQgU1ZHRWxlbWVudH1cclxuICAgICAqIEBwYXJhbSB7U1ZHRWxlbWVudHxkMy5zZWxlY3Rpb259IFtzdmdFbGVtZW50XVxyXG4gICAgICogQHJldHVybnMge1NWR0VsZW1lbnR8ZDMuc2VsZWN0aW9ufGRjLmJhc2VNaXhpbn1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LnN2ZyA9IGZ1bmN0aW9uIChzdmdFbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfc3ZnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfc3ZnID0gc3ZnRWxlbWVudDtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZSB0aGUgY2hhcnQncyBTVkdFbGVtZW50cyBmcm9tIHRoZSBkb20gYW5kIHJlY3JlYXRlIHRoZSBjb250YWluZXIgU1ZHRWxlbWVudC5cclxuICAgICAqIEBtZXRob2QgcmVzZXRTdmdcclxuICAgICAqIEBtZW1iZXJvZiBkYy5iYXNlTWl4aW5cclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NWR0VsZW1lbnQgU1ZHRWxlbWVudH1cclxuICAgICAqIEByZXR1cm5zIHtTVkdFbGVtZW50fVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQucmVzZXRTdmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX2NoYXJ0LnNlbGVjdCgnc3ZnJykucmVtb3ZlKCk7XHJcbiAgICAgICAgcmV0dXJuIGdlbmVyYXRlU3ZnKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIHNpemVTdmcgKCkge1xyXG4gICAgICAgIGlmIChfc3ZnKSB7XHJcbiAgICAgICAgICAgIGlmICghX3VzZVZpZXdCb3hSZXNpemluZykge1xyXG4gICAgICAgICAgICAgICAgX3N2Z1xyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIF9jaGFydC53aWR0aCgpKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBfY2hhcnQuaGVpZ2h0KCkpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFfc3ZnLmF0dHIoJ3ZpZXdCb3gnKSkge1xyXG4gICAgICAgICAgICAgICAgX3N2Z1xyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd2aWV3Qm94JywgJzAgMCAnICsgX2NoYXJ0LndpZHRoKCkgKyAnICcgKyBfY2hhcnQuaGVpZ2h0KCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlU3ZnICgpIHtcclxuICAgICAgICBfc3ZnID0gX2NoYXJ0LnJvb3QoKS5hcHBlbmQoJ3N2ZycpO1xyXG4gICAgICAgIHNpemVTdmcoKTtcclxuICAgICAgICByZXR1cm4gX3N2ZztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBvciBnZXQgdGhlIGZpbHRlciBwcmludGVyIGZ1bmN0aW9uLiBUaGUgZmlsdGVyIHByaW50ZXIgZnVuY3Rpb24gaXMgdXNlZCB0byBnZW5lcmF0ZSBodW1hblxyXG4gICAgICogZnJpZW5kbHkgdGV4dCBmb3IgZmlsdGVyIHZhbHVlKHMpIGFzc29jaWF0ZWQgd2l0aCB0aGUgY2hhcnQgaW5zdGFuY2UuIFRoZSB0ZXh0IHdpbGwgZ2V0IHNob3duXHJcbiAgICAgKiBpbiB0aGUgYC5maWx0ZXIgZWxlbWVudDsgc2VlIHtAbGluayBkYy5iYXNlTWl4aW4jdHVybk9uQ29udHJvbHMgdHVybk9uQ29udHJvbHN9LlxyXG4gICAgICpcclxuICAgICAqIEJ5IGRlZmF1bHQgZGMgY2hhcnRzIHVzZSBhIGRlZmF1bHQgZmlsdGVyIHByaW50ZXIge0BsaW5rIGRjLnByaW50ZXJzLmZpbHRlcnMgZGMucHJpbnRlcnMuZmlsdGVyc31cclxuICAgICAqIHRoYXQgcHJvdmlkZXMgc2ltcGxlIHByaW50aW5nIHN1cHBvcnQgZm9yIGJvdGggc2luZ2xlIHZhbHVlIGFuZCByYW5nZWQgZmlsdGVycy5cclxuICAgICAqIEBtZXRob2QgZmlsdGVyUHJpbnRlclxyXG4gICAgICogQG1lbWJlcm9mIGRjLmJhc2VNaXhpblxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gZm9yIGEgY2hhcnQgd2l0aCBhbiBvcmRpbmFsIGJydXNoLCBwcmludCB0aGUgZmlsdGVycyBpbiB1cHBlciBjYXNlXHJcbiAgICAgKiBjaGFydC5maWx0ZXJQcmludGVyKGZ1bmN0aW9uKGZpbHRlcnMpIHtcclxuICAgICAqICAgcmV0dXJuIGZpbHRlcnMubWFwKGZ1bmN0aW9uKGYpIHsgcmV0dXJuIGYudG9VcHBlckNhc2UoKTsgfSkuam9pbignLCAnKTtcclxuICAgICAqIH0pO1xyXG4gICAgICogLy8gZm9yIGEgY2hhcnQgd2l0aCBhIHJhbmdlIGJydXNoLCBwcmludCB0aGUgZmlsdGVyIGFzIHN0YXJ0IGFuZCBleHRlbnRcclxuICAgICAqIGNoYXJ0LmZpbHRlclByaW50ZXIoZnVuY3Rpb24oZmlsdGVycykge1xyXG4gICAgICogICByZXR1cm4gJ3N0YXJ0ICcgKyBkYy51dGlscy5wcmludFNpbmdsZVZhbHVlKGZpbHRlcnNbMF1bMF0pICtcclxuICAgICAqICAgICAnIGV4dGVudCAnICsgZGMudXRpbHMucHJpbnRTaW5nbGVWYWx1ZShmaWx0ZXJzWzBdWzFdIC0gZmlsdGVyc1swXVswXSk7XHJcbiAgICAgKiB9KTtcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtmaWx0ZXJQcmludGVyRnVuY3Rpb249ZGMucHJpbnRlcnMuZmlsdGVyc11cclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbnxkYy5iYXNlTWl4aW59XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5maWx0ZXJQcmludGVyID0gZnVuY3Rpb24gKGZpbHRlclByaW50ZXJGdW5jdGlvbikge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2ZpbHRlclByaW50ZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9maWx0ZXJQcmludGVyID0gZmlsdGVyUHJpbnRlckZ1bmN0aW9uO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSWYgc2V0LCB1c2UgdGhlIGB2aXNpYmlsaXR5YCBhdHRyaWJ1dGUgaW5zdGVhZCBvZiB0aGUgYGRpc3BsYXlgIGF0dHJpYnV0ZSBmb3Igc2hvd2luZy9oaWRpbmdcclxuICAgICAqIGNoYXJ0IHJlc2V0IGFuZCBmaWx0ZXIgY29udHJvbHMsIGZvciBsZXNzIGRpc3J1cHRpb24gdG8gdGhlIGxheW91dC5cclxuICAgICAqIEBtZXRob2QgY29udHJvbHNVc2VWaXNpYmlsaXR5XHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuYmFzZU1peGluXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbnRyb2xzVXNlVmlzaWJpbGl0eT1mYWxzZV1cclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufGRjLmJhc2VNaXhpbn1cclxuICAgICAqKi9cclxuICAgIF9jaGFydC5jb250cm9sc1VzZVZpc2liaWxpdHkgPSBmdW5jdGlvbiAodXNlVmlzaWJpbGl0eSkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRyb2xzVXNlVmlzaWJpbGl0eTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX2NvbnRyb2xzVXNlVmlzaWJpbGl0eSA9IHVzZVZpc2liaWxpdHk7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUdXJuIG9uIG9wdGlvbmFsIGNvbnRyb2wgZWxlbWVudHMgd2l0aGluIHRoZSByb290IGVsZW1lbnQuIGRjIGN1cnJlbnRseSBzdXBwb3J0cyB0aGVcclxuICAgICAqIGZvbGxvd2luZyBodG1sIGNvbnRyb2wgZWxlbWVudHMuXHJcbiAgICAgKiAqIHJvb3Quc2VsZWN0QWxsKCcucmVzZXQnKSAtIGVsZW1lbnRzIGFyZSB0dXJuZWQgb24gaWYgdGhlIGNoYXJ0IGhhcyBhbiBhY3RpdmUgZmlsdGVyLiBUaGlzIHR5cGVcclxuICAgICAqIG9mIGNvbnRyb2wgZWxlbWVudCBpcyB1c3VhbGx5IHVzZWQgdG8gc3RvcmUgYSByZXNldCBsaW5rIHRvIGFsbG93IHVzZXIgdG8gcmVzZXQgZmlsdGVyIG9uIGFcclxuICAgICAqIGNlcnRhaW4gY2hhcnQuIFRoaXMgZWxlbWVudCB3aWxsIGJlIHR1cm5lZCBvZmYgYXV0b21hdGljYWxseSBpZiB0aGUgZmlsdGVyIGlzIGNsZWFyZWQuXHJcbiAgICAgKiAqIHJvb3Quc2VsZWN0QWxsKCcuZmlsdGVyJykgZWxlbWVudHMgYXJlIHR1cm5lZCBvbiBpZiB0aGUgY2hhcnQgaGFzIGFuIGFjdGl2ZSBmaWx0ZXIuIFRoZSB0ZXh0XHJcbiAgICAgKiBjb250ZW50IG9mIHRoaXMgZWxlbWVudCBpcyB0aGVuIHJlcGxhY2VkIHdpdGggdGhlIGN1cnJlbnQgZmlsdGVyIHZhbHVlIHVzaW5nIHRoZSBmaWx0ZXIgcHJpbnRlclxyXG4gICAgICogZnVuY3Rpb24uIFRoaXMgdHlwZSBvZiBlbGVtZW50IHdpbGwgYmUgdHVybmVkIG9mZiBhdXRvbWF0aWNhbGx5IGlmIHRoZSBmaWx0ZXIgaXMgY2xlYXJlZC5cclxuICAgICAqIEBtZXRob2QgdHVybk9uQ29udHJvbHNcclxuICAgICAqIEBtZW1iZXJvZiBkYy5iYXNlTWl4aW5cclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHJldHVybnMge2RjLmJhc2VNaXhpbn1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LnR1cm5PbkNvbnRyb2xzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChfcm9vdCkge1xyXG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gX2NoYXJ0LmNvbnRyb2xzVXNlVmlzaWJpbGl0eSgpID8gJ3Zpc2liaWxpdHknIDogJ2Rpc3BsYXknO1xyXG4gICAgICAgICAgICBfY2hhcnQuc2VsZWN0QWxsKCcucmVzZXQnKS5zdHlsZShhdHRyaWJ1dGUsIG51bGwpO1xyXG4gICAgICAgICAgICBfY2hhcnQuc2VsZWN0QWxsKCcuZmlsdGVyJykudGV4dChfZmlsdGVyUHJpbnRlcihfY2hhcnQuZmlsdGVycygpKSkuc3R5bGUoYXR0cmlidXRlLCBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUdXJuIG9mZiBvcHRpb25hbCBjb250cm9sIGVsZW1lbnRzIHdpdGhpbiB0aGUgcm9vdCBlbGVtZW50LlxyXG4gICAgICogQG1ldGhvZCB0dXJuT2ZmQ29udHJvbHNcclxuICAgICAqIEBtZW1iZXJvZiBkYy5iYXNlTWl4aW5cclxuICAgICAqIEBzZWUge0BsaW5rIGRjLmJhc2VNaXhpbiN0dXJuT25Db250cm9scyB0dXJuT25Db250cm9sc31cclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHJldHVybnMge2RjLmJhc2VNaXhpbn1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LnR1cm5PZmZDb250cm9scyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoX3Jvb3QpIHtcclxuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IF9jaGFydC5jb250cm9sc1VzZVZpc2liaWxpdHkoKSA/ICd2aXNpYmlsaXR5JyA6ICdkaXNwbGF5JztcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gX2NoYXJ0LmNvbnRyb2xzVXNlVmlzaWJpbGl0eSgpID8gJ2hpZGRlbicgOiAnbm9uZSc7XHJcbiAgICAgICAgICAgIF9jaGFydC5zZWxlY3RBbGwoJy5yZXNldCcpLnN0eWxlKGF0dHJpYnV0ZSwgdmFsdWUpO1xyXG4gICAgICAgICAgICBfY2hhcnQuc2VsZWN0QWxsKCcuZmlsdGVyJykuc3R5bGUoYXR0cmlidXRlLCB2YWx1ZSkudGV4dChfY2hhcnQuZmlsdGVyKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBvciBnZXQgdGhlIGFuaW1hdGlvbiB0cmFuc2l0aW9uIGR1cmF0aW9uIChpbiBtaWxsaXNlY29uZHMpIGZvciB0aGlzIGNoYXJ0IGluc3RhbmNlLlxyXG4gICAgICogQG1ldGhvZCB0cmFuc2l0aW9uRHVyYXRpb25cclxuICAgICAqIEBtZW1iZXJvZiBkYy5iYXNlTWl4aW5cclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtkdXJhdGlvbj03NTBdXHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfGRjLmJhc2VNaXhpbn1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LnRyYW5zaXRpb25EdXJhdGlvbiA9IGZ1bmN0aW9uIChkdXJhdGlvbikge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3RyYW5zaXRpb25EdXJhdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3RyYW5zaXRpb25EdXJhdGlvbiA9IGR1cmF0aW9uO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IG9yIGdldCB0aGUgYW5pbWF0aW9uIHRyYW5zaXRpb24gZGVsYXkgKGluIG1pbGxpc2Vjb25kcykgZm9yIHRoaXMgY2hhcnQgaW5zdGFuY2UuXHJcbiAgICAgKiBAbWV0aG9kIHRyYW5zaXRpb25EZWxheVxyXG4gICAgICogQG1lbWJlcm9mIGRjLmJhc2VNaXhpblxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2RlbGF5PTBdXHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfGRjLmJhc2VNaXhpbn1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LnRyYW5zaXRpb25EZWxheSA9IGZ1bmN0aW9uIChkZWxheSkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3RyYW5zaXRpb25EZWxheTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3RyYW5zaXRpb25EZWxheSA9IGRlbGF5O1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF9jaGFydC5fbWFuZGF0b3J5QXR0cmlidXRlcyA9IGZ1bmN0aW9uIChfKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfbWFuZGF0b3J5QXR0cmlidXRlcztcclxuICAgICAgICB9XHJcbiAgICAgICAgX21hbmRhdG9yeUF0dHJpYnV0ZXMgPSBfO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGNoZWNrRm9yTWFuZGF0b3J5QXR0cmlidXRlcyAoYSkge1xyXG4gICAgICAgIGlmICghX2NoYXJ0W2FdIHx8ICFfY2hhcnRbYV0oKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZGMuZXJyb3JzLkludmFsaWRTdGF0ZUV4Y2VwdGlvbignTWFuZGF0b3J5IGF0dHJpYnV0ZSBjaGFydC4nICsgYSArXHJcbiAgICAgICAgICAgICAgICAnIGlzIG1pc3Npbmcgb24gY2hhcnRbIycgKyBfY2hhcnQuYW5jaG9yTmFtZSgpICsgJ10nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnZva2luZyB0aGlzIG1ldGhvZCB3aWxsIGZvcmNlIHRoZSBjaGFydCB0byByZS1yZW5kZXIgZXZlcnl0aGluZyBmcm9tIHNjcmF0Y2guIEdlbmVyYWxseSBpdFxyXG4gICAgICogc2hvdWxkIG9ubHkgYmUgdXNlZCB0byByZW5kZXIgdGhlIGNoYXJ0IGZvciB0aGUgZmlyc3QgdGltZSBvbiB0aGUgcGFnZSBvciBpZiB5b3Ugd2FudCB0byBtYWtlXHJcbiAgICAgKiBzdXJlIGV2ZXJ5dGhpbmcgaXMgcmVkcmF3biBmcm9tIHNjcmF0Y2ggaW5zdGVhZCBvZiByZWx5aW5nIG9uIHRoZSBkZWZhdWx0IGluY3JlbWVudGFsIHJlZHJhd2luZ1xyXG4gICAgICogYmVoYXZpb3VyLlxyXG4gICAgICogQG1ldGhvZCByZW5kZXJcclxuICAgICAqIEBtZW1iZXJvZiBkYy5iYXNlTWl4aW5cclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHJldHVybnMge2RjLmJhc2VNaXhpbn1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfaGVpZ2h0ID0gX3dpZHRoID0gdW5kZWZpbmVkOyAvLyBmb3JjZSByZWNhbGN1bGF0ZVxyXG4gICAgICAgIF9saXN0ZW5lcnMuY2FsbCgncHJlUmVuZGVyJywgX2NoYXJ0LCBfY2hhcnQpO1xyXG5cclxuICAgICAgICBpZiAoX21hbmRhdG9yeUF0dHJpYnV0ZXMpIHtcclxuICAgICAgICAgICAgX21hbmRhdG9yeUF0dHJpYnV0ZXMuZm9yRWFjaChjaGVja0Zvck1hbmRhdG9yeUF0dHJpYnV0ZXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IF9jaGFydC5fZG9SZW5kZXIoKTtcclxuXHJcbiAgICAgICAgaWYgKF9sZWdlbmQpIHtcclxuICAgICAgICAgICAgX2xlZ2VuZC5yZW5kZXIoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIF9jaGFydC5fYWN0aXZhdGVSZW5kZXJsZXRzKCdwb3N0UmVuZGVyJyk7XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF9jaGFydC5fYWN0aXZhdGVSZW5kZXJsZXRzID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgX2xpc3RlbmVycy5jYWxsKCdwcmV0cmFuc2l0aW9uJywgX2NoYXJ0LCBfY2hhcnQpO1xyXG4gICAgICAgIGlmIChfY2hhcnQudHJhbnNpdGlvbkR1cmF0aW9uKCkgPiAwICYmIF9zdmcpIHtcclxuICAgICAgICAgICAgX3N2Zy50cmFuc2l0aW9uKCkuZHVyYXRpb24oX2NoYXJ0LnRyYW5zaXRpb25EdXJhdGlvbigpKS5kZWxheShfY2hhcnQudHJhbnNpdGlvbkRlbGF5KCkpXHJcbiAgICAgICAgICAgICAgICAub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBfbGlzdGVuZXJzLmNhbGwoJ3JlbmRlcmxldCcsIF9jaGFydCwgX2NoYXJ0KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2xpc3RlbmVycy5jYWxsKGV2ZW50LCBfY2hhcnQsIF9jaGFydCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgX2xpc3RlbmVycy5jYWxsKCdyZW5kZXJsZXQnLCBfY2hhcnQsIF9jaGFydCk7XHJcbiAgICAgICAgICAgIGlmIChldmVudCkge1xyXG4gICAgICAgICAgICAgICAgX2xpc3RlbmVycy5jYWxsKGV2ZW50LCBfY2hhcnQsIF9jaGFydCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGluZyByZWRyYXcgd2lsbCBjYXVzZSB0aGUgY2hhcnQgdG8gcmUtcmVuZGVyIGRhdGEgY2hhbmdlcyBpbmNyZW1lbnRhbGx5LiBJZiB0aGVyZSBpcyBub1xyXG4gICAgICogY2hhbmdlIGluIHRoZSB1bmRlcmx5aW5nIGRhdGEgZGltZW5zaW9uIHRoZW4gY2FsbGluZyB0aGlzIG1ldGhvZCB3aWxsIGhhdmUgbm8gZWZmZWN0IG9uIHRoZVxyXG4gICAgICogY2hhcnQuIE1vc3QgY2hhcnQgaW50ZXJhY3Rpb24gaW4gZGMgd2lsbCBhdXRvbWF0aWNhbGx5IHRyaWdnZXIgdGhpcyBtZXRob2QgdGhyb3VnaCBpbnRlcm5hbFxyXG4gICAgICogZXZlbnRzIChpbiBwYXJ0aWN1bGFyIHtAbGluayBkYy5yZWRyYXdBbGwgZGMucmVkcmF3QWxsfSk7IHRoZXJlZm9yZSwgeW91IG9ubHkgbmVlZCB0b1xyXG4gICAgICogbWFudWFsbHkgaW52b2tlIHRoaXMgZnVuY3Rpb24gaWYgZGF0YSBpcyBtYW5pcHVsYXRlZCBvdXRzaWRlIG9mIGRjJ3MgY29udHJvbCAoZm9yIGV4YW1wbGUgaWZcclxuICAgICAqIGRhdGEgaXMgbG9hZGVkIGluIHRoZSBiYWNrZ3JvdW5kIHVzaW5nXHJcbiAgICAgKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Nyb3NzZmlsdGVyL2Nyb3NzZmlsdGVyL3dpa2kvQVBJLVJlZmVyZW5jZSNjcm9zc2ZpbHRlcl9hZGQgY3Jvc3NmaWx0ZXIuYWRkfSkuXHJcbiAgICAgKiBAbWV0aG9kIHJlZHJhd1xyXG4gICAgICogQG1lbWJlcm9mIGRjLmJhc2VNaXhpblxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAcmV0dXJucyB7ZGMuYmFzZU1peGlufVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQucmVkcmF3ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNpemVTdmcoKTtcclxuICAgICAgICBfbGlzdGVuZXJzLmNhbGwoJ3ByZVJlZHJhdycsIF9jaGFydCwgX2NoYXJ0KTtcclxuXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IF9jaGFydC5fZG9SZWRyYXcoKTtcclxuXHJcbiAgICAgICAgaWYgKF9sZWdlbmQpIHtcclxuICAgICAgICAgICAgX2xlZ2VuZC5yZW5kZXIoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIF9jaGFydC5fYWN0aXZhdGVSZW5kZXJsZXRzKCdwb3N0UmVkcmF3Jyk7XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cy9zZXRzIHRoZSBjb21taXQgaGFuZGxlci4gSWYgdGhlIGNoYXJ0IGhhcyBhIGNvbW1pdCBoYW5kbGVyLCB0aGUgaGFuZGxlciB3aWxsIGJlIGNhbGxlZCB3aGVuXHJcbiAgICAgKiB0aGUgY2hhcnQncyBmaWx0ZXJzIGhhdmUgY2hhbmdlZCwgaW4gb3JkZXIgdG8gc2VuZCB0aGUgZmlsdGVyIGRhdGEgYXN5bmNocm9ub3VzbHkgdG8gYSBzZXJ2ZXIuXHJcbiAgICAgKlxyXG4gICAgICogVW5saWtlIG90aGVyIGZ1bmN0aW9ucyBpbiBkYy5qcywgdGhlIGNvbW1pdCBoYW5kbGVyIGlzIGFzeW5jaHJvbm91cy4gSXQgdGFrZXMgdHdvIGFyZ3VtZW50czpcclxuICAgICAqIGEgZmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyBpcyBhIHJlbmRlciAodHJ1ZSkgb3IgYSByZWRyYXcgKGZhbHNlKSwgYW5kIGEgY2FsbGJhY2sgdG8gYmVcclxuICAgICAqIHRyaWdnZXJlZCBvbmNlIHRoZSBjb21taXQgaXMgZmlsdGVyZWQuIFRoZSBjYWxsYmFjayBoYXMgdGhlIHN0YW5kYXJkIG5vZGUuanMgY29udGludWF0aW9uIHNpZ25hdHVyZVxyXG4gICAgICogd2l0aCBlcnJvciBmaXJzdCBhbmQgcmVzdWx0IHNlY29uZC5cclxuICAgICAqIEBtZXRob2QgY29tbWl0SGFuZGxlclxyXG4gICAgICogQG1lbWJlcm9mIGRjLmJhc2VNaXhpblxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAcmV0dXJucyB7ZGMuYmFzZU1peGlufVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQuY29tbWl0SGFuZGxlciA9IGZ1bmN0aW9uIChjb21taXRIYW5kbGVyKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfY29tbWl0SGFuZGxlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgX2NvbW1pdEhhbmRsZXIgPSBjb21taXRIYW5kbGVyO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVkcmF3cyBhbGwgY2hhcnRzIGluIHRoZSBzYW1lIGdyb3VwIGFzIHRoaXMgY2hhcnQsIHR5cGljYWxseSBpbiByZWFjdGlvbiB0byBhIGZpbHRlclxyXG4gICAgICogY2hhbmdlLiBJZiB0aGUgY2hhcnQgaGFzIGEge0BsaW5rIGRjLmJhc2VNaXhpbi5jb21taXRGaWx0ZXIgY29tbWl0SGFuZGxlcn0sIGl0IHdpbGxcclxuICAgICAqIGJlIGV4ZWN1dGVkIGFuZCB3YWl0ZWQgZm9yLlxyXG4gICAgICogQG1ldGhvZCByZWRyYXdHcm91cFxyXG4gICAgICogQG1lbWJlcm9mIGRjLmJhc2VNaXhpblxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAcmV0dXJucyB7ZGMuYmFzZU1peGlufVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQucmVkcmF3R3JvdXAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKF9jb21taXRIYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIF9jb21taXRIYW5kbGVyKGZhbHNlLCBmdW5jdGlvbiAoZXJyb3IsIHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBkYy5yZWRyYXdBbGwoX2NoYXJ0LmNoYXJ0R3JvdXAoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGRjLnJlZHJhd0FsbChfY2hhcnQuY2hhcnRHcm91cCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXJzIGFsbCBjaGFydHMgaW4gdGhlIHNhbWUgZ3JvdXAgYXMgdGhpcyBjaGFydC4gSWYgdGhlIGNoYXJ0IGhhcyBhXHJcbiAgICAgKiB7QGxpbmsgZGMuYmFzZU1peGluLmNvbW1pdEZpbHRlciBjb21taXRIYW5kbGVyfSwgaXQgd2lsbCBiZSBleGVjdXRlZCBhbmQgd2FpdGVkIGZvclxyXG4gICAgICogQG1ldGhvZCByZW5kZXJHcm91cFxyXG4gICAgICogQG1lbWJlcm9mIGRjLmJhc2VNaXhpblxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAcmV0dXJucyB7ZGMuYmFzZU1peGlufVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQucmVuZGVyR3JvdXAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKF9jb21taXRIYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIF9jb21taXRIYW5kbGVyKGZhbHNlLCBmdW5jdGlvbiAoZXJyb3IsIHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBkYy5yZW5kZXJBbGwoX2NoYXJ0LmNoYXJ0R3JvdXAoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGRjLnJlbmRlckFsbChfY2hhcnQuY2hhcnRHcm91cCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgX2NoYXJ0Ll9pbnZva2VGaWx0ZXJlZExpc3RlbmVyID0gZnVuY3Rpb24gKGYpIHtcclxuICAgICAgICBpZiAoZiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIF9saXN0ZW5lcnMuY2FsbCgnZmlsdGVyZWQnLCBfY2hhcnQsIF9jaGFydCwgZik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfY2hhcnQuX2ludm9rZVpvb21lZExpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9saXN0ZW5lcnMuY2FsbCgnem9vbWVkJywgX2NoYXJ0LCBfY2hhcnQpO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgX2hhc0ZpbHRlckhhbmRsZXIgPSBmdW5jdGlvbiAoZmlsdGVycywgZmlsdGVyKSB7XHJcbiAgICAgICAgaWYgKGZpbHRlciA9PT0gbnVsbCB8fCB0eXBlb2YoZmlsdGVyKSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcnMubGVuZ3RoID4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZpbHRlcnMuc29tZShmdW5jdGlvbiAoZikge1xyXG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyIDw9IGYgJiYgZmlsdGVyID49IGY7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IG9yIGdldCB0aGUgaGFzLWZpbHRlciBoYW5kbGVyLiBUaGUgaGFzLWZpbHRlciBoYW5kbGVyIGlzIGEgZnVuY3Rpb24gdGhhdCBjaGVja3MgdG8gc2VlIGlmXHJcbiAgICAgKiB0aGUgY2hhcnQncyBjdXJyZW50IGZpbHRlcnMgKGZpcnN0IGFyZ3VtZW50KSBpbmNsdWRlIGEgc3BlY2lmaWMgZmlsdGVyIChzZWNvbmQgYXJndW1lbnQpLiAgVXNpbmcgYSBjdXN0b20gaGFzLWZpbHRlciBoYW5kbGVyIGFsbG93c1xyXG4gICAgICogeW91IHRvIGNoYW5nZSB0aGUgd2F5IGZpbHRlcnMgYXJlIGNoZWNrZWQgZm9yIGFuZCByZXBsYWNlZC5cclxuICAgICAqIEBtZXRob2QgaGFzRmlsdGVySGFuZGxlclxyXG4gICAgICogQG1lbWJlcm9mIGRjLmJhc2VNaXhpblxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gZGVmYXVsdCBoYXMtZmlsdGVyIGhhbmRsZXJcclxuICAgICAqIGNoYXJ0Lmhhc0ZpbHRlckhhbmRsZXIoZnVuY3Rpb24gKGZpbHRlcnMsIGZpbHRlcikge1xyXG4gICAgICogICAgIGlmIChmaWx0ZXIgPT09IG51bGwgfHwgdHlwZW9mKGZpbHRlcikgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgKiAgICAgICAgIHJldHVybiBmaWx0ZXJzLmxlbmd0aCA+IDA7XHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogICAgIHJldHVybiBmaWx0ZXJzLnNvbWUoZnVuY3Rpb24gKGYpIHtcclxuICAgICAqICAgICAgICAgcmV0dXJuIGZpbHRlciA8PSBmICYmIGZpbHRlciA+PSBmO1xyXG4gICAgICogICAgIH0pO1xyXG4gICAgICogfSk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gY3VzdG9tIGZpbHRlciBoYW5kbGVyIChuby1vcClcclxuICAgICAqIGNoYXJ0Lmhhc0ZpbHRlckhhbmRsZXIoZnVuY3Rpb24oZmlsdGVycywgZmlsdGVyKSB7XHJcbiAgICAgKiAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICogfSk7XHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaGFzRmlsdGVySGFuZGxlcl1cclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbnxkYy5iYXNlTWl4aW59XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5oYXNGaWx0ZXJIYW5kbGVyID0gZnVuY3Rpb24gKGhhc0ZpbHRlckhhbmRsZXIpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9oYXNGaWx0ZXJIYW5kbGVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfaGFzRmlsdGVySGFuZGxlciA9IGhhc0ZpbHRlckhhbmRsZXI7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayB3aGV0aGVyIGFueSBhY3RpdmUgZmlsdGVyIG9yIGEgc3BlY2lmaWMgZmlsdGVyIGlzIGFzc29jaWF0ZWQgd2l0aCBwYXJ0aWN1bGFyIGNoYXJ0IGluc3RhbmNlLlxyXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyAqKm5vdCBjaGFpbmFibGUqKi5cclxuICAgICAqIEBtZXRob2QgaGFzRmlsdGVyXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuYmFzZU1peGluXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBzZWUge0BsaW5rIGRjLmJhc2VNaXhpbiNoYXNGaWx0ZXJIYW5kbGVyIGhhc0ZpbHRlckhhbmRsZXJ9XHJcbiAgICAgKiBAcGFyYW0geyp9IFtmaWx0ZXJdXHJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0Lmhhc0ZpbHRlciA9IGZ1bmN0aW9uIChmaWx0ZXIpIHtcclxuICAgICAgICByZXR1cm4gX2hhc0ZpbHRlckhhbmRsZXIoX2ZpbHRlcnMsIGZpbHRlcik7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBfcmVtb3ZlRmlsdGVySGFuZGxlciA9IGZ1bmN0aW9uIChmaWx0ZXJzLCBmaWx0ZXIpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbHRlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGZpbHRlcnNbaV0gPD0gZmlsdGVyICYmIGZpbHRlcnNbaV0gPj0gZmlsdGVyKSB7XHJcbiAgICAgICAgICAgICAgICBmaWx0ZXJzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmaWx0ZXJzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBvciBnZXQgdGhlIHJlbW92ZSBmaWx0ZXIgaGFuZGxlci4gVGhlIHJlbW92ZSBmaWx0ZXIgaGFuZGxlciBpcyBhIGZ1bmN0aW9uIHRoYXQgcmVtb3ZlcyBhXHJcbiAgICAgKiBmaWx0ZXIgZnJvbSB0aGUgY2hhcnQncyBjdXJyZW50IGZpbHRlcnMuIFVzaW5nIGEgY3VzdG9tIHJlbW92ZSBmaWx0ZXIgaGFuZGxlciBhbGxvd3MgeW91IHRvXHJcbiAgICAgKiBjaGFuZ2UgaG93IGZpbHRlcnMgYXJlIHJlbW92ZWQgb3IgcGVyZm9ybSBhZGRpdGlvbmFsIHdvcmsgd2hlbiByZW1vdmluZyBhIGZpbHRlciwgZS5nLiB3aGVuXHJcbiAgICAgKiB1c2luZyBhIGZpbHRlciBzZXJ2ZXIgb3RoZXIgdGhhbiBjcm9zc2ZpbHRlci5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgaGFuZGxlciBzaG91bGQgcmV0dXJuIGEgbmV3IG9yIG1vZGlmaWVkIGFycmF5IGFzIHRoZSByZXN1bHQuXHJcbiAgICAgKiBAbWV0aG9kIHJlbW92ZUZpbHRlckhhbmRsZXJcclxuICAgICAqIEBtZW1iZXJvZiBkYy5iYXNlTWl4aW5cclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGRlZmF1bHQgcmVtb3ZlIGZpbHRlciBoYW5kbGVyXHJcbiAgICAgKiBjaGFydC5yZW1vdmVGaWx0ZXJIYW5kbGVyKGZ1bmN0aW9uIChmaWx0ZXJzLCBmaWx0ZXIpIHtcclxuICAgICAqICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbHRlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAqICAgICAgICAgaWYgKGZpbHRlcnNbaV0gPD0gZmlsdGVyICYmIGZpbHRlcnNbaV0gPj0gZmlsdGVyKSB7XHJcbiAgICAgKiAgICAgICAgICAgICBmaWx0ZXJzLnNwbGljZShpLCAxKTtcclxuICAgICAqICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICogICAgICAgICB9XHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogICAgIHJldHVybiBmaWx0ZXJzO1xyXG4gICAgICogfSk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gY3VzdG9tIGZpbHRlciBoYW5kbGVyIChuby1vcClcclxuICAgICAqIGNoYXJ0LnJlbW92ZUZpbHRlckhhbmRsZXIoZnVuY3Rpb24oZmlsdGVycywgZmlsdGVyKSB7XHJcbiAgICAgKiAgICAgcmV0dXJuIGZpbHRlcnM7XHJcbiAgICAgKiB9KTtcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZW1vdmVGaWx0ZXJIYW5kbGVyXVxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufGRjLmJhc2VNaXhpbn1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LnJlbW92ZUZpbHRlckhhbmRsZXIgPSBmdW5jdGlvbiAocmVtb3ZlRmlsdGVySGFuZGxlcikge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3JlbW92ZUZpbHRlckhhbmRsZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9yZW1vdmVGaWx0ZXJIYW5kbGVyID0gcmVtb3ZlRmlsdGVySGFuZGxlcjtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgX2FkZEZpbHRlckhhbmRsZXIgPSBmdW5jdGlvbiAoZmlsdGVycywgZmlsdGVyKSB7XHJcbiAgICAgICAgZmlsdGVycy5wdXNoKGZpbHRlcik7XHJcbiAgICAgICAgcmV0dXJuIGZpbHRlcnM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IG9yIGdldCB0aGUgYWRkIGZpbHRlciBoYW5kbGVyLiBUaGUgYWRkIGZpbHRlciBoYW5kbGVyIGlzIGEgZnVuY3Rpb24gdGhhdCBhZGRzIGEgZmlsdGVyIHRvXHJcbiAgICAgKiB0aGUgY2hhcnQncyBmaWx0ZXIgbGlzdC4gVXNpbmcgYSBjdXN0b20gYWRkIGZpbHRlciBoYW5kbGVyIGFsbG93cyB5b3UgdG8gY2hhbmdlIHRoZSB3YXkgZmlsdGVyc1xyXG4gICAgICogYXJlIGFkZGVkIG9yIHBlcmZvcm0gYWRkaXRpb25hbCB3b3JrIHdoZW4gYWRkaW5nIGEgZmlsdGVyLCBlLmcuIHdoZW4gdXNpbmcgYSBmaWx0ZXIgc2VydmVyIG90aGVyXHJcbiAgICAgKiB0aGFuIGNyb3NzZmlsdGVyLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBoYW5kbGVyIHNob3VsZCByZXR1cm4gYSBuZXcgb3IgbW9kaWZpZWQgYXJyYXkgYXMgdGhlIHJlc3VsdC5cclxuICAgICAqIEBtZXRob2QgYWRkRmlsdGVySGFuZGxlclxyXG4gICAgICogQG1lbWJlcm9mIGRjLmJhc2VNaXhpblxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gZGVmYXVsdCBhZGQgZmlsdGVyIGhhbmRsZXJcclxuICAgICAqIGNoYXJ0LmFkZEZpbHRlckhhbmRsZXIoZnVuY3Rpb24gKGZpbHRlcnMsIGZpbHRlcikge1xyXG4gICAgICogICAgIGZpbHRlcnMucHVzaChmaWx0ZXIpO1xyXG4gICAgICogICAgIHJldHVybiBmaWx0ZXJzO1xyXG4gICAgICogfSk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gY3VzdG9tIGZpbHRlciBoYW5kbGVyIChuby1vcClcclxuICAgICAqIGNoYXJ0LmFkZEZpbHRlckhhbmRsZXIoZnVuY3Rpb24oZmlsdGVycywgZmlsdGVyKSB7XHJcbiAgICAgKiAgICAgcmV0dXJuIGZpbHRlcnM7XHJcbiAgICAgKiB9KTtcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFthZGRGaWx0ZXJIYW5kbGVyXVxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufGRjLmJhc2VNaXhpbn1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LmFkZEZpbHRlckhhbmRsZXIgPSBmdW5jdGlvbiAoYWRkRmlsdGVySGFuZGxlcikge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2FkZEZpbHRlckhhbmRsZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9hZGRGaWx0ZXJIYW5kbGVyID0gYWRkRmlsdGVySGFuZGxlcjtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgX3Jlc2V0RmlsdGVySGFuZGxlciA9IGZ1bmN0aW9uIChmaWx0ZXJzKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBvciBnZXQgdGhlIHJlc2V0IGZpbHRlciBoYW5kbGVyLiBUaGUgcmVzZXQgZmlsdGVyIGhhbmRsZXIgaXMgYSBmdW5jdGlvbiB0aGF0IHJlc2V0cyB0aGVcclxuICAgICAqIGNoYXJ0J3MgZmlsdGVyIGxpc3QgYnkgcmV0dXJuaW5nIGEgbmV3IGxpc3QuIFVzaW5nIGEgY3VzdG9tIHJlc2V0IGZpbHRlciBoYW5kbGVyIGFsbG93cyB5b3UgdG9cclxuICAgICAqIGNoYW5nZSB0aGUgd2F5IGZpbHRlcnMgYXJlIHJlc2V0LCBvciBwZXJmb3JtIGFkZGl0aW9uYWwgd29yayB3aGVuIHJlc2V0dGluZyB0aGUgZmlsdGVycyxcclxuICAgICAqIGUuZy4gd2hlbiB1c2luZyBhIGZpbHRlciBzZXJ2ZXIgb3RoZXIgdGhhbiBjcm9zc2ZpbHRlci5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgaGFuZGxlciBzaG91bGQgcmV0dXJuIGEgbmV3IG9yIG1vZGlmaWVkIGFycmF5IGFzIHRoZSByZXN1bHQuXHJcbiAgICAgKiBAbWV0aG9kIHJlc2V0RmlsdGVySGFuZGxlclxyXG4gICAgICogQG1lbWJlcm9mIGRjLmJhc2VNaXhpblxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gZGVmYXVsdCByZW1vdmUgZmlsdGVyIGhhbmRsZXJcclxuICAgICAqIGZ1bmN0aW9uIChmaWx0ZXJzKSB7XHJcbiAgICAgKiAgICAgcmV0dXJuIFtdO1xyXG4gICAgICogfVxyXG4gICAgICpcclxuICAgICAqIC8vIGN1c3RvbSBmaWx0ZXIgaGFuZGxlciAobm8tb3ApXHJcbiAgICAgKiBjaGFydC5yZXNldEZpbHRlckhhbmRsZXIoZnVuY3Rpb24oZmlsdGVycykge1xyXG4gICAgICogICAgIHJldHVybiBmaWx0ZXJzO1xyXG4gICAgICogfSk7XHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzZXRGaWx0ZXJIYW5kbGVyXVxyXG4gICAgICogQHJldHVybnMge2RjLmJhc2VNaXhpbn1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LnJlc2V0RmlsdGVySGFuZGxlciA9IGZ1bmN0aW9uIChyZXNldEZpbHRlckhhbmRsZXIpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9yZXNldEZpbHRlckhhbmRsZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9yZXNldEZpbHRlckhhbmRsZXIgPSByZXNldEZpbHRlckhhbmRsZXI7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gYXBwbHlGaWx0ZXJzIChmaWx0ZXJzKSB7XHJcbiAgICAgICAgaWYgKF9jaGFydC5kaW1lbnNpb24oKSAmJiBfY2hhcnQuZGltZW5zaW9uKCkuZmlsdGVyKSB7XHJcbiAgICAgICAgICAgIHZhciBmcyA9IF9maWx0ZXJIYW5kbGVyKF9jaGFydC5kaW1lbnNpb24oKSwgZmlsdGVycyk7XHJcbiAgICAgICAgICAgIGlmIChmcykge1xyXG4gICAgICAgICAgICAgICAgZmlsdGVycyA9IGZzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmaWx0ZXJzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVwbGFjZSB0aGUgY2hhcnQgZmlsdGVyLiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gY2FsbGluZyBgY2hhcnQuZmlsdGVyKG51bGwpLmZpbHRlcihmaWx0ZXIpYFxyXG4gICAgICogYnV0IG1vcmUgZWZmaWNpZW50IGJlY2F1c2UgdGhlIGZpbHRlciBpcyBvbmx5IGFwcGxpZWQgb25jZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWV0aG9kIHJlcGxhY2VGaWx0ZXJcclxuICAgICAqIEBtZW1iZXJvZiBkYy5iYXNlTWl4aW5cclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHsqfSBbZmlsdGVyXVxyXG4gICAgICogQHJldHVybnMge2RjLmJhc2VNaXhpbn1cclxuICAgICAqKi9cclxuICAgIF9jaGFydC5yZXBsYWNlRmlsdGVyID0gZnVuY3Rpb24gKGZpbHRlcikge1xyXG4gICAgICAgIF9maWx0ZXJzID0gX3Jlc2V0RmlsdGVySGFuZGxlcihfZmlsdGVycyk7XHJcbiAgICAgICAgX2NoYXJ0LmZpbHRlcihmaWx0ZXIpO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlsdGVyIHRoZSBjaGFydCBieSB0aGUgZ2l2ZW4gcGFyYW1ldGVyLCBvciByZXR1cm4gdGhlIGN1cnJlbnQgZmlsdGVyIGlmIG5vIGlucHV0IHBhcmFtZXRlclxyXG4gICAgICogaXMgZ2l2ZW4uXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGZpbHRlciBwYXJhbWV0ZXIgY2FuIHRha2Ugb25lIG9mIHRoZXNlIGZvcm1zOlxyXG4gICAgICogKiBBIHNpbmdsZSB2YWx1ZTogdGhlIHZhbHVlIHdpbGwgYmUgdG9nZ2xlZCAoYWRkZWQgaWYgaXQgaXMgbm90IHByZXNlbnQgaW4gdGhlIGN1cnJlbnRcclxuICAgICAqIGZpbHRlcnMsIHJlbW92ZWQgaWYgaXQgaXMgcHJlc2VudClcclxuICAgICAqICogQW4gYXJyYXkgY29udGFpbmluZyBhIHNpbmdsZSBhcnJheSBvZiB2YWx1ZXMgKGBbW3ZhbHVlLHZhbHVlLHZhbHVlXV1gKTogZWFjaCB2YWx1ZSBpc1xyXG4gICAgICogdG9nZ2xlZFxyXG4gICAgICogKiBXaGVuIGFwcHJvcHJpYXRlIGZvciB0aGUgY2hhcnQsIGEge0BsaW5rIGRjLmZpbHRlcnMgZGMgZmlsdGVyIG9iamVjdH0gc3VjaCBhc1xyXG4gICAgICogICAqIHtAbGluayBkYy5maWx0ZXJzLlJhbmdlZEZpbHRlciBgZGMuZmlsdGVycy5SYW5nZWRGaWx0ZXJgfSBmb3IgdGhlXHJcbiAgICAgKiB7QGxpbmsgZGMuY29vcmRpbmF0ZUdyaWRNaXhpbiBkYy5jb29yZGluYXRlR3JpZE1peGlufSBjaGFydHNcclxuICAgICAqICAgKiB7QGxpbmsgZGMuZmlsdGVycy5Ud29EaW1lbnNpb25hbEZpbHRlciBgZGMuZmlsdGVycy5Ud29EaW1lbnNpb25hbEZpbHRlcmB9IGZvciB0aGVcclxuICAgICAqIHtAbGluayBkYy5oZWF0TWFwIGhlYXQgbWFwfVxyXG4gICAgICogICAqIHtAbGluayBkYy5maWx0ZXJzLlJhbmdlZFR3b0RpbWVuc2lvbmFsRmlsdGVyIGBkYy5maWx0ZXJzLlJhbmdlZFR3b0RpbWVuc2lvbmFsRmlsdGVyYH1cclxuICAgICAqIGZvciB0aGUge0BsaW5rIGRjLnNjYXR0ZXJQbG90IHNjYXR0ZXIgcGxvdH1cclxuICAgICAqICogYG51bGxgOiB0aGUgZmlsdGVyIHdpbGwgYmUgcmVzZXQgdXNpbmcgdGhlXHJcbiAgICAgKiB7QGxpbmsgZGMuYmFzZU1peGluI3Jlc2V0RmlsdGVySGFuZGxlciByZXNldEZpbHRlckhhbmRsZXJ9XHJcbiAgICAgKlxyXG4gICAgICogTm90ZSB0aGF0IHRoaXMgaXMgYWx3YXlzIGEgdG9nZ2xlIChldmVuIHdoZW4gaXQgZG9lc24ndCBtYWtlIHNlbnNlIGZvciB0aGUgZmlsdGVyIHR5cGUpLiBJZlxyXG4gICAgICogeW91IHdpc2ggdG8gcmVwbGFjZSB0aGUgY3VycmVudCBmaWx0ZXIsIGVpdGhlciBjYWxsIGBjaGFydC5maWx0ZXIobnVsbClgIGZpcnN0IC0gb3IgaXQncyBtb3JlXHJcbiAgICAgKiBlZmZpY2llbnQgdG8gY2FsbCB7QGxpbmsgZGMuYmFzZU1peGluI3JlcGxhY2VGaWx0ZXIgYGNoYXJ0LnJlcGxhY2VGaWx0ZXIoZmlsdGVyKWB9IGluc3RlYWQuXHJcbiAgICAgKlxyXG4gICAgICogRWFjaCB0b2dnbGUgaXMgZXhlY3V0ZWQgYnkgY2hlY2tpbmcgaWYgdGhlIHZhbHVlIGlzIGFscmVhZHkgcHJlc2VudCB1c2luZyB0aGVcclxuICAgICAqIHtAbGluayBkYy5iYXNlTWl4aW4jaGFzRmlsdGVySGFuZGxlciBoYXNGaWx0ZXJIYW5kbGVyfTsgaWYgaXQgaXMgbm90IHByZXNlbnQsIGl0IGlzIGFkZGVkXHJcbiAgICAgKiB1c2luZyB0aGUge0BsaW5rIGRjLmJhc2VNaXhpbiNhZGRGaWx0ZXJIYW5kbGVyIGFkZEZpbHRlckhhbmRsZXJ9OyBpZiBpdCBpcyBhbHJlYWR5IHByZXNlbnQsXHJcbiAgICAgKiBpdCBpcyByZW1vdmVkIHVzaW5nIHRoZSB7QGxpbmsgZGMuYmFzZU1peGluI3JlbW92ZUZpbHRlckhhbmRsZXIgcmVtb3ZlRmlsdGVySGFuZGxlcn0uXHJcbiAgICAgKlxyXG4gICAgICogT25jZSB0aGUgZmlsdGVycyBhcnJheSBoYXMgYmVlbiB1cGRhdGVkLCB0aGUgZmlsdGVycyBhcmUgYXBwbGllZCB0byB0aGVcclxuICAgICAqIGNyb3NzZmlsdGVyIGRpbWVuc2lvbiwgdXNpbmcgdGhlIHtAbGluayBkYy5iYXNlTWl4aW4jZmlsdGVySGFuZGxlciBmaWx0ZXJIYW5kbGVyfS5cclxuICAgICAqXHJcbiAgICAgKiBPbmNlIHlvdSBoYXZlIHNldCB0aGUgZmlsdGVycywgY2FsbCB7QGxpbmsgZGMuYmFzZU1peGluI3JlZHJhd0dyb3VwIGBjaGFydC5yZWRyYXdHcm91cCgpYH1cclxuICAgICAqIChvciB7QGxpbmsgZGMucmVkcmF3QWxsIGBkYy5yZWRyYXdBbGwoKWB9KSB0byByZWRyYXcgdGhlIGNoYXJ0J3MgZ3JvdXAuXHJcbiAgICAgKiBAbWV0aG9kIGZpbHRlclxyXG4gICAgICogQG1lbWJlcm9mIGRjLmJhc2VNaXhpblxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAc2VlIHtAbGluayBkYy5iYXNlTWl4aW4jYWRkRmlsdGVySGFuZGxlciBhZGRGaWx0ZXJIYW5kbGVyfVxyXG4gICAgICogQHNlZSB7QGxpbmsgZGMuYmFzZU1peGluI3JlbW92ZUZpbHRlckhhbmRsZXIgcmVtb3ZlRmlsdGVySGFuZGxlcn1cclxuICAgICAqIEBzZWUge0BsaW5rIGRjLmJhc2VNaXhpbiNyZXNldEZpbHRlckhhbmRsZXIgcmVzZXRGaWx0ZXJIYW5kbGVyfVxyXG4gICAgICogQHNlZSB7QGxpbmsgZGMuYmFzZU1peGluI2ZpbHRlckhhbmRsZXIgZmlsdGVySGFuZGxlcn1cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBmaWx0ZXIgYnkgYSBzaW5nbGUgc3RyaW5nXHJcbiAgICAgKiBjaGFydC5maWx0ZXIoJ1N1bmRheScpO1xyXG4gICAgICogLy8gZmlsdGVyIGJ5IGEgc2luZ2xlIGFnZVxyXG4gICAgICogY2hhcnQuZmlsdGVyKDE4KTtcclxuICAgICAqIC8vIGZpbHRlciBieSBhIHNldCBvZiBzdGF0ZXNcclxuICAgICAqIGNoYXJ0LmZpbHRlcihbWydNQScsICdUWCcsICdORCcsICdXQSddXSk7XHJcbiAgICAgKiAvLyBmaWx0ZXIgYnkgcmFuZ2UgLS0gbm90ZSB0aGUgdXNlIG9mIGRjLmZpbHRlcnMuUmFuZ2VkRmlsdGVyLCB3aGljaCBpcyBkaWZmZXJlbnRcclxuICAgICAqIC8vIGZyb20gdGhlIHN5bnRheCBmb3IgZmlsdGVyaW5nIGEgY3Jvc3NmaWx0ZXIgZGltZW5zaW9uIGRpcmVjdGx5LCBkaW1lbnNpb24uZmlsdGVyKFsxNSwyMF0pXHJcbiAgICAgKiBjaGFydC5maWx0ZXIoZGMuZmlsdGVycy5SYW5nZWRGaWx0ZXIoMTUsMjApKTtcclxuICAgICAqIEBwYXJhbSB7Kn0gW2ZpbHRlcl1cclxuICAgICAqIEByZXR1cm5zIHtkYy5iYXNlTWl4aW59XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5maWx0ZXIgPSBmdW5jdGlvbiAoZmlsdGVyKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfZmlsdGVycy5sZW5ndGggPiAwID8gX2ZpbHRlcnNbMF0gOiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZmlsdGVycyA9IF9maWx0ZXJzO1xyXG4gICAgICAgIGlmIChmaWx0ZXIgaW5zdGFuY2VvZiBBcnJheSAmJiBmaWx0ZXJbMF0gaW5zdGFuY2VvZiBBcnJheSAmJiAhZmlsdGVyLmlzRmlsdGVyZWQpIHtcclxuICAgICAgICAgICAgLy8gdG9nZ2xlIGVhY2ggZmlsdGVyXHJcbiAgICAgICAgICAgIGZpbHRlclswXS5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX2hhc0ZpbHRlckhhbmRsZXIoZmlsdGVycywgZikpIHtcclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJzID0gX3JlbW92ZUZpbHRlckhhbmRsZXIoZmlsdGVycywgZik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcnMgPSBfYWRkRmlsdGVySGFuZGxlcihmaWx0ZXJzLCBmKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChmaWx0ZXIgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgZmlsdGVycyA9IF9yZXNldEZpbHRlckhhbmRsZXIoZmlsdGVycyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKF9oYXNGaWx0ZXJIYW5kbGVyKGZpbHRlcnMsIGZpbHRlcikpIHtcclxuICAgICAgICAgICAgICAgIGZpbHRlcnMgPSBfcmVtb3ZlRmlsdGVySGFuZGxlcihmaWx0ZXJzLCBmaWx0ZXIpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZmlsdGVycyA9IF9hZGRGaWx0ZXJIYW5kbGVyKGZpbHRlcnMsIGZpbHRlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgX2ZpbHRlcnMgPSBhcHBseUZpbHRlcnMoZmlsdGVycyk7XHJcbiAgICAgICAgX2NoYXJ0Ll9pbnZva2VGaWx0ZXJlZExpc3RlbmVyKGZpbHRlcik7XHJcblxyXG4gICAgICAgIGlmIChfcm9vdCAhPT0gbnVsbCAmJiBfY2hhcnQuaGFzRmlsdGVyKCkpIHtcclxuICAgICAgICAgICAgX2NoYXJ0LnR1cm5PbkNvbnRyb2xzKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgX2NoYXJ0LnR1cm5PZmZDb250cm9scygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFsbCBjdXJyZW50IGZpbHRlcnMuIFRoaXMgbWV0aG9kIGRvZXMgbm90IHBlcmZvcm0gZGVmZW5zaXZlIGNsb25pbmcgb2YgdGhlIGludGVybmFsXHJcbiAgICAgKiBmaWx0ZXIgYXJyYXkgYmVmb3JlIHJldHVybmluZywgdGhlcmVmb3JlIGFueSBtb2RpZmljYXRpb24gb2YgdGhlIHJldHVybmVkIGFycmF5IHdpbGwgZWZmZWN0IHRoZVxyXG4gICAgICogY2hhcnQncyBpbnRlcm5hbCBmaWx0ZXIgc3RvcmFnZS5cclxuICAgICAqIEBtZXRob2QgZmlsdGVyc1xyXG4gICAgICogQG1lbWJlcm9mIGRjLmJhc2VNaXhpblxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8Kj59XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5maWx0ZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfZmlsdGVycztcclxuICAgIH07XHJcblxyXG4gICAgX2NoYXJ0LmhpZ2hsaWdodFNlbGVjdGVkID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBkMy5zZWxlY3QoZSkuY2xhc3NlZChkYy5jb25zdGFudHMuU0VMRUNURURfQ0xBU1MsIHRydWUpO1xyXG4gICAgICAgIGQzLnNlbGVjdChlKS5jbGFzc2VkKGRjLmNvbnN0YW50cy5ERVNFTEVDVEVEX0NMQVNTLCBmYWxzZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9jaGFydC5mYWRlRGVzZWxlY3RlZCA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgZDMuc2VsZWN0KGUpLmNsYXNzZWQoZGMuY29uc3RhbnRzLlNFTEVDVEVEX0NMQVNTLCBmYWxzZSk7XHJcbiAgICAgICAgZDMuc2VsZWN0KGUpLmNsYXNzZWQoZGMuY29uc3RhbnRzLkRFU0VMRUNURURfQ0xBU1MsIHRydWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfY2hhcnQucmVzZXRIaWdobGlnaHQgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIGQzLnNlbGVjdChlKS5jbGFzc2VkKGRjLmNvbnN0YW50cy5TRUxFQ1RFRF9DTEFTUywgZmFsc2UpO1xyXG4gICAgICAgIGQzLnNlbGVjdChlKS5jbGFzc2VkKGRjLmNvbnN0YW50cy5ERVNFTEVDVEVEX0NMQVNTLCBmYWxzZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBwYXNzZWQgdG8gZDMgYXMgdGhlIG9uQ2xpY2sgaGFuZGxlciBmb3IgZWFjaCBjaGFydC4gVGhlIGRlZmF1bHQgYmVoYXZpb3IgaXMgdG9cclxuICAgICAqIGZpbHRlciBvbiB0aGUgY2xpY2tlZCBkYXR1bSAocGFzc2VkIHRvIHRoZSBjYWxsYmFjaykgYW5kIHJlZHJhdyB0aGUgY2hhcnQgZ3JvdXAuXHJcbiAgICAgKiBAbWV0aG9kIG9uQ2xpY2tcclxuICAgICAqIEBtZW1iZXJvZiBkYy5iYXNlTWl4aW5cclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHsqfSBkYXR1bVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQub25DbGljayA9IGZ1bmN0aW9uIChkYXR1bSkge1xyXG4gICAgICAgIHZhciBmaWx0ZXIgPSBfY2hhcnQua2V5QWNjZXNzb3IoKShkYXR1bSk7XHJcbiAgICAgICAgZGMuZXZlbnRzLnRyaWdnZXIoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfY2hhcnQuZmlsdGVyKGZpbHRlcik7XHJcbiAgICAgICAgICAgIF9jaGFydC5yZWRyYXdHcm91cCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBvciBnZXQgdGhlIGZpbHRlciBoYW5kbGVyLiBUaGUgZmlsdGVyIGhhbmRsZXIgaXMgYSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIHRoZSBmaWx0ZXIgYWN0aW9uXHJcbiAgICAgKiBvbiBhIHNwZWNpZmljIGRpbWVuc2lvbi4gVXNpbmcgYSBjdXN0b20gZmlsdGVyIGhhbmRsZXIgYWxsb3dzIHlvdSB0byBwZXJmb3JtIGFkZGl0aW9uYWwgbG9naWNcclxuICAgICAqIGJlZm9yZSBvciBhZnRlciBmaWx0ZXJpbmcuXHJcbiAgICAgKiBAbWV0aG9kIGZpbHRlckhhbmRsZXJcclxuICAgICAqIEBtZW1iZXJvZiBkYy5iYXNlTWl4aW5cclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Nyb3NzZmlsdGVyL2Nyb3NzZmlsdGVyL3dpa2kvQVBJLVJlZmVyZW5jZSNkaW1lbnNpb25fZmlsdGVyIGNyb3NzZmlsdGVyLmRpbWVuc2lvbi5maWx0ZXJ9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gdGhlIGRlZmF1bHQgZmlsdGVyIGhhbmRsZXIgaGFuZGxlcyBhbGwgcG9zc2libGUgY2FzZXMgZm9yIHRoZSBjaGFydHMgaW4gZGMuanNcclxuICAgICAqIC8vIHlvdSBjYW4gcmVwbGFjZSBpdCB3aXRoIHNvbWV0aGluZyBtb3JlIHNwZWNpYWxpemVkIGZvciB5b3VyIG93biBjaGFydFxyXG4gICAgICogY2hhcnQuZmlsdGVySGFuZGxlcihmdW5jdGlvbiAoZGltZW5zaW9uLCBmaWx0ZXJzKSB7XHJcbiAgICAgKiAgICAgaWYgKGZpbHRlcnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgKiAgICAgICAgIC8vIHRoZSBlbXB0eSBjYXNlIChubyBmaWx0ZXJpbmcpXHJcbiAgICAgKiAgICAgICAgIGRpbWVuc2lvbi5maWx0ZXIobnVsbCk7XHJcbiAgICAgKiAgICAgfSBlbHNlIGlmIChmaWx0ZXJzLmxlbmd0aCA9PT0gMSAmJiAhZmlsdGVyc1swXS5pc0ZpbHRlcmVkKSB7XHJcbiAgICAgKiAgICAgICAgIC8vIHNpbmdsZSB2YWx1ZSBhbmQgbm90IGEgZnVuY3Rpb24tYmFzZWQgZmlsdGVyXHJcbiAgICAgKiAgICAgICAgIGRpbWVuc2lvbi5maWx0ZXJFeGFjdChmaWx0ZXJzWzBdKTtcclxuICAgICAqICAgICB9IGVsc2UgaWYgKGZpbHRlcnMubGVuZ3RoID09PSAxICYmIGZpbHRlcnNbMF0uZmlsdGVyVHlwZSA9PT0gJ1JhbmdlZEZpbHRlcicpIHtcclxuICAgICAqICAgICAgICAgLy8gc2luZ2xlIHJhbmdlLWJhc2VkIGZpbHRlclxyXG4gICAgICogICAgICAgICBkaW1lbnNpb24uZmlsdGVyUmFuZ2UoZmlsdGVyc1swXSk7XHJcbiAgICAgKiAgICAgfSBlbHNlIHtcclxuICAgICAqICAgICAgICAgLy8gYW4gYXJyYXkgb2YgdmFsdWVzLCBvciBhbiBhcnJheSBvZiBmaWx0ZXIgb2JqZWN0c1xyXG4gICAgICogICAgICAgICBkaW1lbnNpb24uZmlsdGVyRnVuY3Rpb24oZnVuY3Rpb24gKGQpIHtcclxuICAgICAqICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsdGVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICogICAgICAgICAgICAgICAgIHZhciBmaWx0ZXIgPSBmaWx0ZXJzW2ldO1xyXG4gICAgICogICAgICAgICAgICAgICAgIGlmIChmaWx0ZXIuaXNGaWx0ZXJlZCAmJiBmaWx0ZXIuaXNGaWx0ZXJlZChkKSkge1xyXG4gICAgICogICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAqICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZpbHRlciA8PSBkICYmIGZpbHRlciA+PSBkKSB7XHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICogICAgICAgICAgICAgICAgIH1cclxuICAgICAqICAgICAgICAgICAgIH1cclxuICAgICAqICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAqICAgICAgICAgfSk7XHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogICAgIHJldHVybiBmaWx0ZXJzO1xyXG4gICAgICogfSk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gY3VzdG9tIGZpbHRlciBoYW5kbGVyXHJcbiAgICAgKiBjaGFydC5maWx0ZXJIYW5kbGVyKGZ1bmN0aW9uKGRpbWVuc2lvbiwgZmlsdGVyKXtcclxuICAgICAqICAgICB2YXIgbmV3RmlsdGVyID0gZmlsdGVyICsgMTA7XHJcbiAgICAgKiAgICAgZGltZW5zaW9uLmZpbHRlcihuZXdGaWx0ZXIpO1xyXG4gICAgICogICAgIHJldHVybiBuZXdGaWx0ZXI7IC8vIHNldCB0aGUgYWN0dWFsIGZpbHRlciB2YWx1ZSB0byB0aGUgbmV3IHZhbHVlXHJcbiAgICAgKiB9KTtcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtmaWx0ZXJIYW5kbGVyXVxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufGRjLmJhc2VNaXhpbn1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LmZpbHRlckhhbmRsZXIgPSBmdW5jdGlvbiAoZmlsdGVySGFuZGxlcikge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2ZpbHRlckhhbmRsZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9maWx0ZXJIYW5kbGVyID0gZmlsdGVySGFuZGxlcjtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBhYnN0cmFjdCBmdW5jdGlvbiBzdHViXHJcbiAgICBfY2hhcnQuX2RvUmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIGRvIG5vdGhpbmcgaW4gYmFzZSwgc2hvdWxkIGJlIG92ZXJyaWRkZW4gYnkgc3ViLWZ1bmN0aW9uXHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgX2NoYXJ0Ll9kb1JlZHJhdyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBkbyBub3RoaW5nIGluIGJhc2UsIHNob3VsZCBiZSBvdmVycmlkZGVuIGJ5IHN1Yi1mdW5jdGlvblxyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF9jaGFydC5sZWdlbmRhYmxlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBkbyBub3RoaW5nIGluIGJhc2UsIHNob3VsZCBiZSBvdmVycmlkZGVuIGJ5IHN1Yi1mdW5jdGlvblxyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH07XHJcblxyXG4gICAgX2NoYXJ0LmxlZ2VuZEhpZ2hsaWdodCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBkbyBub3RoaW5nIGluIGJhc2UsIHNob3VsZCBiZSBvdmVycmlkZGVuIGJ5IHN1Yi1mdW5jdGlvblxyXG4gICAgfTtcclxuXHJcbiAgICBfY2hhcnQubGVnZW5kUmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gZG8gbm90aGluZyBpbiBiYXNlLCBzaG91bGQgYmUgb3ZlcnJpZGRlbiBieSBzdWItZnVuY3Rpb25cclxuICAgIH07XHJcblxyXG4gICAgX2NoYXJ0LmxlZ2VuZFRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBkbyBub3RoaW5nIGluIGJhc2UsIHNob3VsZCBiZSBvdmVycmlkZW4gYnkgc3ViLWZ1bmN0aW9uXHJcbiAgICB9O1xyXG5cclxuICAgIF9jaGFydC5pc0xlZ2VuZGFibGVIaWRkZW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gZG8gbm90aGluZyBpbiBiYXNlLCBzaG91bGQgYmUgb3ZlcnJpZGRlbiBieSBzdWItZnVuY3Rpb25cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IG9yIGdldCB0aGUga2V5IGFjY2Vzc29yIGZ1bmN0aW9uLiBUaGUga2V5IGFjY2Vzc29yIGZ1bmN0aW9uIGlzIHVzZWQgdG8gcmV0cmlldmUgdGhlIGtleVxyXG4gICAgICogdmFsdWUgZnJvbSB0aGUgY3Jvc3NmaWx0ZXIgZ3JvdXAuIEtleSB2YWx1ZXMgYXJlIHVzZWQgZGlmZmVyZW50bHkgaW4gZGlmZmVyZW50IGNoYXJ0cywgZm9yXHJcbiAgICAgKiBleGFtcGxlIGtleXMgY29ycmVzcG9uZCB0byBzbGljZXMgaW4gYSBwaWUgY2hhcnQgYW5kIHggYXhpcyBwb3NpdGlvbnMgaW4gYSBncmlkIGNvb3JkaW5hdGUgY2hhcnQuXHJcbiAgICAgKiBAbWV0aG9kIGtleUFjY2Vzc29yXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuYmFzZU1peGluXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBkZWZhdWx0IGtleSBhY2Nlc3NvclxyXG4gICAgICogY2hhcnQua2V5QWNjZXNzb3IoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5rZXk7IH0pO1xyXG4gICAgICogLy8gY3VzdG9tIGtleSBhY2Nlc3NvciBmb3IgYSBtdWx0aS12YWx1ZSBjcm9zc2ZpbHRlciByZWR1Y3Rpb25cclxuICAgICAqIGNoYXJ0LmtleUFjY2Vzc29yKGZ1bmN0aW9uKHApIHsgcmV0dXJuIHAudmFsdWUuYWJzR2FpbjsgfSk7XHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBba2V5QWNjZXNzb3JdXHJcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb258ZGMuYmFzZU1peGlufVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQua2V5QWNjZXNzb3IgPSBmdW5jdGlvbiAoa2V5QWNjZXNzb3IpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9rZXlBY2Nlc3NvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgX2tleUFjY2Vzc29yID0ga2V5QWNjZXNzb3I7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgb3IgZ2V0IHRoZSB2YWx1ZSBhY2Nlc3NvciBmdW5jdGlvbi4gVGhlIHZhbHVlIGFjY2Vzc29yIGZ1bmN0aW9uIGlzIHVzZWQgdG8gcmV0cmlldmUgdGhlXHJcbiAgICAgKiB2YWx1ZSBmcm9tIHRoZSBjcm9zc2ZpbHRlciBncm91cC4gR3JvdXAgdmFsdWVzIGFyZSB1c2VkIGRpZmZlcmVudGx5IGluIGRpZmZlcmVudCBjaGFydHMsIGZvclxyXG4gICAgICogZXhhbXBsZSB2YWx1ZXMgY29ycmVzcG9uZCB0byBzbGljZSBzaXplcyBpbiBhIHBpZSBjaGFydCBhbmQgeSBheGlzIHBvc2l0aW9ucyBpbiBhIGdyaWRcclxuICAgICAqIGNvb3JkaW5hdGUgY2hhcnQuXHJcbiAgICAgKiBAbWV0aG9kIHZhbHVlQWNjZXNzb3JcclxuICAgICAqIEBtZW1iZXJvZiBkYy5iYXNlTWl4aW5cclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGRlZmF1bHQgdmFsdWUgYWNjZXNzb3JcclxuICAgICAqIGNoYXJ0LnZhbHVlQWNjZXNzb3IoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC52YWx1ZTsgfSk7XHJcbiAgICAgKiAvLyBjdXN0b20gdmFsdWUgYWNjZXNzb3IgZm9yIGEgbXVsdGktdmFsdWUgY3Jvc3NmaWx0ZXIgcmVkdWN0aW9uXHJcbiAgICAgKiBjaGFydC52YWx1ZUFjY2Vzc29yKGZ1bmN0aW9uKHApIHsgcmV0dXJuIHAudmFsdWUucGVyY2VudGFnZUdhaW47IH0pO1xyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ZhbHVlQWNjZXNzb3JdXHJcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb258ZGMuYmFzZU1peGlufVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQudmFsdWVBY2Nlc3NvciA9IGZ1bmN0aW9uICh2YWx1ZUFjY2Vzc29yKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfdmFsdWVBY2Nlc3NvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3ZhbHVlQWNjZXNzb3IgPSB2YWx1ZUFjY2Vzc29yO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IG9yIGdldCB0aGUgbGFiZWwgZnVuY3Rpb24uIFRoZSBjaGFydCBjbGFzcyB3aWxsIHVzZSB0aGlzIGZ1bmN0aW9uIHRvIHJlbmRlciBsYWJlbHMgZm9yIGVhY2hcclxuICAgICAqIGNoaWxkIGVsZW1lbnQgaW4gdGhlIGNoYXJ0LCBlLmcuIHNsaWNlcyBpbiBhIHBpZSBjaGFydCBvciBidWJibGVzIGluIGEgYnViYmxlIGNoYXJ0LiBOb3QgZXZlcnlcclxuICAgICAqIGNoYXJ0IHN1cHBvcnRzIHRoZSBsYWJlbCBmdW5jdGlvbiwgZm9yIGV4YW1wbGUgbGluZSBjaGFydCBkb2VzIG5vdCB1c2UgdGhpcyBmdW5jdGlvblxyXG4gICAgICogYXQgYWxsLiBCeSBkZWZhdWx0LCBlbmFibGVzIGxhYmVsczsgcGFzcyBmYWxzZSBmb3IgdGhlIHNlY29uZCBwYXJhbWV0ZXIgaWYgdGhpcyBpcyBub3QgZGVzaXJlZC5cclxuICAgICAqIEBtZXRob2QgbGFiZWxcclxuICAgICAqIEBtZW1iZXJvZiBkYy5iYXNlTWl4aW5cclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGRlZmF1bHQgbGFiZWwgZnVuY3Rpb24ganVzdCByZXR1cm4gdGhlIGtleVxyXG4gICAgICogY2hhcnQubGFiZWwoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5rZXk7IH0pO1xyXG4gICAgICogLy8gbGFiZWwgZnVuY3Rpb24gaGFzIGFjY2VzcyB0byB0aGUgc3RhbmRhcmQgZDMgZGF0YSBiaW5kaW5nIGFuZCBjYW4gZ2V0IHF1aXRlIGNvbXBsaWNhdGVkXHJcbiAgICAgKiBjaGFydC5sYWJlbChmdW5jdGlvbihkKSB7IHJldHVybiBkLmRhdGEua2V5ICsgJygnICsgTWF0aC5mbG9vcihkLmRhdGEudmFsdWUgLyBhbGwudmFsdWUoKSAqIDEwMCkgKyAnJSknOyB9KTtcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtsYWJlbEZ1bmN0aW9uXVxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZW5hYmxlTGFiZWxzPXRydWVdXHJcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb258ZGMuYmFzZU1peGlufVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQubGFiZWwgPSBmdW5jdGlvbiAobGFiZWxGdW5jdGlvbiwgZW5hYmxlTGFiZWxzKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfbGFiZWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9sYWJlbCA9IGxhYmVsRnVuY3Rpb247XHJcbiAgICAgICAgaWYgKChlbmFibGVMYWJlbHMgPT09IHVuZGVmaW5lZCkgfHwgZW5hYmxlTGFiZWxzKSB7XHJcbiAgICAgICAgICAgIF9yZW5kZXJMYWJlbCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHVybiBvbi9vZmYgbGFiZWwgcmVuZGVyaW5nXHJcbiAgICAgKiBAbWV0aG9kIHJlbmRlckxhYmVsXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuYmFzZU1peGluXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3JlbmRlckxhYmVsPWZhbHNlXVxyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW58ZGMuYmFzZU1peGlufVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQucmVuZGVyTGFiZWwgPSBmdW5jdGlvbiAocmVuZGVyTGFiZWwpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9yZW5kZXJMYWJlbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3JlbmRlckxhYmVsID0gcmVuZGVyTGFiZWw7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgb3IgZ2V0IHRoZSB0aXRsZSBmdW5jdGlvbi4gVGhlIGNoYXJ0IGNsYXNzIHdpbGwgdXNlIHRoaXMgZnVuY3Rpb24gdG8gcmVuZGVyIHRoZSBTVkdFbGVtZW50IHRpdGxlXHJcbiAgICAgKiAodXN1YWxseSBpbnRlcnByZXRlZCBieSBicm93c2VyIGFzIHRvb2x0aXBzKSBmb3IgZWFjaCBjaGlsZCBlbGVtZW50IGluIHRoZSBjaGFydCwgZS5nLiBhIHNsaWNlXHJcbiAgICAgKiBpbiBhIHBpZSBjaGFydCBvciBhIGJ1YmJsZSBpbiBhIGJ1YmJsZSBjaGFydC4gQWxtb3N0IGV2ZXJ5IGNoYXJ0IHN1cHBvcnRzIHRoZSB0aXRsZSBmdW5jdGlvbjtcclxuICAgICAqIGhvd2V2ZXIgaW4gZ3JpZCBjb29yZGluYXRlIGNoYXJ0cyB5b3UgbmVlZCB0byB0dXJuIG9mZiB0aGUgYnJ1c2ggaW4gb3JkZXIgdG8gc2VlIHRpdGxlcywgYmVjYXVzZVxyXG4gICAgICogb3RoZXJ3aXNlIHRoZSBicnVzaCBsYXllciB3aWxsIGJsb2NrIHRvb2x0aXAgdHJpZ2dlcmluZy5cclxuICAgICAqIEBtZXRob2QgdGl0bGVcclxuICAgICAqIEBtZW1iZXJvZiBkYy5iYXNlTWl4aW5cclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGRlZmF1bHQgdGl0bGUgZnVuY3Rpb24gc2hvd3MgXCJrZXk6IHZhbHVlXCJcclxuICAgICAqIGNoYXJ0LnRpdGxlKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQua2V5ICsgJzogJyArIGQudmFsdWU7IH0pO1xyXG4gICAgICogLy8gdGl0bGUgZnVuY3Rpb24gaGFzIGFjY2VzcyB0byB0aGUgc3RhbmRhcmQgZDMgZGF0YSBiaW5kaW5nIGFuZCBjYW4gZ2V0IHF1aXRlIGNvbXBsaWNhdGVkXHJcbiAgICAgKiBjaGFydC50aXRsZShmdW5jdGlvbihwKSB7XHJcbiAgICAgKiAgICByZXR1cm4gcC5rZXkuZ2V0RnVsbFllYXIoKVxyXG4gICAgICogICAgICAgICsgJ1xcbidcclxuICAgICAqICAgICAgICArICdJbmRleCBHYWluOiAnICsgbnVtYmVyRm9ybWF0KHAudmFsdWUuYWJzR2FpbikgKyAnXFxuJ1xyXG4gICAgICogICAgICAgICsgJ0luZGV4IEdhaW4gaW4gUGVyY2VudGFnZTogJyArIG51bWJlckZvcm1hdChwLnZhbHVlLnBlcmNlbnRhZ2VHYWluKSArICclXFxuJ1xyXG4gICAgICogICAgICAgICsgJ0ZsdWN0dWF0aW9uIC8gSW5kZXggUmF0aW86ICcgKyBudW1iZXJGb3JtYXQocC52YWx1ZS5mbHVjdHVhdGlvblBlcmNlbnRhZ2UpICsgJyUnO1xyXG4gICAgICogfSk7XHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbdGl0bGVGdW5jdGlvbl1cclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbnxkYy5iYXNlTWl4aW59XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC50aXRsZSA9IGZ1bmN0aW9uICh0aXRsZUZ1bmN0aW9uKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGl0bGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF90aXRsZSA9IHRpdGxlRnVuY3Rpb247XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUdXJuIG9uL29mZiB0aXRsZSByZW5kZXJpbmcsIG9yIHJldHVybiB0aGUgc3RhdGUgb2YgdGhlIHJlbmRlciB0aXRsZSBmbGFnIGlmIG5vIGFyZ3VtZW50cyBhcmVcclxuICAgICAqIGdpdmVuLlxyXG4gICAgICogQG1ldGhvZCByZW5kZXJUaXRsZVxyXG4gICAgICogQG1lbWJlcm9mIGRjLmJhc2VNaXhpblxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtyZW5kZXJUaXRsZT10cnVlXVxyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW58ZGMuYmFzZU1peGlufVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQucmVuZGVyVGl0bGUgPSBmdW5jdGlvbiAocmVuZGVyVGl0bGUpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9yZW5kZXJUaXRsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3JlbmRlclRpdGxlID0gcmVuZGVyVGl0bGU7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHJlbmRlcmxldCBpcyBzaW1pbGFyIHRvIGFuIGV2ZW50IGxpc3RlbmVyIG9uIHJlbmRlcmluZyBldmVudC4gTXVsdGlwbGUgcmVuZGVybGV0cyBjYW4gYmUgYWRkZWRcclxuICAgICAqIHRvIGFuIGluZGl2aWR1YWwgY2hhcnQuICBFYWNoIHRpbWUgYSBjaGFydCBpcyByZXJlbmRlcmVkIG9yIHJlZHJhd24gdGhlIHJlbmRlcmxldHMgYXJlIGludm9rZWRcclxuICAgICAqIHJpZ2h0IGFmdGVyIHRoZSBjaGFydCBmaW5pc2hlcyBpdHMgdHJhbnNpdGlvbnMsIGdpdmluZyB5b3UgYSB3YXkgdG8gbW9kaWZ5IHRoZSBTVkdFbGVtZW50cy5cclxuICAgICAqIFJlbmRlcmxldCBmdW5jdGlvbnMgdGFrZSB0aGUgY2hhcnQgaW5zdGFuY2UgYXMgdGhlIG9ubHkgaW5wdXQgcGFyYW1ldGVyIGFuZCB5b3UgY2FuXHJcbiAgICAgKiB1c2UgdGhlIGRjIEFQSSBvciB1c2UgcmF3IGQzIHRvIGFjaGlldmUgcHJldHR5IG11Y2ggYW55IGVmZmVjdC5cclxuICAgICAqXHJcbiAgICAgKiBVc2Uge0BsaW5rIGRjLmJhc2VNaXhpbiNvbiBvbn0gd2l0aCBhICdyZW5kZXJsZXQnIHByZWZpeC5cclxuICAgICAqIEdlbmVyYXRlcyBhIHJhbmRvbSBrZXkgZm9yIHRoZSByZW5kZXJsZXQsIHdoaWNoIG1ha2VzIGl0IGhhcmQgdG8gcmVtb3ZlLlxyXG4gICAgICogQG1ldGhvZCByZW5kZXJsZXRcclxuICAgICAqIEBtZW1iZXJvZiBkYy5iYXNlTWl4aW5cclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBkbyB0aGlzIGluc3RlYWQgb2YgLnJlbmRlcmxldChmdW5jdGlvbihjaGFydCkgeyAuLi4gfSlcclxuICAgICAqIGNoYXJ0Lm9uKFwicmVuZGVybGV0XCIsIGZ1bmN0aW9uKGNoYXJ0KXtcclxuICAgICAqICAgICAvLyBtaXggb2YgZGMgQVBJIGFuZCBkMyBtYW5pcHVsYXRpb25cclxuICAgICAqICAgICBjaGFydC5zZWxlY3QoJ2cueScpLnN0eWxlKCdkaXNwbGF5JywgJ25vbmUnKTtcclxuICAgICAqICAgICAvLyBpdHMgYSBjbG9zdXJlIHNvIHlvdSBjYW4gYWxzbyBhY2Nlc3Mgb3RoZXIgY2hhcnQgdmFyaWFibGUgYXZhaWxhYmxlIGluIHRoZSBjbG9zdXJlIHNjb3BlXHJcbiAgICAgKiAgICAgbW92ZUNoYXJ0LmZpbHRlcihjaGFydC5maWx0ZXIoKSk7XHJcbiAgICAgKiB9KTtcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlbmRlcmxldEZ1bmN0aW9uXHJcbiAgICAgKiBAcmV0dXJucyB7ZGMuYmFzZU1peGlufVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQucmVuZGVybGV0ID0gZGMubG9nZ2VyLmRlcHJlY2F0ZShmdW5jdGlvbiAocmVuZGVybGV0RnVuY3Rpb24pIHtcclxuICAgICAgICBfY2hhcnQub24oJ3JlbmRlcmxldC4nICsgZGMudXRpbHMudW5pcXVlSWQoKSwgcmVuZGVybGV0RnVuY3Rpb24pO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9LCAnY2hhcnQucmVuZGVybGV0IGhhcyBiZWVuIGRlcHJlY2F0ZWQuICBQbGVhc2UgdXNlIGNoYXJ0Lm9uKFwicmVuZGVybGV0LjxyZW5kZXJsZXRLZXk+XCIsIHJlbmRlcmxldEZ1bmN0aW9uKScpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IG9yIHNldCB0aGUgY2hhcnQgZ3JvdXAgdG8gd2hpY2ggdGhpcyBjaGFydCBiZWxvbmdzLiBDaGFydCBncm91cHMgYXJlIHJlbmRlcmVkIG9yIHJlZHJhd25cclxuICAgICAqIHRvZ2V0aGVyIHNpbmNlIGl0IGlzIGV4cGVjdGVkIHRoZXkgc2hhcmUgdGhlIHNhbWUgdW5kZXJseWluZyBjcm9zc2ZpbHRlciBkYXRhIHNldC5cclxuICAgICAqIEBtZXRob2QgY2hhcnRHcm91cFxyXG4gICAgICogQG1lbWJlcm9mIGRjLmJhc2VNaXhpblxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NoYXJ0R3JvdXBdXHJcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfGRjLmJhc2VNaXhpbn1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LmNoYXJ0R3JvdXAgPSBmdW5jdGlvbiAoY2hhcnRHcm91cCkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2NoYXJ0R3JvdXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghX2lzQ2hpbGQpIHtcclxuICAgICAgICAgICAgZGMuZGVyZWdpc3RlckNoYXJ0KF9jaGFydCwgX2NoYXJ0R3JvdXApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfY2hhcnRHcm91cCA9IGNoYXJ0R3JvdXA7XHJcbiAgICAgICAgaWYgKCFfaXNDaGlsZCkge1xyXG4gICAgICAgICAgICBkYy5yZWdpc3RlckNoYXJ0KF9jaGFydCwgX2NoYXJ0R3JvdXApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEV4cGlyZSB0aGUgaW50ZXJuYWwgY2hhcnQgY2FjaGUuIGRjIGNoYXJ0cyBjYWNoZSBzb21lIGRhdGEgaW50ZXJuYWxseSBvbiBhIHBlciBjaGFydCBiYXNpcyB0b1xyXG4gICAgICogc3BlZWQgdXAgcmVuZGVyaW5nIGFuZCBhdm9pZCB1bm5lY2Vzc2FyeSBjYWxjdWxhdGlvbjsgaG93ZXZlciBpdCBtaWdodCBiZSB1c2VmdWwgdG8gY2xlYXIgdGhlXHJcbiAgICAgKiBjYWNoZSBpZiB5b3UgaGF2ZSBjaGFuZ2VkIHN0YXRlIHdoaWNoIHdpbGwgYWZmZWN0IHJlbmRlcmluZy4gIEZvciBleGFtcGxlLCBpZiB5b3UgaW52b2tlXHJcbiAgICAgKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Nyb3NzZmlsdGVyL2Nyb3NzZmlsdGVyL3dpa2kvQVBJLVJlZmVyZW5jZSNjcm9zc2ZpbHRlcl9hZGQgY3Jvc3NmaWx0ZXIuYWRkfVxyXG4gICAgICogZnVuY3Rpb24gb3IgcmVzZXQgZ3JvdXAgb3IgZGltZW5zaW9uIGFmdGVyIHJlbmRlcmluZywgaXQgaXMgYSBnb29kIGlkZWEgdG9cclxuICAgICAqIGNsZWFyIHRoZSBjYWNoZSB0byBtYWtlIHN1cmUgY2hhcnRzIGFyZSByZW5kZXJlZCBwcm9wZXJseS5cclxuICAgICAqIEBtZXRob2QgZXhwaXJlQ2FjaGVcclxuICAgICAqIEBtZW1iZXJvZiBkYy5iYXNlTWl4aW5cclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHJldHVybnMge2RjLmJhc2VNaXhpbn1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LmV4cGlyZUNhY2hlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIGRvIG5vdGhpbmcgaW4gYmFzZSwgc2hvdWxkIGJlIG92ZXJyaWRkZW4gYnkgc3ViLWZ1bmN0aW9uXHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBdHRhY2ggYSBkYy5sZWdlbmQgd2lkZ2V0IHRvIHRoaXMgY2hhcnQuIFRoZSBsZWdlbmQgd2lkZ2V0IHdpbGwgYXV0b21hdGljYWxseSBkcmF3IGxlZ2VuZCBsYWJlbHNcclxuICAgICAqIGJhc2VkIG9uIHRoZSBjb2xvciBzZXR0aW5nIGFuZCBuYW1lcyBhc3NvY2lhdGVkIHdpdGggZWFjaCBncm91cC5cclxuICAgICAqIEBtZXRob2QgbGVnZW5kXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuYmFzZU1peGluXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBjaGFydC5sZWdlbmQoZGMubGVnZW5kKCkueCg0MDApLnkoMTApLml0ZW1IZWlnaHQoMTMpLmdhcCg1KSlcclxuICAgICAqIEBwYXJhbSB7ZGMubGVnZW5kfSBbbGVnZW5kXVxyXG4gICAgICogQHJldHVybnMge2RjLmxlZ2VuZHxkYy5iYXNlTWl4aW59XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5sZWdlbmQgPSBmdW5jdGlvbiAobGVnZW5kKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfbGVnZW5kO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfbGVnZW5kID0gbGVnZW5kO1xyXG4gICAgICAgIF9sZWdlbmQucGFyZW50KF9jaGFydCk7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBpbnRlcm5hbCBudW1lcmljIElEIG9mIHRoZSBjaGFydC5cclxuICAgICAqIEBtZXRob2QgY2hhcnRJRFxyXG4gICAgICogQG1lbWJlcm9mIGRjLmJhc2VNaXhpblxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQuY2hhcnRJRCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0Ll9fZGNGbGFnX187XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGNoYXJ0IG9wdGlvbnMgdXNpbmcgYSBjb25maWd1cmF0aW9uIG9iamVjdC4gRWFjaCBrZXkgaW4gdGhlIG9iamVjdCB3aWxsIGNhdXNlIHRoZSBtZXRob2Qgb2ZcclxuICAgICAqIHRoZSBzYW1lIG5hbWUgdG8gYmUgY2FsbGVkIHdpdGggdGhlIHZhbHVlIHRvIHNldCB0aGF0IGF0dHJpYnV0ZSBmb3IgdGhlIGNoYXJ0LlxyXG4gICAgICogQG1ldGhvZCBvcHRpb25zXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuYmFzZU1peGluXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBjaGFydC5vcHRpb25zKHtkaW1lbnNpb246IG15RGltZW5zaW9uLCBncm91cDogbXlHcm91cH0pO1xyXG4gICAgICogQHBhcmFtIHt7fX0gb3B0c1xyXG4gICAgICogQHJldHVybnMge2RjLmJhc2VNaXhpbn1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0Lm9wdGlvbnMgPSBmdW5jdGlvbiAob3B0cykge1xyXG4gICAgICAgIHZhciBhcHBseU9wdGlvbnMgPSBbXHJcbiAgICAgICAgICAgICdhbmNob3InLFxyXG4gICAgICAgICAgICAnZ3JvdXAnLFxyXG4gICAgICAgICAgICAneEF4aXNMYWJlbCcsXHJcbiAgICAgICAgICAgICd5QXhpc0xhYmVsJyxcclxuICAgICAgICAgICAgJ3N0YWNrJyxcclxuICAgICAgICAgICAgJ3RpdGxlJyxcclxuICAgICAgICAgICAgJ3BvaW50JyxcclxuICAgICAgICAgICAgJ2dldENvbG9yJyxcclxuICAgICAgICAgICAgJ292ZXJsYXlHZW9Kc29uJ1xyXG4gICAgICAgIF07XHJcblxyXG4gICAgICAgIGZvciAodmFyIG8gaW4gb3B0cykge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mKF9jaGFydFtvXSkgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvcHRzW29dIGluc3RhbmNlb2YgQXJyYXkgJiYgYXBwbHlPcHRpb25zLmluZGV4T2YobykgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2NoYXJ0W29dLmFwcGx5KF9jaGFydCwgb3B0c1tvXSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIF9jaGFydFtvXS5jYWxsKF9jaGFydCwgb3B0c1tvXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkYy5sb2dnZXIuZGVidWcoJ05vdCBhIHZhbGlkIG9wdGlvbiBzZXR0ZXIgbmFtZTogJyArIG8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWxsIGRjIGNoYXJ0IGluc3RhbmNlIHN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgbGlzdGVuZXJzLlxyXG4gICAgICogU3VwcG9ydHMgdGhlIGZvbGxvd2luZyBldmVudHM6XHJcbiAgICAgKiAqIGByZW5kZXJsZXRgIC0gVGhpcyBsaXN0ZW5lciBmdW5jdGlvbiB3aWxsIGJlIGludm9rZWQgYWZ0ZXIgdHJhbnNpdGlvbnMgYWZ0ZXIgcmVkcmF3IGFuZCByZW5kZXIuIFJlcGxhY2VzIHRoZVxyXG4gICAgICogZGVwcmVjYXRlZCB7QGxpbmsgZGMuYmFzZU1peGluI3JlbmRlcmxldCByZW5kZXJsZXR9IG1ldGhvZC5cclxuICAgICAqICogYHByZXRyYW5zaXRpb25gIC0gTGlrZSBgLm9uKCdyZW5kZXJsZXQnLCAuLi4pYCBidXQgdGhlIGV2ZW50IGlzIGZpcmVkIGJlZm9yZSB0cmFuc2l0aW9ucyBzdGFydC5cclxuICAgICAqICogYHByZVJlbmRlcmAgLSBUaGlzIGxpc3RlbmVyIGZ1bmN0aW9uIHdpbGwgYmUgaW52b2tlZCBiZWZvcmUgY2hhcnQgcmVuZGVyaW5nLlxyXG4gICAgICogKiBgcG9zdFJlbmRlcmAgLSBUaGlzIGxpc3RlbmVyIGZ1bmN0aW9uIHdpbGwgYmUgaW52b2tlZCBhZnRlciBjaGFydCBmaW5pc2ggcmVuZGVyaW5nIGluY2x1ZGluZ1xyXG4gICAgICogYWxsIHJlbmRlcmxldHMnIGxvZ2ljLlxyXG4gICAgICogKiBgcHJlUmVkcmF3YCAtIFRoaXMgbGlzdGVuZXIgZnVuY3Rpb24gd2lsbCBiZSBpbnZva2VkIGJlZm9yZSBjaGFydCByZWRyYXdpbmcuXHJcbiAgICAgKiAqIGBwb3N0UmVkcmF3YCAtIFRoaXMgbGlzdGVuZXIgZnVuY3Rpb24gd2lsbCBiZSBpbnZva2VkIGFmdGVyIGNoYXJ0IGZpbmlzaCByZWRyYXdpbmdcclxuICAgICAqIGluY2x1ZGluZyBhbGwgcmVuZGVybGV0cycgbG9naWMuXHJcbiAgICAgKiAqIGBmaWx0ZXJlZGAgLSBUaGlzIGxpc3RlbmVyIGZ1bmN0aW9uIHdpbGwgYmUgaW52b2tlZCBhZnRlciBhIGZpbHRlciBpcyBhcHBsaWVkLCBhZGRlZCBvciByZW1vdmVkLlxyXG4gICAgICogKiBgem9vbWVkYCAtIFRoaXMgbGlzdGVuZXIgZnVuY3Rpb24gd2lsbCBiZSBpbnZva2VkIGFmdGVyIGEgem9vbSBpcyB0cmlnZ2VyZWQuXHJcbiAgICAgKiBAbWV0aG9kIG9uXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuYmFzZU1peGluXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1kaXNwYXRjaC9ibG9iL21hc3Rlci9SRUFETUUubWQjZGlzcGF0Y2hfb24gZDMuZGlzcGF0Y2gub259XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLm9uKCdyZW5kZXJsZXQnLCBmdW5jdGlvbihjaGFydCwgZmlsdGVyKXsuLi59KVxyXG4gICAgICogLm9uKCdwcmV0cmFuc2l0aW9uJywgZnVuY3Rpb24oY2hhcnQsIGZpbHRlcil7Li4ufSlcclxuICAgICAqIC5vbigncHJlUmVuZGVyJywgZnVuY3Rpb24oY2hhcnQpey4uLn0pXHJcbiAgICAgKiAub24oJ3Bvc3RSZW5kZXInLCBmdW5jdGlvbihjaGFydCl7Li4ufSlcclxuICAgICAqIC5vbigncHJlUmVkcmF3JywgZnVuY3Rpb24oY2hhcnQpey4uLn0pXHJcbiAgICAgKiAub24oJ3Bvc3RSZWRyYXcnLCBmdW5jdGlvbihjaGFydCl7Li4ufSlcclxuICAgICAqIC5vbignZmlsdGVyZWQnLCBmdW5jdGlvbihjaGFydCwgZmlsdGVyKXsuLi59KVxyXG4gICAgICogLm9uKCd6b29tZWQnLCBmdW5jdGlvbihjaGFydCwgZmlsdGVyKXsuLi59KVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lclxyXG4gICAgICogQHJldHVybnMge2RjLmJhc2VNaXhpbn1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0Lm9uID0gZnVuY3Rpb24gKGV2ZW50LCBsaXN0ZW5lcikge1xyXG4gICAgICAgIF9saXN0ZW5lcnMub24oZXZlbnQsIGxpc3RlbmVyKTtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gX2NoYXJ0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1hcmdpbiBpcyBhIG1peGluIHRoYXQgcHJvdmlkZXMgbWFyZ2luIHV0aWxpdHkgZnVuY3Rpb25zIGZvciBib3RoIHRoZSBSb3cgQ2hhcnQgYW5kIENvb3JkaW5hdGUgR3JpZFxyXG4gKiBDaGFydHMuXHJcbiAqIEBuYW1lIG1hcmdpbk1peGluXHJcbiAqIEBtZW1iZXJvZiBkY1xyXG4gKiBAbWl4aW5cclxuICogQHBhcmFtIHtPYmplY3R9IF9jaGFydFxyXG4gKiBAcmV0dXJucyB7ZGMubWFyZ2luTWl4aW59XHJcbiAqL1xyXG5kYy5tYXJnaW5NaXhpbiA9IGZ1bmN0aW9uIChfY2hhcnQpIHtcclxuICAgIHZhciBfbWFyZ2luID0ge3RvcDogMTAsIHJpZ2h0OiA1MCwgYm90dG9tOiAzMCwgbGVmdDogMzB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IG9yIHNldCB0aGUgbWFyZ2lucyBmb3IgYSBwYXJ0aWN1bGFyIGNvb3JkaW5hdGUgZ3JpZCBjaGFydCBpbnN0YW5jZS4gVGhlIG1hcmdpbnMgaXMgc3RvcmVkIGFzXHJcbiAgICAgKiBhbiBhc3NvY2lhdGl2ZSBKYXZhc2NyaXB0IGFycmF5LlxyXG4gICAgICogQG1ldGhvZCBtYXJnaW5zXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMubWFyZ2luTWl4aW5cclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIHZhciBsZWZ0TWFyZ2luID0gY2hhcnQubWFyZ2lucygpLmxlZnQ7IC8vIDMwIGJ5IGRlZmF1bHRcclxuICAgICAqIGNoYXJ0Lm1hcmdpbnMoKS5sZWZ0ID0gNTA7XHJcbiAgICAgKiBsZWZ0TWFyZ2luID0gY2hhcnQubWFyZ2lucygpLmxlZnQ7IC8vIG5vdyA1MFxyXG4gICAgICogQHBhcmFtIHt7dG9wOiBOdW1iZXIsIHJpZ2h0OiBOdW1iZXIsIGxlZnQ6IE51bWJlciwgYm90dG9tOiBOdW1iZXJ9fSBbbWFyZ2lucz17dG9wOiAxMCwgcmlnaHQ6IDUwLCBib3R0b206IDMwLCBsZWZ0OiAzMH1dXHJcbiAgICAgKiBAcmV0dXJucyB7e3RvcDogTnVtYmVyLCByaWdodDogTnVtYmVyLCBsZWZ0OiBOdW1iZXIsIGJvdHRvbTogTnVtYmVyfXxkYy5tYXJnaW5NaXhpbn1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0Lm1hcmdpbnMgPSBmdW5jdGlvbiAobWFyZ2lucykge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX21hcmdpbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgX21hcmdpbiA9IG1hcmdpbnM7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgX2NoYXJ0LmVmZmVjdGl2ZVdpZHRoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQud2lkdGgoKSAtIF9jaGFydC5tYXJnaW5zKCkubGVmdCAtIF9jaGFydC5tYXJnaW5zKCkucmlnaHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF9jaGFydC5lZmZlY3RpdmVIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydC5oZWlnaHQoKSAtIF9jaGFydC5tYXJnaW5zKCkudG9wIC0gX2NoYXJ0Lm1hcmdpbnMoKS5ib3R0b207XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBfY2hhcnQ7XHJcbn07XHJcblxyXG4vKipcclxuICogVGhlIENvbG9yIE1peGluIGlzIGFuIGFic3RyYWN0IGNoYXJ0IGZ1bmN0aW9uYWwgY2xhc3MgcHJvdmlkaW5nIHVuaXZlcnNhbCBjb2xvcmluZyBzdXBwb3J0XHJcbiAqIGFzIGEgbWl4LWluIGZvciBhbnkgY29uY3JldGUgY2hhcnQgaW1wbGVtZW50YXRpb24uXHJcbiAqIEBuYW1lIGNvbG9yTWl4aW5cclxuICogQG1lbWJlcm9mIGRjXHJcbiAqIEBtaXhpblxyXG4gKiBAcGFyYW0ge09iamVjdH0gX2NoYXJ0XHJcbiAqIEByZXR1cm5zIHtkYy5jb2xvck1peGlufVxyXG4gKi9cclxuZGMuY29sb3JNaXhpbiA9IGZ1bmN0aW9uIChfY2hhcnQpIHtcclxuICAgIHZhciBfY29sb3JzID0gZDMuc2NhbGVPcmRpbmFsKGRjLmNvbmZpZy5kZWZhdWx0Q29sb3JzKCkpO1xyXG4gICAgdmFyIF9kZWZhdWx0QWNjZXNzb3IgPSB0cnVlO1xyXG5cclxuICAgIHZhciBfY29sb3JBY2Nlc3NvciA9IGZ1bmN0aW9uIChkKSB7IHJldHVybiBfY2hhcnQua2V5QWNjZXNzb3IoKShkKTsgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlIGN1cnJlbnQgY29sb3Igc2NhbGUgb3Igc2V0IGEgbmV3IGNvbG9yIHNjYWxlLiBUaGlzIG1ldGhvZHMgYWNjZXB0cyBhbnkgZnVuY3Rpb24gdGhhdFxyXG4gICAgICogb3BlcmF0ZXMgbGlrZSBhIGQzIHNjYWxlLlxyXG4gICAgICogQG1ldGhvZCBjb2xvcnNcclxuICAgICAqIEBtZW1iZXJvZiBkYy5jb2xvck1peGluXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1zY2FsZS9ibG9iL21hc3Rlci9SRUFETUUubWQgZDMuc2NhbGV9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gYWx0ZXJuYXRlIGNhdGVnb3JpY2FsIHNjYWxlXHJcbiAgICAgKiBjaGFydC5jb2xvcnMoZDMuc2NhbGUuY2F0ZWdvcnkyMGIoKSk7XHJcbiAgICAgKiAvLyBvcmRpbmFsIHNjYWxlXHJcbiAgICAgKiBjaGFydC5jb2xvcnMoZDMuc2NhbGVPcmRpbmFsKCkucmFuZ2UoWydyZWQnLCdncmVlbicsJ2JsdWUnXSkpO1xyXG4gICAgICogLy8gY29udmVuaWVuY2UgbWV0aG9kLCB0aGUgc2FtZSBhcyBhYm92ZVxyXG4gICAgICogY2hhcnQub3JkaW5hbENvbG9ycyhbJ3JlZCcsJ2dyZWVuJywnYmx1ZSddKTtcclxuICAgICAqIC8vIHNldCBhIGxpbmVhciBzY2FsZVxyXG4gICAgICogY2hhcnQubGluZWFyQ29sb3JzKFtcIiM0NTc1YjRcIiwgXCIjZmZmZmJmXCIsIFwiI2E1MDAyNlwiXSk7XHJcbiAgICAgKiBAcGFyYW0ge2QzLnNjYWxlfSBbY29sb3JTY2FsZT1kMy5zY2FsZU9yZGluYWwoZDMuc2NoZW1lQ2F0ZWdvcnkyMGMpXVxyXG4gICAgICogQHJldHVybnMge2QzLnNjYWxlfGRjLmNvbG9yTWl4aW59XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5jb2xvcnMgPSBmdW5jdGlvbiAoY29sb3JTY2FsZSkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2NvbG9ycztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbG9yU2NhbGUgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAgICAgICBfY29sb3JzID0gZDMuc2NhbGVRdWFudGl6ZSgpLnJhbmdlKGNvbG9yU2NhbGUpOyAvLyBkZXByZWNhdGVkIGxlZ2FjeSBzdXBwb3J0LCBub3RlOiB0aGlzIGZhaWxzIGZvciBvcmRpbmFsIGRvbWFpbnNcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBfY29sb3JzID0gdHlwZW9mIGNvbG9yU2NhbGUgPT09ICdmdW5jdGlvbicgPyBjb2xvclNjYWxlIDogZGMudXRpbHMuY29uc3RhbnQoY29sb3JTY2FsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVuaWVuY2UgbWV0aG9kIHRvIHNldCB0aGUgY29sb3Igc2NhbGUgdG9cclxuICAgICAqIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2NhbGUvYmxvYi9tYXN0ZXIvUkVBRE1FLm1kI29yZGluYWwtc2NhbGVzIGQzLnNjYWxlT3JkaW5hbH0gd2l0aFxyXG4gICAgICogcmFuZ2UgYHJgLlxyXG4gICAgICogQG1ldGhvZCBvcmRpbmFsQ29sb3JzXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuY29sb3JNaXhpblxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5PFN0cmluZz59IHJcclxuICAgICAqIEByZXR1cm5zIHtkYy5jb2xvck1peGlufVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQub3JkaW5hbENvbG9ycyA9IGZ1bmN0aW9uIChyKSB7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydC5jb2xvcnMoZDMuc2NhbGVPcmRpbmFsKCkucmFuZ2UocikpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCB0byBzZXQgdGhlIGNvbG9yIHNjYWxlIHRvIGFuIEhjbCBpbnRlcnBvbGF0ZWQgbGluZWFyIHNjYWxlIHdpdGggcmFuZ2UgYHJgLlxyXG4gICAgICogQG1ldGhvZCBsaW5lYXJDb2xvcnNcclxuICAgICAqIEBtZW1iZXJvZiBkYy5jb2xvck1peGluXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gclxyXG4gICAgICogQHJldHVybnMge2RjLmNvbG9yTWl4aW59XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5saW5lYXJDb2xvcnMgPSBmdW5jdGlvbiAocikge1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQuY29sb3JzKGQzLnNjYWxlTGluZWFyKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmFuZ2UocilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuaW50ZXJwb2xhdGUoZDMuaW50ZXJwb2xhdGVIY2wpKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgb3IgdGhlIGdldCBjb2xvciBhY2Nlc3NvciBmdW5jdGlvbi4gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIHVzZWQgdG8gbWFwIGEgZGF0YSBwb2ludCBpbiBhXHJcbiAgICAgKiBjcm9zc2ZpbHRlciBncm91cCB0byBhIGNvbG9yIHZhbHVlIG9uIHRoZSBjb2xvciBzY2FsZS4gVGhlIGRlZmF1bHQgZnVuY3Rpb24gdXNlcyB0aGUga2V5XHJcbiAgICAgKiBhY2Nlc3Nvci5cclxuICAgICAqIEBtZXRob2QgY29sb3JBY2Nlc3NvclxyXG4gICAgICogQG1lbWJlcm9mIGRjLmNvbG9yTWl4aW5cclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGRlZmF1bHQgaW5kZXggYmFzZWQgY29sb3IgYWNjZXNzb3JcclxuICAgICAqIC5jb2xvckFjY2Vzc29yKGZ1bmN0aW9uIChkLCBpKXtyZXR1cm4gaTt9KVxyXG4gICAgICogLy8gY29sb3IgYWNjZXNzb3IgZm9yIGEgbXVsdGktdmFsdWUgY3Jvc3NmaWx0ZXIgcmVkdWN0aW9uXHJcbiAgICAgKiAuY29sb3JBY2Nlc3NvcihmdW5jdGlvbiAoZCl7cmV0dXJuIGQudmFsdWUuYWJzR2Fpbjt9KVxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbG9yQWNjZXNzb3JdXHJcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb258ZGMuY29sb3JNaXhpbn1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LmNvbG9yQWNjZXNzb3IgPSBmdW5jdGlvbiAoY29sb3JBY2Nlc3Nvcikge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2NvbG9yQWNjZXNzb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9jb2xvckFjY2Vzc29yID0gY29sb3JBY2Nlc3NvcjtcclxuICAgICAgICBfZGVmYXVsdEFjY2Vzc29yID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLy8gd2hhdCBpcyB0aGlzP1xyXG4gICAgX2NoYXJ0LmRlZmF1bHRDb2xvckFjY2Vzc29yID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfZGVmYXVsdEFjY2Vzc29yO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBvciBnZXQgdGhlIGN1cnJlbnQgZG9tYWluIGZvciB0aGUgY29sb3IgbWFwcGluZyBmdW5jdGlvbi4gVGhlIGRvbWFpbiBtdXN0IGJlIHN1cHBsaWVkIGFzIGFuXHJcbiAgICAgKiBhcnJheS5cclxuICAgICAqXHJcbiAgICAgKiBOb3RlOiBwcmV2aW91c2x5IHRoaXMgbWV0aG9kIGFjY2VwdGVkIGEgY2FsbGJhY2sgZnVuY3Rpb24uIEluc3RlYWQgeW91IG1heSB1c2UgYSBjdXN0b20gc2NhbGVcclxuICAgICAqIHNldCBieSB7QGxpbmsgZGMuY29sb3JNaXhpbiNjb2xvcnMgLmNvbG9yc30uXHJcbiAgICAgKiBAbWV0aG9kIGNvbG9yRG9tYWluXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuY29sb3JNaXhpblxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5PFN0cmluZz59IFtkb21haW5dXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8U3RyaW5nPnxkYy5jb2xvck1peGlufVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQuY29sb3JEb21haW4gPSBmdW5jdGlvbiAoZG9tYWluKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfY29sb3JzLmRvbWFpbigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfY29sb3JzLmRvbWFpbihkb21haW4pO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBkb21haW4gYnkgZGV0ZXJtaW5pbmcgdGhlIG1pbiBhbmQgbWF4IHZhbHVlcyBhcyByZXRyaWV2ZWQgYnlcclxuICAgICAqIHtAbGluayBkYy5jb2xvck1peGluI2NvbG9yQWNjZXNzb3IgLmNvbG9yQWNjZXNzb3J9IG92ZXIgdGhlIGNoYXJ0J3MgZGF0YXNldC5cclxuICAgICAqIEBtZXRob2QgY2FsY3VsYXRlQ29sb3JEb21haW5cclxuICAgICAqIEBtZW1iZXJvZiBkYy5jb2xvck1peGluXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEByZXR1cm5zIHtkYy5jb2xvck1peGlufVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQuY2FsY3VsYXRlQ29sb3JEb21haW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG5ld0RvbWFpbiA9IFtkMy5taW4oX2NoYXJ0LmRhdGEoKSwgX2NoYXJ0LmNvbG9yQWNjZXNzb3IoKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBkMy5tYXgoX2NoYXJ0LmRhdGEoKSwgX2NoYXJ0LmNvbG9yQWNjZXNzb3IoKSldO1xyXG4gICAgICAgIF9jb2xvcnMuZG9tYWluKG5ld0RvbWFpbik7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGNvbG9yIGZvciB0aGUgZGF0dW0gZCBhbmQgY291bnRlciBpLiBUaGlzIGlzIHVzZWQgaW50ZXJuYWxseSBieSBjaGFydHMgdG8gcmV0cmlldmUgYSBjb2xvci5cclxuICAgICAqIEBtZXRob2QgZ2V0Q29sb3JcclxuICAgICAqIEBtZW1iZXJvZiBkYy5jb2xvck1peGluXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7Kn0gZFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtpXVxyXG4gICAgICogQHJldHVybnMge1N0cmluZ31cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LmdldENvbG9yID0gZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICByZXR1cm4gX2NvbG9ycyhfY29sb3JBY2Nlc3Nvci5jYWxsKHRoaXMsIGQsIGkpKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAqKkRlcHJlY2F0ZWQuKiogR2V0L3NldCB0aGUgY29sb3IgY2FsY3VsYXRvci4gVGhpcyBhY3R1YWxseSByZXBsYWNlcyB0aGVcclxuICAgICAqIHtAbGluayBkYy5jb2xvck1peGluI2dldENvbG9yIGdldENvbG9yfSBtZXRob2QhXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBpcyBub3QgcmVjb21tZW5kZWQsIHNpbmNlIHVzaW5nIGEge0BsaW5rIGRjLmNvbG9yTWl4aW4jY29sb3JBY2Nlc3NvciBjb2xvckFjY2Vzc29yfSBhbmRcclxuICAgICAqIGNvbG9yIHNjYWxlICh7QGxpbmsgZGMuY29sb3JNaXhpbiNjb2xvcnMgLmNvbG9yc30pIGlzIG1vcmUgcG93ZXJmdWwgYW5kIGlkaW9tYXRpYyBkMy5cclxuICAgICAqIEBtZXRob2QgY29sb3JDYWxjdWxhdG9yXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuY29sb3JNaXhpblxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0geyp9IFtjb2xvckNhbGN1bGF0b3JdXHJcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb258ZGMuY29sb3JNaXhpbn1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LmNvbG9yQ2FsY3VsYXRvciA9IGRjLmxvZ2dlci5kZXByZWNhdGUoZnVuY3Rpb24gKGNvbG9yQ2FsY3VsYXRvcikge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2NoYXJ0LmdldENvbG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfY2hhcnQuZ2V0Q29sb3IgPSBjb2xvckNhbGN1bGF0b3I7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH0sICdjb2xvck1peGluLmNvbG9yQ2FsY3VsYXRvciBoYXMgYmVlbiBkZXByZWNhdGVkLiBQbGVhc2UgY29sb3JNaXhpbi5jb2xvcnMgYW5kIGNvbG9yTWl4aW4uY29sb3JBY2Nlc3NvciBpbnN0ZWFkJyk7XHJcblxyXG4gICAgcmV0dXJuIF9jaGFydDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb29yZGluYXRlIEdyaWQgaXMgYW4gYWJzdHJhY3QgYmFzZSBjaGFydCBkZXNpZ25lZCB0byBzdXBwb3J0IGEgbnVtYmVyIG9mIGNvb3JkaW5hdGUgZ3JpZCBiYXNlZFxyXG4gKiBjb25jcmV0ZSBjaGFydCB0eXBlcywgZS5nLiBiYXIgY2hhcnQsIGxpbmUgY2hhcnQsIGFuZCBidWJibGUgY2hhcnQuXHJcbiAqIEBuYW1lIGNvb3JkaW5hdGVHcmlkTWl4aW5cclxuICogQG1lbWJlcm9mIGRjXHJcbiAqIEBtaXhpblxyXG4gKiBAbWl4ZXMgZGMuY29sb3JNaXhpblxyXG4gKiBAbWl4ZXMgZGMubWFyZ2luTWl4aW5cclxuICogQG1peGVzIGRjLmJhc2VNaXhpblxyXG4gKiBAcGFyYW0ge09iamVjdH0gX2NoYXJ0XHJcbiAqIEByZXR1cm5zIHtkYy5jb29yZGluYXRlR3JpZE1peGlufVxyXG4gKi9cclxuZGMuY29vcmRpbmF0ZUdyaWRNaXhpbiA9IGZ1bmN0aW9uIChfY2hhcnQpIHtcclxuICAgIHZhciBHUklEX0xJTkVfQ0xBU1MgPSAnZ3JpZC1saW5lJztcclxuICAgIHZhciBIT1JJWk9OVEFMX0NMQVNTID0gJ2hvcml6b250YWwnO1xyXG4gICAgdmFyIFZFUlRJQ0FMX0NMQVNTID0gJ3ZlcnRpY2FsJztcclxuICAgIHZhciBZX0FYSVNfTEFCRUxfQ0xBU1MgPSAneS1heGlzLWxhYmVsJztcclxuICAgIHZhciBYX0FYSVNfTEFCRUxfQ0xBU1MgPSAneC1heGlzLWxhYmVsJztcclxuICAgIHZhciBDVVNUT01fQlJVU0hfSEFORExFX0NMQVNTID0gJ2N1c3RvbS1icnVzaC1oYW5kbGUnO1xyXG4gICAgdmFyIERFRkFVTFRfQVhJU19MQUJFTF9QQURESU5HID0gMTI7XHJcblxyXG4gICAgX2NoYXJ0ID0gZGMuY29sb3JNaXhpbihkYy5tYXJnaW5NaXhpbihkYy5iYXNlTWl4aW4oX2NoYXJ0KSkpO1xyXG5cclxuICAgIF9jaGFydC5jb2xvcnMoZDMuc2NhbGVPcmRpbmFsKGQzLnNjaGVtZUNhdGVnb3J5MTApKTtcclxuICAgIF9jaGFydC5fbWFuZGF0b3J5QXR0cmlidXRlcygpLnB1c2goJ3gnKTtcclxuICAgIHZhciBfcGFyZW50O1xyXG4gICAgdmFyIF9nO1xyXG4gICAgdmFyIF9jaGFydEJvZHlHO1xyXG5cclxuICAgIHZhciBfeDtcclxuICAgIHZhciBfb3JpZ1g7IC8vIFdpbGwgaG9sZCBvcmdpbmlhbCBzY2FsZSBpbiBjYXNlIG9mIHpvb21cclxuICAgIHZhciBfeE9yaWdpbmFsRG9tYWluO1xyXG4gICAgdmFyIF94QXhpcyA9IGQzLmF4aXNCb3R0b20oKTtcclxuICAgIHZhciBfeFVuaXRzID0gZGMudW5pdHMuaW50ZWdlcnM7XHJcbiAgICB2YXIgX3hBeGlzUGFkZGluZyA9IDA7XHJcbiAgICB2YXIgX3hBeGlzUGFkZGluZ1VuaXQgPSBkMy50aW1lRGF5O1xyXG4gICAgdmFyIF94RWxhc3RpY2l0eSA9IGZhbHNlO1xyXG4gICAgdmFyIF94QXhpc0xhYmVsO1xyXG4gICAgdmFyIF94QXhpc0xhYmVsUGFkZGluZyA9IDA7XHJcbiAgICB2YXIgX2xhc3RYRG9tYWluO1xyXG5cclxuICAgIHZhciBfeTtcclxuICAgIHZhciBfeUF4aXMgPSBudWxsO1xyXG4gICAgdmFyIF95QXhpc1BhZGRpbmcgPSAwO1xyXG4gICAgdmFyIF95RWxhc3RpY2l0eSA9IGZhbHNlO1xyXG4gICAgdmFyIF95QXhpc0xhYmVsO1xyXG4gICAgdmFyIF95QXhpc0xhYmVsUGFkZGluZyA9IDA7XHJcblxyXG4gICAgdmFyIF9icnVzaCA9IGQzLmJydXNoWCgpO1xyXG4gICAgdmFyIF9nQnJ1c2g7XHJcbiAgICB2YXIgX2JydXNoT24gPSB0cnVlO1xyXG4gICAgdmFyIF9wYXJlbnRCcnVzaE9uID0gZmFsc2U7XHJcbiAgICB2YXIgX3JvdW5kO1xyXG5cclxuICAgIHZhciBfcmVuZGVySG9yaXpvbnRhbEdyaWRMaW5lID0gZmFsc2U7XHJcbiAgICB2YXIgX3JlbmRlclZlcnRpY2FsR3JpZExpbmUgPSBmYWxzZTtcclxuXHJcbiAgICB2YXIgX3Jlc2l6aW5nID0gZmFsc2U7XHJcbiAgICB2YXIgX3VuaXRDb3VudDtcclxuXHJcbiAgICB2YXIgX3pvb21TY2FsZSA9IFsxLCBJbmZpbml0eV07XHJcbiAgICB2YXIgX3pvb21PdXRSZXN0cmljdCA9IHRydWU7XHJcblxyXG4gICAgdmFyIF96b29tID0gZDMuem9vbSgpLm9uKCd6b29tJywgb25ab29tKTtcclxuICAgIHZhciBfbnVsbFpvb20gPSBkMy56b29tKCkub24oJ3pvb20nLCBudWxsKTtcclxuICAgIHZhciBfaGFzQmVlbk1vdXNlWm9vbWFibGUgPSBmYWxzZTtcclxuXHJcbiAgICB2YXIgX3JhbmdlQ2hhcnQ7XHJcbiAgICB2YXIgX2ZvY3VzQ2hhcnQ7XHJcblxyXG4gICAgdmFyIF9tb3VzZVpvb21hYmxlID0gZmFsc2U7XHJcbiAgICB2YXIgX2NsaXBQYWRkaW5nID0gMDtcclxuXHJcbiAgICB2YXIgX291dGVyUmFuZ2VCYW5kUGFkZGluZyA9IDAuNTtcclxuICAgIHZhciBfcmFuZ2VCYW5kUGFkZGluZyA9IDA7XHJcblxyXG4gICAgdmFyIF91c2VSaWdodFlBeGlzID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGVuIGNoYW5naW5nIHRoZSBkb21haW4gb2YgdGhlIHggb3IgeSBzY2FsZSwgaXQgaXMgbmVjZXNzYXJ5IHRvIHRlbGwgdGhlIGNoYXJ0IHRvIHJlY2FsY3VsYXRlXHJcbiAgICAgKiBhbmQgcmVkcmF3IHRoZSBheGVzLiAoYC5yZXNjYWxlKClgIGlzIGNhbGxlZCBhdXRvbWF0aWNhbGx5IHdoZW4gdGhlIHggb3IgeSBzY2FsZSBpcyByZXBsYWNlZFxyXG4gICAgICogd2l0aCB7QGxpbmsgZGMuY29vcmRpbmF0ZUdyaWRNaXhpbit4IC54KCl9IG9yIHtAbGluayBkYy5jb29yZGluYXRlR3JpZE1peGluI3kgLnkoKX0sIGFuZCBoYXNcclxuICAgICAqIG5vIGVmZmVjdCBvbiBlbGFzdGljIHNjYWxlcy4pXHJcbiAgICAgKiBAbWV0aG9kIHJlc2NhbGVcclxuICAgICAqIEBtZW1iZXJvZiBkYy5jb29yZGluYXRlR3JpZE1peGluXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEByZXR1cm5zIHtkYy5jb29yZGluYXRlR3JpZE1peGlufVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQucmVzY2FsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfdW5pdENvdW50ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIF9yZXNpemluZyA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgX2NoYXJ0LnJlc2l6aW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfcmVzaXppbmc7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IG9yIHNldCB0aGUgcmFuZ2Ugc2VsZWN0aW9uIGNoYXJ0IGFzc29jaWF0ZWQgd2l0aCB0aGlzIGluc3RhbmNlLiBTZXR0aW5nIHRoZSByYW5nZSBzZWxlY3Rpb25cclxuICAgICAqIGNoYXJ0IHVzaW5nIHRoaXMgZnVuY3Rpb24gd2lsbCBhdXRvbWF0aWNhbGx5IHVwZGF0ZSBpdHMgc2VsZWN0aW9uIGJydXNoIHdoZW4gdGhlIGN1cnJlbnQgY2hhcnRcclxuICAgICAqIHpvb21zIGluLiBJbiByZXR1cm4gdGhlIGdpdmVuIHJhbmdlIGNoYXJ0IHdpbGwgYWxzbyBhdXRvbWF0aWNhbGx5IGF0dGFjaCB0aGlzIGNoYXJ0IGFzIGl0cyBmb2N1c1xyXG4gICAgICogY2hhcnQgaGVuY2Ugem9vbSBpbiB3aGVuIHJhbmdlIGJydXNoIHVwZGF0ZXMuXHJcbiAgICAgKlxyXG4gICAgICogVXN1YWxseSB0aGUgcmFuZ2UgYW5kIGZvY3VzIGNoYXJ0cyB3aWxsIHNoYXJlIGEgZGltZW5zaW9uLiBUaGUgcmFuZ2UgY2hhcnQgd2lsbCBzZXQgdGhlIHpvb21cclxuICAgICAqIGJvdW5kYXJpZXMgZm9yIHRoZSBmb2N1cyBjaGFydCwgc28gaXRzIGRpbWVuc2lvbiB2YWx1ZXMgbXVzdCBiZSBjb21wYXRpYmxlIHdpdGggdGhlIGRvbWFpbiBvZlxyXG4gICAgICogdGhlIGZvY3VzIGNoYXJ0LlxyXG4gICAgICpcclxuICAgICAqIFNlZSB0aGUgW05hc2RhcSAxMDAgSW5kZXhdKGh0dHA6Ly9kYy1qcy5naXRodWIuY29tL2RjLmpzLykgZXhhbXBsZSBmb3IgdGhpcyBlZmZlY3QgaW4gYWN0aW9uLlxyXG4gICAgICogQG1ldGhvZCByYW5nZUNoYXJ0XHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuY29vcmRpbmF0ZUdyaWRNaXhpblxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0ge2RjLmNvb3JkaW5hdGVHcmlkTWl4aW59IFtyYW5nZUNoYXJ0XVxyXG4gICAgICogQHJldHVybnMge2RjLmNvb3JkaW5hdGVHcmlkTWl4aW59XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5yYW5nZUNoYXJ0ID0gZnVuY3Rpb24gKHJhbmdlQ2hhcnQpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9yYW5nZUNoYXJ0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBfcmFuZ2VDaGFydCA9IHJhbmdlQ2hhcnQ7XHJcbiAgICAgICAgX3JhbmdlQ2hhcnQuZm9jdXNDaGFydChfY2hhcnQpO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IG9yIHNldCB0aGUgc2NhbGUgZXh0ZW50IGZvciBtb3VzZSB6b29tcy5cclxuICAgICAqIEBtZXRob2Qgem9vbVNjYWxlXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuY29vcmRpbmF0ZUdyaWRNaXhpblxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5PE51bWJlcnxEYXRlPn0gW2V4dGVudD1bMSwgSW5maW5pdHldXVxyXG4gICAgICogQHJldHVybnMge0FycmF5PE51bWJlcnxEYXRlPnxkYy5jb29yZGluYXRlR3JpZE1peGlufVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQuem9vbVNjYWxlID0gZnVuY3Rpb24gKGV4dGVudCkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3pvb21TY2FsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3pvb21TY2FsZSA9IGV4dGVudDtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBvciBzZXQgdGhlIHpvb20gcmVzdHJpY3Rpb24gZm9yIHRoZSBjaGFydC4gSWYgdHJ1ZSBsaW1pdHMgdGhlIHpvb20gdG8gb3JpZ2lvbmFsIGRvbWFpbiBvZiB0aGUgY2hhcnQuXHJcbiAgICAgKiBAbWV0aG9kIHpvb21PdXRSZXN0cmljdFxyXG4gICAgICogQG1lbWJlcm9mIGRjLmNvb3JkaW5hdGVHcmlkTWl4aW5cclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbem9vbU91dFJlc3RyaWN0PXRydWVdXHJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbnxkYy5jb29yZGluYXRlR3JpZE1peGlufVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQuem9vbU91dFJlc3RyaWN0ID0gZnVuY3Rpb24gKHpvb21PdXRSZXN0cmljdCkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3pvb21PdXRSZXN0cmljdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3pvb21PdXRSZXN0cmljdCA9IHpvb21PdXRSZXN0cmljdDtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICBfY2hhcnQuX2dlbmVyYXRlRyA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcclxuICAgICAgICBpZiAocGFyZW50ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgX3BhcmVudCA9IF9jaGFydC5zdmcoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBfcGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGhyZWYgPSB3aW5kb3cubG9jYXRpb24uaHJlZi5zcGxpdCgnIycpWzBdO1xyXG5cclxuICAgICAgICBfZyA9IF9wYXJlbnQuYXBwZW5kKCdnJyk7XHJcblxyXG4gICAgICAgIF9jaGFydEJvZHlHID0gX2cuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnY2hhcnQtYm9keScpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBfY2hhcnQubWFyZ2lucygpLmxlZnQgKyAnLCAnICsgX2NoYXJ0Lm1hcmdpbnMoKS50b3AgKyAnKScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGlwLXBhdGgnLCAndXJsKCcgKyBocmVmICsgJyMnICsgZ2V0Q2xpcFBhdGhJZCgpICsgJyknKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIF9nO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBvciBzZXQgdGhlIHJvb3QgZyBlbGVtZW50LiBUaGlzIG1ldGhvZCBpcyB1c3VhbGx5IHVzZWQgdG8gcmV0cmlldmUgdGhlIGcgZWxlbWVudCBpbiBvcmRlciB0b1xyXG4gICAgICogb3ZlcmxheSBjdXN0b20gc3ZnIGRyYXdpbmcgcHJvZ3JhbWF0aWNhbGx5LiAqKkNhdXRpb24qKjogVGhlIHJvb3QgZyBlbGVtZW50IGlzIHVzdWFsbHkgZ2VuZXJhdGVkXHJcbiAgICAgKiBieSBkYy5qcyBpbnRlcm5hbHMsIGFuZCByZXNldHRpbmcgaXQgbWlnaHQgcHJvZHVjZSB1bnByZWRpY3RhYmxlIHJlc3VsdC5cclxuICAgICAqIEBtZXRob2QgZ1xyXG4gICAgICogQG1lbWJlcm9mIGRjLmNvb3JkaW5hdGVHcmlkTWl4aW5cclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBbZ0VsZW1lbnRdXHJcbiAgICAgKiBAcmV0dXJucyB7U1ZHRWxlbWVudHxkYy5jb29yZGluYXRlR3JpZE1peGlufVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQuZyA9IGZ1bmN0aW9uIChnRWxlbWVudCkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2c7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9nID0gZ0VsZW1lbnQ7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgb3IgZ2V0IG1vdXNlIHpvb20gY2FwYWJpbGl0eSBmbGFnIChkZWZhdWx0OiBmYWxzZSkuIFdoZW4gdHVybmVkIG9uIHRoZSBjaGFydCB3aWxsIGJlXHJcbiAgICAgKiB6b29tYWJsZSB1c2luZyB0aGUgbW91c2Ugd2hlZWwuIElmIHRoZSByYW5nZSBzZWxlY3RvciBjaGFydCBpcyBhdHRhY2hlZCB6b29taW5nIHdpbGwgYWxzbyB1cGRhdGVcclxuICAgICAqIHRoZSByYW5nZSBzZWxlY3Rpb24gYnJ1c2ggb24gdGhlIGFzc29jaWF0ZWQgcmFuZ2Ugc2VsZWN0b3IgY2hhcnQuXHJcbiAgICAgKiBAbWV0aG9kIG1vdXNlWm9vbWFibGVcclxuICAgICAqIEBtZW1iZXJvZiBkYy5jb29yZGluYXRlR3JpZE1peGluXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21vdXNlWm9vbWFibGU9ZmFsc2VdXHJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbnxkYy5jb29yZGluYXRlR3JpZE1peGlufVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQubW91c2Vab29tYWJsZSA9IGZ1bmN0aW9uIChtb3VzZVpvb21hYmxlKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfbW91c2Vab29tYWJsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX21vdXNlWm9vbWFibGUgPSBtb3VzZVpvb21hYmxlO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmUgdGhlIHN2ZyBncm91cCBmb3IgdGhlIGNoYXJ0IGJvZHkuXHJcbiAgICAgKiBAbWV0aG9kIGNoYXJ0Qm9keUdcclxuICAgICAqIEBtZW1iZXJvZiBkYy5jb29yZGluYXRlR3JpZE1peGluXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gW2NoYXJ0Qm9keUddXHJcbiAgICAgKiBAcmV0dXJucyB7U1ZHRWxlbWVudH1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LmNoYXJ0Qm9keUcgPSBmdW5jdGlvbiAoY2hhcnRCb2R5Rykge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2NoYXJ0Qm9keUc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9jaGFydEJvZHlHID0gY2hhcnRCb2R5RztcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqICoqbWFuZGF0b3J5KipcclxuICAgICAqXHJcbiAgICAgKiBHZXQgb3Igc2V0IHRoZSB4IHNjYWxlLiBUaGUgeCBzY2FsZSBjYW4gYmUgYW55IGQzXHJcbiAgICAgKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNjYWxlL2Jsb2IvbWFzdGVyL1JFQURNRS5tZCBkMy5zY2FsZX0gb3JcclxuICAgICAqIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2NhbGUvYmxvYi9tYXN0ZXIvUkVBRE1FLm1kI29yZGluYWwtc2NhbGVzIG9yZGluYWwgc2NhbGV9XHJcbiAgICAgKiBAbWV0aG9kIHhcclxuICAgICAqIEBtZW1iZXJvZiBkYy5jb29yZGluYXRlR3JpZE1peGluXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1zY2FsZS9ibG9iL21hc3Rlci9SRUFETUUubWQgZDMuc2NhbGV9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gc2V0IHggdG8gYSBsaW5lYXIgc2NhbGVcclxuICAgICAqIGNoYXJ0LngoZDMuc2NhbGVMaW5lYXIoKS5kb21haW4oWy0yNTAwLCAyNTAwXSkpXHJcbiAgICAgKiAvLyBzZXQgeCB0byBhIHRpbWUgc2NhbGUgdG8gZ2VuZXJhdGUgaGlzdG9ncmFtXHJcbiAgICAgKiBjaGFydC54KGQzLnNjYWxlVGltZSgpLmRvbWFpbihbbmV3IERhdGUoMTk4NSwgMCwgMSksIG5ldyBEYXRlKDIwMTIsIDExLCAzMSldKSlcclxuICAgICAqIEBwYXJhbSB7ZDMuc2NhbGV9IFt4U2NhbGVdXHJcbiAgICAgKiBAcmV0dXJucyB7ZDMuc2NhbGV8ZGMuY29vcmRpbmF0ZUdyaWRNaXhpbn1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LnggPSBmdW5jdGlvbiAoeFNjYWxlKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfeDtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3ggPSB4U2NhbGU7XHJcbiAgICAgICAgX3hPcmlnaW5hbERvbWFpbiA9IF94LmRvbWFpbigpO1xyXG4gICAgICAgIF9jaGFydC5yZXNjYWxlKCk7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgX2NoYXJ0LnhPcmlnaW5hbERvbWFpbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX3hPcmlnaW5hbERvbWFpbjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgb3IgZ2V0IHRoZSB4VW5pdHMgZnVuY3Rpb24uIFRoZSBjb29yZGluYXRlIGdyaWQgY2hhcnQgdXNlcyB0aGUgeFVuaXRzIGZ1bmN0aW9uIHRvIGNhbGN1bGF0ZVxyXG4gICAgICogdGhlIG51bWJlciBvZiBkYXRhIHByb2plY3Rpb25zIG9uIHRoZSB4IGF4aXMgc3VjaCBhcyB0aGUgbnVtYmVyIG9mIGJhcnMgZm9yIGEgYmFyIGNoYXJ0IG9yIHRoZVxyXG4gICAgICogbnVtYmVyIG9mIGRvdHMgZm9yIGEgbGluZSBjaGFydC5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGV4cGVjdGVkIHRvIHJldHVybiBhIEphdmFzY3JpcHQgYXJyYXkgb2YgYWxsIGRhdGEgcG9pbnRzIG9uIHRoZSB4IGF4aXMsIG9yXHJcbiAgICAgKiB0aGUgbnVtYmVyIG9mIHBvaW50cyBvbiB0aGUgYXhpcy4gZDMgdGltZSByYW5nZSBmdW5jdGlvbnMgW2QzLnRpbWVEYXlzLCBkMy50aW1lTW9udGhzLCBhbmRcclxuICAgICAqIGQzLnRpbWVZZWFyc10oaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXRpbWUvYmxvYi9tYXN0ZXIvUkVBRE1FLm1kI2ludGVydmFscykgYXJlIGFsbCB2YWxpZFxyXG4gICAgICogeFVuaXRzIGZ1bmN0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBkYy5qcyBhbHNvIHByb3ZpZGVzIGEgZmV3IHVuaXRzIGZ1bmN0aW9uLCBzZWUgdGhlIHtAbGluayBkYy51bml0cyBVbml0cyBOYW1lc3BhY2V9IGZvclxyXG4gICAgICogYSBsaXN0IG9mIGJ1aWx0LWluIHVuaXRzIGZ1bmN0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBOb3RlIHRoYXQgYXMgb2YgZGMuanMgMy4wLCBgZGMudW5pdHMub3JkaW5hbGAgaXMgbm90IGEgcmVhbCBmdW5jdGlvbiwgYmVjYXVzZSBpdCBpcyBub3RcclxuICAgICAqIHBvc3NpYmxlIHRvIGRlZmluZSB0aGlzIGZ1bmN0aW9uIGNvbXBsaWFudCB3aXRoIHRoZSBkMyByYW5nZSBmdW5jdGlvbnMuIEl0IHdhcyBhbHJlYWR5IGFcclxuICAgICAqIG1hZ2ljIHZhbHVlIHdoaWNoIGNhdXNlZCBjaGFydHMgdG8gYmVoYXZlIGRpZmZlcmVudGx5LCBhbmQgbm93IGl0IGlzIGNvbXBsZXRlbHkgc28uXHJcbiAgICAgKiBAbWV0aG9kIHhVbml0c1xyXG4gICAgICogQG1lbWJlcm9mIGRjLmNvb3JkaW5hdGVHcmlkTWl4aW5cclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIHNldCB4IHVuaXRzIHRvIGNvdW50IGRheXNcclxuICAgICAqIGNoYXJ0LnhVbml0cyhkMy50aW1lRGF5cyk7XHJcbiAgICAgKiAvLyBzZXQgeCB1bml0cyB0byBjb3VudCBtb250aHNcclxuICAgICAqIGNoYXJ0LnhVbml0cyhkMy50aW1lTW9udGhzKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBBIGN1c3RvbSB4VW5pdHMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgYXMgbG9uZyBhcyBpdCBmb2xsb3dzIHRoZSBmb2xsb3dpbmcgaW50ZXJmYWNlOlxyXG4gICAgICogLy8gdW5pdHMgaW4gaW50ZWdlclxyXG4gICAgICogZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xyXG4gICAgICogICAgICAvLyBzaW1wbHkgY2FsY3VsYXRlcyBob3cgbWFueSBpbnRlZ2VycyBpbiB0aGUgZG9tYWluXHJcbiAgICAgKiAgICAgIHJldHVybiBNYXRoLmFicyhlbmQgLSBzdGFydCk7XHJcbiAgICAgKiB9XHJcbiAgICAgKlxyXG4gICAgICogLy8gZml4ZWQgdW5pdHNcclxuICAgICAqIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcclxuICAgICAqICAgICAgLy8gYmUgYXdhcmUgdXNpbmcgZml4ZWQgdW5pdHMgd2lsbCBkaXNhYmxlIHRoZSBmb2N1cy96b29tIGFiaWxpdHkgb24gdGhlIGNoYXJ0XHJcbiAgICAgKiAgICAgIHJldHVybiAxMDAwO1xyXG4gICAgICogfVxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3hVbml0cz1kYy51bml0cy5pbnRlZ2Vyc11cclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbnxkYy5jb29yZGluYXRlR3JpZE1peGlufVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQueFVuaXRzID0gZnVuY3Rpb24gKHhVbml0cykge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3hVbml0cztcclxuICAgICAgICB9XHJcbiAgICAgICAgX3hVbml0cyA9IHhVbml0cztcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBvciBnZXQgdGhlIHggYXhpcyB1c2VkIGJ5IGEgcGFydGljdWxhciBjb29yZGluYXRlIGdyaWQgY2hhcnQgaW5zdGFuY2UuIFRoaXMgZnVuY3Rpb24gaXMgbW9zdFxyXG4gICAgICogdXNlZnVsIHdoZW4geCBheGlzIGN1c3RvbWl6YXRpb24gaXMgcmVxdWlyZWQuIFRoZSB4IGF4aXMgaW4gZGMuanMgaXMgYW4gaW5zdGFuY2Ugb2YgYVxyXG4gICAgICoge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1heGlzL2Jsb2IvbWFzdGVyL1JFQURNRS5tZCNheGlzQm90dG9tIGQzIGJvdHRvbSBheGlzIG9iamVjdH07XHJcbiAgICAgKiB0aGVyZWZvcmUgaXQgc3VwcG9ydHMgYW55IHZhbGlkIGQzIGF4aXNCb3R0b20gbWFuaXB1bGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqICoqQ2F1dGlvbioqOiBUaGUgeCBheGlzIGlzIHVzdWFsbHkgZ2VuZXJhdGVkIGludGVybmFsbHkgYnkgZGM7IHJlc2V0dGluZyBpdCBtYXkgY2F1c2VcclxuICAgICAqIHVuZXhwZWN0ZWQgcmVzdWx0cy4gTm90ZSBhbHNvIHRoYXQgd2hlbiB1c2VkIGFzIGEgZ2V0dGVyLCB0aGlzIGZ1bmN0aW9uIGlzIG5vdCBjaGFpbmFibGU6XHJcbiAgICAgKiBpdCByZXR1cm5zIHRoZSBheGlzLCBub3QgdGhlIGNoYXJ0LFxyXG4gICAgICoge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9kYy1qcy9kYy5qcy93aWtpL0ZBUSN3aHktZG9lcy1ldmVyeXRoaW5nLWJyZWFrLWFmdGVyLWEtY2FsbC10by14YXhpcy1vci15YXhpc1xyXG4gICAgICogc28gYXR0ZW1wdGluZyB0byBjYWxsIGNoYXJ0IGZ1bmN0aW9ucyBhZnRlciBjYWxsaW5nIGAueEF4aXMoKWAgd2lsbCBmYWlsfS5cclxuICAgICAqIEBtZXRob2QgeEF4aXNcclxuICAgICAqIEBtZW1iZXJvZiBkYy5jb29yZGluYXRlR3JpZE1peGluXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1heGlzL2Jsb2IvbWFzdGVyL1JFQURNRS5tZCNheGlzQm90dG9tIGQzLmF4aXNCb3R0b219XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gY3VzdG9taXplIHggYXhpcyB0aWNrIGZvcm1hdFxyXG4gICAgICogY2hhcnQueEF4aXMoKS50aWNrRm9ybWF0KGZ1bmN0aW9uKHYpIHtyZXR1cm4gdiArICclJzt9KTtcclxuICAgICAqIC8vIGN1c3RvbWl6ZSB4IGF4aXMgdGljayB2YWx1ZXNcclxuICAgICAqIGNoYXJ0LnhBeGlzKCkudGlja1ZhbHVlcyhbMCwgMTAwLCAyMDAsIDMwMF0pO1xyXG4gICAgICogQHBhcmFtIHtkMy5heGlzfSBbeEF4aXM9ZDMuYXhpc0JvdHRvbSgpXVxyXG4gICAgICogQHJldHVybnMge2QzLmF4aXN8ZGMuY29vcmRpbmF0ZUdyaWRNaXhpbn1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LnhBeGlzID0gZnVuY3Rpb24gKHhBeGlzKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfeEF4aXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF94QXhpcyA9IHhBeGlzO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHVybiBvbi9vZmYgZWxhc3RpYyB4IGF4aXMgYmVoYXZpb3IuIElmIHggYXhpcyBlbGFzdGljaXR5IGlzIHR1cm5lZCBvbiwgdGhlbiB0aGUgZ3JpZCBjaGFydCB3aWxsXHJcbiAgICAgKiBhdHRlbXB0IHRvIHJlY2FsY3VsYXRlIHRoZSB4IGF4aXMgcmFuZ2Ugd2hlbmV2ZXIgYSByZWRyYXcgZXZlbnQgaXMgdHJpZ2dlcmVkLlxyXG4gICAgICogQG1ldGhvZCBlbGFzdGljWFxyXG4gICAgICogQG1lbWJlcm9mIGRjLmNvb3JkaW5hdGVHcmlkTWl4aW5cclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZWxhc3RpY1g9ZmFsc2VdXHJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbnxkYy5jb29yZGluYXRlR3JpZE1peGlufVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQuZWxhc3RpY1ggPSBmdW5jdGlvbiAoZWxhc3RpY1gpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF94RWxhc3RpY2l0eTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3hFbGFzdGljaXR5ID0gZWxhc3RpY1g7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgb3IgZ2V0IHggYXhpcyBwYWRkaW5nIGZvciB0aGUgZWxhc3RpYyB4IGF4aXMuIFRoZSBwYWRkaW5nIHdpbGwgYmUgYWRkZWQgdG8gYm90aCBlbmQgb2YgdGhlIHhcclxuICAgICAqIGF4aXMgaWYgZWxhc3RpY1ggaXMgdHVybmVkIG9uOyBvdGhlcndpc2UgaXQgaXMgaWdub3JlZC5cclxuICAgICAqXHJcbiAgICAgKiBQYWRkaW5nIGNhbiBiZSBhbiBpbnRlZ2VyIG9yIHBlcmNlbnRhZ2UgaW4gc3RyaW5nIChlLmcuICcxMCUnKS4gUGFkZGluZyBjYW4gYmUgYXBwbGllZCB0b1xyXG4gICAgICogbnVtYmVyIG9yIGRhdGUgeCBheGVzLiAgV2hlbiBwYWRkaW5nIGEgZGF0ZSBheGlzLCBhbiBpbnRlZ2VyIHJlcHJlc2VudHMgbnVtYmVyIG9mIHVuaXRzIGJlaW5nIHBhZGRlZFxyXG4gICAgICogYW5kIGEgcGVyY2VudGFnZSBzdHJpbmcgd2lsbCBiZSB0cmVhdGVkIHRoZSBzYW1lIGFzIGFuIGludGVnZXIuIFRoZSB1bml0IHdpbGwgYmUgZGV0ZXJtaW5lZCBieSB0aGVcclxuICAgICAqIHhBeGlzUGFkZGluZ1VuaXQgdmFyaWFibGUuXHJcbiAgICAgKiBAbWV0aG9kIHhBeGlzUGFkZGluZ1xyXG4gICAgICogQG1lbWJlcm9mIGRjLmNvb3JkaW5hdGVHcmlkTWl4aW5cclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBbcGFkZGluZz0wXVxyXG4gICAgICogQHJldHVybnMge051bWJlcnxTdHJpbmd8ZGMuY29vcmRpbmF0ZUdyaWRNaXhpbn1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LnhBeGlzUGFkZGluZyA9IGZ1bmN0aW9uIChwYWRkaW5nKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfeEF4aXNQYWRkaW5nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfeEF4aXNQYWRkaW5nID0gcGFkZGluZztcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBvciBnZXQgeCBheGlzIHBhZGRpbmcgdW5pdCBmb3IgdGhlIGVsYXN0aWMgeCBheGlzLiBUaGUgcGFkZGluZyB1bml0IHdpbGwgZGV0ZXJtaW5lIHdoaWNoIHVuaXQgdG9cclxuICAgICAqIHVzZSB3aGVuIGFwcGx5aW5nIHhBeGlzIHBhZGRpbmcgaWYgZWxhc3RpY1ggaXMgdHVybmVkIG9uIGFuZCBpZiB4LWF4aXMgdXNlcyBhIHRpbWUgZGltZW5zaW9uO1xyXG4gICAgICogb3RoZXJ3aXNlIGl0IGlzIGlnbm9yZWQuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIHBhZGRpbmcgdW5pdCBzaG91bGQgYmUgYVxyXG4gICAgICogW2QzIHRpbWUgaW50ZXJ2YWxdKGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy10aW1lL2Jsb2IvbWFzdGVyL1JFQURNRS5tZCNfaW50ZXJ2YWwpLlxyXG4gICAgICogRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgd2l0aCBkYy5qcyAyLjAsIGl0IGNhbiBhbHNvIGJlIHRoZSBuYW1lIG9mIGEgZDMgdGltZSBpbnRlcnZhbFxyXG4gICAgICogKCdkYXknLCAnaG91cicsIGV0YykuIEF2YWlsYWJsZSBhcmd1bWVudHMgYXJlIHRoZVxyXG4gICAgICogW2QzIHRpbWUgaW50ZXJ2YWxzXShodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtdGltZS9ibG9iL21hc3Rlci9SRUFETUUubWQjaW50ZXJ2YWxzIGQzLnRpbWVJbnRlcnZhbCkuXHJcbiAgICAgKiBAbWV0aG9kIHhBeGlzUGFkZGluZ1VuaXRcclxuICAgICAqIEBtZW1iZXJvZiBkYy5jb29yZGluYXRlR3JpZE1peGluXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbdW5pdD1kMy50aW1lRGF5XVxyXG4gICAgICogQHJldHVybnMge1N0cmluZ3xkYy5jb29yZGluYXRlR3JpZE1peGlufVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQueEF4aXNQYWRkaW5nVW5pdCA9IGZ1bmN0aW9uICh1bml0KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfeEF4aXNQYWRkaW5nVW5pdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3hBeGlzUGFkZGluZ1VuaXQgPSB1bml0O1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHVuaXRzIGRpc3BsYXllZCBvbiB0aGUgeCBheGlzLiBJZiB0aGUgeCBheGlzIGlzIG9yZGluYWwgKGB4VW5pdHNgIGlzXHJcbiAgICAgKiBgZGMudW5pdHMub3JkaW5hbGApLCB0aGlzIGlzIHRoZSBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIGRvbWFpbiBvZiB0aGUgeCBzY2FsZS4gT3RoZXJ3aXNlLCB0aGVcclxuICAgICAqIHggdW5pdCBjb3VudCBpcyBjYWxjdWxhdGVkIHVzaW5nIHRoZSB7QGxpbmsgZGMuY29vcmRpbmF0ZUdyaWRNaXhpbiN4VW5pdHMgeFVuaXRzfSBmdW5jdGlvbi5cclxuICAgICAqIEBtZXRob2QgeFVuaXRDb3VudFxyXG4gICAgICogQG1lbWJlcm9mIGRjLmNvb3JkaW5hdGVHcmlkTWl4aW5cclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHJldHVybnMge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LnhVbml0Q291bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKF91bml0Q291bnQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBpZiAoX2NoYXJ0LmlzT3JkaW5hbCgpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJbiB0aGlzIGNhc2UgaXQgbnVtYmVyIG9mIGl0ZW1zIGluIGRvbWFpblxyXG4gICAgICAgICAgICAgICAgX3VuaXRDb3VudCA9IF9jaGFydC54KCkuZG9tYWluKCkubGVuZ3RoO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgX3VuaXRDb3VudCA9IF9jaGFydC54VW5pdHMoKShfY2hhcnQueCgpLmRvbWFpbigpWzBdLCBfY2hhcnQueCgpLmRvbWFpbigpWzFdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTb21ldGltZXMgeFVuaXRzKCkgbWF5IHJldHVybiBhbiBhcnJheSB3aGlsZSBzb21ldGltZXMgZGlyZWN0bHkgdGhlIGNvdW50XHJcbiAgICAgICAgICAgICAgICBpZiAoX3VuaXRDb3VudCBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3VuaXRDb3VudCA9IF91bml0Q291bnQubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gX3VuaXRDb3VudDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgd2hldGhlciB0aGUgY2hhcnQgc2hvdWxkIGJlIGRyYXduIHdpdGggYSByaWdodCBheGlzIGluc3RlYWQgb2YgYSBsZWZ0IGF4aXMuIFdoZW5cclxuICAgICAqIHVzZWQgd2l0aCBhIGNoYXJ0IGluIGEgY29tcG9zaXRlIGNoYXJ0LCBhbGxvd3MgYm90aCBsZWZ0IGFuZCByaWdodCBZIGF4ZXMgdG8gYmUgc2hvd24gb24gYVxyXG4gICAgICogY2hhcnQuXHJcbiAgICAgKiBAbWV0aG9kIHVzZVJpZ2h0WUF4aXNcclxuICAgICAqIEBtZW1iZXJvZiBkYy5jb29yZGluYXRlR3JpZE1peGluXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3VzZVJpZ2h0WUF4aXM9ZmFsc2VdXHJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbnxkYy5jb29yZGluYXRlR3JpZE1peGlufVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQudXNlUmlnaHRZQXhpcyA9IGZ1bmN0aW9uICh1c2VSaWdodFlBeGlzKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfdXNlUmlnaHRZQXhpcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gd2FybiBpZiB2YWx1ZSBpcyBjaGFuZ2luZyBhZnRlciBfeUF4aXMgd2FzIGNyZWF0ZWRcclxuICAgICAgICBpZiAoX3VzZVJpZ2h0WUF4aXMgIT09IHVzZVJpZ2h0WUF4aXMgJiYgX3lBeGlzKSB7XHJcbiAgICAgICAgICAgIGRjLmxvZ2dlci53YXJuKCdWYWx1ZSBvZiB1c2VSaWdodFlBeGlzIGhhcyBiZWVuIGFsdGVyZWQsIGFmdGVyIHlBeGlzIHdhcyBjcmVhdGVkLiAnICtcclxuICAgICAgICAgICAgICAgICdZb3UgbWlnaHQgZ2V0IHVuZXhwZWN0ZWQgeUF4aXMgYmVoYXZpb3IuICcgK1xyXG4gICAgICAgICAgICAgICAgJ01ha2UgY2FsbHMgdG8gdXNlUmlnaHRZQXhpcyBzb29uZXIgaW4geW91ciBjaGFydCBjcmVhdGlvbiBwcm9jZXNzLicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgX3VzZVJpZ2h0WUF4aXMgPSB1c2VSaWdodFlBeGlzO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBjaGFydCBpcyB1c2luZyBvcmRpbmFsIHhVbml0cyAoe0BsaW5rIGRjLnVuaXRzLm9yZGluYWwgZGMudW5pdHMub3JkaW5hbH0sIG9yIGZhbHNlXHJcbiAgICAgKiBvdGhlcndpc2UuIE1vc3QgY2hhcnRzIGJlaGF2ZSBkaWZmZXJlbnRseSB3aXRoIG9yZGluYWwgZGF0YSBhbmQgdXNlIHRoZSByZXN1bHQgb2YgdGhpcyBtZXRob2QgdG9cclxuICAgICAqIHRyaWdnZXIgdGhlIGFwcHJvcHJpYXRlIGxvZ2ljLlxyXG4gICAgICogQG1ldGhvZCBpc09yZGluYWxcclxuICAgICAqIEBtZW1iZXJvZiBkYy5jb29yZGluYXRlR3JpZE1peGluXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQuaXNPcmRpbmFsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQueFVuaXRzKCkgPT09IGRjLnVuaXRzLm9yZGluYWw7XHJcbiAgICB9O1xyXG5cclxuICAgIF9jaGFydC5fdXNlT3V0ZXJQYWRkaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuXHJcbiAgICBfY2hhcnQuX29yZGluYWxYRG9tYWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBncm91cHMgPSBfY2hhcnQuX2NvbXB1dGVPcmRlcmVkR3JvdXBzKF9jaGFydC5kYXRhKCkpO1xyXG4gICAgICAgIHJldHVybiBncm91cHMubWFwKF9jaGFydC5rZXlBY2Nlc3NvcigpKTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gcHJlcGFyZVhBeGlzIChnLCByZW5kZXIpIHtcclxuICAgICAgICBpZiAoIV9jaGFydC5pc09yZGluYWwoKSkge1xyXG4gICAgICAgICAgICBpZiAoX2NoYXJ0LmVsYXN0aWNYKCkpIHtcclxuICAgICAgICAgICAgICAgIF94LmRvbWFpbihbX2NoYXJ0LnhBeGlzTWluKCksIF9jaGFydC54QXhpc01heCgpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgeyAvLyBfY2hhcnQuaXNPcmRpbmFsKClcclxuICAgICAgICAgICAgLy8gRDN2NCAtIE9yZGluYWwgY2hhcnRzIHdvdWxkIG5lZWQgc2NhbGVCYW5kXHJcbiAgICAgICAgICAgIC8vIGJhbmR3aWR0aCBpcyBhIG1ldGhvZCBpbiBzY2FsZUJhbmRcclxuICAgICAgICAgICAgLy8gKGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1zY2FsZS9ibG9iL21hc3Rlci9SRUFETUUubWQjc2NhbGVCYW5kKVxyXG4gICAgICAgICAgICBpZiAoIV94LmJhbmR3aWR0aCkge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgX3ggaXMgbm90IGEgc2NhbGVCYW5kIGNyZWF0ZSBhIG5ldyBzY2FsZSBhbmRcclxuICAgICAgICAgICAgICAgIC8vIGNvcHkgdGhlIG9yaWdpbmFsIGRvbWFpbiB0byB0aGUgbmV3IHNjYWxlXHJcbiAgICAgICAgICAgICAgICBkYy5sb2dnZXIud2FybignRm9yIGNvbXBhdGliaWxpdHkgd2l0aCBkM3Y0KywgZGMuanMgZDMuMCBvcmRpbmFsIGJhci9saW5lL2J1YmJsZSBjaGFydHMgbmVlZCAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkMy5zY2FsZUJhbmQoKSBmb3IgdGhlIHggc2NhbGUsIGluc3RlYWQgb2YgZDMuc2NhbGVPcmRpbmFsKCkuICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1JlcGxhY2luZyAueCgpIHdpdGggYSBkMy5zY2FsZUJhbmQgd2l0aCB0aGUgc2FtZSBkb21haW4gLSAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdtYWtlIHRoZSBzYW1lIGNoYW5nZSBpbiB5b3VyIGNvZGUgdG8gYXZvaWQgdGhpcyB3YXJuaW5nIScpO1xyXG4gICAgICAgICAgICAgICAgX3ggPSBkMy5zY2FsZUJhbmQoKS5kb21haW4oX3guZG9tYWluKCkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoX2NoYXJ0LmVsYXN0aWNYKCkgfHwgX3guZG9tYWluKCkubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBfeC5kb21haW4oX2NoYXJ0Ll9vcmRpbmFsWERvbWFpbigpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gaGFzIHRoZSBkb21haW4gY2hhbmdlZD9cclxuICAgICAgICB2YXIgeGRvbSA9IF94LmRvbWFpbigpO1xyXG4gICAgICAgIGlmIChyZW5kZXIgfHwgIWRjLnV0aWxzLmFycmF5c0VxdWFsKF9sYXN0WERvbWFpbiwgeGRvbSkpIHtcclxuICAgICAgICAgICAgX2NoYXJ0LnJlc2NhbGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX2xhc3RYRG9tYWluID0geGRvbTtcclxuXHJcbiAgICAgICAgLy8gcGxlYXNlIGNhbid0IHdlIGFsd2F5cyB1c2UgcmFuZ2VCYW5kcyBmb3IgYmFyIGNoYXJ0cz9cclxuICAgICAgICBpZiAoX2NoYXJ0LmlzT3JkaW5hbCgpKSB7XHJcbiAgICAgICAgICAgIF94LnJhbmdlKFswLCBfY2hhcnQueEF4aXNMZW5ndGgoKV0pXHJcbiAgICAgICAgICAgICAgICAucGFkZGluZ0lubmVyKF9yYW5nZUJhbmRQYWRkaW5nKVxyXG4gICAgICAgICAgICAgICAgLnBhZGRpbmdPdXRlcihfY2hhcnQuX3VzZU91dGVyUGFkZGluZygpID8gX291dGVyUmFuZ2VCYW5kUGFkZGluZyA6IDApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIF94LnJhbmdlKFswLCBfY2hhcnQueEF4aXNMZW5ndGgoKV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgX3hBeGlzID0gX3hBeGlzLnNjYWxlKF9jaGFydC54KCkpO1xyXG5cclxuICAgICAgICByZW5kZXJWZXJ0aWNhbEdyaWRMaW5lcyhnKTtcclxuICAgIH1cclxuXHJcbiAgICBfY2hhcnQucmVuZGVyWEF4aXMgPSBmdW5jdGlvbiAoZykge1xyXG4gICAgICAgIHZhciBheGlzWEcgPSBnLnNlbGVjdCgnZy54Jyk7XHJcblxyXG4gICAgICAgIGlmIChheGlzWEcuZW1wdHkoKSkge1xyXG4gICAgICAgICAgICBheGlzWEcgPSBnLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnYXhpcyB4JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBfY2hhcnQubWFyZ2lucygpLmxlZnQgKyAnLCcgKyBfY2hhcnQuX3hBeGlzWSgpICsgJyknKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBheGlzWExhYiA9IGcuc2VsZWN0KCd0ZXh0LicgKyBYX0FYSVNfTEFCRUxfQ0xBU1MpO1xyXG4gICAgICAgIGlmIChheGlzWExhYi5lbXB0eSgpICYmIF9jaGFydC54QXhpc0xhYmVsKCkpIHtcclxuICAgICAgICAgICAgYXhpc1hMYWIgPSBnLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCBYX0FYSVNfTEFCRUxfQ0xBU1MpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgKF9jaGFydC5tYXJnaW5zKCkubGVmdCArIF9jaGFydC54QXhpc0xlbmd0aCgpIC8gMikgKyAnLCcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgKF9jaGFydC5oZWlnaHQoKSAtIF94QXhpc0xhYmVsUGFkZGluZykgKyAnKScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnbWlkZGxlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChfY2hhcnQueEF4aXNMYWJlbCgpICYmIGF4aXNYTGFiLnRleHQoKSAhPT0gX2NoYXJ0LnhBeGlzTGFiZWwoKSkge1xyXG4gICAgICAgICAgICBheGlzWExhYi50ZXh0KF9jaGFydC54QXhpc0xhYmVsKCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZGMudHJhbnNpdGlvbihheGlzWEcsIF9jaGFydC50cmFuc2l0aW9uRHVyYXRpb24oKSwgX2NoYXJ0LnRyYW5zaXRpb25EZWxheSgpKVxyXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgX2NoYXJ0Lm1hcmdpbnMoKS5sZWZ0ICsgJywnICsgX2NoYXJ0Ll94QXhpc1koKSArICcpJylcclxuICAgICAgICAgICAgLmNhbGwoX3hBeGlzKTtcclxuICAgICAgICBkYy50cmFuc2l0aW9uKGF4aXNYTGFiLCBfY2hhcnQudHJhbnNpdGlvbkR1cmF0aW9uKCksIF9jaGFydC50cmFuc2l0aW9uRGVsYXkoKSlcclxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIChfY2hhcnQubWFyZ2lucygpLmxlZnQgKyBfY2hhcnQueEF4aXNMZW5ndGgoKSAvIDIpICsgJywnICtcclxuICAgICAgICAgICAgICAgICAgKF9jaGFydC5oZWlnaHQoKSAtIF94QXhpc0xhYmVsUGFkZGluZykgKyAnKScpO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiByZW5kZXJWZXJ0aWNhbEdyaWRMaW5lcyAoZykge1xyXG4gICAgICAgIHZhciBncmlkTGluZUcgPSBnLnNlbGVjdCgnZy4nICsgVkVSVElDQUxfQ0xBU1MpO1xyXG5cclxuICAgICAgICBpZiAoX3JlbmRlclZlcnRpY2FsR3JpZExpbmUpIHtcclxuICAgICAgICAgICAgaWYgKGdyaWRMaW5lRy5lbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICBncmlkTGluZUcgPSBnLmluc2VydCgnZycsICc6Zmlyc3QtY2hpbGQnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIEdSSURfTElORV9DTEFTUyArICcgJyArIFZFUlRJQ0FMX0NMQVNTKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBfY2hhcnQubWFyZ2lucygpLmxlZnQgKyAnLCcgKyBfY2hhcnQubWFyZ2lucygpLnRvcCArICcpJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciB0aWNrcyA9IF94QXhpcy50aWNrVmFsdWVzKCkgPyBfeEF4aXMudGlja1ZhbHVlcygpIDpcclxuICAgICAgICAgICAgICAgICh0eXBlb2YgX3gudGlja3MgPT09ICdmdW5jdGlvbicgPyBfeC50aWNrcy5hcHBseShfeCwgX3hBeGlzLnRpY2tBcmd1bWVudHMoKSkgOiBfeC5kb21haW4oKSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgbGluZXMgPSBncmlkTGluZUcuc2VsZWN0QWxsKCdsaW5lJylcclxuICAgICAgICAgICAgICAgIC5kYXRhKHRpY2tzKTtcclxuXHJcbiAgICAgICAgICAgIC8vIGVudGVyXHJcbiAgICAgICAgICAgIHZhciBsaW5lc0dFbnRlciA9IGxpbmVzLmVudGVyKClcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3goZCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgX2NoYXJ0Ll94QXhpc1koKSAtIF9jaGFydC5tYXJnaW5zKCkudG9wKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3goZCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgMClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdvcGFjaXR5JywgMCk7XHJcbiAgICAgICAgICAgIGRjLnRyYW5zaXRpb24obGluZXNHRW50ZXIsIF9jaGFydC50cmFuc2l0aW9uRHVyYXRpb24oKSwgX2NoYXJ0LnRyYW5zaXRpb25EZWxheSgpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ29wYWNpdHknLCAxKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHVwZGF0ZVxyXG4gICAgICAgICAgICB2YXIgbGluZXNHRW50ZXJVcGRhdGUgPSBsaW5lc0dFbnRlci5tZXJnZShsaW5lcyk7XHJcbiAgICAgICAgICAgIGRjLnRyYW5zaXRpb24obGluZXNHRW50ZXJVcGRhdGUsIF9jaGFydC50cmFuc2l0aW9uRHVyYXRpb24oKSwgX2NoYXJ0LnRyYW5zaXRpb25EZWxheSgpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3goZCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgX2NoYXJ0Ll94QXhpc1koKSAtIF9jaGFydC5tYXJnaW5zKCkudG9wKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3goZCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgMCk7XHJcblxyXG4gICAgICAgICAgICAvLyBleGl0XHJcbiAgICAgICAgICAgIGxpbmVzLmV4aXQoKS5yZW1vdmUoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBncmlkTGluZUcuc2VsZWN0QWxsKCdsaW5lJykucmVtb3ZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIF9jaGFydC5feEF4aXNZID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAoX2NoYXJ0LmhlaWdodCgpIC0gX2NoYXJ0Lm1hcmdpbnMoKS5ib3R0b20pO1xyXG4gICAgfTtcclxuXHJcbiAgICBfY2hhcnQueEF4aXNMZW5ndGggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydC5lZmZlY3RpdmVXaWR0aCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBvciBnZXQgdGhlIHggYXhpcyBsYWJlbC4gSWYgc2V0dGluZyB0aGUgbGFiZWwsIHlvdSBtYXkgb3B0aW9uYWxseSBpbmNsdWRlIGFkZGl0aW9uYWwgcGFkZGluZyB0b1xyXG4gICAgICogdGhlIG1hcmdpbiB0byBtYWtlIHJvb20gZm9yIHRoZSBsYWJlbC4gQnkgZGVmYXVsdCB0aGUgcGFkZGVkIGlzIHNldCB0byAxMiB0byBhY2NvbW9kYXRlIHRoZSB0ZXh0IGhlaWdodC5cclxuICAgICAqIEBtZXRob2QgeEF4aXNMYWJlbFxyXG4gICAgICogQG1lbWJlcm9mIGRjLmNvb3JkaW5hdGVHcmlkTWl4aW5cclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtsYWJlbFRleHRdXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhZGRpbmc9MTJdXHJcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQueEF4aXNMYWJlbCA9IGZ1bmN0aW9uIChsYWJlbFRleHQsIHBhZGRpbmcpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF94QXhpc0xhYmVsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfeEF4aXNMYWJlbCA9IGxhYmVsVGV4dDtcclxuICAgICAgICBfY2hhcnQubWFyZ2lucygpLmJvdHRvbSAtPSBfeEF4aXNMYWJlbFBhZGRpbmc7XHJcbiAgICAgICAgX3hBeGlzTGFiZWxQYWRkaW5nID0gKHBhZGRpbmcgPT09IHVuZGVmaW5lZCkgPyBERUZBVUxUX0FYSVNfTEFCRUxfUEFERElORyA6IHBhZGRpbmc7XHJcbiAgICAgICAgX2NoYXJ0Lm1hcmdpbnMoKS5ib3R0b20gKz0gX3hBeGlzTGFiZWxQYWRkaW5nO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZVlBeGlzICgpIHtcclxuICAgICAgICByZXR1cm4gX3VzZVJpZ2h0WUF4aXMgPyBkMy5heGlzUmlnaHQoKSA6IGQzLmF4aXNMZWZ0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgX2NoYXJ0Ll9wcmVwYXJlWUF4aXMgPSBmdW5jdGlvbiAoZykge1xyXG4gICAgICAgIGlmIChfeSA9PT0gdW5kZWZpbmVkIHx8IF9jaGFydC5lbGFzdGljWSgpKSB7XHJcbiAgICAgICAgICAgIGlmIChfeSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBfeSA9IGQzLnNjYWxlTGluZWFyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG1pbiA9IF9jaGFydC55QXhpc01pbigpIHx8IDAsXHJcbiAgICAgICAgICAgICAgICBtYXggPSBfY2hhcnQueUF4aXNNYXgoKSB8fCAwO1xyXG4gICAgICAgICAgICBfeS5kb21haW4oW21pbiwgbWF4XSkucmFuZ2VSb3VuZChbX2NoYXJ0LnlBeGlzSGVpZ2h0KCksIDBdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIF95LnJhbmdlKFtfY2hhcnQueUF4aXNIZWlnaHQoKSwgMF0pO1xyXG5cclxuICAgICAgICBpZiAoIV95QXhpcykge1xyXG4gICAgICAgICAgICBfeUF4aXMgPSBjcmVhdGVZQXhpcygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgX3lBeGlzLnNjYWxlKF95KTtcclxuXHJcbiAgICAgICAgX2NoYXJ0Ll9yZW5kZXJIb3Jpem9udGFsR3JpZExpbmVzRm9yQXhpcyhnLCBfeSwgX3lBeGlzKTtcclxuICAgIH07XHJcblxyXG4gICAgX2NoYXJ0LnJlbmRlcllBeGlzTGFiZWwgPSBmdW5jdGlvbiAoYXhpc0NsYXNzLCB0ZXh0LCByb3RhdGlvbiwgbGFiZWxYUG9zaXRpb24pIHtcclxuICAgICAgICBsYWJlbFhQb3NpdGlvbiA9IGxhYmVsWFBvc2l0aW9uIHx8IF95QXhpc0xhYmVsUGFkZGluZztcclxuXHJcbiAgICAgICAgdmFyIGF4aXNZTGFiID0gX2NoYXJ0LmcoKS5zZWxlY3QoJ3RleHQuJyArIFlfQVhJU19MQUJFTF9DTEFTUyArICcuJyArIGF4aXNDbGFzcyArICctbGFiZWwnKTtcclxuICAgICAgICB2YXIgbGFiZWxZUG9zaXRpb24gPSAoX2NoYXJ0Lm1hcmdpbnMoKS50b3AgKyBfY2hhcnQueUF4aXNIZWlnaHQoKSAvIDIpO1xyXG4gICAgICAgIGlmIChheGlzWUxhYi5lbXB0eSgpICYmIHRleHQpIHtcclxuICAgICAgICAgICAgYXhpc1lMYWIgPSBfY2hhcnQuZygpLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbGFiZWxYUG9zaXRpb24gKyAnLCcgKyBsYWJlbFlQb3NpdGlvbiArICcpLHJvdGF0ZSgnICsgcm90YXRpb24gKyAnKScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCBZX0FYSVNfTEFCRUxfQ0xBU1MgKyAnICcgKyBheGlzQ2xhc3MgKyAnLWxhYmVsJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKVxyXG4gICAgICAgICAgICAgICAgLnRleHQodGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0ZXh0ICYmIGF4aXNZTGFiLnRleHQoKSAhPT0gdGV4dCkge1xyXG4gICAgICAgICAgICBheGlzWUxhYi50ZXh0KHRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkYy50cmFuc2l0aW9uKGF4aXNZTGFiLCBfY2hhcnQudHJhbnNpdGlvbkR1cmF0aW9uKCksIF9jaGFydC50cmFuc2l0aW9uRGVsYXkoKSlcclxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIGxhYmVsWFBvc2l0aW9uICsgJywnICsgbGFiZWxZUG9zaXRpb24gKyAnKSxyb3RhdGUoJyArIHJvdGF0aW9uICsgJyknKTtcclxuICAgIH07XHJcblxyXG4gICAgX2NoYXJ0LnJlbmRlcllBeGlzQXQgPSBmdW5jdGlvbiAoYXhpc0NsYXNzLCBheGlzLCBwb3NpdGlvbikge1xyXG4gICAgICAgIHZhciBheGlzWUcgPSBfY2hhcnQuZygpLnNlbGVjdCgnZy4nICsgYXhpc0NsYXNzKTtcclxuICAgICAgICBpZiAoYXhpc1lHLmVtcHR5KCkpIHtcclxuICAgICAgICAgICAgYXhpc1lHID0gX2NoYXJ0LmcoKS5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2F4aXMgJyArIGF4aXNDbGFzcylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBwb3NpdGlvbiArICcsJyArIF9jaGFydC5tYXJnaW5zKCkudG9wICsgJyknKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRjLnRyYW5zaXRpb24oYXhpc1lHLCBfY2hhcnQudHJhbnNpdGlvbkR1cmF0aW9uKCksIF9jaGFydC50cmFuc2l0aW9uRGVsYXkoKSlcclxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIHBvc2l0aW9uICsgJywnICsgX2NoYXJ0Lm1hcmdpbnMoKS50b3AgKyAnKScpXHJcbiAgICAgICAgICAgIC5jYWxsKGF4aXMpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfY2hhcnQucmVuZGVyWUF4aXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGF4aXNQb3NpdGlvbiA9IF91c2VSaWdodFlBeGlzID8gKF9jaGFydC53aWR0aCgpIC0gX2NoYXJ0Lm1hcmdpbnMoKS5yaWdodCkgOiBfY2hhcnQuX3lBeGlzWCgpO1xyXG4gICAgICAgIF9jaGFydC5yZW5kZXJZQXhpc0F0KCd5JywgX3lBeGlzLCBheGlzUG9zaXRpb24pO1xyXG4gICAgICAgIHZhciBsYWJlbFBvc2l0aW9uID0gX3VzZVJpZ2h0WUF4aXMgPyAoX2NoYXJ0LndpZHRoKCkgLSBfeUF4aXNMYWJlbFBhZGRpbmcpIDogX3lBeGlzTGFiZWxQYWRkaW5nO1xyXG4gICAgICAgIHZhciByb3RhdGlvbiA9IF91c2VSaWdodFlBeGlzID8gOTAgOiAtOTA7XHJcbiAgICAgICAgX2NoYXJ0LnJlbmRlcllBeGlzTGFiZWwoJ3knLCBfY2hhcnQueUF4aXNMYWJlbCgpLCByb3RhdGlvbiwgbGFiZWxQb3NpdGlvbik7XHJcbiAgICB9O1xyXG5cclxuICAgIF9jaGFydC5fcmVuZGVySG9yaXpvbnRhbEdyaWRMaW5lc0ZvckF4aXMgPSBmdW5jdGlvbiAoZywgc2NhbGUsIGF4aXMpIHtcclxuICAgICAgICB2YXIgZ3JpZExpbmVHID0gZy5zZWxlY3QoJ2cuJyArIEhPUklaT05UQUxfQ0xBU1MpO1xyXG5cclxuICAgICAgICBpZiAoX3JlbmRlckhvcml6b250YWxHcmlkTGluZSkge1xyXG4gICAgICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLWF4aXMvYmxvYi9tYXN0ZXIvc3JjL2F4aXMuanMjTDQ4XHJcbiAgICAgICAgICAgIHZhciB0aWNrcyA9IGF4aXMudGlja1ZhbHVlcygpID8gYXhpcy50aWNrVmFsdWVzKCkgOlxyXG4gICAgICAgICAgICAgICAgKHNjYWxlLnRpY2tzID8gc2NhbGUudGlja3MuYXBwbHkoc2NhbGUsIGF4aXMudGlja0FyZ3VtZW50cygpKSA6IHNjYWxlLmRvbWFpbigpKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChncmlkTGluZUcuZW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgZ3JpZExpbmVHID0gZy5pbnNlcnQoJ2cnLCAnOmZpcnN0LWNoaWxkJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCBHUklEX0xJTkVfQ0xBU1MgKyAnICcgKyBIT1JJWk9OVEFMX0NMQVNTKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBfY2hhcnQubWFyZ2lucygpLmxlZnQgKyAnLCcgKyBfY2hhcnQubWFyZ2lucygpLnRvcCArICcpJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBsaW5lcyA9IGdyaWRMaW5lRy5zZWxlY3RBbGwoJ2xpbmUnKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEodGlja3MpO1xyXG5cclxuICAgICAgICAgICAgLy8gZW50ZXJcclxuICAgICAgICAgICAgdmFyIGxpbmVzR0VudGVyID0gbGluZXMuZW50ZXIoKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneDEnLCAxKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NhbGUoZCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgX2NoYXJ0LnhBeGlzTGVuZ3RoKCkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneTInLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzY2FsZShkKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuYXR0cignb3BhY2l0eScsIDApO1xyXG4gICAgICAgICAgICBkYy50cmFuc2l0aW9uKGxpbmVzR0VudGVyLCBfY2hhcnQudHJhbnNpdGlvbkR1cmF0aW9uKCksIF9jaGFydC50cmFuc2l0aW9uRGVsYXkoKSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdvcGFjaXR5JywgMSk7XHJcblxyXG4gICAgICAgICAgICAvLyB1cGRhdGVcclxuICAgICAgICAgICAgdmFyIGxpbmVzR0VudGVyVXBkYXRlID0gbGluZXNHRW50ZXIubWVyZ2UobGluZXMpO1xyXG4gICAgICAgICAgICBkYy50cmFuc2l0aW9uKGxpbmVzR0VudGVyVXBkYXRlLCBfY2hhcnQudHJhbnNpdGlvbkR1cmF0aW9uKCksIF9jaGFydC50cmFuc2l0aW9uRGVsYXkoKSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIDEpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneTEnLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzY2FsZShkKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneDInLCBfY2hhcnQueEF4aXNMZW5ndGgoKSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjYWxlKGQpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBleGl0XHJcbiAgICAgICAgICAgIGxpbmVzLmV4aXQoKS5yZW1vdmUoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBncmlkTGluZUcuc2VsZWN0QWxsKCdsaW5lJykucmVtb3ZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfY2hhcnQuX3lBeGlzWCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0LnVzZVJpZ2h0WUF4aXMoKSA/IF9jaGFydC53aWR0aCgpIC0gX2NoYXJ0Lm1hcmdpbnMoKS5yaWdodCA6IF9jaGFydC5tYXJnaW5zKCkubGVmdDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgb3IgZ2V0IHRoZSB5IGF4aXMgbGFiZWwuIElmIHNldHRpbmcgdGhlIGxhYmVsLCB5b3UgbWF5IG9wdGlvbmFsbHkgaW5jbHVkZSBhZGRpdGlvbmFsIHBhZGRpbmdcclxuICAgICAqIHRvIHRoZSBtYXJnaW4gdG8gbWFrZSByb29tIGZvciB0aGUgbGFiZWwuIEJ5IGRlZmF1bHQgdGhlIHBhZGRpbmcgaXMgc2V0IHRvIDEyIHRvIGFjY29tbW9kYXRlIHRoZVxyXG4gICAgICogdGV4dCBoZWlnaHQuXHJcbiAgICAgKiBAbWV0aG9kIHlBeGlzTGFiZWxcclxuICAgICAqIEBtZW1iZXJvZiBkYy5jb29yZGluYXRlR3JpZE1peGluXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbbGFiZWxUZXh0XVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYWRkaW5nPTEyXVxyXG4gICAgICogQHJldHVybnMge1N0cmluZ3xkYy5jb29yZGluYXRlR3JpZE1peGlufVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQueUF4aXNMYWJlbCA9IGZ1bmN0aW9uIChsYWJlbFRleHQsIHBhZGRpbmcpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF95QXhpc0xhYmVsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfeUF4aXNMYWJlbCA9IGxhYmVsVGV4dDtcclxuICAgICAgICBfY2hhcnQubWFyZ2lucygpLmxlZnQgLT0gX3lBeGlzTGFiZWxQYWRkaW5nO1xyXG4gICAgICAgIF95QXhpc0xhYmVsUGFkZGluZyA9IChwYWRkaW5nID09PSB1bmRlZmluZWQpID8gREVGQVVMVF9BWElTX0xBQkVMX1BBRERJTkcgOiBwYWRkaW5nO1xyXG4gICAgICAgIF9jaGFydC5tYXJnaW5zKCkubGVmdCArPSBfeUF4aXNMYWJlbFBhZGRpbmc7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgb3Igc2V0IHRoZSB5IHNjYWxlLiBUaGUgeSBzY2FsZSBpcyB0eXBpY2FsbHkgYXV0b21hdGljYWxseSBkZXRlcm1pbmVkIGJ5IHRoZSBjaGFydCBpbXBsZW1lbnRhdGlvbi5cclxuICAgICAqIEBtZXRob2QgeVxyXG4gICAgICogQG1lbWJlcm9mIGRjLmNvb3JkaW5hdGVHcmlkTWl4aW5cclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNjYWxlL2Jsb2IvbWFzdGVyL1JFQURNRS5tZCBkMy5zY2FsZX1cclxuICAgICAqIEBwYXJhbSB7ZDMuc2NhbGV9IFt5U2NhbGVdXHJcbiAgICAgKiBAcmV0dXJucyB7ZDMuc2NhbGV8ZGMuY29vcmRpbmF0ZUdyaWRNaXhpbn1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LnkgPSBmdW5jdGlvbiAoeVNjYWxlKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfeTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3kgPSB5U2NhbGU7XHJcbiAgICAgICAgX2NoYXJ0LnJlc2NhbGUoKTtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBvciBnZXQgdGhlIHkgYXhpcyB1c2VkIGJ5IHRoZSBjb29yZGluYXRlIGdyaWQgY2hhcnQgaW5zdGFuY2UuIFRoaXMgZnVuY3Rpb24gaXMgbW9zdCB1c2VmdWxcclxuICAgICAqIHdoZW4geSBheGlzIGN1c3RvbWl6YXRpb24gaXMgcmVxdWlyZWQuIERlcGVuZGluZyBvbiBgdXNlUmlnaHRZQXhpc2AgdGhlIHkgYXhpcyBpbiBkYy5qcyBpcyBhbiBpbnN0YW5jZSBvZlxyXG4gICAgICogZWl0aGVyIFtkMy5heGlzTGVmdF0oaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLWF4aXMvYmxvYi9tYXN0ZXIvUkVBRE1FLm1kI2F4aXNMZWZ0KSBvclxyXG4gICAgICogW2QzLmF4aXNSaWdodF0oaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLWF4aXMvYmxvYi9tYXN0ZXIvUkVBRE1FLm1kI2F4aXNSaWdodCk7IHRoZXJlZm9yZSBpdCBzdXBwb3J0cyBhbnlcclxuICAgICAqIHZhbGlkIGQzIGF4aXMgbWFuaXB1bGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqICoqQ2F1dGlvbioqOiBUaGUgeSBheGlzIGlzIHVzdWFsbHkgZ2VuZXJhdGVkIGludGVybmFsbHkgYnkgZGM7IHJlc2V0dGluZyBpdCBtYXkgY2F1c2VcclxuICAgICAqIHVuZXhwZWN0ZWQgcmVzdWx0cy4gIE5vdGUgYWxzbyB0aGF0IHdoZW4gdXNlZCBhcyBhIGdldHRlciwgdGhpcyBmdW5jdGlvbiBpcyBub3QgY2hhaW5hYmxlOiBpdFxyXG4gICAgICogcmV0dXJucyB0aGUgYXhpcywgbm90IHRoZSBjaGFydCxcclxuICAgICAqIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZGMtanMvZGMuanMvd2lraS9GQVEjd2h5LWRvZXMtZXZlcnl0aGluZy1icmVhay1hZnRlci1hLWNhbGwtdG8teGF4aXMtb3IteWF4aXNcclxuICAgICAqIHNvIGF0dGVtcHRpbmcgdG8gY2FsbCBjaGFydCBmdW5jdGlvbnMgYWZ0ZXIgY2FsbGluZyBgLnlBeGlzKClgIHdpbGwgZmFpbH0uXHJcbiAgICAgKiBJbiBhZGRpdGlvbiwgZGVwZW5kaW5nIG9uIHdoZXRoZXIgeW91IGFyZSBnb2luZyB0byB1c2UgdGhlIGF4aXMgb24gbGVmdCBvciByaWdodFxyXG4gICAgICogeW91IG5lZWQgdG8gYXBwcm9wcmlhdGVseSBwYXNzIFtkMy5heGlzTGVmdF0oaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLWF4aXMvYmxvYi9tYXN0ZXIvUkVBRE1FLm1kI2F4aXNMZWZ0KVxyXG4gICAgICogb3IgW2QzLmF4aXNSaWdodF0oaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLWF4aXMvYmxvYi9tYXN0ZXIvUkVBRE1FLm1kI2F4aXNSaWdodClcclxuICAgICAqIEBtZXRob2QgeUF4aXNcclxuICAgICAqIEBtZW1iZXJvZiBkYy5jb29yZGluYXRlR3JpZE1peGluXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1heGlzL2Jsb2IvbWFzdGVyL1JFQURNRS5tZCBkMy5heGlzfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGN1c3RvbWl6ZSB5IGF4aXMgdGljayBmb3JtYXRcclxuICAgICAqIGNoYXJ0LnlBeGlzKCkudGlja0Zvcm1hdChmdW5jdGlvbih2KSB7cmV0dXJuIHYgKyAnJSc7fSk7XHJcbiAgICAgKiAvLyBjdXN0b21pemUgeSBheGlzIHRpY2sgdmFsdWVzXHJcbiAgICAgKiBjaGFydC55QXhpcygpLnRpY2tWYWx1ZXMoWzAsIDEwMCwgMjAwLCAzMDBdKTtcclxuICAgICAqIEBwYXJhbSB7ZDMuYXhpc0xlZnR8ZDMuYXhpc1JpZ2h0fSBbeUF4aXNdXHJcbiAgICAgKiBAcmV0dXJucyB7ZDMuYXhpc0xlZnR8ZDMuYXhpc1JpZ2h0fGRjLmNvb3JkaW5hdGVHcmlkTWl4aW59XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC55QXhpcyA9IGZ1bmN0aW9uICh5QXhpcykge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBpZiAoIV95QXhpcykge1xyXG4gICAgICAgICAgICAgICAgX3lBeGlzID0gY3JlYXRlWUF4aXMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gX3lBeGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfeUF4aXMgPSB5QXhpcztcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFR1cm4gb24vb2ZmIGVsYXN0aWMgeSBheGlzIGJlaGF2aW9yLiBJZiB5IGF4aXMgZWxhc3RpY2l0eSBpcyB0dXJuZWQgb24sIHRoZW4gdGhlIGdyaWQgY2hhcnQgd2lsbFxyXG4gICAgICogYXR0ZW1wdCB0byByZWNhbGN1bGF0ZSB0aGUgeSBheGlzIHJhbmdlIHdoZW5ldmVyIGEgcmVkcmF3IGV2ZW50IGlzIHRyaWdnZXJlZC5cclxuICAgICAqIEBtZXRob2QgZWxhc3RpY1lcclxuICAgICAqIEBtZW1iZXJvZiBkYy5jb29yZGluYXRlR3JpZE1peGluXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2VsYXN0aWNZPWZhbHNlXVxyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW58ZGMuY29vcmRpbmF0ZUdyaWRNaXhpbn1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LmVsYXN0aWNZID0gZnVuY3Rpb24gKGVsYXN0aWNZKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfeUVsYXN0aWNpdHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF95RWxhc3RpY2l0eSA9IGVsYXN0aWNZO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHVybiBvbi9vZmYgaG9yaXpvbnRhbCBncmlkIGxpbmVzLlxyXG4gICAgICogQG1ldGhvZCByZW5kZXJIb3Jpem9udGFsR3JpZExpbmVzXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuY29vcmRpbmF0ZUdyaWRNaXhpblxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtyZW5kZXJIb3Jpem9udGFsR3JpZExpbmVzPWZhbHNlXVxyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW58ZGMuY29vcmRpbmF0ZUdyaWRNaXhpbn1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LnJlbmRlckhvcml6b250YWxHcmlkTGluZXMgPSBmdW5jdGlvbiAocmVuZGVySG9yaXpvbnRhbEdyaWRMaW5lcykge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3JlbmRlckhvcml6b250YWxHcmlkTGluZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3JlbmRlckhvcml6b250YWxHcmlkTGluZSA9IHJlbmRlckhvcml6b250YWxHcmlkTGluZXM7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUdXJuIG9uL29mZiB2ZXJ0aWNhbCBncmlkIGxpbmVzLlxyXG4gICAgICogQG1ldGhvZCByZW5kZXJWZXJ0aWNhbEdyaWRMaW5lc1xyXG4gICAgICogQG1lbWJlcm9mIGRjLmNvb3JkaW5hdGVHcmlkTWl4aW5cclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcmVuZGVyVmVydGljYWxHcmlkTGluZXM9ZmFsc2VdXHJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbnxkYy5jb29yZGluYXRlR3JpZE1peGlufVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQucmVuZGVyVmVydGljYWxHcmlkTGluZXMgPSBmdW5jdGlvbiAocmVuZGVyVmVydGljYWxHcmlkTGluZXMpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9yZW5kZXJWZXJ0aWNhbEdyaWRMaW5lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfcmVuZGVyVmVydGljYWxHcmlkTGluZSA9IHJlbmRlclZlcnRpY2FsR3JpZExpbmVzO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgbWluaW11bSB4IHZhbHVlIHRvIGRpc3BsYXkgaW4gdGhlIGNoYXJ0LiBJbmNsdWRlcyB4QXhpc1BhZGRpbmcgaWYgc2V0LlxyXG4gICAgICogQG1ldGhvZCB4QXhpc01pblxyXG4gICAgICogQG1lbWJlcm9mIGRjLmNvb3JkaW5hdGVHcmlkTWl4aW5cclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC54QXhpc01pbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbWluID0gZDMubWluKF9jaGFydC5kYXRhKCksIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfY2hhcnQua2V5QWNjZXNzb3IoKShlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZGMudXRpbHMuc3VidHJhY3QobWluLCBfeEF4aXNQYWRkaW5nLCBfeEF4aXNQYWRkaW5nVW5pdCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgbWF4aW11bSB4IHZhbHVlIHRvIGRpc3BsYXkgaW4gdGhlIGNoYXJ0LiBJbmNsdWRlcyB4QXhpc1BhZGRpbmcgaWYgc2V0LlxyXG4gICAgICogQG1ldGhvZCB4QXhpc01heFxyXG4gICAgICogQG1lbWJlcm9mIGRjLmNvb3JkaW5hdGVHcmlkTWl4aW5cclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC54QXhpc01heCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbWF4ID0gZDMubWF4KF9jaGFydC5kYXRhKCksIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfY2hhcnQua2V5QWNjZXNzb3IoKShlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZGMudXRpbHMuYWRkKG1heCwgX3hBeGlzUGFkZGluZywgX3hBeGlzUGFkZGluZ1VuaXQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgdGhlIG1pbmltdW0geSB2YWx1ZSB0byBkaXNwbGF5IGluIHRoZSBjaGFydC4gSW5jbHVkZXMgeUF4aXNQYWRkaW5nIGlmIHNldC5cclxuICAgICAqIEBtZXRob2QgeUF4aXNNaW5cclxuICAgICAqIEBtZW1iZXJvZiBkYy5jb29yZGluYXRlR3JpZE1peGluXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQueUF4aXNNaW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG1pbiA9IGQzLm1pbihfY2hhcnQuZGF0YSgpLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2NoYXJ0LnZhbHVlQWNjZXNzb3IoKShlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZGMudXRpbHMuc3VidHJhY3QobWluLCBfeUF4aXNQYWRkaW5nKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBtYXhpbXVtIHkgdmFsdWUgdG8gZGlzcGxheSBpbiB0aGUgY2hhcnQuIEluY2x1ZGVzIHlBeGlzUGFkZGluZyBpZiBzZXQuXHJcbiAgICAgKiBAbWV0aG9kIHlBeGlzTWF4XHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuY29vcmRpbmF0ZUdyaWRNaXhpblxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LnlBeGlzTWF4ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBtYXggPSBkMy5tYXgoX2NoYXJ0LmRhdGEoKSwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9jaGFydC52YWx1ZUFjY2Vzc29yKCkoZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGRjLnV0aWxzLmFkZChtYXgsIF95QXhpc1BhZGRpbmcpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBvciBnZXQgeSBheGlzIHBhZGRpbmcgZm9yIHRoZSBlbGFzdGljIHkgYXhpcy4gVGhlIHBhZGRpbmcgd2lsbCBiZSBhZGRlZCB0byB0aGUgdG9wIGFuZFxyXG4gICAgICogYm90dG9tIG9mIHRoZSB5IGF4aXMgaWYgZWxhc3RpY1kgaXMgdHVybmVkIG9uOyBvdGhlcndpc2UgaXQgaXMgaWdub3JlZC5cclxuICAgICAqXHJcbiAgICAgKiBQYWRkaW5nIGNhbiBiZSBhbiBpbnRlZ2VyIG9yIHBlcmNlbnRhZ2UgaW4gc3RyaW5nIChlLmcuICcxMCUnKS4gUGFkZGluZyBjYW4gYmUgYXBwbGllZCB0b1xyXG4gICAgICogbnVtYmVyIG9yIGRhdGUgYXhlcy4gV2hlbiBwYWRkaW5nIGEgZGF0ZSBheGlzLCBhbiBpbnRlZ2VyIHJlcHJlc2VudHMgbnVtYmVyIG9mIGRheXMgYmVpbmcgcGFkZGVkXHJcbiAgICAgKiBhbmQgYSBwZXJjZW50YWdlIHN0cmluZyB3aWxsIGJlIHRyZWF0ZWQgdGhlIHNhbWUgYXMgYW4gaW50ZWdlci5cclxuICAgICAqIEBtZXRob2QgeUF4aXNQYWRkaW5nXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuY29vcmRpbmF0ZUdyaWRNaXhpblxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IFtwYWRkaW5nPTBdXHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfGRjLmNvb3JkaW5hdGVHcmlkTWl4aW59XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC55QXhpc1BhZGRpbmcgPSBmdW5jdGlvbiAocGFkZGluZykge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3lBeGlzUGFkZGluZztcclxuICAgICAgICB9XHJcbiAgICAgICAgX3lBeGlzUGFkZGluZyA9IHBhZGRpbmc7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgX2NoYXJ0LnlBeGlzSGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQuZWZmZWN0aXZlSGVpZ2h0KCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IG9yIGdldCB0aGUgcm91bmRpbmcgZnVuY3Rpb24gdXNlZCB0byBxdWFudGl6ZSB0aGUgc2VsZWN0aW9uIHdoZW4gYnJ1c2hpbmcgaXMgZW5hYmxlZC5cclxuICAgICAqIEBtZXRob2Qgcm91bmRcclxuICAgICAqIEBtZW1iZXJvZiBkYy5jb29yZGluYXRlR3JpZE1peGluXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBzZXQgeCB1bml0IHJvdW5kIHRvIGJ5IG1vbnRoLCB0aGlzIHdpbGwgbWFrZSBzdXJlIHJhbmdlIHNlbGVjdGlvbiBicnVzaCB3aWxsXHJcbiAgICAgKiAvLyBzZWxlY3Qgd2hvbGUgbW9udGhzXHJcbiAgICAgKiBjaGFydC5yb3VuZChkMy50aW1lTW9udGgucm91bmQpO1xyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3JvdW5kXVxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufGRjLmNvb3JkaW5hdGVHcmlkTWl4aW59XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5yb3VuZCA9IGZ1bmN0aW9uIChyb3VuZCkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3JvdW5kO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfcm91bmQgPSByb3VuZDtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICBfY2hhcnQuX3JhbmdlQmFuZFBhZGRpbmcgPSBmdW5jdGlvbiAoXykge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3JhbmdlQmFuZFBhZGRpbmc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9yYW5nZUJhbmRQYWRkaW5nID0gXztcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICBfY2hhcnQuX291dGVyUmFuZ2VCYW5kUGFkZGluZyA9IGZ1bmN0aW9uIChfKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfb3V0ZXJSYW5nZUJhbmRQYWRkaW5nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfb3V0ZXJSYW5nZUJhbmRQYWRkaW5nID0gXztcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICBkYy5vdmVycmlkZShfY2hhcnQsICdmaWx0ZXInLCBmdW5jdGlvbiAoXykge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2NoYXJ0Ll9maWx0ZXIoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIF9jaGFydC5fZmlsdGVyKF8pO1xyXG5cclxuICAgICAgICBfY2hhcnQucmVkcmF3QnJ1c2goXywgZmFsc2UpO1xyXG5cclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgb3Igc2V0IHRoZSBicnVzaC4gQnJ1c2ggbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBkMyBicnVzaGVzXHJcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtYnJ1c2gvYmxvYi9tYXN0ZXIvUkVBRE1FLm1kXHJcbiAgICAgKiBZb3Ugd2lsbCB1c2UgdGhpcyBvbmx5IGlmIHlvdSBhcmUgd3JpdGluZyBhIG5ldyBjaGFydCB0eXBlIHRoYXQgc3VwcG9ydHMgYnJ1c2hpbmcuXHJcbiAgICAgKlxyXG4gICAgICogKipDYXV0aW9uKio6IGRjIGNyZWF0ZXMgYW5kIG1hbmFnZXMgYnJ1c2hlcyBpbnRlcm5hbGx5LiBHbyB0aHJvdWdoIGFuZCB1bmRlcnN0YW5kIHRoZSBzb3VyY2UgY29kZVxyXG4gICAgICogaWYgeW91IHdhbnQgdG8gcGFzcyBhIG5ldyBicnVzaCBvYmplY3QuIEV2ZW4gaWYgeW91IGFyZSBvbmx5IHVzaW5nIHRoZSBnZXR0ZXIsXHJcbiAgICAgKiB0aGUgYnJ1c2ggb2JqZWN0IG1heSBub3QgYmVoYXZlIHRoZSB3YXkgeW91IGV4cGVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAbWV0aG9kIGJydXNoXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuY29vcmRpbmF0ZUdyaWRNaXhpblxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0ge2QzLmJydXNofSBbX11cclxuICAgICAqIEByZXR1cm5zIHtkMy5icnVzaHxkYy5jb29yZGluYXRlR3JpZE1peGlufVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQuYnJ1c2ggPSBmdW5jdGlvbiAoXykge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2JydXNoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfYnJ1c2ggPSBfO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF9jaGFydC5yZW5kZXJCcnVzaCA9IGZ1bmN0aW9uIChnLCBkb1RyYW5zaXRpb24pIHtcclxuICAgICAgICBpZiAoX2JydXNoT24pIHtcclxuICAgICAgICAgICAgX2JydXNoLm9uKCdzdGFydCBicnVzaCBlbmQnLCBfY2hhcnQuX2JydXNoaW5nKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFRvIHJldHJpZXZlIHNlbGVjdGlvbiB3ZSBuZWVkIF9nQnJ1c2hcclxuICAgICAgICAgICAgX2dCcnVzaCA9IGcuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdicnVzaCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgX2NoYXJ0Lm1hcmdpbnMoKS5sZWZ0ICsgJywnICsgX2NoYXJ0Lm1hcmdpbnMoKS50b3AgKyAnKScpO1xyXG5cclxuICAgICAgICAgICAgX2NoYXJ0LnNldEJydXNoRXh0ZW50cygpO1xyXG5cclxuICAgICAgICAgICAgX2NoYXJ0LmNyZWF0ZUJydXNoSGFuZGxlUGF0aHMoX2dCcnVzaCwgZG9UcmFuc2l0aW9uKTtcclxuXHJcbiAgICAgICAgICAgIF9jaGFydC5yZWRyYXdCcnVzaChfY2hhcnQuZmlsdGVyKCksIGRvVHJhbnNpdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfY2hhcnQuY3JlYXRlQnJ1c2hIYW5kbGVQYXRocyA9IGZ1bmN0aW9uIChnQnJ1c2gpIHtcclxuICAgICAgICB2YXIgYnJ1c2hIYW5kbGVzID0gZ0JydXNoLnNlbGVjdEFsbCgncGF0aC4nICsgQ1VTVE9NX0JSVVNIX0hBTkRMRV9DTEFTUykuZGF0YShbe3R5cGU6ICd3J30sIHt0eXBlOiAnZSd9XSk7XHJcblxyXG4gICAgICAgIGJydXNoSGFuZGxlcyA9IGJydXNoSGFuZGxlc1xyXG4gICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgQ1VTVE9NX0JSVVNIX0hBTkRMRV9DTEFTUylcclxuICAgICAgICAgICAgLm1lcmdlKGJydXNoSGFuZGxlcyk7XHJcblxyXG4gICAgICAgIGJydXNoSGFuZGxlc1xyXG4gICAgICAgICAgICAuYXR0cignZCcsIF9jaGFydC5yZXNpemVIYW5kbGVQYXRoKTtcclxuICAgIH07XHJcblxyXG4gICAgX2NoYXJ0LmV4dGVuZEJydXNoID0gZnVuY3Rpb24gKGJydXNoU2VsZWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKGJydXNoU2VsZWN0aW9uICYmIF9jaGFydC5yb3VuZCgpKSB7XHJcbiAgICAgICAgICAgIGJydXNoU2VsZWN0aW9uWzBdID0gX2NoYXJ0LnJvdW5kKCkoYnJ1c2hTZWxlY3Rpb25bMF0pO1xyXG4gICAgICAgICAgICBicnVzaFNlbGVjdGlvblsxXSA9IF9jaGFydC5yb3VuZCgpKGJydXNoU2VsZWN0aW9uWzFdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJydXNoU2VsZWN0aW9uO1xyXG4gICAgfTtcclxuXHJcbiAgICBfY2hhcnQuYnJ1c2hJc0VtcHR5ID0gZnVuY3Rpb24gKGJydXNoU2VsZWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuICFicnVzaFNlbGVjdGlvbiB8fCBicnVzaFNlbGVjdGlvblsxXSA8PSBicnVzaFNlbGVjdGlvblswXTtcclxuICAgIH07XHJcblxyXG4gICAgX2NoYXJ0Ll9icnVzaGluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBBdm9pZHMgaW5maW5pdGUgcmVjdXJzaW9uIChtdXR1YWwgcmVjdXJzaW9uIGJldHdlZW4gcmFuZ2UgYW5kIGZvY3VzIG9wZXJhdGlvbnMpXHJcbiAgICAgICAgLy8gU291cmNlIEV2ZW50IHdpbGwgYmUgbnVsbCB3aGVuIGJydXNoLm1vdmUgaXMgY2FsbGVkIHByb2dyYW1tYXRpY2FsbHkgKHNlZSBiZWxvdyBhcyB3ZWxsKS5cclxuICAgICAgICBpZiAoIWQzLmV2ZW50LnNvdXJjZUV2ZW50KSB7IHJldHVybjsgfVxyXG5cclxuICAgICAgICAvLyBJZ25vcmUgZXZlbnQgaWYgcmVjdXJzaXZlIGV2ZW50IC0gaS5lLiBub3QgZGlyZWN0bHkgZ2VuZXJhdGVkIGJ5IHVzZXIgYWN0aW9uIChsaWtlIG1vdXNlL3RvdWNoIGV0Yy4pXHJcbiAgICAgICAgLy8gSW4gdGhpcyBjYXNlIHdlIGFyZSBtb3JlIHdvcnJpZWQgYWJvdXQgdGhpcyBoYW5kbGVyIGNhdXNpbmcgYnJ1c2ggbW92ZSBwcm9ncmFtbWF0aWNhbGx5IHdoaWNoIHdpbGxcclxuICAgICAgICAvLyBjYXVzZSB0aGlzIGhhbmRsZXIgdG8gYmUgaW52b2tlZCBhZ2FpbiB3aXRoIGEgbmV3IGQzLmV2ZW50IChhbmQgY3VycmVudCBldmVudCBzZXQgYXMgc291cmNlRXZlbnQpXHJcbiAgICAgICAgLy8gVGhpcyBjaGVjayBhdm9pZHMgcmVjdXJzaXZlIGNhbGxzXHJcbiAgICAgICAgaWYgKGQzLmV2ZW50LnNvdXJjZUV2ZW50LnR5cGUgJiYgWydzdGFydCcsICdicnVzaCcsICdlbmQnXS5pbmRleE9mKGQzLmV2ZW50LnNvdXJjZUV2ZW50LnR5cGUpICE9PSAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgYnJ1c2hTZWxlY3Rpb24gPSBkMy5ldmVudC5zZWxlY3Rpb247XHJcbiAgICAgICAgaWYgKGJydXNoU2VsZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIGJydXNoU2VsZWN0aW9uID0gYnJ1c2hTZWxlY3Rpb24ubWFwKF9jaGFydC54KCkuaW52ZXJ0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGJydXNoU2VsZWN0aW9uID0gX2NoYXJ0LmV4dGVuZEJydXNoKGJydXNoU2VsZWN0aW9uKTtcclxuXHJcbiAgICAgICAgX2NoYXJ0LnJlZHJhd0JydXNoKGJydXNoU2VsZWN0aW9uLCBmYWxzZSk7XHJcblxyXG4gICAgICAgIHZhciByYW5nZWRGaWx0ZXIgPSBfY2hhcnQuYnJ1c2hJc0VtcHR5KGJydXNoU2VsZWN0aW9uKSA/IG51bGwgOiBkYy5maWx0ZXJzLlJhbmdlZEZpbHRlcihicnVzaFNlbGVjdGlvblswXSwgYnJ1c2hTZWxlY3Rpb25bMV0pO1xyXG5cclxuICAgICAgICBkYy5ldmVudHMudHJpZ2dlcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF9jaGFydC5hcHBseUJydXNoU2VsZWN0aW9uKHJhbmdlZEZpbHRlcik7XHJcbiAgICAgICAgfSwgZGMuY29uc3RhbnRzLkVWRU5UX0RFTEFZKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gVGhpcyBjYW4gYmUgb3ZlcnJpZGRlbiBpbiBhIGRlcml2ZWQgY2hhcnQuIEZvciBleGFtcGxlIENvbXBvc2l0ZSBjaGFydCBvdmVycmlkZXMgaXRcclxuICAgIF9jaGFydC5hcHBseUJydXNoU2VsZWN0aW9uID0gZnVuY3Rpb24gKHJhbmdlZEZpbHRlcikge1xyXG4gICAgICAgIF9jaGFydC5yZXBsYWNlRmlsdGVyKHJhbmdlZEZpbHRlcik7XHJcbiAgICAgICAgX2NoYXJ0LnJlZHJhd0dyb3VwKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9jaGFydC5zZXRCcnVzaEV4dGVudHMgPSBmdW5jdGlvbiAoZG9UcmFuc2l0aW9uKSB7XHJcbiAgICAgICAgLy8gU2V0IGJvdW5kYXJpZXMgb2YgdGhlIGJydXNoLCBtdXN0IHNldCBpdCBiZWZvcmUgYXBwbHlpbmcgdG8gX2dCcnVzaFxyXG4gICAgICAgIF9icnVzaC5leHRlbnQoW1swLCAwXSwgW19jaGFydC5lZmZlY3RpdmVXaWR0aCgpLCBfY2hhcnQuZWZmZWN0aXZlSGVpZ2h0KCldXSk7XHJcblxyXG4gICAgICAgIF9nQnJ1c2hcclxuICAgICAgICAgICAgLmNhbGwoX2JydXNoKTtcclxuICAgIH07XHJcblxyXG4gICAgX2NoYXJ0LnJlZHJhd0JydXNoID0gZnVuY3Rpb24gKGJydXNoU2VsZWN0aW9uLCBkb1RyYW5zaXRpb24pIHtcclxuICAgICAgICBpZiAoX2JydXNoT24gJiYgX2dCcnVzaCkge1xyXG4gICAgICAgICAgICBpZiAoX3Jlc2l6aW5nKSB7XHJcbiAgICAgICAgICAgICAgICBfY2hhcnQuc2V0QnJ1c2hFeHRlbnRzKGRvVHJhbnNpdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghYnJ1c2hTZWxlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIF9nQnJ1c2hcclxuICAgICAgICAgICAgICAgICAgICAuY2FsbChfYnJ1c2gubW92ZSwgbnVsbCk7XHJcblxyXG4gICAgICAgICAgICAgICAgX2dCcnVzaC5zZWxlY3RBbGwoJ3BhdGguJyArIENVU1RPTV9CUlVTSF9IQU5ETEVfQ0xBU1MpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2Rpc3BsYXknLCAnbm9uZScpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNjYWxlZFNlbGVjdGlvbiA9IFtfeChicnVzaFNlbGVjdGlvblswXSksIF94KGJydXNoU2VsZWN0aW9uWzFdKV07XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGdCcnVzaCA9XHJcbiAgICAgICAgICAgICAgICAgICAgZGMub3B0aW9uYWxUcmFuc2l0aW9uKGRvVHJhbnNpdGlvbiwgX2NoYXJ0LnRyYW5zaXRpb25EdXJhdGlvbigpLCBfY2hhcnQudHJhbnNpdGlvbkRlbGF5KCkpKF9nQnJ1c2gpO1xyXG5cclxuICAgICAgICAgICAgICAgIGdCcnVzaFxyXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKF9icnVzaC5tb3ZlLCBzY2FsZWRTZWxlY3Rpb24pO1xyXG5cclxuICAgICAgICAgICAgICAgIGdCcnVzaC5zZWxlY3RBbGwoJ3BhdGguJyArIENVU1RPTV9CUlVTSF9IQU5ETEVfQ0xBU1MpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2Rpc3BsYXknLCBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgX3goYnJ1c2hTZWxlY3Rpb25baV0pICsgJywgMCknO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBfY2hhcnQucmVzaXplSGFuZGxlUGF0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgX2NoYXJ0LmZhZGVEZXNlbGVjdGVkQXJlYShicnVzaFNlbGVjdGlvbik7XHJcbiAgICB9O1xyXG5cclxuICAgIF9jaGFydC5mYWRlRGVzZWxlY3RlZEFyZWEgPSBmdW5jdGlvbiAoYnJ1c2hTZWxlY3Rpb24pIHtcclxuICAgICAgICAvLyBkbyBub3RoaW5nLCBzdWItY2hhcnQgc2hvdWxkIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb25cclxuICAgIH07XHJcblxyXG4gICAgLy8gYm9ycm93ZWQgZnJvbSBDcm9zc2ZpbHRlciBleGFtcGxlXHJcbiAgICBfY2hhcnQucmVzaXplSGFuZGxlUGF0aCA9IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgZCA9IGQudHlwZTtcclxuICAgICAgICB2YXIgZSA9ICsoZCA9PT0gJ2UnKSwgeCA9IGUgPyAxIDogLTEsIHkgPSBfY2hhcnQuZWZmZWN0aXZlSGVpZ2h0KCkgLyAzO1xyXG4gICAgICAgIHJldHVybiAnTScgKyAoMC41ICogeCkgKyAnLCcgKyB5ICtcclxuICAgICAgICAgICAgJ0E2LDYgMCAwICcgKyBlICsgJyAnICsgKDYuNSAqIHgpICsgJywnICsgKHkgKyA2KSArXHJcbiAgICAgICAgICAgICdWJyArICgyICogeSAtIDYpICtcclxuICAgICAgICAgICAgJ0E2LDYgMCAwICcgKyBlICsgJyAnICsgKDAuNSAqIHgpICsgJywnICsgKDIgKiB5KSArXHJcbiAgICAgICAgICAgICdaJyArXHJcbiAgICAgICAgICAgICdNJyArICgyLjUgKiB4KSArICcsJyArICh5ICsgOCkgK1xyXG4gICAgICAgICAgICAnVicgKyAoMiAqIHkgLSA4KSArXHJcbiAgICAgICAgICAgICdNJyArICg0LjUgKiB4KSArICcsJyArICh5ICsgOCkgK1xyXG4gICAgICAgICAgICAnVicgKyAoMiAqIHkgLSA4KTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0Q2xpcFBhdGhJZCAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydC5hbmNob3JOYW1lKCkucmVwbGFjZSgvWyAuIz1cXFtcXF1cIl0vZywgJy0nKSArICctY2xpcCc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgb3Igc2V0IHRoZSBwYWRkaW5nIGluIHBpeGVscyBmb3IgdGhlIGNsaXAgcGF0aC4gT25jZSBzZXQgcGFkZGluZyB3aWxsIGJlIGFwcGxpZWQgZXZlbmx5IHRvXHJcbiAgICAgKiB0aGUgdG9wLCBsZWZ0LCByaWdodCwgYW5kIGJvdHRvbSB3aGVuIHRoZSBjbGlwIHBhdGggaXMgZ2VuZXJhdGVkLiBJZiBzZXQgdG8gemVybywgdGhlIGNsaXAgYXJlYVxyXG4gICAgICogd2lsbCBiZSBleGFjdGx5IHRoZSBjaGFydCBib2R5IGFyZWEgbWludXMgdGhlIG1hcmdpbnMuXHJcbiAgICAgKiBAbWV0aG9kIGNsaXBQYWRkaW5nXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuY29vcmRpbmF0ZUdyaWRNaXhpblxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhZGRpbmc9NV1cclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ8ZGMuY29vcmRpbmF0ZUdyaWRNaXhpbn1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LmNsaXBQYWRkaW5nID0gZnVuY3Rpb24gKHBhZGRpbmcpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9jbGlwUGFkZGluZztcclxuICAgICAgICB9XHJcbiAgICAgICAgX2NsaXBQYWRkaW5nID0gcGFkZGluZztcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUNsaXBQYXRoICgpIHtcclxuICAgICAgICB2YXIgZGVmcyA9IGRjLnV0aWxzLmFwcGVuZE9yU2VsZWN0KF9wYXJlbnQsICdkZWZzJyk7XHJcbiAgICAgICAgLy8gY2Fubm90IHNlbGVjdCA8Y2xpcHBhdGg+IGVsZW1lbnRzOyBidWcgaW4gV2ViS2l0LCBtdXN0IHNlbGVjdCBieSBpZFxyXG4gICAgICAgIC8vIGh0dHBzOi8vZ3JvdXBzLmdvb2dsZS5jb20vZm9ydW0vIyF0b3BpYy9kMy1qcy82RXBBelEyZ1U5SVxyXG4gICAgICAgIHZhciBpZCA9IGdldENsaXBQYXRoSWQoKTtcclxuICAgICAgICB2YXIgY2hhcnRCb2R5Q2xpcCA9IGRjLnV0aWxzLmFwcGVuZE9yU2VsZWN0KGRlZnMsICcjJyArIGlkLCAnY2xpcFBhdGgnKS5hdHRyKCdpZCcsIGlkKTtcclxuXHJcbiAgICAgICAgdmFyIHBhZGRpbmcgPSBfY2xpcFBhZGRpbmcgKiAyO1xyXG5cclxuICAgICAgICBkYy51dGlscy5hcHBlbmRPclNlbGVjdChjaGFydEJvZHlDbGlwLCAncmVjdCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIF9jaGFydC54QXhpc0xlbmd0aCgpICsgcGFkZGluZylcclxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIF9jaGFydC55QXhpc0hlaWdodCgpICsgcGFkZGluZylcclxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoLScgKyBfY2xpcFBhZGRpbmcgKyAnLCAtJyArIF9jbGlwUGFkZGluZyArICcpJyk7XHJcbiAgICB9XHJcblxyXG4gICAgX2NoYXJ0Ll9wcmVwcm9jZXNzRGF0YSA9IGZ1bmN0aW9uICgpIHt9O1xyXG5cclxuICAgIF9jaGFydC5fZG9SZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX2NoYXJ0LnJlc2V0U3ZnKCk7XHJcblxyXG4gICAgICAgIF9jaGFydC5fcHJlcHJvY2Vzc0RhdGEoKTtcclxuXHJcbiAgICAgICAgX2NoYXJ0Ll9nZW5lcmF0ZUcoKTtcclxuICAgICAgICBnZW5lcmF0ZUNsaXBQYXRoKCk7XHJcblxyXG4gICAgICAgIGRyYXdDaGFydCh0cnVlKTtcclxuXHJcbiAgICAgICAgY29uZmlndXJlTW91c2Vab29tKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF9jaGFydC5fZG9SZWRyYXcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX2NoYXJ0Ll9wcmVwcm9jZXNzRGF0YSgpO1xyXG5cclxuICAgICAgICBkcmF3Q2hhcnQoZmFsc2UpO1xyXG4gICAgICAgIGdlbmVyYXRlQ2xpcFBhdGgoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd0NoYXJ0IChyZW5kZXIpIHtcclxuICAgICAgICBpZiAoX2NoYXJ0LmlzT3JkaW5hbCgpKSB7XHJcbiAgICAgICAgICAgIF9icnVzaE9uID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcmVwYXJlWEF4aXMoX2NoYXJ0LmcoKSwgcmVuZGVyKTtcclxuICAgICAgICBfY2hhcnQuX3ByZXBhcmVZQXhpcyhfY2hhcnQuZygpKTtcclxuXHJcbiAgICAgICAgX2NoYXJ0LnBsb3REYXRhKCk7XHJcblxyXG4gICAgICAgIGlmIChfY2hhcnQuZWxhc3RpY1goKSB8fCBfcmVzaXppbmcgfHwgcmVuZGVyKSB7XHJcbiAgICAgICAgICAgIF9jaGFydC5yZW5kZXJYQXhpcyhfY2hhcnQuZygpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChfY2hhcnQuZWxhc3RpY1koKSB8fCBfcmVzaXppbmcgfHwgcmVuZGVyKSB7XHJcbiAgICAgICAgICAgIF9jaGFydC5yZW5kZXJZQXhpcyhfY2hhcnQuZygpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChyZW5kZXIpIHtcclxuICAgICAgICAgICAgX2NoYXJ0LnJlbmRlckJydXNoKF9jaGFydC5nKCksIGZhbHNlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBBbmltYXRlIHRoZSBicnVzaCBvbmx5IHdoaWxlIHJlc2l6aW5nXHJcbiAgICAgICAgICAgIF9jaGFydC5yZWRyYXdCcnVzaChfY2hhcnQuZmlsdGVyKCksIF9yZXNpemluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9jaGFydC5mYWRlRGVzZWxlY3RlZEFyZWEoX2NoYXJ0LmZpbHRlcigpKTtcclxuICAgICAgICBfcmVzaXppbmcgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb25maWd1cmVNb3VzZVpvb20gKCkge1xyXG4gICAgICAgIC8vIFNhdmUgYSBjb3B5IG9mIG9yaWdpbmFsIHggc2NhbGVcclxuICAgICAgICBfb3JpZ1ggPSBfeC5jb3B5KCk7XHJcblxyXG4gICAgICAgIGlmIChfbW91c2Vab29tYWJsZSkge1xyXG4gICAgICAgICAgICBfY2hhcnQuX2VuYWJsZU1vdXNlWm9vbSgpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoX2hhc0JlZW5Nb3VzZVpvb21hYmxlKSB7XHJcbiAgICAgICAgICAgIF9jaGFydC5fZGlzYWJsZU1vdXNlWm9vbSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBfY2hhcnQuX2VuYWJsZU1vdXNlWm9vbSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfaGFzQmVlbk1vdXNlWm9vbWFibGUgPSB0cnVlO1xyXG5cclxuICAgICAgICB2YXIgZXh0ZW50ID0gW1swLCAwXSxbX2NoYXJ0LmVmZmVjdGl2ZVdpZHRoKCksIF9jaGFydC5lZmZlY3RpdmVIZWlnaHQoKV1dO1xyXG5cclxuICAgICAgICBfem9vbVxyXG4gICAgICAgICAgICAuc2NhbGVFeHRlbnQoX3pvb21TY2FsZSlcclxuICAgICAgICAgICAgLmV4dGVudChleHRlbnQpXHJcbiAgICAgICAgICAgIC5kdXJhdGlvbihfY2hhcnQudHJhbnNpdGlvbkR1cmF0aW9uKCkpO1xyXG5cclxuICAgICAgICBpZiAoX3pvb21PdXRSZXN0cmljdCkge1xyXG4gICAgICAgICAgICAvLyBFbnN1cmUgbWluaW11bSB6b29tU2NhbGUgaXMgYXQgbGVhc3QgMVxyXG4gICAgICAgICAgICB2YXIgem9vbVNjYWxlTWluID0gTWF0aC5tYXgoX3pvb21TY2FsZVswXSwgMSk7XHJcbiAgICAgICAgICAgIF96b29tXHJcbiAgICAgICAgICAgICAgICAudHJhbnNsYXRlRXh0ZW50KGV4dGVudClcclxuICAgICAgICAgICAgICAgIC5zY2FsZUV4dGVudChbem9vbVNjYWxlTWluLCBfem9vbVNjYWxlWzFdXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBfY2hhcnQucm9vdCgpLmNhbGwoX3pvb20pO1xyXG5cclxuICAgICAgICAvLyBUZWxsIEQzIHpvb20gb3VyIGN1cnJlbnQgem9vbS9wYW4gc3RhdHVzXHJcbiAgICAgICAgdXBkYXRlRDN6b29tVHJhbnNmb3JtKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9jaGFydC5fZGlzYWJsZU1vdXNlWm9vbSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfY2hhcnQucm9vdCgpLmNhbGwoX251bGxab29tKTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gem9vbUhhbmRsZXIgKG5ld0RvbWFpbiwgbm9SYWlzZUV2ZW50cykge1xyXG4gICAgICAgIHZhciBkb21GaWx0ZXI7XHJcblxyXG4gICAgICAgIGlmIChoYXNSYW5nZVNlbGVjdGVkKG5ld0RvbWFpbikpIHtcclxuICAgICAgICAgICAgX2NoYXJ0LngoKS5kb21haW4obmV3RG9tYWluKTtcclxuICAgICAgICAgICAgZG9tRmlsdGVyID0gZGMuZmlsdGVycy5SYW5nZWRGaWx0ZXIobmV3RG9tYWluWzBdLCBuZXdEb21haW5bMV0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIF9jaGFydC54KCkuZG9tYWluKF94T3JpZ2luYWxEb21haW4pO1xyXG4gICAgICAgICAgICBkb21GaWx0ZXIgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgX2NoYXJ0LnJlcGxhY2VGaWx0ZXIoZG9tRmlsdGVyKTtcclxuICAgICAgICBfY2hhcnQucmVzY2FsZSgpO1xyXG4gICAgICAgIF9jaGFydC5yZWRyYXcoKTtcclxuXHJcbiAgICAgICAgaWYgKCFub1JhaXNlRXZlbnRzKSB7XHJcbiAgICAgICAgICAgIGlmIChfcmFuZ2VDaGFydCAmJiAhZGMudXRpbHMuYXJyYXlzRXF1YWwoX2NoYXJ0LmZpbHRlcigpLCBfcmFuZ2VDaGFydC5maWx0ZXIoKSkpIHtcclxuICAgICAgICAgICAgICAgIGRjLmV2ZW50cy50cmlnZ2VyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBfcmFuZ2VDaGFydC5yZXBsYWNlRmlsdGVyKGRvbUZpbHRlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgX3JhbmdlQ2hhcnQucmVkcmF3KCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgX2NoYXJ0Ll9pbnZva2Vab29tZWRMaXN0ZW5lcigpO1xyXG4gICAgICAgICAgICBkYy5ldmVudHMudHJpZ2dlcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfY2hhcnQucmVkcmF3R3JvdXAoKTtcclxuICAgICAgICAgICAgfSwgZGMuY29uc3RhbnRzLkVWRU5UX0RFTEFZKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZXZlbnQudHJhbnNmb3JtLnJlc2NhbGVYKF9vcmlnWCkuZG9tYWluKCkgc2hvdWxkIGdpdmUgYmFjayBuZXdEb21haW5cclxuICAgIGZ1bmN0aW9uIGRvbWFpblRvWm9vbVRyYW5zZm9ybSAobmV3RG9tYWluLCBvcmlnRG9tYWluLCB4U2NhbGUpIHtcclxuICAgICAgICB2YXIgayA9IChvcmlnRG9tYWluWzFdIC0gb3JpZ0RvbWFpblswXSkgLyAobmV3RG9tYWluWzFdIC0gbmV3RG9tYWluWzBdKTtcclxuICAgICAgICB2YXIgeHQgPSAtMSAqIHhTY2FsZShuZXdEb21haW5bMF0pO1xyXG5cclxuICAgICAgICByZXR1cm4gZDMuem9vbUlkZW50aXR5LnNjYWxlKGspLnRyYW5zbGF0ZSh4dCwgMCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgd2UgY2hhbmdpbmcgem9vbSBzdGF0dXMgKGZvciBleGFtcGxlIGJ5IGNhbGxpbmcgZm9jdXMpLCB0ZWxsIEQzIHpvb20gYWJvdXQgaXRcclxuICAgIGZ1bmN0aW9uIHVwZGF0ZUQzem9vbVRyYW5zZm9ybSAoKSB7XHJcbiAgICAgICAgaWYgKF96b29tKSB7XHJcbiAgICAgICAgICAgIF96b29tLnRyYW5zZm9ybShfY2hhcnQucm9vdCgpLCBkb21haW5Ub1pvb21UcmFuc2Zvcm0oX2NoYXJ0LngoKS5kb21haW4oKSwgX3hPcmlnaW5hbERvbWFpbiwgX29yaWdYKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG9uWm9vbSAoKSB7XHJcbiAgICAgICAgLy8gQXZvaWRzIGluZmluaXRlIHJlY3Vyc2lvbiAobXV0dWFsIHJlY3Vyc2lvbiBiZXR3ZWVuIHJhbmdlIGFuZCBmb2N1cyBvcGVyYXRpb25zKVxyXG4gICAgICAgIC8vIFNvdXJjZSBFdmVudCB3aWxsIGJlIG51bGwgd2hlbiB6b29tIGlzIGNhbGxlZCBwcm9ncmFtbWF0aWNhbGx5IChzZWUgYmVsb3cgYXMgd2VsbCkuXHJcbiAgICAgICAgaWYgKCFkMy5ldmVudC5zb3VyY2VFdmVudCkgeyByZXR1cm47IH1cclxuXHJcbiAgICAgICAgLy8gSWdub3JlIGV2ZW50IGlmIHJlY3Vyc2l2ZSBldmVudCAtIGkuZS4gbm90IGRpcmVjdGx5IGdlbmVyYXRlZCBieSB1c2VyIGFjdGlvbiAobGlrZSBtb3VzZS90b3VjaCBldGMuKVxyXG4gICAgICAgIC8vIEluIHRoaXMgY2FzZSB3ZSBhcmUgbW9yZSB3b3JyaWVkIGFib3V0IHRoaXMgaGFuZGxlciBjYXVzaW5nIHpvb20gcHJvZ3JhbW1hdGljYWxseSB3aGljaCB3aWxsXHJcbiAgICAgICAgLy8gY2F1c2UgdGhpcyBoYW5kbGVyIHRvIGJlIGludm9rZWQgYWdhaW4gd2l0aCBhIG5ldyBkMy5ldmVudCAoYW5kIGN1cnJlbnQgZXZlbnQgc2V0IGFzIHNvdXJjZUV2ZW50KVxyXG4gICAgICAgIC8vIFRoaXMgY2hlY2sgYXZvaWRzIHJlY3Vyc2l2ZSBjYWxsc1xyXG4gICAgICAgIGlmIChkMy5ldmVudC5zb3VyY2VFdmVudC50eXBlICYmIFsnc3RhcnQnLCAnem9vbScsICdlbmQnXS5pbmRleE9mKGQzLmV2ZW50LnNvdXJjZUV2ZW50LnR5cGUpICE9PSAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbmV3RG9tYWluID0gZDMuZXZlbnQudHJhbnNmb3JtLnJlc2NhbGVYKF9vcmlnWCkuZG9tYWluKCk7XHJcbiAgICAgICAgX2NoYXJ0LmZvY3VzKG5ld0RvbWFpbiwgZmFsc2UpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNoZWNrRXh0ZW50cyAoZXh0LCBvdXRlckxpbWl0cykge1xyXG4gICAgICAgIGlmICghZXh0IHx8IGV4dC5sZW5ndGggIT09IDIgfHwgIW91dGVyTGltaXRzIHx8IG91dGVyTGltaXRzLmxlbmd0aCAhPT0gMikge1xyXG4gICAgICAgICAgICByZXR1cm4gZXh0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGV4dFswXSA+IG91dGVyTGltaXRzWzFdIHx8IGV4dFsxXSA8IG91dGVyTGltaXRzWzBdKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignQ291bGQgbm90IGludGVyc2VjdCBleHRlbnRzLCB3aWxsIHJlc2V0Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE1hdGgubWF4IGRvZXMgbm90IHdvcmsgKGFzIHRoZSB2YWx1ZXMgbWF5IGJlIGRhdGVzIGFzIHdlbGwpXHJcbiAgICAgICAgcmV0dXJuIFtleHRbMF0gPiBvdXRlckxpbWl0c1swXSA/IGV4dFswXSA6IG91dGVyTGltaXRzWzBdLCBleHRbMV0gPCBvdXRlckxpbWl0c1sxXSA/IGV4dFsxXSA6IG91dGVyTGltaXRzWzFdXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFpvb20gdGhpcyBjaGFydCB0byBmb2N1cyBvbiB0aGUgZ2l2ZW4gcmFuZ2UuIFRoZSBnaXZlbiByYW5nZSBzaG91bGQgYmUgYW4gYXJyYXkgY29udGFpbmluZyBvbmx5XHJcbiAgICAgKiAyIGVsZW1lbnRzIChgW3N0YXJ0LCBlbmRdYCkgZGVmaW5pbmcgYSByYW5nZSBpbiB0aGUgeCBkb21haW4uIElmIHRoZSByYW5nZSBpcyBub3QgZ2l2ZW4gb3Igc2V0XHJcbiAgICAgKiB0byBudWxsLCB0aGVuIHRoZSB6b29tIHdpbGwgYmUgcmVzZXQuIF9Gb3IgZm9jdXMgdG8gd29yayBlbGFzdGljWCBoYXMgdG8gYmUgdHVybmVkIG9mZjtcclxuICAgICAqIG90aGVyd2lzZSBmb2N1cyB3aWxsIGJlIGlnbm9yZWQuXHJcbiAgICAgKlxyXG4gICAgICogVG8gYXZvaWQgcGluZy1wb25nIHZvbGxleSBvZiBldmVudHMgYmV0d2VlbiBhIHBhaXIgb2YgcmFuZ2UgYW5kIGZvY3VzIGNoYXJ0cyBwbGVhc2Ugc2V0XHJcbiAgICAgKiBgbm9SYWlzZUV2ZW50c2AgdG8gYHRydWVgLiBJbiB0aGF0IGNhc2UgaXQgd2lsbCB1cGRhdGUgdGhpcyBjaGFydCBidXQgd2lsbCBub3QgZmlyZSBgem9vbWAgZXZlbnRcclxuICAgICAqIGFuZCBub3QgdHJ5IHRvIHVwZGF0ZSBiYWNrIHRoZSBhc3NvY2lhdGVkIHJhbmdlIGNoYXJ0LlxyXG4gICAgICogSWYgeW91IGFyZSBjYWxsaW5nIGl0IG1hbnVhbGx5IC0gdHlwaWNhbGx5IHlvdSB3aWxsIGxlYXZlIGl0IHRvIGBmYWxzZWAgKHRoZSBkZWZhdWx0KS5cclxuICAgICAqXHJcbiAgICAgKiBAbWV0aG9kIGZvY3VzXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuY29vcmRpbmF0ZUdyaWRNaXhpblxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogY2hhcnQub24oJ3JlbmRlcmxldCcsIGZ1bmN0aW9uKGNoYXJ0KSB7XHJcbiAgICAgKiAgICAgLy8gc21vb3RoIHRoZSByZW5kZXJpbmcgdGhyb3VnaCBldmVudCB0aHJvdHRsaW5nXHJcbiAgICAgKiAgICAgZGMuZXZlbnRzLnRyaWdnZXIoZnVuY3Rpb24oKXtcclxuICAgICAqICAgICAgICAgIC8vIGZvY3VzIHNvbWUgb3RoZXIgY2hhcnQgdG8gdGhlIHJhbmdlIHNlbGVjdGVkIGJ5IHVzZXIgb24gdGhpcyBjaGFydFxyXG4gICAgICogICAgICAgICAgc29tZU90aGVyQ2hhcnQuZm9jdXMoY2hhcnQuZmlsdGVyKCkpO1xyXG4gICAgICogICAgIH0pO1xyXG4gICAgICogfSlcclxuICAgICAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gW3JhbmdlXVxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbbm9SYWlzZUV2ZW50cyA9IGZhbHNlXVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQuZm9jdXMgPSBmdW5jdGlvbiAocmFuZ2UsIG5vUmFpc2VFdmVudHMpIHtcclxuICAgICAgICBpZiAoX3pvb21PdXRSZXN0cmljdCkge1xyXG4gICAgICAgICAgICAvLyBlbnN1cmUgcmFuZ2UgaXMgd2l0aGluIF94T3JpZ2luYWxEb21haW5cclxuICAgICAgICAgICAgcmFuZ2UgPSBjaGVja0V4dGVudHMocmFuZ2UsIF94T3JpZ2luYWxEb21haW4pO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgaXQgaGFzIGFuIGFzc29jaWF0ZWQgcmFuZ2UgY2hhcnQgZW5zdXJlIHJhbmdlIGlzIHdpdGhpbiBkb21haW4gb2YgdGhhdCByYW5nZUNoYXJ0XHJcbiAgICAgICAgICAgIGlmIChfcmFuZ2VDaGFydCkge1xyXG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBjaGVja0V4dGVudHMocmFuZ2UsIF9yYW5nZUNoYXJ0LngoKS5kb21haW4oKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHpvb21IYW5kbGVyKHJhbmdlLCBub1JhaXNlRXZlbnRzKTtcclxuICAgICAgICB1cGRhdGVEM3pvb21UcmFuc2Zvcm0oKTtcclxuICAgIH07XHJcblxyXG4gICAgX2NoYXJ0LnJlZm9jdXNlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gIWRjLnV0aWxzLmFycmF5c0VxdWFsKF9jaGFydC54KCkuZG9tYWluKCksIF94T3JpZ2luYWxEb21haW4pO1xyXG4gICAgfTtcclxuXHJcbiAgICBfY2hhcnQuZm9jdXNDaGFydCA9IGZ1bmN0aW9uIChjKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfZm9jdXNDaGFydDtcclxuICAgICAgICB9XHJcbiAgICAgICAgX2ZvY3VzQ2hhcnQgPSBjO1xyXG4gICAgICAgIF9jaGFydC5vbignZmlsdGVyZWQuZGNqcy1yYW5nZS1jaGFydCcsIGZ1bmN0aW9uIChjaGFydCkge1xyXG4gICAgICAgICAgICBpZiAoIWNoYXJ0LmZpbHRlcigpKSB7XHJcbiAgICAgICAgICAgICAgICBkYy5ldmVudHMudHJpZ2dlcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2ZvY3VzQ2hhcnQueCgpLmRvbWFpbihfZm9jdXNDaGFydC54T3JpZ2luYWxEb21haW4oKSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICghZGMudXRpbHMuYXJyYXlzRXF1YWwoY2hhcnQuZmlsdGVyKCksIF9mb2N1c0NoYXJ0LmZpbHRlcigpKSkge1xyXG4gICAgICAgICAgICAgICAgZGMuZXZlbnRzLnRyaWdnZXIoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF9mb2N1c0NoYXJ0LmZvY3VzKGNoYXJ0LmZpbHRlcigpLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUdXJuIG9uL29mZiB0aGUgYnJ1c2gtYmFzZWQgcmFuZ2UgZmlsdGVyLiBXaGVuIGJydXNoaW5nIGlzIG9uIHRoZW4gdXNlciBjYW4gZHJhZyB0aGUgbW91c2VcclxuICAgICAqIGFjcm9zcyBhIGNoYXJ0IHdpdGggYSBxdWFudGl0YXRpdmUgc2NhbGUgdG8gcGVyZm9ybSByYW5nZSBmaWx0ZXJpbmcgYmFzZWQgb24gdGhlIGV4dGVudCBvZiB0aGVcclxuICAgICAqIGJydXNoLCBvciBjbGljayBvbiB0aGUgYmFycyBvZiBhbiBvcmRpbmFsIGJhciBjaGFydCBvciBzbGljZXMgb2YgYSBwaWUgY2hhcnQgdG8gZmlsdGVyIGFuZFxyXG4gICAgICogdW4tZmlsdGVyIHRoZW0uIEhvd2V2ZXIgdHVybmluZyBvbiB0aGUgYnJ1c2ggZmlsdGVyIHdpbGwgZGlzYWJsZSBvdGhlciBpbnRlcmFjdGl2ZSBlbGVtZW50cyBvblxyXG4gICAgICogdGhlIGNoYXJ0IHN1Y2ggYXMgaGlnaGxpZ2h0aW5nLCB0b29sIHRpcHMsIGFuZCByZWZlcmVuY2UgbGluZXMuIFpvb21pbmcgd2lsbCBzdGlsbCBiZSBwb3NzaWJsZVxyXG4gICAgICogaWYgZW5hYmxlZCwgYnV0IG9ubHkgdmlhIHNjcm9sbGluZyAocGFubmluZyB3aWxsIGJlIGRpc2FibGVkLilcclxuICAgICAqIEBtZXRob2QgYnJ1c2hPblxyXG4gICAgICogQG1lbWJlcm9mIGRjLmNvb3JkaW5hdGVHcmlkTWl4aW5cclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYnJ1c2hPbj10cnVlXVxyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW58ZGMuY29vcmRpbmF0ZUdyaWRNaXhpbn1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LmJydXNoT24gPSBmdW5jdGlvbiAoYnJ1c2hPbikge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2JydXNoT247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9icnVzaE9uID0gYnJ1c2hPbjtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgd2lsbCBiZSBpbnRlcm5hbGx5IHVzZWQgYnkgY29tcG9zaXRlIGNoYXJ0IG9udG8gY2hpbGRyZW4uIFBsZWFzZSBnbyBub3QgaW52b2tlIGRpcmVjdGx5LlxyXG4gICAgICpcclxuICAgICAqIEBtZXRob2QgcGFyZW50QnJ1c2hPblxyXG4gICAgICogQG1lbWJlcm9mIGRjLmNvb3JkaW5hdGVHcmlkTWl4aW5cclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYnJ1c2hPbj1mYWxzZV1cclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufGRjLmNvb3JkaW5hdGVHcmlkTWl4aW59XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5wYXJlbnRCcnVzaE9uID0gZnVuY3Rpb24gKGJydXNoT24pIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9wYXJlbnRCcnVzaE9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfcGFyZW50QnJ1c2hPbiA9IGJydXNoT247XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLy8gR2V0IHRoZSBTVkcgcmVuZGVyZWQgYnJ1c2hcclxuICAgIF9jaGFydC5nQnJ1c2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9nQnJ1c2g7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGhhc1JhbmdlU2VsZWN0ZWQgKHJhbmdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHJhbmdlIGluc3RhbmNlb2YgQXJyYXkgJiYgcmFuZ2UubGVuZ3RoID4gMTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gX2NoYXJ0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFN0YWNrIE1peGluIGlzIGFuIG1peGluIHRoYXQgcHJvdmlkZXMgY3Jvc3MtY2hhcnQgc3VwcG9ydCBvZiBzdGFja2FiaWxpdHkgdXNpbmcgZDMuc3RhY2tEM3YzLlxyXG4gKiBAbmFtZSBzdGFja01peGluXHJcbiAqIEBtZW1iZXJvZiBkY1xyXG4gKiBAbWl4aW5cclxuICogQHBhcmFtIHtPYmplY3R9IF9jaGFydFxyXG4gKiBAcmV0dXJucyB7ZGMuc3RhY2tNaXhpbn1cclxuICovXHJcbmRjLnN0YWNrTWl4aW4gPSBmdW5jdGlvbiAoX2NoYXJ0KSB7XHJcblxyXG4gICAgZnVuY3Rpb24gcHJlcGFyZVZhbHVlcyAobGF5ZXIsIGxheWVySWR4KSB7XHJcbiAgICAgICAgdmFyIHZhbEFjY2Vzc29yID0gbGF5ZXIuYWNjZXNzb3IgfHwgX2NoYXJ0LnZhbHVlQWNjZXNzb3IoKTtcclxuICAgICAgICBsYXllci5uYW1lID0gU3RyaW5nKGxheWVyLm5hbWUgfHwgbGF5ZXJJZHgpO1xyXG4gICAgICAgIHZhciBhbGxWYWx1ZXMgPSBsYXllci5ncm91cC5hbGwoKS5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHg6IF9jaGFydC5rZXlBY2Nlc3NvcigpKGQsIGkpLFxyXG4gICAgICAgICAgICAgICAgeTogbGF5ZXIuaGlkZGVuID8gbnVsbCA6IHZhbEFjY2Vzc29yKGQsIGkpLFxyXG4gICAgICAgICAgICAgICAgZGF0YTogZCxcclxuICAgICAgICAgICAgICAgIGxheWVyOiBsYXllci5uYW1lLFxyXG4gICAgICAgICAgICAgICAgaGlkZGVuOiBsYXllci5oaWRkZW5cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbGF5ZXIuZG9tYWluVmFsdWVzID0gYWxsVmFsdWVzLmZpbHRlcihkb21haW5GaWx0ZXIoKSk7XHJcbiAgICAgICAgbGF5ZXIudmFsdWVzID0gX2NoYXJ0LmV2YWRlRG9tYWluRmlsdGVyKCkgPyBhbGxWYWx1ZXMgOiBsYXllci5kb21haW5WYWx1ZXM7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIF9zdGFja0xheW91dCA9IGQzLnN0YWNrKCk7XHJcblxyXG4gICAgdmFyIF9zdGFjayA9IFtdO1xyXG4gICAgdmFyIF90aXRsZXMgPSB7fTtcclxuXHJcbiAgICB2YXIgX2hpZGFibGVTdGFja3MgPSBmYWxzZTtcclxuICAgIHZhciBfZXZhZGVEb21haW5GaWx0ZXIgPSBmYWxzZTtcclxuXHJcbiAgICBmdW5jdGlvbiBkb21haW5GaWx0ZXIgKCkge1xyXG4gICAgICAgIGlmICghX2NoYXJ0LngoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGMudXRpbHMuY29uc3RhbnQodHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB4RG9tYWluID0gX2NoYXJ0LngoKS5kb21haW4oKTtcclxuICAgICAgICBpZiAoX2NoYXJ0LmlzT3JkaW5hbCgpKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE8gIzQxNlxyXG4gICAgICAgICAgICAvL3ZhciBkb21haW5TZXQgPSBkMy5zZXQoeERvbWFpbik7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy9kb21haW5TZXQuaGFzKHAueCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChfY2hhcnQuZWxhc3RpY1goKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwKSB7XHJcbiAgICAgICAgICAgIC8vcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIHJldHVybiBwLnggPj0geERvbWFpblswXSAmJiBwLnggPD0geERvbWFpblt4RG9tYWluLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFjayBhIG5ldyBjcm9zc2ZpbHRlciBncm91cCBvbnRvIHRoaXMgY2hhcnQgd2l0aCBhbiBvcHRpb25hbCBjdXN0b20gdmFsdWUgYWNjZXNzb3IuIEFsbCBzdGFja3NcclxuICAgICAqIGluIHRoZSBzYW1lIGNoYXJ0IHdpbGwgc2hhcmUgdGhlIHNhbWUga2V5IGFjY2Vzc29yIGFuZCB0aGVyZWZvcmUgdGhlIHNhbWUgc2V0IG9mIGtleXMuXHJcbiAgICAgKlxyXG4gICAgICogRm9yIGV4YW1wbGUsIGluIGEgc3RhY2tlZCBiYXIgY2hhcnQsIHRoZSBiYXJzIG9mIGVhY2ggc3RhY2sgd2lsbCBiZSBwb3NpdGlvbmVkIHVzaW5nIHRoZSBzYW1lIHNldFxyXG4gICAgICogb2Yga2V5cyBvbiB0aGUgeCBheGlzLCB3aGlsZSBzdGFja2VkIHZlcnRpY2FsbHkuIElmIG5hbWUgaXMgc3BlY2lmaWVkIHRoZW4gaXQgd2lsbCBiZSB1c2VkIHRvXHJcbiAgICAgKiBnZW5lcmF0ZSB0aGUgbGVnZW5kIGxhYmVsLlxyXG4gICAgICogQG1ldGhvZCBzdGFja1xyXG4gICAgICogQG1lbWJlcm9mIGRjLnN0YWNrTWl4aW5cclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Nyb3NzZmlsdGVyL2Nyb3NzZmlsdGVyL3dpa2kvQVBJLVJlZmVyZW5jZSNncm91cC1tYXAtcmVkdWNlIGNyb3NzZmlsdGVyLmdyb3VwfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIHN0YWNrIGdyb3VwIHVzaW5nIGRlZmF1bHQgYWNjZXNzb3JcclxuICAgICAqIGNoYXJ0LnN0YWNrKHZhbHVlU3VtR3JvdXApXHJcbiAgICAgKiAvLyBzdGFjayBncm91cCB1c2luZyBjdXN0b20gYWNjZXNzb3JcclxuICAgICAqIC5zdGFjayhhdmdCeURheUdyb3VwLCBmdW5jdGlvbihkKXtyZXR1cm4gZC52YWx1ZS5hdmdCeURheTt9KTtcclxuICAgICAqIEBwYXJhbSB7Y3Jvc3NmaWx0ZXIuZ3JvdXB9IGdyb3VwXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW25hbWVdXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbYWNjZXNzb3JdXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8e2dyb3VwOiBjcm9zc2ZpbHRlci5ncm91cCwgbmFtZTogU3RyaW5nLCBhY2Nlc3NvcjogRnVuY3Rpb259PnxkYy5zdGFja01peGlufVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQuc3RhY2sgPSBmdW5jdGlvbiAoZ3JvdXAsIG5hbWUsIGFjY2Vzc29yKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfc3RhY2s7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAyKSB7XHJcbiAgICAgICAgICAgIGFjY2Vzc29yID0gbmFtZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBsYXllciA9IHtncm91cDogZ3JvdXB9O1xyXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgbGF5ZXIubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgYWNjZXNzb3IgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgbGF5ZXIuYWNjZXNzb3IgPSBhY2Nlc3NvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3N0YWNrLnB1c2gobGF5ZXIpO1xyXG5cclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICBkYy5vdmVycmlkZShfY2hhcnQsICdncm91cCcsIGZ1bmN0aW9uIChnLCBuLCBmKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfY2hhcnQuX2dyb3VwKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9zdGFjayA9IFtdO1xyXG4gICAgICAgIF90aXRsZXMgPSB7fTtcclxuICAgICAgICBfY2hhcnQuc3RhY2soZywgbik7XHJcbiAgICAgICAgaWYgKGYpIHtcclxuICAgICAgICAgICAgX2NoYXJ0LnZhbHVlQWNjZXNzb3IoZik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfY2hhcnQuX2dyb3VwKGcsIG4pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGxvdyBuYW1lZCBzdGFja3MgdG8gYmUgaGlkZGVuIG9yIHNob3duIGJ5IGNsaWNraW5nIG9uIGxlZ2VuZCBpdGVtcy5cclxuICAgICAqIFRoaXMgZG9lcyBub3QgYWZmZWN0IHRoZSBiZWhhdmlvciBvZiBoaWRlU3RhY2sgb3Igc2hvd1N0YWNrLlxyXG4gICAgICogQG1ldGhvZCBoaWRhYmxlU3RhY2tzXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuc3RhY2tNaXhpblxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtoaWRhYmxlU3RhY2tzPWZhbHNlXVxyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW58ZGMuc3RhY2tNaXhpbn1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LmhpZGFibGVTdGFja3MgPSBmdW5jdGlvbiAoaGlkYWJsZVN0YWNrcykge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2hpZGFibGVTdGFja3M7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9oaWRhYmxlU3RhY2tzID0gaGlkYWJsZVN0YWNrcztcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBmaW5kTGF5ZXJCeU5hbWUgKG4pIHtcclxuICAgICAgICB2YXIgaSA9IF9zdGFjay5tYXAoZGMucGx1Y2soJ25hbWUnKSkuaW5kZXhPZihuKTtcclxuICAgICAgICByZXR1cm4gX3N0YWNrW2ldO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGlkZSBhbGwgc3RhY2tzIG9uIHRoZSBjaGFydCB3aXRoIHRoZSBnaXZlbiBuYW1lLlxyXG4gICAgICogVGhlIGNoYXJ0IG11c3QgYmUgcmUtcmVuZGVyZWQgZm9yIHRoaXMgY2hhbmdlIHRvIGFwcGVhci5cclxuICAgICAqIEBtZXRob2QgaGlkZVN0YWNrXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuc3RhY2tNaXhpblxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RhY2tOYW1lXHJcbiAgICAgKiBAcmV0dXJucyB7ZGMuc3RhY2tNaXhpbn1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LmhpZGVTdGFjayA9IGZ1bmN0aW9uIChzdGFja05hbWUpIHtcclxuICAgICAgICB2YXIgbGF5ZXIgPSBmaW5kTGF5ZXJCeU5hbWUoc3RhY2tOYW1lKTtcclxuICAgICAgICBpZiAobGF5ZXIpIHtcclxuICAgICAgICAgICAgbGF5ZXIuaGlkZGVuID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaG93IGFsbCBzdGFja3Mgb24gdGhlIGNoYXJ0IHdpdGggdGhlIGdpdmVuIG5hbWUuXHJcbiAgICAgKiBUaGUgY2hhcnQgbXVzdCBiZSByZS1yZW5kZXJlZCBmb3IgdGhpcyBjaGFuZ2UgdG8gYXBwZWFyLlxyXG4gICAgICogQG1ldGhvZCBzaG93U3RhY2tcclxuICAgICAqIEBtZW1iZXJvZiBkYy5zdGFja01peGluXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdGFja05hbWVcclxuICAgICAqIEByZXR1cm5zIHtkYy5zdGFja01peGlufVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQuc2hvd1N0YWNrID0gZnVuY3Rpb24gKHN0YWNrTmFtZSkge1xyXG4gICAgICAgIHZhciBsYXllciA9IGZpbmRMYXllckJ5TmFtZShzdGFja05hbWUpO1xyXG4gICAgICAgIGlmIChsYXllcikge1xyXG4gICAgICAgICAgICBsYXllci5oaWRkZW4gPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgX2NoYXJ0LmdldFZhbHVlQWNjZXNzb3JCeUluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdGFja1tpbmRleF0uYWNjZXNzb3IgfHwgX2NoYXJ0LnZhbHVlQWNjZXNzb3IoKTtcclxuICAgIH07XHJcblxyXG4gICAgX2NoYXJ0LnlBeGlzTWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBtaW4gPSBkMy5taW4oZmxhdHRlblN0YWNrKCksIGZ1bmN0aW9uIChwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAocC55IDwgMCkgPyAocC55ICsgcC55MCkgOiBwLnkwO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gZGMudXRpbHMuc3VidHJhY3QobWluLCBfY2hhcnQueUF4aXNQYWRkaW5nKCkpO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgX2NoYXJ0LnlBeGlzTWF4ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBtYXggPSBkMy5tYXgoZmxhdHRlblN0YWNrKCksIGZ1bmN0aW9uIChwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAocC55ID4gMCkgPyAocC55ICsgcC55MCkgOiBwLnkwO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gZGMudXRpbHMuYWRkKG1heCwgX2NoYXJ0LnlBeGlzUGFkZGluZygpKTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gZmxhdHRlblN0YWNrICgpIHtcclxuICAgICAgICB2YXIgdmFsdWVzZXMgPSBfY2hhcnQuZGF0YSgpLm1hcChmdW5jdGlvbiAobGF5ZXIpIHsgcmV0dXJuIGxheWVyLmRvbWFpblZhbHVlczsgfSk7XHJcbiAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIHZhbHVlc2VzKTtcclxuICAgIH1cclxuXHJcbiAgICBfY2hhcnQueEF4aXNNaW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG1pbiA9IGQzLm1pbihmbGF0dGVuU3RhY2soKSwgZGMucGx1Y2soJ3gnKSk7XHJcbiAgICAgICAgcmV0dXJuIGRjLnV0aWxzLnN1YnRyYWN0KG1pbiwgX2NoYXJ0LnhBeGlzUGFkZGluZygpLCBfY2hhcnQueEF4aXNQYWRkaW5nVW5pdCgpKTtcclxuICAgIH07XHJcblxyXG4gICAgX2NoYXJ0LnhBeGlzTWF4ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBtYXggPSBkMy5tYXgoZmxhdHRlblN0YWNrKCksIGRjLnBsdWNrKCd4JykpO1xyXG4gICAgICAgIHJldHVybiBkYy51dGlscy5hZGQobWF4LCBfY2hhcnQueEF4aXNQYWRkaW5nKCksIF9jaGFydC54QXhpc1BhZGRpbmdVbml0KCkpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBvciBnZXQgdGhlIHRpdGxlIGZ1bmN0aW9uLiBDaGFydCBjbGFzcyB3aWxsIHVzZSB0aGlzIGZ1bmN0aW9uIHRvIHJlbmRlciBzdmcgdGl0bGUgKHVzdWFsbHkgaW50ZXJwcmV0ZWQgYnlcclxuICAgICAqIGJyb3dzZXIgYXMgdG9vbHRpcHMpIGZvciBlYWNoIGNoaWxkIGVsZW1lbnQgaW4gdGhlIGNoYXJ0LCBpLmUuIGEgc2xpY2UgaW4gYSBwaWUgY2hhcnQgb3IgYSBidWJibGUgaW4gYSBidWJibGUgY2hhcnQuXHJcbiAgICAgKiBBbG1vc3QgZXZlcnkgY2hhcnQgc3VwcG9ydHMgdGl0bGUgZnVuY3Rpb24gaG93ZXZlciBpbiBncmlkIGNvb3JkaW5hdGUgY2hhcnQgeW91IG5lZWQgdG8gdHVybiBvZmYgYnJ1c2ggaW4gb3JkZXIgdG9cclxuICAgICAqIHVzZSB0aXRsZSBvdGhlcndpc2UgdGhlIGJydXNoIGxheWVyIHdpbGwgYmxvY2sgdG9vbHRpcCB0cmlnZ2VyLlxyXG4gICAgICpcclxuICAgICAqIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIHN0YWNrIG5hbWUsIHRoZSB0aXRsZSBmdW5jdGlvbiB3aWxsIGdldCBvciBzZXQgdGhlIHRpdGxlIGZvciB0aGF0IHN0YWNrLiBJZiBzdGFja05hbWVcclxuICAgICAqIGlzIG5vdCBwcm92aWRlZCwgdGhlIGZpcnN0IHN0YWNrIGlzIGltcGxpZWQuXHJcbiAgICAgKiBAbWV0aG9kIHRpdGxlXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuc3RhY2tNaXhpblxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gc2V0IGEgdGl0bGUgZnVuY3Rpb24gb24gJ2ZpcnN0IHN0YWNrJ1xyXG4gICAgICogY2hhcnQudGl0bGUoJ2ZpcnN0IHN0YWNrJywgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5rZXkgKyAnOiAnICsgZC52YWx1ZTsgfSk7XHJcbiAgICAgKiAvLyBnZXQgYSB0aXRsZSBmdW5jdGlvbiBmcm9tICdzZWNvbmQgc3RhY2snXHJcbiAgICAgKiB2YXIgc2Vjb25kVGl0bGVGdW5jdGlvbiA9IGNoYXJ0LnRpdGxlKCdzZWNvbmQgc3RhY2snKTtcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc3RhY2tOYW1lXVxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3RpdGxlQWNjZXNzb3JdXHJcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfGRjLnN0YWNrTWl4aW59XHJcbiAgICAgKi9cclxuICAgIGRjLm92ZXJyaWRlKF9jaGFydCwgJ3RpdGxlJywgZnVuY3Rpb24gKHN0YWNrTmFtZSwgdGl0bGVBY2Nlc3Nvcikge1xyXG4gICAgICAgIGlmICghc3RhY2tOYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfY2hhcnQuX3RpdGxlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHlwZW9mIHN0YWNrTmFtZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICByZXR1cm4gX2NoYXJ0Ll90aXRsZShzdGFja05hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RhY2tOYW1lID09PSBfY2hhcnQuX2dyb3VwTmFtZSAmJiB0eXBlb2YgdGl0bGVBY2Nlc3NvciA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICByZXR1cm4gX2NoYXJ0Ll90aXRsZSh0aXRsZUFjY2Vzc29yKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgdGl0bGVBY2Nlc3NvciAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICByZXR1cm4gX3RpdGxlc1tzdGFja05hbWVdIHx8IF9jaGFydC5fdGl0bGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIF90aXRsZXNbc3RhY2tOYW1lXSA9IHRpdGxlQWNjZXNzb3I7XHJcblxyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgc3RhY2sgbGF5b3V0IGFsZ29yaXRobSwgd2hpY2ggY29tcHV0ZXMgYSBiYXNlbGluZSBmb3IgZWFjaCBzdGFjayBhbmRcclxuICAgICAqIHByb3BhZ2F0ZXMgaXQgdG8gdGhlIG5leHQuXHJcbiAgICAgKiBAbWV0aG9kIHN0YWNrTGF5b3V0XHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuc3RhY2tNaXhpblxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtMy54LWFwaS1yZWZlcmVuY2UvYmxvYi9tYXN0ZXIvU3RhY2stTGF5b3V0Lm1kIGQzLnN0YWNrRDN2M31cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdGFjaz1kMy5zdGFja0QzdjNdXHJcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb258ZGMuc3RhY2tNaXhpbn1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LnN0YWNrTGF5b3V0ID0gZnVuY3Rpb24gKHN0YWNrKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfc3RhY2tMYXlvdXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9zdGFja0xheW91dCA9IHN0YWNrO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2luY2UgZGMuanMgMi4wLCB0aGVyZSBoYXMgYmVlbiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2RjLWpzL2RjLmpzL2lzc3Vlcy85NDkgYW4gaXNzdWV9XHJcbiAgICAgKiB3aGVyZSBwb2ludHMgYXJlIGZpbHRlcmVkIHRvIHRoZSBjdXJyZW50IGRvbWFpbi4gV2hpbGUgdGhpcyBpcyBhIHVzZWZ1bCBvcHRpbWl6YXRpb24sIGl0IGlzXHJcbiAgICAgKiBpbmNvcnJlY3RseSBpbXBsZW1lbnRlZDogdGhlIG5leHQgcG9pbnQgb3V0c2lkZSB0aGUgZG9tYWluIGlzIHJlcXVpcmVkIGluIG9yZGVyIHRvIGRyYXcgbGluZXNcclxuICAgICAqIHRoYXQgYXJlIGNsaXBwZWQgdG8gdGhlIGJvdW5kcywgYXMgd2VsbCBhcyBiYXJzIHRoYXQgYXJlIHBhcnRseSBjbGlwcGVkLlxyXG4gICAgICpcclxuICAgICAqIEEgZml4IHdpbGwgYmUgaW5jbHVkZWQgaW4gZGMuanMgMi4xLngsIGJ1dCBhIHdvcmthcm91bmQgaXMgbmVlZGVkIGZvciBkYy5qcyAyLjAgYW5kIHVudGlsXHJcbiAgICAgKiB0aGF0IGZpeCBpcyBwdWJsaXNoZWQsIHNvIHNldCB0aGlzIGZsYWcgdG8gc2tpcCBhbnkgZmlsdGVyaW5nIG9mIHBvaW50cy5cclxuICAgICAqXHJcbiAgICAgKiBPbmNlIHRoZSBidWcgaXMgZml4ZWQsIHRoaXMgZmxhZyB3aWxsIGhhdmUgbm8gZWZmZWN0LCBhbmQgaXQgd2lsbCBiZSBkZXByZWNhdGVkLlxyXG4gICAgICogQG1ldGhvZCBldmFkZURvbWFpbkZpbHRlclxyXG4gICAgICogQG1lbWJlcm9mIGRjLnN0YWNrTWl4aW5cclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZXZhZGVEb21haW5GaWx0ZXI9ZmFsc2VdXHJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbnxkYy5zdGFja01peGlufVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQuZXZhZGVEb21haW5GaWx0ZXIgPSBmdW5jdGlvbiAoZXZhZGVEb21haW5GaWx0ZXIpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9ldmFkZURvbWFpbkZpbHRlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgX2V2YWRlRG9tYWluRmlsdGVyID0gZXZhZGVEb21haW5GaWx0ZXI7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gdmlzaWJpbGl0eSAobCkge1xyXG4gICAgICAgIHJldHVybiAhbC5oaWRkZW47XHJcbiAgICB9XHJcblxyXG4gICAgX2NoYXJ0LmRhdGEoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBsYXllcnMgPSBfc3RhY2suZmlsdGVyKHZpc2liaWxpdHkpO1xyXG4gICAgICAgIGlmICghbGF5ZXJzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxheWVycy5mb3JFYWNoKHByZXBhcmVWYWx1ZXMpO1xyXG4gICAgICAgIHZhciB2NGRhdGEgPSBsYXllcnNbMF0udmFsdWVzLm1hcChmdW5jdGlvbiAodiwgaSkge1xyXG4gICAgICAgICAgICB2YXIgY29sID0ge3g6IHYueH07XHJcbiAgICAgICAgICAgIGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChsYXllcikge1xyXG4gICAgICAgICAgICAgICAgY29sW2xheWVyLm5hbWVdID0gbGF5ZXIudmFsdWVzW2ldLnk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gY29sO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBrZXlzID0gbGF5ZXJzLm1hcChmdW5jdGlvbiAobGF5ZXIpIHsgcmV0dXJuIGxheWVyLm5hbWU7IH0pO1xyXG4gICAgICAgIHZhciB2NHJlc3VsdCA9IF9jaGFydC5zdGFja0xheW91dCgpLmtleXMoa2V5cykodjRkYXRhKTtcclxuICAgICAgICB2NHJlc3VsdC5mb3JFYWNoKGZ1bmN0aW9uIChzZXJpZXMsIGkpIHtcclxuICAgICAgICAgICAgc2VyaWVzLmZvckVhY2goZnVuY3Rpb24gKHlzLCBqKSB7XHJcbiAgICAgICAgICAgICAgICBsYXllcnNbaV0udmFsdWVzW2pdLnkwID0geXNbMF07XHJcbiAgICAgICAgICAgICAgICBsYXllcnNbaV0udmFsdWVzW2pdLnkxID0geXNbMV07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBsYXllcnM7XHJcbiAgICB9KTtcclxuXHJcbiAgICBfY2hhcnQuX29yZGluYWxYRG9tYWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBmbGF0ID0gZmxhdHRlblN0YWNrKCkubWFwKGRjLnBsdWNrKCdkYXRhJykpO1xyXG4gICAgICAgIHZhciBvcmRlcmVkID0gX2NoYXJ0Ll9jb21wdXRlT3JkZXJlZEdyb3VwcyhmbGF0KTtcclxuICAgICAgICByZXR1cm4gb3JkZXJlZC5tYXAoX2NoYXJ0LmtleUFjY2Vzc29yKCkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfY2hhcnQuY29sb3JBY2Nlc3NvcihmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIHZhciBsYXllciA9IHRoaXMubGF5ZXIgfHwgdGhpcy5uYW1lIHx8IGQubmFtZSB8fCBkLmxheWVyO1xyXG4gICAgICAgIHJldHVybiBsYXllcjtcclxuICAgIH0pO1xyXG5cclxuICAgIF9jaGFydC5sZWdlbmRhYmxlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX3N0YWNrLm1hcChmdW5jdGlvbiAobGF5ZXIsIGkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGNoYXJ0OiBfY2hhcnQsXHJcbiAgICAgICAgICAgICAgICBuYW1lOiBsYXllci5uYW1lLFxyXG4gICAgICAgICAgICAgICAgaGlkZGVuOiBsYXllci5oaWRkZW4gfHwgZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBjb2xvcjogX2NoYXJ0LmdldENvbG9yLmNhbGwobGF5ZXIsIGxheWVyLnZhbHVlcywgaSlcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgX2NoYXJ0LmlzTGVnZW5kYWJsZUhpZGRlbiA9IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgdmFyIGxheWVyID0gZmluZExheWVyQnlOYW1lKGQubmFtZSk7XHJcbiAgICAgICAgcmV0dXJuIGxheWVyID8gbGF5ZXIuaGlkZGVuIDogZmFsc2U7XHJcbiAgICB9O1xyXG5cclxuICAgIF9jaGFydC5sZWdlbmRUb2dnbGUgPSBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIGlmIChfaGlkYWJsZVN0YWNrcykge1xyXG4gICAgICAgICAgICBpZiAoX2NoYXJ0LmlzTGVnZW5kYWJsZUhpZGRlbihkKSkge1xyXG4gICAgICAgICAgICAgICAgX2NoYXJ0LnNob3dTdGFjayhkLm5hbWUpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgX2NoYXJ0LmhpZGVTdGFjayhkLm5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vX2NoYXJ0LnJlZHJhdygpO1xyXG4gICAgICAgICAgICBfY2hhcnQucmVuZGVyR3JvdXAoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBfY2hhcnQ7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2FwIGlzIGEgbWl4aW4gdGhhdCBncm91cHMgc21hbGwgZGF0YSBlbGVtZW50cyBiZWxvdyBhIF9jYXBfIGludG8gYW4gKm90aGVycyogZ3JvdXBpbmcgZm9yIGJvdGggdGhlXHJcbiAqIFJvdyBhbmQgUGllIENoYXJ0cy5cclxuICpcclxuICogVGhlIHRvcCBvcmRlcmVkIGVsZW1lbnRzIGluIHRoZSBncm91cCB1cCB0byB0aGUgY2FwIGFtb3VudCB3aWxsIGJlIGtlcHQgaW4gdGhlIGNoYXJ0LCBhbmQgdGhlIHJlc3RcclxuICogd2lsbCBiZSByZXBsYWNlZCB3aXRoIGFuICpvdGhlcnMqIGVsZW1lbnQsIHdpdGggdmFsdWUgZXF1YWwgdG8gdGhlIHN1bSBvZiB0aGUgcmVwbGFjZWQgdmFsdWVzLiBUaGVcclxuICoga2V5cyBvZiB0aGUgZWxlbWVudHMgYmVsb3cgdGhlIGNhcCBsaW1pdCBhcmUgcmVjb3JkZWQgaW4gb3JkZXIgdG8gZmlsdGVyIGJ5IHRob3NlIGtleXMgd2hlbiB0aGVcclxuICogb3RoZXJzKiBlbGVtZW50IGlzIGNsaWNrZWQuXHJcbiAqIEBuYW1lIGNhcE1peGluXHJcbiAqIEBtZW1iZXJvZiBkY1xyXG4gKiBAbWl4aW5cclxuICogQHBhcmFtIHtPYmplY3R9IF9jaGFydFxyXG4gKiBAcmV0dXJucyB7ZGMuY2FwTWl4aW59XHJcbiAqL1xyXG5kYy5jYXBNaXhpbiA9IGZ1bmN0aW9uIChfY2hhcnQpIHtcclxuICAgIHZhciBfY2FwID0gSW5maW5pdHksIF90YWtlRnJvbnQgPSB0cnVlO1xyXG4gICAgdmFyIF9vdGhlcnNMYWJlbCA9ICdPdGhlcnMnO1xyXG5cclxuICAgIC8vIGVtdWxhdGUgb2xkIGdyb3VwLnRvcChOKSBvcmRlcmluZ1xyXG4gICAgX2NoYXJ0Lm9yZGVyaW5nKGZ1bmN0aW9uIChrdikge1xyXG4gICAgICAgIHJldHVybiAta3YudmFsdWU7XHJcbiAgICB9KTtcclxuXHJcbiAgICB2YXIgX290aGVyc0dyb3VwZXIgPSBmdW5jdGlvbiAodG9wSXRlbXMsIHJlc3RJdGVtcykge1xyXG4gICAgICAgIHZhciByZXN0SXRlbXNTdW0gPSBkMy5zdW0ocmVzdEl0ZW1zLCBfY2hhcnQudmFsdWVBY2Nlc3NvcigpKSxcclxuICAgICAgICAgICAgcmVzdEtleXMgPSByZXN0SXRlbXMubWFwKF9jaGFydC5rZXlBY2Nlc3NvcigpKTtcclxuICAgICAgICBpZiAocmVzdEl0ZW1zU3VtID4gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdG9wSXRlbXMuY29uY2F0KFt7XHJcbiAgICAgICAgICAgICAgICBvdGhlcnM6IHJlc3RLZXlzLFxyXG4gICAgICAgICAgICAgICAga2V5OiBfY2hhcnQub3RoZXJzTGFiZWwoKSxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiByZXN0SXRlbXNTdW1cclxuICAgICAgICAgICAgfV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdG9wSXRlbXM7XHJcbiAgICB9O1xyXG5cclxuICAgIF9jaGFydC5jYXBwZWRLZXlBY2Nlc3NvciA9IGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgaWYgKGQub3RoZXJzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkLmtleTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydC5rZXlBY2Nlc3NvcigpKGQsIGkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfY2hhcnQuY2FwcGVkVmFsdWVBY2Nlc3NvciA9IGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgaWYgKGQub3RoZXJzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkLnZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX2NoYXJ0LnZhbHVlQWNjZXNzb3IoKShkLCBpKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gcmV0dXJuIE4gXCJ0b3BcIiBncm91cHMsIHdoZXJlIE4gaXMgdGhlIGNhcCwgc29ydGVkIGJ5IGJhc2VNaXhpbi5vcmRlcmluZ1xyXG4gICAgLy8gd2hldGhlciB0b3AgbWVhbnMgZnJvbnQgb3IgYmFjayBkZXBlbmRzIG9uIHRha2VGcm9udFxyXG4gICAgX2NoYXJ0LmRhdGEoZnVuY3Rpb24gKGdyb3VwKSB7XHJcbiAgICAgICAgaWYgKF9jYXAgPT09IEluZmluaXR5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfY2hhcnQuX2NvbXB1dGVPcmRlcmVkR3JvdXBzKGdyb3VwLmFsbCgpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgaXRlbXMgPSBncm91cC5hbGwoKSwgcmVzdDtcclxuICAgICAgICAgICAgaXRlbXMgPSBfY2hhcnQuX2NvbXB1dGVPcmRlcmVkR3JvdXBzKGl0ZW1zKTsgLy8gc29ydCBieSBiYXNlTWl4aW4ub3JkZXJpbmdcclxuXHJcbiAgICAgICAgICAgIGlmIChfY2FwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX3Rha2VGcm9udCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3QgPSBpdGVtcy5zbGljZShfY2FwKTtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtcyA9IGl0ZW1zLnNsaWNlKDAsIF9jYXApO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBNYXRoLm1heCgwLCBpdGVtcy5sZW5ndGggLSBfY2FwKTtcclxuICAgICAgICAgICAgICAgICAgICByZXN0ID0gaXRlbXMuc2xpY2UoMCwgc3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zID0gaXRlbXMuc2xpY2Uoc3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoX290aGVyc0dyb3VwZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfb3RoZXJzR3JvdXBlcihpdGVtcywgcmVzdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGl0ZW1zO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IG9yIHNldCB0aGUgY291bnQgb2YgZWxlbWVudHMgdG8gdGhhdCB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSBjYXAuIElmIHRoZXJlIGlzIGFuXHJcbiAgICAgKiB7QGxpbmsgZGMuY2FwTWl4aW4jb3RoZXJzR3JvdXBlciBvdGhlcnNHcm91cGVyfSwgYW55IGZ1cnRoZXIgZWxlbWVudHMgd2lsbCBiZSBjb21iaW5lZCBpbiBhblxyXG4gICAgICogZXh0cmEgZWxlbWVudCB3aXRoIGl0cyBuYW1lIGRldGVybWluZWQgYnkge0BsaW5rIGRjLmNhcE1peGluI290aGVyc0xhYmVsIG90aGVyc0xhYmVsfS5cclxuICAgICAqXHJcbiAgICAgKiBBcyBvZiBkYy5qcyAyLjEgYW5kIG9ud2FyZCwgdGhlIGNhcHBlZCBjaGFydHMgdXNlXHJcbiAgICAgKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Nyb3NzZmlsdGVyL2Nyb3NzZmlsdGVyL3dpa2kvQVBJLVJlZmVyZW5jZSNncm91cF9hbGwgZ3JvdXAuYWxsKCl9XHJcbiAgICAgKiBhbmQge0BsaW5rIGRjLmJhc2VNaXhpbiNvcmRlcmluZyBiYXNlTWl4aW4ub3JkZXJpbmcoKX0gdG8gZGV0ZXJtaW5lIHRoZSBvcmRlciBvZlxyXG4gICAgICogZWxlbWVudHMuIFRoZW4gYGNhcGAgYW5kIHtAbGluayBkYy5jYXBNaXhpbiN0YWtlRnJvbnQgdGFrZUZyb250fSBkZXRlcm1pbmUgaG93IG1hbnkgZWxlbWVudHNcclxuICAgICAqIHRvIGtlZXAsIGZyb20gd2hpY2ggZW5kIG9mIHRoZSByZXN1bHRpbmcgYXJyYXkuXHJcbiAgICAgKlxyXG4gICAgICogKipNaWdyYXRpb24gbm90ZToqKiBVcCB0aHJvdWdoIGRjLmpzIDIuMC4qLCBjYXBwaW5nIHVzZWRcclxuICAgICAqIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vY3Jvc3NmaWx0ZXIvY3Jvc3NmaWx0ZXIvd2lraS9BUEktUmVmZXJlbmNlI2dyb3VwX3RvcCBncm91cC50b3AoTil9LFxyXG4gICAgICogd2hpY2ggc2VsZWN0cyB0aGUgbGFyZ2VzdCBpdGVtcyBhY2NvcmRpbmcgdG9cclxuICAgICAqIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vY3Jvc3NmaWx0ZXIvY3Jvc3NmaWx0ZXIvd2lraS9BUEktUmVmZXJlbmNlI2dyb3VwX29yZGVyIGdyb3VwLm9yZGVyKCl9LlxyXG4gICAgICogVGhlIGNoYXJ0IHRoZW4gc29ydGVkIHRoZSBpdGVtcyBhY2NvcmRpbmcgdG8ge0BsaW5rIGRjLmJhc2VNaXhpbiNvcmRlcmluZyBiYXNlTWl4aW4ub3JkZXJpbmcoKX0uXHJcbiAgICAgKiBTbyB0aGUgdHdvIHZhbHVlcyBlc3NlbnRpYWxseSBoYWQgdG8gYWdyZWUsIGJ1dCBpZiB0aGUgYGdyb3VwLm9yZGVyKClgIHdhcyBpbmNvcnJlY3QgKGl0J3NcclxuICAgICAqIGVhc3kgdG8gZm9yZ2V0IGFib3V0KSwgdGhlIHdyb25nIHJvd3Mgb3Igc2xpY2VzIHdvdWxkIGJlIGRpc3BsYXllZCwgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuXHJcbiAgICAgKlxyXG4gICAgICogSWYgeW91ciBjaGFydCBwcmV2aW91c2x5IHJlbGllZCBvbiBgZ3JvdXAub3JkZXIoKWAsIHVzZSBgY2hhcnQub3JkZXJpbmcoKWAgaW5zdGVhZC4gQXMgb2ZcclxuICAgICAqIDIuMS41LCB0aGUgb3JkZXJpbmcgZGVmYXVsdHMgdG8gc29ydGluZyBmcm9tIGdyZWF0ZXN0IHRvIGxlYXN0IGxpa2UgYGdyb3VwLnRvcChOKWAgZGlkLlxyXG4gICAgICpcclxuICAgICAqIElmIHlvdSB3YW50IHRvIGNhcCBieSBvbmUgb3JkZXJpbmcgYnV0IHNvcnQgYnkgYW5vdGhlciwgcGxlYXNlXHJcbiAgICAgKiBbZmlsZSBhbiBpc3N1ZV0oaHR0cHM6Ly9naXRodWIuY29tL2RjLWpzL2RjLmpzL2lzc3Vlcy9uZXcpIC0gaXQncyBzdGlsbCBwb3NzaWJsZSBidXQgd2UnbGxcclxuICAgICAqIG5lZWQgdG8gd29yayB1cCBhbiBleGFtcGxlLlxyXG4gICAgICogQG1ldGhvZCBjYXBcclxuICAgICAqIEBtZW1iZXJvZiBkYy5jYXBNaXhpblxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvdW50PUluZmluaXR5XVxyXG4gICAgICogQHJldHVybnMge051bWJlcnxkYy5jYXBNaXhpbn1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LmNhcCA9IGZ1bmN0aW9uIChjb3VudCkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2NhcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgX2NhcCA9IGNvdW50O1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IG9yIHNldCB0aGUgZGlyZWN0aW9uIG9mIGNhcHBpbmcuIElmIHNldCwgdGhlIGNoYXJ0IHRha2VzIHRoZSBmaXJzdFxyXG4gICAgICoge0BsaW5rIGRjLmNhcE1peGluI2NhcCBjYXB9IGVsZW1lbnRzIGZyb20gdGhlIHNvcnRlZCBhcnJheSBvZiBlbGVtZW50czsgb3RoZXJ3aXNlXHJcbiAgICAgKiBpdCB0YWtlcyB0aGUgbGFzdCBgY2FwYCBlbGVtZW50cy5cclxuICAgICAqIEBtZXRob2QgdGFrZUZyb250XHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuY2FwTWl4aW5cclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbdGFrZUZyb250PXRydWVdXHJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbnxkYy5jYXBNaXhpbn1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LnRha2VGcm9udCA9IGZ1bmN0aW9uICh0YWtlRnJvbnQpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF90YWtlRnJvbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF90YWtlRnJvbnQgPSB0YWtlRnJvbnQ7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgb3Igc2V0IHRoZSBsYWJlbCBmb3IgKk90aGVycyogc2xpY2Ugd2hlbiBzbGljZXMgY2FwIGlzIHNwZWNpZmllZC5cclxuICAgICAqIEBtZXRob2Qgb3RoZXJzTGFiZWxcclxuICAgICAqIEBtZW1iZXJvZiBkYy5jYXBNaXhpblxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2xhYmVsPVwiT3RoZXJzXCJdXHJcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfGRjLmNhcE1peGlufVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQub3RoZXJzTGFiZWwgPSBmdW5jdGlvbiAobGFiZWwpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9vdGhlcnNMYWJlbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgX290aGVyc0xhYmVsID0gbGFiZWw7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgb3Igc2V0IHRoZSBncm91cGVyIGZ1bmN0aW9uIHRoYXQgd2lsbCBwZXJmb3JtIHRoZSBpbnNlcnRpb24gb2YgZGF0YSBmb3IgdGhlICpPdGhlcnMqIHNsaWNlXHJcbiAgICAgKiBpZiB0aGUgc2xpY2VzIGNhcCBpcyBzcGVjaWZpZWQuIElmIHNldCB0byBhIGZhbHN5IHZhbHVlLCBubyBvdGhlcnMgd2lsbCBiZSBhZGRlZC5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgZ3JvdXBlciBmdW5jdGlvbiB0YWtlcyBhbiBhcnJheSBvZiBpbmNsdWRlZCAoXCJ0b3BcIikgaXRlbXMsIGFuZCBhbiBhcnJheSBvZiB0aGUgcmVzdCBvZlxyXG4gICAgICogdGhlIGl0ZW1zLiBCeSBkZWZhdWx0IHRoZSBncm91cGVyIGZ1bmN0aW9uIGNvbXB1dGVzIHRoZSBzdW0gb2YgdGhlIHJlc3QuXHJcbiAgICAgKiBAbWV0aG9kIG90aGVyc0dyb3VwZXJcclxuICAgICAqIEBtZW1iZXJvZiBkYy5jYXBNaXhpblxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gRG8gbm90IHNob3cgb3RoZXJzXHJcbiAgICAgKiBjaGFydC5vdGhlcnNHcm91cGVyKG51bGwpO1xyXG4gICAgICogLy8gRGVmYXVsdCBvdGhlcnMgZ3JvdXBlclxyXG4gICAgICogY2hhcnQub3RoZXJzR3JvdXBlcihmdW5jdGlvbiAodG9wSXRlbXMsIHJlc3RJdGVtcykge1xyXG4gICAgICogICAgIHZhciByZXN0SXRlbXNTdW0gPSBkMy5zdW0ocmVzdEl0ZW1zLCBfY2hhcnQudmFsdWVBY2Nlc3NvcigpKSxcclxuICAgICAqICAgICAgICAgcmVzdEtleXMgPSByZXN0SXRlbXMubWFwKF9jaGFydC5rZXlBY2Nlc3NvcigpKTtcclxuICAgICAqICAgICBpZiAocmVzdEl0ZW1zU3VtID4gMCkge1xyXG4gICAgICogICAgICAgICByZXR1cm4gdG9wSXRlbXMuY29uY2F0KFt7XHJcbiAgICAgKiAgICAgICAgICAgICBvdGhlcnM6IHJlc3RLZXlzLFxyXG4gICAgICogICAgICAgICAgICAga2V5OiBfY2hhcnQub3RoZXJzTGFiZWwoKSxcclxuICAgICAqICAgICAgICAgICAgIHZhbHVlOiByZXN0SXRlbXNTdW1cclxuICAgICAqICAgICAgICAgfV0pO1xyXG4gICAgICogICAgIH1cclxuICAgICAqICAgICByZXR1cm4gdG9wSXRlbXM7XHJcbiAgICAgKiB9KTtcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtncm91cGVyRnVuY3Rpb25dXHJcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb258ZGMuY2FwTWl4aW59XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5vdGhlcnNHcm91cGVyID0gZnVuY3Rpb24gKGdyb3VwZXJGdW5jdGlvbikge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX290aGVyc0dyb3VwZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9vdGhlcnNHcm91cGVyID0gZ3JvdXBlckZ1bmN0aW9uO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIGRjLm92ZXJyaWRlKF9jaGFydCwgJ29uQ2xpY2snLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIGlmIChkLm90aGVycykge1xyXG4gICAgICAgICAgICBfY2hhcnQuZmlsdGVyKFtkLm90aGVyc10pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfY2hhcnQuX29uQ2xpY2soZCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gX2NoYXJ0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgTWl4aW4gcHJvdmlkZXMgcmV1c2FibGUgZnVuY3Rpb25hbGl0aWVzIGZvciBhbnkgY2hhcnQgdGhhdCBuZWVkcyB0byB2aXN1YWxpemUgZGF0YSB1c2luZyBidWJibGVzLlxyXG4gKiBAbmFtZSBidWJibGVNaXhpblxyXG4gKiBAbWVtYmVyb2YgZGNcclxuICogQG1peGluXHJcbiAqIEBtaXhlcyBkYy5jb2xvck1peGluXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBfY2hhcnRcclxuICogQHJldHVybnMge2RjLmJ1YmJsZU1peGlufVxyXG4gKi9cclxuZGMuYnViYmxlTWl4aW4gPSBmdW5jdGlvbiAoX2NoYXJ0KSB7XHJcbiAgICB2YXIgX21heEJ1YmJsZVJlbGF0aXZlU2l6ZSA9IDAuMztcclxuICAgIHZhciBfbWluUmFkaXVzV2l0aExhYmVsID0gMTA7XHJcbiAgICB2YXIgX3NvcnRCdWJibGVTaXplID0gZmFsc2U7XHJcbiAgICB2YXIgX2VsYXN0aWNSYWRpdXMgPSBmYWxzZTtcclxuXHJcbiAgICBfY2hhcnQuQlVCQkxFX05PREVfQ0xBU1MgPSAnbm9kZSc7XHJcbiAgICBfY2hhcnQuQlVCQkxFX0NMQVNTID0gJ2J1YmJsZSc7XHJcbiAgICBfY2hhcnQuTUlOX1JBRElVUyA9IDEwO1xyXG5cclxuICAgIF9jaGFydCA9IGRjLmNvbG9yTWl4aW4oX2NoYXJ0KTtcclxuXHJcbiAgICBfY2hhcnQucmVuZGVyTGFiZWwodHJ1ZSk7XHJcblxyXG4gICAgX2NoYXJ0LmRhdGEoZnVuY3Rpb24gKGdyb3VwKSB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSBncm91cC5hbGwoKTtcclxuICAgICAgICBpZiAoX3NvcnRCdWJibGVTaXplKSB7XHJcbiAgICAgICAgICAgIC8vIHNvcnQgZGVzY2VuZGluZyBzbyBzbWFsbGVyIGJ1YmJsZXMgYXJlIG9uIHRvcFxyXG4gICAgICAgICAgICB2YXIgcmFkaXVzQWNjZXNzb3IgPSBfY2hhcnQucmFkaXVzVmFsdWVBY2Nlc3NvcigpO1xyXG4gICAgICAgICAgICBkYXRhLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGQzLmRlc2NlbmRpbmcocmFkaXVzQWNjZXNzb3IoYSksIHJhZGl1c0FjY2Vzc29yKGIpKTsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdmFyIF9yID0gZDMuc2NhbGVMaW5lYXIoKS5kb21haW4oWzAsIDEwMF0pO1xyXG5cclxuICAgIHZhciBfclZhbHVlQWNjZXNzb3IgPSBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIHJldHVybiBkLnI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IG9yIHNldCB0aGUgYnViYmxlIHJhZGl1cyBzY2FsZS4gQnkgZGVmYXVsdCB0aGUgYnViYmxlIGNoYXJ0IHVzZXNcclxuICAgICAqIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2NhbGUvYmxvYi9tYXN0ZXIvUkVBRE1FLm1kI3NjYWxlTGluZWFyIGQzLnNjYWxlTGluZWFyKCkuZG9tYWluKFswLCAxMDBdKX1cclxuICAgICAqIGFzIGl0cyByYWRpdXMgc2NhbGUuXHJcbiAgICAgKiBAbWV0aG9kIHJcclxuICAgICAqIEBtZW1iZXJvZiBkYy5idWJibGVNaXhpblxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2NhbGUvYmxvYi9tYXN0ZXIvUkVBRE1FLm1kIGQzLnNjYWxlfVxyXG4gICAgICogQHBhcmFtIHtkMy5zY2FsZX0gW2J1YmJsZVJhZGl1c1NjYWxlPWQzLnNjYWxlTGluZWFyKCkuZG9tYWluKFswLCAxMDBdKV1cclxuICAgICAqIEByZXR1cm5zIHtkMy5zY2FsZXxkYy5idWJibGVNaXhpbn1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LnIgPSBmdW5jdGlvbiAoYnViYmxlUmFkaXVzU2NhbGUpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfciA9IGJ1YmJsZVJhZGl1c1NjYWxlO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHVybiBvbiBvciBvZmYgdGhlIGVsYXN0aWMgYnViYmxlIHJhZGl1cyBmZWF0dXJlLCBvciByZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBmbGFnLiBJZiB0aGlzXHJcbiAgICAgKiBmZWF0dXJlIGlzIHR1cm5lZCBvbiwgdGhlbiBidWJibGUgcmFkaWkgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHJlc2NhbGVkIHRvIGZpdCB0aGUgY2hhcnQgYmV0dGVyLlxyXG4gICAgICogQG1ldGhvZCBlbGFzdGljUmFkaXVzXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuYnViYmxlQ2hhcnRcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZWxhc3RpY1JhZGl1cz1mYWxzZV1cclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufGRjLmJ1YmJsZUNoYXJ0fVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQuZWxhc3RpY1JhZGl1cyA9IGZ1bmN0aW9uIChlbGFzdGljUmFkaXVzKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfZWxhc3RpY1JhZGl1cztcclxuICAgICAgICB9XHJcbiAgICAgICAgX2VsYXN0aWNSYWRpdXMgPSBlbGFzdGljUmFkaXVzO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF9jaGFydC5jYWxjdWxhdGVSYWRpdXNEb21haW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKF9lbGFzdGljUmFkaXVzKSB7XHJcbiAgICAgICAgICAgIF9jaGFydC5yKCkuZG9tYWluKFtfY2hhcnQuck1pbigpLCBfY2hhcnQuck1heCgpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBvciBzZXQgdGhlIHJhZGl1cyB2YWx1ZSBhY2Nlc3NvciBmdW5jdGlvbi4gSWYgc2V0LCB0aGUgcmFkaXVzIHZhbHVlIGFjY2Vzc29yIGZ1bmN0aW9uIHdpbGxcclxuICAgICAqIGJlIHVzZWQgdG8gcmV0cmlldmUgYSBkYXRhIHZhbHVlIGZvciBlYWNoIGJ1YmJsZS4gVGhlIGRhdGEgcmV0cmlldmVkIHRoZW4gd2lsbCBiZSBtYXBwZWQgdXNpbmdcclxuICAgICAqIHRoZSByIHNjYWxlIHRvIHRoZSBhY3R1YWwgYnViYmxlIHJhZGl1cy4gVGhpcyBhbGxvd3MgeW91IHRvIGVuY29kZSBhIGRhdGEgZGltZW5zaW9uIHVzaW5nIGJ1YmJsZVxyXG4gICAgICogc2l6ZS5cclxuICAgICAqIEBtZXRob2QgcmFkaXVzVmFsdWVBY2Nlc3NvclxyXG4gICAgICogQG1lbWJlcm9mIGRjLmJ1YmJsZU1peGluXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyYWRpdXNWYWx1ZUFjY2Vzc29yXVxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufGRjLmJ1YmJsZU1peGlufVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQucmFkaXVzVmFsdWVBY2Nlc3NvciA9IGZ1bmN0aW9uIChyYWRpdXNWYWx1ZUFjY2Vzc29yKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfclZhbHVlQWNjZXNzb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9yVmFsdWVBY2Nlc3NvciA9IHJhZGl1c1ZhbHVlQWNjZXNzb3I7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgX2NoYXJ0LnJNaW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG1pbiA9IGQzLm1pbihfY2hhcnQuZGF0YSgpLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2NoYXJ0LnJhZGl1c1ZhbHVlQWNjZXNzb3IoKShlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbWluO1xyXG4gICAgfTtcclxuXHJcbiAgICBfY2hhcnQuck1heCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbWF4ID0gZDMubWF4KF9jaGFydC5kYXRhKCksIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfY2hhcnQucmFkaXVzVmFsdWVBY2Nlc3NvcigpKGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBtYXg7XHJcbiAgICB9O1xyXG5cclxuICAgIF9jaGFydC5idWJibGVSID0gZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSBfY2hhcnQucmFkaXVzVmFsdWVBY2Nlc3NvcigpKGQpO1xyXG4gICAgICAgIHZhciByID0gX2NoYXJ0LnIoKSh2YWx1ZSk7XHJcbiAgICAgICAgaWYgKGlzTmFOKHIpIHx8IHZhbHVlIDw9IDApIHtcclxuICAgICAgICAgICAgciA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgbGFiZWxGdW5jdGlvbiA9IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydC5sYWJlbCgpKGQpO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgc2hvdWxkTGFiZWwgPSBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIHJldHVybiAoX2NoYXJ0LmJ1YmJsZVIoZCkgPiBfbWluUmFkaXVzV2l0aExhYmVsKTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGxhYmVsT3BhY2l0eSA9IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgcmV0dXJuIHNob3VsZExhYmVsKGQpID8gMSA6IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBsYWJlbFBvaW50ZXJFdmVudCA9IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgcmV0dXJuIHNob3VsZExhYmVsKGQpID8gJ2FsbCcgOiAnbm9uZSc7XHJcbiAgICB9O1xyXG5cclxuICAgIF9jaGFydC5fZG9SZW5kZXJMYWJlbCA9IGZ1bmN0aW9uIChidWJibGVHRW50ZXIpIHtcclxuICAgICAgICBpZiAoX2NoYXJ0LnJlbmRlckxhYmVsKCkpIHtcclxuICAgICAgICAgICAgdmFyIGxhYmVsID0gYnViYmxlR0VudGVyLnNlbGVjdCgndGV4dCcpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGxhYmVsLmVtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIGxhYmVsID0gYnViYmxlR0VudGVyLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgJy4zZW0nKVxyXG4gICAgICAgICAgICAgICAgICAgIC5vbignY2xpY2snLCBfY2hhcnQub25DbGljayk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxhYmVsXHJcbiAgICAgICAgICAgICAgICAuYXR0cignb3BhY2l0eScsIDApXHJcbiAgICAgICAgICAgICAgICAuYXR0cigncG9pbnRlci1ldmVudHMnLCBsYWJlbFBvaW50ZXJFdmVudClcclxuICAgICAgICAgICAgICAgIC50ZXh0KGxhYmVsRnVuY3Rpb24pO1xyXG4gICAgICAgICAgICBkYy50cmFuc2l0aW9uKGxhYmVsLCBfY2hhcnQudHJhbnNpdGlvbkR1cmF0aW9uKCksIF9jaGFydC50cmFuc2l0aW9uRGVsYXkoKSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdvcGFjaXR5JywgbGFiZWxPcGFjaXR5KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9jaGFydC5kb1VwZGF0ZUxhYmVscyA9IGZ1bmN0aW9uIChidWJibGVHRW50ZXIpIHtcclxuICAgICAgICBpZiAoX2NoYXJ0LnJlbmRlckxhYmVsKCkpIHtcclxuICAgICAgICAgICAgdmFyIGxhYmVscyA9IGJ1YmJsZUdFbnRlci5zZWxlY3QoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3BvaW50ZXItZXZlbnRzJywgbGFiZWxQb2ludGVyRXZlbnQpXHJcbiAgICAgICAgICAgICAgICAudGV4dChsYWJlbEZ1bmN0aW9uKTtcclxuICAgICAgICAgICAgZGMudHJhbnNpdGlvbihsYWJlbHMsIF9jaGFydC50cmFuc2l0aW9uRHVyYXRpb24oKSwgX2NoYXJ0LnRyYW5zaXRpb25EZWxheSgpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ29wYWNpdHknLCBsYWJlbE9wYWNpdHkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdmFyIHRpdGxlRnVuY3Rpb24gPSBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQudGl0bGUoKShkKTtcclxuICAgIH07XHJcblxyXG4gICAgX2NoYXJ0Ll9kb1JlbmRlclRpdGxlcyA9IGZ1bmN0aW9uIChnKSB7XHJcbiAgICAgICAgaWYgKF9jaGFydC5yZW5kZXJUaXRsZSgpKSB7XHJcbiAgICAgICAgICAgIHZhciB0aXRsZSA9IGcuc2VsZWN0KCd0aXRsZScpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRpdGxlLmVtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIGcuYXBwZW5kKCd0aXRsZScpLnRleHQodGl0bGVGdW5jdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9jaGFydC5kb1VwZGF0ZVRpdGxlcyA9IGZ1bmN0aW9uIChnKSB7XHJcbiAgICAgICAgaWYgKF9jaGFydC5yZW5kZXJUaXRsZSgpKSB7XHJcbiAgICAgICAgICAgIGcuc2VsZWN0KCd0aXRsZScpLnRleHQodGl0bGVGdW5jdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFR1cm4gb24gb3Igb2ZmIHRoZSBidWJibGUgc29ydGluZyBmZWF0dXJlLCBvciByZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBmbGFnLiBJZiBlbmFibGVkLFxyXG4gICAgICogYnViYmxlcyB3aWxsIGJlIHNvcnRlZCBieSB0aGVpciByYWRpdXMsIHdpdGggc21hbGxlciBidWJibGVzIGluIGZyb250LlxyXG4gICAgICogQG1ldGhvZCBzb3J0QnViYmxlU2l6ZVxyXG4gICAgICogQG1lbWJlcm9mIGRjLmJ1YmJsZUNoYXJ0XHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NvcnRCdWJibGVTaXplPWZhbHNlXVxyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW58ZGMuYnViYmxlQ2hhcnR9XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5zb3J0QnViYmxlU2l6ZSA9IGZ1bmN0aW9uIChzb3J0QnViYmxlU2l6ZSkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3NvcnRCdWJibGVTaXplO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfc29ydEJ1YmJsZVNpemUgPSBzb3J0QnViYmxlU2l6ZTtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBvciBzZXQgdGhlIG1pbmltdW0gcmFkaXVzLiBUaGlzIHdpbGwgYmUgdXNlZCB0byBpbml0aWFsaXplIHRoZSByYWRpdXMgc2NhbGUncyByYW5nZS5cclxuICAgICAqIEBtZXRob2QgbWluUmFkaXVzXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuYnViYmxlTWl4aW5cclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtyYWRpdXM9MTBdXHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfGRjLmJ1YmJsZU1peGlufVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQubWluUmFkaXVzID0gZnVuY3Rpb24gKHJhZGl1cykge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2NoYXJ0Lk1JTl9SQURJVVM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9jaGFydC5NSU5fUkFESVVTID0gcmFkaXVzO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IG9yIHNldCB0aGUgbWluaW11bSByYWRpdXMgZm9yIGxhYmVsIHJlbmRlcmluZy4gSWYgYSBidWJibGUncyByYWRpdXMgaXMgbGVzcyB0aGFuIHRoaXMgdmFsdWVcclxuICAgICAqIHRoZW4gbm8gbGFiZWwgd2lsbCBiZSByZW5kZXJlZC5cclxuICAgICAqIEBtZXRob2QgbWluUmFkaXVzV2l0aExhYmVsXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuYnViYmxlTWl4aW5cclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtyYWRpdXM9MTBdXHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfGRjLmJ1YmJsZU1peGlufVxyXG4gICAgICovXHJcblxyXG4gICAgX2NoYXJ0Lm1pblJhZGl1c1dpdGhMYWJlbCA9IGZ1bmN0aW9uIChyYWRpdXMpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9taW5SYWRpdXNXaXRoTGFiZWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9taW5SYWRpdXNXaXRoTGFiZWwgPSByYWRpdXM7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgb3Igc2V0IHRoZSBtYXhpbXVtIHJlbGF0aXZlIHNpemUgb2YgYSBidWJibGUgdG8gdGhlIGxlbmd0aCBvZiB4IGF4aXMuIFRoaXMgdmFsdWUgaXMgdXNlZnVsXHJcbiAgICAgKiB3aGVuIHRoZSBkaWZmZXJlbmNlIGluIHJhZGl1cyBiZXR3ZWVuIGJ1YmJsZXMgaXMgdG9vIGdyZWF0LlxyXG4gICAgICogQG1ldGhvZCBtYXhCdWJibGVSZWxhdGl2ZVNpemVcclxuICAgICAqIEBtZW1iZXJvZiBkYy5idWJibGVNaXhpblxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3JlbGF0aXZlU2l6ZT0wLjNdXHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfGRjLmJ1YmJsZU1peGlufVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQubWF4QnViYmxlUmVsYXRpdmVTaXplID0gZnVuY3Rpb24gKHJlbGF0aXZlU2l6ZSkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX21heEJ1YmJsZVJlbGF0aXZlU2l6ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX21heEJ1YmJsZVJlbGF0aXZlU2l6ZSA9IHJlbGF0aXZlU2l6ZTtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICBfY2hhcnQuZmFkZURlc2VsZWN0ZWRBcmVhID0gZnVuY3Rpb24gKHNlbGVjdGlvbikge1xyXG4gICAgICAgIGlmIChfY2hhcnQuaGFzRmlsdGVyKCkpIHtcclxuICAgICAgICAgICAgX2NoYXJ0LnNlbGVjdEFsbCgnZy4nICsgX2NoYXJ0LkJVQkJMRV9OT0RFX0NMQVNTKS5lYWNoKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX2NoYXJ0LmlzU2VsZWN0ZWROb2RlKGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2NoYXJ0LmhpZ2hsaWdodFNlbGVjdGVkKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBfY2hhcnQuZmFkZURlc2VsZWN0ZWQodGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIF9jaGFydC5zZWxlY3RBbGwoJ2cuJyArIF9jaGFydC5CVUJCTEVfTk9ERV9DTEFTUykuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfY2hhcnQucmVzZXRIaWdobGlnaHQodGhpcyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgX2NoYXJ0LmlzU2VsZWN0ZWROb2RlID0gZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0Lmhhc0ZpbHRlcihkLmtleSk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9jaGFydC5vbkNsaWNrID0gZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICB2YXIgZmlsdGVyID0gZC5rZXk7XHJcbiAgICAgICAgZGMuZXZlbnRzLnRyaWdnZXIoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfY2hhcnQuZmlsdGVyKGZpbHRlcik7XHJcbiAgICAgICAgICAgIF9jaGFydC5yZWRyYXdHcm91cCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gX2NoYXJ0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRoZSBwaWUgY2hhcnQgaW1wbGVtZW50YXRpb24gaXMgdXN1YWxseSB1c2VkIHRvIHZpc3VhbGl6ZSBhIHNtYWxsIGNhdGVnb3JpY2FsIGRpc3RyaWJ1dGlvbi4gIFRoZSBwaWVcclxuICogY2hhcnQgdXNlcyBrZXlBY2Nlc3NvciB0byBkZXRlcm1pbmUgdGhlIHNsaWNlcywgYW5kIHZhbHVlQWNjZXNzb3IgdG8gY2FsY3VsYXRlIHRoZSBzaXplIG9mIGVhY2hcclxuICogc2xpY2UgcmVsYXRpdmUgdG8gdGhlIHN1bSBvZiBhbGwgdmFsdWVzLiBTbGljZXMgYXJlIG9yZGVyZWQgYnkge0BsaW5rIGRjLmJhc2VNaXhpbiNvcmRlcmluZyBvcmRlcmluZ31cclxuICogd2hpY2ggZGVmYXVsdHMgdG8gc29ydGluZyBieSBrZXkuXHJcbiAqXHJcbiAqIEV4YW1wbGVzOlxyXG4gKiAtIHtAbGluayBodHRwOi8vZGMtanMuZ2l0aHViLmNvbS9kYy5qcy8gTmFzZGFxIDEwMCBJbmRleH1cclxuICogQGNsYXNzIHBpZUNoYXJ0XHJcbiAqIEBtZW1iZXJvZiBkY1xyXG4gKiBAbWl4ZXMgZGMuY2FwTWl4aW5cclxuICogQG1peGVzIGRjLmNvbG9yTWl4aW5cclxuICogQG1peGVzIGRjLmJhc2VNaXhpblxyXG4gKiBAZXhhbXBsZVxyXG4gKiAvLyBjcmVhdGUgYSBwaWUgY2hhcnQgdW5kZXIgI2NoYXJ0LWNvbnRhaW5lcjEgZWxlbWVudCB1c2luZyB0aGUgZGVmYXVsdCBnbG9iYWwgY2hhcnQgZ3JvdXBcclxuICogdmFyIGNoYXJ0MSA9IGRjLnBpZUNoYXJ0KCcjY2hhcnQtY29udGFpbmVyMScpO1xyXG4gKiAvLyBjcmVhdGUgYSBwaWUgY2hhcnQgdW5kZXIgI2NoYXJ0LWNvbnRhaW5lcjIgZWxlbWVudCB1c2luZyBjaGFydCBncm91cCBBXHJcbiAqIHZhciBjaGFydDIgPSBkYy5waWVDaGFydCgnI2NoYXJ0LWNvbnRhaW5lcjInLCAnY2hhcnRHcm91cEEnKTtcclxuICogQHBhcmFtIHtTdHJpbmd8bm9kZXxkMy5zZWxlY3Rpb259IHBhcmVudCAtIEFueSB2YWxpZFxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNlbGVjdGlvbi9ibG9iL21hc3Rlci9SRUFETUUubWQjc2VsZWN0IGQzIHNpbmdsZSBzZWxlY3Rvcn0gc3BlY2lmeWluZ1xyXG4gKiBhIGRvbSBibG9jayBlbGVtZW50IHN1Y2ggYXMgYSBkaXY7IG9yIGEgZG9tIGVsZW1lbnQgb3IgZDMgc2VsZWN0aW9uLlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gW2NoYXJ0R3JvdXBdIC0gVGhlIG5hbWUgb2YgdGhlIGNoYXJ0IGdyb3VwIHRoaXMgY2hhcnQgaW5zdGFuY2Ugc2hvdWxkIGJlIHBsYWNlZCBpbi5cclxuICogSW50ZXJhY3Rpb24gd2l0aCBhIGNoYXJ0IHdpbGwgb25seSB0cmlnZ2VyIGV2ZW50cyBhbmQgcmVkcmF3cyB3aXRoaW4gdGhlIGNoYXJ0J3MgZ3JvdXAuXHJcbiAqIEByZXR1cm5zIHtkYy5waWVDaGFydH1cclxuICovXHJcbmRjLnBpZUNoYXJ0ID0gZnVuY3Rpb24gKHBhcmVudCwgY2hhcnRHcm91cCkge1xyXG4gICAgdmFyIERFRkFVTFRfTUlOX0FOR0xFX0ZPUl9MQUJFTCA9IDAuNTtcclxuXHJcbiAgICB2YXIgX3NsaWNlQ3NzQ2xhc3MgPSAncGllLXNsaWNlJztcclxuICAgIHZhciBfbGFiZWxDc3NDbGFzcyA9ICdwaWUtbGFiZWwnO1xyXG4gICAgdmFyIF9zbGljZUdyb3VwQ3NzQ2xhc3MgPSAncGllLXNsaWNlLWdyb3VwJztcclxuICAgIHZhciBfbGFiZWxHcm91cENzc0NsYXNzID0gJ3BpZS1sYWJlbC1ncm91cCc7XHJcbiAgICB2YXIgX2VtcHR5Q3NzQ2xhc3MgPSAnZW1wdHktY2hhcnQnO1xyXG4gICAgdmFyIF9lbXB0eVRpdGxlID0gJ2VtcHR5JztcclxuXHJcbiAgICB2YXIgX3JhZGl1cyxcclxuICAgICAgICBfZ2l2ZW5SYWRpdXMsIC8vIHNwZWNpZmllZCByYWRpdXMsIGlmIGFueVxyXG4gICAgICAgIF9pbm5lclJhZGl1cyA9IDAsXHJcbiAgICAgICAgX2V4dGVybmFsUmFkaXVzUGFkZGluZyA9IDA7XHJcblxyXG4gICAgdmFyIF9nO1xyXG4gICAgdmFyIF9jeDtcclxuICAgIHZhciBfY3k7XHJcbiAgICB2YXIgX21pbkFuZ2xlRm9yTGFiZWwgPSBERUZBVUxUX01JTl9BTkdMRV9GT1JfTEFCRUw7XHJcbiAgICB2YXIgX2V4dGVybmFsTGFiZWxSYWRpdXM7XHJcbiAgICB2YXIgX2RyYXdQYXRocyA9IGZhbHNlO1xyXG4gICAgdmFyIF9jaGFydCA9IGRjLmNhcE1peGluKGRjLmNvbG9yTWl4aW4oZGMuYmFzZU1peGluKHt9KSkpO1xyXG5cclxuICAgIF9jaGFydC5jb2xvckFjY2Vzc29yKF9jaGFydC5jYXBwZWRLZXlBY2Nlc3Nvcik7XHJcblxyXG4gICAgX2NoYXJ0LnRpdGxlKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydC5jYXBwZWRLZXlBY2Nlc3NvcihkKSArICc6ICcgKyBfY2hhcnQuY2FwcGVkVmFsdWVBY2Nlc3NvcihkKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IG9yIHNldCB0aGUgbWF4aW11bSBudW1iZXIgb2Ygc2xpY2VzIHRoZSBwaWUgY2hhcnQgd2lsbCBnZW5lcmF0ZS4gVGhlIHRvcCBzbGljZXMgYXJlIGRldGVybWluZWQgYnlcclxuICAgICAqIHZhbHVlIGZyb20gaGlnaCB0byBsb3cuIE90aGVyIHNsaWNlcyBleGVlZGluZyB0aGUgY2FwIHdpbGwgYmUgcm9sbGVkIHVwIGludG8gb25lIHNpbmdsZSAqT3RoZXJzKiBzbGljZS5cclxuICAgICAqIEBtZXRob2Qgc2xpY2VzQ2FwXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMucGllQ2hhcnRcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjYXBdXHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfGRjLnBpZUNoYXJ0fVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQuc2xpY2VzQ2FwID0gX2NoYXJ0LmNhcDtcclxuXHJcbiAgICBfY2hhcnQubGFiZWwoX2NoYXJ0LmNhcHBlZEtleUFjY2Vzc29yKTtcclxuICAgIF9jaGFydC5yZW5kZXJMYWJlbCh0cnVlKTtcclxuXHJcbiAgICBfY2hhcnQudHJhbnNpdGlvbkR1cmF0aW9uKDM1MCk7XHJcbiAgICBfY2hhcnQudHJhbnNpdGlvbkRlbGF5KDApO1xyXG5cclxuICAgIF9jaGFydC5fZG9SZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX2NoYXJ0LnJlc2V0U3ZnKCk7XHJcblxyXG4gICAgICAgIF9nID0gX2NoYXJ0LnN2ZygpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgX2NoYXJ0LmN4KCkgKyAnLCcgKyBfY2hhcnQuY3koKSArICcpJyk7XHJcblxyXG4gICAgICAgIF9nLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgX3NsaWNlR3JvdXBDc3NDbGFzcyk7XHJcbiAgICAgICAgX2cuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCBfbGFiZWxHcm91cENzc0NsYXNzKTtcclxuXHJcbiAgICAgICAgZHJhd0NoYXJ0KCk7XHJcblxyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGRyYXdDaGFydCAoKSB7XHJcbiAgICAgICAgLy8gc2V0IHJhZGl1cyBmcm9tIGNoYXJ0IHNpemUgaWYgbm9uZSBnaXZlbiwgb3IgaWYgZ2l2ZW4gcmFkaXVzIGlzIHRvbyBsYXJnZVxyXG4gICAgICAgIHZhciBtYXhSYWRpdXMgPSAgZDMubWluKFtfY2hhcnQud2lkdGgoKSwgX2NoYXJ0LmhlaWdodCgpXSkgLyAyO1xyXG4gICAgICAgIF9yYWRpdXMgPSBfZ2l2ZW5SYWRpdXMgJiYgX2dpdmVuUmFkaXVzIDwgbWF4UmFkaXVzID8gX2dpdmVuUmFkaXVzIDogbWF4UmFkaXVzO1xyXG5cclxuICAgICAgICB2YXIgYXJjID0gYnVpbGRBcmNzKCk7XHJcblxyXG4gICAgICAgIHZhciBwaWUgPSBwaWVMYXlvdXQoKTtcclxuICAgICAgICB2YXIgcGllRGF0YTtcclxuICAgICAgICAvLyBpZiB3ZSBoYXZlIGRhdGEuLi5cclxuICAgICAgICBpZiAoZDMuc3VtKF9jaGFydC5kYXRhKCksIF9jaGFydC52YWx1ZUFjY2Vzc29yKCkpKSB7XHJcbiAgICAgICAgICAgIHBpZURhdGEgPSBwaWUoX2NoYXJ0LmRhdGEoKSk7XHJcbiAgICAgICAgICAgIF9nLmNsYXNzZWQoX2VtcHR5Q3NzQ2xhc3MsIGZhbHNlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBvdGhlcndpc2Ugd2UnZCBiZSBnZXR0aW5nIE5hTnMsIHNvIG92ZXJyaWRlXHJcbiAgICAgICAgICAgIC8vIG5vdGU6IGFidXNlIG90aGVycyBmb3IgaXRzIGlnbm9yaW5nIHRoZSB2YWx1ZSBhY2Nlc3NvclxyXG4gICAgICAgICAgICBwaWVEYXRhID0gcGllKFt7a2V5OiBfZW1wdHlUaXRsZSwgdmFsdWU6IDEsIG90aGVyczogW19lbXB0eVRpdGxlXX1dKTtcclxuICAgICAgICAgICAgX2cuY2xhc3NlZChfZW1wdHlDc3NDbGFzcywgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoX2cpIHtcclxuICAgICAgICAgICAgdmFyIHNsaWNlcyA9IF9nLnNlbGVjdCgnZy4nICsgX3NsaWNlR3JvdXBDc3NDbGFzcylcclxuICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ2cuJyArIF9zbGljZUNzc0NsYXNzKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEocGllRGF0YSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgbGFiZWxzID0gX2cuc2VsZWN0KCdnLicgKyBfbGFiZWxHcm91cENzc0NsYXNzKVxyXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgndGV4dC4nICsgX2xhYmVsQ3NzQ2xhc3MpXHJcbiAgICAgICAgICAgICAgICAuZGF0YShwaWVEYXRhKTtcclxuXHJcbiAgICAgICAgICAgIHJlbW92ZUVsZW1lbnRzKHNsaWNlcywgbGFiZWxzKTtcclxuXHJcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnRzKHNsaWNlcywgbGFiZWxzLCBhcmMsIHBpZURhdGEpO1xyXG5cclxuICAgICAgICAgICAgdXBkYXRlRWxlbWVudHMocGllRGF0YSwgYXJjKTtcclxuXHJcbiAgICAgICAgICAgIGhpZ2hsaWdodEZpbHRlcigpO1xyXG5cclxuICAgICAgICAgICAgZGMudHJhbnNpdGlvbihfZywgX2NoYXJ0LnRyYW5zaXRpb25EdXJhdGlvbigpLCBfY2hhcnQudHJhbnNpdGlvbkRlbGF5KCkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgX2NoYXJ0LmN4KCkgKyAnLCcgKyBfY2hhcnQuY3koKSArICcpJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRzIChzbGljZXMsIGxhYmVscywgYXJjLCBwaWVEYXRhKSB7XHJcbiAgICAgICAgdmFyIHNsaWNlc0VudGVyID0gY3JlYXRlU2xpY2VOb2RlcyhzbGljZXMpO1xyXG5cclxuICAgICAgICBjcmVhdGVTbGljZVBhdGgoc2xpY2VzRW50ZXIsIGFyYyk7XHJcblxyXG4gICAgICAgIGNyZWF0ZVRpdGxlcyhzbGljZXNFbnRlcik7XHJcblxyXG4gICAgICAgIGNyZWF0ZUxhYmVscyhsYWJlbHMsIHBpZURhdGEsIGFyYyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlU2xpY2VOb2RlcyAoc2xpY2VzKSB7XHJcbiAgICAgICAgdmFyIHNsaWNlc0VudGVyID0gc2xpY2VzXHJcbiAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zbGljZUNzc0NsYXNzICsgJyBfJyArIGk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBzbGljZXNFbnRlcjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVTbGljZVBhdGggKHNsaWNlc0VudGVyLCBhcmMpIHtcclxuICAgICAgICB2YXIgc2xpY2VQYXRoID0gc2xpY2VzRW50ZXIuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCBmaWxsKVxyXG4gICAgICAgICAgICAub24oJ2NsaWNrJywgb25DbGljaylcclxuICAgICAgICAgICAgLmF0dHIoJ2QnLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNhZmVBcmMoZCwgaSwgYXJjKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHZhciB0cmFuc2l0aW9uID0gZGMudHJhbnNpdGlvbihzbGljZVBhdGgsIF9jaGFydC50cmFuc2l0aW9uRHVyYXRpb24oKSwgX2NoYXJ0LnRyYW5zaXRpb25EZWxheSgpKTtcclxuICAgICAgICBpZiAodHJhbnNpdGlvbi5hdHRyVHdlZW4pIHtcclxuICAgICAgICAgICAgdHJhbnNpdGlvbi5hdHRyVHdlZW4oJ2QnLCB0d2VlblBpZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZVRpdGxlcyAoc2xpY2VzRW50ZXIpIHtcclxuICAgICAgICBpZiAoX2NoYXJ0LnJlbmRlclRpdGxlKCkpIHtcclxuICAgICAgICAgICAgc2xpY2VzRW50ZXIuYXBwZW5kKCd0aXRsZScpLnRleHQoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfY2hhcnQudGl0bGUoKShkLmRhdGEpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgX2NoYXJ0Ll9hcHBseUxhYmVsVGV4dCA9IGZ1bmN0aW9uIChsYWJlbHMpIHtcclxuICAgICAgICBsYWJlbHNcclxuICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gZC5kYXRhO1xyXG4gICAgICAgICAgICAgICAgaWYgKChzbGljZUhhc05vRGF0YShkYXRhKSB8fCBzbGljZVRvb1NtYWxsKGQpKSAmJiAhaXNTZWxlY3RlZFNsaWNlKGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jaGFydC5sYWJlbCgpKGQuZGF0YSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBwb3NpdGlvbkxhYmVscyAobGFiZWxzLCBhcmMpIHtcclxuICAgICAgICBfY2hhcnQuX2FwcGx5TGFiZWxUZXh0KGxhYmVscyk7XHJcbiAgICAgICAgZGMudHJhbnNpdGlvbihsYWJlbHMsIF9jaGFydC50cmFuc2l0aW9uRHVyYXRpb24oKSwgX2NoYXJ0LnRyYW5zaXRpb25EZWxheSgpKVxyXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsYWJlbFBvc2l0aW9uKGQsIGFyYyk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBoaWdobGlnaHRTbGljZSAoaSwgd2hldGhlcikge1xyXG4gICAgICAgIF9jaGFydC5zZWxlY3QoJ2cucGllLXNsaWNlLl8nICsgaSlcclxuICAgICAgICAgICAgLmNsYXNzZWQoJ2hpZ2hsaWdodCcsIHdoZXRoZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxhYmVscyAobGFiZWxzLCBwaWVEYXRhLCBhcmMpIHtcclxuICAgICAgICBpZiAoX2NoYXJ0LnJlbmRlckxhYmVsKCkpIHtcclxuICAgICAgICAgICAgdmFyIGxhYmVsc0VudGVyID0gbGFiZWxzXHJcbiAgICAgICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjbGFzc2VzID0gX3NsaWNlQ3NzQ2xhc3MgKyAnICcgKyBfbGFiZWxDc3NDbGFzcyArICcgXycgKyBpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfZXh0ZXJuYWxMYWJlbFJhZGl1cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc2VzICs9ICcgZXh0ZXJuYWwnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xhc3NlcztcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAub24oJ2NsaWNrJywgb25DbGljaylcclxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHRTbGljZShpLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHRTbGljZShpLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcG9zaXRpb25MYWJlbHMobGFiZWxzRW50ZXIsIGFyYyk7XHJcbiAgICAgICAgICAgIGlmIChfZXh0ZXJuYWxMYWJlbFJhZGl1cyAmJiBfZHJhd1BhdGhzKSB7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVMYWJlbFBhdGhzKHBpZURhdGEsIGFyYyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdXBkYXRlTGFiZWxQYXRocyAocGllRGF0YSwgYXJjKSB7XHJcbiAgICAgICAgdmFyIHBvbHlsaW5lID0gX2cuc2VsZWN0QWxsKCdwb2x5bGluZS4nICsgX3NsaWNlQ3NzQ2xhc3MpXHJcbiAgICAgICAgICAgICAgICAuZGF0YShwaWVEYXRhKTtcclxuXHJcbiAgICAgICAgcG9seWxpbmUuZXhpdCgpLnJlbW92ZSgpO1xyXG5cclxuICAgICAgICBwb2x5bGluZSA9IHBvbHlsaW5lXHJcbiAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3BvbHlsaW5lJylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAncGllLXBhdGggXycgKyBpICsgJyAnICsgX3NsaWNlQ3NzQ2xhc3M7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5vbignY2xpY2snLCBvbkNsaWNrKVxyXG4gICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICAgICAgICBoaWdobGlnaHRTbGljZShpLCB0cnVlKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICAgICAgICBoaWdobGlnaHRTbGljZShpLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5tZXJnZShwb2x5bGluZSk7XHJcblxyXG4gICAgICAgIHZhciBhcmMyID0gZDMuYXJjKClcclxuICAgICAgICAgICAgICAgIC5vdXRlclJhZGl1cyhfcmFkaXVzIC0gX2V4dGVybmFsUmFkaXVzUGFkZGluZyArIF9leHRlcm5hbExhYmVsUmFkaXVzKVxyXG4gICAgICAgICAgICAgICAgLmlubmVyUmFkaXVzKF9yYWRpdXMgLSBfZXh0ZXJuYWxSYWRpdXNQYWRkaW5nKTtcclxuICAgICAgICB2YXIgdHJhbnNpdGlvbiA9IGRjLnRyYW5zaXRpb24ocG9seWxpbmUsIF9jaGFydC50cmFuc2l0aW9uRHVyYXRpb24oKSwgX2NoYXJ0LnRyYW5zaXRpb25EZWxheSgpKTtcclxuICAgICAgICAvLyB0aGlzIGlzIG9uZSByYXJlIGNhc2Ugd2hlcmUgZDMuc2VsZWN0aW9uIGRpZmZlcnMgZnJvbSBkMy50cmFuc2l0aW9uXHJcbiAgICAgICAgaWYgKHRyYW5zaXRpb24uYXR0clR3ZWVuKSB7XHJcbiAgICAgICAgICAgIHRyYW5zaXRpb25cclxuICAgICAgICAgICAgICAgIC5hdHRyVHdlZW4oJ3BvaW50cycsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLl9jdXJyZW50IHx8IGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IHtzdGFydEFuZ2xlOiBjdXJyZW50LnN0YXJ0QW5nbGUsIGVuZEFuZ2xlOiBjdXJyZW50LmVuZEFuZ2xlfTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW50ZXJwb2xhdGUgPSBkMy5pbnRlcnBvbGF0ZShjdXJyZW50LCBkKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50ID0gaW50ZXJwb2xhdGUoMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkMiA9IGludGVycG9sYXRlKHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2FyYy5jZW50cm9pZChkMiksIGFyYzIuY2VudHJvaWQoZDIpXTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdHJhbnNpdGlvbi5hdHRyKCdwb2ludHMnLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFthcmMuY2VudHJvaWQoZCksIGFyYzIuY2VudHJvaWQoZCldO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJhbnNpdGlvbi5zdHlsZSgndmlzaWJpbGl0eScsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkLmVuZEFuZ2xlIC0gZC5zdGFydEFuZ2xlIDwgMC4wMDAxID8gJ2hpZGRlbicgOiAndmlzaWJsZSc7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZUVsZW1lbnRzIChwaWVEYXRhLCBhcmMpIHtcclxuICAgICAgICB1cGRhdGVTbGljZVBhdGhzKHBpZURhdGEsIGFyYyk7XHJcbiAgICAgICAgdXBkYXRlTGFiZWxzKHBpZURhdGEsIGFyYyk7XHJcbiAgICAgICAgdXBkYXRlVGl0bGVzKHBpZURhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZVNsaWNlUGF0aHMgKHBpZURhdGEsIGFyYykge1xyXG4gICAgICAgIHZhciBzbGljZVBhdGhzID0gX2cuc2VsZWN0QWxsKCdnLicgKyBfc2xpY2VDc3NDbGFzcylcclxuICAgICAgICAgICAgLmRhdGEocGllRGF0YSlcclxuICAgICAgICAgICAgLnNlbGVjdCgncGF0aCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdkJywgZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzYWZlQXJjKGQsIGksIGFyYyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIHZhciB0cmFuc2l0aW9uID0gZGMudHJhbnNpdGlvbihzbGljZVBhdGhzLCBfY2hhcnQudHJhbnNpdGlvbkR1cmF0aW9uKCksIF9jaGFydC50cmFuc2l0aW9uRGVsYXkoKSk7XHJcbiAgICAgICAgaWYgKHRyYW5zaXRpb24uYXR0clR3ZWVuKSB7XHJcbiAgICAgICAgICAgIHRyYW5zaXRpb24uYXR0clR3ZWVuKCdkJywgdHdlZW5QaWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cmFuc2l0aW9uLmF0dHIoJ2ZpbGwnLCBmaWxsKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB1cGRhdGVMYWJlbHMgKHBpZURhdGEsIGFyYykge1xyXG4gICAgICAgIGlmIChfY2hhcnQucmVuZGVyTGFiZWwoKSkge1xyXG4gICAgICAgICAgICB2YXIgbGFiZWxzID0gX2cuc2VsZWN0QWxsKCd0ZXh0LicgKyBfbGFiZWxDc3NDbGFzcylcclxuICAgICAgICAgICAgICAgIC5kYXRhKHBpZURhdGEpO1xyXG4gICAgICAgICAgICBwb3NpdGlvbkxhYmVscyhsYWJlbHMsIGFyYyk7XHJcbiAgICAgICAgICAgIGlmIChfZXh0ZXJuYWxMYWJlbFJhZGl1cyAmJiBfZHJhd1BhdGhzKSB7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVMYWJlbFBhdGhzKHBpZURhdGEsIGFyYyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdXBkYXRlVGl0bGVzIChwaWVEYXRhKSB7XHJcbiAgICAgICAgaWYgKF9jaGFydC5yZW5kZXJUaXRsZSgpKSB7XHJcbiAgICAgICAgICAgIF9nLnNlbGVjdEFsbCgnZy4nICsgX3NsaWNlQ3NzQ2xhc3MpXHJcbiAgICAgICAgICAgICAgICAuZGF0YShwaWVEYXRhKVxyXG4gICAgICAgICAgICAgICAgLnNlbGVjdCgndGl0bGUnKVxyXG4gICAgICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NoYXJ0LnRpdGxlKCkoZC5kYXRhKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZW1vdmVFbGVtZW50cyAoc2xpY2VzLCBsYWJlbHMpIHtcclxuICAgICAgICBzbGljZXMuZXhpdCgpLnJlbW92ZSgpO1xyXG4gICAgICAgIGxhYmVscy5leGl0KCkucmVtb3ZlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaGlnaGxpZ2h0RmlsdGVyICgpIHtcclxuICAgICAgICBpZiAoX2NoYXJ0Lmhhc0ZpbHRlcigpKSB7XHJcbiAgICAgICAgICAgIF9jaGFydC5zZWxlY3RBbGwoJ2cuJyArIF9zbGljZUNzc0NsYXNzKS5lYWNoKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNTZWxlY3RlZFNsaWNlKGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2NoYXJ0LmhpZ2hsaWdodFNlbGVjdGVkKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBfY2hhcnQuZmFkZURlc2VsZWN0ZWQodGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIF9jaGFydC5zZWxlY3RBbGwoJ2cuJyArIF9zbGljZUNzc0NsYXNzKS5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF9jaGFydC5yZXNldEhpZ2hsaWdodCh0aGlzKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IG9yIHNldCB0aGUgZXh0ZXJuYWwgcmFkaXVzIHBhZGRpbmcgb2YgdGhlIHBpZSBjaGFydC4gVGhpcyB3aWxsIGZvcmNlIHRoZSByYWRpdXMgb2YgdGhlXHJcbiAgICAgKiBwaWUgY2hhcnQgdG8gYmVjb21lIHNtYWxsZXIgb3IgbGFyZ2VyIGRlcGVuZGluZyBvbiB0aGUgdmFsdWUuXHJcbiAgICAgKiBAbWV0aG9kIGV4dGVybmFsUmFkaXVzUGFkZGluZ1xyXG4gICAgICogQG1lbWJlcm9mIGRjLnBpZUNoYXJ0XHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZXh0ZXJuYWxSYWRpdXNQYWRkaW5nPTBdXHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfGRjLnBpZUNoYXJ0fVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQuZXh0ZXJuYWxSYWRpdXNQYWRkaW5nID0gZnVuY3Rpb24gKGV4dGVybmFsUmFkaXVzUGFkZGluZykge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2V4dGVybmFsUmFkaXVzUGFkZGluZztcclxuICAgICAgICB9XHJcbiAgICAgICAgX2V4dGVybmFsUmFkaXVzUGFkZGluZyA9IGV4dGVybmFsUmFkaXVzUGFkZGluZztcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBvciBzZXQgdGhlIGlubmVyIHJhZGl1cyBvZiB0aGUgcGllIGNoYXJ0LiBJZiB0aGUgaW5uZXIgcmFkaXVzIGlzIGdyZWF0ZXIgdGhhbiAwcHggdGhlbiB0aGVcclxuICAgICAqIHBpZSBjaGFydCB3aWxsIGJlIHJlbmRlcmVkIGFzIGEgZG91Z2hudXQgY2hhcnQuXHJcbiAgICAgKiBAbWV0aG9kIGlubmVyUmFkaXVzXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMucGllQ2hhcnRcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtpbm5lclJhZGl1cz0wXVxyXG4gICAgICogQHJldHVybnMge051bWJlcnxkYy5waWVDaGFydH1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LmlubmVyUmFkaXVzID0gZnVuY3Rpb24gKGlubmVyUmFkaXVzKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfaW5uZXJSYWRpdXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9pbm5lclJhZGl1cyA9IGlubmVyUmFkaXVzO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IG9yIHNldCB0aGUgb3V0ZXIgcmFkaXVzLiBJZiB0aGUgcmFkaXVzIGlzIG5vdCBzZXQsIGl0IHdpbGwgYmUgaGFsZiBvZiB0aGUgbWluaW11bSBvZiB0aGVcclxuICAgICAqIGNoYXJ0IHdpZHRoIGFuZCBoZWlnaHQuXHJcbiAgICAgKiBAbWV0aG9kIHJhZGl1c1xyXG4gICAgICogQG1lbWJlcm9mIGRjLnBpZUNoYXJ0XHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcmFkaXVzXVxyXG4gICAgICogQHJldHVybnMge051bWJlcnxkYy5waWVDaGFydH1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LnJhZGl1cyA9IGZ1bmN0aW9uIChyYWRpdXMpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9naXZlblJhZGl1cztcclxuICAgICAgICB9XHJcbiAgICAgICAgX2dpdmVuUmFkaXVzID0gcmFkaXVzO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IG9yIHNldCBjZW50ZXIgeCBjb29yZGluYXRlIHBvc2l0aW9uLiBEZWZhdWx0IGlzIGNlbnRlciBvZiBzdmcuXHJcbiAgICAgKiBAbWV0aG9kIGN4XHJcbiAgICAgKiBAbWVtYmVyb2YgZGMucGllQ2hhcnRcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjeF1cclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ8ZGMucGllQ2hhcnR9XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5jeCA9IGZ1bmN0aW9uIChjeCkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKF9jeCB8fCAgX2NoYXJ0LndpZHRoKCkgLyAyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX2N4ID0gY3g7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgb3Igc2V0IGNlbnRlciB5IGNvb3JkaW5hdGUgcG9zaXRpb24uIERlZmF1bHQgaXMgY2VudGVyIG9mIHN2Zy5cclxuICAgICAqIEBtZXRob2QgY3lcclxuICAgICAqIEBtZW1iZXJvZiBkYy5waWVDaGFydFxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2N5XVxyXG4gICAgICogQHJldHVybnMge051bWJlcnxkYy5waWVDaGFydH1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LmN5ID0gZnVuY3Rpb24gKGN5KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoX2N5IHx8ICBfY2hhcnQuaGVpZ2h0KCkgLyAyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX2N5ID0gY3k7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gYnVpbGRBcmNzICgpIHtcclxuICAgICAgICByZXR1cm4gZDMuYXJjKClcclxuICAgICAgICAgICAgLm91dGVyUmFkaXVzKF9yYWRpdXMgLSBfZXh0ZXJuYWxSYWRpdXNQYWRkaW5nKVxyXG4gICAgICAgICAgICAuaW5uZXJSYWRpdXMoX2lubmVyUmFkaXVzKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpc1NlbGVjdGVkU2xpY2UgKGQpIHtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0Lmhhc0ZpbHRlcihfY2hhcnQuY2FwcGVkS2V5QWNjZXNzb3IoZC5kYXRhKSk7XHJcbiAgICB9XHJcblxyXG4gICAgX2NoYXJ0Ll9kb1JlZHJhdyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBkcmF3Q2hhcnQoKTtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBvciBzZXQgdGhlIG1pbmltYWwgc2xpY2UgYW5nbGUgZm9yIGxhYmVsIHJlbmRlcmluZy4gQW55IHNsaWNlIHdpdGggYSBzbWFsbGVyIGFuZ2xlIHdpbGwgbm90XHJcbiAgICAgKiBkaXNwbGF5IGEgc2xpY2UgbGFiZWwuXHJcbiAgICAgKiBAbWV0aG9kIG1pbkFuZ2xlRm9yTGFiZWxcclxuICAgICAqIEBtZW1iZXJvZiBkYy5waWVDaGFydFxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW21pbkFuZ2xlRm9yTGFiZWw9MC41XVxyXG4gICAgICogQHJldHVybnMge051bWJlcnxkYy5waWVDaGFydH1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0Lm1pbkFuZ2xlRm9yTGFiZWwgPSBmdW5jdGlvbiAobWluQW5nbGVGb3JMYWJlbCkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX21pbkFuZ2xlRm9yTGFiZWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9taW5BbmdsZUZvckxhYmVsID0gbWluQW5nbGVGb3JMYWJlbDtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBwaWVMYXlvdXQgKCkge1xyXG4gICAgICAgIHJldHVybiBkMy5waWUoKS5zb3J0KG51bGwpLnZhbHVlKF9jaGFydC5jYXBwZWRWYWx1ZUFjY2Vzc29yKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzbGljZVRvb1NtYWxsIChkKSB7XHJcbiAgICAgICAgdmFyIGFuZ2xlID0gKGQuZW5kQW5nbGUgLSBkLnN0YXJ0QW5nbGUpO1xyXG4gICAgICAgIHJldHVybiBpc05hTihhbmdsZSkgfHwgYW5nbGUgPCBfbWluQW5nbGVGb3JMYWJlbDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzbGljZUhhc05vRGF0YSAoZCkge1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQuY2FwcGVkVmFsdWVBY2Nlc3NvcihkKSA9PT0gMDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0d2VlblBpZSAoYikge1xyXG4gICAgICAgIGIuaW5uZXJSYWRpdXMgPSBfaW5uZXJSYWRpdXM7XHJcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLl9jdXJyZW50O1xyXG4gICAgICAgIGlmIChpc09mZkNhbnZhcyhjdXJyZW50KSkge1xyXG4gICAgICAgICAgICBjdXJyZW50ID0ge3N0YXJ0QW5nbGU6IDAsIGVuZEFuZ2xlOiAwfTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBvbmx5IGludGVycG9sYXRlIHN0YXJ0QW5nbGUgJiBlbmRBbmdsZSwgbm90IHRoZSB3aG9sZSBkYXRhIG9iamVjdFxyXG4gICAgICAgICAgICBjdXJyZW50ID0ge3N0YXJ0QW5nbGU6IGN1cnJlbnQuc3RhcnRBbmdsZSwgZW5kQW5nbGU6IGN1cnJlbnQuZW5kQW5nbGV9O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaSA9IGQzLmludGVycG9sYXRlKGN1cnJlbnQsIGIpO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnQgPSBpKDApO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc2FmZUFyYyhpKHQpLCAwLCBidWlsZEFyY3MoKSk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpc09mZkNhbnZhcyAoY3VycmVudCkge1xyXG4gICAgICAgIHJldHVybiAhY3VycmVudCB8fCBpc05hTihjdXJyZW50LnN0YXJ0QW5nbGUpIHx8IGlzTmFOKGN1cnJlbnQuZW5kQW5nbGUpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGZpbGwgKGQsIGkpIHtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0LmdldENvbG9yKGQuZGF0YSwgaSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gb25DbGljayAoZCwgaSkge1xyXG4gICAgICAgIGlmIChfZy5hdHRyKCdjbGFzcycpICE9PSBfZW1wdHlDc3NDbGFzcykge1xyXG4gICAgICAgICAgICBfY2hhcnQub25DbGljayhkLmRhdGEsIGkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzYWZlQXJjIChkLCBpLCBhcmMpIHtcclxuICAgICAgICB2YXIgcGF0aCA9IGFyYyhkLCBpKTtcclxuICAgICAgICBpZiAocGF0aC5pbmRleE9mKCdOYU4nKSA+PSAwKSB7XHJcbiAgICAgICAgICAgIHBhdGggPSAnTTAsMCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXRoO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGl0bGUgdG8gdXNlIGZvciB0aGUgb25seSBzbGljZSB3aGVuIHRoZXJlIGlzIG5vIGRhdGEuXHJcbiAgICAgKiBAbWV0aG9kIGVtcHR5VGl0bGVcclxuICAgICAqIEBtZW1iZXJvZiBkYy5waWVDaGFydFxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3RpdGxlXVxyXG4gICAgICogQHJldHVybnMge1N0cmluZ3xkYy5waWVDaGFydH1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LmVtcHR5VGl0bGUgPSBmdW5jdGlvbiAodGl0bGUpIHtcclxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2VtcHR5VGl0bGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9lbXB0eVRpdGxlID0gdGl0bGU7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQb3NpdGlvbiBzbGljZSBsYWJlbHMgb2Zmc2V0IGZyb20gdGhlIG91dGVyIGVkZ2Ugb2YgdGhlIGNoYXJ0LlxyXG4gICAgICpcclxuICAgICAqIFRoZSBhcmd1bWVudCBzcGVjaWZpZXMgdGhlIGV4dHJhIHJhZGl1cyB0byBiZSBhZGRlZCBmb3Igc2xpY2UgbGFiZWxzLlxyXG4gICAgICogQG1ldGhvZCBleHRlcm5hbExhYmVsc1xyXG4gICAgICogQG1lbWJlcm9mIGRjLnBpZUNoYXJ0XHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZXh0ZXJuYWxMYWJlbFJhZGl1c11cclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ8ZGMucGllQ2hhcnR9XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5leHRlcm5hbExhYmVscyA9IGZ1bmN0aW9uIChleHRlcm5hbExhYmVsUmFkaXVzKSB7XHJcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9leHRlcm5hbExhYmVsUmFkaXVzO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZXh0ZXJuYWxMYWJlbFJhZGl1cykge1xyXG4gICAgICAgICAgICBfZXh0ZXJuYWxMYWJlbFJhZGl1cyA9IGV4dGVybmFsTGFiZWxSYWRpdXM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgX2V4dGVybmFsTGFiZWxSYWRpdXMgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBvciBzZXQgd2hldGhlciB0byBkcmF3IGxpbmVzIGZyb20gcGllIHNsaWNlcyB0byB0aGVpciBsYWJlbHMuXHJcbiAgICAgKlxyXG4gICAgICogQG1ldGhvZCBkcmF3UGF0aHNcclxuICAgICAqIEBtZW1iZXJvZiBkYy5waWVDaGFydFxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtkcmF3UGF0aHNdXHJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbnxkYy5waWVDaGFydH1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LmRyYXdQYXRocyA9IGZ1bmN0aW9uIChkcmF3UGF0aHMpIHtcclxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2RyYXdQYXRocztcclxuICAgICAgICB9XHJcbiAgICAgICAgX2RyYXdQYXRocyA9IGRyYXdQYXRocztcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBsYWJlbFBvc2l0aW9uIChkLCBhcmMpIHtcclxuICAgICAgICB2YXIgY2VudHJvaWQ7XHJcbiAgICAgICAgaWYgKF9leHRlcm5hbExhYmVsUmFkaXVzKSB7XHJcbiAgICAgICAgICAgIGNlbnRyb2lkID0gZDMuYXJjKClcclxuICAgICAgICAgICAgICAgIC5vdXRlclJhZGl1cyhfcmFkaXVzIC0gX2V4dGVybmFsUmFkaXVzUGFkZGluZyArIF9leHRlcm5hbExhYmVsUmFkaXVzKVxyXG4gICAgICAgICAgICAgICAgLmlubmVyUmFkaXVzKF9yYWRpdXMgLSBfZXh0ZXJuYWxSYWRpdXNQYWRkaW5nICsgX2V4dGVybmFsTGFiZWxSYWRpdXMpXHJcbiAgICAgICAgICAgICAgICAuY2VudHJvaWQoZCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY2VudHJvaWQgPSBhcmMuY2VudHJvaWQoZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc05hTihjZW50cm9pZFswXSkgfHwgaXNOYU4oY2VudHJvaWRbMV0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKDAsMCknO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyBjZW50cm9pZCArICcpJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgX2NoYXJ0LmxlZ2VuZGFibGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQuZGF0YSgpLm1hcChmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICB2YXIgbGVnZW5kYWJsZSA9IHtuYW1lOiBkLmtleSwgZGF0YTogZC52YWx1ZSwgb3RoZXJzOiBkLm90aGVycywgY2hhcnQ6IF9jaGFydH07XHJcbiAgICAgICAgICAgIGxlZ2VuZGFibGUuY29sb3IgPSBfY2hhcnQuZ2V0Q29sb3IoZCwgaSk7XHJcbiAgICAgICAgICAgIHJldHVybiBsZWdlbmRhYmxlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBfY2hhcnQubGVnZW5kSGlnaGxpZ2h0ID0gZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICBoaWdobGlnaHRTbGljZUZyb21MZWdlbmRhYmxlKGQsIHRydWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfY2hhcnQubGVnZW5kUmVzZXQgPSBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIGhpZ2hsaWdodFNsaWNlRnJvbUxlZ2VuZGFibGUoZCwgZmFsc2UpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfY2hhcnQubGVnZW5kVG9nZ2xlID0gZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICBfY2hhcnQub25DbGljayh7a2V5OiBkLm5hbWUsIG90aGVyczogZC5vdGhlcnN9KTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gaGlnaGxpZ2h0U2xpY2VGcm9tTGVnZW5kYWJsZSAobGVnZW5kYWJsZSwgaGlnaGxpZ2h0ZWQpIHtcclxuICAgICAgICBfY2hhcnQuc2VsZWN0QWxsKCdnLnBpZS1zbGljZScpLmVhY2goZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgaWYgKGxlZ2VuZGFibGUubmFtZSA9PT0gZC5kYXRhLmtleSkge1xyXG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNsYXNzZWQoJ2hpZ2hsaWdodCcsIGhpZ2hsaWdodGVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBfY2hhcnQuYW5jaG9yKHBhcmVudCwgY2hhcnRHcm91cCk7XHJcbn07XHJcblxyXG4vKipcclxuICogVGhlIHN1bmJ1cnN0IGNoYXJ0IGltcGxlbWVudGF0aW9uIGlzIHVzdWFsbHkgdXNlZCB0byB2aXN1YWxpemUgYSBzbWFsbCB0cmVlIGRpc3RyaWJ1dGlvbi4gIFRoZSBzdW5idXJzdFxyXG4gKiBjaGFydCB1c2VzIGtleUFjY2Vzc29yIHRvIGRldGVybWluZSB0aGUgc2xpY2VzLCBhbmQgdmFsdWVBY2Nlc3NvciB0byBjYWxjdWxhdGUgdGhlIHNpemUgb2YgZWFjaFxyXG4gKiBzbGljZSByZWxhdGl2ZSB0byB0aGUgc3VtIG9mIGFsbCB2YWx1ZXMuIFNsaWNlcyBhcmUgb3JkZXJlZCBieSB7QGxpbmsgZGMuYmFzZU1peGluI29yZGVyaW5nIG9yZGVyaW5nfSB3aGljaCBkZWZhdWx0cyB0byBzb3J0aW5nXHJcbiAqIGJ5IGtleS5cclxuICpcclxuICogVGhlIGtleXMgdXNlZCBpbiB0aGUgc3VuYnVyc3QgY2hhcnQgc2hvdWxkIGJlIGFycmF5cywgcmVwcmVzZW50aW5nIHBhdGhzIGluIHRoZSB0cmVlLlxyXG4gKlxyXG4gKiBXaGVuIGZpbHRlcmluZywgdGhlIHN1bmJ1cnN0IGNoYXJ0IGNyZWF0ZXMgaW5zdGFuY2VzIG9mIHtAbGluayBkYy5maWx0ZXJzLkhpZXJhcmNoeUZpbHRlciBIaWVyYXJjaHlGaWx0ZXJ9LlxyXG4gKlxyXG4gKiBAY2xhc3Mgc3VuYnVyc3RDaGFydFxyXG4gKiBAbWVtYmVyb2YgZGNcclxuICogQG1peGVzIGRjLmNhcE1peGluXHJcbiAqIEBtaXhlcyBkYy5jb2xvck1peGluXHJcbiAqIEBtaXhlcyBkYy5iYXNlTWl4aW5cclxuICogQGV4YW1wbGVcclxuICogLy8gY3JlYXRlIGEgc3VuYnVyc3QgY2hhcnQgdW5kZXIgI2NoYXJ0LWNvbnRhaW5lcjEgZWxlbWVudCB1c2luZyB0aGUgZGVmYXVsdCBnbG9iYWwgY2hhcnQgZ3JvdXBcclxuICogdmFyIGNoYXJ0MSA9IGRjLnN1bmJ1cnN0Q2hhcnQoJyNjaGFydC1jb250YWluZXIxJyk7XHJcbiAqIC8vIGNyZWF0ZSBhIHN1bmJ1cnN0IGNoYXJ0IHVuZGVyICNjaGFydC1jb250YWluZXIyIGVsZW1lbnQgdXNpbmcgY2hhcnQgZ3JvdXAgQVxyXG4gKiB2YXIgY2hhcnQyID0gZGMuc3VuYnVyc3RDaGFydCgnI2NoYXJ0LWNvbnRhaW5lcjInLCAnY2hhcnRHcm91cEEnKTtcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd8bm9kZXxkMy5zZWxlY3Rpb259IHBhcmVudCAtIEFueSB2YWxpZFxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLTMueC1hcGktcmVmZXJlbmNlL2Jsb2IvbWFzdGVyL1NlbGVjdGlvbnMubWQjc2VsZWN0aW5nLWVsZW1lbnRzIGQzIHNpbmdsZSBzZWxlY3Rvcn0gc3BlY2lmeWluZ1xyXG4gKiBhIGRvbSBibG9jayBlbGVtZW50IHN1Y2ggYXMgYSBkaXY7IG9yIGEgZG9tIGVsZW1lbnQgb3IgZDMgc2VsZWN0aW9uLlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gW2NoYXJ0R3JvdXBdIC0gVGhlIG5hbWUgb2YgdGhlIGNoYXJ0IGdyb3VwIHRoaXMgY2hhcnQgaW5zdGFuY2Ugc2hvdWxkIGJlIHBsYWNlZCBpbi5cclxuICogSW50ZXJhY3Rpb24gd2l0aCBhIGNoYXJ0IHdpbGwgb25seSB0cmlnZ2VyIGV2ZW50cyBhbmQgcmVkcmF3cyB3aXRoaW4gdGhlIGNoYXJ0J3MgZ3JvdXAuXHJcbiAqIEByZXR1cm5zIHtkYy5zdW5idXJzdENoYXJ0fVxyXG4gKiovXHJcbmRjLnN1bmJ1cnN0Q2hhcnQgPSBmdW5jdGlvbiAocGFyZW50LCBjaGFydEdyb3VwKSB7XHJcbiAgICB2YXIgREVGQVVMVF9NSU5fQU5HTEVfRk9SX0xBQkVMID0gMC41O1xyXG5cclxuICAgIHZhciBfc2xpY2VDc3NDbGFzcyA9ICdwaWUtc2xpY2UnO1xyXG4gICAgdmFyIF9lbXB0eUNzc0NsYXNzID0gJ2VtcHR5LWNoYXJ0JztcclxuICAgIHZhciBfZW1wdHlUaXRsZSA9ICdlbXB0eSc7XHJcblxyXG4gICAgdmFyIF9yYWRpdXMsXHJcbiAgICAgICAgX2lubmVyUmFkaXVzID0gMDtcclxuXHJcbiAgICB2YXIgX2c7XHJcbiAgICB2YXIgX2N4O1xyXG4gICAgdmFyIF9jeTtcclxuICAgIHZhciBfbWluQW5nbGVGb3JMYWJlbCA9IERFRkFVTFRfTUlOX0FOR0xFX0ZPUl9MQUJFTDtcclxuICAgIHZhciBfZXh0ZXJuYWxMYWJlbFJhZGl1cztcclxuICAgIHZhciBfY2hhcnQgPSBkYy5jYXBNaXhpbihkYy5jb2xvck1peGluKGRjLmJhc2VNaXhpbih7fSkpKTtcclxuXHJcbiAgICBfY2hhcnQuY29sb3JBY2Nlc3NvcihfY2hhcnQuY2FwcGVkS2V5QWNjZXNzb3IpO1xyXG5cclxuICAgIC8vIEhhbmRsZSBjYXNlcyBpZiB2YWx1ZSBjb3JyZXNwb25kcyB0byBnZW5lcmF0ZWQgcGFyZW50IG5vZGVzXHJcbiAgICBmdW5jdGlvbiBleHRlbmRlZFZhbHVlQWNjZXNzb3IgKGQpIHtcclxuICAgICAgICBpZiAoZC5wYXRoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkLnZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX2NoYXJ0LmNhcHBlZFZhbHVlQWNjZXNzb3IoZCk7XHJcbiAgICB9XHJcblxyXG4gICAgX2NoYXJ0LnRpdGxlKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydC5jYXBwZWRLZXlBY2Nlc3NvcihkKSArICc6ICcgKyBleHRlbmRlZFZhbHVlQWNjZXNzb3IoZCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBfY2hhcnQubGFiZWwoX2NoYXJ0LmNhcHBlZEtleUFjY2Vzc29yKTtcclxuICAgIF9jaGFydC5yZW5kZXJMYWJlbCh0cnVlKTtcclxuXHJcbiAgICBfY2hhcnQudHJhbnNpdGlvbkR1cmF0aW9uKDM1MCk7XHJcblxyXG4gICAgX2NoYXJ0LmZpbHRlckhhbmRsZXIoZnVuY3Rpb24gKGRpbWVuc2lvbiwgZmlsdGVycykge1xyXG4gICAgICAgIGlmIChmaWx0ZXJzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBkaW1lbnNpb24uZmlsdGVyKG51bGwpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGRpbWVuc2lvbi5maWx0ZXJGdW5jdGlvbihmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpbHRlciA9IGZpbHRlcnNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlci5pc0ZpbHRlcmVkICYmIGZpbHRlci5pc0ZpbHRlcmVkKGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmaWx0ZXJzO1xyXG4gICAgfSk7XHJcblxyXG4gICAgX2NoYXJ0Ll9kb1JlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfY2hhcnQucmVzZXRTdmcoKTtcclxuXHJcbiAgICAgICAgX2cgPSBfY2hhcnQuc3ZnKClcclxuICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBfY2hhcnQuY3goKSArICcsJyArIF9jaGFydC5jeSgpICsgJyknKTtcclxuXHJcbiAgICAgICAgZHJhd0NoYXJ0KCk7XHJcblxyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGRyYXdDaGFydCAoKSB7XHJcbiAgICAgICAgLy8gc2V0IHJhZGl1cyBvbiBiYXNpcyBvZiBjaGFydCBkaW1lbnNpb24gaWYgbWlzc2luZ1xyXG4gICAgICAgIF9yYWRpdXMgPSBfcmFkaXVzID8gX3JhZGl1cyA6IGQzLm1pbihbX2NoYXJ0LndpZHRoKCksIF9jaGFydC5oZWlnaHQoKV0pIC8gMjtcclxuXHJcbiAgICAgICAgdmFyIGFyYyA9IGJ1aWxkQXJjcygpO1xyXG5cclxuICAgICAgICB2YXIgc3VuYnVyc3REYXRhLCBjZGF0YTtcclxuICAgICAgICAvLyBpZiB3ZSBoYXZlIGRhdGEuLi5cclxuICAgICAgICBpZiAoZDMuc3VtKF9jaGFydC5kYXRhKCksIF9jaGFydC52YWx1ZUFjY2Vzc29yKCkpKSB7XHJcbiAgICAgICAgICAgIGNkYXRhID0gZGMudXRpbHMudG9IaWVyYXJjaHkoX2NoYXJ0LmRhdGEoKSwgX2NoYXJ0LnZhbHVlQWNjZXNzb3IoKSk7XHJcbiAgICAgICAgICAgIHN1bmJ1cnN0RGF0YSA9IHBhcnRpdGlvbk5vZGVzKGNkYXRhKTtcclxuICAgICAgICAgICAgLy8gRmlyc3Qgb25lIGlzIHRoZSByb290LCB3aGljaCBpcyBub3QgbmVlZGVkXHJcbiAgICAgICAgICAgIHN1bmJ1cnN0RGF0YS5zaGlmdCgpO1xyXG4gICAgICAgICAgICBfZy5jbGFzc2VkKF9lbXB0eUNzc0NsYXNzLCBmYWxzZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHdlJ2QgYmUgZ2V0dGluZyBOYU5zLCBzbyBvdmVycmlkZVxyXG4gICAgICAgICAgICAvLyBub3RlOiBhYnVzZSBvdGhlcnMgZm9yIGl0cyBpZ25vcmluZyB0aGUgdmFsdWUgYWNjZXNzb3JcclxuICAgICAgICAgICAgY2RhdGEgPSBkYy51dGlscy50b0hpZXJhcmNoeShbXSwgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkLnZhbHVlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgc3VuYnVyc3REYXRhID0gcGFydGl0aW9uTm9kZXMoY2RhdGEpO1xyXG4gICAgICAgICAgICBfZy5jbGFzc2VkKF9lbXB0eUNzc0NsYXNzLCB0cnVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChfZykge1xyXG4gICAgICAgICAgICB2YXIgc2xpY2VzID0gX2cuc2VsZWN0QWxsKCdnLicgKyBfc2xpY2VDc3NDbGFzcylcclxuICAgICAgICAgICAgICAgIC5kYXRhKHN1bmJ1cnN0RGF0YSk7XHJcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnRzKHNsaWNlcywgYXJjLCBzdW5idXJzdERhdGEpO1xyXG5cclxuICAgICAgICAgICAgdXBkYXRlRWxlbWVudHMoc3VuYnVyc3REYXRhLCBhcmMpO1xyXG5cclxuICAgICAgICAgICAgcmVtb3ZlRWxlbWVudHMoc2xpY2VzKTtcclxuXHJcbiAgICAgICAgICAgIGhpZ2hsaWdodEZpbHRlcigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50cyAoc2xpY2VzLCBhcmMsIHN1bmJ1cnN0RGF0YSkge1xyXG4gICAgICAgIHZhciBzbGljZXNFbnRlciA9IGNyZWF0ZVNsaWNlTm9kZXMoc2xpY2VzKTtcclxuXHJcbiAgICAgICAgY3JlYXRlU2xpY2VQYXRoKHNsaWNlc0VudGVyLCBhcmMpO1xyXG4gICAgICAgIGNyZWF0ZVRpdGxlcyhzbGljZXNFbnRlcik7XHJcbiAgICAgICAgY3JlYXRlTGFiZWxzKHN1bmJ1cnN0RGF0YSwgYXJjKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVTbGljZU5vZGVzIChzbGljZXMpIHtcclxuICAgICAgICB2YXIgc2xpY2VzRW50ZXIgPSBzbGljZXNcclxuICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3NsaWNlQ3NzQ2xhc3MgK1xyXG4gICAgICAgICAgICAgICAgICAgICcgXycgKyBpICsgJyAnICtcclxuICAgICAgICAgICAgICAgICAgICBfc2xpY2VDc3NDbGFzcyArICctbGV2ZWwtJyArIGQuZGVwdGg7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBzbGljZXNFbnRlcjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVTbGljZVBhdGggKHNsaWNlc0VudGVyLCBhcmMpIHtcclxuICAgICAgICB2YXIgc2xpY2VQYXRoID0gc2xpY2VzRW50ZXIuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCBmaWxsKVxyXG4gICAgICAgICAgICAub24oJ2NsaWNrJywgb25DbGljaylcclxuICAgICAgICAgICAgLmF0dHIoJ2QnLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNhZmVBcmMoZCwgaSwgYXJjKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHZhciB0cmFuc2l0aW9uID0gZGMudHJhbnNpdGlvbihzbGljZVBhdGgsIF9jaGFydC50cmFuc2l0aW9uRHVyYXRpb24oKSk7XHJcbiAgICAgICAgaWYgKHRyYW5zaXRpb24uYXR0clR3ZWVuKSB7XHJcbiAgICAgICAgICAgIHRyYW5zaXRpb24uYXR0clR3ZWVuKCdkJywgdHdlZW5TbGljZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZVRpdGxlcyAoc2xpY2VzRW50ZXIpIHtcclxuICAgICAgICBpZiAoX2NoYXJ0LnJlbmRlclRpdGxlKCkpIHtcclxuICAgICAgICAgICAgc2xpY2VzRW50ZXIuYXBwZW5kKCd0aXRsZScpLnRleHQoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfY2hhcnQudGl0bGUoKShkKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHBvc2l0aW9uTGFiZWxzIChsYWJlbHNFbnRlciwgYXJjKSB7XHJcbiAgICAgICAgZGMudHJhbnNpdGlvbihsYWJlbHNFbnRlciwgX2NoYXJ0LnRyYW5zaXRpb25EdXJhdGlvbigpKVxyXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsYWJlbFBvc2l0aW9uKGQsIGFyYyk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKVxyXG4gICAgICAgICAgICAudGV4dChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gcG9zaXRpb24gbGFiZWwuLi5cclxuICAgICAgICAgICAgICAgIGlmIChzbGljZUhhc05vRGF0YShkKSB8fCBzbGljZVRvb1NtYWxsKGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jaGFydC5sYWJlbCgpKGQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVMYWJlbHMgKHN1bmJ1cnN0RGF0YSwgYXJjKSB7XHJcbiAgICAgICAgaWYgKF9jaGFydC5yZW5kZXJMYWJlbCgpKSB7XHJcbiAgICAgICAgICAgIHZhciBsYWJlbHMgPSBfZy5zZWxlY3RBbGwoJ3RleHQuJyArIF9zbGljZUNzc0NsYXNzKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEoc3VuYnVyc3REYXRhKTtcclxuXHJcbiAgICAgICAgICAgIGxhYmVscy5leGl0KCkucmVtb3ZlKCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgbGFiZWxzRW50ZXIgPSBsYWJlbHNcclxuICAgICAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzZXMgPSBfc2xpY2VDc3NDbGFzcyArICcgXycgKyBpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfZXh0ZXJuYWxMYWJlbFJhZGl1cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc2VzICs9ICcgZXh0ZXJuYWwnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xhc3NlcztcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAub24oJ2NsaWNrJywgb25DbGljayk7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uTGFiZWxzKGxhYmVsc0VudGVyLCBhcmMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB1cGRhdGVFbGVtZW50cyAoc3VuYnVyc3REYXRhLCBhcmMpIHtcclxuICAgICAgICB1cGRhdGVTbGljZVBhdGhzKHN1bmJ1cnN0RGF0YSwgYXJjKTtcclxuICAgICAgICB1cGRhdGVMYWJlbHMoc3VuYnVyc3REYXRhLCBhcmMpO1xyXG4gICAgICAgIHVwZGF0ZVRpdGxlcyhzdW5idXJzdERhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZVNsaWNlUGF0aHMgKHN1bmJ1cnN0RGF0YSwgYXJjKSB7XHJcbiAgICAgICAgdmFyIHNsaWNlUGF0aHMgPSBfZy5zZWxlY3RBbGwoJ2cuJyArIF9zbGljZUNzc0NsYXNzKVxyXG4gICAgICAgICAgICAuZGF0YShzdW5idXJzdERhdGEpXHJcbiAgICAgICAgICAgIC5zZWxlY3QoJ3BhdGgnKVxyXG4gICAgICAgICAgICAuYXR0cignZCcsIGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2FmZUFyYyhkLCBpLCBhcmMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB2YXIgdHJhbnNpdGlvbiA9IGRjLnRyYW5zaXRpb24oc2xpY2VQYXRocywgX2NoYXJ0LnRyYW5zaXRpb25EdXJhdGlvbigpKTtcclxuICAgICAgICBpZiAodHJhbnNpdGlvbi5hdHRyVHdlZW4pIHtcclxuICAgICAgICAgICAgdHJhbnNpdGlvbi5hdHRyVHdlZW4oJ2QnLCB0d2VlblNsaWNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJhbnNpdGlvbi5hdHRyKCdmaWxsJywgZmlsbCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdXBkYXRlTGFiZWxzIChzdW5idXJzdERhdGEsIGFyYykge1xyXG4gICAgICAgIGlmIChfY2hhcnQucmVuZGVyTGFiZWwoKSkge1xyXG4gICAgICAgICAgICB2YXIgbGFiZWxzID0gX2cuc2VsZWN0QWxsKCd0ZXh0LicgKyBfc2xpY2VDc3NDbGFzcylcclxuICAgICAgICAgICAgICAgIC5kYXRhKHN1bmJ1cnN0RGF0YSk7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uTGFiZWxzKGxhYmVscywgYXJjKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdXBkYXRlVGl0bGVzIChzdW5idXJzdERhdGEpIHtcclxuICAgICAgICBpZiAoX2NoYXJ0LnJlbmRlclRpdGxlKCkpIHtcclxuICAgICAgICAgICAgX2cuc2VsZWN0QWxsKCdnLicgKyBfc2xpY2VDc3NDbGFzcylcclxuICAgICAgICAgICAgICAgIC5kYXRhKHN1bmJ1cnN0RGF0YSlcclxuICAgICAgICAgICAgICAgIC5zZWxlY3QoJ3RpdGxlJylcclxuICAgICAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jaGFydC50aXRsZSgpKGQpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlbW92ZUVsZW1lbnRzIChzbGljZXMpIHtcclxuICAgICAgICBzbGljZXMuZXhpdCgpLnJlbW92ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGhpZ2hsaWdodEZpbHRlciAoKSB7XHJcbiAgICAgICAgaWYgKF9jaGFydC5oYXNGaWx0ZXIoKSkge1xyXG4gICAgICAgICAgICBfY2hhcnQuc2VsZWN0QWxsKCdnLicgKyBfc2xpY2VDc3NDbGFzcykuZWFjaChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzU2VsZWN0ZWRTbGljZShkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIF9jaGFydC5oaWdobGlnaHRTZWxlY3RlZCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2NoYXJ0LmZhZGVEZXNlbGVjdGVkKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBfY2hhcnQuc2VsZWN0QWxsKCdnLicgKyBfc2xpY2VDc3NDbGFzcykuZWFjaChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgX2NoYXJ0LnJlc2V0SGlnaGxpZ2h0KHRoaXMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgb3Igc2V0IHRoZSBpbm5lciByYWRpdXMgb2YgdGhlIHN1bmJ1cnN0IGNoYXJ0LiBJZiB0aGUgaW5uZXIgcmFkaXVzIGlzIGdyZWF0ZXIgdGhhbiAwcHggdGhlbiB0aGVcclxuICAgICAqIHN1bmJ1cnN0IGNoYXJ0IHdpbGwgYmUgcmVuZGVyZWQgYXMgYSBkb3VnaG51dCBjaGFydC4gRGVmYXVsdCBpbm5lciByYWRpdXMgaXMgMHB4LlxyXG4gICAgICogQG1ldGhvZCBpbm5lclJhZGl1c1xyXG4gICAgICogQG1lbWJlcm9mIGRjLnN1bmJ1cnN0Q2hhcnRcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtpbm5lclJhZGl1cz0wXVxyXG4gICAgICogQHJldHVybnMge051bWJlcnxkYy5zdW5idXJzdENoYXJ0fVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQuaW5uZXJSYWRpdXMgPSBmdW5jdGlvbiAoaW5uZXJSYWRpdXMpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9pbm5lclJhZGl1cztcclxuICAgICAgICB9XHJcbiAgICAgICAgX2lubmVyUmFkaXVzID0gaW5uZXJSYWRpdXM7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgb3Igc2V0IHRoZSBvdXRlciByYWRpdXMuIElmIHRoZSByYWRpdXMgaXMgbm90IHNldCwgaXQgd2lsbCBiZSBoYWxmIG9mIHRoZSBtaW5pbXVtIG9mIHRoZVxyXG4gICAgICogY2hhcnQgd2lkdGggYW5kIGhlaWdodC5cclxuICAgICAqIEBtZXRob2QgcmFkaXVzXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuc3VuYnVyc3RDaGFydFxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3JhZGl1c11cclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ8ZGMuc3VuYnVyc3RDaGFydH1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LnJhZGl1cyA9IGZ1bmN0aW9uIChyYWRpdXMpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9yYWRpdXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9yYWRpdXMgPSByYWRpdXM7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgb3Igc2V0IGNlbnRlciB4IGNvb3JkaW5hdGUgcG9zaXRpb24uIERlZmF1bHQgaXMgY2VudGVyIG9mIHN2Zy5cclxuICAgICAqIEBtZXRob2QgY3hcclxuICAgICAqIEBtZW1iZXJvZiBkYy5zdW5idXJzdENoYXJ0XHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY3hdXHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfGRjLnN1bmJ1cnN0Q2hhcnR9XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5jeCA9IGZ1bmN0aW9uIChjeCkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKF9jeCB8fCBfY2hhcnQud2lkdGgoKSAvIDIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfY3ggPSBjeDtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBvciBzZXQgY2VudGVyIHkgY29vcmRpbmF0ZSBwb3NpdGlvbi4gRGVmYXVsdCBpcyBjZW50ZXIgb2Ygc3ZnLlxyXG4gICAgICogQG1ldGhvZCBjeVxyXG4gICAgICogQG1lbWJlcm9mIGRjLnN1bmJ1cnN0Q2hhcnRcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjeV1cclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ8ZGMuc3VuYnVyc3RDaGFydH1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LmN5ID0gZnVuY3Rpb24gKGN5KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoX2N5IHx8IF9jaGFydC5oZWlnaHQoKSAvIDIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfY3kgPSBjeTtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBvciBzZXQgdGhlIG1pbmltYWwgc2xpY2UgYW5nbGUgZm9yIGxhYmVsIHJlbmRlcmluZy4gQW55IHNsaWNlIHdpdGggYSBzbWFsbGVyIGFuZ2xlIHdpbGwgbm90XHJcbiAgICAgKiBkaXNwbGF5IGEgc2xpY2UgbGFiZWwuXHJcbiAgICAgKiBAbWV0aG9kIG1pbkFuZ2xlRm9yTGFiZWxcclxuICAgICAqIEBtZW1iZXJvZiBkYy5zdW5idXJzdENoYXJ0XHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbbWluQW5nbGVGb3JMYWJlbD0wLjVdXHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfGRjLnN1bmJ1cnN0Q2hhcnR9XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5taW5BbmdsZUZvckxhYmVsID0gZnVuY3Rpb24gKG1pbkFuZ2xlRm9yTGFiZWwpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9taW5BbmdsZUZvckxhYmVsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfbWluQW5nbGVGb3JMYWJlbCA9IG1pbkFuZ2xlRm9yTGFiZWw7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaXRsZSB0byB1c2UgZm9yIHRoZSBvbmx5IHNsaWNlIHdoZW4gdGhlcmUgaXMgbm8gZGF0YS5cclxuICAgICAqIEBtZXRob2QgZW1wdHlUaXRsZVxyXG4gICAgICogQG1lbWJlcm9mIGRjLnN1bmJ1cnN0Q2hhcnRcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFt0aXRsZV1cclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd8ZGMuc3VuYnVyc3RDaGFydH1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LmVtcHR5VGl0bGUgPSBmdW5jdGlvbiAodGl0bGUpIHtcclxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2VtcHR5VGl0bGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9lbXB0eVRpdGxlID0gdGl0bGU7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQb3NpdGlvbiBzbGljZSBsYWJlbHMgb2Zmc2V0IGZyb20gdGhlIG91dGVyIGVkZ2Ugb2YgdGhlIGNoYXJ0LlxyXG4gICAgICpcclxuICAgICAqIFRoZSBhcmd1bWVudCBzcGVjaWZpZXMgdGhlIGV4dHJhIHJhZGl1cyB0byBiZSBhZGRlZCBmb3Igc2xpY2UgbGFiZWxzLlxyXG4gICAgICogQG1ldGhvZCBleHRlcm5hbExhYmVsc1xyXG4gICAgICogQG1lbWJlcm9mIGRjLnN1bmJ1cnN0Q2hhcnRcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtleHRlcm5hbExhYmVsUmFkaXVzXVxyXG4gICAgICogQHJldHVybnMge051bWJlcnxkYy5zdW5idXJzdENoYXJ0fVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQuZXh0ZXJuYWxMYWJlbHMgPSBmdW5jdGlvbiAoZXh0ZXJuYWxMYWJlbFJhZGl1cykge1xyXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfZXh0ZXJuYWxMYWJlbFJhZGl1cztcclxuICAgICAgICB9IGVsc2UgaWYgKGV4dGVybmFsTGFiZWxSYWRpdXMpIHtcclxuICAgICAgICAgICAgX2V4dGVybmFsTGFiZWxSYWRpdXMgPSBleHRlcm5hbExhYmVsUmFkaXVzO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIF9leHRlcm5hbExhYmVsUmFkaXVzID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gYnVpbGRBcmNzICgpIHtcclxuICAgICAgICByZXR1cm4gZDMuYXJjKClcclxuICAgICAgICAgICAgLnN0YXJ0QW5nbGUoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkLngwO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuZW5kQW5nbGUoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkLngxO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuaW5uZXJSYWRpdXMoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkLmRhdGEucGF0aCAmJiBkLmRhdGEucGF0aC5sZW5ndGggPT09IDEgPyBfaW5uZXJSYWRpdXMgOiBNYXRoLnNxcnQoZC55MCk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5vdXRlclJhZGl1cyhmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydChkLnkxKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaXNTZWxlY3RlZFNsaWNlIChkKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzUGF0aEZpbHRlcmVkKGQucGF0aCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaXNQYXRoRmlsdGVyZWQgKHBhdGgpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9jaGFydC5maWx0ZXJzKCkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRGaWx0ZXIgPSBfY2hhcnQuZmlsdGVycygpW2ldO1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudEZpbHRlci5pc0ZpbHRlcmVkKHBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcmV0dXJucyBhbGwgZmlsdGVycyB0aGF0IGFyZSBhIHBhcmVudCBvciBjaGlsZCBvZiB0aGUgcGF0aFxyXG4gICAgZnVuY3Rpb24gZmlsdGVyc0ZvclBhdGggKHBhdGgpIHtcclxuICAgICAgICB2YXIgcGF0aEZpbHRlciA9IGRjLmZpbHRlcnMuSGllcmFyY2h5RmlsdGVyKHBhdGgpO1xyXG4gICAgICAgIHZhciBmaWx0ZXJzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfY2hhcnQuZmlsdGVycygpLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50RmlsdGVyID0gX2NoYXJ0LmZpbHRlcnMoKVtpXTtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRGaWx0ZXIuaXNGaWx0ZXJlZChwYXRoKSB8fCBwYXRoRmlsdGVyLmlzRmlsdGVyZWQoY3VycmVudEZpbHRlcikpIHtcclxuICAgICAgICAgICAgICAgIGZpbHRlcnMucHVzaChjdXJyZW50RmlsdGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmlsdGVycztcclxuICAgIH1cclxuXHJcbiAgICBfY2hhcnQuX2RvUmVkcmF3ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGRyYXdDaGFydCgpO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIHBhcnRpdGlvbk5vZGVzIChkYXRhKSB7XHJcbiAgICAgICAgLy8gVGhlIGNoYW5nZXMgcGlja2VkIHVwIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLWhpZXJhcmNoeS9pc3N1ZXMvNTBcclxuICAgICAgICB2YXIgaGllcmFyY2h5ID0gZDMuaGllcmFyY2h5KGRhdGEpXHJcbiAgICAgICAgICAgIC5zdW0oZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkLmNoaWxkcmVuID8gMCA6IGV4dGVuZGVkVmFsdWVBY2Nlc3NvcihkKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkMy5hc2NlbmRpbmcoYS5kYXRhLnBhdGgsIGIuZGF0YS5wYXRoKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHZhciBwYXJ0aXRpb24gPSBkMy5wYXJ0aXRpb24oKVxyXG4gICAgICAgICAgICAuc2l6ZShbMiAqIE1hdGguUEksIF9yYWRpdXMgKiBfcmFkaXVzXSk7XHJcblxyXG4gICAgICAgIHBhcnRpdGlvbihoaWVyYXJjaHkpO1xyXG5cclxuICAgICAgICAvLyBJbiBEM3Y0IHRoZSByZXR1cm5lZCBkYXRhIGlzIHNsaWdodGx5IGRpZmZlcmVudCwgY2hhbmdlIGl0IGVub3VnaCB0byBzdWl0IG91ciBwdXJwb3Nlcy5cclxuICAgICAgICB2YXIgbm9kZXMgPSBoaWVyYXJjaHkuZGVzY2VuZGFudHMoKS5tYXAoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgZC5rZXkgPSBkLmRhdGEua2V5O1xyXG4gICAgICAgICAgICBkLnBhdGggPSBkLmRhdGEucGF0aDtcclxuICAgICAgICAgICAgcmV0dXJuIGQ7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBub2RlcztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzbGljZVRvb1NtYWxsIChkKSB7XHJcbiAgICAgICAgdmFyIGFuZ2xlID0gZC54MSAtIGQueDA7XHJcbiAgICAgICAgcmV0dXJuIGlzTmFOKGFuZ2xlKSB8fCBhbmdsZSA8IF9taW5BbmdsZUZvckxhYmVsO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNsaWNlSGFzTm9EYXRhIChkKSB7XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZGVkVmFsdWVBY2Nlc3NvcihkKSA9PT0gMDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0d2VlblNsaWNlIChiKSB7XHJcbiAgICAgICAgYi5pbm5lclJhZGl1cyA9IF9pbm5lclJhZGl1czsgLy8/XHJcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLl9jdXJyZW50O1xyXG4gICAgICAgIGlmIChpc09mZkNhbnZhcyhjdXJyZW50KSkge1xyXG4gICAgICAgICAgICBjdXJyZW50ID0ge3g6IDAsIHk6IDAsIGR4OiAwLCBkeTogMH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHVuZm9ydHVuYWxseSwgd2UgY2FuJ3QgdHdlZW4gYW4gZW50aXJlIGhpZXJhcmNoeSBzaW5jZSBpdCBoYXMgMiB3YXkgbGlua3MuXHJcbiAgICAgICAgdmFyIHR3ZWVuVGFyZ2V0ID0ge3g6IGIueCwgeTogYi55LCBkeDogYi5keCwgZHk6IGIuZHl9O1xyXG4gICAgICAgIHZhciBpID0gZDMuaW50ZXJwb2xhdGUoY3VycmVudCwgdHdlZW5UYXJnZXQpO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnQgPSBpKDApO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc2FmZUFyYyhPYmplY3QuYXNzaWduKHt9LCBiLCBpKHQpKSwgMCwgYnVpbGRBcmNzKCkpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaXNPZmZDYW52YXMgKGN1cnJlbnQpIHtcclxuICAgICAgICByZXR1cm4gIWN1cnJlbnQgfHwgaXNOYU4oY3VycmVudC5keCkgfHwgaXNOYU4oY3VycmVudC5keSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZmlsbCAoZCwgaSkge1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQuZ2V0Q29sb3IoZCwgaSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX29uQ2xpY2sgKGQpIHtcclxuICAgICAgICAvLyBDbGlja2luZyBvbiBMZWdlbmRzIGRvIG5vdCBmaWx0ZXIsIGl0IHRocm93cyBleGNlcHRpb25cclxuICAgICAgICAvLyBNdXN0IGJlIGJldHRlciB3YXkgdG8gaGFuZGxlIHRoaXMsIGluIGxlZ2VuZHMgd2UgbmVlZCB0byBhY2Nlc3MgYGQua2V5YFxyXG4gICAgICAgIHZhciBwYXRoID0gZC5wYXRoIHx8IGQua2V5O1xyXG4gICAgICAgIHZhciBmaWx0ZXIgPSBkYy5maWx0ZXJzLkhpZXJhcmNoeUZpbHRlcihwYXRoKTtcclxuXHJcbiAgICAgICAgLy8gZmlsdGVycyBhcmUgZXF1YWwgdG8sIHBhcmVudHMgb3IgY2hpbGRyZW4gb2YgdGhlIHBhdGguXHJcbiAgICAgICAgdmFyIGZpbHRlcnMgPSBmaWx0ZXJzRm9yUGF0aChwYXRoKTtcclxuICAgICAgICB2YXIgZXhhY3RNYXRjaCA9IGZhbHNlO1xyXG4gICAgICAgIC8vIGNsZWFyIG91dCBhbnkgZmlsdGVycyB0aGF0IGNvdmVyIHRoZSBwYXRoIGZpbHRlcmVkLlxyXG4gICAgICAgIGZvciAodmFyIGkgPSBmaWx0ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50RmlsdGVyID0gZmlsdGVyc1tpXTtcclxuICAgICAgICAgICAgaWYgKGRjLnV0aWxzLmFycmF5c0lkZW50aWNhbChjdXJyZW50RmlsdGVyLCBwYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgZXhhY3RNYXRjaCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX2NoYXJ0LmZpbHRlcihmaWx0ZXJzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGMuZXZlbnRzLnRyaWdnZXIoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBpZiBpdCBpcyBhIG5ldyBmaWx0ZXIgLSBwdXQgaXQgaW4uXHJcbiAgICAgICAgICAgIGlmICghZXhhY3RNYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgX2NoYXJ0LmZpbHRlcihmaWx0ZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF9jaGFydC5yZWRyYXdHcm91cCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIF9jaGFydC5vbkNsaWNrID0gb25DbGljaztcclxuXHJcbiAgICBmdW5jdGlvbiBvbkNsaWNrIChkLCBpKSB7XHJcbiAgICAgICAgaWYgKF9nLmF0dHIoJ2NsYXNzJykgIT09IF9lbXB0eUNzc0NsYXNzKSB7XHJcbiAgICAgICAgICAgIF9vbkNsaWNrKGQsIGkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzYWZlQXJjIChkLCBpLCBhcmMpIHtcclxuICAgICAgICB2YXIgcGF0aCA9IGFyYyhkLCBpKTtcclxuICAgICAgICBpZiAocGF0aC5pbmRleE9mKCdOYU4nKSA+PSAwKSB7XHJcbiAgICAgICAgICAgIHBhdGggPSAnTTAsMCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXRoO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGxhYmVsUG9zaXRpb24gKGQsIGFyYykge1xyXG4gICAgICAgIHZhciBjZW50cm9pZDtcclxuICAgICAgICBpZiAoX2V4dGVybmFsTGFiZWxSYWRpdXMpIHtcclxuICAgICAgICAgICAgY2VudHJvaWQgPSBkMy5zdmcuYXJjKClcclxuICAgICAgICAgICAgICAgIC5vdXRlclJhZGl1cyhfcmFkaXVzICsgX2V4dGVybmFsTGFiZWxSYWRpdXMpXHJcbiAgICAgICAgICAgICAgICAuaW5uZXJSYWRpdXMoX3JhZGl1cyArIF9leHRlcm5hbExhYmVsUmFkaXVzKVxyXG4gICAgICAgICAgICAgICAgLmNlbnRyb2lkKGQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNlbnRyb2lkID0gYXJjLmNlbnRyb2lkKGQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNOYU4oY2VudHJvaWRbMF0pIHx8IGlzTmFOKGNlbnRyb2lkWzFdKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgwLDApJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgY2VudHJvaWQgKyAnKSc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIF9jaGFydC5sZWdlbmRhYmxlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0LmRhdGEoKS5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgdmFyIGxlZ2VuZGFibGUgPSB7bmFtZTogZC5rZXksIGRhdGE6IGQudmFsdWUsIG90aGVyczogZC5vdGhlcnMsIGNoYXJ0OiBfY2hhcnR9O1xyXG4gICAgICAgICAgICBsZWdlbmRhYmxlLmNvbG9yID0gX2NoYXJ0LmdldENvbG9yKGQsIGkpO1xyXG4gICAgICAgICAgICByZXR1cm4gbGVnZW5kYWJsZTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgX2NoYXJ0LmxlZ2VuZEhpZ2hsaWdodCA9IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgaGlnaGxpZ2h0U2xpY2VGcm9tTGVnZW5kYWJsZShkLCB0cnVlKTtcclxuICAgIH07XHJcblxyXG4gICAgX2NoYXJ0LmxlZ2VuZFJlc2V0ID0gZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICBoaWdobGlnaHRTbGljZUZyb21MZWdlbmRhYmxlKGQsIGZhbHNlKTtcclxuICAgIH07XHJcblxyXG4gICAgX2NoYXJ0LmxlZ2VuZFRvZ2dsZSA9IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgX2NoYXJ0Lm9uQ2xpY2soe2tleTogZC5uYW1lLCBvdGhlcnM6IGQub3RoZXJzfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGhpZ2hsaWdodFNsaWNlRnJvbUxlZ2VuZGFibGUgKGxlZ2VuZGFibGUsIGhpZ2hsaWdodGVkKSB7XHJcbiAgICAgICAgX2NoYXJ0LnNlbGVjdEFsbCgnZy5waWUtc2xpY2UnKS5lYWNoKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIGlmIChsZWdlbmRhYmxlLm5hbWUgPT09IGQua2V5KSB7XHJcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuY2xhc3NlZCgnaGlnaGxpZ2h0JywgaGlnaGxpZ2h0ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIF9jaGFydC5hbmNob3IocGFyZW50LCBjaGFydEdyb3VwKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb25jcmV0ZSBiYXIgY2hhcnQvaGlzdG9ncmFtIGltcGxlbWVudGF0aW9uLlxyXG4gKlxyXG4gKiBFeGFtcGxlczpcclxuICogLSB7QGxpbmsgaHR0cDovL2RjLWpzLmdpdGh1Yi5jb20vZGMuanMvIE5hc2RhcSAxMDAgSW5kZXh9XHJcbiAqIC0ge0BsaW5rIGh0dHA6Ly9kYy1qcy5naXRodWIuY29tL2RjLmpzL2NyaW1lL2luZGV4Lmh0bWwgQ2FuYWRpYW4gQ2l0eSBDcmltZSBTdGF0c31cclxuICogQGNsYXNzIGJhckNoYXJ0XHJcbiAqIEBtZW1iZXJvZiBkY1xyXG4gKiBAbWl4ZXMgZGMuc3RhY2tNaXhpblxyXG4gKiBAbWl4ZXMgZGMuY29vcmRpbmF0ZUdyaWRNaXhpblxyXG4gKiBAZXhhbXBsZVxyXG4gKiAvLyBjcmVhdGUgYSBiYXIgY2hhcnQgdW5kZXIgI2NoYXJ0LWNvbnRhaW5lcjEgZWxlbWVudCB1c2luZyB0aGUgZGVmYXVsdCBnbG9iYWwgY2hhcnQgZ3JvdXBcclxuICogdmFyIGNoYXJ0MSA9IGRjLmJhckNoYXJ0KCcjY2hhcnQtY29udGFpbmVyMScpO1xyXG4gKiAvLyBjcmVhdGUgYSBiYXIgY2hhcnQgdW5kZXIgI2NoYXJ0LWNvbnRhaW5lcjIgZWxlbWVudCB1c2luZyBjaGFydCBncm91cCBBXHJcbiAqIHZhciBjaGFydDIgPSBkYy5iYXJDaGFydCgnI2NoYXJ0LWNvbnRhaW5lcjInLCAnY2hhcnRHcm91cEEnKTtcclxuICogLy8gY3JlYXRlIGEgc3ViLWNoYXJ0IHVuZGVyIGEgY29tcG9zaXRlIHBhcmVudCBjaGFydFxyXG4gKiB2YXIgY2hhcnQzID0gZGMuYmFyQ2hhcnQoY29tcG9zaXRlQ2hhcnQpO1xyXG4gKiBAcGFyYW0ge1N0cmluZ3xub2RlfGQzLnNlbGVjdGlvbnxkYy5jb21wb3NpdGVDaGFydH0gcGFyZW50IC0gQW55IHZhbGlkXHJcbiAqIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2VsZWN0aW9uL2Jsb2IvbWFzdGVyL1JFQURNRS5tZCNzZWxlY3QgZDMgc2luZ2xlIHNlbGVjdG9yfVxyXG4gKiBzcGVjaWZ5aW5nIGEgZG9tIGJsb2NrIGVsZW1lbnQgc3VjaCBhcyBhIGRpdjsgb3IgYSBkb20gZWxlbWVudCBvciBkMyBzZWxlY3Rpb24uICBJZiB0aGUgYmFyXHJcbiAqIGNoYXJ0IGlzIGEgc3ViLWNoYXJ0IGluIGEge0BsaW5rIGRjLmNvbXBvc2l0ZUNoYXJ0IENvbXBvc2l0ZSBDaGFydH0gdGhlbiBwYXNzIGluIHRoZSBwYXJlbnRcclxuICogY29tcG9zaXRlIGNoYXJ0IGluc3RhbmNlIGluc3RlYWQuXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbY2hhcnRHcm91cF0gLSBUaGUgbmFtZSBvZiB0aGUgY2hhcnQgZ3JvdXAgdGhpcyBjaGFydCBpbnN0YW5jZSBzaG91bGQgYmUgcGxhY2VkIGluLlxyXG4gKiBJbnRlcmFjdGlvbiB3aXRoIGEgY2hhcnQgd2lsbCBvbmx5IHRyaWdnZXIgZXZlbnRzIGFuZCByZWRyYXdzIHdpdGhpbiB0aGUgY2hhcnQncyBncm91cC5cclxuICogQHJldHVybnMge2RjLmJhckNoYXJ0fVxyXG4gKi9cclxuZGMuYmFyQ2hhcnQgPSBmdW5jdGlvbiAocGFyZW50LCBjaGFydEdyb3VwKSB7XHJcbiAgICB2YXIgTUlOX0JBUl9XSURUSCA9IDE7XHJcbiAgICB2YXIgREVGQVVMVF9HQVBfQkVUV0VFTl9CQVJTID0gMjtcclxuICAgIHZhciBMQUJFTF9QQURESU5HID0gMztcclxuXHJcbiAgICB2YXIgX2NoYXJ0ID0gZGMuc3RhY2tNaXhpbihkYy5jb29yZGluYXRlR3JpZE1peGluKHt9KSk7XHJcblxyXG4gICAgdmFyIF9nYXAgPSBERUZBVUxUX0dBUF9CRVRXRUVOX0JBUlM7XHJcbiAgICB2YXIgX2NlbnRlckJhciA9IGZhbHNlO1xyXG4gICAgdmFyIF9hbHdheXNVc2VSb3VuZGluZyA9IGZhbHNlO1xyXG5cclxuICAgIHZhciBfYmFyV2lkdGg7XHJcblxyXG4gICAgZGMub3ZlcnJpZGUoX2NoYXJ0LCAncmVzY2FsZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfY2hhcnQuX3Jlc2NhbGUoKTtcclxuICAgICAgICBfYmFyV2lkdGggPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH0pO1xyXG5cclxuICAgIGRjLm92ZXJyaWRlKF9jaGFydCwgJ3JlbmRlcicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoX2NoYXJ0LnJvdW5kKCkgJiYgX2NlbnRlckJhciAmJiAhX2Fsd2F5c1VzZVJvdW5kaW5nKSB7XHJcbiAgICAgICAgICAgIGRjLmxvZ2dlci53YXJuKCdCeSBkZWZhdWx0LCBicnVzaCByb3VuZGluZyBpcyBkaXNhYmxlZCBpZiBiYXJzIGFyZSBjZW50ZXJlZC4gJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAnU2VlIGRjLmpzIGJhciBjaGFydCBBUEkgZG9jdW1lbnRhdGlvbiBmb3IgZGV0YWlscy4nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBfY2hhcnQuX3JlbmRlcigpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgX2NoYXJ0LmxhYmVsKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgcmV0dXJuIGRjLnV0aWxzLnByaW50U2luZ2xlVmFsdWUoZC55MCArIGQueSk7XHJcbiAgICB9LCBmYWxzZSk7XHJcblxyXG4gICAgX2NoYXJ0LnBsb3REYXRhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBsYXllcnMgPSBfY2hhcnQuY2hhcnRCb2R5RygpLnNlbGVjdEFsbCgnZy5zdGFjaycpXHJcbiAgICAgICAgICAgIC5kYXRhKF9jaGFydC5kYXRhKCkpO1xyXG5cclxuICAgICAgICBjYWxjdWxhdGVCYXJXaWR0aCgpO1xyXG5cclxuICAgICAgICBsYXllcnMgPSBsYXllcnNcclxuICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3N0YWNrICcgKyAnXycgKyBpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLm1lcmdlKGxheWVycyk7XHJcblxyXG4gICAgICAgIHZhciBsYXN0ID0gbGF5ZXJzLnNpemUoKSAtIDE7XHJcbiAgICAgICAgbGF5ZXJzLmVhY2goZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgdmFyIGxheWVyID0gZDMuc2VsZWN0KHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgcmVuZGVyQmFycyhsYXllciwgaSwgZCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoX2NoYXJ0LnJlbmRlckxhYmVsKCkgJiYgbGFzdCA9PT0gaSkge1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyTGFiZWxzKGxheWVyLCBpLCBkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBiYXJIZWlnaHQgKGQpIHtcclxuICAgICAgICByZXR1cm4gZGMudXRpbHMuc2FmZU51bWJlcihNYXRoLmFicyhfY2hhcnQueSgpKGQueSArIGQueTApIC0gX2NoYXJ0LnkoKShkLnkwKSkpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGxhYmVsWFBvcyAoZCkge1xyXG4gICAgICAgIHZhciB4ID0gX2NoYXJ0LngoKShkLngpO1xyXG4gICAgICAgIGlmICghX2NlbnRlckJhcikge1xyXG4gICAgICAgICAgICB4ICs9IF9iYXJXaWR0aCAvIDI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChfY2hhcnQuaXNPcmRpbmFsKCkgJiYgX2dhcCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHggKz0gX2dhcCAvIDI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkYy51dGlscy5zYWZlTnVtYmVyKHgpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGxhYmVsWVBvcyAoZCkge1xyXG4gICAgICAgIHZhciB5ID0gX2NoYXJ0LnkoKShkLnkgKyBkLnkwKTtcclxuXHJcbiAgICAgICAgaWYgKGQueSA8IDApIHtcclxuICAgICAgICAgICAgeSAtPSBiYXJIZWlnaHQoZCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZGMudXRpbHMuc2FmZU51bWJlcih5IC0gTEFCRUxfUEFERElORyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVuZGVyTGFiZWxzIChsYXllciwgbGF5ZXJJbmRleCwgZCkge1xyXG4gICAgICAgIHZhciBsYWJlbHMgPSBsYXllci5zZWxlY3RBbGwoJ3RleHQuYmFyTGFiZWwnKVxyXG4gICAgICAgICAgICAuZGF0YShkLnZhbHVlcywgZGMucGx1Y2soJ3gnKSk7XHJcblxyXG4gICAgICAgIHZhciBsYWJlbHNFbnRlclVwZGF0ZSA9IGxhYmVsc1xyXG4gICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnYmFyTGFiZWwnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIGxhYmVsWFBvcylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgbGFiZWxZUG9zKVxyXG4gICAgICAgICAgICAubWVyZ2UobGFiZWxzKTtcclxuXHJcbiAgICAgICAgaWYgKF9jaGFydC5pc09yZGluYWwoKSkge1xyXG4gICAgICAgICAgICBsYWJlbHNFbnRlclVwZGF0ZS5vbignY2xpY2snLCBfY2hhcnQub25DbGljayk7XHJcbiAgICAgICAgICAgIGxhYmVsc0VudGVyVXBkYXRlLmF0dHIoJ2N1cnNvcicsICdwb2ludGVyJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkYy50cmFuc2l0aW9uKGxhYmVsc0VudGVyVXBkYXRlLCBfY2hhcnQudHJhbnNpdGlvbkR1cmF0aW9uKCksIF9jaGFydC50cmFuc2l0aW9uRGVsYXkoKSlcclxuICAgICAgICAgICAgLmF0dHIoJ3gnLCBsYWJlbFhQb3MpXHJcbiAgICAgICAgICAgIC5hdHRyKCd5JywgbGFiZWxZUG9zKVxyXG4gICAgICAgICAgICAudGV4dChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jaGFydC5sYWJlbCgpKGQpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZGMudHJhbnNpdGlvbihsYWJlbHMuZXhpdCgpLCBfY2hhcnQudHJhbnNpdGlvbkR1cmF0aW9uKCksIF9jaGFydC50cmFuc2l0aW9uRGVsYXkoKSlcclxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIDApXHJcbiAgICAgICAgICAgIC5yZW1vdmUoKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBiYXJYUG9zIChkKSB7XHJcbiAgICAgICAgdmFyIHggPSBfY2hhcnQueCgpKGQueCk7XHJcbiAgICAgICAgaWYgKF9jZW50ZXJCYXIpIHtcclxuICAgICAgICAgICAgeCAtPSBfYmFyV2lkdGggLyAyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoX2NoYXJ0LmlzT3JkaW5hbCgpICYmIF9nYXAgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB4ICs9IF9nYXAgLyAyO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGMudXRpbHMuc2FmZU51bWJlcih4KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZW5kZXJCYXJzIChsYXllciwgbGF5ZXJJbmRleCwgZCkge1xyXG4gICAgICAgIHZhciBiYXJzID0gbGF5ZXIuc2VsZWN0QWxsKCdyZWN0LmJhcicpXHJcbiAgICAgICAgICAgIC5kYXRhKGQudmFsdWVzLCBkYy5wbHVjaygneCcpKTtcclxuXHJcbiAgICAgICAgdmFyIGVudGVyID0gYmFycy5lbnRlcigpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnYmFyJylcclxuICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCBkYy5wbHVjaygnZGF0YScsIF9jaGFydC5nZXRDb2xvcikpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4JywgYmFyWFBvcylcclxuICAgICAgICAgICAgLmF0dHIoJ3knLCBfY2hhcnQueUF4aXNIZWlnaHQoKSlcclxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIDApO1xyXG5cclxuICAgICAgICB2YXIgYmFyc0VudGVyVXBkYXRlID0gZW50ZXIubWVyZ2UoYmFycyk7XHJcblxyXG4gICAgICAgIGlmIChfY2hhcnQucmVuZGVyVGl0bGUoKSkge1xyXG4gICAgICAgICAgICBlbnRlci5hcHBlbmQoJ3RpdGxlJykudGV4dChkYy5wbHVjaygnZGF0YScsIF9jaGFydC50aXRsZShkLm5hbWUpKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoX2NoYXJ0LmlzT3JkaW5hbCgpKSB7XHJcbiAgICAgICAgICAgIGJhcnNFbnRlclVwZGF0ZS5vbignY2xpY2snLCBfY2hhcnQub25DbGljayk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkYy50cmFuc2l0aW9uKGJhcnNFbnRlclVwZGF0ZSwgX2NoYXJ0LnRyYW5zaXRpb25EdXJhdGlvbigpLCBfY2hhcnQudHJhbnNpdGlvbkRlbGF5KCkpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4JywgYmFyWFBvcylcclxuICAgICAgICAgICAgLmF0dHIoJ3knLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHkgPSBfY2hhcnQueSgpKGQueSArIGQueTApO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChkLnkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeSAtPSBiYXJIZWlnaHQoZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRjLnV0aWxzLnNhZmVOdW1iZXIoeSk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIF9iYXJXaWR0aClcclxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYmFySGVpZ2h0KGQpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuYXR0cignZmlsbCcsIGRjLnBsdWNrKCdkYXRhJywgX2NoYXJ0LmdldENvbG9yKSlcclxuICAgICAgICAgICAgLnNlbGVjdCgndGl0bGUnKS50ZXh0KGRjLnBsdWNrKCdkYXRhJywgX2NoYXJ0LnRpdGxlKGQubmFtZSkpKTtcclxuXHJcbiAgICAgICAgZGMudHJhbnNpdGlvbihiYXJzLmV4aXQoKSwgX2NoYXJ0LnRyYW5zaXRpb25EdXJhdGlvbigpLCBfY2hhcnQudHJhbnNpdGlvbkRlbGF5KCkpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4JywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIF9jaGFydC54KCkoZC54KTsgfSlcclxuICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgX2JhcldpZHRoICogMC45KVxyXG4gICAgICAgICAgICAucmVtb3ZlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlQmFyV2lkdGggKCkge1xyXG4gICAgICAgIGlmIChfYmFyV2lkdGggPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB2YXIgbnVtYmVyT2ZCYXJzID0gX2NoYXJ0LnhVbml0Q291bnQoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHBsZWFzZSBjYW4ndCB3ZSBhbHdheXMgdXNlIHJhbmdlQmFuZHMgZm9yIGJhciBjaGFydHM/XHJcbiAgICAgICAgICAgIGlmIChfY2hhcnQuaXNPcmRpbmFsKCkgJiYgX2dhcCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBfYmFyV2lkdGggPSBNYXRoLmZsb29yKF9jaGFydC54KCkuYmFuZHdpZHRoKCkpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKF9nYXApIHtcclxuICAgICAgICAgICAgICAgIF9iYXJXaWR0aCA9IE1hdGguZmxvb3IoKF9jaGFydC54QXhpc0xlbmd0aCgpIC0gKG51bWJlck9mQmFycyAtIDEpICogX2dhcCkgLyBudW1iZXJPZkJhcnMpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgX2JhcldpZHRoID0gTWF0aC5mbG9vcihfY2hhcnQueEF4aXNMZW5ndGgoKSAvICgxICsgX2NoYXJ0LmJhclBhZGRpbmcoKSkgLyBudW1iZXJPZkJhcnMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoX2JhcldpZHRoID09PSBJbmZpbml0eSB8fCBpc05hTihfYmFyV2lkdGgpIHx8IF9iYXJXaWR0aCA8IE1JTl9CQVJfV0lEVEgpIHtcclxuICAgICAgICAgICAgICAgIF9iYXJXaWR0aCA9IE1JTl9CQVJfV0lEVEg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgX2NoYXJ0LmZhZGVEZXNlbGVjdGVkQXJlYSA9IGZ1bmN0aW9uIChicnVzaFNlbGVjdGlvbikge1xyXG4gICAgICAgIHZhciBiYXJzID0gX2NoYXJ0LmNoYXJ0Qm9keUcoKS5zZWxlY3RBbGwoJ3JlY3QuYmFyJyk7XHJcblxyXG4gICAgICAgIGlmIChfY2hhcnQuaXNPcmRpbmFsKCkpIHtcclxuICAgICAgICAgICAgaWYgKF9jaGFydC5oYXNGaWx0ZXIoKSkge1xyXG4gICAgICAgICAgICAgICAgYmFycy5jbGFzc2VkKGRjLmNvbnN0YW50cy5TRUxFQ1RFRF9DTEFTUywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NoYXJ0Lmhhc0ZpbHRlcihkLngpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBiYXJzLmNsYXNzZWQoZGMuY29uc3RhbnRzLkRFU0VMRUNURURfQ0xBU1MsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFfY2hhcnQuaGFzRmlsdGVyKGQueCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJhcnMuY2xhc3NlZChkYy5jb25zdGFudHMuU0VMRUNURURfQ0xBU1MsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIGJhcnMuY2xhc3NlZChkYy5jb25zdGFudHMuREVTRUxFQ1RFRF9DTEFTUywgZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChfY2hhcnQuYnJ1c2hPbigpIHx8IF9jaGFydC5wYXJlbnRCcnVzaE9uKCkpIHtcclxuICAgICAgICAgICAgaWYgKCFfY2hhcnQuYnJ1c2hJc0VtcHR5KGJydXNoU2VsZWN0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gYnJ1c2hTZWxlY3Rpb25bMF07XHJcbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gYnJ1c2hTZWxlY3Rpb25bMV07XHJcblxyXG4gICAgICAgICAgICAgICAgYmFycy5jbGFzc2VkKGRjLmNvbnN0YW50cy5ERVNFTEVDVEVEX0NMQVNTLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkLnggPCBzdGFydCB8fCBkLnggPj0gZW5kO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBiYXJzLmNsYXNzZWQoZGMuY29uc3RhbnRzLkRFU0VMRUNURURfQ0xBU1MsIGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRoZSBiYXIgY2hhcnQgd2lsbCByZW5kZXIgZWFjaCBiYXIgY2VudGVyZWQgYXJvdW5kIHRoZSBkYXRhIHBvc2l0aW9uIG9uIHRoZSB4LWF4aXMuXHJcbiAgICAgKiBAbWV0aG9kIGNlbnRlckJhclxyXG4gICAgICogQG1lbWJlcm9mIGRjLmJhckNoYXJ0XHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NlbnRlckJhcj1mYWxzZV1cclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufGRjLmJhckNoYXJ0fVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQuY2VudGVyQmFyID0gZnVuY3Rpb24gKGNlbnRlckJhcikge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2NlbnRlckJhcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgX2NlbnRlckJhciA9IGNlbnRlckJhcjtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICBkYy5vdmVycmlkZShfY2hhcnQsICdvbkNsaWNrJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICBfY2hhcnQuX29uQ2xpY2soZC5kYXRhKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IG9yIHNldCB0aGUgc3BhY2luZyBiZXR3ZWVuIGJhcnMgYXMgYSBmcmFjdGlvbiBvZiBiYXIgc2l6ZS4gVmFsaWQgdmFsdWVzIGFyZSBiZXR3ZWVuIDAtMS5cclxuICAgICAqIFNldHRpbmcgdGhpcyB2YWx1ZSB3aWxsIGFsc28gcmVtb3ZlIGFueSBwcmV2aW91c2x5IHNldCB7QGxpbmsgZGMuYmFyQ2hhcnQjZ2FwIGdhcH0uIFNlZSB0aGVcclxuICAgICAqIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2NhbGUvYmxvYi9tYXN0ZXIvUkVBRE1FLm1kI3NjYWxlQmFuZCBkMyBkb2NzfVxyXG4gICAgICogZm9yIGEgdmlzdWFsIGRlc2NyaXB0aW9uIG9mIGhvdyB0aGUgcGFkZGluZyBpcyBhcHBsaWVkLlxyXG4gICAgICogQG1ldGhvZCBiYXJQYWRkaW5nXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuYmFyQ2hhcnRcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtiYXJQYWRkaW5nPTBdXHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfGRjLmJhckNoYXJ0fVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQuYmFyUGFkZGluZyA9IGZ1bmN0aW9uIChiYXJQYWRkaW5nKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfY2hhcnQuX3JhbmdlQmFuZFBhZGRpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX2NoYXJ0Ll9yYW5nZUJhbmRQYWRkaW5nKGJhclBhZGRpbmcpO1xyXG4gICAgICAgIF9nYXAgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgX2NoYXJ0Ll91c2VPdXRlclBhZGRpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9nYXAgPT09IHVuZGVmaW5lZDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgb3Igc2V0IHRoZSBvdXRlciBwYWRkaW5nIG9uIGFuIG9yZGluYWwgYmFyIGNoYXJ0LiBUaGlzIHNldHRpbmcgaGFzIG5vIGVmZmVjdCBvbiBub24tb3JkaW5hbCBjaGFydHMuXHJcbiAgICAgKiBXaWxsIHBhZCB0aGUgd2lkdGggYnkgYHBhZGRpbmcgKiBiYXJXaWR0aGAgb24gZWFjaCBzaWRlIG9mIHRoZSBjaGFydC5cclxuICAgICAqIEBtZXRob2Qgb3V0ZXJQYWRkaW5nXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuYmFyQ2hhcnRcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYWRkaW5nPTAuNV1cclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ8ZGMuYmFyQ2hhcnR9XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5vdXRlclBhZGRpbmcgPSBfY2hhcnQuX291dGVyUmFuZ2VCYW5kUGFkZGluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hbnVhbGx5IHNldCBmaXhlZCBnYXAgKGluIHB4KSBiZXR3ZWVuIGJhcnMgaW5zdGVhZCBvZiByZWx5aW5nIG9uIHRoZSBkZWZhdWx0IGF1dG8tZ2VuZXJhdGVkXHJcbiAgICAgKiBnYXAuICBCeSBkZWZhdWx0IHRoZSBiYXIgY2hhcnQgaW1wbGVtZW50YXRpb24gd2lsbCBjYWxjdWxhdGUgYW5kIHNldCB0aGUgZ2FwIGF1dG9tYXRpY2FsbHlcclxuICAgICAqIGJhc2VkIG9uIHRoZSBudW1iZXIgb2YgZGF0YSBwb2ludHMgYW5kIHRoZSBsZW5ndGggb2YgdGhlIHggYXhpcy5cclxuICAgICAqIEBtZXRob2QgZ2FwXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuYmFyQ2hhcnRcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtnYXA9Ml1cclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ8ZGMuYmFyQ2hhcnR9XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5nYXAgPSBmdW5jdGlvbiAoZ2FwKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfZ2FwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfZ2FwID0gZ2FwO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF9jaGFydC5leHRlbmRCcnVzaCA9IGZ1bmN0aW9uIChicnVzaFNlbGVjdGlvbikge1xyXG4gICAgICAgIGlmIChicnVzaFNlbGVjdGlvbiAmJiBfY2hhcnQucm91bmQoKSAmJiAoIV9jZW50ZXJCYXIgfHwgX2Fsd2F5c1VzZVJvdW5kaW5nKSkge1xyXG4gICAgICAgICAgICBicnVzaFNlbGVjdGlvblswXSA9IF9jaGFydC5yb3VuZCgpKGJydXNoU2VsZWN0aW9uWzBdKTtcclxuICAgICAgICAgICAgYnJ1c2hTZWxlY3Rpb25bMV0gPSBfY2hhcnQucm91bmQoKShicnVzaFNlbGVjdGlvblsxXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBicnVzaFNlbGVjdGlvbjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgb3IgZ2V0IHdoZXRoZXIgcm91bmRpbmcgaXMgZW5hYmxlZCB3aGVuIGJhcnMgYXJlIGNlbnRlcmVkLiBJZiBmYWxzZSwgdXNpbmdcclxuICAgICAqIHJvdW5kaW5nIHdpdGggY2VudGVyZWQgYmFycyB3aWxsIHJlc3VsdCBpbiBhIHdhcm5pbmcgYW5kIHJvdW5kaW5nIHdpbGwgYmUgaWdub3JlZC4gIFRoaXMgZmxhZ1xyXG4gICAgICogaGFzIG5vIGVmZmVjdCBpZiBiYXJzIGFyZSBub3Qge0BsaW5rIGRjLmJhckNoYXJ0I2NlbnRlckJhciBjZW50ZXJlZH0uXHJcbiAgICAgKiBXaGVuIHVzaW5nIHN0YW5kYXJkIGQzLmpzIHJvdW5kaW5nIG1ldGhvZHMsIHRoZSBicnVzaCBvZnRlbiBkb2Vzbid0IGFsaWduIGNvcnJlY3RseSB3aXRoXHJcbiAgICAgKiBjZW50ZXJlZCBiYXJzIHNpbmNlIHRoZSBiYXJzIGFyZSBvZmZzZXQuICBUaGUgcm91bmRpbmcgZnVuY3Rpb24gbXVzdCBhZGQgYW4gb2Zmc2V0IHRvXHJcbiAgICAgKiBjb21wZW5zYXRlLCBzdWNoIGFzIGluIHRoZSBmb2xsb3dpbmcgZXhhbXBsZS5cclxuICAgICAqIEBtZXRob2QgYWx3YXlzVXNlUm91bmRpbmdcclxuICAgICAqIEBtZW1iZXJvZiBkYy5iYXJDaGFydFxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogY2hhcnQucm91bmQoZnVuY3Rpb24obikgeyByZXR1cm4gTWF0aC5mbG9vcihuKSArIDAuNTsgfSk7XHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFthbHdheXNVc2VSb3VuZGluZz1mYWxzZV1cclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufGRjLmJhckNoYXJ0fVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQuYWx3YXlzVXNlUm91bmRpbmcgPSBmdW5jdGlvbiAoYWx3YXlzVXNlUm91bmRpbmcpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9hbHdheXNVc2VSb3VuZGluZztcclxuICAgICAgICB9XHJcbiAgICAgICAgX2Fsd2F5c1VzZVJvdW5kaW5nID0gYWx3YXlzVXNlUm91bmRpbmc7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gY29sb3JGaWx0ZXIgKGNvbG9yLCBpbnYpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgaXRlbSA9IGQzLnNlbGVjdCh0aGlzKTtcclxuICAgICAgICAgICAgdmFyIG1hdGNoID0gaXRlbS5hdHRyKCdmaWxsJykgPT09IGNvbG9yO1xyXG4gICAgICAgICAgICByZXR1cm4gaW52ID8gIW1hdGNoIDogbWF0Y2g7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBfY2hhcnQubGVnZW5kSGlnaGxpZ2h0ID0gZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICBpZiAoIV9jaGFydC5pc0xlZ2VuZGFibGVIaWRkZW4oZCkpIHtcclxuICAgICAgICAgICAgX2NoYXJ0LmcoKS5zZWxlY3RBbGwoJ3JlY3QuYmFyJylcclxuICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdoaWdobGlnaHQnLCBjb2xvckZpbHRlcihkLmNvbG9yKSlcclxuICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdmYWRlb3V0JywgY29sb3JGaWx0ZXIoZC5jb2xvciwgdHJ1ZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgX2NoYXJ0LmxlZ2VuZFJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9jaGFydC5nKCkuc2VsZWN0QWxsKCdyZWN0LmJhcicpXHJcbiAgICAgICAgICAgIC5jbGFzc2VkKCdoaWdobGlnaHQnLCBmYWxzZSlcclxuICAgICAgICAgICAgLmNsYXNzZWQoJ2ZhZGVvdXQnLCBmYWxzZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGRjLm92ZXJyaWRlKF9jaGFydCwgJ3hBeGlzTWF4JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBtYXggPSB0aGlzLl94QXhpc01heCgpO1xyXG4gICAgICAgIGlmICgncmVzb2x1dGlvbicgaW4gX2NoYXJ0LnhVbml0cygpKSB7XHJcbiAgICAgICAgICAgIHZhciByZXMgPSBfY2hhcnQueFVuaXRzKCkucmVzb2x1dGlvbjtcclxuICAgICAgICAgICAgbWF4ICs9IHJlcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1heDtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBfY2hhcnQuYW5jaG9yKHBhcmVudCwgY2hhcnRHcm91cCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29uY3JldGUgbGluZS9hcmVhIGNoYXJ0IGltcGxlbWVudGF0aW9uLlxyXG4gKlxyXG4gKiBFeGFtcGxlczpcclxuICogLSB7QGxpbmsgaHR0cDovL2RjLWpzLmdpdGh1Yi5jb20vZGMuanMvIE5hc2RhcSAxMDAgSW5kZXh9XHJcbiAqIC0ge0BsaW5rIGh0dHA6Ly9kYy1qcy5naXRodWIuY29tL2RjLmpzL2NyaW1lL2luZGV4Lmh0bWwgQ2FuYWRpYW4gQ2l0eSBDcmltZSBTdGF0c31cclxuICogQGNsYXNzIGxpbmVDaGFydFxyXG4gKiBAbWVtYmVyb2YgZGNcclxuICogQG1peGVzIGRjLnN0YWNrTWl4aW5cclxuICogQG1peGVzIGRjLmNvb3JkaW5hdGVHcmlkTWl4aW5cclxuICogQGV4YW1wbGVcclxuICogLy8gY3JlYXRlIGEgbGluZSBjaGFydCB1bmRlciAjY2hhcnQtY29udGFpbmVyMSBlbGVtZW50IHVzaW5nIHRoZSBkZWZhdWx0IGdsb2JhbCBjaGFydCBncm91cFxyXG4gKiB2YXIgY2hhcnQxID0gZGMubGluZUNoYXJ0KCcjY2hhcnQtY29udGFpbmVyMScpO1xyXG4gKiAvLyBjcmVhdGUgYSBsaW5lIGNoYXJ0IHVuZGVyICNjaGFydC1jb250YWluZXIyIGVsZW1lbnQgdXNpbmcgY2hhcnQgZ3JvdXAgQVxyXG4gKiB2YXIgY2hhcnQyID0gZGMubGluZUNoYXJ0KCcjY2hhcnQtY29udGFpbmVyMicsICdjaGFydEdyb3VwQScpO1xyXG4gKiAvLyBjcmVhdGUgYSBzdWItY2hhcnQgdW5kZXIgYSBjb21wb3NpdGUgcGFyZW50IGNoYXJ0XHJcbiAqIHZhciBjaGFydDMgPSBkYy5saW5lQ2hhcnQoY29tcG9zaXRlQ2hhcnQpO1xyXG4gKiBAcGFyYW0ge1N0cmluZ3xub2RlfGQzLnNlbGVjdGlvbnxkYy5jb21wb3NpdGVDaGFydH0gcGFyZW50IC0gQW55IHZhbGlkXHJcbiAqIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2VsZWN0aW9uL2Jsb2IvbWFzdGVyL1JFQURNRS5tZCNzZWxlY3QgZDMgc2luZ2xlIHNlbGVjdG9yfVxyXG4gKiBzcGVjaWZ5aW5nIGEgZG9tIGJsb2NrIGVsZW1lbnQgc3VjaCBhcyBhIGRpdjsgb3IgYSBkb20gZWxlbWVudCBvciBkMyBzZWxlY3Rpb24uICBJZiB0aGUgbGluZVxyXG4gKiBjaGFydCBpcyBhIHN1Yi1jaGFydCBpbiBhIHtAbGluayBkYy5jb21wb3NpdGVDaGFydCBDb21wb3NpdGUgQ2hhcnR9IHRoZW4gcGFzcyBpbiB0aGUgcGFyZW50XHJcbiAqIGNvbXBvc2l0ZSBjaGFydCBpbnN0YW5jZSBpbnN0ZWFkLlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gW2NoYXJ0R3JvdXBdIC0gVGhlIG5hbWUgb2YgdGhlIGNoYXJ0IGdyb3VwIHRoaXMgY2hhcnQgaW5zdGFuY2Ugc2hvdWxkIGJlIHBsYWNlZCBpbi5cclxuICogSW50ZXJhY3Rpb24gd2l0aCBhIGNoYXJ0IHdpbGwgb25seSB0cmlnZ2VyIGV2ZW50cyBhbmQgcmVkcmF3cyB3aXRoaW4gdGhlIGNoYXJ0J3MgZ3JvdXAuXHJcbiAqIEByZXR1cm5zIHtkYy5saW5lQ2hhcnR9XHJcbiAqL1xyXG5kYy5saW5lQ2hhcnQgPSBmdW5jdGlvbiAocGFyZW50LCBjaGFydEdyb3VwKSB7XHJcbiAgICB2YXIgREVGQVVMVF9ET1RfUkFESVVTID0gNTtcclxuICAgIHZhciBUT09MVElQX0dfQ0xBU1MgPSAnZGMtdG9vbHRpcCc7XHJcbiAgICB2YXIgRE9UX0NJUkNMRV9DTEFTUyA9ICdkb3QnO1xyXG4gICAgdmFyIFlfQVhJU19SRUZfTElORV9DTEFTUyA9ICd5UmVmJztcclxuICAgIHZhciBYX0FYSVNfUkVGX0xJTkVfQ0xBU1MgPSAneFJlZic7XHJcbiAgICB2YXIgREVGQVVMVF9ET1RfT1BBQ0lUWSA9IDFlLTY7XHJcbiAgICB2YXIgTEFCRUxfUEFERElORyA9IDM7XHJcblxyXG4gICAgdmFyIF9jaGFydCA9IGRjLnN0YWNrTWl4aW4oZGMuY29vcmRpbmF0ZUdyaWRNaXhpbih7fSkpO1xyXG4gICAgdmFyIF9yZW5kZXJBcmVhID0gZmFsc2U7XHJcbiAgICB2YXIgX2RvdFJhZGl1cyA9IERFRkFVTFRfRE9UX1JBRElVUztcclxuICAgIHZhciBfZGF0YVBvaW50UmFkaXVzID0gbnVsbDtcclxuICAgIHZhciBfZGF0YVBvaW50RmlsbE9wYWNpdHkgPSBERUZBVUxUX0RPVF9PUEFDSVRZO1xyXG4gICAgdmFyIF9kYXRhUG9pbnRTdHJva2VPcGFjaXR5ID0gREVGQVVMVF9ET1RfT1BBQ0lUWTtcclxuICAgIHZhciBfY3VydmUgPSBudWxsO1xyXG4gICAgdmFyIF9pbnRlcnBvbGF0ZSA9IG51bGw7IC8vIGQzLmN1cnZlTGluZWFyOyAgLy8gZGVwcmVjYXRlZCBpbiAzLjBcclxuICAgIHZhciBfdGVuc2lvbiA9IG51bGw7ICAvLyBkZXByZWNhdGVkIGluIDMuMFxyXG4gICAgdmFyIF9kZWZpbmVkO1xyXG4gICAgdmFyIF9kYXNoU3R5bGU7XHJcbiAgICB2YXIgX3h5VGlwc09uID0gdHJ1ZTtcclxuXHJcbiAgICBfY2hhcnQudHJhbnNpdGlvbkR1cmF0aW9uKDUwMCk7XHJcbiAgICBfY2hhcnQudHJhbnNpdGlvbkRlbGF5KDApO1xyXG4gICAgX2NoYXJ0Ll9yYW5nZUJhbmRQYWRkaW5nKDEpO1xyXG5cclxuICAgIF9jaGFydC5wbG90RGF0YSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY2hhcnRCb2R5ID0gX2NoYXJ0LmNoYXJ0Qm9keUcoKTtcclxuICAgICAgICB2YXIgbGF5ZXJzTGlzdCA9IGNoYXJ0Qm9keS5zZWxlY3QoJ2cuc3RhY2stbGlzdCcpO1xyXG5cclxuICAgICAgICBpZiAobGF5ZXJzTGlzdC5lbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIGxheWVyc0xpc3QgPSBjaGFydEJvZHkuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnc3RhY2stbGlzdCcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGxheWVycyA9IGxheWVyc0xpc3Quc2VsZWN0QWxsKCdnLnN0YWNrJykuZGF0YShfY2hhcnQuZGF0YSgpKTtcclxuXHJcbiAgICAgICAgdmFyIGxheWVyc0VudGVyID0gbGF5ZXJzXHJcbiAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdzdGFjayAnICsgJ18nICsgaTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGxheWVycyA9IGxheWVyc0VudGVyLm1lcmdlKGxheWVycyk7XHJcblxyXG4gICAgICAgIGRyYXdMaW5lKGxheWVyc0VudGVyLCBsYXllcnMpO1xyXG5cclxuICAgICAgICBkcmF3QXJlYShsYXllcnNFbnRlciwgbGF5ZXJzKTtcclxuXHJcbiAgICAgICAgZHJhd0RvdHMoY2hhcnRCb2R5LCBsYXllcnMpO1xyXG5cclxuICAgICAgICBpZiAoX2NoYXJ0LnJlbmRlckxhYmVsKCkpIHtcclxuICAgICAgICAgICAgZHJhd0xhYmVscyhsYXllcnMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGN1cnZlIGZhY3RvcnkgdG8gdXNlIGZvciBsaW5lcyBhbmQgYXJlYXMgZHJhd24sIGFsbG93aW5nIGUuZy4gc3RlcFxyXG4gICAgICogZnVuY3Rpb25zLCBzcGxpbmVzLCBhbmQgY3ViaWMgaW50ZXJwb2xhdGlvbi4gVHlwaWNhbGx5IHlvdSB3b3VsZCB1c2Ugb25lIG9mIHRoZSBpbnRlcnBvbGF0b3IgZnVuY3Rpb25zXHJcbiAgICAgKiBwcm92aWRlZCBieSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNoYXBlL2Jsb2IvbWFzdGVyL1JFQURNRS5tZCNjdXJ2ZXMgZDMgY3VydmVzfS5cclxuICAgICAqXHJcbiAgICAgKiBSZXBsYWNlcyB0aGUgdXNlIG9mIHtAbGluayBkYy5saW5lQ2hhcnQjaW50ZXJwb2xhdGV9IGFuZCB7QGxpbmsgZGMubGluZUNoYXJ0I3RlbnNpb259XHJcbiAgICAgKiBpbiBkYy5qcyA8IDMuMFxyXG4gICAgICpcclxuICAgICAqIFRoaXMgaXMgcGFzc2VkIHRvXHJcbiAgICAgKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNoYXBlL2Jsb2IvbWFzdGVyL1JFQURNRS5tZCNsaW5lX2N1cnZlIGxpbmUuY3VydmV9IGFuZFxyXG4gICAgICoge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1zaGFwZS9ibG9iL21hc3Rlci9SRUFETUUubWQjYXJlYV9jdXJ2ZSBhcmVhLmN1cnZlfS5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBkZWZhdWx0XHJcbiAgICAgKiBjaGFydFxyXG4gICAgICogICAgIC5jdXJ2ZShkMy5jdXJ2ZUxpbmVhcik7XHJcbiAgICAgKiAvLyBBZGQgdGVuc2lvbiB0byBjdXJ2ZXMgdGhhdCBzdXBwb3J0IGl0XHJcbiAgICAgKiBjaGFydFxyXG4gICAgICogICAgIC5jdXJ2ZShkMy5jdXJ2ZUNhcmRpbmFsLnRlbnNpb24oMC41KSk7XHJcbiAgICAgKiAvLyBZb3UgY2FuIHVzZSBzb21lIHNwZWNpYWxpemVkIHZhcmlhdGlvbiBsaWtlXHJcbiAgICAgKiAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DZW50cmlwZXRhbF9DYXRtdWxsJUUyJTgwJTkzUm9tX3NwbGluZVxyXG4gICAgICogY2hhcnRcclxuICAgICAqICAgICAuY3VydmUoZDMuY3VydmVDYXRtdWxsUm9tLmFscGhhKDAuNSkpO1xyXG4gICAgICogQG1ldGhvZCBjdXJ2ZVxyXG4gICAgICogQG1lbWJlcm9mIGRjLmxpbmVDaGFydFxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2hhcGUvYmxvYi9tYXN0ZXIvUkVBRE1FLm1kI2xpbmVfY3VydmUgbGluZS5jdXJ2ZX1cclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1zaGFwZS9ibG9iL21hc3Rlci9SRUFETUUubWQjYXJlYV9jdXJ2ZSBhcmVhLmN1cnZlfVxyXG4gICAgICogQHBhcmFtICB7ZDMuY3VydmV9IFtjdXJ2ZT1kMy5jdXJ2ZUxpbmVhcl1cclxuICAgICAqIEByZXR1cm5zIHtkMy5jdXJ2ZXxkYy5saW5lQ2hhcnR9XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5jdXJ2ZSA9IGZ1bmN0aW9uIChjdXJ2ZSkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2N1cnZlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfY3VydmUgPSBjdXJ2ZTtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgaW50ZXJwb2xhdG9yIHRvIHVzZSBmb3IgbGluZXMgZHJhd24sIGJ5IHN0cmluZyBuYW1lLCBhbGxvd2luZyBlLmcuIHN0ZXBcclxuICAgICAqIGZ1bmN0aW9ucywgc3BsaW5lcywgYW5kIGN1YmljIGludGVycG9sYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogUG9zc2libGUgdmFsdWVzIGFyZTogJ2xpbmVhcicsICdsaW5lYXItY2xvc2VkJywgJ3N0ZXAnLCAnc3RlcC1iZWZvcmUnLCAnc3RlcC1hZnRlcicsICdiYXNpcycsXHJcbiAgICAgKiAnYmFzaXMtb3BlbicsICdiYXNpcy1jbG9zZWQnLCAnYnVuZGxlJywgJ2NhcmRpbmFsJywgJ2NhcmRpbmFsLW9wZW4nLCAnY2FyZGluYWwtY2xvc2VkJywgYW5kXHJcbiAgICAgKiAnbW9ub3RvbmUnLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgZnVuY3Rpb24gZXhpc3RzIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LiBVc2Uge0BsaW5rIGRjLmxpbmVDaGFydCNjdXJ2ZX1cclxuICAgICAqIHdoaWNoIGlzIGdlbmVyaWMgYW5kIHByb3ZpZGVzIG1vcmUgb3B0aW9ucy5cclxuICAgICAqIFZhbHVlIHNldCB0aHJvdWdoIGAuY3VydmVgIHRha2VzIHByZWNlZGVuY2Ugb3ZlciBgLmludGVycG9sYXRlYCBhbmQgYC50ZW5zaW9uYC5cclxuICAgICAqIEBtZXRob2QgaW50ZXJwb2xhdGVcclxuICAgICAqIEBtZW1iZXJvZiBkYy5saW5lQ2hhcnRcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAzLjAgdXNlIHtAbGluayBkYy5saW5lQ2hhcnQjY3VydmV9IGluc3RlYWRcclxuICAgICAqIEBzZWUge0BsaW5rIGRjLmxpbmVDaGFydCNjdXJ2ZX1cclxuICAgICAqIEBwYXJhbSAge2QzLmN1cnZlfSBbaW50ZXJwb2xhdGU9ZDMuY3VydmVMaW5lYXJdXHJcbiAgICAgKiBAcmV0dXJucyB7ZDMuY3VydmV8ZGMubGluZUNoYXJ0fVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQuaW50ZXJwb2xhdGUgPSBkYy5sb2dnZXIuZGVwcmVjYXRlKGZ1bmN0aW9uIChpbnRlcnBvbGF0ZSkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2ludGVycG9sYXRlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfaW50ZXJwb2xhdGUgPSBpbnRlcnBvbGF0ZTtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfSwgJ2RjLmxpbmVDaGFydC5pbnRlcnBvbGF0ZSBoYXMgYmVlbiBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMy4wIHVzZSBkYy5saW5lQ2hhcnQuY3VydmUgaW5zdGVhZCcpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSB0ZW5zaW9uIHRvIHVzZSBmb3IgbGluZXMgZHJhd24sIGluIHRoZSByYW5nZSAwIHRvIDEuXHJcbiAgICAgKlxyXG4gICAgICogUGFzc2VkIHRvIHRoZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNoYXBlL2Jsb2IvbWFzdGVyL1JFQURNRS5tZCNjdXJ2ZXMgZDMgY3VydmUgZnVuY3Rpb259XHJcbiAgICAgKiBpZiBpdCBwcm92aWRlcyBhIGAudGVuc2lvbmAgZnVuY3Rpb24uIEV4YW1wbGU6XHJcbiAgICAgKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNoYXBlL2Jsb2IvbWFzdGVyL1JFQURNRS5tZCNjdXJ2ZUNhcmRpbmFsX3RlbnNpb24gY3VydmVDYXJkaW5hbC50ZW5zaW9ufS5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGV4aXN0cyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS4gVXNlIHtAbGluayBkYy5saW5lQ2hhcnQjY3VydmV9XHJcbiAgICAgKiB3aGljaCBpcyBnZW5lcmljIGFuZCBwcm92aWRlcyBtb3JlIG9wdGlvbnMuXHJcbiAgICAgKiBWYWx1ZSBzZXQgdGhyb3VnaCBgLmN1cnZlYCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgYC5pbnRlcnBvbGF0ZWAgYW5kIGAudGVuc2lvbmAuXHJcbiAgICAgKiBAbWV0aG9kIHRlbnNpb25cclxuICAgICAqIEBtZW1iZXJvZiBkYy5saW5lQ2hhcnRcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAzLjAgdXNlIHtAbGluayBkYy5saW5lQ2hhcnQjY3VydmV9IGluc3RlYWRcclxuICAgICAqIEBzZWUge0BsaW5rIGRjLmxpbmVDaGFydCNjdXJ2ZX1cclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gW3RlbnNpb249MF1cclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ8ZGMubGluZUNoYXJ0fVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQudGVuc2lvbiA9IGRjLmxvZ2dlci5kZXByZWNhdGUoZnVuY3Rpb24gKHRlbnNpb24pIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF90ZW5zaW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfdGVuc2lvbiA9IHRlbnNpb247XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH0sICdkYy5saW5lQ2hhcnQudGVuc2lvbiBoYXMgYmVlbiBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMy4wIHVzZSBkYy5saW5lQ2hhcnQuY3VydmUgaW5zdGVhZCcpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGRldGVybWluZSBkaXNjb250aW51aXRpZXMgaW4gdGhlIGxpbmUgd2hpY2ggc2hvdWxkIGJlXHJcbiAgICAgKiBza2lwcGVkOiB0aGUgcGF0aCB3aWxsIGJlIGJyb2tlbiBpbnRvIHNlcGFyYXRlIHN1YnBhdGhzIGlmIHNvbWUgcG9pbnRzIGFyZSB1bmRlZmluZWQuXHJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHBhc3NlZCB0b1xyXG4gICAgICoge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1zaGFwZS9ibG9iL21hc3Rlci9SRUFETUUubWQjbGluZV9kZWZpbmVkIGxpbmUuZGVmaW5lZH1cclxuICAgICAqXHJcbiAgICAgKiBOb3RlOiBjcm9zc2ZpbHRlciB3aWxsIHNvbWV0aW1lcyBjb2VyY2UgbnVsbHMgdG8gMCwgc28geW91IG1heSBuZWVkIHRvIGNhcmVmdWxseSB3cml0ZVxyXG4gICAgICogY3VzdG9tIHJlZHVjZSBmdW5jdGlvbnMgdG8gZ2V0IHRoaXMgdG8gd29yaywgZGVwZW5kaW5nIG9uIHlvdXIgZGF0YS4gU2VlXHJcbiAgICAgKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2RjLWpzL2RjLmpzL2lzc3Vlcy82MTUjaXNzdWVjb21tZW50LTQ5MDg5MjQ4IHRoaXMgR2l0SHViIGNvbW1lbnR9XHJcbiAgICAgKiBmb3IgbW9yZSBkZXRhaWxzIGFuZCBhbiBleGFtcGxlLlxyXG4gICAgICogQG1ldGhvZCBkZWZpbmVkXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMubGluZUNoYXJ0XHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1zaGFwZS9ibG9iL21hc3Rlci9SRUFETUUubWQjbGluZV9kZWZpbmVkIGxpbmUuZGVmaW5lZH1cclxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBbZGVmaW5lZF1cclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbnxkYy5saW5lQ2hhcnR9XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5kZWZpbmVkID0gZnVuY3Rpb24gKGRlZmluZWQpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfZGVmaW5lZCA9IGRlZmluZWQ7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIGxpbmUncyBkMyBkYXNoc3R5bGUuIFRoaXMgdmFsdWUgYmVjb21lcyB0aGUgJ3N0cm9rZS1kYXNoYXJyYXknIG9mIGxpbmUuIERlZmF1bHRzIHRvIGVtcHR5XHJcbiAgICAgKiBhcnJheSAoc29saWQgbGluZSkuXHJcbiAgICAgKiBAbWV0aG9kIGRhc2hTdHlsZVxyXG4gICAgICogQG1lbWJlcm9mIGRjLmxpbmVDaGFydFxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1kYXNoYXJyYXkgc3Ryb2tlLWRhc2hhcnJheX1cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBjcmVhdGUgYSBEYXNoIERvdCBEb3QgRG90XHJcbiAgICAgKiBjaGFydC5kYXNoU3R5bGUoWzMsMSwxLDFdKTtcclxuICAgICAqIEBwYXJhbSAge0FycmF5PE51bWJlcj59IFtkYXNoU3R5bGU9W11dXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8TnVtYmVyPnxkYy5saW5lQ2hhcnR9XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5kYXNoU3R5bGUgPSBmdW5jdGlvbiAoZGFzaFN0eWxlKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfZGFzaFN0eWxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfZGFzaFN0eWxlID0gZGFzaFN0eWxlO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IG9yIHNldCByZW5kZXIgYXJlYSBmbGFnLiBJZiB0aGUgZmxhZyBpcyBzZXQgdG8gdHJ1ZSB0aGVuIHRoZSBjaGFydCB3aWxsIHJlbmRlciB0aGUgYXJlYVxyXG4gICAgICogYmVuZWF0aCBlYWNoIGxpbmUgYW5kIHRoZSBsaW5lIGNoYXJ0IGVmZmVjdGl2ZWx5IGJlY29tZXMgYW4gYXJlYSBjaGFydC5cclxuICAgICAqIEBtZXRob2QgcmVuZGVyQXJlYVxyXG4gICAgICogQG1lbWJlcm9mIGRjLmxpbmVDaGFydFxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBbcmVuZGVyQXJlYT1mYWxzZV1cclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufGRjLmxpbmVDaGFydH1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LnJlbmRlckFyZWEgPSBmdW5jdGlvbiAocmVuZGVyQXJlYSkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3JlbmRlckFyZWE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9yZW5kZXJBcmVhID0gcmVuZGVyQXJlYTtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBjb2xvcnMgKGQsIGkpIHtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0LmdldENvbG9yLmNhbGwoZCwgZC52YWx1ZXMsIGkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRvIGtlZXAgaXQgYmFja3dhcmQgY29tcGF0aWJsZSwgdGhpcyBjb3ZlcnMgbXVsdGlwbGUgY2FzZXNcclxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZGMtanMvZGMuanMvaXNzdWVzLzEzNzZcclxuICAgIC8vIEl0IHdpbGwgYmUgcmVtb3ZlZCB3aGVuIGludGVycG9sYXRlIGFuZCB0ZW5zaW9uIGFyZSByZW1vdmVkLlxyXG4gICAgZnVuY3Rpb24gZ2V0Q3VydmVGYWN0b3J5ICgpIHtcclxuICAgICAgICB2YXIgY3VydmUgPSBudWxsO1xyXG5cclxuICAgICAgICAvLyBfY3VydmUgdGFrZXMgcHJlY2VkZW5jZVxyXG4gICAgICAgIGlmIChfY3VydmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9jdXJ2ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEFwcHJveGltYXRlIHRoZSBEM3YzIGJlaGF2aW9yXHJcbiAgICAgICAgaWYgKHR5cGVvZiBfaW50ZXJwb2xhdGUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgY3VydmUgPSBfaW50ZXJwb2xhdGU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gSWYgX2ludGVycG9sYXRlIGlzIHN0cmluZ1xyXG4gICAgICAgICAgICB2YXIgbWFwcGluZyA9IHtcclxuICAgICAgICAgICAgICAgICdsaW5lYXInOiBkMy5jdXJ2ZUxpbmVhcixcclxuICAgICAgICAgICAgICAgICdsaW5lYXItY2xvc2VkJzogZDMuY3VydmVMaW5lYXJDbG9zZWQsXHJcbiAgICAgICAgICAgICAgICAnc3RlcCc6IGQzLmN1cnZlU3RlcCxcclxuICAgICAgICAgICAgICAgICdzdGVwLWJlZm9yZSc6IGQzLmN1cnZlU3RlcEJlZm9yZSxcclxuICAgICAgICAgICAgICAgICdzdGVwLWFmdGVyJzogZDMuY3VydmVTdGVwQWZ0ZXIsXHJcbiAgICAgICAgICAgICAgICAnYmFzaXMnOiBkMy5jdXJ2ZUJhc2lzLFxyXG4gICAgICAgICAgICAgICAgJ2Jhc2lzLW9wZW4nOiBkMy5jdXJ2ZUJhc2lzT3BlbixcclxuICAgICAgICAgICAgICAgICdiYXNpcy1jbG9zZWQnOiBkMy5jdXJ2ZUJhc2lzQ2xvc2VkLFxyXG4gICAgICAgICAgICAgICAgJ2J1bmRsZSc6IGQzLmN1cnZlQnVuZGxlLFxyXG4gICAgICAgICAgICAgICAgJ2NhcmRpbmFsJzogZDMuY3VydmVDYXJkaW5hbCxcclxuICAgICAgICAgICAgICAgICdjYXJkaW5hbC1vcGVuJzogZDMuY3VydmVDYXJkaW5hbE9wZW4sXHJcbiAgICAgICAgICAgICAgICAnY2FyZGluYWwtY2xvc2VkJzogZDMuY3VydmVDYXJkaW5hbENsb3NlZCxcclxuICAgICAgICAgICAgICAgICdtb25vdG9uZSc6IGQzLmN1cnZlTW9ub3RvbmVYXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGN1cnZlID0gbWFwcGluZ1tfaW50ZXJwb2xhdGVdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRGVmYXVsdCB2YWx1ZVxyXG4gICAgICAgIGlmICghY3VydmUpIHtcclxuICAgICAgICAgICAgY3VydmUgPSBkMy5jdXJ2ZUxpbmVhcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChfdGVuc2lvbiAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGN1cnZlLnRlbnNpb24gIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIGRjLmxvZ2dlci53YXJuKCd0ZW5zaW9uIHdhcyBzcGVjaWZpZWQgYnV0IHRoZSBjdXJ2ZS9pbnRlcnBvbGF0ZSBkb2VzIG5vdCBzdXBwb3J0IGl0LicpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY3VydmUgPSBjdXJ2ZS50ZW5zaW9uKF90ZW5zaW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY3VydmU7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd0xpbmUgKGxheWVyc0VudGVyLCBsYXllcnMpIHtcclxuICAgICAgICB2YXIgbGluZSA9IGQzLmxpbmUoKVxyXG4gICAgICAgICAgICAueChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jaGFydC54KCkoZC54KTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLnkoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfY2hhcnQueSgpKGQueSArIGQueTApO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuY3VydmUoZ2V0Q3VydmVGYWN0b3J5KCkpO1xyXG4gICAgICAgIGlmIChfZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBsaW5lLmRlZmluZWQoX2RlZmluZWQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHBhdGggPSBsYXllcnNFbnRlci5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbGluZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCBjb2xvcnMpO1xyXG4gICAgICAgIGlmIChfZGFzaFN0eWxlKSB7XHJcbiAgICAgICAgICAgIHBhdGguYXR0cignc3Ryb2tlLWRhc2hhcnJheScsIF9kYXNoU3R5bGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZGMudHJhbnNpdGlvbihsYXllcnMuc2VsZWN0KCdwYXRoLmxpbmUnKSwgX2NoYXJ0LnRyYW5zaXRpb25EdXJhdGlvbigpLCBfY2hhcnQudHJhbnNpdGlvbkRlbGF5KCkpXHJcbiAgICAgICAgICAgIC8vLmVhc2UoJ2xpbmVhcicpXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCBjb2xvcnMpXHJcbiAgICAgICAgICAgIC5hdHRyKCdkJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzYWZlRChsaW5lKGQudmFsdWVzKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRyYXdBcmVhIChsYXllcnNFbnRlciwgbGF5ZXJzKSB7XHJcbiAgICAgICAgaWYgKF9yZW5kZXJBcmVhKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmVhID0gZDMuYXJlYSgpXHJcbiAgICAgICAgICAgICAgICAueChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfY2hhcnQueCgpKGQueCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLnkxKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jaGFydC55KCkoZC55ICsgZC55MCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLnkwKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jaGFydC55KCkoZC55MCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmN1cnZlKGdldEN1cnZlRmFjdG9yeSgpKTtcclxuICAgICAgICAgICAgaWYgKF9kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBhcmVhLmRlZmluZWQoX2RlZmluZWQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsYXllcnNFbnRlci5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2FyZWEnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCBjb2xvcnMpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZCcsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNhZmVEKGFyZWEoZC52YWx1ZXMpKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgZGMudHJhbnNpdGlvbihsYXllcnMuc2VsZWN0KCdwYXRoLmFyZWEnKSwgX2NoYXJ0LnRyYW5zaXRpb25EdXJhdGlvbigpLCBfY2hhcnQudHJhbnNpdGlvbkRlbGF5KCkpXHJcbiAgICAgICAgICAgICAgICAvLy5lYXNlKCdsaW5lYXInKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCBjb2xvcnMpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZCcsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNhZmVEKGFyZWEoZC52YWx1ZXMpKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzYWZlRCAoZCkge1xyXG4gICAgICAgIHJldHVybiAoIWQgfHwgZC5pbmRleE9mKCdOYU4nKSA+PSAwKSA/ICdNMCwwJyA6IGQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd0RvdHMgKGNoYXJ0Qm9keSwgbGF5ZXJzKSB7XHJcbiAgICAgICAgaWYgKF9jaGFydC54eVRpcHNPbigpID09PSAnYWx3YXlzJyB8fCAoIShfY2hhcnQuYnJ1c2hPbigpIHx8IF9jaGFydC5wYXJlbnRCcnVzaE9uKCkpICYmIF9jaGFydC54eVRpcHNPbigpKSkge1xyXG4gICAgICAgICAgICB2YXIgdG9vbHRpcExpc3RDbGFzcyA9IFRPT0xUSVBfR19DTEFTUyArICctbGlzdCc7XHJcbiAgICAgICAgICAgIHZhciB0b29sdGlwcyA9IGNoYXJ0Qm9keS5zZWxlY3QoJ2cuJyArIHRvb2x0aXBMaXN0Q2xhc3MpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRvb2x0aXBzLmVtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIHRvb2x0aXBzID0gY2hhcnRCb2R5LmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgdG9vbHRpcExpc3RDbGFzcyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxheWVycy5lYWNoKGZ1bmN0aW9uIChkLCBsYXllckluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRzID0gZC52YWx1ZXM7XHJcbiAgICAgICAgICAgICAgICBpZiAoX2RlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb2ludHMgPSBwb2ludHMuZmlsdGVyKF9kZWZpbmVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZyA9IHRvb2x0aXBzLnNlbGVjdCgnZy4nICsgVE9PTFRJUF9HX0NMQVNTICsgJy5fJyArIGxheWVySW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGcuZW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGcgPSB0b29sdGlwcy5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsIFRPT0xUSVBfR19DTEFTUyArICcgXycgKyBsYXllckluZGV4KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBjcmVhdGVSZWZMaW5lcyhnKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZG90cyA9IGcuc2VsZWN0QWxsKCdjaXJjbGUuJyArIERPVF9DSVJDTEVfQ0xBU1MpXHJcbiAgICAgICAgICAgICAgICAgICAgLmRhdGEocG9pbnRzLCBkYy5wbHVjaygneCcpKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZG90c0VudGVyTW9kaWZ5ID0gZG90c1xyXG4gICAgICAgICAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2NpcmNsZScpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIERPVF9DSVJDTEVfQ0xBU1MpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjeCcsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGMudXRpbHMuc2FmZU51bWJlcihfY2hhcnQueCgpKGQueCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignY3knLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRjLnV0aWxzLnNhZmVOdW1iZXIoX2NoYXJ0LnkoKShkLnkgKyBkLnkwKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdyJywgZ2V0RG90UmFkaXVzKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbC1vcGFjaXR5JywgX2RhdGFQb2ludEZpbGxPcGFjaXR5KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZS1vcGFjaXR5JywgX2RhdGFQb2ludFN0cm9rZU9wYWNpdHkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgX2NoYXJ0LmdldENvbG9yKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgX2NoYXJ0LmdldENvbG9yKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb3QgPSBkMy5zZWxlY3QodGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG93RG90KGRvdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG93UmVmTGluZXMoZG90LCBnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb3QgPSBkMy5zZWxlY3QodGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWRlRG90KGRvdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWRlUmVmTGluZXMoZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLm1lcmdlKGRvdHMpO1xyXG5cclxuICAgICAgICAgICAgICAgIGRvdHNFbnRlck1vZGlmeS5jYWxsKHJlbmRlclRpdGxlLCBkKTtcclxuXHJcbiAgICAgICAgICAgICAgICBkYy50cmFuc2l0aW9uKGRvdHNFbnRlck1vZGlmeSwgX2NoYXJ0LnRyYW5zaXRpb25EdXJhdGlvbigpKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjeCcsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYy51dGlscy5zYWZlTnVtYmVyKF9jaGFydC54KCkoZC54KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY3knLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGMudXRpbHMuc2FmZU51bWJlcihfY2hhcnQueSgpKGQueSArIGQueTApKTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgX2NoYXJ0LmdldENvbG9yKTtcclxuXHJcbiAgICAgICAgICAgICAgICBkb3RzLmV4aXQoKS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIF9jaGFydC5sYWJlbChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIHJldHVybiBkYy51dGlscy5wcmludFNpbmdsZVZhbHVlKGQueTAgKyBkLnkpO1xyXG4gICAgfSwgZmFsc2UpO1xyXG5cclxuICAgIGZ1bmN0aW9uIGRyYXdMYWJlbHMgKGxheWVycykge1xyXG4gICAgICAgIGxheWVycy5lYWNoKGZ1bmN0aW9uIChkLCBsYXllckluZGV4KSB7XHJcbiAgICAgICAgICAgIHZhciBsYXllciA9IGQzLnNlbGVjdCh0aGlzKTtcclxuICAgICAgICAgICAgdmFyIGxhYmVscyA9IGxheWVyLnNlbGVjdEFsbCgndGV4dC5saW5lTGFiZWwnKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEoZC52YWx1ZXMsIGRjLnBsdWNrKCd4JykpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGxhYmVsc0VudGVyTW9kaWZ5ID0gbGFiZWxzXHJcbiAgICAgICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdsaW5lTGFiZWwnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKVxyXG4gICAgICAgICAgICAgICAgLm1lcmdlKGxhYmVscyk7XHJcblxyXG4gICAgICAgICAgICBkYy50cmFuc2l0aW9uKGxhYmVsc0VudGVyTW9kaWZ5LCBfY2hhcnQudHJhbnNpdGlvbkR1cmF0aW9uKCkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRjLnV0aWxzLnNhZmVOdW1iZXIoX2NoYXJ0LngoKShkLngpKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSBfY2hhcnQueSgpKGQueSArIGQueTApIC0gTEFCRUxfUEFERElORztcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGMudXRpbHMuc2FmZU51bWJlcih5KTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAudGV4dChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfY2hhcnQubGFiZWwoKShkKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgZGMudHJhbnNpdGlvbihsYWJlbHMuZXhpdCgpLCBfY2hhcnQudHJhbnNpdGlvbkR1cmF0aW9uKCkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgMClcclxuICAgICAgICAgICAgICAgIC5yZW1vdmUoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVSZWZMaW5lcyAoZykge1xyXG4gICAgICAgIHZhciB5UmVmTGluZSA9IGcuc2VsZWN0KCdwYXRoLicgKyBZX0FYSVNfUkVGX0xJTkVfQ0xBU1MpLmVtcHR5KCkgP1xyXG4gICAgICAgICAgICBnLmFwcGVuZCgncGF0aCcpLmF0dHIoJ2NsYXNzJywgWV9BWElTX1JFRl9MSU5FX0NMQVNTKSA6IGcuc2VsZWN0KCdwYXRoLicgKyBZX0FYSVNfUkVGX0xJTkVfQ0xBU1MpO1xyXG4gICAgICAgIHlSZWZMaW5lLnN0eWxlKCdkaXNwbGF5JywgJ25vbmUnKS5hdHRyKCdzdHJva2UtZGFzaGFycmF5JywgJzUsNScpO1xyXG5cclxuICAgICAgICB2YXIgeFJlZkxpbmUgPSBnLnNlbGVjdCgncGF0aC4nICsgWF9BWElTX1JFRl9MSU5FX0NMQVNTKS5lbXB0eSgpID9cclxuICAgICAgICAgICAgZy5hcHBlbmQoJ3BhdGgnKS5hdHRyKCdjbGFzcycsIFhfQVhJU19SRUZfTElORV9DTEFTUykgOiBnLnNlbGVjdCgncGF0aC4nICsgWF9BWElTX1JFRl9MSU5FX0NMQVNTKTtcclxuICAgICAgICB4UmVmTGluZS5zdHlsZSgnZGlzcGxheScsICdub25lJykuYXR0cignc3Ryb2tlLWRhc2hhcnJheScsICc1LDUnKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzaG93RG90IChkb3QpIHtcclxuICAgICAgICBkb3Quc3R5bGUoJ2ZpbGwtb3BhY2l0eScsIDAuOCk7XHJcbiAgICAgICAgZG90LnN0eWxlKCdzdHJva2Utb3BhY2l0eScsIDAuOCk7XHJcbiAgICAgICAgZG90LmF0dHIoJ3InLCBfZG90UmFkaXVzKTtcclxuICAgICAgICByZXR1cm4gZG90O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNob3dSZWZMaW5lcyAoZG90LCBnKSB7XHJcbiAgICAgICAgdmFyIHggPSBkb3QuYXR0cignY3gnKTtcclxuICAgICAgICB2YXIgeSA9IGRvdC5hdHRyKCdjeScpO1xyXG4gICAgICAgIHZhciB5QXhpc1ggPSAoX2NoYXJ0Ll95QXhpc1goKSAtIF9jaGFydC5tYXJnaW5zKCkubGVmdCk7XHJcbiAgICAgICAgdmFyIHlBeGlzUmVmUGF0aEQgPSAnTScgKyB5QXhpc1ggKyAnICcgKyB5ICsgJ0wnICsgKHgpICsgJyAnICsgKHkpO1xyXG4gICAgICAgIHZhciB4QXhpc1JlZlBhdGhEID0gJ00nICsgeCArICcgJyArIF9jaGFydC55QXhpc0hlaWdodCgpICsgJ0wnICsgeCArICcgJyArIHk7XHJcbiAgICAgICAgZy5zZWxlY3QoJ3BhdGguJyArIFlfQVhJU19SRUZfTElORV9DTEFTUykuc3R5bGUoJ2Rpc3BsYXknLCAnJykuYXR0cignZCcsIHlBeGlzUmVmUGF0aEQpO1xyXG4gICAgICAgIGcuc2VsZWN0KCdwYXRoLicgKyBYX0FYSVNfUkVGX0xJTkVfQ0xBU1MpLnN0eWxlKCdkaXNwbGF5JywgJycpLmF0dHIoJ2QnLCB4QXhpc1JlZlBhdGhEKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXREb3RSYWRpdXMgKCkge1xyXG4gICAgICAgIHJldHVybiBfZGF0YVBvaW50UmFkaXVzIHx8IF9kb3RSYWRpdXM7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaGlkZURvdCAoZG90KSB7XHJcbiAgICAgICAgZG90LnN0eWxlKCdmaWxsLW9wYWNpdHknLCBfZGF0YVBvaW50RmlsbE9wYWNpdHkpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLW9wYWNpdHknLCBfZGF0YVBvaW50U3Ryb2tlT3BhY2l0eSlcclxuICAgICAgICAgICAgLmF0dHIoJ3InLCBnZXREb3RSYWRpdXMoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaGlkZVJlZkxpbmVzIChnKSB7XHJcbiAgICAgICAgZy5zZWxlY3QoJ3BhdGguJyArIFlfQVhJU19SRUZfTElORV9DTEFTUykuc3R5bGUoJ2Rpc3BsYXknLCAnbm9uZScpO1xyXG4gICAgICAgIGcuc2VsZWN0KCdwYXRoLicgKyBYX0FYSVNfUkVGX0xJTkVfQ0xBU1MpLnN0eWxlKCdkaXNwbGF5JywgJ25vbmUnKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZW5kZXJUaXRsZSAoZG90LCBkKSB7XHJcbiAgICAgICAgaWYgKF9jaGFydC5yZW5kZXJUaXRsZSgpKSB7XHJcbiAgICAgICAgICAgIGRvdC5zZWxlY3QoJ3RpdGxlJykucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIGRvdC5hcHBlbmQoJ3RpdGxlJykudGV4dChkYy5wbHVjaygnZGF0YScsIF9jaGFydC50aXRsZShkLm5hbWUpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHVybiBvbi9vZmYgdGhlIG1vdXNlb3ZlciBiZWhhdmlvciBvZiBhbiBpbmRpdmlkdWFsIGRhdGEgcG9pbnQgd2hpY2ggcmVuZGVycyBhIGNpcmNsZSBhbmQgeC95IGF4aXNcclxuICAgICAqIGRhc2hlZCBsaW5lcyBiYWNrIHRvIGVhY2ggcmVzcGVjdGl2ZSBheGlzLiAgVGhpcyBpcyBpZ25vcmVkIGlmIHRoZSBjaGFydFxyXG4gICAgICoge0BsaW5rIGRjLmNvb3JkaW5hdGVHcmlkTWl4aW4jYnJ1c2hPbiBicnVzaH0gaXMgb25cclxuICAgICAqIEBtZXRob2QgeHlUaXBzT25cclxuICAgICAqIEBtZW1iZXJvZiBkYy5saW5lQ2hhcnRcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gW3h5VGlwc09uPWZhbHNlXVxyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW58ZGMubGluZUNoYXJ0fVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQueHlUaXBzT24gPSBmdW5jdGlvbiAoeHlUaXBzT24pIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF94eVRpcHNPbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3h5VGlwc09uID0geHlUaXBzT247XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgb3Igc2V0IHRoZSByYWRpdXMgKGluIHB4KSBmb3IgZG90cyBkaXNwbGF5ZWQgb24gdGhlIGRhdGEgcG9pbnRzLlxyXG4gICAgICogQG1ldGhvZCBkb3RSYWRpdXNcclxuICAgICAqIEBtZW1iZXJvZiBkYy5saW5lQ2hhcnRcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBbZG90UmFkaXVzPTVdXHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfGRjLmxpbmVDaGFydH1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LmRvdFJhZGl1cyA9IGZ1bmN0aW9uIChkb3RSYWRpdXMpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9kb3RSYWRpdXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9kb3RSYWRpdXMgPSBkb3RSYWRpdXM7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbHdheXMgc2hvdyBpbmRpdmlkdWFsIGRvdHMgZm9yIGVhY2ggZGF0YXBvaW50LlxyXG4gICAgICpcclxuICAgICAqIElmIGBvcHRpb25zYCBpcyBmYWxzeSwgaXQgZGlzYWJsZXMgZGF0YSBwb2ludCByZW5kZXJpbmcuIElmIG5vIGBvcHRpb25zYCBhcmUgcHJvdmlkZWQsIHRoZVxyXG4gICAgICogY3VycmVudCBgb3B0aW9uc2AgdmFsdWVzIGFyZSBpbnN0ZWFkIHJldHVybmVkLlxyXG4gICAgICogQG1ldGhvZCByZW5kZXJEYXRhUG9pbnRzXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMubGluZUNoYXJ0XHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBjaGFydC5yZW5kZXJEYXRhUG9pbnRzKHtyYWRpdXM6IDIsIGZpbGxPcGFjaXR5OiAwLjgsIHN0cm9rZU9wYWNpdHk6IDAuMH0pXHJcbiAgICAgKiBAcGFyYW0gIHt7ZmlsbE9wYWNpdHk6IE51bWJlciwgc3Ryb2tlT3BhY2l0eTogTnVtYmVyLCByYWRpdXM6IE51bWJlcn19IFtvcHRpb25zPXtmaWxsT3BhY2l0eTogMC44LCBzdHJva2VPcGFjaXR5OiAwLjAsIHJhZGl1czogMn1dXHJcbiAgICAgKiBAcmV0dXJucyB7e2ZpbGxPcGFjaXR5OiBOdW1iZXIsIHN0cm9rZU9wYWNpdHk6IE51bWJlciwgcmFkaXVzOiBOdW1iZXJ9fGRjLmxpbmVDaGFydH1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LnJlbmRlckRhdGFQb2ludHMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgZmlsbE9wYWNpdHk6IF9kYXRhUG9pbnRGaWxsT3BhY2l0eSxcclxuICAgICAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IF9kYXRhUG9pbnRTdHJva2VPcGFjaXR5LFxyXG4gICAgICAgICAgICAgICAgcmFkaXVzOiBfZGF0YVBvaW50UmFkaXVzXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSBlbHNlIGlmICghb3B0aW9ucykge1xyXG4gICAgICAgICAgICBfZGF0YVBvaW50RmlsbE9wYWNpdHkgPSBERUZBVUxUX0RPVF9PUEFDSVRZO1xyXG4gICAgICAgICAgICBfZGF0YVBvaW50U3Ryb2tlT3BhY2l0eSA9IERFRkFVTFRfRE9UX09QQUNJVFk7XHJcbiAgICAgICAgICAgIF9kYXRhUG9pbnRSYWRpdXMgPSBudWxsO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIF9kYXRhUG9pbnRGaWxsT3BhY2l0eSA9IG9wdGlvbnMuZmlsbE9wYWNpdHkgfHwgMC44O1xyXG4gICAgICAgICAgICBfZGF0YVBvaW50U3Ryb2tlT3BhY2l0eSA9IG9wdGlvbnMuc3Ryb2tlT3BhY2l0eSB8fCAwLjA7XHJcbiAgICAgICAgICAgIF9kYXRhUG9pbnRSYWRpdXMgPSBvcHRpb25zLnJhZGl1cyB8fCAyO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBjb2xvckZpbHRlciAoY29sb3IsIGRhc2hzdHlsZSwgaW52KSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGl0ZW0gPSBkMy5zZWxlY3QodGhpcyk7XHJcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IChpdGVtLmF0dHIoJ3N0cm9rZScpID09PSBjb2xvciAmJlxyXG4gICAgICAgICAgICAgICAgaXRlbS5hdHRyKCdzdHJva2UtZGFzaGFycmF5JykgPT09ICgoZGFzaHN0eWxlIGluc3RhbmNlb2YgQXJyYXkpID9cclxuICAgICAgICAgICAgICAgICAgICBkYXNoc3R5bGUuam9pbignLCcpIDogbnVsbCkpIHx8IGl0ZW0uYXR0cignZmlsbCcpID09PSBjb2xvcjtcclxuICAgICAgICAgICAgcmV0dXJuIGludiA/ICFtYXRjaCA6IG1hdGNoO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgX2NoYXJ0LmxlZ2VuZEhpZ2hsaWdodCA9IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgaWYgKCFfY2hhcnQuaXNMZWdlbmRhYmxlSGlkZGVuKGQpKSB7XHJcbiAgICAgICAgICAgIF9jaGFydC5nKCkuc2VsZWN0QWxsKCdwYXRoLmxpbmUsIHBhdGguYXJlYScpXHJcbiAgICAgICAgICAgICAgICAuY2xhc3NlZCgnaGlnaGxpZ2h0JywgY29sb3JGaWx0ZXIoZC5jb2xvciwgZC5kYXNoc3R5bGUpKVxyXG4gICAgICAgICAgICAgICAgLmNsYXNzZWQoJ2ZhZGVvdXQnLCBjb2xvckZpbHRlcihkLmNvbG9yLCBkLmRhc2hzdHlsZSwgdHJ1ZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgX2NoYXJ0LmxlZ2VuZFJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9jaGFydC5nKCkuc2VsZWN0QWxsKCdwYXRoLmxpbmUsIHBhdGguYXJlYScpXHJcbiAgICAgICAgICAgIC5jbGFzc2VkKCdoaWdobGlnaHQnLCBmYWxzZSlcclxuICAgICAgICAgICAgLmNsYXNzZWQoJ2ZhZGVvdXQnLCBmYWxzZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGRjLm92ZXJyaWRlKF9jaGFydCwgJ2xlZ2VuZGFibGVzJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBsZWdlbmRhYmxlcyA9IF9jaGFydC5fbGVnZW5kYWJsZXMoKTtcclxuICAgICAgICBpZiAoIV9kYXNoU3R5bGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxlZ2VuZGFibGVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbGVnZW5kYWJsZXMubWFwKGZ1bmN0aW9uIChsKSB7XHJcbiAgICAgICAgICAgIGwuZGFzaHN0eWxlID0gX2Rhc2hTdHlsZTtcclxuICAgICAgICAgICAgcmV0dXJuIGw7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gX2NoYXJ0LmFuY2hvcihwYXJlbnQsIGNoYXJ0R3JvdXApO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRoZSBkYXRhIGNvdW50IHdpZGdldCBpcyBhIHNpbXBsZSB3aWRnZXQgZGVzaWduZWQgdG8gZGlzcGxheSB0aGUgbnVtYmVyIG9mIHJlY29yZHMgc2VsZWN0ZWQgYnkgdGhlXHJcbiAqIGN1cnJlbnQgZmlsdGVycyBvdXQgb2YgdGhlIHRvdGFsIG51bWJlciBvZiByZWNvcmRzIGluIHRoZSBkYXRhIHNldC4gT25jZSBjcmVhdGVkIHRoZSBkYXRhIGNvdW50IHdpZGdldFxyXG4gKiB3aWxsIGF1dG9tYXRpY2FsbHkgdXBkYXRlIHRoZSB0ZXh0IGNvbnRlbnQgb2YgY2hpbGQgZWxlbWVudHMgd2l0aCB0aGUgZm9sbG93aW5nIGNsYXNzZXM6XHJcbiAqXHJcbiAqICogYC50b3RhbC1jb3VudGAgLSB0b3RhbCBudW1iZXIgb2YgcmVjb3Jkc1xyXG4gKiAqIGAuZmlsdGVyLWNvdW50YCAtIG51bWJlciBvZiByZWNvcmRzIG1hdGNoZWQgYnkgdGhlIGN1cnJlbnQgZmlsdGVyc1xyXG4gKlxyXG4gKiBOb3RlOiB0aGlzIHdpZGdldCB3b3JrcyBiZXN0IGZvciB0aGUgc3BlY2lmaWMgY2FzZSBvZiBzaG93aW5nIHRoZSBudW1iZXIgb2YgcmVjb3JkcyBvdXQgb2YgYVxyXG4gKiB0b3RhbC4gSWYgeW91IHdhbnQgYSBtb3JlIGdlbmVyYWwtcHVycG9zZSBudW1lcmljIGRpc3BsYXksIHBsZWFzZSB1c2UgdGhlXHJcbiAqIHtAbGluayBkYy5udW1iZXJEaXNwbGF5fSB3aWRnZXQgaW5zdGVhZC5cclxuICpcclxuICogRXhhbXBsZXM6XHJcbiAqIC0ge0BsaW5rIGh0dHA6Ly9kYy1qcy5naXRodWIuY29tL2RjLmpzLyBOYXNkYXEgMTAwIEluZGV4fVxyXG4gKiBAY2xhc3MgZGF0YUNvdW50XHJcbiAqIEBtZW1iZXJvZiBkY1xyXG4gKiBAbWl4ZXMgZGMuYmFzZU1peGluXHJcbiAqIEBleGFtcGxlXHJcbiAqIHZhciBuZHggPSBjcm9zc2ZpbHRlcihkYXRhKTtcclxuICogdmFyIGFsbCA9IG5keC5ncm91cEFsbCgpO1xyXG4gKlxyXG4gKiBkYy5kYXRhQ291bnQoJy5kYy1kYXRhLWNvdW50JylcclxuICogICAgIC5kaW1lbnNpb24obmR4KVxyXG4gKiAgICAgLmdyb3VwKGFsbCk7XHJcbiAqIEBwYXJhbSB7U3RyaW5nfG5vZGV8ZDMuc2VsZWN0aW9ufSBwYXJlbnQgLSBBbnkgdmFsaWRcclxuICoge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1zZWxlY3Rpb24vYmxvYi9tYXN0ZXIvUkVBRE1FLm1kI3NlbGVjdCBkMyBzaW5nbGUgc2VsZWN0b3J9IHNwZWNpZnlpbmdcclxuICogYSBkb20gYmxvY2sgZWxlbWVudCBzdWNoIGFzIGEgZGl2OyBvciBhIGRvbSBlbGVtZW50IG9yIGQzIHNlbGVjdGlvbi5cclxuICogQHBhcmFtIHtTdHJpbmd9IFtjaGFydEdyb3VwXSAtIFRoZSBuYW1lIG9mIHRoZSBjaGFydCBncm91cCB0aGlzIGNoYXJ0IGluc3RhbmNlIHNob3VsZCBiZSBwbGFjZWQgaW4uXHJcbiAqIEludGVyYWN0aW9uIHdpdGggYSBjaGFydCB3aWxsIG9ubHkgdHJpZ2dlciBldmVudHMgYW5kIHJlZHJhd3Mgd2l0aGluIHRoZSBjaGFydCdzIGdyb3VwLlxyXG4gKiBAcmV0dXJucyB7ZGMuZGF0YUNvdW50fVxyXG4gKi9cclxuZGMuZGF0YUNvdW50ID0gZnVuY3Rpb24gKHBhcmVudCwgY2hhcnRHcm91cCkge1xyXG4gICAgdmFyIF9mb3JtYXROdW1iZXIgPSBkMy5mb3JtYXQoJyxkJyk7XHJcbiAgICB2YXIgX2NoYXJ0ID0gZGMuYmFzZU1peGluKHt9KTtcclxuICAgIHZhciBfaHRtbCA9IHtzb21lOiAnJywgYWxsOiAnJ307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgYW4gb3B0aW9uYWwgb2JqZWN0IHNwZWNpZnlpbmcgSFRNTCB0ZW1wbGF0ZXMgdG8gdXNlIGRlcGVuZGluZyBob3cgbWFueSBpdGVtcyBhcmVcclxuICAgICAqIHNlbGVjdGVkLiBUaGUgdGV4dCBgJXRvdGFsLWNvdW50YCB3aWxsIHJlcGxhY2VkIHdpdGggdGhlIHRvdGFsIG51bWJlciBvZiByZWNvcmRzLCBhbmQgdGhlIHRleHRcclxuICAgICAqIGAlZmlsdGVyLWNvdW50YCB3aWxsIGJlIHJlcGxhY2VkIHdpdGggdGhlIG51bWJlciBvZiBzZWxlY3RlZCByZWNvcmRzLlxyXG4gICAgICogLSBhbGw6IEhUTUwgdGVtcGxhdGUgdG8gdXNlIGlmIGFsbCBpdGVtcyBhcmUgc2VsZWN0ZWRcclxuICAgICAqIC0gc29tZTogSFRNTCB0ZW1wbGF0ZSB0byB1c2UgaWYgbm90IGFsbCBpdGVtcyBhcmUgc2VsZWN0ZWRcclxuICAgICAqIEBtZXRob2QgaHRtbFxyXG4gICAgICogQG1lbWJlcm9mIGRjLmRhdGFDb3VudFxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogY291bnRlci5odG1sKHtcclxuICAgICAqICAgICAgc29tZTogJyVmaWx0ZXItY291bnQgb3V0IG9mICV0b3RhbC1jb3VudCByZWNvcmRzIHNlbGVjdGVkJyxcclxuICAgICAqICAgICAgYWxsOiAnQWxsIHJlY29yZHMgc2VsZWN0ZWQuIENsaWNrIG9uIGNoYXJ0cyB0byBhcHBseSBmaWx0ZXJzJ1xyXG4gICAgICogfSlcclxuICAgICAqIEBwYXJhbSB7e3NvbWU6U3RyaW5nLCBhbGw6IFN0cmluZ319IFtvcHRpb25zXVxyXG4gICAgICogQHJldHVybnMge3tzb21lOlN0cmluZywgYWxsOiBTdHJpbmd9fGRjLmRhdGFDb3VudH1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0Lmh0bWwgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2h0bWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRpb25zLmFsbCkge1xyXG4gICAgICAgICAgICBfaHRtbC5hbGwgPSBvcHRpb25zLmFsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuc29tZSkge1xyXG4gICAgICAgICAgICBfaHRtbC5zb21lID0gb3B0aW9ucy5zb21lO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyBhbiBvcHRpb25hbCBmdW5jdGlvbiB0byBmb3JtYXQgdGhlIGZpbHRlciBjb3VudCBhbmQgdG90YWwgY291bnQuXHJcbiAgICAgKiBAbWV0aG9kIGZvcm1hdE51bWJlclxyXG4gICAgICogQG1lbWJlcm9mIGRjLmRhdGFDb3VudFxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtZm9ybWF0L2Jsb2IvbWFzdGVyL1JFQURNRS5tZCNmb3JtYXQgZDMuZm9ybWF0fVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGNvdW50ZXIuZm9ybWF0TnVtYmVyKGQzLmZvcm1hdCgnLjJnJykpXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm9ybWF0dGVyPWQzLmZvcm1hdCgnLjJnJyldXHJcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb258ZGMuZGF0YUNvdW50fVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQuZm9ybWF0TnVtYmVyID0gZnVuY3Rpb24gKGZvcm1hdHRlcikge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2Zvcm1hdE51bWJlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgX2Zvcm1hdE51bWJlciA9IGZvcm1hdHRlcjtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICBfY2hhcnQuX2RvUmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB0b3QgPSBfY2hhcnQuZGltZW5zaW9uKCkuc2l6ZSgpLFxyXG4gICAgICAgICAgICB2YWwgPSBfY2hhcnQuZ3JvdXAoKS52YWx1ZSgpO1xyXG4gICAgICAgIHZhciBhbGwgPSBfZm9ybWF0TnVtYmVyKHRvdCk7XHJcbiAgICAgICAgdmFyIHNlbGVjdGVkID0gX2Zvcm1hdE51bWJlcih2YWwpO1xyXG5cclxuICAgICAgICBpZiAoKHRvdCA9PT0gdmFsKSAmJiAoX2h0bWwuYWxsICE9PSAnJykpIHtcclxuICAgICAgICAgICAgX2NoYXJ0LnJvb3QoKS5odG1sKF9odG1sLmFsbC5yZXBsYWNlKCcldG90YWwtY291bnQnLCBhbGwpLnJlcGxhY2UoJyVmaWx0ZXItY291bnQnLCBzZWxlY3RlZCkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoX2h0bWwuc29tZSAhPT0gJycpIHtcclxuICAgICAgICAgICAgX2NoYXJ0LnJvb3QoKS5odG1sKF9odG1sLnNvbWUucmVwbGFjZSgnJXRvdGFsLWNvdW50JywgYWxsKS5yZXBsYWNlKCclZmlsdGVyLWNvdW50Jywgc2VsZWN0ZWQpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBfY2hhcnQuc2VsZWN0QWxsKCcudG90YWwtY291bnQnKS50ZXh0KGFsbCk7XHJcbiAgICAgICAgICAgIF9jaGFydC5zZWxlY3RBbGwoJy5maWx0ZXItY291bnQnKS50ZXh0KHNlbGVjdGVkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgX2NoYXJ0Ll9kb1JlZHJhdyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0Ll9kb1JlbmRlcigpO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gX2NoYXJ0LmFuY2hvcihwYXJlbnQsIGNoYXJ0R3JvdXApO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRoZSBkYXRhIHRhYmxlIGlzIGEgc2ltcGxlIHdpZGdldCBkZXNpZ25lZCB0byBsaXN0IGNyb3NzZmlsdGVyIGZvY3VzZWQgZGF0YSBzZXQgKHJvd3MgYmVpbmdcclxuICogZmlsdGVyZWQpIGluIGEgZ29vZCBvbGQgdGFidWxhciBmYXNoaW9uLlxyXG4gKlxyXG4gKiBOb3RlOiBVbmxpa2Ugb3RoZXIgY2hhcnRzLCB0aGUgZGF0YSB0YWJsZSAoYW5kIGRhdGEgZ3JpZCBjaGFydCkgdXNlIHRoZSB7QGxpbmsgZGMuZGF0YVRhYmxlI2dyb3VwIGdyb3VwfSBhdHRyaWJ1dGUgYXMgYVxyXG4gKiBrZXlpbmcgZnVuY3Rpb24gZm9yIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtY29sbGVjdGlvbi9ibG9iL21hc3Rlci9SRUFETUUubWQjbmVzdCBuZXN0aW5nfSB0aGUgZGF0YVxyXG4gKiB0b2dldGhlciBpbiBncm91cHMuICBEbyBub3QgcGFzcyBpbiBhIGNyb3NzZmlsdGVyIGdyb3VwIGFzIHRoaXMgd2lsbCBub3Qgd29yay5cclxuICpcclxuICogQW5vdGhlciBpbnRlcmVzdGluZyBmZWF0dXJlIG9mIHRoZSBkYXRhIHRhYmxlIGlzIHRoYXQgeW91IGNhbiBwYXNzIGEgY3Jvc3NmaWx0ZXIgZ3JvdXAgdG8gdGhlIGBkaW1lbnNpb25gLCBhc1xyXG4gKiBsb25nIGFzIHlvdSBzcGVjaWZ5IHRoZSB7QGxpbmsgZGMuZGF0YVRhYmxlI29yZGVyIG9yZGVyfSBhcyBgZDMuZGVzY2VuZGluZ2AsIHNpbmNlIHRoZSBkYXRhXHJcbiAqIHRhYmxlIHdpbGwgdXNlIGBkaW1lbnNpb24udG9wKClgIHRvIGZldGNoIHRoZSBkYXRhIGluIHRoYXQgY2FzZSwgYW5kIHRoZSBtZXRob2QgaXMgZXF1YWxseVxyXG4gKiBzdXBwb3J0ZWQgb24gdGhlIGNyb3NzZmlsdGVyIGdyb3VwIGFzIHRoZSBjcm9zc2ZpbHRlciBkaW1lbnNpb24uXHJcbiAqXHJcbiAqIEV4YW1wbGVzOlxyXG4gKiAtIHtAbGluayBodHRwOi8vZGMtanMuZ2l0aHViLmNvbS9kYy5qcy8gTmFzZGFxIDEwMCBJbmRleH1cclxuICogLSB7QGxpbmsgaHR0cDovL2RjLWpzLmdpdGh1Yi5pby9kYy5qcy9leGFtcGxlcy90YWJsZS1vbi1hZ2dyZWdhdGVkLWRhdGEuaHRtbCBkYXRhVGFibGUgb24gYSBjcm9zc2ZpbHRlciBncm91cH1cclxuICogKHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZGMtanMvZGMuanMvYmxvYi9kZXZlbG9wL3dlYi9leGFtcGxlcy90YWJsZS1vbi1hZ2dyZWdhdGVkLWRhdGEuaHRtbCBzb3VyY2V9KVxyXG4gKiBAY2xhc3MgZGF0YVRhYmxlXHJcbiAqIEBtZW1iZXJvZiBkY1xyXG4gKiBAbWl4ZXMgZGMuYmFzZU1peGluXHJcbiAqIEBwYXJhbSB7U3RyaW5nfG5vZGV8ZDMuc2VsZWN0aW9ufSBwYXJlbnQgLSBBbnkgdmFsaWRcclxuICoge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1zZWxlY3Rpb24vYmxvYi9tYXN0ZXIvUkVBRE1FLm1kI3NlbGVjdCBkMyBzaW5nbGUgc2VsZWN0b3J9IHNwZWNpZnlpbmdcclxuICogYSBkb20gYmxvY2sgZWxlbWVudCBzdWNoIGFzIGEgZGl2OyBvciBhIGRvbSBlbGVtZW50IG9yIGQzIHNlbGVjdGlvbi5cclxuICogQHBhcmFtIHtTdHJpbmd9IFtjaGFydEdyb3VwXSAtIFRoZSBuYW1lIG9mIHRoZSBjaGFydCBncm91cCB0aGlzIGNoYXJ0IGluc3RhbmNlIHNob3VsZCBiZSBwbGFjZWQgaW4uXHJcbiAqIEludGVyYWN0aW9uIHdpdGggYSBjaGFydCB3aWxsIG9ubHkgdHJpZ2dlciBldmVudHMgYW5kIHJlZHJhd3Mgd2l0aGluIHRoZSBjaGFydCdzIGdyb3VwLlxyXG4gKiBAcmV0dXJucyB7ZGMuZGF0YVRhYmxlfVxyXG4gKi9cclxuZGMuZGF0YVRhYmxlID0gZnVuY3Rpb24gKHBhcmVudCwgY2hhcnRHcm91cCkge1xyXG4gICAgdmFyIExBQkVMX0NTU19DTEFTUyA9ICdkYy10YWJsZS1sYWJlbCc7XHJcbiAgICB2YXIgUk9XX0NTU19DTEFTUyA9ICdkYy10YWJsZS1yb3cnO1xyXG4gICAgdmFyIENPTFVNTl9DU1NfQ0xBU1MgPSAnZGMtdGFibGUtY29sdW1uJztcclxuICAgIHZhciBHUk9VUF9DU1NfQ0xBU1MgPSAnZGMtdGFibGUtZ3JvdXAnO1xyXG4gICAgdmFyIEhFQURfQ1NTX0NMQVNTID0gJ2RjLXRhYmxlLWhlYWQnO1xyXG5cclxuICAgIHZhciBfY2hhcnQgPSBkYy5iYXNlTWl4aW4oe30pO1xyXG5cclxuICAgIHZhciBfc2l6ZSA9IDI1O1xyXG4gICAgdmFyIF9jb2x1bW5zID0gW107XHJcbiAgICB2YXIgX3NvcnRCeSA9IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgcmV0dXJuIGQ7XHJcbiAgICB9O1xyXG4gICAgdmFyIF9vcmRlciA9IGQzLmFzY2VuZGluZztcclxuICAgIHZhciBfYmVnaW5TbGljZSA9IDA7XHJcbiAgICB2YXIgX2VuZFNsaWNlO1xyXG4gICAgdmFyIF9zaG93R3JvdXBzID0gdHJ1ZTtcclxuXHJcbiAgICBfY2hhcnQuX2RvUmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9jaGFydC5zZWxlY3RBbGwoJ3Rib2R5JykucmVtb3ZlKCk7XHJcblxyXG4gICAgICAgIHJlbmRlclJvd3MocmVuZGVyR3JvdXBzKCkpO1xyXG5cclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICBfY2hhcnQuX2RvQ29sdW1uVmFsdWVGb3JtYXQgPSBmdW5jdGlvbiAodiwgZCkge1xyXG4gICAgICAgIHJldHVybiAoKHR5cGVvZiB2ID09PSAnZnVuY3Rpb24nKSA/XHJcbiAgICAgICAgICAgICAgICB2KGQpIDogICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHYgYXMgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICgodHlwZW9mIHYgPT09ICdzdHJpbmcnKSA/XHJcbiAgICAgICAgICAgICAgICAgZFt2XSA6ICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHYgaXMgZmllbGQgbmFtZSBzdHJpbmdcclxuICAgICAgICAgICAgICAgICB2LmZvcm1hdChkKSAgICAgICAgICAgICAgICAgICAgICAgIC8vIHYgaXMgT2JqZWN0LCB1c2UgZm4gKGVsZW1lbnQgMilcclxuICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgKTtcclxuICAgIH07XHJcblxyXG4gICAgX2NoYXJ0Ll9kb0NvbHVtbkhlYWRlckZvcm1hdCA9IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgLy8gaWYgJ2Z1bmN0aW9uJywgY29udmVydCB0byBzdHJpbmcgcmVwcmVzZW50YXRpb25cclxuICAgICAgICAvLyBzaG93IGEgc3RyaW5nIGNhcGl0YWxpemVkXHJcbiAgICAgICAgLy8gaWYgYW4gb2JqZWN0IHRoZW4gZGlzcGxheSBpdHMgbGFiZWwgc3RyaW5nIGFzLWlzLlxyXG4gICAgICAgIHJldHVybiAodHlwZW9mIGQgPT09ICdmdW5jdGlvbicpID9cclxuICAgICAgICAgICAgICAgIF9jaGFydC5fZG9Db2x1bW5IZWFkZXJGblRvU3RyaW5nKGQpIDpcclxuICAgICAgICAgICAgICAgICgodHlwZW9mIGQgPT09ICdzdHJpbmcnKSA/XHJcbiAgICAgICAgICAgICAgICAgX2NoYXJ0Ll9kb0NvbHVtbkhlYWRlckNhcGl0YWxpemUoZCkgOiBTdHJpbmcoZC5sYWJlbCkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfY2hhcnQuX2RvQ29sdW1uSGVhZGVyQ2FwaXRhbGl6ZSA9IGZ1bmN0aW9uIChzKSB7XHJcbiAgICAgICAgLy8gY2FwaXRhbGl6ZVxyXG4gICAgICAgIHJldHVybiBzLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcy5zbGljZSgxKTtcclxuICAgIH07XHJcblxyXG4gICAgX2NoYXJ0Ll9kb0NvbHVtbkhlYWRlckZuVG9TdHJpbmcgPSBmdW5jdGlvbiAoZikge1xyXG4gICAgICAgIC8vIGNvbHVtblN0cmluZyhmKSB7XHJcbiAgICAgICAgdmFyIHMgPSBTdHJpbmcoZik7XHJcbiAgICAgICAgdmFyIGkxID0gcy5pbmRleE9mKCdyZXR1cm4gJyk7XHJcbiAgICAgICAgaWYgKGkxID49IDApIHtcclxuICAgICAgICAgICAgdmFyIGkyID0gcy5sYXN0SW5kZXhPZignOycpO1xyXG4gICAgICAgICAgICBpZiAoaTIgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgcyA9IHMuc3Vic3RyaW5nKGkxICsgNywgaTIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGkzID0gcy5pbmRleE9mKCdudW1iZXJGb3JtYXQnKTtcclxuICAgICAgICAgICAgICAgIGlmIChpMyA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZSgnbnVtYmVyRm9ybWF0JywgJycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiByZW5kZXJHcm91cHMgKCkge1xyXG4gICAgICAgIC8vIFRoZSAnb3JpZ2luYWwnIGV4YW1wbGUgdXNlcyBhbGwgJ2Z1bmN0aW9ucycuXHJcbiAgICAgICAgLy8gSWYgYWxsICdmdW5jdGlvbnMnIGFyZSB1c2VkLCB0aGVuIGRvbid0IHJlbW92ZS9hZGQgYSBoZWFkZXIsIGFuZCBsZWF2ZVxyXG4gICAgICAgIC8vIHRoZSBodG1sIGFsb25lLiBUaGlzIHByZXNlcnZlcyB0aGUgZnVuY3Rpb25hbGl0eSBvZiBlYXJsaWVyIHJlbGVhc2VzLlxyXG4gICAgICAgIC8vIEEgMm5kIG9wdGlvbiBpcyBhIHN0cmluZyByZXByZXNlbnRpbmcgYSBmaWVsZCBpbiB0aGUgZGF0YS5cclxuICAgICAgICAvLyBBIHRoaXJkIG9wdGlvbiBpcyB0byBzdXBwbHkgYW4gT2JqZWN0IHN1Y2ggYXMgYW4gYXJyYXkgb2YgJ2luZm9ybWF0aW9uJywgYW5kXHJcbiAgICAgICAgLy8gc3VwcGx5IHlvdXIgb3duIF9kb0NvbHVtbkhlYWRlckZvcm1hdCBhbmQgX2RvQ29sdW1uVmFsdWVGb3JtYXQgZnVuY3Rpb25zIHRvXHJcbiAgICAgICAgLy8gY3JlYXRlIHdoYXQgeW91IG5lZWQuXHJcbiAgICAgICAgdmFyIGJBbGxGdW5jdGlvbnMgPSB0cnVlO1xyXG4gICAgICAgIF9jb2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcclxuICAgICAgICAgICAgYkFsbEZ1bmN0aW9ucyA9IGJBbGxGdW5jdGlvbnMgJiAodHlwZW9mIGYgPT09ICdmdW5jdGlvbicpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAoIWJBbGxGdW5jdGlvbnMpIHtcclxuICAgICAgICAgICAgLy8gZW5zdXJlIG9uZSB0aGVhZFxyXG4gICAgICAgICAgICB2YXIgdGhlYWQgPSBfY2hhcnQuc2VsZWN0QWxsKCd0aGVhZCcpLmRhdGEoWzBdKTtcclxuICAgICAgICAgICAgdGhlYWQuZXhpdCgpLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICB0aGVhZCA9IHRoZWFkLmVudGVyKClcclxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCd0aGVhZCcpXHJcbiAgICAgICAgICAgICAgICAubWVyZ2UodGhlYWQpO1xyXG5cclxuICAgICAgICAgICAgLy8gd2l0aCBvbmUgdHJcclxuICAgICAgICAgICAgdmFyIGhlYWRyb3cgPSB0aGVhZC5zZWxlY3RBbGwoJ3RyJykuZGF0YShbMF0pO1xyXG4gICAgICAgICAgICBoZWFkcm93LmV4aXQoKS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgaGVhZHJvdyA9IGhlYWRyb3cuZW50ZXIoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RyJylcclxuICAgICAgICAgICAgICAgIC5tZXJnZShoZWFkcm93KTtcclxuXHJcbiAgICAgICAgICAgIC8vIHdpdGggYSB0aCBmb3IgZWFjaCBjb2x1bW5cclxuICAgICAgICAgICAgdmFyIGhlYWRjb2xzID0gaGVhZHJvdy5zZWxlY3RBbGwoJ3RoJylcclxuICAgICAgICAgICAgICAgIC5kYXRhKF9jb2x1bW5zKTtcclxuICAgICAgICAgICAgaGVhZGNvbHMuZXhpdCgpLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICBoZWFkY29scy5lbnRlcigpLmFwcGVuZCgndGgnKVxyXG4gICAgICAgICAgICAgICAgLm1lcmdlKGhlYWRjb2xzKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIEhFQURfQ1NTX0NMQVNTKVxyXG4gICAgICAgICAgICAgICAgICAgIC5odG1sKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoX2NoYXJ0Ll9kb0NvbHVtbkhlYWRlckZvcm1hdChkKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZ3JvdXBzID0gX2NoYXJ0LnJvb3QoKS5zZWxlY3RBbGwoJ3Rib2R5JylcclxuICAgICAgICAgICAgLmRhdGEobmVzdEVudHJpZXMoKSwgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfY2hhcnQua2V5QWNjZXNzb3IoKShkKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHZhciByb3dHcm91cCA9IGdyb3Vwc1xyXG4gICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCd0Ym9keScpO1xyXG5cclxuICAgICAgICBpZiAoX3Nob3dHcm91cHMgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgcm93R3JvdXBcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RyJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIEdST1VQX0NTU19DTEFTUylcclxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgTEFCRUxfQ1NTX0NMQVNTKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjb2xzcGFuJywgX2NvbHVtbnMubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5odG1sKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY2hhcnQua2V5QWNjZXNzb3IoKShkKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGdyb3Vwcy5leGl0KCkucmVtb3ZlKCk7XHJcblxyXG4gICAgICAgIHJldHVybiByb3dHcm91cDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBuZXN0RW50cmllcyAoKSB7XHJcbiAgICAgICAgdmFyIGVudHJpZXM7XHJcbiAgICAgICAgaWYgKF9vcmRlciA9PT0gZDMuYXNjZW5kaW5nKSB7XHJcbiAgICAgICAgICAgIGVudHJpZXMgPSBfY2hhcnQuZGltZW5zaW9uKCkuYm90dG9tKF9zaXplKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBlbnRyaWVzID0gX2NoYXJ0LmRpbWVuc2lvbigpLnRvcChfc2l6ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZDMubmVzdCgpXHJcbiAgICAgICAgICAgIC5rZXkoX2NoYXJ0Lmdyb3VwKCkpXHJcbiAgICAgICAgICAgIC5zb3J0S2V5cyhfb3JkZXIpXHJcbiAgICAgICAgICAgIC5lbnRyaWVzKGVudHJpZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9vcmRlcihfc29ydEJ5KGEpLCBfc29ydEJ5KGIpKTtcclxuICAgICAgICAgICAgfSkuc2xpY2UoX2JlZ2luU2xpY2UsIF9lbmRTbGljZSkpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlbmRlclJvd3MgKGdyb3Vwcykge1xyXG4gICAgICAgIHZhciByb3dzID0gZ3JvdXBzLm9yZGVyKClcclxuICAgICAgICAgICAgLnNlbGVjdEFsbCgndHIuJyArIFJPV19DU1NfQ0xBU1MpXHJcbiAgICAgICAgICAgIC5kYXRhKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZC52YWx1ZXM7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICB2YXIgcm93RW50ZXIgPSByb3dzLmVudGVyKClcclxuICAgICAgICAgICAgLmFwcGVuZCgndHInKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCBST1dfQ1NTX0NMQVNTKTtcclxuXHJcbiAgICAgICAgX2NvbHVtbnMuZm9yRWFjaChmdW5jdGlvbiAodiwgaSkge1xyXG4gICAgICAgICAgICByb3dFbnRlci5hcHBlbmQoJ3RkJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIENPTFVNTl9DU1NfQ0xBU1MgKyAnIF8nICsgaSlcclxuICAgICAgICAgICAgICAgIC5odG1sKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jaGFydC5fZG9Db2x1bW5WYWx1ZUZvcm1hdCh2LCBkKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByb3dzLmV4aXQoKS5yZW1vdmUoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJvd3M7XHJcbiAgICB9XHJcblxyXG4gICAgX2NoYXJ0Ll9kb1JlZHJhdyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0Ll9kb1JlbmRlcigpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBvciBzZXQgdGhlIGdyb3VwIGZ1bmN0aW9uIGZvciB0aGUgZGF0YSB0YWJsZS4gVGhlIGdyb3VwIGZ1bmN0aW9uIHRha2VzIGEgZGF0YSByb3cgYW5kXHJcbiAgICAgKiByZXR1cm5zIHRoZSBrZXkgdG8gc3BlY2lmeSB0byB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLWNvbGxlY3Rpb24vYmxvYi9tYXN0ZXIvUkVBRE1FLm1kI25lc3QgZDMubmVzdH1cclxuICAgICAqIHRvIHNwbGl0IHJvd3MgaW50byBncm91cHMuXHJcbiAgICAgKlxyXG4gICAgICogRG8gbm90IHBhc3MgaW4gYSBjcm9zc2ZpbHRlciBncm91cCBhcyB0aGlzIHdpbGwgbm90IHdvcmsuXHJcbiAgICAgKiBAbWV0aG9kIGdyb3VwXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuZGF0YVRhYmxlXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBncm91cCByb3dzIGJ5IHRoZSB2YWx1ZSBvZiB0aGVpciBmaWVsZFxyXG4gICAgICogY2hhcnRcclxuICAgICAqICAgICAuZ3JvdXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5maWVsZDsgfSlcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGdyb3VwRnVuY3Rpb24gRnVuY3Rpb24gdGFraW5nIGEgcm93IG9mIGRhdGEgYW5kIHJldHVybmluZyB0aGUgbmVzdCBrZXkuXHJcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb258ZGMuZGF0YVRhYmxlfVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgb3Igc2V0IHRoZSB0YWJsZSBzaXplIHdoaWNoIGRldGVybWluZXMgdGhlIG51bWJlciBvZiByb3dzIGRpc3BsYXllZCBieSB0aGUgd2lkZ2V0LlxyXG4gICAgICogQG1ldGhvZCBzaXplXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuZGF0YVRhYmxlXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc2l6ZT0yNV1cclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ8ZGMuZGF0YVRhYmxlfVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQuc2l6ZSA9IGZ1bmN0aW9uIChzaXplKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfc2l6ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3NpemUgPSBzaXplO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IG9yIHNldCB0aGUgaW5kZXggb2YgdGhlIGJlZ2lubmluZyBzbGljZSB3aGljaCBkZXRlcm1pbmVzIHdoaWNoIGVudHJpZXMgZ2V0IGRpc3BsYXllZFxyXG4gICAgICogYnkgdGhlIHdpZGdldC4gVXNlZnVsIHdoZW4gaW1wbGVtZW50aW5nIHBhZ2luYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogTm90ZTogdGhlIHNvcnRCeSBmdW5jdGlvbiB3aWxsIGRldGVybWluZSBob3cgdGhlIHJvd3MgYXJlIG9yZGVyZWQgZm9yIHBhZ2luYXRpb24gcHVycG9zZXMuXHJcblxyXG4gICAgICogU2VlIHRoZSB7QGxpbmsgaHR0cDovL2RjLWpzLmdpdGh1Yi5pby9kYy5qcy9leGFtcGxlcy90YWJsZS1wYWdpbmF0aW9uLmh0bWwgdGFibGUgcGFnaW5hdGlvbiBleGFtcGxlfVxyXG4gICAgICogdG8gc2VlIGhvdyB0byBpbXBsZW1lbnQgdGhlIHBhZ2luYXRpb24gdXNlciBpbnRlcmZhY2UgdXNpbmcgYGJlZ2luU2xpY2VgIGFuZCBgZW5kU2xpY2VgLlxyXG4gICAgICogQG1ldGhvZCBiZWdpblNsaWNlXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuZGF0YVRhYmxlXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbYmVnaW5TbGljZT0wXVxyXG4gICAgICogQHJldHVybnMge051bWJlcnxkYy5kYXRhVGFibGV9XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5iZWdpblNsaWNlID0gZnVuY3Rpb24gKGJlZ2luU2xpY2UpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9iZWdpblNsaWNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfYmVnaW5TbGljZSA9IGJlZ2luU2xpY2U7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgb3Igc2V0IHRoZSBpbmRleCBvZiB0aGUgZW5kIHNsaWNlIHdoaWNoIGRldGVybWluZXMgd2hpY2ggZW50cmllcyBnZXQgZGlzcGxheWVkIGJ5IHRoZVxyXG4gICAgICogd2lkZ2V0LiBVc2VmdWwgd2hlbiBpbXBsZW1lbnRpbmcgcGFnaW5hdGlvbi4gU2VlIHtAbGluayBkYy5kYXRhVGFibGUjYmVnaW5TbGljZSBgYmVnaW5TbGljZWB9IGZvciBtb3JlIGluZm9ybWF0aW9uLlxyXG4gICAgICogQG1ldGhvZCBlbmRTbGljZVxyXG4gICAgICogQG1lbWJlcm9mIGRjLmRhdGFUYWJsZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcnx1bmRlZmluZWR9IFtlbmRTbGljZT11bmRlZmluZWRdXHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfGRjLmRhdGFUYWJsZX1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LmVuZFNsaWNlID0gZnVuY3Rpb24gKGVuZFNsaWNlKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfZW5kU2xpY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9lbmRTbGljZSA9IGVuZFNsaWNlO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IG9yIHNldCBjb2x1bW4gZnVuY3Rpb25zLiBUaGUgZGF0YSB0YWJsZSB3aWRnZXQgc3VwcG9ydHMgc2V2ZXJhbCBtZXRob2RzIG9mIHNwZWNpZnlpbmcgdGhlXHJcbiAgICAgKiBjb2x1bW5zIHRvIGRpc3BsYXkuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIG9yaWdpbmFsIG1ldGhvZCB1c2VzIGFuIGFycmF5IG9mIGZ1bmN0aW9ucyB0byBnZW5lcmF0ZSBkeW5hbWljIGNvbHVtbnMuIENvbHVtbiBmdW5jdGlvbnNcclxuICAgICAqIGFyZSBzaW1wbGUgamF2YXNjcmlwdCBmdW5jdGlvbnMgd2l0aCBvbmx5IG9uZSBpbnB1dCBhcmd1bWVudCBgZGAgd2hpY2ggcmVwcmVzZW50cyBhIHJvdyBpblxyXG4gICAgICogdGhlIGRhdGEgc2V0LiBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoZXNlIGZ1bmN0aW9ucyB3aWxsIGJlIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGNvbnRlbnQgZm9yXHJcbiAgICAgKiBlYWNoIGNlbGwuIEhvd2V2ZXIsIHRoaXMgbWV0aG9kIHJlcXVpcmVzIHRoZSBIVE1MIGZvciB0aGUgdGFibGUgdG8gaGF2ZSBhIGZpeGVkIHNldCBvZiBjb2x1bW5cclxuICAgICAqIGhlYWRlcnMuXHJcbiAgICAgKlxyXG4gICAgICogPHByZT48Y29kZT5jaGFydC5jb2x1bW5zKFtcclxuICAgICAqICAgICBmdW5jdGlvbihkKSB7IHJldHVybiBkLmRhdGU7IH0sXHJcbiAgICAgKiAgICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5vcGVuOyB9LFxyXG4gICAgICogICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuY2xvc2U7IH0sXHJcbiAgICAgKiAgICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gbnVtYmVyRm9ybWF0KGQuY2xvc2UgLSBkLm9wZW4pOyB9LFxyXG4gICAgICogICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQudm9sdW1lOyB9XHJcbiAgICAgKiBdKTtcclxuICAgICAqIDwvY29kZT48L3ByZT5cclxuICAgICAqXHJcbiAgICAgKiBJbiB0aGUgc2Vjb25kIG1ldGhvZCwgeW91IGNhbiBsaXN0IHRoZSBjb2x1bW5zIHRvIHJlYWQgZnJvbSB0aGUgZGF0YSB3aXRob3V0IHNwZWNpZnlpbmcgaXQgYXNcclxuICAgICAqIGEgZnVuY3Rpb24sIGV4Y2VwdCB3aGVyZSBuZWNlc3NhcnkgKGllLCBjb21wdXRlZCBjb2x1bW5zKS4gIE5vdGUgdGhlIGRhdGEgZWxlbWVudCBuYW1lIGlzXHJcbiAgICAgKiBjYXBpdGFsaXplZCB3aGVuIGRpc3BsYXllZCBpbiB0aGUgdGFibGUgaGVhZGVyLiBZb3UgY2FuIGFsc28gbWl4IGluIGZ1bmN0aW9ucyBhcyBuZWNlc3NhcnksXHJcbiAgICAgKiB1c2luZyB0aGUgdGhpcmQgYHtsYWJlbCwgZm9ybWF0fWAgZm9ybSwgYXMgc2hvd24gYmVsb3cuXHJcbiAgICAgKlxyXG4gICAgICogPHByZT48Y29kZT5jaGFydC5jb2x1bW5zKFtcclxuICAgICAqICAgICBcImRhdGVcIiwgICAgLy8gZFtcImRhdGVcIl0sIGllLCBhIGZpZWxkIGFjY2Vzc29yOyBjYXBpdGFsaXplZCBhdXRvbWF0aWNhbGx5XHJcbiAgICAgKiAgICAgXCJvcGVuXCIsICAgIC8vIC4uLlxyXG4gICAgICogICAgIFwiY2xvc2VcIiwgICAvLyAuLi5cclxuICAgICAqICAgICB7XHJcbiAgICAgKiAgICAgICAgIGxhYmVsOiBcIkNoYW5nZVwiLFxyXG4gICAgICogICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgKiAgICAgICAgICAgICByZXR1cm4gbnVtYmVyRm9ybWF0KGQuY2xvc2UgLSBkLm9wZW4pO1xyXG4gICAgICogICAgICAgICB9XHJcbiAgICAgKiAgICAgfSxcclxuICAgICAqICAgICBcInZvbHVtZVwiICAgLy8gZFtcInZvbHVtZVwiXSwgaWUsIGEgZmllbGQgYWNjZXNzb3I7IGNhcGl0YWxpemVkIGF1dG9tYXRpY2FsbHlcclxuICAgICAqIF0pO1xyXG4gICAgICogPC9jb2RlPjwvcHJlPlxyXG4gICAgICpcclxuICAgICAqIEluIHRoZSB0aGlyZCBleGFtcGxlLCB3ZSBzcGVjaWZ5IGFsbCBmaWVsZHMgdXNpbmcgdGhlIGB7bGFiZWwsIGZvcm1hdH1gIG1ldGhvZDpcclxuICAgICAqIDxwcmU+PGNvZGU+Y2hhcnQuY29sdW1ucyhbXHJcbiAgICAgKiAgICAge1xyXG4gICAgICogICAgICAgICBsYWJlbDogXCJEYXRlXCIsXHJcbiAgICAgKiAgICAgICAgIGZvcm1hdDogZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQuZGF0ZTsgfVxyXG4gICAgICogICAgIH0sXHJcbiAgICAgKiAgICAge1xyXG4gICAgICogICAgICAgICBsYWJlbDogXCJPcGVuXCIsXHJcbiAgICAgKiAgICAgICAgIGZvcm1hdDogZnVuY3Rpb24gKGQpIHsgcmV0dXJuIG51bWJlckZvcm1hdChkLm9wZW4pOyB9XHJcbiAgICAgKiAgICAgfSxcclxuICAgICAqICAgICB7XHJcbiAgICAgKiAgICAgICAgIGxhYmVsOiBcIkNsb3NlXCIsXHJcbiAgICAgKiAgICAgICAgIGZvcm1hdDogZnVuY3Rpb24gKGQpIHsgcmV0dXJuIG51bWJlckZvcm1hdChkLmNsb3NlKTsgfVxyXG4gICAgICogICAgIH0sXHJcbiAgICAgKiAgICAge1xyXG4gICAgICogICAgICAgICBsYWJlbDogXCJDaGFuZ2VcIixcclxuICAgICAqICAgICAgICAgZm9ybWF0OiBmdW5jdGlvbiAoZCkgeyByZXR1cm4gbnVtYmVyRm9ybWF0KGQuY2xvc2UgLSBkLm9wZW4pOyB9XHJcbiAgICAgKiAgICAgfSxcclxuICAgICAqICAgICB7XHJcbiAgICAgKiAgICAgICAgIGxhYmVsOiBcIlZvbHVtZVwiLFxyXG4gICAgICogICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLnZvbHVtZTsgfVxyXG4gICAgICogICAgIH1cclxuICAgICAqIF0pO1xyXG4gICAgICogPC9jb2RlPjwvcHJlPlxyXG4gICAgICpcclxuICAgICAqIFlvdSBtYXkgd2lzaCB0byBvdmVycmlkZSB0aGUgZGF0YVRhYmxlIGZ1bmN0aW9ucyBgX2RvQ29sdW1uSGVhZGVyQ2FwaXRhbGl6ZWAgYW5kXHJcbiAgICAgKiBgX2RvQ29sdW1uSGVhZGVyRm5Ub1N0cmluZ2AsIHdoaWNoIGFyZSB1c2VkIGludGVybmFsbHkgdG8gdHJhbnNsYXRlIHRoZSBjb2x1bW4gaW5mb3JtYXRpb24gb3JcclxuICAgICAqIGZ1bmN0aW9uIGludG8gYSBkaXNwbGF5ZWQgaGVhZGVyLiBUaGUgZmlyc3Qgb25lIGlzIHVzZWQgb24gdGhlIFwic3RyaW5nXCIgY29sdW1uIHNwZWNpZmllcjsgdGhlXHJcbiAgICAgKiBzZWNvbmQgaXMgdXNlZCB0byB0cmFuc2Zvcm0gYSBzdHJpbmdpZmllZCBmdW5jdGlvbiBpbnRvIHNvbWV0aGluZyBkaXNwbGF5YWJsZS4gRm9yIHRoZSBTdG9ja1xyXG4gICAgICogZXhhbXBsZSwgdGhlIGZ1bmN0aW9uIGZvciBDaGFuZ2UgYmVjb21lcyB0aGUgdGFibGUgaGVhZGVyICoqZC5jbG9zZSAtIGQub3BlbioqLlxyXG4gICAgICpcclxuICAgICAqIEZpbmFsbHksIHlvdSBjYW4gZXZlbiBzcGVjaWZ5IGEgY29tcGxldGVseSBkaWZmZXJlbnQgZm9ybSBvZiBjb2x1bW4gZGVmaW5pdGlvbi4gVG8gZG8gdGhpcyxcclxuICAgICAqIG92ZXJyaWRlIGBfY2hhcnQuX2RvQ29sdW1uSGVhZGVyRm9ybWF0YCBhbmQgYF9jaGFydC5fZG9Db2x1bW5WYWx1ZUZvcm1hdGAgQmUgYXdhcmUgdGhhdFxyXG4gICAgICogZmllbGRzIHdpdGhvdXQgbnVtYmVyRm9ybWF0IHNwZWNpZmljYXRpb24gd2lsbCBiZSBkaXNwbGF5ZWQganVzdCBhcyB0aGV5IGFyZSBzdG9yZWQgaW4gdGhlXHJcbiAgICAgKiBkYXRhLCB1bmZvcm1hdHRlZC5cclxuICAgICAqIEBtZXRob2QgY29sdW1uc1xyXG4gICAgICogQG1lbWJlcm9mIGRjLmRhdGFUYWJsZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5PEZ1bmN0aW9uPn0gW2NvbHVtbnM9W11dXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8RnVuY3Rpb24+fXxkYy5kYXRhVGFibGV9XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5jb2x1bW5zID0gZnVuY3Rpb24gKGNvbHVtbnMpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9jb2x1bW5zO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfY29sdW1ucyA9IGNvbHVtbnM7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgb3Igc2V0IHNvcnQtYnkgZnVuY3Rpb24uIFRoaXMgZnVuY3Rpb24gd29ya3MgYXMgYSB2YWx1ZSBhY2Nlc3NvciBhdCByb3cgbGV2ZWwgYW5kIHJldHVybnMgYVxyXG4gICAgICogcGFydGljdWxhciBmaWVsZCB0byBiZSBzb3J0ZWQgYnkuXHJcbiAgICAgKiBAbWV0aG9kIHNvcnRCeVxyXG4gICAgICogQG1lbWJlcm9mIGRjLmRhdGFUYWJsZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogY2hhcnQuc29ydEJ5KGZ1bmN0aW9uKGQpIHtcclxuICAgICAqICAgICByZXR1cm4gZC5kYXRlO1xyXG4gICAgICogfSk7XHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc29ydEJ5PWlkZW50aXR5IGZ1bmN0aW9uXVxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufGRjLmRhdGFUYWJsZX1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LnNvcnRCeSA9IGZ1bmN0aW9uIChzb3J0QnkpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9zb3J0Qnk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9zb3J0QnkgPSBzb3J0Qnk7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgb3Igc2V0IHNvcnQgb3JkZXIuIElmIHRoZSBvcmRlciBpcyBgZDMuYXNjZW5kaW5nYCwgdGhlIGRhdGEgdGFibGUgd2lsbCB1c2VcclxuICAgICAqIGBkaW1lbnNpb24oKS5ib3R0b20oKWAgdG8gZmV0Y2ggdGhlIGRhdGE7IG90aGVyd2lzZSBpdCB3aWxsIHVzZSBgZGltZW5zaW9uKCkudG9wKClgXHJcbiAgICAgKiBAbWV0aG9kIG9yZGVyXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuZGF0YVRhYmxlXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1hcnJheS9ibG9iL21hc3Rlci9SRUFETUUubWQjYXNjZW5kaW5nIGQzLmFzY2VuZGluZ31cclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1hcnJheS9ibG9iL21hc3Rlci9SRUFETUUubWQjZGVzY2VuZGluZyBkMy5kZXNjZW5kaW5nfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGNoYXJ0Lm9yZGVyKGQzLmRlc2NlbmRpbmcpO1xyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29yZGVyPWQzLmFzY2VuZGluZ11cclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbnxkYy5kYXRhVGFibGV9XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5vcmRlciA9IGZ1bmN0aW9uIChvcmRlcikge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX29yZGVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfb3JkZXIgPSBvcmRlcjtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBvciBzZXQgaWYgZ3JvdXAgcm93cyB3aWxsIGJlIHNob3duLiBUaGUgZGF0YVRhYmxlIHtAbGluayBkYy5kYXRhVGFibGUjZ3JvdXAgZ3JvdXB9XHJcbiAgICAgKiBmdW5jdGlvbiBtdXN0IGJlIHNwZWNpZmllZCBldmVuIGlmIGdyb3VwcyBhcmUgbm90IHNob3duLlxyXG4gICAgICogQG1ldGhvZCBzaG93R3JvdXBzXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuZGF0YVRhYmxlXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBjaGFydFxyXG4gICAgICogICAgIC5ncm91cChbdmFsdWVdLCBbbmFtZV0pXHJcbiAgICAgKiAgICAgLnNob3dHcm91cHModHJ1ZXxmYWxzZSk7XHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaG93R3JvdXBzPXRydWVdXHJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbnxkYy5kYXRhVGFibGV9XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5zaG93R3JvdXBzID0gZnVuY3Rpb24gKHNob3dHcm91cHMpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9zaG93R3JvdXBzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfc2hvd0dyb3VwcyA9IHNob3dHcm91cHM7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIF9jaGFydC5hbmNob3IocGFyZW50LCBjaGFydEdyb3VwKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBEYXRhIGdyaWQgaXMgYSBzaW1wbGUgd2lkZ2V0IGRlc2lnbmVkIHRvIGxpc3QgdGhlIGZpbHRlcmVkIHJlY29yZHMsIHByb3ZpZGluZ1xyXG4gKiBhIHNpbXBsZSB3YXkgdG8gZGVmaW5lIGhvdyB0aGUgaXRlbXMgYXJlIGRpc3BsYXllZC5cclxuICpcclxuICogTm90ZTogVW5saWtlIG90aGVyIGNoYXJ0cywgdGhlIGRhdGEgZ3JpZCBjaGFydCAoYW5kIGRhdGEgdGFibGUpIHVzZSB0aGUge0BsaW5rIGRjLmRhdGFHcmlkI2dyb3VwIGdyb3VwfSBhdHRyaWJ1dGUgYXMgYSBrZXlpbmcgZnVuY3Rpb25cclxuICogZm9yIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtY29sbGVjdGlvbi9ibG9iL21hc3Rlci9SRUFETUUubWQjbmVzdCBuZXN0aW5nfSB0aGUgZGF0YSB0b2dldGhlciBpbiBncm91cHMuXHJcbiAqIERvIG5vdCBwYXNzIGluIGEgY3Jvc3NmaWx0ZXIgZ3JvdXAgYXMgdGhpcyB3aWxsIG5vdCB3b3JrLlxyXG4gKlxyXG4gKiBFeGFtcGxlczpcclxuICogLSB7QGxpbmsgaHR0cDovL2V1cm9wYXJsLm1lL2RjLmpzL3dlYi9lcC9pbmRleC5odG1sIExpc3Qgb2YgbWVtYmVycyBvZiB0aGUgZXVyb3BlYW4gcGFybGlhbWVudH1cclxuICogQGNsYXNzIGRhdGFHcmlkXHJcbiAqIEBtZW1iZXJvZiBkY1xyXG4gKiBAbWl4ZXMgZGMuYmFzZU1peGluXHJcbiAqIEBwYXJhbSB7U3RyaW5nfG5vZGV8ZDMuc2VsZWN0aW9ufSBwYXJlbnQgLSBBbnkgdmFsaWRcclxuICoge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1zZWxlY3Rpb24vYmxvYi9tYXN0ZXIvUkVBRE1FLm1kI3NlbGVjdCBkMyBzaW5nbGUgc2VsZWN0b3J9IHNwZWNpZnlpbmdcclxuICogYSBkb20gYmxvY2sgZWxlbWVudCBzdWNoIGFzIGEgZGl2OyBvciBhIGRvbSBlbGVtZW50IG9yIGQzIHNlbGVjdGlvbi5cclxuICogQHBhcmFtIHtTdHJpbmd9IFtjaGFydEdyb3VwXSAtIFRoZSBuYW1lIG9mIHRoZSBjaGFydCBncm91cCB0aGlzIGNoYXJ0IGluc3RhbmNlIHNob3VsZCBiZSBwbGFjZWQgaW4uXHJcbiAqIEludGVyYWN0aW9uIHdpdGggYSBjaGFydCB3aWxsIG9ubHkgdHJpZ2dlciBldmVudHMgYW5kIHJlZHJhd3Mgd2l0aGluIHRoZSBjaGFydCdzIGdyb3VwLlxyXG4gKiBAcmV0dXJucyB7ZGMuZGF0YUdyaWR9XHJcbiAqL1xyXG5kYy5kYXRhR3JpZCA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoYXJ0R3JvdXApIHtcclxuICAgIHZhciBMQUJFTF9DU1NfQ0xBU1MgPSAnZGMtZ3JpZC1sYWJlbCc7XHJcbiAgICB2YXIgSVRFTV9DU1NfQ0xBU1MgPSAnZGMtZ3JpZC1pdGVtJztcclxuICAgIHZhciBHUk9VUF9DU1NfQ0xBU1MgPSAnZGMtZ3JpZC1ncm91cCc7XHJcbiAgICB2YXIgR1JJRF9DU1NfQ0xBU1MgPSAnZGMtZ3JpZC10b3AnO1xyXG5cclxuICAgIHZhciBfY2hhcnQgPSBkYy5iYXNlTWl4aW4oe30pO1xyXG5cclxuICAgIHZhciBfc2l6ZSA9IDk5OTsgLy8gc2hvdWxkbid0IGJlIG5lZWRlZCwgYnV0IHlvdSBtaWdodFxyXG4gICAgdmFyIF9odG1sID0gZnVuY3Rpb24gKGQpIHsgcmV0dXJuICd5b3UgbmVlZCB0byBwcm92aWRlIGFuIGh0bWwoKSBoYW5kbGluZyBwYXJhbTogICcgKyBKU09OLnN0cmluZ2lmeShkKTsgfTtcclxuICAgIHZhciBfc29ydEJ5ID0gZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICByZXR1cm4gZDtcclxuICAgIH07XHJcbiAgICB2YXIgX29yZGVyID0gZDMuYXNjZW5kaW5nO1xyXG4gICAgdmFyIF9iZWdpblNsaWNlID0gMCwgX2VuZFNsaWNlO1xyXG5cclxuICAgIHZhciBfaHRtbEdyb3VwID0gZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICByZXR1cm4gJzxkaXYgY2xhc3M9XFwnJyArIEdST1VQX0NTU19DTEFTUyArICdcXCc+PGgxIGNsYXNzPVxcJycgKyBMQUJFTF9DU1NfQ0xBU1MgKyAnXFwnPicgK1xyXG4gICAgICAgICAgICBfY2hhcnQua2V5QWNjZXNzb3IoKShkKSArICc8L2gxPjwvZGl2Pic7XHJcbiAgICB9O1xyXG5cclxuICAgIF9jaGFydC5fZG9SZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX2NoYXJ0LnNlbGVjdEFsbCgnZGl2LicgKyBHUklEX0NTU19DTEFTUykucmVtb3ZlKCk7XHJcblxyXG4gICAgICAgIHJlbmRlckl0ZW1zKHJlbmRlckdyb3VwcygpKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gcmVuZGVyR3JvdXBzICgpIHtcclxuICAgICAgICB2YXIgZ3JvdXBzID0gX2NoYXJ0LnJvb3QoKS5zZWxlY3RBbGwoJ2Rpdi4nICsgR1JJRF9DU1NfQ0xBU1MpXHJcbiAgICAgICAgICAgICAgICAuZGF0YShuZXN0RW50cmllcygpLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfY2hhcnQua2V5QWNjZXNzb3IoKShkKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICB2YXIgaXRlbUdyb3VwID0gZ3JvdXBzXHJcbiAgICAgICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnZGl2JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIEdSSURfQ1NTX0NMQVNTKTtcclxuXHJcbiAgICAgICAgaWYgKF9odG1sR3JvdXApIHtcclxuICAgICAgICAgICAgaXRlbUdyb3VwXHJcbiAgICAgICAgICAgICAgICAuaHRtbChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfaHRtbEdyb3VwKGQpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBncm91cHMuZXhpdCgpLnJlbW92ZSgpO1xyXG4gICAgICAgIHJldHVybiBpdGVtR3JvdXA7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbmVzdEVudHJpZXMgKCkge1xyXG4gICAgICAgIHZhciBlbnRyaWVzID0gX2NoYXJ0LmRpbWVuc2lvbigpLnRvcChfc2l6ZSk7XHJcblxyXG4gICAgICAgIHJldHVybiBkMy5uZXN0KClcclxuICAgICAgICAgICAgLmtleShfY2hhcnQuZ3JvdXAoKSlcclxuICAgICAgICAgICAgLnNvcnRLZXlzKF9vcmRlcilcclxuICAgICAgICAgICAgLmVudHJpZXMoZW50cmllcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX29yZGVyKF9zb3J0QnkoYSksIF9zb3J0QnkoYikpO1xyXG4gICAgICAgICAgICB9KS5zbGljZShfYmVnaW5TbGljZSwgX2VuZFNsaWNlKSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVuZGVySXRlbXMgKGdyb3Vwcykge1xyXG4gICAgICAgIHZhciBpdGVtcyA9IGdyb3Vwcy5vcmRlcigpXHJcbiAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCdkaXYuJyArIElURU1fQ1NTX0NMQVNTKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC52YWx1ZXM7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaXRlbXMuZXhpdCgpLnJlbW92ZSgpO1xyXG5cclxuICAgICAgICBpdGVtcyA9IGl0ZW1zXHJcbiAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdkaXYnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgSVRFTV9DU1NfQ0xBU1MpXHJcbiAgICAgICAgICAgICAgICAuaHRtbChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfaHRtbChkKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5tZXJnZShpdGVtcyk7XHJcblxyXG4gICAgICAgIHJldHVybiBpdGVtcztcclxuICAgIH1cclxuXHJcbiAgICBfY2hhcnQuX2RvUmVkcmF3ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQuX2RvUmVuZGVyKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IG9yIHNldCB0aGUgZ3JvdXAgZnVuY3Rpb24gZm9yIHRoZSBkYXRhIGdyaWQuIFRoZSBncm91cCBmdW5jdGlvbiB0YWtlcyBhIGRhdGEgcm93IGFuZFxyXG4gICAgICogcmV0dXJucyB0aGUga2V5IHRvIHNwZWNpZnkgdG8ge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1jb2xsZWN0aW9uL2Jsb2IvbWFzdGVyL1JFQURNRS5tZCNuZXN0IGQzLm5lc3R9XHJcbiAgICAgKiB0byBzcGxpdCByb3dzIGludG8gZ3JvdXBzLlxyXG4gICAgICpcclxuICAgICAqIERvIG5vdCBwYXNzIGluIGEgY3Jvc3NmaWx0ZXIgZ3JvdXAgYXMgdGhpcyB3aWxsIG5vdCB3b3JrLlxyXG4gICAgICogQG1ldGhvZCBncm91cFxyXG4gICAgICogQG1lbWJlcm9mIGRjLmRhdGFHcmlkXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBncm91cCByb3dzIGJ5IHRoZSB2YWx1ZSBvZiB0aGVpciBmaWVsZFxyXG4gICAgICogY2hhcnRcclxuICAgICAqICAgICAuZ3JvdXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5maWVsZDsgfSlcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGdyb3VwRnVuY3Rpb24gRnVuY3Rpb24gdGFraW5nIGEgcm93IG9mIGRhdGEgYW5kIHJldHVybmluZyB0aGUgbmVzdCBrZXkuXHJcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb258ZGMuZGF0YVRhYmxlfVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgb3Igc2V0IHRoZSBpbmRleCBvZiB0aGUgYmVnaW5uaW5nIHNsaWNlIHdoaWNoIGRldGVybWluZXMgd2hpY2ggZW50cmllcyBnZXQgZGlzcGxheWVkIGJ5IHRoZSB3aWRnZXQuXHJcbiAgICAgKiBVc2VmdWwgd2hlbiBpbXBsZW1lbnRpbmcgcGFnaW5hdGlvbi5cclxuICAgICAqIEBtZXRob2QgYmVnaW5TbGljZVxyXG4gICAgICogQG1lbWJlcm9mIGRjLmRhdGFHcmlkXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbYmVnaW5TbGljZT0wXVxyXG4gICAgICogQHJldHVybnMge051bWJlcnxkYy5kYXRhR3JpZH1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LmJlZ2luU2xpY2UgPSBmdW5jdGlvbiAoYmVnaW5TbGljZSkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2JlZ2luU2xpY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9iZWdpblNsaWNlID0gYmVnaW5TbGljZTtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBvciBzZXQgdGhlIGluZGV4IG9mIHRoZSBlbmQgc2xpY2Ugd2hpY2ggZGV0ZXJtaW5lcyB3aGljaCBlbnRyaWVzIGdldCBkaXNwbGF5ZWQgYnkgdGhlIHdpZGdldC5cclxuICAgICAqIFVzZWZ1bCB3aGVuIGltcGxlbWVudGluZyBwYWdpbmF0aW9uLlxyXG4gICAgICogQG1ldGhvZCBlbmRTbGljZVxyXG4gICAgICogQG1lbWJlcm9mIGRjLmRhdGFHcmlkXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZW5kU2xpY2VdXHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfGRjLmRhdGFHcmlkfVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQuZW5kU2xpY2UgPSBmdW5jdGlvbiAoZW5kU2xpY2UpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9lbmRTbGljZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX2VuZFNsaWNlID0gZW5kU2xpY2U7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgb3Igc2V0IHRoZSBncmlkIHNpemUgd2hpY2ggZGV0ZXJtaW5lcyB0aGUgbnVtYmVyIG9mIGl0ZW1zIGRpc3BsYXllZCBieSB0aGUgd2lkZ2V0LlxyXG4gICAgICogQG1ldGhvZCBzaXplXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuZGF0YUdyaWRcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtzaXplPTk5OV1cclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ8ZGMuZGF0YUdyaWR9XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5zaXplID0gZnVuY3Rpb24gKHNpemUpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9zaXplO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfc2l6ZSA9IHNpemU7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgb3Igc2V0IHRoZSBmdW5jdGlvbiB0aGF0IGZvcm1hdHMgYW4gaXRlbS4gVGhlIGRhdGEgZ3JpZCB3aWRnZXQgdXNlcyBhXHJcbiAgICAgKiBmdW5jdGlvbiB0byBnZW5lcmF0ZSBkeW5hbWljIGh0bWwuIFVzZSB5b3VyIGZhdm91cml0ZSB0ZW1wbGF0aW5nIGVuZ2luZSBvclxyXG4gICAgICogZ2VuZXJhdGUgdGhlIHN0cmluZyBkaXJlY3RseS5cclxuICAgICAqIEBtZXRob2QgaHRtbFxyXG4gICAgICogQG1lbWJlcm9mIGRjLmRhdGFHcmlkXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBjaGFydC5odG1sKGZ1bmN0aW9uIChkKSB7IHJldHVybiAnPGRpdiBjbGFzcz0naXRlbSAnK2RhdGEuZXhhbXBsZUNhdGVnb3J5KycnPicrZGF0YS5leGFtcGxlU3RyaW5nKyc8L2Rpdj4nO30pO1xyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2h0bWxdXHJcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb258ZGMuZGF0YUdyaWR9XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5odG1sID0gZnVuY3Rpb24gKGh0bWwpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9odG1sO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfaHRtbCA9IGh0bWw7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgb3Igc2V0IHRoZSBmdW5jdGlvbiB0aGF0IGZvcm1hdHMgYSBncm91cCBsYWJlbC5cclxuICAgICAqIEBtZXRob2QgaHRtbEdyb3VwXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuZGF0YUdyaWRcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGNoYXJ0Lmh0bWxHcm91cCAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuICc8aDI+Jy5kLmtleSAuICd3aXRoICcgLiBkLnZhbHVlcy5sZW5ndGggLicgaXRlbXM8L2gyPid9KTtcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtodG1sR3JvdXBdXHJcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb258ZGMuZGF0YUdyaWR9XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5odG1sR3JvdXAgPSBmdW5jdGlvbiAoaHRtbEdyb3VwKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfaHRtbEdyb3VwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfaHRtbEdyb3VwID0gaHRtbEdyb3VwO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IG9yIHNldCBzb3J0LWJ5IGZ1bmN0aW9uLiBUaGlzIGZ1bmN0aW9uIHdvcmtzIGFzIGEgdmFsdWUgYWNjZXNzb3IgYXQgdGhlIGl0ZW1cclxuICAgICAqIGxldmVsIGFuZCByZXR1cm5zIGEgcGFydGljdWxhciBmaWVsZCB0byBiZSBzb3J0ZWQuXHJcbiAgICAgKiBAbWV0aG9kIHNvcnRCeVxyXG4gICAgICogQG1lbWJlcm9mIGRjLmRhdGFHcmlkXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBjaGFydC5zb3J0QnkoZnVuY3Rpb24oZCkge1xyXG4gICAgICogICAgIHJldHVybiBkLmRhdGU7XHJcbiAgICAgKiB9KTtcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzb3J0QnlGdW5jdGlvbl1cclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbnxkYy5kYXRhR3JpZH1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LnNvcnRCeSA9IGZ1bmN0aW9uIChzb3J0QnlGdW5jdGlvbikge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3NvcnRCeTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3NvcnRCeSA9IHNvcnRCeUZ1bmN0aW9uO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IG9yIHNldCBzb3J0IHRoZSBvcmRlciBmdW5jdGlvbi5cclxuICAgICAqIEBtZXRob2Qgb3JkZXJcclxuICAgICAqIEBtZW1iZXJvZiBkYy5kYXRhR3JpZFxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtYXJyYXkvYmxvYi9tYXN0ZXIvUkVBRE1FLm1kI2FzY2VuZGluZyBkMy5hc2NlbmRpbmd9XHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtYXJyYXkvYmxvYi9tYXN0ZXIvUkVBRE1FLm1kI2Rlc2NlbmRpbmcgZDMuZGVzY2VuZGluZ31cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBjaGFydC5vcmRlcihkMy5kZXNjZW5kaW5nKTtcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcmRlcj1kMy5hc2NlbmRpbmddXHJcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb258ZGMuZGF0YUdyaWR9XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5vcmRlciA9IGZ1bmN0aW9uIChvcmRlcikge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX29yZGVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfb3JkZXIgPSBvcmRlcjtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gX2NoYXJ0LmFuY2hvcihwYXJlbnQsIGNoYXJ0R3JvdXApO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEEgY29uY3JldGUgaW1wbGVtZW50YXRpb24gb2YgYSBnZW5lcmFsIHB1cnBvc2UgYnViYmxlIGNoYXJ0IHRoYXQgYWxsb3dzIGRhdGEgdmlzdWFsaXphdGlvbiB1c2luZyB0aGVcclxuICogZm9sbG93aW5nIGRpbWVuc2lvbnM6XHJcbiAqIC0geCBheGlzIHBvc2l0aW9uXHJcbiAqIC0geSBheGlzIHBvc2l0aW9uXHJcbiAqIC0gYnViYmxlIHJhZGl1c1xyXG4gKiAtIGNvbG9yXHJcbiAqXHJcbiAqIEV4YW1wbGVzOlxyXG4gKiAtIHtAbGluayBodHRwOi8vZGMtanMuZ2l0aHViLmNvbS9kYy5qcy8gTmFzZGFxIDEwMCBJbmRleH1cclxuICogLSB7QGxpbmsgaHR0cDovL2RjLWpzLmdpdGh1Yi5jb20vZGMuanMvdmMvaW5kZXguaHRtbCBVUyBWZW50dXJlIENhcGl0YWwgTGFuZHNjYXBlIDIwMTF9XHJcbiAqIEBjbGFzcyBidWJibGVDaGFydFxyXG4gKiBAbWVtYmVyb2YgZGNcclxuICogQG1peGVzIGRjLmJ1YmJsZU1peGluXHJcbiAqIEBtaXhlcyBkYy5jb29yZGluYXRlR3JpZE1peGluXHJcbiAqIEBleGFtcGxlXHJcbiAqIC8vIGNyZWF0ZSBhIGJ1YmJsZSBjaGFydCB1bmRlciAjY2hhcnQtY29udGFpbmVyMSBlbGVtZW50IHVzaW5nIHRoZSBkZWZhdWx0IGdsb2JhbCBjaGFydCBncm91cFxyXG4gKiB2YXIgYnViYmxlQ2hhcnQxID0gZGMuYnViYmxlQ2hhcnQoJyNjaGFydC1jb250YWluZXIxJyk7XHJcbiAqIC8vIGNyZWF0ZSBhIGJ1YmJsZSBjaGFydCB1bmRlciAjY2hhcnQtY29udGFpbmVyMiBlbGVtZW50IHVzaW5nIGNoYXJ0IGdyb3VwIEFcclxuICogdmFyIGJ1YmJsZUNoYXJ0MiA9IGRjLmJ1YmJsZUNoYXJ0KCcjY2hhcnQtY29udGFpbmVyMicsICdjaGFydEdyb3VwQScpO1xyXG4gKiBAcGFyYW0ge1N0cmluZ3xub2RlfGQzLnNlbGVjdGlvbn0gcGFyZW50IC0gQW55IHZhbGlkXHJcbiAqIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2VsZWN0aW9uL2Jsb2IvbWFzdGVyL1JFQURNRS5tZCNzZWxlY3QgZDMgc2luZ2xlIHNlbGVjdG9yfSBzcGVjaWZ5aW5nXHJcbiAqIGEgZG9tIGJsb2NrIGVsZW1lbnQgc3VjaCBhcyBhIGRpdjsgb3IgYSBkb20gZWxlbWVudCBvciBkMyBzZWxlY3Rpb24uXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbY2hhcnRHcm91cF0gLSBUaGUgbmFtZSBvZiB0aGUgY2hhcnQgZ3JvdXAgdGhpcyBjaGFydCBpbnN0YW5jZSBzaG91bGQgYmUgcGxhY2VkIGluLlxyXG4gKiBJbnRlcmFjdGlvbiB3aXRoIGEgY2hhcnQgd2lsbCBvbmx5IHRyaWdnZXIgZXZlbnRzIGFuZCByZWRyYXdzIHdpdGhpbiB0aGUgY2hhcnQncyBncm91cC5cclxuICogQHJldHVybnMge2RjLmJ1YmJsZUNoYXJ0fVxyXG4gKi9cclxuZGMuYnViYmxlQ2hhcnQgPSBmdW5jdGlvbiAocGFyZW50LCBjaGFydEdyb3VwKSB7XHJcbiAgICB2YXIgX2NoYXJ0ID0gZGMuYnViYmxlTWl4aW4oZGMuY29vcmRpbmF0ZUdyaWRNaXhpbih7fSkpO1xyXG5cclxuICAgIF9jaGFydC50cmFuc2l0aW9uRHVyYXRpb24oNzUwKTtcclxuXHJcbiAgICBfY2hhcnQudHJhbnNpdGlvbkRlbGF5KDApO1xyXG5cclxuICAgIHZhciBidWJibGVMb2NhdG9yID0gZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgKGJ1YmJsZVgoZCkpICsgJywnICsgKGJ1YmJsZVkoZCkpICsgJyknO1xyXG4gICAgfTtcclxuXHJcbiAgICBfY2hhcnQucGxvdERhdGEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX2NoYXJ0LmNhbGN1bGF0ZVJhZGl1c0RvbWFpbigpO1xyXG4gICAgICAgIF9jaGFydC5yKCkucmFuZ2UoW19jaGFydC5NSU5fUkFESVVTLCBfY2hhcnQueEF4aXNMZW5ndGgoKSAqIF9jaGFydC5tYXhCdWJibGVSZWxhdGl2ZVNpemUoKV0pO1xyXG5cclxuICAgICAgICB2YXIgZGF0YSA9IF9jaGFydC5kYXRhKCk7XHJcbiAgICAgICAgdmFyIGJ1YmJsZUcgPSBfY2hhcnQuY2hhcnRCb2R5RygpLnNlbGVjdEFsbCgnZy4nICsgX2NoYXJ0LkJVQkJMRV9OT0RFX0NMQVNTKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEoZGF0YSwgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQua2V5OyB9KTtcclxuICAgICAgICBpZiAoX2NoYXJ0LnNvcnRCdWJibGVTaXplKCkpIHtcclxuICAgICAgICAgICAgLy8gdXBkYXRlIGRvbSBvcmRlciBiYXNlZCBvbiBzb3J0XHJcbiAgICAgICAgICAgIGJ1YmJsZUcub3JkZXIoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlbW92ZU5vZGVzKGJ1YmJsZUcpO1xyXG5cclxuICAgICAgICBidWJibGVHID0gcmVuZGVyTm9kZXMoYnViYmxlRyk7XHJcblxyXG4gICAgICAgIHVwZGF0ZU5vZGVzKGJ1YmJsZUcpO1xyXG5cclxuICAgICAgICBfY2hhcnQuZmFkZURlc2VsZWN0ZWRBcmVhKF9jaGFydC5maWx0ZXIoKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIHJlbmRlck5vZGVzIChidWJibGVHKSB7XHJcbiAgICAgICAgdmFyIGJ1YmJsZUdFbnRlciA9IGJ1YmJsZUcuZW50ZXIoKS5hcHBlbmQoJ2cnKTtcclxuXHJcbiAgICAgICAgYnViYmxlR0VudGVyXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIF9jaGFydC5CVUJCTEVfTk9ERV9DTEFTUylcclxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGJ1YmJsZUxvY2F0b3IpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2NpcmNsZScpLmF0dHIoJ2NsYXNzJywgZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfY2hhcnQuQlVCQkxFX0NMQVNTICsgJyBfJyArIGk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5vbignY2xpY2snLCBfY2hhcnQub25DbGljaylcclxuICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCBfY2hhcnQuZ2V0Q29sb3IpXHJcbiAgICAgICAgICAgIC5hdHRyKCdyJywgMCk7XHJcblxyXG4gICAgICAgIGJ1YmJsZUcgPSBidWJibGVHRW50ZXIubWVyZ2UoYnViYmxlRyk7XHJcblxyXG4gICAgICAgIGRjLnRyYW5zaXRpb24oYnViYmxlRywgX2NoYXJ0LnRyYW5zaXRpb25EdXJhdGlvbigpLCBfY2hhcnQudHJhbnNpdGlvbkRlbGF5KCkpXHJcbiAgICAgICAgICAgIC5zZWxlY3QoJ2NpcmNsZS4nICsgX2NoYXJ0LkJVQkJMRV9DTEFTUylcclxuICAgICAgICAgICAgLmF0dHIoJ3InLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jaGFydC5idWJibGVSKGQpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuYXR0cignb3BhY2l0eScsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKF9jaGFydC5idWJibGVSKGQpID4gMCkgPyAxIDogMDtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIF9jaGFydC5fZG9SZW5kZXJMYWJlbChidWJibGVHRW50ZXIpO1xyXG5cclxuICAgICAgICBfY2hhcnQuX2RvUmVuZGVyVGl0bGVzKGJ1YmJsZUdFbnRlcik7XHJcblxyXG4gICAgICAgIHJldHVybiBidWJibGVHO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZU5vZGVzIChidWJibGVHKSB7XHJcbiAgICAgICAgZGMudHJhbnNpdGlvbihidWJibGVHLCBfY2hhcnQudHJhbnNpdGlvbkR1cmF0aW9uKCksIF9jaGFydC50cmFuc2l0aW9uRGVsYXkoKSlcclxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGJ1YmJsZUxvY2F0b3IpXHJcbiAgICAgICAgICAgIC5zZWxlY3QoJ2NpcmNsZS4nICsgX2NoYXJ0LkJVQkJMRV9DTEFTUylcclxuICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCBfY2hhcnQuZ2V0Q29sb3IpXHJcbiAgICAgICAgICAgIC5hdHRyKCdyJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfY2hhcnQuYnViYmxlUihkKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmF0dHIoJ29wYWNpdHknLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChfY2hhcnQuYnViYmxlUihkKSA+IDApID8gMSA6IDA7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICBfY2hhcnQuZG9VcGRhdGVMYWJlbHMoYnViYmxlRyk7XHJcbiAgICAgICAgX2NoYXJ0LmRvVXBkYXRlVGl0bGVzKGJ1YmJsZUcpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlbW92ZU5vZGVzIChidWJibGVHKSB7XHJcbiAgICAgICAgYnViYmxlRy5leGl0KCkucmVtb3ZlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYnViYmxlWCAoZCkge1xyXG4gICAgICAgIHZhciB4ID0gX2NoYXJ0LngoKShfY2hhcnQua2V5QWNjZXNzb3IoKShkKSk7XHJcbiAgICAgICAgaWYgKGlzTmFOKHgpIHx8ICFpc0Zpbml0ZSh4KSkge1xyXG4gICAgICAgICAgICB4ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHg7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYnViYmxlWSAoZCkge1xyXG4gICAgICAgIHZhciB5ID0gX2NoYXJ0LnkoKShfY2hhcnQudmFsdWVBY2Nlc3NvcigpKGQpKTtcclxuICAgICAgICBpZiAoaXNOYU4oeSkgfHwgIWlzRmluaXRlKHkpKSB7XHJcbiAgICAgICAgICAgIHkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geTtcclxuICAgIH1cclxuXHJcbiAgICBfY2hhcnQucmVuZGVyQnJ1c2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gb3ZlcnJpZGUgZGVmYXVsdCB4IGF4aXMgYnJ1c2ggZnJvbSBwYXJlbnQgY2hhcnRcclxuICAgIH07XHJcblxyXG4gICAgX2NoYXJ0LnJlZHJhd0JydXNoID0gZnVuY3Rpb24gKGJydXNoU2VsZWN0aW9uLCBkb1RyYW5zaXRpb24pIHtcclxuICAgICAgICAvLyBvdmVycmlkZSBkZWZhdWx0IHggYXhpcyBicnVzaCBmcm9tIHBhcmVudCBjaGFydFxyXG4gICAgICAgIF9jaGFydC5mYWRlRGVzZWxlY3RlZEFyZWEoYnJ1c2hTZWxlY3Rpb24pO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gX2NoYXJ0LmFuY2hvcihwYXJlbnQsIGNoYXJ0R3JvdXApO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbXBvc2l0ZSBjaGFydHMgYXJlIGEgc3BlY2lhbCBraW5kIG9mIGNoYXJ0IHRoYXQgcmVuZGVyIG11bHRpcGxlIGNoYXJ0cyBvbiB0aGUgc2FtZSBDb29yZGluYXRlXHJcbiAqIEdyaWQuIFlvdSBjYW4gb3ZlcmxheSAoY29tcG9zZSkgZGlmZmVyZW50IGJhci9saW5lL2FyZWEgY2hhcnRzIGluIGEgc2luZ2xlIGNvbXBvc2l0ZSBjaGFydCB0b1xyXG4gKiBhY2hpZXZlIHNvbWUgcXVpdGUgZmxleGlibGUgY2hhcnRpbmcgZWZmZWN0cy5cclxuICogQGNsYXNzIGNvbXBvc2l0ZUNoYXJ0XHJcbiAqIEBtZW1iZXJvZiBkY1xyXG4gKiBAbWl4ZXMgZGMuY29vcmRpbmF0ZUdyaWRNaXhpblxyXG4gKiBAZXhhbXBsZVxyXG4gKiAvLyBjcmVhdGUgYSBjb21wb3NpdGUgY2hhcnQgdW5kZXIgI2NoYXJ0LWNvbnRhaW5lcjEgZWxlbWVudCB1c2luZyB0aGUgZGVmYXVsdCBnbG9iYWwgY2hhcnQgZ3JvdXBcclxuICogdmFyIGNvbXBvc2l0ZUNoYXJ0MSA9IGRjLmNvbXBvc2l0ZUNoYXJ0KCcjY2hhcnQtY29udGFpbmVyMScpO1xyXG4gKiAvLyBjcmVhdGUgYSBjb21wb3NpdGUgY2hhcnQgdW5kZXIgI2NoYXJ0LWNvbnRhaW5lcjIgZWxlbWVudCB1c2luZyBjaGFydCBncm91cCBBXHJcbiAqIHZhciBjb21wb3NpdGVDaGFydDIgPSBkYy5jb21wb3NpdGVDaGFydCgnI2NoYXJ0LWNvbnRhaW5lcjInLCAnY2hhcnRHcm91cEEnKTtcclxuICogQHBhcmFtIHtTdHJpbmd8bm9kZXxkMy5zZWxlY3Rpb259IHBhcmVudCAtIEFueSB2YWxpZFxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNlbGVjdGlvbi9ibG9iL21hc3Rlci9SRUFETUUubWQjc2VsZWN0IGQzIHNpbmdsZSBzZWxlY3Rvcn0gc3BlY2lmeWluZ1xyXG4gKiBhIGRvbSBibG9jayBlbGVtZW50IHN1Y2ggYXMgYSBkaXY7IG9yIGEgZG9tIGVsZW1lbnQgb3IgZDMgc2VsZWN0aW9uLlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gW2NoYXJ0R3JvdXBdIC0gVGhlIG5hbWUgb2YgdGhlIGNoYXJ0IGdyb3VwIHRoaXMgY2hhcnQgaW5zdGFuY2Ugc2hvdWxkIGJlIHBsYWNlZCBpbi5cclxuICogSW50ZXJhY3Rpb24gd2l0aCBhIGNoYXJ0IHdpbGwgb25seSB0cmlnZ2VyIGV2ZW50cyBhbmQgcmVkcmF3cyB3aXRoaW4gdGhlIGNoYXJ0J3MgZ3JvdXAuXHJcbiAqIEByZXR1cm5zIHtkYy5jb21wb3NpdGVDaGFydH1cclxuICovXHJcbmRjLmNvbXBvc2l0ZUNoYXJ0ID0gZnVuY3Rpb24gKHBhcmVudCwgY2hhcnRHcm91cCkge1xyXG5cclxuICAgIHZhciBTVUJfQ0hBUlRfQ0xBU1MgPSAnc3ViJztcclxuICAgIHZhciBERUZBVUxUX1JJR0hUX1lfQVhJU19MQUJFTF9QQURESU5HID0gMTI7XHJcblxyXG4gICAgdmFyIF9jaGFydCA9IGRjLmNvb3JkaW5hdGVHcmlkTWl4aW4oe30pO1xyXG4gICAgdmFyIF9jaGlsZHJlbiA9IFtdO1xyXG5cclxuICAgIHZhciBfY2hpbGRPcHRpb25zID0ge307XHJcblxyXG4gICAgdmFyIF9zaGFyZUNvbG9ycyA9IGZhbHNlLFxyXG4gICAgICAgIF9zaGFyZVRpdGxlID0gdHJ1ZSxcclxuICAgICAgICBfYWxpZ25ZQXhlcyA9IGZhbHNlO1xyXG5cclxuICAgIHZhciBfcmlnaHRZQXhpcyA9IGQzLmF4aXNSaWdodCgpLFxyXG4gICAgICAgIF9yaWdodFlBeGlzTGFiZWwgPSAwLFxyXG4gICAgICAgIF9yaWdodFlBeGlzTGFiZWxQYWRkaW5nID0gREVGQVVMVF9SSUdIVF9ZX0FYSVNfTEFCRUxfUEFERElORyxcclxuICAgICAgICBfcmlnaHRZLFxyXG4gICAgICAgIF9yaWdodEF4aXNHcmlkTGluZXMgPSBmYWxzZTtcclxuXHJcbiAgICBfY2hhcnQuX21hbmRhdG9yeUF0dHJpYnV0ZXMoW10pO1xyXG4gICAgX2NoYXJ0LnRyYW5zaXRpb25EdXJhdGlvbig1MDApO1xyXG4gICAgX2NoYXJ0LnRyYW5zaXRpb25EZWxheSgwKTtcclxuXHJcbiAgICBkYy5vdmVycmlkZShfY2hhcnQsICdfZ2VuZXJhdGVHJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBnID0gdGhpcy5fX2dlbmVyYXRlRygpO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9jaGlsZHJlbi5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBfY2hpbGRyZW5baV07XHJcblxyXG4gICAgICAgICAgICBnZW5lcmF0ZUNoaWxkRyhjaGlsZCwgaSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIWNoaWxkLmRpbWVuc2lvbigpKSB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZC5kaW1lbnNpb24oX2NoYXJ0LmRpbWVuc2lvbigpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWNoaWxkLmdyb3VwKCkpIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkLmdyb3VwKF9jaGFydC5ncm91cCgpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY2hpbGQuY2hhcnRHcm91cChfY2hhcnQuY2hhcnRHcm91cCgpKTtcclxuICAgICAgICAgICAgY2hpbGQuc3ZnKF9jaGFydC5zdmcoKSk7XHJcbiAgICAgICAgICAgIGNoaWxkLnhVbml0cyhfY2hhcnQueFVuaXRzKCkpO1xyXG4gICAgICAgICAgICBjaGlsZC50cmFuc2l0aW9uRHVyYXRpb24oX2NoYXJ0LnRyYW5zaXRpb25EdXJhdGlvbigpLCBfY2hhcnQudHJhbnNpdGlvbkRlbGF5KCkpO1xyXG4gICAgICAgICAgICBjaGlsZC5wYXJlbnRCcnVzaE9uKF9jaGFydC5icnVzaE9uKCkpO1xyXG4gICAgICAgICAgICBjaGlsZC5icnVzaE9uKGZhbHNlKTtcclxuICAgICAgICAgICAgY2hpbGQucmVuZGVyVGl0bGUoX2NoYXJ0LnJlbmRlclRpdGxlKCkpO1xyXG4gICAgICAgICAgICBjaGlsZC5lbGFzdGljWChfY2hhcnQuZWxhc3RpY1goKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZztcclxuICAgIH0pO1xyXG5cclxuICAgIF9jaGFydC5vbignZmlsdGVyZWQuZGNqcy1jb21wb3NpdGUtY2hhcnQnLCBmdW5jdGlvbiAoY2hhcnQpIHtcclxuICAgICAgICAvLyBQcm9wYWdhdGUgdGhlIGZpbHRlcnMgb250byB0aGUgY2hpbGRyZW5cclxuICAgICAgICAvLyBOb3RpY2UgdGhhdCBvbiBjaGlsZHJlbiB0aGUgY2FsbCBpcyAucmVwbGFjZUZpbHRlciBhbmQgbm90IC5maWx0ZXJcclxuICAgICAgICAvLyAgIHRoZSByZWFzb24gaXMgdGhhdCBfY2hhcnQuZmlsdGVyKCkgcmV0dXJucyB0aGUgZW50aXJlIGN1cnJlbnQgc2V0IG9mIGZpbHRlcnMgbm90IGp1c3QgdGhlIGxhc3QgYWRkZWQgb25lXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgX2NoaWxkcmVuW2ldLnJlcGxhY2VGaWx0ZXIoX2NoYXJ0LmZpbHRlcigpKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBfY2hhcnQuX3ByZXBhcmVZQXhpcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbGVmdCA9IChsZWZ0WUF4aXNDaGlsZHJlbigpLmxlbmd0aCAhPT0gMCk7XHJcbiAgICAgICAgdmFyIHJpZ2h0ID0gKHJpZ2h0WUF4aXNDaGlsZHJlbigpLmxlbmd0aCAhPT0gMCk7XHJcbiAgICAgICAgdmFyIHJhbmdlcyA9IGNhbGN1bGF0ZVlBeGlzUmFuZ2VzKGxlZnQsIHJpZ2h0KTtcclxuXHJcbiAgICAgICAgaWYgKGxlZnQpIHsgcHJlcGFyZUxlZnRZQXhpcyhyYW5nZXMpOyB9XHJcbiAgICAgICAgaWYgKHJpZ2h0KSB7IHByZXBhcmVSaWdodFlBeGlzKHJhbmdlcyk7IH1cclxuXHJcbiAgICAgICAgaWYgKGxlZnRZQXhpc0NoaWxkcmVuKCkubGVuZ3RoID4gMCAmJiAhX3JpZ2h0QXhpc0dyaWRMaW5lcykge1xyXG4gICAgICAgICAgICBfY2hhcnQuX3JlbmRlckhvcml6b250YWxHcmlkTGluZXNGb3JBeGlzKF9jaGFydC5nKCksIF9jaGFydC55KCksIF9jaGFydC55QXhpcygpKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHJpZ2h0WUF4aXNDaGlsZHJlbigpLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgX2NoYXJ0Ll9yZW5kZXJIb3Jpem9udGFsR3JpZExpbmVzRm9yQXhpcyhfY2hhcnQuZygpLCBfcmlnaHRZLCBfcmlnaHRZQXhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfY2hhcnQucmVuZGVyWUF4aXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKGxlZnRZQXhpc0NoaWxkcmVuKCkubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgICAgICAgIF9jaGFydC5yZW5kZXJZQXhpc0F0KCd5JywgX2NoYXJ0LnlBeGlzKCksIF9jaGFydC5tYXJnaW5zKCkubGVmdCk7XHJcbiAgICAgICAgICAgIF9jaGFydC5yZW5kZXJZQXhpc0xhYmVsKCd5JywgX2NoYXJ0LnlBeGlzTGFiZWwoKSwgLTkwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChyaWdodFlBeGlzQ2hpbGRyZW4oKS5sZW5ndGggIT09IDApIHtcclxuICAgICAgICAgICAgX2NoYXJ0LnJlbmRlcllBeGlzQXQoJ3lyJywgX2NoYXJ0LnJpZ2h0WUF4aXMoKSwgX2NoYXJ0LndpZHRoKCkgLSBfY2hhcnQubWFyZ2lucygpLnJpZ2h0KTtcclxuICAgICAgICAgICAgX2NoYXJ0LnJlbmRlcllBeGlzTGFiZWwoJ3lyJywgX2NoYXJ0LnJpZ2h0WUF4aXNMYWJlbCgpLCA5MCwgX2NoYXJ0LndpZHRoKCkgLSBfcmlnaHRZQXhpc0xhYmVsUGFkZGluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBjYWxjdWxhdGVZQXhpc1JhbmdlcyAobGVmdCwgcmlnaHQpIHtcclxuICAgICAgICB2YXIgbHlBeGlzTWluLCBseUF4aXNNYXgsIHJ5QXhpc01pbiwgcnlBeGlzTWF4O1xyXG4gICAgICAgIHZhciByYW5nZXM7XHJcblxyXG4gICAgICAgIGlmIChsZWZ0KSB7XHJcbiAgICAgICAgICAgIGx5QXhpc01pbiA9IHlBeGlzTWluKCk7XHJcbiAgICAgICAgICAgIGx5QXhpc01heCA9IHlBeGlzTWF4KCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocmlnaHQpIHtcclxuICAgICAgICAgICAgcnlBeGlzTWluID0gcmlnaHRZQXhpc01pbigpO1xyXG4gICAgICAgICAgICByeUF4aXNNYXggPSByaWdodFlBeGlzTWF4KCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoX2NoYXJ0LmFsaWduWUF4ZXMoKSAmJiBsZWZ0ICYmIHJpZ2h0KSB7XHJcbiAgICAgICAgICAgIHJhbmdlcyA9IGFsaWduWUF4aXNSYW5nZXMobHlBeGlzTWluLCBseUF4aXNNYXgsIHJ5QXhpc01pbiwgcnlBeGlzTWF4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByYW5nZXMgfHwge1xyXG4gICAgICAgICAgICBseUF4aXNNaW46IGx5QXhpc01pbixcclxuICAgICAgICAgICAgbHlBeGlzTWF4OiBseUF4aXNNYXgsXHJcbiAgICAgICAgICAgIHJ5QXhpc01pbjogcnlBeGlzTWluLFxyXG4gICAgICAgICAgICByeUF4aXNNYXg6IHJ5QXhpc01heFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYWxpZ25ZQXhpc1JhbmdlcyAobHlBeGlzTWluLCBseUF4aXNNYXgsIHJ5QXhpc01pbiwgcnlBeGlzTWF4KSB7XHJcbiAgICAgICAgLy8gc2luY2UgdGhlIHR3byBzZXJpZXMgd2lsbCBzaGFyZSBhIHplcm8sIGVhY2ggWSBpcyBqdXN0IGEgbXVsdGlwbGVcclxuICAgICAgICAvLyBvZiB0aGUgb3RoZXIuIGFuZCB0aGUgcmF0aW8gc2hvdWxkIGJlIHRoZSByYXRpbyBvZiB0aGUgcmFuZ2VzIG9mIHRoZVxyXG4gICAgICAgIC8vIGlucHV0IGRhdGEsIHNvIHRoYXQgdGhleSBjb21lIG91dCB0aGUgc2FtZSBoZWlnaHQuIHNvIHdlIGp1c3QgbWluL21heFxyXG5cclxuICAgICAgICAvLyBub3RlOiBib3RoIHJhbmdlcyBhbHJlYWR5IGluY2x1ZGUgemVybyBkdWUgdG8gdGhlIHN0YWNrIG1peGluICgjNjY3KVxyXG4gICAgICAgIC8vIGlmICM2NjcgY2hhbmdlcywgd2UgY2FuIHJlY29uc2lkZXIgd2hldGhlciB3ZSB3YW50IGRhdGEgaGVpZ2h0IG9yXHJcbiAgICAgICAgLy8gaGVpZ2h0IGZyb20gemVybyB0byBiZSBlcXVhbC4gYW5kIGl0IHdpbGwgYmUgcG9zc2libGUgZm9yIHRoZSBheGVzXHJcbiAgICAgICAgLy8gdG8gYmUgYWxpZ25lZCBidXQgbm90IHZpc2libGUuXHJcbiAgICAgICAgdmFyIGV4dGVudFJhdGlvID0gKHJ5QXhpc01heCAtIHJ5QXhpc01pbikgLyAobHlBeGlzTWF4IC0gbHlBeGlzTWluKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbHlBeGlzTWluOiBNYXRoLm1pbihseUF4aXNNaW4sIHJ5QXhpc01pbiAvIGV4dGVudFJhdGlvKSxcclxuICAgICAgICAgICAgbHlBeGlzTWF4OiBNYXRoLm1heChseUF4aXNNYXgsIHJ5QXhpc01heCAvIGV4dGVudFJhdGlvKSxcclxuICAgICAgICAgICAgcnlBeGlzTWluOiBNYXRoLm1pbihyeUF4aXNNaW4sIGx5QXhpc01pbiAqIGV4dGVudFJhdGlvKSxcclxuICAgICAgICAgICAgcnlBeGlzTWF4OiBNYXRoLm1heChyeUF4aXNNYXgsIGx5QXhpc01heCAqIGV4dGVudFJhdGlvKVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcHJlcGFyZVJpZ2h0WUF4aXMgKHJhbmdlcykge1xyXG4gICAgICAgIHZhciBuZWVkRG9tYWluID0gX2NoYXJ0LnJpZ2h0WSgpID09PSB1bmRlZmluZWQgfHwgX2NoYXJ0LmVsYXN0aWNZKCksXHJcbiAgICAgICAgICAgIG5lZWRSYW5nZSA9IG5lZWREb21haW4gfHwgX2NoYXJ0LnJlc2l6aW5nKCk7XHJcbiAgICAgICAgaWYgKF9jaGFydC5yaWdodFkoKSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIF9jaGFydC5yaWdodFkoZDMuc2NhbGVMaW5lYXIoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuZWVkRG9tYWluKSB7XHJcbiAgICAgICAgICAgIF9jaGFydC5yaWdodFkoKS5kb21haW4oW3Jhbmdlcy5yeUF4aXNNaW4sIHJhbmdlcy5yeUF4aXNNYXhdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5lZWRSYW5nZSkge1xyXG4gICAgICAgICAgICBfY2hhcnQucmlnaHRZKCkucmFuZ2VSb3VuZChbX2NoYXJ0LnlBeGlzSGVpZ2h0KCksIDBdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIF9jaGFydC5yaWdodFkoKS5yYW5nZShbX2NoYXJ0LnlBeGlzSGVpZ2h0KCksIDBdKTtcclxuICAgICAgICBfY2hhcnQucmlnaHRZQXhpcyhfY2hhcnQucmlnaHRZQXhpcygpLnNjYWxlKF9jaGFydC5yaWdodFkoKSkpO1xyXG5cclxuICAgICAgICAvLyBJbiBEM3Y0IGNyZWF0ZSBhIFJpZ2h0QXhpc1xyXG4gICAgICAgIC8vIF9jaGFydC5yaWdodFlBeGlzKCkub3JpZW50KCdyaWdodCcpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHByZXBhcmVMZWZ0WUF4aXMgKHJhbmdlcykge1xyXG4gICAgICAgIHZhciBuZWVkRG9tYWluID0gX2NoYXJ0LnkoKSA9PT0gdW5kZWZpbmVkIHx8IF9jaGFydC5lbGFzdGljWSgpLFxyXG4gICAgICAgICAgICBuZWVkUmFuZ2UgPSBuZWVkRG9tYWluIHx8IF9jaGFydC5yZXNpemluZygpO1xyXG4gICAgICAgIGlmIChfY2hhcnQueSgpID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgX2NoYXJ0LnkoZDMuc2NhbGVMaW5lYXIoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuZWVkRG9tYWluKSB7XHJcbiAgICAgICAgICAgIF9jaGFydC55KCkuZG9tYWluKFtyYW5nZXMubHlBeGlzTWluLCByYW5nZXMubHlBeGlzTWF4XSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuZWVkUmFuZ2UpIHtcclxuICAgICAgICAgICAgX2NoYXJ0LnkoKS5yYW5nZVJvdW5kKFtfY2hhcnQueUF4aXNIZWlnaHQoKSwgMF0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgX2NoYXJ0LnkoKS5yYW5nZShbX2NoYXJ0LnlBeGlzSGVpZ2h0KCksIDBdKTtcclxuICAgICAgICBfY2hhcnQueUF4aXMoX2NoYXJ0LnlBeGlzKCkuc2NhbGUoX2NoYXJ0LnkoKSkpO1xyXG5cclxuICAgICAgICAvLyBJbiBEM3Y0IGNyZWF0ZSBhIExlZnRBeGlzXHJcbiAgICAgICAgLy8gX2NoYXJ0LnlBeGlzKCkub3JpZW50KCdsZWZ0Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVDaGlsZEcgKGNoaWxkLCBpKSB7XHJcbiAgICAgICAgY2hpbGQuX2dlbmVyYXRlRyhfY2hhcnQuZygpKTtcclxuICAgICAgICBjaGlsZC5nKCkuYXR0cignY2xhc3MnLCBTVUJfQ0hBUlRfQ0xBU1MgKyAnIF8nICsgaSk7XHJcbiAgICB9XHJcblxyXG4gICAgX2NoYXJ0LnBsb3REYXRhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX2NoaWxkcmVuLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IF9jaGlsZHJlbltpXTtcclxuXHJcbiAgICAgICAgICAgIGlmICghY2hpbGQuZygpKSB7XHJcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZUNoaWxkRyhjaGlsZCwgaSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChfc2hhcmVDb2xvcnMpIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkLmNvbG9ycyhfY2hhcnQuY29sb3JzKCkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjaGlsZC54KF9jaGFydC54KCkpO1xyXG5cclxuICAgICAgICAgICAgY2hpbGQueEF4aXMoX2NoYXJ0LnhBeGlzKCkpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGNoaWxkLnVzZVJpZ2h0WUF4aXMoKSkge1xyXG4gICAgICAgICAgICAgICAgY2hpbGQueShfY2hhcnQucmlnaHRZKCkpO1xyXG4gICAgICAgICAgICAgICAgY2hpbGQueUF4aXMoX2NoYXJ0LnJpZ2h0WUF4aXMoKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZC55KF9jaGFydC55KCkpO1xyXG4gICAgICAgICAgICAgICAgY2hpbGQueUF4aXMoX2NoYXJ0LnlBeGlzKCkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjaGlsZC5wbG90RGF0YSgpO1xyXG5cclxuICAgICAgICAgICAgY2hpbGQuX2FjdGl2YXRlUmVuZGVybGV0cygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgb3Igc2V0IHdoZXRoZXIgdG8gZHJhdyBncmlkbGluZXMgZnJvbSB0aGUgcmlnaHQgeSBheGlzLiAgRHJhd2luZyBmcm9tIHRoZSBsZWZ0IHkgYXhpcyBpcyB0aGVcclxuICAgICAqIGRlZmF1bHQgYmVoYXZpb3IuIFRoaXMgb3B0aW9uIGlzIG9ubHkgcmVzcGVjdGVkIHdoZW4gc3ViY2hhcnRzIHdpdGggYm90aCBsZWZ0IGFuZCByaWdodCB5LWF4ZXNcclxuICAgICAqIGFyZSBwcmVzZW50LlxyXG4gICAgICogQG1ldGhvZCB1c2VSaWdodEF4aXNHcmlkTGluZXNcclxuICAgICAqIEBtZW1iZXJvZiBkYy5jb21wb3NpdGVDaGFydFxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFt1c2VSaWdodEF4aXNHcmlkTGluZXM9ZmFsc2VdXHJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbnxkYy5jb21wb3NpdGVDaGFydH1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LnVzZVJpZ2h0QXhpc0dyaWRMaW5lcyA9IGZ1bmN0aW9uICh1c2VSaWdodEF4aXNHcmlkTGluZXMpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cykge1xyXG4gICAgICAgICAgICByZXR1cm4gX3JpZ2h0QXhpc0dyaWRMaW5lcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIF9yaWdodEF4aXNHcmlkTGluZXMgPSB1c2VSaWdodEF4aXNHcmlkTGluZXM7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgb3Igc2V0IGNoYXJ0LXNwZWNpZmljIG9wdGlvbnMgZm9yIGFsbCBjaGlsZCBjaGFydHMuIFRoaXMgaXMgZXF1aXZhbGVudCB0byBjYWxsaW5nXHJcbiAgICAgKiB7QGxpbmsgZGMuYmFzZU1peGluI29wdGlvbnMgLm9wdGlvbnN9IG9uIGVhY2ggY2hpbGQgY2hhcnQuXHJcbiAgICAgKlxyXG4gICAgICogTm90ZTogY3VycmVudGx5IHlvdSBtdXN0IGNhbGwgdGhpcyBiZWZvcmUgYGNvbXBvc2VgIGluIG9yZGVyIGZvciB0aGUgb3B0aW9ucyB0byBiZSBwcm9wYWdhdGVkLlxyXG4gICAgICogQG1ldGhvZCBjaGlsZE9wdGlvbnNcclxuICAgICAqIEBtZW1iZXJvZiBkYy5jb21wb3NpdGVDaGFydFxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NoaWxkT3B0aW9uc11cclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8ZGMuY29tcG9zaXRlQ2hhcnR9XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5jaGlsZE9wdGlvbnMgPSBmdW5jdGlvbiAoY2hpbGRPcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfY2hpbGRPcHRpb25zO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfY2hpbGRPcHRpb25zID0gY2hpbGRPcHRpb25zO1xyXG4gICAgICAgIF9jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgICAgICBjaGlsZC5vcHRpb25zKF9jaGlsZE9wdGlvbnMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF9jaGFydC5mYWRlRGVzZWxlY3RlZEFyZWEgPSBmdW5jdGlvbiAoYnJ1c2hTZWxlY3Rpb24pIHtcclxuICAgICAgICBpZiAoX2NoYXJ0LmJydXNoT24oKSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9jaGlsZHJlbi5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gX2NoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICAgICAgY2hpbGQuZmFkZURlc2VsZWN0ZWRBcmVhKGJydXNoU2VsZWN0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgb3IgZ2V0IHRoZSByaWdodCB5IGF4aXMgbGFiZWwuXHJcbiAgICAgKiBAbWV0aG9kIHJpZ2h0WUF4aXNMYWJlbFxyXG4gICAgICogQG1lbWJlcm9mIGRjLmNvbXBvc2l0ZUNoYXJ0XHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbcmlnaHRZQXhpc0xhYmVsXVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYWRkaW5nXVxyXG4gICAgICogQHJldHVybnMge1N0cmluZ3xkYy5jb21wb3NpdGVDaGFydH1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LnJpZ2h0WUF4aXNMYWJlbCA9IGZ1bmN0aW9uIChyaWdodFlBeGlzTGFiZWwsIHBhZGRpbmcpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9yaWdodFlBeGlzTGFiZWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9yaWdodFlBeGlzTGFiZWwgPSByaWdodFlBeGlzTGFiZWw7XHJcbiAgICAgICAgX2NoYXJ0Lm1hcmdpbnMoKS5yaWdodCAtPSBfcmlnaHRZQXhpc0xhYmVsUGFkZGluZztcclxuICAgICAgICBfcmlnaHRZQXhpc0xhYmVsUGFkZGluZyA9IChwYWRkaW5nID09PSB1bmRlZmluZWQpID8gREVGQVVMVF9SSUdIVF9ZX0FYSVNfTEFCRUxfUEFERElORyA6IHBhZGRpbmc7XHJcbiAgICAgICAgX2NoYXJ0Lm1hcmdpbnMoKS5yaWdodCArPSBfcmlnaHRZQXhpc0xhYmVsUGFkZGluZztcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbWJpbmUgdGhlIGdpdmVuIGNoYXJ0cyBpbnRvIG9uZSBzaW5nbGUgY29tcG9zaXRlIGNvb3JkaW5hdGUgZ3JpZCBjaGFydC5cclxuICAgICAqXHJcbiAgICAgKiBOb3RlOiBjdXJyZW50bHkgZHVlIHRvIHRoZSB3YXkgaXQgaXMgaW1wbGVtZW50ZWQsIHlvdSBtdXN0IGNhbGwgdGhpcyBmdW5jdGlvbiBhdCB0aGUgZW5kIG9mXHJcbiAgICAgKiBpbml0aWFsaXphdGlvbiBvZiB0aGUgY29tcG9zaXRlIGNoYXJ0LCBpbiBwYXJ0aWN1bGFyIGFmdGVyIGBzaGFyZVRpdGxlYCwgYGNoaWxkT3B0aW9uc2AsXHJcbiAgICAgKiBgd2lkdGhgLCBgaGVpZ2h0YCwgYW5kIGBtYXJnaW5zYCwgaW4gb3JkZXIgZm9yIHRoZSBzZXR0aW5ncyB0byBnZXQgcHJvcGFnYXRlZCB0byB0aGUgY2hpbGRyZW5cclxuICAgICAqIGNvcnJlY3RseS5cclxuICAgICAqIEBtZXRob2QgY29tcG9zZVxyXG4gICAgICogQG1lbWJlcm9mIGRjLmNvbXBvc2l0ZUNoYXJ0XHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBtb3ZlQ2hhcnQuY29tcG9zZShbXHJcbiAgICAgKiAgICAgLy8gd2hlbiBjcmVhdGluZyBzdWItY2hhcnQgeW91IG5lZWQgdG8gcGFzcyBpbiB0aGUgcGFyZW50IGNoYXJ0XHJcbiAgICAgKiAgICAgZGMubGluZUNoYXJ0KG1vdmVDaGFydClcclxuICAgICAqICAgICAgICAgLmdyb3VwKGluZGV4QXZnQnlNb250aEdyb3VwKSAvLyBpZiBncm91cCBpcyBtaXNzaW5nIHRoZW4gcGFyZW50J3MgZ3JvdXAgd2lsbCBiZSB1c2VkXHJcbiAgICAgKiAgICAgICAgIC52YWx1ZUFjY2Vzc29yKGZ1bmN0aW9uIChkKXtyZXR1cm4gZC52YWx1ZS5hdmc7fSlcclxuICAgICAqICAgICAgICAgLy8gbW9zdCBvZiB0aGUgbm9ybWFsIGZ1bmN0aW9ucyB3aWxsIGNvbnRpbnVlIHRvIHdvcmsgaW4gYSBjb21wb3NlZCBjaGFydFxyXG4gICAgICogICAgICAgICAucmVuZGVyQXJlYSh0cnVlKVxyXG4gICAgICogICAgICAgICAuc3RhY2sobW9udGhseU1vdmVHcm91cCwgZnVuY3Rpb24gKGQpe3JldHVybiBkLnZhbHVlO30pXHJcbiAgICAgKiAgICAgICAgIC50aXRsZShmdW5jdGlvbiAoZCl7XHJcbiAgICAgKiAgICAgICAgICAgICB2YXIgdmFsdWUgPSBkLnZhbHVlLmF2Zz9kLnZhbHVlLmF2ZzpkLnZhbHVlO1xyXG4gICAgICogICAgICAgICAgICAgaWYoaXNOYU4odmFsdWUpKSB2YWx1ZSA9IDA7XHJcbiAgICAgKiAgICAgICAgICAgICByZXR1cm4gZGF0ZUZvcm1hdChkLmtleSkgKyAnXFxuJyArIG51bWJlckZvcm1hdCh2YWx1ZSk7XHJcbiAgICAgKiAgICAgICAgIH0pLFxyXG4gICAgICogICAgIGRjLmJhckNoYXJ0KG1vdmVDaGFydClcclxuICAgICAqICAgICAgICAgLmdyb3VwKHZvbHVtZUJ5TW9udGhHcm91cClcclxuICAgICAqICAgICAgICAgLmNlbnRlckJhcih0cnVlKVxyXG4gICAgICogXSk7XHJcbiAgICAgKiBAcGFyYW0ge0FycmF5PENoYXJ0Pn0gW3N1YkNoYXJ0QXJyYXldXHJcbiAgICAgKiBAcmV0dXJucyB7ZGMuY29tcG9zaXRlQ2hhcnR9XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5jb21wb3NlID0gZnVuY3Rpb24gKHN1YkNoYXJ0QXJyYXkpIHtcclxuICAgICAgICBfY2hpbGRyZW4gPSBzdWJDaGFydEFycmF5O1xyXG4gICAgICAgIF9jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgICAgICBjaGlsZC5oZWlnaHQoX2NoYXJ0LmhlaWdodCgpKTtcclxuICAgICAgICAgICAgY2hpbGQud2lkdGgoX2NoYXJ0LndpZHRoKCkpO1xyXG4gICAgICAgICAgICBjaGlsZC5tYXJnaW5zKF9jaGFydC5tYXJnaW5zKCkpO1xyXG5cclxuICAgICAgICAgICAgaWYgKF9zaGFyZVRpdGxlKSB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZC50aXRsZShfY2hhcnQudGl0bGUoKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNoaWxkLm9wdGlvbnMoX2NoaWxkT3B0aW9ucyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjaGlsZCBjaGFydHMgd2hpY2ggYXJlIGNvbXBvc2VkIGludG8gdGhlIGNvbXBvc2l0ZSBjaGFydC5cclxuICAgICAqIEBtZXRob2QgY2hpbGRyZW5cclxuICAgICAqIEBtZW1iZXJvZiBkYy5jb21wb3NpdGVDaGFydFxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8ZGMuYmFzZU1peGluPn1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LmNoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfY2hpbGRyZW47XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IG9yIHNldCBjb2xvciBzaGFyaW5nIGZvciB0aGUgY2hhcnQuIElmIHNldCwgdGhlIHtAbGluayBkYy5jb2xvck1peGluI2NvbG9ycyAuY29sb3JzKCl9IHZhbHVlIGZyb20gdGhpcyBjaGFydFxyXG4gICAgICogd2lsbCBiZSBzaGFyZWQgd2l0aCBjb21wb3NlZCBjaGlsZHJlbi4gQWRkaXRpb25hbGx5IGlmIHRoZSBjaGlsZCBjaGFydCBpbXBsZW1lbnRzXHJcbiAgICAgKiBTdGFja2FibGUgYW5kIGhhcyBub3Qgc2V0IGEgY3VzdG9tIC5jb2xvckFjY2Vzc29yLCB0aGVuIGl0IHdpbGwgZ2VuZXJhdGUgYSBjb2xvclxyXG4gICAgICogc3BlY2lmaWMgdG8gaXRzIG9yZGVyIGluIHRoZSBjb21wb3NpdGlvbi5cclxuICAgICAqIEBtZXRob2Qgc2hhcmVDb2xvcnNcclxuICAgICAqIEBtZW1iZXJvZiBkYy5jb21wb3NpdGVDaGFydFxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaGFyZUNvbG9ycz1mYWxzZV1cclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufGRjLmNvbXBvc2l0ZUNoYXJ0fVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQuc2hhcmVDb2xvcnMgPSBmdW5jdGlvbiAoc2hhcmVDb2xvcnMpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9zaGFyZUNvbG9ycztcclxuICAgICAgICB9XHJcbiAgICAgICAgX3NoYXJlQ29sb3JzID0gc2hhcmVDb2xvcnM7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgb3Igc2V0IHRpdGxlIHNoYXJpbmcgZm9yIHRoZSBjaGFydC4gSWYgc2V0LCB0aGUge0BsaW5rIGRjLmJhc2VNaXhpbiN0aXRsZSAudGl0bGUoKX0gdmFsdWUgZnJvbVxyXG4gICAgICogdGhpcyBjaGFydCB3aWxsIGJlIHNoYXJlZCB3aXRoIGNvbXBvc2VkIGNoaWxkcmVuLlxyXG4gICAgICpcclxuICAgICAqIE5vdGU6IGN1cnJlbnRseSB5b3UgbXVzdCBjYWxsIHRoaXMgYmVmb3JlIGBjb21wb3NlYCBvciB0aGUgY2hpbGQgd2lsbCBzdGlsbCBnZXQgdGhlIHBhcmVudCdzXHJcbiAgICAgKiBgdGl0bGVgIGZ1bmN0aW9uIVxyXG4gICAgICogQG1ldGhvZCBzaGFyZVRpdGxlXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuY29tcG9zaXRlQ2hhcnRcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2hhcmVUaXRsZT10cnVlXVxyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW58ZGMuY29tcG9zaXRlQ2hhcnR9XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5zaGFyZVRpdGxlID0gZnVuY3Rpb24gKHNoYXJlVGl0bGUpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9zaGFyZVRpdGxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfc2hhcmVUaXRsZSA9IHNoYXJlVGl0bGU7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgb3Igc2V0IHRoZSB5IHNjYWxlIGZvciB0aGUgcmlnaHQgYXhpcy4gVGhlIHJpZ2h0IHkgc2NhbGUgaXMgdHlwaWNhbGx5IGF1dG9tYXRpY2FsbHlcclxuICAgICAqIGdlbmVyYXRlZCBieSB0aGUgY2hhcnQgaW1wbGVtZW50YXRpb24uXHJcbiAgICAgKiBAbWV0aG9kIHJpZ2h0WVxyXG4gICAgICogQG1lbWJlcm9mIGRjLmNvbXBvc2l0ZUNoYXJ0XHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1zY2FsZS9ibG9iL21hc3Rlci9SRUFETUUubWQgZDMuc2NhbGV9XHJcbiAgICAgKiBAcGFyYW0ge2QzLnNjYWxlfSBbeVNjYWxlXVxyXG4gICAgICogQHJldHVybnMge2QzLnNjYWxlfGRjLmNvbXBvc2l0ZUNoYXJ0fVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQucmlnaHRZID0gZnVuY3Rpb24gKHlTY2FsZSkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3JpZ2h0WTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3JpZ2h0WSA9IHlTY2FsZTtcclxuICAgICAgICBfY2hhcnQucmVzY2FsZSgpO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IG9yIHNldCBhbGlnbm1lbnQgYmV0d2VlbiBsZWZ0IGFuZCByaWdodCB5IGF4ZXMuIEEgbGluZSBjb25uZWN0aW5nICcwJyBvbiBib3RoIHkgYXhpc1xyXG4gICAgICogd2lsbCBiZSBwYXJhbGxlbCB0byB4IGF4aXMuIFRoaXMgb25seSBoYXMgZWZmZWN0IHdoZW4ge0BsaW5rICNkYy5jb29yZGluYXRlR3JpZE1peGluK2VsYXN0aWNZIGVsYXN0aWNZfSBpcyB0cnVlLlxyXG4gICAgICogQG1ldGhvZCBhbGlnbllBeGVzXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuY29tcG9zaXRlQ2hhcnRcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYWxpZ25ZQXhlcz1mYWxzZV1cclxuICAgICAqIEByZXR1cm5zIHtDaGFydH1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LmFsaWduWUF4ZXMgPSBmdW5jdGlvbiAoYWxpZ25ZQXhlcykge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2FsaWduWUF4ZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9hbGlnbllBeGVzID0gYWxpZ25ZQXhlcztcclxuICAgICAgICBfY2hhcnQucmVzY2FsZSgpO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGxlZnRZQXhpc0NoaWxkcmVuICgpIHtcclxuICAgICAgICByZXR1cm4gX2NoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuICFjaGlsZC51c2VSaWdodFlBeGlzKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmlnaHRZQXhpc0NoaWxkcmVuICgpIHtcclxuICAgICAgICByZXR1cm4gX2NoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNoaWxkLnVzZVJpZ2h0WUF4aXMoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRZQXhpc01pbiAoY2hhcnRzKSB7XHJcbiAgICAgICAgcmV0dXJuIGNoYXJ0cy5tYXAoZnVuY3Rpb24gKGMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGMueUF4aXNNaW4oKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBkZWxldGUgX2NoYXJ0LnlBeGlzTWluO1xyXG4gICAgZnVuY3Rpb24geUF4aXNNaW4gKCkge1xyXG4gICAgICAgIHJldHVybiBkMy5taW4oZ2V0WUF4aXNNaW4obGVmdFlBeGlzQ2hpbGRyZW4oKSkpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJpZ2h0WUF4aXNNaW4gKCkge1xyXG4gICAgICAgIHJldHVybiBkMy5taW4oZ2V0WUF4aXNNaW4ocmlnaHRZQXhpc0NoaWxkcmVuKCkpKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRZQXhpc01heCAoY2hhcnRzKSB7XHJcbiAgICAgICAgcmV0dXJuIGNoYXJ0cy5tYXAoZnVuY3Rpb24gKGMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGMueUF4aXNNYXgoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBkZWxldGUgX2NoYXJ0LnlBeGlzTWF4O1xyXG4gICAgZnVuY3Rpb24geUF4aXNNYXggKCkge1xyXG4gICAgICAgIHJldHVybiBkYy51dGlscy5hZGQoZDMubWF4KGdldFlBeGlzTWF4KGxlZnRZQXhpc0NoaWxkcmVuKCkpKSwgX2NoYXJ0LnlBeGlzUGFkZGluZygpKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByaWdodFlBeGlzTWF4ICgpIHtcclxuICAgICAgICByZXR1cm4gZGMudXRpbHMuYWRkKGQzLm1heChnZXRZQXhpc01heChyaWdodFlBeGlzQ2hpbGRyZW4oKSkpLCBfY2hhcnQueUF4aXNQYWRkaW5nKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldEFsbFhBeGlzTWluRnJvbUNoaWxkQ2hhcnRzICgpIHtcclxuICAgICAgICByZXR1cm4gX2NoaWxkcmVuLm1hcChmdW5jdGlvbiAoYykge1xyXG4gICAgICAgICAgICByZXR1cm4gYy54QXhpc01pbigpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGRjLm92ZXJyaWRlKF9jaGFydCwgJ3hBeGlzTWluJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBkYy51dGlscy5zdWJ0cmFjdChkMy5taW4oZ2V0QWxsWEF4aXNNaW5Gcm9tQ2hpbGRDaGFydHMoKSksIF9jaGFydC54QXhpc1BhZGRpbmcoKSwgX2NoYXJ0LnhBeGlzUGFkZGluZ1VuaXQoKSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBmdW5jdGlvbiBnZXRBbGxYQXhpc01heEZyb21DaGlsZENoYXJ0cyAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGMueEF4aXNNYXgoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBkYy5vdmVycmlkZShfY2hhcnQsICd4QXhpc01heCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gZGMudXRpbHMuYWRkKGQzLm1heChnZXRBbGxYQXhpc01heEZyb21DaGlsZENoYXJ0cygpKSwgX2NoYXJ0LnhBeGlzUGFkZGluZygpLCBfY2hhcnQueEF4aXNQYWRkaW5nVW5pdCgpKTtcclxuICAgIH0pO1xyXG5cclxuICAgIF9jaGFydC5sZWdlbmRhYmxlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX2NoaWxkcmVuLnJlZHVjZShmdW5jdGlvbiAoaXRlbXMsIGNoaWxkKSB7XHJcbiAgICAgICAgICAgIGlmIChfc2hhcmVDb2xvcnMpIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkLmNvbG9ycyhfY2hhcnQuY29sb3JzKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGl0ZW1zLnB1c2guYXBwbHkoaXRlbXMsIGNoaWxkLmxlZ2VuZGFibGVzKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gaXRlbXM7XHJcbiAgICAgICAgfSwgW10pO1xyXG4gICAgfTtcclxuXHJcbiAgICBfY2hhcnQubGVnZW5kSGlnaGxpZ2h0ID0gZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IF9jaGlsZHJlbi5sZW5ndGg7ICsraikge1xyXG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBfY2hpbGRyZW5bal07XHJcbiAgICAgICAgICAgIGNoaWxkLmxlZ2VuZEhpZ2hsaWdodChkKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9jaGFydC5sZWdlbmRSZXNldCA9IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBfY2hpbGRyZW4ubGVuZ3RoOyArK2opIHtcclxuICAgICAgICAgICAgdmFyIGNoaWxkID0gX2NoaWxkcmVuW2pdO1xyXG4gICAgICAgICAgICBjaGlsZC5sZWdlbmRSZXNldChkKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9jaGFydC5sZWdlbmRUb2dnbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ2NvbXBvc2l0ZSBzaG91bGQgbm90IGJlIGdldHRpbmcgbGVnZW5kVG9nZ2xlIGl0c2VsZicpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBvciBnZXQgdGhlIHJpZ2h0IHkgYXhpcyB1c2VkIGJ5IHRoZSBjb21wb3NpdGUgY2hhcnQuIFRoaXMgZnVuY3Rpb24gaXMgbW9zdCB1c2VmdWwgd2hlbiB5XHJcbiAgICAgKiBheGlzIGN1c3RvbWl6YXRpb24gaXMgcmVxdWlyZWQuIFRoZSB5IGF4aXMgaW4gZGMuanMgaXMgYW4gaW5zdGFuY2Ugb2YgYVxyXG4gICAgICogW2QzLmF4aXNSaWdodF0oaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLWF4aXMvYmxvYi9tYXN0ZXIvUkVBRE1FLm1kI2F4aXNSaWdodCkgdGhlcmVmb3JlIGl0IHN1cHBvcnRzIGFueSB2YWxpZFxyXG4gICAgICogZDMgYXhpcyBtYW5pcHVsYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogKipDYXV0aW9uKio6IFRoZSByaWdodCB5IGF4aXMgaXMgdXN1YWxseSBnZW5lcmF0ZWQgaW50ZXJuYWxseSBieSBkYzsgcmVzZXR0aW5nIGl0IG1heSBjYXVzZVxyXG4gICAgICogdW5leHBlY3RlZCByZXN1bHRzLiAgTm90ZSBhbHNvIHRoYXQgd2hlbiB1c2VkIGFzIGEgZ2V0dGVyLCB0aGlzIGZ1bmN0aW9uIGlzIG5vdCBjaGFpbmFibGU6IGl0XHJcbiAgICAgKiByZXR1cm5zIHRoZSBheGlzLCBub3QgdGhlIGNoYXJ0LFxyXG4gICAgICoge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9kYy1qcy9kYy5qcy93aWtpL0ZBUSN3aHktZG9lcy1ldmVyeXRoaW5nLWJyZWFrLWFmdGVyLWEtY2FsbC10by14YXhpcy1vci15YXhpc1xyXG4gICAgICogc28gYXR0ZW1wdGluZyB0byBjYWxsIGNoYXJ0IGZ1bmN0aW9ucyBhZnRlciBjYWxsaW5nIGAueUF4aXMoKWAgd2lsbCBmYWlsfS5cclxuICAgICAqIEBtZXRob2QgcmlnaHRZQXhpc1xyXG4gICAgICogQG1lbWJlcm9mIGRjLmNvbXBvc2l0ZUNoYXJ0XHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1heGlzL2Jsb2IvbWFzdGVyL1JFQURNRS5tZCNheGlzUmlnaHR9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gY3VzdG9taXplIHkgYXhpcyB0aWNrIGZvcm1hdFxyXG4gICAgICogY2hhcnQucmlnaHRZQXhpcygpLnRpY2tGb3JtYXQoZnVuY3Rpb24gKHYpIHtyZXR1cm4gdiArICclJzt9KTtcclxuICAgICAqIC8vIGN1c3RvbWl6ZSB5IGF4aXMgdGljayB2YWx1ZXNcclxuICAgICAqIGNoYXJ0LnJpZ2h0WUF4aXMoKS50aWNrVmFsdWVzKFswLCAxMDAsIDIwMCwgMzAwXSk7XHJcbiAgICAgKiBAcGFyYW0ge2QzLmF4aXNSaWdodH0gW3JpZ2h0WUF4aXNdXHJcbiAgICAgKiBAcmV0dXJucyB7ZDMuYXhpc1JpZ2h0fGRjLmNvbXBvc2l0ZUNoYXJ0fVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQucmlnaHRZQXhpcyA9IGZ1bmN0aW9uIChyaWdodFlBeGlzKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfcmlnaHRZQXhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgX3JpZ2h0WUF4aXMgPSByaWdodFlBeGlzO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBfY2hhcnQuYW5jaG9yKHBhcmVudCwgY2hhcnRHcm91cCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQSBzZXJpZXMgY2hhcnQgaXMgYSBjaGFydCB0aGF0IHNob3dzIG11bHRpcGxlIHNlcmllcyBvZiBkYXRhIG92ZXJsYWlkIG9uIG9uZSBjaGFydCwgd2hlcmUgdGhlXHJcbiAqIHNlcmllcyBpcyBzcGVjaWZpZWQgaW4gdGhlIGRhdGEuIEl0IGlzIGEgc3BlY2lhbGl6YXRpb24gb2YgQ29tcG9zaXRlIENoYXJ0IGFuZCBpbmhlcml0cyBhbGxcclxuICogY29tcG9zaXRlIGZlYXR1cmVzIG90aGVyIHRoYW4gcmVjb21wb3NpbmcgdGhlIGNoYXJ0LlxyXG4gKlxyXG4gKiBFeGFtcGxlczpcclxuICogLSB7QGxpbmsgaHR0cDovL2RjLWpzLmdpdGh1Yi5pby9kYy5qcy9leGFtcGxlcy9zZXJpZXMuaHRtbCBTZXJpZXMgQ2hhcnR9XHJcbiAqIEBjbGFzcyBzZXJpZXNDaGFydFxyXG4gKiBAbWVtYmVyb2YgZGNcclxuICogQG1peGVzIGRjLmNvbXBvc2l0ZUNoYXJ0XHJcbiAqIEBleGFtcGxlXHJcbiAqIC8vIGNyZWF0ZSBhIHNlcmllcyBjaGFydCB1bmRlciAjY2hhcnQtY29udGFpbmVyMSBlbGVtZW50IHVzaW5nIHRoZSBkZWZhdWx0IGdsb2JhbCBjaGFydCBncm91cFxyXG4gKiB2YXIgc2VyaWVzQ2hhcnQxID0gZGMuc2VyaWVzQ2hhcnQoXCIjY2hhcnQtY29udGFpbmVyMVwiKTtcclxuICogLy8gY3JlYXRlIGEgc2VyaWVzIGNoYXJ0IHVuZGVyICNjaGFydC1jb250YWluZXIyIGVsZW1lbnQgdXNpbmcgY2hhcnQgZ3JvdXAgQVxyXG4gKiB2YXIgc2VyaWVzQ2hhcnQyID0gZGMuc2VyaWVzQ2hhcnQoXCIjY2hhcnQtY29udGFpbmVyMlwiLCBcImNoYXJ0R3JvdXBBXCIpO1xyXG4gKiBAcGFyYW0ge1N0cmluZ3xub2RlfGQzLnNlbGVjdGlvbn0gcGFyZW50IC0gQW55IHZhbGlkXHJcbiAqIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2VsZWN0aW9uL2Jsb2IvbWFzdGVyL1JFQURNRS5tZCNzZWxlY3QgZDMgc2luZ2xlIHNlbGVjdG9yfSBzcGVjaWZ5aW5nXHJcbiAqIGEgZG9tIGJsb2NrIGVsZW1lbnQgc3VjaCBhcyBhIGRpdjsgb3IgYSBkb20gZWxlbWVudCBvciBkMyBzZWxlY3Rpb24uXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbY2hhcnRHcm91cF0gLSBUaGUgbmFtZSBvZiB0aGUgY2hhcnQgZ3JvdXAgdGhpcyBjaGFydCBpbnN0YW5jZSBzaG91bGQgYmUgcGxhY2VkIGluLlxyXG4gKiBJbnRlcmFjdGlvbiB3aXRoIGEgY2hhcnQgd2lsbCBvbmx5IHRyaWdnZXIgZXZlbnRzIGFuZCByZWRyYXdzIHdpdGhpbiB0aGUgY2hhcnQncyBncm91cC5cclxuICogQHJldHVybnMge2RjLnNlcmllc0NoYXJ0fVxyXG4gKi9cclxuZGMuc2VyaWVzQ2hhcnQgPSBmdW5jdGlvbiAocGFyZW50LCBjaGFydEdyb3VwKSB7XHJcbiAgICB2YXIgX2NoYXJ0ID0gZGMuY29tcG9zaXRlQ2hhcnQocGFyZW50LCBjaGFydEdyb3VwKTtcclxuXHJcbiAgICBmdW5jdGlvbiBrZXlTb3J0IChhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIGQzLmFzY2VuZGluZyhfY2hhcnQua2V5QWNjZXNzb3IoKShhKSwgX2NoYXJ0LmtleUFjY2Vzc29yKCkoYikpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBfY2hhcnRzID0ge307XHJcbiAgICB2YXIgX2NoYXJ0RnVuY3Rpb24gPSBkYy5saW5lQ2hhcnQ7XHJcbiAgICB2YXIgX3Nlcmllc0FjY2Vzc29yO1xyXG4gICAgdmFyIF9zZXJpZXNTb3J0ID0gZDMuYXNjZW5kaW5nO1xyXG4gICAgdmFyIF92YWx1ZVNvcnQgPSBrZXlTb3J0O1xyXG5cclxuICAgIF9jaGFydC5fbWFuZGF0b3J5QXR0cmlidXRlcygpLnB1c2goJ3Nlcmllc0FjY2Vzc29yJywgJ2NoYXJ0Jyk7XHJcbiAgICBfY2hhcnQuc2hhcmVDb2xvcnModHJ1ZSk7XHJcblxyXG4gICAgX2NoYXJ0Ll9wcmVwcm9jZXNzRGF0YSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIga2VlcCA9IFtdO1xyXG4gICAgICAgIHZhciBjaGlsZHJlbkNoYW5nZWQ7XHJcbiAgICAgICAgdmFyIG5lc3RlciA9IGQzLm5lc3QoKS5rZXkoX3Nlcmllc0FjY2Vzc29yKTtcclxuICAgICAgICBpZiAoX3Nlcmllc1NvcnQpIHtcclxuICAgICAgICAgICAgbmVzdGVyLnNvcnRLZXlzKF9zZXJpZXNTb3J0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKF92YWx1ZVNvcnQpIHtcclxuICAgICAgICAgICAgbmVzdGVyLnNvcnRWYWx1ZXMoX3ZhbHVlU29ydCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBuZXN0aW5nID0gbmVzdGVyLmVudHJpZXMoX2NoYXJ0LmRhdGEoKSk7XHJcbiAgICAgICAgdmFyIGNoaWxkcmVuID1cclxuICAgICAgICAgICAgbmVzdGluZy5tYXAoZnVuY3Rpb24gKHN1YiwgaSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN1YkNoYXJ0ID0gX2NoYXJ0c1tzdWIua2V5XSB8fCBfY2hhcnRGdW5jdGlvbi5jYWxsKF9jaGFydCwgX2NoYXJ0LCBjaGFydEdyb3VwLCBzdWIua2V5LCBpKTtcclxuICAgICAgICAgICAgICAgIGlmICghX2NoYXJ0c1tzdWIua2V5XSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfY2hhcnRzW3N1Yi5rZXldID0gc3ViQ2hhcnQ7XHJcbiAgICAgICAgICAgICAgICBrZWVwLnB1c2goc3ViLmtleSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ViQ2hhcnRcclxuICAgICAgICAgICAgICAgICAgICAuZGltZW5zaW9uKF9jaGFydC5kaW1lbnNpb24oKSlcclxuICAgICAgICAgICAgICAgICAgICAuZ3JvdXAoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGw6IHR5cGVvZiBzdWIudmFsdWVzID09PSAnZnVuY3Rpb24nID8gc3ViLnZhbHVlcyA6IGRjLnV0aWxzLmNvbnN0YW50KHN1Yi52YWx1ZXMpXHJcbiAgICAgICAgICAgICAgICAgICAgfSwgc3ViLmtleSlcclxuICAgICAgICAgICAgICAgICAgICAua2V5QWNjZXNzb3IoX2NoYXJ0LmtleUFjY2Vzc29yKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgLnZhbHVlQWNjZXNzb3IoX2NoYXJ0LnZhbHVlQWNjZXNzb3IoKSlcclxuICAgICAgICAgICAgICAgICAgICAuYnJ1c2hPbihmYWxzZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIC8vIHRoaXMgd29ya3MgYXJvdW5kIHRoZSBmYWN0IGNvbXBvc2l0ZUNoYXJ0IGRvZXNuJ3QgcmVhbGx5XHJcbiAgICAgICAgLy8gaGF2ZSBhIHJlbW92YWwgaW50ZXJmYWNlXHJcbiAgICAgICAgT2JqZWN0LmtleXMoX2NoYXJ0cylcclxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoYykge3JldHVybiBrZWVwLmluZGV4T2YoYykgPT09IC0xO30pXHJcbiAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhckNoYXJ0KGMpO1xyXG4gICAgICAgICAgICAgICAgY2hpbGRyZW5DaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgX2NoYXJ0Ll9jb21wb3NlKGNoaWxkcmVuKTtcclxuICAgICAgICBpZiAoY2hpbGRyZW5DaGFuZ2VkICYmIF9jaGFydC5sZWdlbmQoKSkge1xyXG4gICAgICAgICAgICBfY2hhcnQubGVnZW5kKCkucmVuZGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBjbGVhckNoYXJ0IChjKSB7XHJcbiAgICAgICAgaWYgKF9jaGFydHNbY10uZygpKSB7XHJcbiAgICAgICAgICAgIF9jaGFydHNbY10uZygpLnJlbW92ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWxldGUgX2NoYXJ0c1tjXTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZXNldENoaWxkcmVuICgpIHtcclxuICAgICAgICBPYmplY3Qua2V5cyhfY2hhcnRzKS5tYXAoY2xlYXJDaGFydCk7XHJcbiAgICAgICAgX2NoYXJ0cyA9IHt9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IG9yIHNldCB0aGUgY2hhcnQgZnVuY3Rpb24sIHdoaWNoIGdlbmVyYXRlcyB0aGUgY2hpbGQgY2hhcnRzLlxyXG4gICAgICogQG1ldGhvZCBjaGFydFxyXG4gICAgICogQG1lbWJlcm9mIGRjLnNlcmllc0NoYXJ0XHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBwdXQgY3VydmUgb24gdGhlIGxpbmUgY2hhcnRzIHVzZWQgZm9yIHRoZSBzZXJpZXNcclxuICAgICAqIGNoYXJ0LmNoYXJ0KGZ1bmN0aW9uKGMpIHsgcmV0dXJuIGRjLmxpbmVDaGFydChjKS5jdXJ2ZShkMy5jdXJ2ZUJhc2lzKTsgfSlcclxuICAgICAqIC8vIGRvIGEgc2NhdHRlciBzZXJpZXMgY2hhcnRcclxuICAgICAqIGNoYXJ0LmNoYXJ0KGRjLnNjYXR0ZXJQbG90KVxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NoYXJ0RnVuY3Rpb249ZGMubGluZUNoYXJ0XVxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufGRjLnNlcmllc0NoYXJ0fVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQuY2hhcnQgPSBmdW5jdGlvbiAoY2hhcnRGdW5jdGlvbikge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2NoYXJ0RnVuY3Rpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9jaGFydEZ1bmN0aW9uID0gY2hhcnRGdW5jdGlvbjtcclxuICAgICAgICByZXNldENoaWxkcmVuKCk7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAqKm1hbmRhdG9yeSoqXHJcbiAgICAgKlxyXG4gICAgICogR2V0IG9yIHNldCBhY2Nlc3NvciBmdW5jdGlvbiBmb3IgdGhlIGRpc3BsYXllZCBzZXJpZXMuIEdpdmVuIGEgZGF0dW0sIHRoaXMgZnVuY3Rpb25cclxuICAgICAqIHNob3VsZCByZXR1cm4gdGhlIHNlcmllcyB0aGF0IGRhdHVtIGJlbG9uZ3MgdG8uXHJcbiAgICAgKiBAbWV0aG9kIHNlcmllc0FjY2Vzc29yXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuc2VyaWVzQ2hhcnRcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIHNpbXBsZSBzZXJpZXMgYWNjZXNzb3JcclxuICAgICAqIGNoYXJ0LnNlcmllc0FjY2Vzc29yKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIFwiRXhwdDogXCIgKyBkLmtleVswXTsgfSlcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFthY2Nlc3Nvcl1cclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbnxkYy5zZXJpZXNDaGFydH1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LnNlcmllc0FjY2Vzc29yID0gZnVuY3Rpb24gKGFjY2Vzc29yKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfc2VyaWVzQWNjZXNzb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9zZXJpZXNBY2Nlc3NvciA9IGFjY2Vzc29yO1xyXG4gICAgICAgIHJlc2V0Q2hpbGRyZW4oKTtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBvciBzZXQgYSBmdW5jdGlvbiB0byBzb3J0IHRoZSBsaXN0IG9mIHNlcmllcyBieSwgZ2l2ZW4gc2VyaWVzIHZhbHVlcy5cclxuICAgICAqIEBtZXRob2Qgc2VyaWVzU29ydFxyXG4gICAgICogQG1lbWJlcm9mIGRjLnNlcmllc0NoYXJ0XHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1hcnJheS9ibG9iL21hc3Rlci9SRUFETUUubWQjYXNjZW5kaW5nIGQzLmFzY2VuZGluZ31cclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1hcnJheS9ibG9iL21hc3Rlci9SRUFETUUubWQjZGVzY2VuZGluZyBkMy5kZXNjZW5kaW5nfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGNoYXJ0LnNlcmllc1NvcnQoZDMuZGVzY2VuZGluZyk7XHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc29ydEZ1bmN0aW9uPWQzLmFzY2VuZGluZ11cclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbnxkYy5zZXJpZXNDaGFydH1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LnNlcmllc1NvcnQgPSBmdW5jdGlvbiAoc29ydEZ1bmN0aW9uKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfc2VyaWVzU29ydDtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3Nlcmllc1NvcnQgPSBzb3J0RnVuY3Rpb247XHJcbiAgICAgICAgcmVzZXRDaGlsZHJlbigpO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IG9yIHNldCBhIGZ1bmN0aW9uIHRvIHNvcnQgZWFjaCBzZXJpZXMgdmFsdWVzIGJ5LiBCeSBkZWZhdWx0IHRoaXMgaXMgdGhlIGtleSBhY2Nlc3NvciB3aGljaCxcclxuICAgICAqIGZvciBleGFtcGxlLCB3aWxsIGVuc3VyZSBhIGxpbmVDaGFydCBzZXJpZXMgY29ubmVjdHMgaXRzIHBvaW50cyBpbiBpbmNyZWFzaW5nIGtleS94IG9yZGVyLFxyXG4gICAgICogcmF0aGVyIHRoYW4gaGFwaGF6YXJkbHkuXHJcbiAgICAgKiBAbWV0aG9kIHZhbHVlU29ydFxyXG4gICAgICogQG1lbWJlcm9mIGRjLnNlcmllc0NoYXJ0XHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1hcnJheS9ibG9iL21hc3Rlci9SRUFETUUubWQjYXNjZW5kaW5nIGQzLmFzY2VuZGluZ31cclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1hcnJheS9ibG9iL21hc3Rlci9SRUFETUUubWQjZGVzY2VuZGluZyBkMy5kZXNjZW5kaW5nfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIERlZmF1bHQgdmFsdWUgc29ydFxyXG4gICAgICogX2NoYXJ0LnZhbHVlU29ydChmdW5jdGlvbiBrZXlTb3J0IChhLCBiKSB7XHJcbiAgICAgKiAgICAgcmV0dXJuIGQzLmFzY2VuZGluZyhfY2hhcnQua2V5QWNjZXNzb3IoKShhKSwgX2NoYXJ0LmtleUFjY2Vzc29yKCkoYikpO1xyXG4gICAgICogfSk7XHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc29ydEZ1bmN0aW9uXVxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufGRjLnNlcmllc0NoYXJ0fVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQudmFsdWVTb3J0ID0gZnVuY3Rpb24gKHNvcnRGdW5jdGlvbikge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3ZhbHVlU29ydDtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3ZhbHVlU29ydCA9IHNvcnRGdW5jdGlvbjtcclxuICAgICAgICByZXNldENoaWxkcmVuKCk7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLy8gbWFrZSBjb21wb3NlIHByaXZhdGVcclxuICAgIF9jaGFydC5fY29tcG9zZSA9IF9jaGFydC5jb21wb3NlO1xyXG4gICAgZGVsZXRlIF9jaGFydC5jb21wb3NlO1xyXG5cclxuICAgIHJldHVybiBfY2hhcnQ7XHJcbn07XHJcblxyXG4vKipcclxuICogVGhlIGdlbyBjaG9yb3BsZXRoIGNoYXJ0IGlzIGRlc2lnbmVkIGFzIGFuIGVhc3kgd2F5IHRvIGNyZWF0ZSBhIGNyb3NzZmlsdGVyIGRyaXZlbiBjaG9yb3BsZXRoIG1hcFxyXG4gKiBmcm9tIEdlb0pzb24gZGF0YS4gVGhpcyBjaGFydCBpbXBsZW1lbnRhdGlvbiB3YXMgaW5zcGlyZWQgYnlcclxuICoge0BsaW5rIGh0dHA6Ly9ibC5vY2tzLm9yZy80MDYwNjA2IHRoZSBncmVhdCBkMyBjaG9yb3BsZXRoIGV4YW1wbGV9LlxyXG4gKlxyXG4gKiBFeGFtcGxlczpcclxuICogLSB7QGxpbmsgaHR0cDovL2RjLWpzLmdpdGh1Yi5jb20vZGMuanMvdmMvaW5kZXguaHRtbCBVUyBWZW50dXJlIENhcGl0YWwgTGFuZHNjYXBlIDIwMTF9XHJcbiAqIEBjbGFzcyBnZW9DaG9yb3BsZXRoQ2hhcnRcclxuICogQG1lbWJlcm9mIGRjXHJcbiAqIEBtaXhlcyBkYy5jb2xvck1peGluXHJcbiAqIEBtaXhlcyBkYy5iYXNlTWl4aW5cclxuICogQGV4YW1wbGVcclxuICogLy8gY3JlYXRlIGEgY2hvcm9wbGV0aCBjaGFydCB1bmRlciAnI3VzLWNoYXJ0JyBlbGVtZW50IHVzaW5nIHRoZSBkZWZhdWx0IGdsb2JhbCBjaGFydCBncm91cFxyXG4gKiB2YXIgY2hhcnQxID0gZGMuZ2VvQ2hvcm9wbGV0aENoYXJ0KCcjdXMtY2hhcnQnKTtcclxuICogLy8gY3JlYXRlIGEgY2hvcm9wbGV0aCBjaGFydCB1bmRlciAnI3VzLWNoYXJ0MicgZWxlbWVudCB1c2luZyBjaGFydCBncm91cCBBXHJcbiAqIHZhciBjaGFydDIgPSBkYy5jb21wb3NpdGVDaGFydCgnI3VzLWNoYXJ0MicsICdjaGFydEdyb3VwQScpO1xyXG4gKiBAcGFyYW0ge1N0cmluZ3xub2RlfGQzLnNlbGVjdGlvbn0gcGFyZW50IC0gQW55IHZhbGlkXHJcbiAqIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2VsZWN0aW9uL2Jsb2IvbWFzdGVyL1JFQURNRS5tZCNzZWxlY3QgZDMgc2luZ2xlIHNlbGVjdG9yfSBzcGVjaWZ5aW5nXHJcbiAqIGEgZG9tIGJsb2NrIGVsZW1lbnQgc3VjaCBhcyBhIGRpdjsgb3IgYSBkb20gZWxlbWVudCBvciBkMyBzZWxlY3Rpb24uXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbY2hhcnRHcm91cF0gLSBUaGUgbmFtZSBvZiB0aGUgY2hhcnQgZ3JvdXAgdGhpcyBjaGFydCBpbnN0YW5jZSBzaG91bGQgYmUgcGxhY2VkIGluLlxyXG4gKiBJbnRlcmFjdGlvbiB3aXRoIGEgY2hhcnQgd2lsbCBvbmx5IHRyaWdnZXIgZXZlbnRzIGFuZCByZWRyYXdzIHdpdGhpbiB0aGUgY2hhcnQncyBncm91cC5cclxuICogQHJldHVybnMge2RjLmdlb0Nob3JvcGxldGhDaGFydH1cclxuICovXHJcbmRjLmdlb0Nob3JvcGxldGhDaGFydCA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoYXJ0R3JvdXApIHtcclxuICAgIHZhciBfY2hhcnQgPSBkYy5jb2xvck1peGluKGRjLmJhc2VNaXhpbih7fSkpO1xyXG5cclxuICAgIF9jaGFydC5jb2xvckFjY2Vzc29yKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgcmV0dXJuIGQgfHwgMDtcclxuICAgIH0pO1xyXG5cclxuICAgIHZhciBfZ2VvUGF0aCA9IGQzLmdlb1BhdGgoKTtcclxuICAgIHZhciBfcHJvamVjdGlvbkZsYWc7XHJcbiAgICB2YXIgX3Byb2plY3Rpb247XHJcblxyXG4gICAgdmFyIF9nZW9Kc29ucyA9IFtdO1xyXG5cclxuICAgIF9jaGFydC5fZG9SZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX2NoYXJ0LnJlc2V0U3ZnKCk7XHJcbiAgICAgICAgZm9yICh2YXIgbGF5ZXJJbmRleCA9IDA7IGxheWVySW5kZXggPCBfZ2VvSnNvbnMubGVuZ3RoOyArK2xheWVySW5kZXgpIHtcclxuICAgICAgICAgICAgdmFyIHN0YXRlcyA9IF9jaGFydC5zdmcoKS5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2xheWVyJyArIGxheWVySW5kZXgpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHJlZ2lvbkcgPSBzdGF0ZXMuc2VsZWN0QWxsKCdnLicgKyBnZW9Kc29uKGxheWVySW5kZXgpLm5hbWUpXHJcbiAgICAgICAgICAgICAgICAuZGF0YShnZW9Kc29uKGxheWVySW5kZXgpLmRhdGEpO1xyXG5cclxuICAgICAgICAgICAgcmVnaW9uRyA9IHJlZ2lvbkcuZW50ZXIoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGdlb0pzb24obGF5ZXJJbmRleCkubmFtZSlcclxuICAgICAgICAgICAgICAgIC5tZXJnZShyZWdpb25HKTtcclxuXHJcbiAgICAgICAgICAgIHJlZ2lvbkdcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnd2hpdGUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBfZ2V0R2VvUGF0aCgpKTtcclxuXHJcbiAgICAgICAgICAgIHJlZ2lvbkcuYXBwZW5kKCd0aXRsZScpO1xyXG5cclxuICAgICAgICAgICAgcGxvdERhdGEobGF5ZXJJbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9wcm9qZWN0aW9uRmxhZyA9IGZhbHNlO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBwbG90RGF0YSAobGF5ZXJJbmRleCkge1xyXG4gICAgICAgIHZhciBkYXRhID0gZ2VuZXJhdGVMYXllcmVkRGF0YSgpO1xyXG5cclxuICAgICAgICBpZiAoaXNEYXRhTGF5ZXIobGF5ZXJJbmRleCkpIHtcclxuICAgICAgICAgICAgdmFyIHJlZ2lvbkcgPSByZW5kZXJSZWdpb25HKGxheWVySW5kZXgpO1xyXG5cclxuICAgICAgICAgICAgcmVuZGVyUGF0aHMocmVnaW9uRywgbGF5ZXJJbmRleCwgZGF0YSk7XHJcblxyXG4gICAgICAgICAgICByZW5kZXJUaXRsZShyZWdpb25HLCBsYXllckluZGV4LCBkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVMYXllcmVkRGF0YSAoKSB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSB7fTtcclxuICAgICAgICB2YXIgZ3JvdXBBbGwgPSBfY2hhcnQuZGF0YSgpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBBbGwubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgZGF0YVtfY2hhcnQua2V5QWNjZXNzb3IoKShncm91cEFsbFtpXSldID0gX2NoYXJ0LnZhbHVlQWNjZXNzb3IoKShncm91cEFsbFtpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGlzRGF0YUxheWVyIChsYXllckluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIGdlb0pzb24obGF5ZXJJbmRleCkua2V5QWNjZXNzb3I7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVuZGVyUmVnaW9uRyAobGF5ZXJJbmRleCkge1xyXG4gICAgICAgIHZhciByZWdpb25HID0gX2NoYXJ0LnN2ZygpXHJcbiAgICAgICAgICAgIC5zZWxlY3RBbGwobGF5ZXJTZWxlY3RvcihsYXllckluZGV4KSlcclxuICAgICAgICAgICAgLmNsYXNzZWQoJ3NlbGVjdGVkJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpc1NlbGVjdGVkKGxheWVySW5kZXgsIGQpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuY2xhc3NlZCgnZGVzZWxlY3RlZCcsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNEZXNlbGVjdGVkKGxheWVySW5kZXgsIGQpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxheWVyTmFtZUNsYXNzID0gZ2VvSnNvbihsYXllckluZGV4KS5uYW1lO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlZ2lvbkNsYXNzID0gZGMudXRpbHMubmFtZVRvSWQoZ2VvSnNvbihsYXllckluZGV4KS5rZXlBY2Nlc3NvcihkKSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYmFzZUNsYXNzZXMgPSBsYXllck5hbWVDbGFzcyArICcgJyArIHJlZ2lvbkNsYXNzO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzU2VsZWN0ZWQobGF5ZXJJbmRleCwgZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBiYXNlQ2xhc3NlcyArPSAnIHNlbGVjdGVkJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc0Rlc2VsZWN0ZWQobGF5ZXJJbmRleCwgZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBiYXNlQ2xhc3NlcyArPSAnIGRlc2VsZWN0ZWQnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhc2VDbGFzc2VzO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVnaW9uRztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBsYXllclNlbGVjdG9yIChsYXllckluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuICdnLmxheWVyJyArIGxheWVySW5kZXggKyAnIGcuJyArIGdlb0pzb24obGF5ZXJJbmRleCkubmFtZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpc1NlbGVjdGVkIChsYXllckluZGV4LCBkKSB7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydC5oYXNGaWx0ZXIoKSAmJiBfY2hhcnQuaGFzRmlsdGVyKGdldEtleShsYXllckluZGV4LCBkKSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaXNEZXNlbGVjdGVkIChsYXllckluZGV4LCBkKSB7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydC5oYXNGaWx0ZXIoKSAmJiAhX2NoYXJ0Lmhhc0ZpbHRlcihnZXRLZXkobGF5ZXJJbmRleCwgZCkpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldEtleSAobGF5ZXJJbmRleCwgZCkge1xyXG4gICAgICAgIHJldHVybiBnZW9Kc29uKGxheWVySW5kZXgpLmtleUFjY2Vzc29yKGQpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdlb0pzb24gKGluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIF9nZW9Kc29uc1tpbmRleF07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVuZGVyUGF0aHMgKHJlZ2lvbkcsIGxheWVySW5kZXgsIGRhdGEpIHtcclxuICAgICAgICB2YXIgcGF0aHMgPSByZWdpb25HXHJcbiAgICAgICAgICAgIC5zZWxlY3QoJ3BhdGgnKVxyXG4gICAgICAgICAgICAuYXR0cignZmlsbCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50RmlsbCA9IGQzLnNlbGVjdCh0aGlzKS5hdHRyKCdmaWxsJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEZpbGwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudEZpbGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ25vbmUnO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAub24oJ2NsaWNrJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfY2hhcnQub25DbGljayhkLCBsYXllckluZGV4KTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGRjLnRyYW5zaXRpb24ocGF0aHMsIF9jaGFydC50cmFuc2l0aW9uRHVyYXRpb24oKSwgX2NoYXJ0LnRyYW5zaXRpb25EZWxheSgpKS5hdHRyKCdmaWxsJywgZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9jaGFydC5nZXRDb2xvcihkYXRhW2dlb0pzb24obGF5ZXJJbmRleCkua2V5QWNjZXNzb3IoZCldLCBpKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBfY2hhcnQub25DbGljayA9IGZ1bmN0aW9uIChkLCBsYXllckluZGV4KSB7XHJcbiAgICAgICAgdmFyIHNlbGVjdGVkUmVnaW9uID0gZ2VvSnNvbihsYXllckluZGV4KS5rZXlBY2Nlc3NvcihkKTtcclxuICAgICAgICBkYy5ldmVudHMudHJpZ2dlcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF9jaGFydC5maWx0ZXIoc2VsZWN0ZWRSZWdpb24pO1xyXG4gICAgICAgICAgICBfY2hhcnQucmVkcmF3R3JvdXAoKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gcmVuZGVyVGl0bGUgKHJlZ2lvbkcsIGxheWVySW5kZXgsIGRhdGEpIHtcclxuICAgICAgICBpZiAoX2NoYXJ0LnJlbmRlclRpdGxlKCkpIHtcclxuICAgICAgICAgICAgcmVnaW9uRy5zZWxlY3RBbGwoJ3RpdGxlJykudGV4dChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGdldEtleShsYXllckluZGV4LCBkKTtcclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGRhdGFba2V5XTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfY2hhcnQudGl0bGUoKSh7a2V5OiBrZXksIHZhbHVlOiB2YWx1ZX0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgX2NoYXJ0Ll9kb1JlZHJhdyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmb3IgKHZhciBsYXllckluZGV4ID0gMDsgbGF5ZXJJbmRleCA8IF9nZW9Kc29ucy5sZW5ndGg7ICsrbGF5ZXJJbmRleCkge1xyXG4gICAgICAgICAgICBwbG90RGF0YShsYXllckluZGV4KTtcclxuICAgICAgICAgICAgaWYgKF9wcm9qZWN0aW9uRmxhZykge1xyXG4gICAgICAgICAgICAgICAgX2NoYXJ0LnN2ZygpLnNlbGVjdEFsbCgnZy4nICsgZ2VvSnNvbihsYXllckluZGV4KS5uYW1lICsgJyBwYXRoJykuYXR0cignZCcsIF9nZXRHZW9QYXRoKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9wcm9qZWN0aW9uRmxhZyA9IGZhbHNlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqICoqbWFuZGF0b3J5KipcclxuICAgICAqXHJcbiAgICAgKiBVc2UgdGhpcyBmdW5jdGlvbiB0byBpbnNlcnQgYSBuZXcgR2VvSnNvbiBtYXAgbGF5ZXIuIFRoaXMgZnVuY3Rpb24gY2FuIGJlIGludm9rZWQgbXVsdGlwbGUgdGltZXNcclxuICAgICAqIGlmIHlvdSBoYXZlIG11bHRpcGxlIEdlb0pzb24gZGF0YSBsYXllcnMgdG8gcmVuZGVyIG9uIHRvcCBvZiBlYWNoIG90aGVyLiBJZiB5b3Ugb3ZlcmxheSBtdWx0aXBsZVxyXG4gICAgICogbGF5ZXJzIHdpdGggdGhlIHNhbWUgbmFtZSB0aGUgbmV3IG92ZXJsYXkgd2lsbCBvdmVycmlkZSB0aGUgZXhpc3Rpbmcgb25lLlxyXG4gICAgICogQG1ldGhvZCBvdmVybGF5R2VvSnNvblxyXG4gICAgICogQG1lbWJlcm9mIGRjLmdlb0Nob3JvcGxldGhDaGFydFxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwOi8vZ2VvanNvbi5vcmcvIEdlb0pTT059XHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vdG9wb2pzb24vdG9wb2pzb24vd2lraSBUb3BvSlNPTn1cclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS90b3BvanNvbi90b3BvanNvbi0xLngtYXBpLXJlZmVyZW5jZS9ibG9iL21hc3Rlci9BUEktUmVmZXJlbmNlLm1kI3dpa2ktZmVhdHVyZSB0b3BvanNvbi5mZWF0dXJlfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGluc2VydCBhIGxheWVyIGZvciByZW5kZXJpbmcgVVMgc3RhdGVzXHJcbiAgICAgKiBjaGFydC5vdmVybGF5R2VvSnNvbihzdGF0ZXNKc29uLmZlYXR1cmVzLCAnc3RhdGUnLCBmdW5jdGlvbihkKSB7XHJcbiAgICAgKiAgICAgIHJldHVybiBkLnByb3BlcnRpZXMubmFtZTtcclxuICAgICAqIH0pO1xyXG4gICAgICogQHBhcmFtIHtnZW9Kc29ufSBqc29uIC0gYSBnZW9qc29uIGZlZWRcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gbmFtZSBvZiB0aGUgbGF5ZXJcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleUFjY2Vzc29yIC0gYWNjZXNzb3IgZnVuY3Rpb24gdXNlZCB0byBleHRyYWN0ICdrZXknIGZyb20gdGhlIEdlb0pzb24gZGF0YS4gVGhlIGtleSBleHRyYWN0ZWQgYnlcclxuICAgICAqIHRoaXMgZnVuY3Rpb24gc2hvdWxkIG1hdGNoIHRoZSBrZXlzIHJldHVybmVkIGJ5IHRoZSBjcm9zc2ZpbHRlciBncm91cHMuXHJcbiAgICAgKiBAcmV0dXJucyB7ZGMuZ2VvQ2hvcm9wbGV0aENoYXJ0fVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQub3ZlcmxheUdlb0pzb24gPSBmdW5jdGlvbiAoanNvbiwgbmFtZSwga2V5QWNjZXNzb3IpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9nZW9Kc29ucy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBpZiAoX2dlb0pzb25zW2ldLm5hbWUgPT09IG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIF9nZW9Kc29uc1tpXS5kYXRhID0ganNvbjtcclxuICAgICAgICAgICAgICAgIF9nZW9Kc29uc1tpXS5rZXlBY2Nlc3NvciA9IGtleUFjY2Vzc29yO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBfZ2VvSnNvbnMucHVzaCh7bmFtZTogbmFtZSwgZGF0YToganNvbiwga2V5QWNjZXNzb3I6IGtleUFjY2Vzc29yfSk7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgYSBjdXN0b20gZ2VvIHByb2plY3Rpb24gZnVuY3Rpb24uIFNlZSB0aGUgYXZhaWxhYmxlXHJcbiAgICAgKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLWdlby9ibG9iL21hc3Rlci9SRUFETUUubWQjcHJvamVjdGlvbnMgZDMgZ2VvIHByb2plY3Rpb24gZnVuY3Rpb25zfS5cclxuICAgICAqXHJcbiAgICAgKiBTdGFydGluZyB2ZXJzaW9uIDMuMCBpdCBoYXMgYmVlbiBkZXByZWNhdGVkIHRvIHJlbHkgb24gdGhlIGRlZmF1bHQgcHJvamVjdGlvbiBiZWluZ1xyXG4gICAgICoge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1nZW8vYmxvYi9tYXN0ZXIvUkVBRE1FLm1kI2dlb0FsYmVyc1VzYSBkMy5nZW9BbGJlcnNVc2EoKX0uIFBsZWFzZVxyXG4gICAgICogc2V0IGl0IGV4cGxpY2l0bHkuIHtAbGluayBodHRwczovL2JsLm9ja3Mub3JnL21ib3N0b2NrLzU1NTc3MjZcclxuICAgICAqIENvbnNpZGVyaW5nIHRoYXQgYG51bGxgIGlzIGFsc28gYSB2YWxpZCB2YWx1ZSBmb3IgcHJvamVjdGlvbn0sIGlmIHlvdSBuZWVkXHJcbiAgICAgKiBwcm9qZWN0aW9uIHRvIGJlIGBudWxsYCBwbGVhc2Ugc2V0IGl0IGV4cGxpY2l0bHkgdG8gYG51bGxgLlxyXG4gICAgICogQG1ldGhvZCBwcm9qZWN0aW9uXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuZ2VvQ2hvcm9wbGV0aENoYXJ0XHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1nZW8vYmxvYi9tYXN0ZXIvUkVBRE1FLm1kI3Byb2plY3Rpb25zIGQzLnByb2plY3Rpb259XHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtZ2VvLXByb2plY3Rpb24gZDMtZ2VvLXByb2plY3Rpb259XHJcbiAgICAgKiBAcGFyYW0ge2QzLnByb2plY3Rpb259IFtwcm9qZWN0aW9uPWQzLmdlb0FsYmVyc1VzYSgpXVxyXG4gICAgICogQHJldHVybnMge2QzLnByb2plY3Rpb258ZGMuZ2VvQ2hvcm9wbGV0aENoYXJ0fVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQucHJvamVjdGlvbiA9IGZ1bmN0aW9uIChwcm9qZWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfcHJvamVjdGlvbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIF9wcm9qZWN0aW9uID0gcHJvamVjdGlvbjtcclxuICAgICAgICBfcHJvamVjdGlvbkZsYWcgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBfZ2V0R2VvUGF0aCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoX3Byb2plY3Rpb24gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBkYy5sb2dnZXIud2FybignY2hvcm9wbGV0aCBwcm9qZWN0aW9uIGRlZmF1bHQgb2YgZ2VvQWxiZXJzIGlzIGRlcHJlY2F0ZWQsJyArXHJcbiAgICAgICAgICAgICAgICAnIGluIG5leHQgdmVyc2lvbiBwcm9qZWN0aW9uIHdpbGwgbmVlZCB0byBiZSBzZXQgZXhwbGljaXRseScpO1xyXG4gICAgICAgICAgICByZXR1cm4gX2dlb1BhdGgucHJvamVjdGlvbihkMy5nZW9BbGJlcnNVc2EoKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gX2dlb1BhdGgucHJvamVjdGlvbihfcHJvamVjdGlvbik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbGwgR2VvSnNvbiBsYXllcnMgY3VycmVudGx5IHJlZ2lzdGVyZWQgd2l0aCB0aGlzIGNoYXJ0LiBUaGUgcmV0dXJuZWQgYXJyYXkgaXMgYVxyXG4gICAgICogcmVmZXJlbmNlIHRvIHRoaXMgY2hhcnQncyBpbnRlcm5hbCBkYXRhIHN0cnVjdHVyZSwgc28gYW55IG1vZGlmaWNhdGlvbiB0byB0aGlzIGFycmF5IHdpbGwgYWxzb1xyXG4gICAgICogbW9kaWZ5IHRoaXMgY2hhcnQncyBpbnRlcm5hbCByZWdpc3RyYXRpb24uXHJcbiAgICAgKiBAbWV0aG9kIGdlb0pzb25zXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuZ2VvQ2hvcm9wbGV0aENoYXJ0XHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEByZXR1cm5zIHtBcnJheTx7bmFtZTpTdHJpbmcsIGRhdGE6IE9iamVjdCwgYWNjZXNzb3I6IEZ1bmN0aW9ufT59XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5nZW9Kc29ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX2dlb0pzb25zO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtZ2VvL2Jsb2IvbWFzdGVyL1JFQURNRS5tZCNwYXRocyBkMy5nZW9QYXRofSBvYmplY3QgdXNlZCB0b1xyXG4gICAgICogcmVuZGVyIHRoZSBwcm9qZWN0aW9uIGFuZCBmZWF0dXJlcy4gIENhbiBiZSB1c2VmdWwgZm9yIGZpZ3VyaW5nIG91dCB0aGUgYm91bmRpbmcgYm94IG9mIHRoZVxyXG4gICAgICogZmVhdHVyZSBzZXQgYW5kIHRodXMgYSB3YXkgdG8gY2FsY3VsYXRlIHNjYWxlIGFuZCB0cmFuc2xhdGlvbiBmb3IgdGhlIHByb2plY3Rpb24uXHJcbiAgICAgKiBAbWV0aG9kIGdlb1BhdGhcclxuICAgICAqIEBtZW1iZXJvZiBkYy5nZW9DaG9yb3BsZXRoQ2hhcnRcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLWdlby9ibG9iL21hc3Rlci9SRUFETUUubWQjcGF0aHMgZDMuZ2VvUGF0aH1cclxuICAgICAqIEByZXR1cm5zIHtkMy5nZW9QYXRofVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQuZ2VvUGF0aCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX2dlb1BhdGg7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIGEgR2VvSnNvbiBsYXllciBmcm9tIHRoaXMgY2hhcnQgYnkgbmFtZVxyXG4gICAgICogQG1ldGhvZCByZW1vdmVHZW9Kc29uXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuZ2VvQ2hvcm9wbGV0aENoYXJ0XHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXHJcbiAgICAgKiBAcmV0dXJucyB7ZGMuZ2VvQ2hvcm9wbGV0aENoYXJ0fVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQucmVtb3ZlR2VvSnNvbiA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgdmFyIGdlb0pzb25zID0gW107XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX2dlb0pzb25zLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciBsYXllciA9IF9nZW9Kc29uc1tpXTtcclxuICAgICAgICAgICAgaWYgKGxheWVyLm5hbWUgIT09IG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGdlb0pzb25zLnB1c2gobGF5ZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBfZ2VvSnNvbnMgPSBnZW9Kc29ucztcclxuXHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIF9jaGFydC5hbmNob3IocGFyZW50LCBjaGFydEdyb3VwKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgYnViYmxlIG92ZXJsYXkgY2hhcnQgaXMgcXVpdGUgZGlmZmVyZW50IGZyb20gdGhlIHR5cGljYWwgYnViYmxlIGNoYXJ0LiBXaXRoIHRoZSBidWJibGUgb3ZlcmxheVxyXG4gKiBjaGFydCB5b3UgY2FuIGFyYml0cmFyaWx5IHBsYWNlIGJ1YmJsZXMgb24gYW4gZXhpc3Rpbmcgc3ZnIG9yIGJpdG1hcCBpbWFnZSwgdGh1cyBjaGFuZ2luZyB0aGVcclxuICogdHlwaWNhbCB4IGFuZCB5IHBvc2l0aW9uaW5nIHdoaWxlIHJldGFpbmluZyB0aGUgY2FwYWJpbGl0eSB0byB2aXN1YWxpemUgZGF0YSB1c2luZyBidWJibGUgcmFkaXVzXHJcbiAqIGFuZCBjb2xvcmluZy5cclxuICpcclxuICogRXhhbXBsZXM6XHJcbiAqIC0ge0BsaW5rIGh0dHA6Ly9kYy1qcy5naXRodWIuY29tL2RjLmpzL2NyaW1lL2luZGV4Lmh0bWwgQ2FuYWRpYW4gQ2l0eSBDcmltZSBTdGF0c31cclxuICogQGNsYXNzIGJ1YmJsZU92ZXJsYXlcclxuICogQG1lbWJlcm9mIGRjXHJcbiAqIEBtaXhlcyBkYy5idWJibGVNaXhpblxyXG4gKiBAbWl4ZXMgZGMuYmFzZU1peGluXHJcbiAqIEBleGFtcGxlXHJcbiAqIC8vIGNyZWF0ZSBhIGJ1YmJsZSBvdmVybGF5IGNoYXJ0IG9uIHRvcCBvZiB0aGUgJyNjaGFydC1jb250YWluZXIxIHN2ZycgZWxlbWVudCB1c2luZyB0aGUgZGVmYXVsdCBnbG9iYWwgY2hhcnQgZ3JvdXBcclxuICogdmFyIGJ1YmJsZUNoYXJ0MSA9IGRjLmJ1YmJsZU92ZXJsYXlDaGFydCgnI2NoYXJ0LWNvbnRhaW5lcjEnKS5zdmcoZDMuc2VsZWN0KCcjY2hhcnQtY29udGFpbmVyMSBzdmcnKSk7XHJcbiAqIC8vIGNyZWF0ZSBhIGJ1YmJsZSBvdmVybGF5IGNoYXJ0IG9uIHRvcCBvZiB0aGUgJyNjaGFydC1jb250YWluZXIyIHN2ZycgZWxlbWVudCB1c2luZyBjaGFydCBncm91cCBBXHJcbiAqIHZhciBidWJibGVDaGFydDIgPSBkYy5jb21wb3NpdGVDaGFydCgnI2NoYXJ0LWNvbnRhaW5lcjInLCAnY2hhcnRHcm91cEEnKS5zdmcoZDMuc2VsZWN0KCcjY2hhcnQtY29udGFpbmVyMiBzdmcnKSk7XHJcbiAqIEBwYXJhbSB7U3RyaW5nfG5vZGV8ZDMuc2VsZWN0aW9ufSBwYXJlbnQgLSBBbnkgdmFsaWRcclxuICoge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1zZWxlY3Rpb24vYmxvYi9tYXN0ZXIvUkVBRE1FLm1kI3NlbGVjdCBkMyBzaW5nbGUgc2VsZWN0b3J9IHNwZWNpZnlpbmdcclxuICogYSBkb20gYmxvY2sgZWxlbWVudCBzdWNoIGFzIGEgZGl2OyBvciBhIGRvbSBlbGVtZW50IG9yIGQzIHNlbGVjdGlvbi5cclxuICogQHBhcmFtIHtTdHJpbmd9IFtjaGFydEdyb3VwXSAtIFRoZSBuYW1lIG9mIHRoZSBjaGFydCBncm91cCB0aGlzIGNoYXJ0IGluc3RhbmNlIHNob3VsZCBiZSBwbGFjZWQgaW4uXHJcbiAqIEludGVyYWN0aW9uIHdpdGggYSBjaGFydCB3aWxsIG9ubHkgdHJpZ2dlciBldmVudHMgYW5kIHJlZHJhd3Mgd2l0aGluIHRoZSBjaGFydCdzIGdyb3VwLlxyXG4gKiBAcmV0dXJucyB7ZGMuYnViYmxlT3ZlcmxheX1cclxuICovXHJcbmRjLmJ1YmJsZU92ZXJsYXkgPSBmdW5jdGlvbiAocGFyZW50LCBjaGFydEdyb3VwKSB7XHJcbiAgICB2YXIgQlVCQkxFX09WRVJMQVlfQ0xBU1MgPSAnYnViYmxlLW92ZXJsYXknO1xyXG4gICAgdmFyIEJVQkJMRV9OT0RFX0NMQVNTID0gJ25vZGUnO1xyXG4gICAgdmFyIEJVQkJMRV9DTEFTUyA9ICdidWJibGUnO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogKiptYW5kYXRvcnkqKlxyXG4gICAgICpcclxuICAgICAqIFNldCB0aGUgdW5kZXJseWluZyBzdmcgaW1hZ2UgZWxlbWVudC4gVW5saWtlIG90aGVyIGRjIGNoYXJ0cyB0aGlzIGNoYXJ0IHdpbGwgbm90IGdlbmVyYXRlIGEgc3ZnXHJcbiAgICAgKiBlbGVtZW50OyB0aGVyZWZvcmUgdGhlIGJ1YmJsZSBvdmVybGF5IGNoYXJ0IHdpbGwgbm90IHdvcmsgaWYgdGhpcyBmdW5jdGlvbiBpcyBub3QgaW52b2tlZC4gSWYgdGhlXHJcbiAgICAgKiB1bmRlcmx5aW5nIGltYWdlIGlzIGEgYml0bWFwLCB0aGVuIGFuIGVtcHR5IHN2ZyB3aWxsIG5lZWQgdG8gYmUgY3JlYXRlZCBvbiB0b3Agb2YgdGhlIGltYWdlLlxyXG4gICAgICogQG1ldGhvZCBzdmdcclxuICAgICAqIEBtZW1iZXJvZiBkYy5idWJibGVPdmVybGF5XHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBzZXQgdXAgdW5kZXJseWluZyBzdmcgZWxlbWVudFxyXG4gICAgICogY2hhcnQuc3ZnKGQzLnNlbGVjdCgnI2NoYXJ0IHN2ZycpKTtcclxuICAgICAqIEBwYXJhbSB7U1ZHRWxlbWVudHxkMy5zZWxlY3Rpb259IFtpbWFnZUVsZW1lbnRdXHJcbiAgICAgKiBAcmV0dXJucyB7ZGMuYnViYmxlT3ZlcmxheX1cclxuICAgICAqL1xyXG4gICAgdmFyIF9jaGFydCA9IGRjLmJ1YmJsZU1peGluKGRjLmJhc2VNaXhpbih7fSkpO1xyXG4gICAgdmFyIF9nO1xyXG4gICAgdmFyIF9wb2ludHMgPSBbXTtcclxuXHJcbiAgICBfY2hhcnQudHJhbnNpdGlvbkR1cmF0aW9uKDc1MCk7XHJcblxyXG4gICAgX2NoYXJ0LnRyYW5zaXRpb25EZWxheSgwKTtcclxuXHJcbiAgICBfY2hhcnQucmFkaXVzVmFsdWVBY2Nlc3NvcihmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIHJldHVybiBkLnZhbHVlO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAqKm1hbmRhdG9yeSoqXHJcbiAgICAgKlxyXG4gICAgICogU2V0IHVwIGEgZGF0YSBwb2ludCBvbiB0aGUgb3ZlcmxheS4gVGhlIG5hbWUgb2YgYSBkYXRhIHBvaW50IHNob3VsZCBtYXRjaCBhIHNwZWNpZmljICdrZXknIGFtb25nXHJcbiAgICAgKiBkYXRhIGdyb3VwcyBnZW5lcmF0ZWQgdXNpbmcga2V5QWNjZXNzb3IuICBJZiBhIG1hdGNoIGlzIGZvdW5kIChwb2ludCBuYW1lIDwtPiBkYXRhIGdyb3VwIGtleSlcclxuICAgICAqIHRoZW4gYSBidWJibGUgd2lsbCBiZSBnZW5lcmF0ZWQgYXQgdGhlIHBvc2l0aW9uIHNwZWNpZmllZCBieSB0aGUgZnVuY3Rpb24uIHggYW5kIHlcclxuICAgICAqIHZhbHVlIHNwZWNpZmllZCBoZXJlIGFyZSByZWxhdGl2ZSB0byB0aGUgdW5kZXJseWluZyBzdmcuXHJcbiAgICAgKiBAbWV0aG9kIHBvaW50XHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuYnViYmxlT3ZlcmxheVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XHJcbiAgICAgKiBAcmV0dXJucyB7ZGMuYnViYmxlT3ZlcmxheX1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LnBvaW50ID0gZnVuY3Rpb24gKG5hbWUsIHgsIHkpIHtcclxuICAgICAgICBfcG9pbnRzLnB1c2goe25hbWU6IG5hbWUsIHg6IHgsIHk6IHl9KTtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICBfY2hhcnQuX2RvUmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9nID0gaW5pdE92ZXJsYXlHKCk7XHJcblxyXG4gICAgICAgIF9jaGFydC5yKCkucmFuZ2UoW19jaGFydC5NSU5fUkFESVVTLCBfY2hhcnQud2lkdGgoKSAqIF9jaGFydC5tYXhCdWJibGVSZWxhdGl2ZVNpemUoKV0pO1xyXG5cclxuICAgICAgICBpbml0aWFsaXplQnViYmxlcygpO1xyXG5cclxuICAgICAgICBfY2hhcnQuZmFkZURlc2VsZWN0ZWRBcmVhKF9jaGFydC5maWx0ZXIoKSk7XHJcblxyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGluaXRPdmVybGF5RyAoKSB7XHJcbiAgICAgICAgX2cgPSBfY2hhcnQuc2VsZWN0KCdnLicgKyBCVUJCTEVfT1ZFUkxBWV9DTEFTUyk7XHJcbiAgICAgICAgaWYgKF9nLmVtcHR5KCkpIHtcclxuICAgICAgICAgICAgX2cgPSBfY2hhcnQuc3ZnKCkuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCBCVUJCTEVfT1ZFUkxBWV9DTEFTUyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfZztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpbml0aWFsaXplQnViYmxlcyAoKSB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSBtYXBEYXRhKCk7XHJcbiAgICAgICAgX2NoYXJ0LmNhbGN1bGF0ZVJhZGl1c0RvbWFpbigpO1xyXG5cclxuICAgICAgICBfcG9pbnRzLmZvckVhY2goZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgICAgICAgICAgIHZhciBub2RlRyA9IGdldE5vZGVHKHBvaW50LCBkYXRhKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBjaXJjbGUgPSBub2RlRy5zZWxlY3QoJ2NpcmNsZS4nICsgQlVCQkxFX0NMQVNTKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChjaXJjbGUuZW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgY2lyY2xlID0gbm9kZUcuYXBwZW5kKCdjaXJjbGUnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIEJVQkJMRV9DTEFTUylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigncicsIDApXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCBfY2hhcnQuZ2V0Q29sb3IpXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uKCdjbGljaycsIF9jaGFydC5vbkNsaWNrKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZGMudHJhbnNpdGlvbihjaXJjbGUsIF9jaGFydC50cmFuc2l0aW9uRHVyYXRpb24oKSwgX2NoYXJ0LnRyYW5zaXRpb25EZWxheSgpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3InLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfY2hhcnQuYnViYmxlUihkKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgX2NoYXJ0Ll9kb1JlbmRlckxhYmVsKG5vZGVHKTtcclxuXHJcbiAgICAgICAgICAgIF9jaGFydC5fZG9SZW5kZXJUaXRsZXMobm9kZUcpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1hcERhdGEgKCkge1xyXG4gICAgICAgIHZhciBkYXRhID0ge307XHJcbiAgICAgICAgX2NoYXJ0LmRhdGEoKS5mb3JFYWNoKGZ1bmN0aW9uIChkYXR1bSkge1xyXG4gICAgICAgICAgICBkYXRhW19jaGFydC5rZXlBY2Nlc3NvcigpKGRhdHVtKV0gPSBkYXR1bTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXROb2RlRyAocG9pbnQsIGRhdGEpIHtcclxuICAgICAgICB2YXIgYnViYmxlTm9kZUNsYXNzID0gQlVCQkxFX05PREVfQ0xBU1MgKyAnICcgKyBkYy51dGlscy5uYW1lVG9JZChwb2ludC5uYW1lKTtcclxuXHJcbiAgICAgICAgdmFyIG5vZGVHID0gX2cuc2VsZWN0KCdnLicgKyBkYy51dGlscy5uYW1lVG9JZChwb2ludC5uYW1lKSk7XHJcblxyXG4gICAgICAgIGlmIChub2RlRy5lbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIG5vZGVHID0gX2cuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGJ1YmJsZU5vZGVDbGFzcylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBwb2ludC54ICsgJywnICsgcG9pbnQueSArICcpJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBub2RlRy5kYXR1bShkYXRhW3BvaW50Lm5hbWVdKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5vZGVHO1xyXG4gICAgfVxyXG5cclxuICAgIF9jaGFydC5fZG9SZWRyYXcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdXBkYXRlQnViYmxlcygpO1xyXG5cclxuICAgICAgICBfY2hhcnQuZmFkZURlc2VsZWN0ZWRBcmVhKF9jaGFydC5maWx0ZXIoKSk7XHJcblxyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZUJ1YmJsZXMgKCkge1xyXG4gICAgICAgIHZhciBkYXRhID0gbWFwRGF0YSgpO1xyXG4gICAgICAgIF9jaGFydC5jYWxjdWxhdGVSYWRpdXNEb21haW4oKTtcclxuXHJcbiAgICAgICAgX3BvaW50cy5mb3JFYWNoKGZ1bmN0aW9uIChwb2ludCkge1xyXG4gICAgICAgICAgICB2YXIgbm9kZUcgPSBnZXROb2RlRyhwb2ludCwgZGF0YSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgY2lyY2xlID0gbm9kZUcuc2VsZWN0KCdjaXJjbGUuJyArIEJVQkJMRV9DTEFTUyk7XHJcblxyXG4gICAgICAgICAgICBkYy50cmFuc2l0aW9uKGNpcmNsZSwgX2NoYXJ0LnRyYW5zaXRpb25EdXJhdGlvbigpLCBfY2hhcnQudHJhbnNpdGlvbkRlbGF5KCkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigncicsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jaGFydC5idWJibGVSKGQpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgX2NoYXJ0LmdldENvbG9yKTtcclxuXHJcbiAgICAgICAgICAgIF9jaGFydC5kb1VwZGF0ZUxhYmVscyhub2RlRyk7XHJcblxyXG4gICAgICAgICAgICBfY2hhcnQuZG9VcGRhdGVUaXRsZXMobm9kZUcpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIF9jaGFydC5kZWJ1ZyA9IGZ1bmN0aW9uIChmbGFnKSB7XHJcbiAgICAgICAgaWYgKGZsYWcpIHtcclxuICAgICAgICAgICAgdmFyIGRlYnVnRyA9IF9jaGFydC5zZWxlY3QoJ2cuJyArIGRjLmNvbnN0YW50cy5ERUJVR19HUk9VUF9DTEFTUyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoZGVidWdHLmVtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIGRlYnVnRyA9IF9jaGFydC5zdmcoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGRjLmNvbnN0YW50cy5ERUJVR19HUk9VUF9DTEFTUyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBkZWJ1Z1RleHQgPSBkZWJ1Z0cuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgMTApXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIDIwKTtcclxuXHJcbiAgICAgICAgICAgIGRlYnVnR1xyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgncmVjdCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBfY2hhcnQud2lkdGgoKSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBfY2hhcnQuaGVpZ2h0KCkpXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBkMy5tb3VzZShkZWJ1Z0cubm9kZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbXNnID0gcG9zaXRpb25bMF0gKyAnLCAnICsgcG9zaXRpb25bMV07XHJcbiAgICAgICAgICAgICAgICAgICAgZGVidWdUZXh0LnRleHQobXNnKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIF9jaGFydC5zZWxlY3RBbGwoJy5kZWJ1ZycpLnJlbW92ZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgX2NoYXJ0LmFuY2hvcihwYXJlbnQsIGNoYXJ0R3JvdXApO1xyXG5cclxuICAgIHJldHVybiBfY2hhcnQ7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29uY3JldGUgcm93IGNoYXJ0IGltcGxlbWVudGF0aW9uLlxyXG4gKlxyXG4gKiBFeGFtcGxlczpcclxuICogLSB7QGxpbmsgaHR0cDovL2RjLWpzLmdpdGh1Yi5jb20vZGMuanMvIE5hc2RhcSAxMDAgSW5kZXh9XHJcbiAqIEBjbGFzcyByb3dDaGFydFxyXG4gKiBAbWVtYmVyb2YgZGNcclxuICogQG1peGVzIGRjLmNhcE1peGluXHJcbiAqIEBtaXhlcyBkYy5tYXJnaW5NaXhpblxyXG4gKiBAbWl4ZXMgZGMuY29sb3JNaXhpblxyXG4gKiBAbWl4ZXMgZGMuYmFzZU1peGluXHJcbiAqIEBleGFtcGxlXHJcbiAqIC8vIGNyZWF0ZSBhIHJvdyBjaGFydCB1bmRlciAjY2hhcnQtY29udGFpbmVyMSBlbGVtZW50IHVzaW5nIHRoZSBkZWZhdWx0IGdsb2JhbCBjaGFydCBncm91cFxyXG4gKiB2YXIgY2hhcnQxID0gZGMucm93Q2hhcnQoJyNjaGFydC1jb250YWluZXIxJyk7XHJcbiAqIC8vIGNyZWF0ZSBhIHJvdyBjaGFydCB1bmRlciAjY2hhcnQtY29udGFpbmVyMiBlbGVtZW50IHVzaW5nIGNoYXJ0IGdyb3VwIEFcclxuICogdmFyIGNoYXJ0MiA9IGRjLnJvd0NoYXJ0KCcjY2hhcnQtY29udGFpbmVyMicsICdjaGFydEdyb3VwQScpO1xyXG4gKiBAcGFyYW0ge1N0cmluZ3xub2RlfGQzLnNlbGVjdGlvbn0gcGFyZW50IC0gQW55IHZhbGlkXHJcbiAqIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2VsZWN0aW9uL2Jsb2IvbWFzdGVyL1JFQURNRS5tZCNzZWxlY3QgZDMgc2luZ2xlIHNlbGVjdG9yfSBzcGVjaWZ5aW5nXHJcbiAqIGEgZG9tIGJsb2NrIGVsZW1lbnQgc3VjaCBhcyBhIGRpdjsgb3IgYSBkb20gZWxlbWVudCBvciBkMyBzZWxlY3Rpb24uXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbY2hhcnRHcm91cF0gLSBUaGUgbmFtZSBvZiB0aGUgY2hhcnQgZ3JvdXAgdGhpcyBjaGFydCBpbnN0YW5jZSBzaG91bGQgYmUgcGxhY2VkIGluLlxyXG4gKiBJbnRlcmFjdGlvbiB3aXRoIGEgY2hhcnQgd2lsbCBvbmx5IHRyaWdnZXIgZXZlbnRzIGFuZCByZWRyYXdzIHdpdGhpbiB0aGUgY2hhcnQncyBncm91cC5cclxuICogQHJldHVybnMge2RjLnJvd0NoYXJ0fVxyXG4gKi9cclxuZGMucm93Q2hhcnQgPSBmdW5jdGlvbiAocGFyZW50LCBjaGFydEdyb3VwKSB7XHJcblxyXG4gICAgdmFyIF9nO1xyXG5cclxuICAgIHZhciBfbGFiZWxPZmZzZXRYID0gMTA7XHJcbiAgICB2YXIgX2xhYmVsT2Zmc2V0WSA9IDE1O1xyXG4gICAgdmFyIF9oYXNMYWJlbE9mZnNldFkgPSBmYWxzZTtcclxuICAgIHZhciBfZHlPZmZzZXQgPSAnMC4zNWVtJzsgIC8vIHRoaXMgaGVscHMgY2VudGVyIGxhYmVscyBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtMy54LWFwaS1yZWZlcmVuY2UvYmxvYi9tYXN0ZXIvU1ZHLVNoYXBlcy5tZCNzdmdfdGV4dFxyXG4gICAgdmFyIF90aXRsZUxhYmVsT2Zmc2V0WCA9IDI7XHJcblxyXG4gICAgdmFyIF9nYXAgPSA1O1xyXG5cclxuICAgIHZhciBfZml4ZWRCYXJIZWlnaHQgPSBmYWxzZTtcclxuICAgIHZhciBfcm93Q3NzQ2xhc3MgPSAncm93JztcclxuICAgIHZhciBfdGl0bGVSb3dDc3NDbGFzcyA9ICd0aXRsZXJvdyc7XHJcbiAgICB2YXIgX3JlbmRlclRpdGxlTGFiZWwgPSBmYWxzZTtcclxuXHJcbiAgICB2YXIgX2NoYXJ0ID0gZGMuY2FwTWl4aW4oZGMubWFyZ2luTWl4aW4oZGMuY29sb3JNaXhpbihkYy5iYXNlTWl4aW4oe30pKSkpO1xyXG5cclxuICAgIHZhciBfeDtcclxuXHJcbiAgICB2YXIgX2VsYXN0aWNYO1xyXG5cclxuICAgIHZhciBfeEF4aXMgPSBkMy5heGlzQm90dG9tKCk7XHJcblxyXG4gICAgdmFyIF9yb3dEYXRhO1xyXG5cclxuICAgIF9jaGFydC5yb3dzQ2FwID0gX2NoYXJ0LmNhcDtcclxuXHJcbiAgICBmdW5jdGlvbiBjYWxjdWxhdGVBeGlzU2NhbGUgKCkge1xyXG4gICAgICAgIGlmICghX3ggfHwgX2VsYXN0aWNYKSB7XHJcbiAgICAgICAgICAgIHZhciBleHRlbnQgPSBkMy5leHRlbnQoX3Jvd0RhdGEsIF9jaGFydC5jYXBwZWRWYWx1ZUFjY2Vzc29yKTtcclxuICAgICAgICAgICAgaWYgKGV4dGVudFswXSA+IDApIHtcclxuICAgICAgICAgICAgICAgIGV4dGVudFswXSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGV4dGVudFsxXSA8IDApIHtcclxuICAgICAgICAgICAgICAgIGV4dGVudFsxXSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3ggPSBkMy5zY2FsZUxpbmVhcigpLmRvbWFpbihleHRlbnQpXHJcbiAgICAgICAgICAgICAgICAucmFuZ2UoWzAsIF9jaGFydC5lZmZlY3RpdmVXaWR0aCgpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF94QXhpcy5zY2FsZShfeCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd0F4aXMgKCkge1xyXG4gICAgICAgIHZhciBheGlzRyA9IF9nLnNlbGVjdCgnZy5heGlzJyk7XHJcblxyXG4gICAgICAgIGNhbGN1bGF0ZUF4aXNTY2FsZSgpO1xyXG5cclxuICAgICAgICBpZiAoYXhpc0cuZW1wdHkoKSkge1xyXG4gICAgICAgICAgICBheGlzRyA9IF9nLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ2F4aXMnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXhpc0cuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCAnICsgX2NoYXJ0LmVmZmVjdGl2ZUhlaWdodCgpICsgJyknKTtcclxuXHJcbiAgICAgICAgZGMudHJhbnNpdGlvbihheGlzRywgX2NoYXJ0LnRyYW5zaXRpb25EdXJhdGlvbigpLCBfY2hhcnQudHJhbnNpdGlvbkRlbGF5KCkpXHJcbiAgICAgICAgICAgIC5jYWxsKF94QXhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgX2NoYXJ0Ll9kb1JlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfY2hhcnQucmVzZXRTdmcoKTtcclxuXHJcbiAgICAgICAgX2cgPSBfY2hhcnQuc3ZnKClcclxuICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBfY2hhcnQubWFyZ2lucygpLmxlZnQgKyAnLCcgKyBfY2hhcnQubWFyZ2lucygpLnRvcCArICcpJyk7XHJcblxyXG4gICAgICAgIGRyYXdDaGFydCgpO1xyXG5cclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICBfY2hhcnQudGl0bGUoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0LmNhcHBlZEtleUFjY2Vzc29yKGQpICsgJzogJyArIF9jaGFydC5jYXBwZWRWYWx1ZUFjY2Vzc29yKGQpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgX2NoYXJ0LmxhYmVsKF9jaGFydC5jYXBwZWRLZXlBY2Nlc3Nvcik7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIHggc2NhbGUuIFRoZSB4IHNjYWxlIGNhbiBiZSBhbnkgZDNcclxuICAgICAqIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2NhbGUvYmxvYi9tYXN0ZXIvUkVBRE1FLm1kIGQzLnNjYWxlfS5cclxuICAgICAqIEBtZXRob2QgeFxyXG4gICAgICogQG1lbWJlcm9mIGRjLnJvd0NoYXJ0XHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1zY2FsZS9ibG9iL21hc3Rlci9SRUFETUUubWQgZDMuc2NhbGV9XHJcbiAgICAgKiBAcGFyYW0ge2QzLnNjYWxlfSBbc2NhbGVdXHJcbiAgICAgKiBAcmV0dXJucyB7ZDMuc2NhbGV8ZGMucm93Q2hhcnR9XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC54ID0gZnVuY3Rpb24gKHNjYWxlKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfeDtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3ggPSBzY2FsZTtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3R3JpZExpbmVzICgpIHtcclxuICAgICAgICBfZy5zZWxlY3RBbGwoJ2cudGljaycpXHJcbiAgICAgICAgICAgIC5zZWxlY3QoJ2xpbmUuZ3JpZC1saW5lJylcclxuICAgICAgICAgICAgLnJlbW92ZSgpO1xyXG5cclxuICAgICAgICBfZy5zZWxlY3RBbGwoJ2cudGljaycpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZ3JpZC1saW5lJylcclxuICAgICAgICAgICAgLmF0dHIoJ3gxJywgMClcclxuICAgICAgICAgICAgLmF0dHIoJ3kxJywgMClcclxuICAgICAgICAgICAgLmF0dHIoJ3gyJywgMClcclxuICAgICAgICAgICAgLmF0dHIoJ3kyJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC1fY2hhcnQuZWZmZWN0aXZlSGVpZ2h0KCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRyYXdDaGFydCAoKSB7XHJcbiAgICAgICAgX3Jvd0RhdGEgPSBfY2hhcnQuZGF0YSgpO1xyXG5cclxuICAgICAgICBkcmF3QXhpcygpO1xyXG4gICAgICAgIGRyYXdHcmlkTGluZXMoKTtcclxuXHJcbiAgICAgICAgdmFyIHJvd3MgPSBfZy5zZWxlY3RBbGwoJ2cuJyArIF9yb3dDc3NDbGFzcylcclxuICAgICAgICAgICAgLmRhdGEoX3Jvd0RhdGEpO1xyXG5cclxuICAgICAgICByZW1vdmVFbGVtZW50cyhyb3dzKTtcclxuICAgICAgICByb3dzID0gY3JlYXRlRWxlbWVudHMocm93cylcclxuICAgICAgICAgICAgLm1lcmdlKHJvd3MpO1xyXG4gICAgICAgIHVwZGF0ZUVsZW1lbnRzKHJvd3MpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRzIChyb3dzKSB7XHJcbiAgICAgICAgdmFyIHJvd0VudGVyID0gcm93cy5lbnRlcigpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9yb3dDc3NDbGFzcyArICcgXycgKyBpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcm93RW50ZXIuYXBwZW5kKCdyZWN0JykuYXR0cignd2lkdGgnLCAwKTtcclxuXHJcbiAgICAgICAgY3JlYXRlTGFiZWxzKHJvd0VudGVyKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJvd0VudGVyO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlbW92ZUVsZW1lbnRzIChyb3dzKSB7XHJcbiAgICAgICAgcm93cy5leGl0KCkucmVtb3ZlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcm9vdFZhbHVlICgpIHtcclxuICAgICAgICB2YXIgcm9vdCA9IF94KDApO1xyXG4gICAgICAgIHJldHVybiAocm9vdCA9PT0gLUluZmluaXR5IHx8IHJvb3QgIT09IHJvb3QpID8gX3goMSkgOiByb290O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZUVsZW1lbnRzIChyb3dzKSB7XHJcbiAgICAgICAgdmFyIG4gPSBfcm93RGF0YS5sZW5ndGg7XHJcblxyXG4gICAgICAgIHZhciBoZWlnaHQ7XHJcbiAgICAgICAgaWYgKCFfZml4ZWRCYXJIZWlnaHQpIHtcclxuICAgICAgICAgICAgaGVpZ2h0ID0gKF9jaGFydC5lZmZlY3RpdmVIZWlnaHQoKSAtIChuICsgMSkgKiBfZ2FwKSAvIG47XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaGVpZ2h0ID0gX2ZpeGVkQmFySGVpZ2h0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gdmVydGljYWxseSBhbGlnbiBsYWJlbCBpbiBjZW50ZXIgdW5sZXNzIHRoZXkgb3ZlcnJpZGUgdGhlIHZhbHVlIHZpYSBwcm9wZXJ0eSBzZXR0ZXJcclxuICAgICAgICBpZiAoIV9oYXNMYWJlbE9mZnNldFkpIHtcclxuICAgICAgICAgICAgX2xhYmVsT2Zmc2V0WSA9IGhlaWdodCAvIDI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcmVjdCA9IHJvd3MuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKDAsJyArICgoaSArIDEpICogX2dhcCArIGkgKiBoZWlnaHQpICsgJyknO1xyXG4gICAgICAgICAgICB9KS5zZWxlY3QoJ3JlY3QnKVxyXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgaGVpZ2h0KVxyXG4gICAgICAgICAgICAuYXR0cignZmlsbCcsIF9jaGFydC5nZXRDb2xvcilcclxuICAgICAgICAgICAgLm9uKCdjbGljaycsIG9uQ2xpY2spXHJcbiAgICAgICAgICAgIC5jbGFzc2VkKCdkZXNlbGVjdGVkJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoX2NoYXJ0Lmhhc0ZpbHRlcigpKSA/ICFpc1NlbGVjdGVkUm93KGQpIDogZmFsc2U7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5jbGFzc2VkKCdzZWxlY3RlZCcsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKF9jaGFydC5oYXNGaWx0ZXIoKSkgPyBpc1NlbGVjdGVkUm93KGQpIDogZmFsc2U7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICBkYy50cmFuc2l0aW9uKHJlY3QsIF9jaGFydC50cmFuc2l0aW9uRHVyYXRpb24oKSwgX2NoYXJ0LnRyYW5zaXRpb25EZWxheSgpKVxyXG4gICAgICAgICAgICAuYXR0cignd2lkdGgnLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHJvb3RWYWx1ZSgpIC0gX3goX2NoYXJ0LnZhbHVlQWNjZXNzb3IoKShkKSkpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgdHJhbnNsYXRlWCk7XHJcblxyXG4gICAgICAgIGNyZWF0ZVRpdGxlcyhyb3dzKTtcclxuICAgICAgICB1cGRhdGVMYWJlbHMocm93cyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlVGl0bGVzIChyb3dzKSB7XHJcbiAgICAgICAgaWYgKF9jaGFydC5yZW5kZXJUaXRsZSgpKSB7XHJcbiAgICAgICAgICAgIHJvd3Muc2VsZWN0KCd0aXRsZScpLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICByb3dzLmFwcGVuZCgndGl0bGUnKS50ZXh0KF9jaGFydC50aXRsZSgpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlTGFiZWxzIChyb3dFbnRlcikge1xyXG4gICAgICAgIGlmIChfY2hhcnQucmVuZGVyTGFiZWwoKSkge1xyXG4gICAgICAgICAgICByb3dFbnRlci5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLm9uKCdjbGljaycsIG9uQ2xpY2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoX2NoYXJ0LnJlbmRlclRpdGxlTGFiZWwoKSkge1xyXG4gICAgICAgICAgICByb3dFbnRlci5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgX3RpdGxlUm93Q3NzQ2xhc3MpXHJcbiAgICAgICAgICAgICAgICAub24oJ2NsaWNrJywgb25DbGljayk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZUxhYmVscyAocm93cykge1xyXG4gICAgICAgIGlmIChfY2hhcnQucmVuZGVyTGFiZWwoKSkge1xyXG4gICAgICAgICAgICB2YXIgbGFiID0gcm93cy5zZWxlY3QoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBfbGFiZWxPZmZzZXRYKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBfbGFiZWxPZmZzZXRZKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgX2R5T2Zmc2V0KVxyXG4gICAgICAgICAgICAgICAgLm9uKCdjbGljaycsIG9uQ2xpY2spXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfcm93Q3NzQ2xhc3MgKyAnIF8nICsgaTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAudGV4dChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfY2hhcnQubGFiZWwoKShkKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBkYy50cmFuc2l0aW9uKGxhYiwgX2NoYXJ0LnRyYW5zaXRpb25EdXJhdGlvbigpLCBfY2hhcnQudHJhbnNpdGlvbkRlbGF5KCkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgdHJhbnNsYXRlWCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChfY2hhcnQucmVuZGVyVGl0bGVMYWJlbCgpKSB7XHJcbiAgICAgICAgICAgIHZhciB0aXRsZWxhYiA9IHJvd3Muc2VsZWN0KCcuJyArIF90aXRsZVJvd0Nzc0NsYXNzKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgX2NoYXJ0LmVmZmVjdGl2ZVdpZHRoKCkgLSBfdGl0bGVMYWJlbE9mZnNldFgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBfbGFiZWxPZmZzZXRZKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsIF9keU9mZnNldClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnZW5kJylcclxuICAgICAgICAgICAgICAgICAgICAub24oJ2NsaWNrJywgb25DbGljaylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RpdGxlUm93Q3NzQ2xhc3MgKyAnIF8nICsgaSA7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAudGV4dChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NoYXJ0LnRpdGxlKCkoZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGRjLnRyYW5zaXRpb24odGl0bGVsYWIsIF9jaGFydC50cmFuc2l0aW9uRHVyYXRpb24oKSwgX2NoYXJ0LnRyYW5zaXRpb25EZWxheSgpKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIHRyYW5zbGF0ZVgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFR1cm4gb24vb2ZmIFRpdGxlIGxhYmVsIHJlbmRlcmluZyAodmFsdWVzKSB1c2luZyBTVkcgc3R5bGUgb2YgdGV4dC1hbmNob3IgJ2VuZCcuXHJcbiAgICAgKiBAbWV0aG9kIHJlbmRlclRpdGxlTGFiZWxcclxuICAgICAqIEBtZW1iZXJvZiBkYy5yb3dDaGFydFxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtyZW5kZXJUaXRsZUxhYmVsPWZhbHNlXVxyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW58ZGMucm93Q2hhcnR9XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5yZW5kZXJUaXRsZUxhYmVsID0gZnVuY3Rpb24gKHJlbmRlclRpdGxlTGFiZWwpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9yZW5kZXJUaXRsZUxhYmVsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfcmVuZGVyVGl0bGVMYWJlbCA9IHJlbmRlclRpdGxlTGFiZWw7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gb25DbGljayAoZCkge1xyXG4gICAgICAgIF9jaGFydC5vbkNsaWNrKGQpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZVggKGQpIHtcclxuICAgICAgICB2YXIgeCA9IF94KF9jaGFydC5jYXBwZWRWYWx1ZUFjY2Vzc29yKGQpKSxcclxuICAgICAgICAgICAgeDAgPSByb290VmFsdWUoKSxcclxuICAgICAgICAgICAgcyA9IHggPiB4MCA/IHgwIDogeDtcclxuICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgcyArICcsMCknO1xyXG4gICAgfVxyXG5cclxuICAgIF9jaGFydC5fZG9SZWRyYXcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZHJhd0NoYXJ0KCk7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgb3Igc2V0cyB0aGUgeCBheGlzIGZvciB0aGUgcm93IGNoYXJ0IGluc3RhbmNlLlxyXG4gICAgICogU2VlIHRoZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLWF4aXMvYmxvYi9tYXN0ZXIvUkVBRE1FLm1kIGQzLmF4aXN9XHJcbiAgICAgKiBkb2N1bWVudGlvbiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cclxuICAgICAqIEBtZXRob2QgeEF4aXNcclxuICAgICAqIEBtZW1iZXJvZiBkYy5yb3dDaGFydFxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gY3VzdG9taXplIHggYXhpcyB0aWNrIGZvcm1hdFxyXG4gICAgICogY2hhcnQueEF4aXMoKS50aWNrRm9ybWF0KGZ1bmN0aW9uICh2KSB7cmV0dXJuIHYgKyAnJSc7fSk7XHJcbiAgICAgKiAvLyBjdXN0b21pemUgeCBheGlzIHRpY2sgdmFsdWVzXHJcbiAgICAgKiBjaGFydC54QXhpcygpLnRpY2tWYWx1ZXMoWzAsIDEwMCwgMjAwLCAzMDBdKTtcclxuICAgICAqIC8vIHVzZSBhIHRvcC1vcmllbnRlZCBheGlzLiBOb3RlOiBwb3NpdGlvbiBvZiB0aGUgYXhpcyBhbmQgZ3JpZCBsaW5lcyB3aWxsIG5lZWQgdG9cclxuICAgICAqIC8vIGJlIHNldCBtYW51YWxseSwgc2VlIGh0dHBzOi8vZGMtanMuZ2l0aHViLmlvL2RjLmpzL2V4YW1wbGVzL3Jvdy10b3AtYXhpcy5odG1sXHJcbiAgICAgKiBjaGFydC54QXhpcyhkMy5heGlzVG9wKCkpXHJcbiAgICAgKiBAcmV0dXJucyB7ZDMuYXhpc31cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LnhBeGlzID0gZnVuY3Rpb24gKHhBeGlzKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfeEF4aXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF94QXhpcyA9IHhBeGlzO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBvciBzZXQgdGhlIGZpeGVkIGJhciBoZWlnaHQuIERlZmF1bHQgaXMgW2ZhbHNlXSB3aGljaCB3aWxsIGF1dG8tc2NhbGUgYmFycy5cclxuICAgICAqIEZvciBleGFtcGxlLCBpZiB5b3Ugd2FudCB0byBmaXggdGhlIGhlaWdodCBmb3IgYSBzcGVjaWZpYyBudW1iZXIgb2YgYmFycyAodXNlZnVsIGluIFRvcE4gY2hhcnRzKVxyXG4gICAgICogeW91IGNvdWxkIGZpeCBoZWlnaHQgYXMgZm9sbG93cyAod2hlcmUgY291bnQgPSB0b3RhbCBudW1iZXIgb2YgYmFycyBpbiB5b3VyIFRvcE4gYW5kIGdhcCBpc1xyXG4gICAgICogeW91ciB2ZXJ0aWNhbCBnYXAgc3BhY2UpLlxyXG4gICAgICogQG1ldGhvZCBmaXhlZEJhckhlaWdodFxyXG4gICAgICogQG1lbWJlcm9mIGRjLnJvd0NoYXJ0XHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBjaGFydC5maXhlZEJhckhlaWdodCggY2hhcnRoZWlnaHQgLSAoY291bnQgKyAxKSAqIGdhcCAvIGNvdW50KTtcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbnxOdW1iZXJ9IFtmaXhlZEJhckhlaWdodD1mYWxzZV1cclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufE51bWJlcnxkYy5yb3dDaGFydH1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LmZpeGVkQmFySGVpZ2h0ID0gZnVuY3Rpb24gKGZpeGVkQmFySGVpZ2h0KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfZml4ZWRCYXJIZWlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9maXhlZEJhckhlaWdodCA9IGZpeGVkQmFySGVpZ2h0O1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IG9yIHNldCB0aGUgdmVydGljYWwgZ2FwIHNwYWNlIGJldHdlZW4gcm93cyBvbiBhIHBhcnRpY3VsYXIgcm93IGNoYXJ0IGluc3RhbmNlLlxyXG4gICAgICogQG1ldGhvZCBnYXBcclxuICAgICAqIEBtZW1iZXJvZiBkYy5yb3dDaGFydFxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2dhcD01XVxyXG4gICAgICogQHJldHVybnMge051bWJlcnxkYy5yb3dDaGFydH1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LmdhcCA9IGZ1bmN0aW9uIChnYXApIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9nYXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9nYXAgPSBnYXA7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgb3Igc2V0IHRoZSBlbGFzdGljaXR5IG9uIHggYXhpcy4gSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRvIHRydWUsIHRoZW4gdGhlIHggYXhpcyB3aWxsIHJlc2NsZSB0byBhdXRvLWZpdCB0aGVcclxuICAgICAqIGRhdGEgcmFuZ2Ugd2hlbiBmaWx0ZXJlZC5cclxuICAgICAqIEBtZXRob2QgZWxhc3RpY1hcclxuICAgICAqIEBtZW1iZXJvZiBkYy5yb3dDaGFydFxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtlbGFzdGljWF1cclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufGRjLnJvd0NoYXJ0fVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQuZWxhc3RpY1ggPSBmdW5jdGlvbiAoZWxhc3RpY1gpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9lbGFzdGljWDtcclxuICAgICAgICB9XHJcbiAgICAgICAgX2VsYXN0aWNYID0gZWxhc3RpY1g7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgb3Igc2V0IHRoZSB4IG9mZnNldCAoaG9yaXpvbnRhbCBzcGFjZSB0byB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIGEgcm93KSBmb3IgbGFiZWxzIG9uIGEgcGFydGljdWxhciByb3cgY2hhcnQuXHJcbiAgICAgKiBAbWV0aG9kIGxhYmVsT2Zmc2V0WFxyXG4gICAgICogQG1lbWJlcm9mIGRjLnJvd0NoYXJ0XHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbbGFiZWxPZmZzZXRYPTEwXVxyXG4gICAgICogQHJldHVybnMge051bWJlcnxkYy5yb3dDaGFydH1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LmxhYmVsT2Zmc2V0WCA9IGZ1bmN0aW9uIChsYWJlbE9mZnNldFgpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9sYWJlbE9mZnNldFg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9sYWJlbE9mZnNldFggPSBsYWJlbE9mZnNldFg7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgb3Igc2V0IHRoZSB5IG9mZnNldCAodmVydGljYWwgc3BhY2UgdG8gdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiBhIHJvdykgZm9yIGxhYmVscyBvbiBhIHBhcnRpY3VsYXIgcm93IGNoYXJ0LlxyXG4gICAgICogQG1ldGhvZCBsYWJlbE9mZnNldFlcclxuICAgICAqIEBtZW1iZXJvZiBkYy5yb3dDaGFydFxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2xhYmVsT2Zmc2V0eT0xNV1cclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ8ZGMucm93Q2hhcnR9XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5sYWJlbE9mZnNldFkgPSBmdW5jdGlvbiAobGFiZWxPZmZzZXR5KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfbGFiZWxPZmZzZXRZO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfbGFiZWxPZmZzZXRZID0gbGFiZWxPZmZzZXR5O1xyXG4gICAgICAgIF9oYXNMYWJlbE9mZnNldFkgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IG9mIHNldCB0aGUgeCBvZmZzZXQgKGhvcml6b250YWwgc3BhY2UgYmV0d2VlbiByaWdodCBlZGdlIG9mIHJvdyBhbmQgcmlnaHQgZWRnZSBvciB0ZXh0LlxyXG4gICAgICogQG1ldGhvZCB0aXRsZUxhYmVsT2Zmc2V0WFxyXG4gICAgICogQG1lbWJlcm9mIGRjLnJvd0NoYXJ0XHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbdGl0bGVMYWJlbE9mZnNldFg9Ml1cclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ8ZGMucm93Q2hhcnR9XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC50aXRsZUxhYmVsT2Zmc2V0WCA9IGZ1bmN0aW9uICh0aXRsZUxhYmVsT2Zmc2V0WCkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3RpdGxlTGFiZWxPZmZzZXRYO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfdGl0bGVMYWJlbE9mZnNldFggPSB0aXRsZUxhYmVsT2Zmc2V0WDtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBpc1NlbGVjdGVkUm93IChkKSB7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydC5oYXNGaWx0ZXIoX2NoYXJ0LmNhcHBlZEtleUFjY2Vzc29yKGQpKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gX2NoYXJ0LmFuY2hvcihwYXJlbnQsIGNoYXJ0R3JvdXApO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIExlZ2VuZCBpcyBhIGF0dGFjaGFibGUgd2lkZ2V0IHRoYXQgY2FuIGJlIGFkZGVkIHRvIG90aGVyIGRjIGNoYXJ0cyB0byByZW5kZXIgaG9yaXpvbnRhbCBsZWdlbmRcclxuICogbGFiZWxzLlxyXG4gKlxyXG4gKiBFeGFtcGxlczpcclxuICogLSB7QGxpbmsgaHR0cDovL2RjLWpzLmdpdGh1Yi5jb20vZGMuanMvIE5hc2RhcSAxMDAgSW5kZXh9XHJcbiAqIC0ge0BsaW5rIGh0dHA6Ly9kYy1qcy5naXRodWIuY29tL2RjLmpzL2NyaW1lL2luZGV4Lmh0bWwgQ2FuYWRpYW4gQ2l0eSBDcmltZSBTdGF0c31cclxuICogQGNsYXNzIGxlZ2VuZFxyXG4gKiBAbWVtYmVyb2YgZGNcclxuICogQGV4YW1wbGVcclxuICogY2hhcnQubGVnZW5kKGRjLmxlZ2VuZCgpLngoNDAwKS55KDEwKS5pdGVtSGVpZ2h0KDEzKS5nYXAoNSkpXHJcbiAqIEByZXR1cm5zIHtkYy5sZWdlbmR9XHJcbiAqL1xyXG5kYy5sZWdlbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgTEFCRUxfR0FQID0gMjtcclxuXHJcbiAgICB2YXIgX2xlZ2VuZCA9IHt9LFxyXG4gICAgICAgIF9wYXJlbnQsXHJcbiAgICAgICAgX3ggPSAwLFxyXG4gICAgICAgIF95ID0gMCxcclxuICAgICAgICBfaXRlbUhlaWdodCA9IDEyLFxyXG4gICAgICAgIF9nYXAgPSA1LFxyXG4gICAgICAgIF9ob3Jpem9udGFsID0gZmFsc2UsXHJcbiAgICAgICAgX2xlZ2VuZFdpZHRoID0gNTYwLFxyXG4gICAgICAgIF9pdGVtV2lkdGggPSA3MCxcclxuICAgICAgICBfYXV0b0l0ZW1XaWR0aCA9IGZhbHNlLFxyXG4gICAgICAgIF9sZWdlbmRUZXh0ID0gZGMucGx1Y2soJ25hbWUnKSxcclxuICAgICAgICBfbWF4SXRlbXM7XHJcblxyXG4gICAgdmFyIF9nO1xyXG5cclxuICAgIF9sZWdlbmQucGFyZW50ID0gZnVuY3Rpb24gKHApIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9wYXJlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9wYXJlbnQgPSBwO1xyXG4gICAgICAgIHJldHVybiBfbGVnZW5kO1xyXG4gICAgfTtcclxuXHJcbiAgICBfbGVnZW5kLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfcGFyZW50LnN2ZygpLnNlbGVjdCgnZy5kYy1sZWdlbmQnKS5yZW1vdmUoKTtcclxuICAgICAgICBfZyA9IF9wYXJlbnQuc3ZnKCkuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2RjLWxlZ2VuZCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBfeCArICcsJyArIF95ICsgJyknKTtcclxuICAgICAgICB2YXIgbGVnZW5kYWJsZXMgPSBfcGFyZW50LmxlZ2VuZGFibGVzKCk7XHJcblxyXG4gICAgICAgIGlmIChfbWF4SXRlbXMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBsZWdlbmRhYmxlcyA9IGxlZ2VuZGFibGVzLnNsaWNlKDAsIF9tYXhJdGVtcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaXRlbUVudGVyID0gX2cuc2VsZWN0QWxsKCdnLmRjLWxlZ2VuZC1pdGVtJylcclxuICAgICAgICAgICAgLmRhdGEobGVnZW5kYWJsZXMpXHJcbiAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZGMtbGVnZW5kLWl0ZW0nKVxyXG4gICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICBfcGFyZW50LmxlZ2VuZEhpZ2hsaWdodChkKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICBfcGFyZW50LmxlZ2VuZFJlc2V0KGQpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAub24oJ2NsaWNrJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIGQuY2hhcnQubGVnZW5kVG9nZ2xlKGQpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgX2cuc2VsZWN0QWxsKCdnLmRjLWxlZ2VuZC1pdGVtJylcclxuICAgICAgICAgICAgLmNsYXNzZWQoJ2ZhZGVvdXQnLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQuY2hhcnQuaXNMZWdlbmRhYmxlSGlkZGVuKGQpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKGxlZ2VuZGFibGVzLnNvbWUoZGMucGx1Y2soJ2Rhc2hzdHlsZScpKSkge1xyXG4gICAgICAgICAgICBpdGVtRW50ZXJcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgMClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIF9pdGVtSGVpZ2h0IC8gMilcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4MicsIF9pdGVtSGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgX2l0ZW1IZWlnaHQgLyAyKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIDIpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlLWRhc2hhcnJheScsIGRjLnBsdWNrKCdkYXNoc3R5bGUnKSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCBkYy5wbHVjaygnY29sb3InKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaXRlbUVudGVyXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIF9pdGVtSGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIF9pdGVtSGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCBmdW5jdGlvbiAoZCkge3JldHVybiBkID8gZC5jb2xvciA6ICdibHVlJzt9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGl0ZW1FbnRlci5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgLnRleHQoX2xlZ2VuZFRleHQpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIF9pdGVtSGVpZ2h0ICsgTEFCRUxfR0FQKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9pdGVtSGVpZ2h0IC8gMiArICh0aGlzLmNsaWVudEhlaWdodCA/IHRoaXMuY2xpZW50SGVpZ2h0IDogMTMpIC8gMiAtIDI7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdmFyIF9jdW11bGF0aXZlTGVnZW5kVGV4dFdpZHRoID0gMDtcclxuICAgICAgICB2YXIgcm93ID0gMDtcclxuICAgICAgICBpdGVtRW50ZXIuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgaWYgKF9ob3Jpem9udGFsKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXRlbVdpZHRoICAgPSBfYXV0b0l0ZW1XaWR0aCA9PT0gdHJ1ZSA/IHRoaXMuZ2V0QkJveCgpLndpZHRoICsgX2dhcCA6IF9pdGVtV2lkdGg7XHJcbiAgICAgICAgICAgICAgICBpZiAoKF9jdW11bGF0aXZlTGVnZW5kVGV4dFdpZHRoICsgaXRlbVdpZHRoKSA+IF9sZWdlbmRXaWR0aCAmJiBfY3VtdWxhdGl2ZUxlZ2VuZFRleHRXaWR0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICArK3JvdztcclxuICAgICAgICAgICAgICAgICAgICBfY3VtdWxhdGl2ZUxlZ2VuZFRleHRXaWR0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnNsYXRlQnkgPSAndHJhbnNsYXRlKCcgKyBfY3VtdWxhdGl2ZUxlZ2VuZFRleHRXaWR0aCArICcsJyArIHJvdyAqIGxlZ2VuZEl0ZW1IZWlnaHQoKSArICcpJztcclxuICAgICAgICAgICAgICAgIF9jdW11bGF0aXZlTGVnZW5kVGV4dFdpZHRoICs9IGl0ZW1XaWR0aDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2xhdGVCeTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKDAsJyArIGkgKiBsZWdlbmRJdGVtSGVpZ2h0KCkgKyAnKSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gbGVnZW5kSXRlbUhlaWdodCAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9nYXAgKyBfaXRlbUhlaWdodDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBvciBnZXQgeCBjb29yZGluYXRlIGZvciBsZWdlbmQgd2lkZ2V0LlxyXG4gICAgICogQG1ldGhvZCB4XHJcbiAgICAgKiBAbWVtYmVyb2YgZGMubGVnZW5kXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gW3g9MF1cclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ8ZGMubGVnZW5kfVxyXG4gICAgICovXHJcbiAgICBfbGVnZW5kLnggPSBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF94ID0geDtcclxuICAgICAgICByZXR1cm4gX2xlZ2VuZDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgb3IgZ2V0IHkgY29vcmRpbmF0ZSBmb3IgbGVnZW5kIHdpZGdldC5cclxuICAgICAqIEBtZXRob2QgeVxyXG4gICAgICogQG1lbWJlcm9mIGRjLmxlZ2VuZFxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFt5PTBdXHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfGRjLmxlZ2VuZH1cclxuICAgICAqL1xyXG4gICAgX2xlZ2VuZC55ID0gZnVuY3Rpb24gKHkpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF95O1xyXG4gICAgICAgIH1cclxuICAgICAgICBfeSA9IHk7XHJcbiAgICAgICAgcmV0dXJuIF9sZWdlbmQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IG9yIGdldCBnYXAgYmV0d2VlbiBsZWdlbmQgaXRlbXMuXHJcbiAgICAgKiBAbWV0aG9kIGdhcFxyXG4gICAgICogQG1lbWJlcm9mIGRjLmxlZ2VuZFxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtnYXA9NV1cclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ8ZGMubGVnZW5kfVxyXG4gICAgICovXHJcbiAgICBfbGVnZW5kLmdhcCA9IGZ1bmN0aW9uIChnYXApIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9nYXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9nYXAgPSBnYXA7XHJcbiAgICAgICAgcmV0dXJuIF9sZWdlbmQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IG9yIGdldCBsZWdlbmQgaXRlbSBoZWlnaHQuXHJcbiAgICAgKiBAbWV0aG9kIGl0ZW1IZWlnaHRcclxuICAgICAqIEBtZW1iZXJvZiBkYy5sZWdlbmRcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBbaXRlbUhlaWdodD0xMl1cclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ8ZGMubGVnZW5kfVxyXG4gICAgICovXHJcbiAgICBfbGVnZW5kLml0ZW1IZWlnaHQgPSBmdW5jdGlvbiAoaXRlbUhlaWdodCkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2l0ZW1IZWlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9pdGVtSGVpZ2h0ID0gaXRlbUhlaWdodDtcclxuICAgICAgICByZXR1cm4gX2xlZ2VuZDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQb3NpdGlvbiBsZWdlbmQgaG9yaXpvbnRhbGx5IGluc3RlYWQgb2YgdmVydGljYWxseS5cclxuICAgICAqIEBtZXRob2QgaG9yaXpvbnRhbFxyXG4gICAgICogQG1lbWJlcm9mIGRjLmxlZ2VuZFxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBbaG9yaXpvbnRhbD1mYWxzZV1cclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufGRjLmxlZ2VuZH1cclxuICAgICAqL1xyXG4gICAgX2xlZ2VuZC5ob3Jpem9udGFsID0gZnVuY3Rpb24gKGhvcml6b250YWwpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9ob3Jpem9udGFsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfaG9yaXpvbnRhbCA9IGhvcml6b250YWw7XHJcbiAgICAgICAgcmV0dXJuIF9sZWdlbmQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWF4aW11bSB3aWR0aCBmb3IgaG9yaXpvbnRhbCBsZWdlbmQuXHJcbiAgICAgKiBAbWV0aG9kIGxlZ2VuZFdpZHRoXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMubGVnZW5kXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gW2xlZ2VuZFdpZHRoPTUwMF1cclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ8ZGMubGVnZW5kfVxyXG4gICAgICovXHJcbiAgICBfbGVnZW5kLmxlZ2VuZFdpZHRoID0gZnVuY3Rpb24gKGxlZ2VuZFdpZHRoKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfbGVnZW5kV2lkdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9sZWdlbmRXaWR0aCA9IGxlZ2VuZFdpZHRoO1xyXG4gICAgICAgIHJldHVybiBfbGVnZW5kO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExlZ2VuZCBpdGVtIHdpZHRoIGZvciBob3Jpem9udGFsIGxlZ2VuZC5cclxuICAgICAqIEBtZXRob2QgaXRlbVdpZHRoXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMubGVnZW5kXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gW2l0ZW1XaWR0aD03MF1cclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ8ZGMubGVnZW5kfVxyXG4gICAgICovXHJcbiAgICBfbGVnZW5kLml0ZW1XaWR0aCA9IGZ1bmN0aW9uIChpdGVtV2lkdGgpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9pdGVtV2lkdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9pdGVtV2lkdGggPSBpdGVtV2lkdGg7XHJcbiAgICAgICAgcmV0dXJuIF9sZWdlbmQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHVybiBhdXRvbWF0aWMgd2lkdGggZm9yIGxlZ2VuZCBpdGVtcyBvbiBvciBvZmYuIElmIHRydWUsIHtAbGluayBkYy5sZWdlbmQjaXRlbVdpZHRoIGl0ZW1XaWR0aH0gaXMgaWdub3JlZC5cclxuICAgICAqIFRoaXMgc2V0dGluZyB0YWtlcyBpbnRvIGFjY291bnQgdGhlIHtAbGluayBkYy5sZWdlbmQjZ2FwIGdhcH0uXHJcbiAgICAgKiBAbWV0aG9kIGF1dG9JdGVtV2lkdGhcclxuICAgICAqIEBtZW1iZXJvZiBkYy5sZWdlbmRcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gW2F1dG9JdGVtV2lkdGg9ZmFsc2VdXHJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbnxkYy5sZWdlbmR9XHJcbiAgICAgKi9cclxuICAgIF9sZWdlbmQuYXV0b0l0ZW1XaWR0aCA9IGZ1bmN0aW9uIChhdXRvSXRlbVdpZHRoKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfYXV0b0l0ZW1XaWR0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgX2F1dG9JdGVtV2lkdGggPSBhdXRvSXRlbVdpZHRoO1xyXG4gICAgICAgIHJldHVybiBfbGVnZW5kO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBvciBnZXQgdGhlIGxlZ2VuZCB0ZXh0IGZ1bmN0aW9uLiBUaGUgbGVnZW5kIHdpZGdldCB1c2VzIHRoaXMgZnVuY3Rpb24gdG8gcmVuZGVyIHRoZSBsZWdlbmRcclxuICAgICAqIHRleHQgZm9yIGVhY2ggaXRlbS4gSWYgbm8gZnVuY3Rpb24gaXMgc3BlY2lmaWVkIHRoZSBsZWdlbmQgd2lkZ2V0IHdpbGwgZGlzcGxheSB0aGUgbmFtZXNcclxuICAgICAqIGFzc29jaWF0ZWQgd2l0aCBlYWNoIGdyb3VwLlxyXG4gICAgICogQG1ldGhvZCBsZWdlbmRUZXh0XHJcbiAgICAgKiBAbWVtYmVyb2YgZGMubGVnZW5kXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBbbGVnZW5kVGV4dF1cclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbnxkYy5sZWdlbmR9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gZGVmYXVsdCBsZWdlbmRUZXh0XHJcbiAgICAgKiBsZWdlbmQubGVnZW5kVGV4dChkYy5wbHVjaygnbmFtZScpKVxyXG4gICAgICpcclxuICAgICAqIC8vIGNyZWF0ZSBudW1iZXJlZCBsZWdlbmQgaXRlbXNcclxuICAgICAqIGNoYXJ0LmxlZ2VuZChkYy5sZWdlbmQoKS5sZWdlbmRUZXh0KGZ1bmN0aW9uKGQsIGkpIHsgcmV0dXJuIGkgKyAnLiAnICsgZC5uYW1lOyB9KSlcclxuICAgICAqXHJcbiAgICAgKiAvLyBjcmVhdGUgbGVnZW5kIGRpc3BsYXlpbmcgZ3JvdXAgY291bnRzXHJcbiAgICAgKiBjaGFydC5sZWdlbmQoZGMubGVnZW5kKCkubGVnZW5kVGV4dChmdW5jdGlvbihkKSB7IHJldHVybiBkLm5hbWUgKyAnOiAnIGQuZGF0YTsgfSkpXHJcbiAgICAgKiovXHJcbiAgICBfbGVnZW5kLmxlZ2VuZFRleHQgPSBmdW5jdGlvbiAobGVnZW5kVGV4dCkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2xlZ2VuZFRleHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9sZWdlbmRUZXh0ID0gbGVnZW5kVGV4dDtcclxuICAgICAgICByZXR1cm4gX2xlZ2VuZDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXhpbXVtIG51bWJlciBvZiBsZWdlbmQgaXRlbXMgdG8gZGlzcGxheVxyXG4gICAgICogQG1ldGhvZCBtYXhJdGVtc1xyXG4gICAgICogQG1lbWJlcm9mIGRjLmxlZ2VuZFxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFttYXhJdGVtc11cclxuICAgICAqIEByZXR1cm4ge2RjLmxlZ2VuZH1cclxuICAgICAqL1xyXG4gICAgX2xlZ2VuZC5tYXhJdGVtcyA9IGZ1bmN0aW9uIChtYXhJdGVtcykge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX21heEl0ZW1zO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfbWF4SXRlbXMgPSBkYy51dGlscy5pc051bWJlcihtYXhJdGVtcykgPyBtYXhJdGVtcyA6IHVuZGVmaW5lZDtcclxuICAgICAgICByZXR1cm4gX2xlZ2VuZDtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIF9sZWdlbmQ7XHJcbn07XHJcblxyXG4vKipcclxuICogaHRtbExlZ2VuZCBpcyBhIGF0dGFjaGFibGUgd2lkZ2V0IHRoYXQgY2FuIGJlIGFkZGVkIHRvIG90aGVyIGRjIGNoYXJ0cyB0byByZW5kZXIgaG9yaXpvbnRhbC92ZXJ0aWNhbCBsZWdlbmRcclxuICogbGFiZWxzLlxyXG4gKlxyXG4gKiBAY2xhc3MgaHRtbExlZ2VuZFxyXG4gKiBAbWVtYmVyb2YgZGNcclxuICogQGV4YW1wbGVcclxuICogY2hhcnQubGVnZW5kKGRjLmh0bWxMZWdlbmQoKS5jb250YWluZXIobGVnZW5kQ29udGFpbmVyRWxlbWVudCkuaG9yaXpvbnRhbChmYWxzZSkpXHJcbiAqIEByZXR1cm5zIHtkYy5odG1sTGVnZW5kfVxyXG4gKi9cclxuZGMuaHRtbExlZ2VuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBfbGVnZW5kID0ge30sXHJcbiAgICAgICAgX2h0bWxMZWdlbmREaXZDc3NDbGFzcyA9ICdkYy1odG1sLWxlZ2VuZCcsXHJcbiAgICAgICAgX2xlZ2VuZEl0ZW1Dc3NDbGFzc0hvcml6b250YWwgPSAnZGMtbGVnZW5kLWl0ZW0taG9yaXpvbnRhbCcsXHJcbiAgICAgICAgX2xlZ2VuZEl0ZW1Dc3NDbGFzc1ZlcnRpY2FsID0gJ2RjLWxlZ2VuZC1pdGVtLXZlcnRpY2FsJyxcclxuICAgICAgICBfcGFyZW50LFxyXG4gICAgICAgIF9jb250YWluZXIsXHJcbiAgICAgICAgX2xlZ2VuZFRleHQgPSBkYy5wbHVjaygnbmFtZScpLFxyXG4gICAgICAgIF9tYXhJdGVtcyxcclxuICAgICAgICBfaG9yaXpvbnRhbCA9IGZhbHNlLFxyXG4gICAgICAgIF9sZWdlbmRJdGVtQ2xhc3MsXHJcbiAgICAgICAgX2hpZ2hsaWdodFNlbGVjdGVkID0gZmFsc2U7XHJcblxyXG4gICAgX2xlZ2VuZC5wYXJlbnQgPSBmdW5jdGlvbiAocCkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3BhcmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3BhcmVudCA9IHA7XHJcbiAgICAgICAgcmV0dXJuIF9sZWdlbmQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF9sZWdlbmQucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfZGVmYXVsdExlZ2VuZEl0ZW1Dc3NDbGFzcyA9IF9ob3Jpem9udGFsID8gIF9sZWdlbmRJdGVtQ3NzQ2xhc3NIb3Jpem9udGFsIDogX2xlZ2VuZEl0ZW1Dc3NDbGFzc1ZlcnRpY2FsO1xyXG4gICAgICAgIF9jb250YWluZXIuc2VsZWN0KCdkaXYuZGMtaHRtbC1sZWdlbmQnKS5yZW1vdmUoKTtcclxuXHJcbiAgICAgICAgdmFyIF9sID0gX2NvbnRhaW5lci5hcHBlbmQoJ2RpdicpLmF0dHIoJ2NsYXNzJywgX2h0bWxMZWdlbmREaXZDc3NDbGFzcyk7XHJcbiAgICAgICAgX2wuYXR0cignc3R5bGUnLCAnbWF4LXdpZHRoOicgKyBfY29udGFpbmVyLm5vZGVzKClbMF0uc3R5bGUud2lkdGgpO1xyXG5cclxuICAgICAgICB2YXIgbGVnZW5kYWJsZXMgPSBfcGFyZW50LmxlZ2VuZGFibGVzKCk7XHJcbiAgICAgICAgdmFyIGZpbHRlcnMgPSBfcGFyZW50LmZpbHRlcnMoKTtcclxuXHJcbiAgICAgICAgaWYgKF9tYXhJdGVtcyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGxlZ2VuZGFibGVzID0gbGVnZW5kYWJsZXMuc2xpY2UoMCwgX21heEl0ZW1zKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBsZWdlbmRJdGVtQ2xhc3NOYW1lID0gX2xlZ2VuZEl0ZW1DbGFzcyA/IF9sZWdlbmRJdGVtQ2xhc3MgOiBfZGVmYXVsdExlZ2VuZEl0ZW1Dc3NDbGFzcztcclxuXHJcbiAgICAgICAgdmFyIGl0ZW1FbnRlciA9IF9sLnNlbGVjdEFsbCgnZGl2LicgKyBsZWdlbmRJdGVtQ2xhc3NOYW1lKVxyXG4gICAgICAgICAgICAuZGF0YShsZWdlbmRhYmxlcykuZW50ZXIoKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdkaXYnKVxyXG4gICAgICAgICAgICAuY2xhc3NlZChsZWdlbmRJdGVtQ2xhc3NOYW1lLCB0cnVlKVxyXG4gICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIF9wYXJlbnQubGVnZW5kSGlnaGxpZ2h0KVxyXG4gICAgICAgICAgICAub24oJ21vdXNlb3V0JywgX3BhcmVudC5sZWdlbmRSZXNldClcclxuICAgICAgICAgICAgLm9uKCdjbGljaycsIF9wYXJlbnQubGVnZW5kVG9nZ2xlKTtcclxuXHJcbiAgICAgICAgaWYgKF9oaWdobGlnaHRTZWxlY3RlZCkge1xyXG4gICAgICAgICAgICBpdGVtRW50ZXIuY2xhc3NlZChkYy5jb25zdGFudHMuU0VMRUNURURfQ0xBU1MsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVycy5pbmRleE9mKGQubmFtZSkgIT09IC0xO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGl0ZW1FbnRlci5hcHBlbmQoJ3NwYW4nKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZGMtbGVnZW5kLWl0ZW0tY29sb3InKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InLCBkYy5wbHVjaygnY29sb3InKSk7XHJcblxyXG4gICAgICAgIGl0ZW1FbnRlci5hcHBlbmQoJ3NwYW4nKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZGMtbGVnZW5kLWl0ZW0tbGFiZWwnKVxyXG4gICAgICAgICAgICAuYXR0cigndGl0bGUnLCBfbGVnZW5kVGV4dClcclxuICAgICAgICAgICAgLnRleHQoX2xlZ2VuZFRleHQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAjIyMjIC5jb250YWluZXIoW3NlbGVjdG9yXSlcclxuICAgICBTZXQgdGhlIGNvbnRhaW5lciBzZWxlY3RvciBmb3IgdGhlIGxlZ2VuZCB3aWRnZXQuIFJlcXVpcmVkLlxyXG4gICAgICoqL1xyXG4gICAgX2xlZ2VuZC5jb250YWluZXIgPSBmdW5jdGlvbiAoYykge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRhaW5lcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgX2NvbnRhaW5lciA9IGQzLnNlbGVjdChjKTtcclxuICAgICAgICByZXR1cm4gX2xlZ2VuZDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgIyMjIyAubGVnZW5kSXRlbUNsYXNzKFtzZWxlY3Rvcl0pXHJcbiAgICAgVGhpcyBjYW4gYmUgb3B0aW9uYWxseSB1c2VkIHRvIG92ZXJyaWRlIGNsYXNzIGZvciBsZWdlbmRpdGVtIGFuZCBqdXN0IHVzZSB0aGlzIGNsYXNzIHN0eWxlLlxyXG4gICAgIFRoZSByZWFzb24gdG8gaGF2ZSB0aGlzIGlzIHNvIHRoaXMgY2FuIGJlIGRvbmUgZm9yIGEgcGFydGljdWxhciBjaGFydCByYXRoZXIgdGhhbiBvdmVycmlkaW5nIHRoZSBzdHlsZSBmb3IgYWxsIGNoYXJ0c1xyXG4gICAgIFNldHRpbmcgdGhpcyB3aWxsIGRpc2FibGUgdGhlIGhpZ2hsaWdodGluZyBvZiBzZWxlY3RlZCBpdGVtcyBhbHNvLlxyXG4gICAgICoqL1xyXG4gICAgX2xlZ2VuZC5sZWdlbmRJdGVtQ2xhc3MgPSBmdW5jdGlvbiAoYykge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2xlZ2VuZEl0ZW1DbGFzcztcclxuICAgICAgICB9XHJcbiAgICAgICAgX2xlZ2VuZEl0ZW1DbGFzcyA9IGM7XHJcbiAgICAgICAgcmV0dXJuIF9sZWdlbmQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICMjIyMgLmhpZ2hsaWdodFNlbGVjdGVkKFtib29sZWFuXSlcclxuICAgICBUaGlzIGNhbiBiZSBvcHRpb25hbGx5IHVzZWQgdG8gZW5hYmxlIGhpZ2hsaWdodGluZyBsZWdlbmRzIGZvciB0aGUgc2VsZWN0aW9ucy9maWx0ZXJzIGZvciB0aGUgY2hhcnQuXHJcbiAgICAgKiovXHJcbiAgICBfbGVnZW5kLmhpZ2hsaWdodFNlbGVjdGVkID0gZnVuY3Rpb24gKGMpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9oaWdobGlnaHRTZWxlY3RlZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgX2hpZ2hsaWdodFNlbGVjdGVkID0gYztcclxuICAgICAgICByZXR1cm4gX2xlZ2VuZDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgIyMjIyAuaG9yaXpvbnRhbChbYm9vbGVhbl0pXHJcbiAgICAgRGlzcGxheSB0aGUgbGVnZW5kIGhvcml6b250YWxseSBpbnN0ZWFkIG9mIGhvcml6b250YWxseVxyXG4gICAgICoqL1xyXG4gICAgX2xlZ2VuZC5ob3Jpem9udGFsID0gZnVuY3Rpb24gKGIpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9ob3Jpem9udGFsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfaG9yaXpvbnRhbCA9IGI7XHJcbiAgICAgICAgcmV0dXJuIF9sZWdlbmQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IG9yIGdldCB0aGUgbGVnZW5kIHRleHQgZnVuY3Rpb24uIFRoZSBsZWdlbmQgd2lkZ2V0IHVzZXMgdGhpcyBmdW5jdGlvbiB0byByZW5kZXIgdGhlIGxlZ2VuZFxyXG4gICAgICogdGV4dCBmb3IgZWFjaCBpdGVtLiBJZiBubyBmdW5jdGlvbiBpcyBzcGVjaWZpZWQgdGhlIGxlZ2VuZCB3aWRnZXQgd2lsbCBkaXNwbGF5IHRoZSBuYW1lc1xyXG4gICAgICogYXNzb2NpYXRlZCB3aXRoIGVhY2ggZ3JvdXAuXHJcbiAgICAgKiBAbWV0aG9kIGxlZ2VuZFRleHRcclxuICAgICAqIEBtZW1iZXJvZiBkYy5odG1sTGVnZW5kXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBbbGVnZW5kVGV4dF1cclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbnxkYy5odG1sTGVnZW5kfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGRlZmF1bHQgbGVnZW5kVGV4dFxyXG4gICAgICogbGVnZW5kLmxlZ2VuZFRleHQoZGMucGx1Y2soJ25hbWUnKSlcclxuICAgICAqXHJcbiAgICAgKiAvLyBjcmVhdGUgbnVtYmVyZWQgbGVnZW5kIGl0ZW1zXHJcbiAgICAgKiBjaGFydC5sZWdlbmQoZGMuaHRtbExlZ2VuZCgpLmxlZ2VuZFRleHQoZnVuY3Rpb24oZCwgaSkgeyByZXR1cm4gaSArICcuICcgKyBkLm5hbWU7IH0pKVxyXG4gICAgICpcclxuICAgICAqIC8vIGNyZWF0ZSBsZWdlbmQgZGlzcGxheWluZyBncm91cCBjb3VudHNcclxuICAgICAqIGNoYXJ0LmxlZ2VuZChkYy5odG1sTGVnZW5kKCkubGVnZW5kVGV4dChmdW5jdGlvbihkKSB7IHJldHVybiBkLm5hbWUgKyAnOiAnIGQuZGF0YTsgfSkpXHJcbiAgICAgKiovXHJcbiAgICBfbGVnZW5kLmxlZ2VuZFRleHQgPSBmdW5jdGlvbiAobGVnZW5kVGV4dCkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2xlZ2VuZFRleHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9sZWdlbmRUZXh0ID0gbGVnZW5kVGV4dDtcclxuICAgICAgICByZXR1cm4gX2xlZ2VuZDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXhpbXVtIG51bWJlciBvZiBsZWdlbmQgaXRlbXMgdG8gZGlzcGxheVxyXG4gICAgICogQG1ldGhvZCBtYXhJdGVtc1xyXG4gICAgICogQG1lbWJlcm9mIGRjLmh0bWxMZWdlbmRcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBbbWF4SXRlbXNdXHJcbiAgICAgKiBAcmV0dXJuIHtkYy5odG1sTGVnZW5kfVxyXG4gICAgICovXHJcbiAgICBfbGVnZW5kLm1heEl0ZW1zID0gZnVuY3Rpb24gKG1heEl0ZW1zKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfbWF4SXRlbXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9tYXhJdGVtcyA9IGRjLnV0aWxzLmlzTnVtYmVyKG1heEl0ZW1zKSA/IG1heEl0ZW1zIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIHJldHVybiBfbGVnZW5kO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gX2xlZ2VuZDtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogQSBzY2F0dGVyIHBsb3QgY2hhcnRcclxuICpcclxuICogRXhhbXBsZXM6XHJcbiAqIC0ge0BsaW5rIGh0dHA6Ly9kYy1qcy5naXRodWIuaW8vZGMuanMvZXhhbXBsZXMvc2NhdHRlci5odG1sIFNjYXR0ZXIgQ2hhcnR9XHJcbiAqIC0ge0BsaW5rIGh0dHA6Ly9kYy1qcy5naXRodWIuaW8vZGMuanMvZXhhbXBsZXMvbXVsdGktc2NhdHRlci5odG1sIE11bHRpLVNjYXR0ZXIgQ2hhcnR9XHJcbiAqIEBjbGFzcyBzY2F0dGVyUGxvdFxyXG4gKiBAbWVtYmVyb2YgZGNcclxuICogQG1peGVzIGRjLmNvb3JkaW5hdGVHcmlkTWl4aW5cclxuICogQGV4YW1wbGVcclxuICogLy8gY3JlYXRlIGEgc2NhdHRlciBwbG90IHVuZGVyICNjaGFydC1jb250YWluZXIxIGVsZW1lbnQgdXNpbmcgdGhlIGRlZmF1bHQgZ2xvYmFsIGNoYXJ0IGdyb3VwXHJcbiAqIHZhciBjaGFydDEgPSBkYy5zY2F0dGVyUGxvdCgnI2NoYXJ0LWNvbnRhaW5lcjEnKTtcclxuICogLy8gY3JlYXRlIGEgc2NhdHRlciBwbG90IHVuZGVyICNjaGFydC1jb250YWluZXIyIGVsZW1lbnQgdXNpbmcgY2hhcnQgZ3JvdXAgQVxyXG4gKiB2YXIgY2hhcnQyID0gZGMuc2NhdHRlclBsb3QoJyNjaGFydC1jb250YWluZXIyJywgJ2NoYXJ0R3JvdXBBJyk7XHJcbiAqIC8vIGNyZWF0ZSBhIHN1Yi1jaGFydCB1bmRlciBhIGNvbXBvc2l0ZSBwYXJlbnQgY2hhcnRcclxuICogdmFyIGNoYXJ0MyA9IGRjLnNjYXR0ZXJQbG90KGNvbXBvc2l0ZUNoYXJ0KTtcclxuICogQHBhcmFtIHtTdHJpbmd8bm9kZXxkMy5zZWxlY3Rpb259IHBhcmVudCAtIEFueSB2YWxpZFxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNlbGVjdGlvbi9ibG9iL21hc3Rlci9SRUFETUUubWQjc2VsZWN0IGQzIHNpbmdsZSBzZWxlY3Rvcn0gc3BlY2lmeWluZ1xyXG4gKiBhIGRvbSBibG9jayBlbGVtZW50IHN1Y2ggYXMgYSBkaXY7IG9yIGEgZG9tIGVsZW1lbnQgb3IgZDMgc2VsZWN0aW9uLlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gW2NoYXJ0R3JvdXBdIC0gVGhlIG5hbWUgb2YgdGhlIGNoYXJ0IGdyb3VwIHRoaXMgY2hhcnQgaW5zdGFuY2Ugc2hvdWxkIGJlIHBsYWNlZCBpbi5cclxuICogSW50ZXJhY3Rpb24gd2l0aCBhIGNoYXJ0IHdpbGwgb25seSB0cmlnZ2VyIGV2ZW50cyBhbmQgcmVkcmF3cyB3aXRoaW4gdGhlIGNoYXJ0J3MgZ3JvdXAuXHJcbiAqIEByZXR1cm5zIHtkYy5zY2F0dGVyUGxvdH1cclxuICovXHJcbmRjLnNjYXR0ZXJQbG90ID0gZnVuY3Rpb24gKHBhcmVudCwgY2hhcnRHcm91cCkge1xyXG4gICAgdmFyIF9jaGFydCA9IGRjLmNvb3JkaW5hdGVHcmlkTWl4aW4oe30pO1xyXG4gICAgdmFyIF9zeW1ib2wgPSBkMy5zeW1ib2woKTtcclxuXHJcbiAgICB2YXIgX2V4aXN0ZW5jZUFjY2Vzc29yID0gZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQudmFsdWU7IH07XHJcblxyXG4gICAgdmFyIG9yaWdpbmFsS2V5QWNjZXNzb3IgPSBfY2hhcnQua2V5QWNjZXNzb3IoKTtcclxuICAgIF9jaGFydC5rZXlBY2Nlc3NvcihmdW5jdGlvbiAoZCkgeyByZXR1cm4gb3JpZ2luYWxLZXlBY2Nlc3NvcihkKVswXTsgfSk7XHJcbiAgICBfY2hhcnQudmFsdWVBY2Nlc3NvcihmdW5jdGlvbiAoZCkgeyByZXR1cm4gb3JpZ2luYWxLZXlBY2Nlc3NvcihkKVsxXTsgfSk7XHJcbiAgICBfY2hhcnQuY29sb3JBY2Nlc3NvcihmdW5jdGlvbiAoKSB7IHJldHVybiBfY2hhcnQuX2dyb3VwTmFtZTsgfSk7XHJcblxyXG4gICAgX2NoYXJ0LnRpdGxlKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgLy8gdGhpcyBiYXNpY2FsbHkganVzdCBjb3VudGVyYWN0cyB0aGUgc2V0dGluZyBvZiBpdHMgb3duIGtleS92YWx1ZSBhY2Nlc3NvcnNcclxuICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2RjLWpzL2RjLmpzL2lzc3Vlcy83MDJcclxuICAgICAgICByZXR1cm4gX2NoYXJ0LmtleUFjY2Vzc29yKCkoZCkgKyAnLCcgKyBfY2hhcnQudmFsdWVBY2Nlc3NvcigpKGQpICsgJzogJyArXHJcbiAgICAgICAgICAgIF9jaGFydC5leGlzdGVuY2VBY2Nlc3NvcigpKGQpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdmFyIF9sb2NhdG9yID0gZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgX2NoYXJ0LngoKShfY2hhcnQua2V5QWNjZXNzb3IoKShkKSkgKyAnLCcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY2hhcnQueSgpKF9jaGFydC52YWx1ZUFjY2Vzc29yKCkoZCkpICsgJyknO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgX2hpZ2hsaWdodGVkU2l6ZSA9IDc7XHJcbiAgICB2YXIgX3N5bWJvbFNpemUgPSA1O1xyXG4gICAgdmFyIF9leGNsdWRlZFNpemUgPSAzO1xyXG4gICAgdmFyIF9leGNsdWRlZENvbG9yID0gbnVsbDtcclxuICAgIHZhciBfZXhjbHVkZWRPcGFjaXR5ID0gMS4wO1xyXG4gICAgdmFyIF9lbXB0eVNpemUgPSAwO1xyXG4gICAgdmFyIF9lbXB0eU9wYWNpdHkgPSAwO1xyXG4gICAgdmFyIF9ub25lbXB0eU9wYWNpdHkgPSAxO1xyXG4gICAgdmFyIF9lbXB0eUNvbG9yID0gbnVsbDtcclxuICAgIHZhciBfZmlsdGVyZWQgPSBbXTtcclxuXHJcbiAgICAvLyBVc2UgYSAyIGRpbWVuc2lvbmFsIGJydXNoXHJcbiAgICBfY2hhcnQuYnJ1c2goZDMuYnJ1c2goKSk7XHJcblxyXG4gICAgZnVuY3Rpb24gZWxlbWVudFNpemUgKGQsIGkpIHtcclxuICAgICAgICBpZiAoIV9leGlzdGVuY2VBY2Nlc3NvcihkKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5wb3coX2VtcHR5U2l6ZSwgMik7XHJcbiAgICAgICAgfSBlbHNlIGlmIChfZmlsdGVyZWRbaV0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGgucG93KF9zeW1ib2xTaXplLCAyKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5wb3coX2V4Y2x1ZGVkU2l6ZSwgMik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3N5bWJvbC5zaXplKGVsZW1lbnRTaXplKTtcclxuXHJcbiAgICBkYy5vdmVycmlkZShfY2hhcnQsICdfZmlsdGVyJywgZnVuY3Rpb24gKGZpbHRlcikge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2NoYXJ0Ll9fZmlsdGVyKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gX2NoYXJ0Ll9fZmlsdGVyKGRjLmZpbHRlcnMuUmFuZ2VkVHdvRGltZW5zaW9uYWxGaWx0ZXIoZmlsdGVyKSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBfY2hhcnQucGxvdERhdGEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHN5bWJvbHMgPSBfY2hhcnQuY2hhcnRCb2R5RygpLnNlbGVjdEFsbCgncGF0aC5zeW1ib2wnKVxyXG4gICAgICAgICAgICAuZGF0YShfY2hhcnQuZGF0YSgpKTtcclxuXHJcbiAgICAgICAgZGMudHJhbnNpdGlvbihzeW1ib2xzLmV4aXQoKSwgX2NoYXJ0LnRyYW5zaXRpb25EdXJhdGlvbigpLCBfY2hhcnQudHJhbnNpdGlvbkRlbGF5KCkpXHJcbiAgICAgICAgICAgIC5hdHRyKCdvcGFjaXR5JywgMCkucmVtb3ZlKCk7XHJcblxyXG4gICAgICAgIHN5bWJvbHMgPSBzeW1ib2xzXHJcbiAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdzeW1ib2wnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ29wYWNpdHknLCAwKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCBcIl9jaGFydC5nZXRDb2xvclwiKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIF9sb2NhdG9yKVxyXG4gICAgICAgICAgICAubWVyZ2Uoc3ltYm9scyk7XHJcblxyXG4gICAgICAgIHN5bWJvbHMuY2FsbChyZW5kZXJUaXRsZXMsIF9jaGFydC5kYXRhKCkpO1xyXG5cclxuICAgICAgICBzeW1ib2xzLmVhY2goZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgX2ZpbHRlcmVkW2ldID0gIV9jaGFydC5maWx0ZXIoKSB8fCBfY2hhcnQuZmlsdGVyKCkuaXNGaWx0ZXJlZChbX2NoYXJ0LmtleUFjY2Vzc29yKCkoZCksIF9jaGFydC52YWx1ZUFjY2Vzc29yKCkoZCldKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZGMudHJhbnNpdGlvbihzeW1ib2xzLCBfY2hhcnQudHJhbnNpdGlvbkR1cmF0aW9uKCksIF9jaGFydC50cmFuc2l0aW9uRGVsYXkoKSlcclxuICAgICAgICAgICAgLmF0dHIoJ29wYWNpdHknLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFfZXhpc3RlbmNlQWNjZXNzb3IoZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2VtcHR5T3BhY2l0eTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoX2ZpbHRlcmVkW2ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9ub25lbXB0eU9wYWNpdHk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfY2hhcnQuZXhjbHVkZWRPcGFjaXR5KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChfZW1wdHlDb2xvciAmJiAhX2V4aXN0ZW5jZUFjY2Vzc29yKGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9lbXB0eUNvbG9yO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChfY2hhcnQuZXhjbHVkZWRDb2xvcigpICYmICFfZmlsdGVyZWRbaV0pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NoYXJ0LmV4Y2x1ZGVkQ29sb3IoKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jaGFydC5nZXRDb2xvcihkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIF9sb2NhdG9yKVxyXG4gICAgICAgICAgICAuYXR0cignZCcsIF9zeW1ib2wpO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiByZW5kZXJUaXRsZXMgKHN5bWJvbCwgZCkge1xyXG4gICAgICAgIGlmIChfY2hhcnQucmVuZGVyVGl0bGUoKSkge1xyXG4gICAgICAgICAgICBzeW1ib2wuc2VsZWN0QWxsKCd0aXRsZScpLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICBzeW1ib2wuYXBwZW5kKCd0aXRsZScpLnRleHQoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfY2hhcnQudGl0bGUoKShkKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IG9yIHNldCB0aGUgZXhpc3RlbmNlIGFjY2Vzc29yLiAgSWYgYSBwb2ludCBleGlzdHMsIGl0IGlzIGRyYXduIHdpdGhcclxuICAgICAqIHtAbGluayBkYy5zY2F0dGVyUGxvdCNzeW1ib2xTaXplIHN5bWJvbFNpemV9IHJhZGl1cyBhbmRcclxuICAgICAqIG9wYWNpdHkgMTsgaWYgaXQgZG9lcyBub3QgZXhpc3QsIGl0IGlzIGRyYXduIHdpdGhcclxuICAgICAqIHtAbGluayBkYy5zY2F0dGVyUGxvdCNlbXB0eVNpemUgZW1wdHlTaXplfSByYWRpdXMgYW5kIG9wYWNpdHkgMC4gQnkgZGVmYXVsdCxcclxuICAgICAqIHRoZSBleGlzdGVuY2UgYWNjZXNzb3IgY2hlY2tzIGlmIHRoZSByZWR1Y2VkIHZhbHVlIGlzIHRydXRoeS5cclxuICAgICAqIEBtZXRob2QgZXhpc3RlbmNlQWNjZXNzb3JcclxuICAgICAqIEBtZW1iZXJvZiBkYy5zY2F0dGVyUGxvdFxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAc2VlIHtAbGluayBkYy5zY2F0dGVyUGxvdCNzeW1ib2xTaXplIHN5bWJvbFNpemV9XHJcbiAgICAgKiBAc2VlIHtAbGluayBkYy5zY2F0dGVyUGxvdCNlbXB0eVNpemUgZW1wdHlTaXplfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGRlZmF1bHQgYWNjZXNzb3JcclxuICAgICAqIGNoYXJ0LmV4aXN0ZW5jZUFjY2Vzc29yKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLnZhbHVlOyB9KTtcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFthY2Nlc3Nvcl1cclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbnxkYy5zY2F0dGVyUGxvdH1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LmV4aXN0ZW5jZUFjY2Vzc29yID0gZnVuY3Rpb24gKGFjY2Vzc29yKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfZXhpc3RlbmNlQWNjZXNzb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9leGlzdGVuY2VBY2Nlc3NvciA9IGFjY2Vzc29yO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBvciBzZXQgdGhlIHN5bWJvbCB0eXBlIHVzZWQgZm9yIGVhY2ggcG9pbnQuIEJ5IGRlZmF1bHQgdGhlIHN5bWJvbCBpcyBhIGNpcmNsZSAoZDMuc3ltYm9sQ2lyY2xlKS5cclxuICAgICAqIFR5cGUgY2FuIGJlIGEgY29uc3RhbnQgb3IgYW4gYWNjZXNzb3IuXHJcbiAgICAgKiBAbWV0aG9kIHN5bWJvbFxyXG4gICAgICogQG1lbWJlcm9mIGRjLnNjYXR0ZXJQbG90XHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1zaGFwZS9ibG9iL21hc3Rlci9SRUFETUUubWQjc3ltYm9sX3R5cGUgc3ltYm9sLnR5cGV9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gQ2lyY2xlIHR5cGVcclxuICAgICAqIGNoYXJ0LnN5bWJvbChkMy5zeW1ib2xDaXJjbGUpO1xyXG4gICAgICogLy8gU3F1YXJlIHR5cGVcclxuICAgICAqIGNoYXJ0LnN5bWJvbChkMy5zeW1ib2xTcXVhcmUpO1xyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3R5cGU9ZDMuc3ltYm9sQ2lyY2xlXVxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufGRjLnNjYXR0ZXJQbG90fVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQuc3ltYm9sID0gZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9zeW1ib2wudHlwZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfc3ltYm9sLnR5cGUodHlwZSk7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgb3Igc2V0IHRoZSBzeW1ib2wgZ2VuZXJhdG9yLiBCeSBkZWZhdWx0IGBkYy5zY2F0dGVyUGxvdGAgd2lsbCB1c2VcclxuICAgICAqIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2hhcGUvYmxvYi9tYXN0ZXIvUkVBRE1FLm1kI3N5bWJvbCBkMy5zeW1ib2woKX1cclxuICAgICAqIHRvIGdlbmVyYXRlIHN5bWJvbHMuIGBkYy5zY2F0dGVyUGxvdGAgd2lsbCBzZXQgdGhlXHJcbiAgICAgKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNoYXBlL2Jsb2IvbWFzdGVyL1JFQURNRS5tZCNzeW1ib2xfc2l6ZSBzeW1ib2wgc2l6ZSBhY2Nlc3Nvcn1cclxuICAgICAqIG9uIHRoZSBzeW1ib2wgZ2VuZXJhdG9yLlxyXG4gICAgICogQG1ldGhvZCBjdXN0b21TeW1ib2xcclxuICAgICAqIEBtZW1iZXJvZiBkYy5zY2F0dGVyUGxvdFxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2hhcGUvYmxvYi9tYXN0ZXIvUkVBRE1FLm1kI3N5bWJvbCBkMy5zeW1ib2x9XHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNTMzMjEyMC9jcmVhdGUtYWRkaXRpb25hbC1kMy1qcy1zeW1ib2xzIENyZWF0ZSBhZGRpdGlvbmFsIEQzLmpzIHN5bWJvbHN9XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gW2N1c3RvbVN5bWJvbD1kMy5zeW1ib2woKV1cclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd8RnVuY3Rpb258ZGMuc2NhdHRlclBsb3R9XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5jdXN0b21TeW1ib2wgPSBmdW5jdGlvbiAoY3VzdG9tU3ltYm9sKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfc3ltYm9sO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfc3ltYm9sID0gY3VzdG9tU3ltYm9sO1xyXG4gICAgICAgIF9zeW1ib2wuc2l6ZShlbGVtZW50U2l6ZSk7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgb3IgZ2V0IHJhZGl1cyBmb3Igc3ltYm9scy5cclxuICAgICAqIEBtZXRob2Qgc3ltYm9sU2l6ZVxyXG4gICAgICogQG1lbWJlcm9mIGRjLnNjYXR0ZXJQbG90XHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1zaGFwZS9ibG9iL21hc3Rlci9SRUFETUUubWQjc3ltYm9sX3NpemUgZDMuc3ltYm9sLnNpemV9XHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3N5bWJvbFNpemU9M11cclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ8ZGMuc2NhdHRlclBsb3R9XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5zeW1ib2xTaXplID0gZnVuY3Rpb24gKHN5bWJvbFNpemUpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9zeW1ib2xTaXplO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfc3ltYm9sU2l6ZSA9IHN5bWJvbFNpemU7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgb3IgZ2V0IHJhZGl1cyBmb3IgaGlnaGxpZ2h0ZWQgc3ltYm9scy5cclxuICAgICAqIEBtZXRob2QgaGlnaGxpZ2h0ZWRTaXplXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuc2NhdHRlclBsb3RcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNoYXBlL2Jsb2IvbWFzdGVyL1JFQURNRS5tZCNzeW1ib2xfc2l6ZSBkMy5zeW1ib2wuc2l6ZX1cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbaGlnaGxpZ2h0ZWRTaXplPTVdXHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfGRjLnNjYXR0ZXJQbG90fVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQuaGlnaGxpZ2h0ZWRTaXplID0gZnVuY3Rpb24gKGhpZ2hsaWdodGVkU2l6ZSkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2hpZ2hsaWdodGVkU2l6ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX2hpZ2hsaWdodGVkU2l6ZSA9IGhpZ2hsaWdodGVkU2l6ZTtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBvciBnZXQgc2l6ZSBmb3Igc3ltYm9scyBleGNsdWRlZCBmcm9tIHRoaXMgY2hhcnQncyBmaWx0ZXIuIElmIG51bGwsIG5vXHJcbiAgICAgKiBzcGVjaWFsIHNpemUgaXMgYXBwbGllZCBmb3Igc3ltYm9scyBiYXNlZCBvbiB0aGVpciBmaWx0ZXIgc3RhdHVzLlxyXG4gICAgICogQG1ldGhvZCBleGNsdWRlZFNpemVcclxuICAgICAqIEBtZW1iZXJvZiBkYy5zY2F0dGVyUGxvdFxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2hhcGUvYmxvYi9tYXN0ZXIvUkVBRE1FLm1kI3N5bWJvbF9zaXplIGQzLnN5bWJvbC5zaXplfVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtleGNsdWRlZFNpemU9bnVsbF1cclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ8ZGMuc2NhdHRlclBsb3R9XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5leGNsdWRlZFNpemUgPSBmdW5jdGlvbiAoZXhjbHVkZWRTaXplKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfZXhjbHVkZWRTaXplO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfZXhjbHVkZWRTaXplID0gZXhjbHVkZWRTaXplO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IG9yIGdldCBjb2xvciBmb3Igc3ltYm9scyBleGNsdWRlZCBmcm9tIHRoaXMgY2hhcnQncyBmaWx0ZXIuIElmIG51bGwsIG5vXHJcbiAgICAgKiBzcGVjaWFsIGNvbG9yIGlzIGFwcGxpZWQgZm9yIHN5bWJvbHMgYmFzZWQgb24gdGhlaXIgZmlsdGVyIHN0YXR1cy5cclxuICAgICAqIEBtZXRob2QgZXhjbHVkZWRDb2xvclxyXG4gICAgICogQG1lbWJlcm9mIGRjLnNjYXR0ZXJQbG90XHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZXhjbHVkZWRDb2xvcj1udWxsXVxyXG4gICAgICogQHJldHVybnMge051bWJlcnxkYy5zY2F0dGVyUGxvdH1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LmV4Y2x1ZGVkQ29sb3IgPSBmdW5jdGlvbiAoZXhjbHVkZWRDb2xvcikge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2V4Y2x1ZGVkQ29sb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9leGNsdWRlZENvbG9yID0gZXhjbHVkZWRDb2xvcjtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBvciBnZXQgb3BhY2l0eSBmb3Igc3ltYm9scyBleGNsdWRlZCBmcm9tIHRoaXMgY2hhcnQncyBmaWx0ZXIuXHJcbiAgICAgKiBAbWV0aG9kIGV4Y2x1ZGVkT3BhY2l0eVxyXG4gICAgICogQG1lbWJlcm9mIGRjLnNjYXR0ZXJQbG90XHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZXhjbHVkZWRPcGFjaXR5PTEuMF1cclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ8ZGMuc2NhdHRlclBsb3R9XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5leGNsdWRlZE9wYWNpdHkgPSBmdW5jdGlvbiAoZXhjbHVkZWRPcGFjaXR5KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfZXhjbHVkZWRPcGFjaXR5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBfZXhjbHVkZWRPcGFjaXR5ID0gZXhjbHVkZWRPcGFjaXR5O1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IG9yIGdldCByYWRpdXMgZm9yIHN5bWJvbHMgd2hlbiB0aGUgZ3JvdXAgaXMgZW1wdHkuXHJcbiAgICAgKiBAbWV0aG9kIGVtcHR5U2l6ZVxyXG4gICAgICogQG1lbWJlcm9mIGRjLnNjYXR0ZXJQbG90XHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1zaGFwZS9ibG9iL21hc3Rlci9SRUFETUUubWQjc3ltYm9sX3NpemUgZDMuc3ltYm9sLnNpemV9XHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2VtcHR5U2l6ZT0wXVxyXG4gICAgICogQHJldHVybnMge051bWJlcnxkYy5zY2F0dGVyUGxvdH1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LmhpZGRlblNpemUgPSBfY2hhcnQuZW1wdHlTaXplID0gZnVuY3Rpb24gKGVtcHR5U2l6ZSkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2VtcHR5U2l6ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX2VtcHR5U2l6ZSA9IGVtcHR5U2l6ZTtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBvciBnZXQgY29sb3IgZm9yIHN5bWJvbHMgd2hlbiB0aGUgZ3JvdXAgaXMgZW1wdHkuIElmIG51bGwsIGp1c3QgdXNlIHRoZVxyXG4gICAgICoge0BsaW5rIGRjLmNvbG9yTWl4aW4jY29sb3JzIGNvbG9yTWl4aW4uY29sb3JzfSBjb2xvciBzY2FsZSB6ZXJvIHZhbHVlLlxyXG4gICAgICogQG5hbWUgZW1wdHlDb2xvclxyXG4gICAgICogQG1lbWJlcm9mIGRjLnNjYXR0ZXJQbG90XHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbZW1wdHlDb2xvcj1udWxsXVxyXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxyXG4gICAgICogQHJldHVybiB7ZGMuc2NhdHRlclBsb3R9L1xyXG4gICAgICovXHJcbiAgICBfY2hhcnQuZW1wdHlDb2xvciA9IGZ1bmN0aW9uIChlbXB0eUNvbG9yKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfZW1wdHlDb2xvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgX2VtcHR5Q29sb3IgPSBlbXB0eUNvbG9yO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IG9yIGdldCBvcGFjaXR5IGZvciBzeW1ib2xzIHdoZW4gdGhlIGdyb3VwIGlzIGVtcHR5LlxyXG4gICAgICogQG5hbWUgZW1wdHlPcGFjaXR5XHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuc2NhdHRlclBsb3RcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtlbXB0eU9wYWNpdHk9MF1cclxuICAgICAqIEByZXR1cm4ge051bWJlcn1cclxuICAgICAqIEByZXR1cm4ge2RjLnNjYXR0ZXJQbG90fVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQuZW1wdHlPcGFjaXR5ID0gZnVuY3Rpb24gKGVtcHR5T3BhY2l0eSkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2VtcHR5T3BhY2l0eTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX2VtcHR5T3BhY2l0eSA9IGVtcHR5T3BhY2l0eTtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBvciBnZXQgb3BhY2l0eSBmb3Igc3ltYm9scyB3aGVuIHRoZSBncm91cCBpcyBub3QgZW1wdHkuXHJcbiAgICAgKiBAbmFtZSBub25lbXB0eU9wYWNpdHlcclxuICAgICAqIEBtZW1iZXJvZiBkYy5zY2F0dGVyUGxvdFxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW25vbmVtcHR5T3BhY2l0eT0xXVxyXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxyXG4gICAgICogQHJldHVybiB7ZGMuc2NhdHRlclBsb3R9XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5ub25lbXB0eU9wYWNpdHkgPSBmdW5jdGlvbiAobm9uZW1wdHlPcGFjaXR5KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfZW1wdHlPcGFjaXR5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBfbm9uZW1wdHlPcGFjaXR5ID0gbm9uZW1wdHlPcGFjaXR5O1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF9jaGFydC5sZWdlbmRhYmxlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gW3tjaGFydDogX2NoYXJ0LCBuYW1lOiBfY2hhcnQuX2dyb3VwTmFtZSwgY29sb3I6IF9jaGFydC5nZXRDb2xvcigpfV07XHJcbiAgICB9O1xyXG5cclxuICAgIF9jaGFydC5sZWdlbmRIaWdobGlnaHQgPSBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIHJlc2l6ZVN5bWJvbHNXaGVyZShmdW5jdGlvbiAoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzeW1ib2wuYXR0cignZmlsbCcpID09PSBkLmNvbG9yO1xyXG4gICAgICAgIH0sIF9oaWdobGlnaHRlZFNpemUpO1xyXG4gICAgICAgIF9jaGFydC5jaGFydEJvZHlHKCkuc2VsZWN0QWxsKCcuY2hhcnQtYm9keSBwYXRoLnN5bWJvbCcpLmZpbHRlcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkMy5zZWxlY3QodGhpcykuYXR0cignZmlsbCcpICE9PSBkLmNvbG9yO1xyXG4gICAgICAgIH0pLmNsYXNzZWQoJ2ZhZGVvdXQnLCB0cnVlKTtcclxuICAgIH07XHJcblxyXG4gICAgX2NoYXJ0LmxlZ2VuZFJlc2V0ID0gZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICByZXNpemVTeW1ib2xzV2hlcmUoZnVuY3Rpb24gKHN5bWJvbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3ltYm9sLmF0dHIoJ2ZpbGwnKSA9PT0gZC5jb2xvcjtcclxuICAgICAgICB9LCBfc3ltYm9sU2l6ZSk7XHJcbiAgICAgICAgX2NoYXJ0LmNoYXJ0Qm9keUcoKS5zZWxlY3RBbGwoJy5jaGFydC1ib2R5IHBhdGguc3ltYm9sJykuZmlsdGVyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGQzLnNlbGVjdCh0aGlzKS5hdHRyKCdmaWxsJykgIT09IGQuY29sb3I7XHJcbiAgICAgICAgfSkuY2xhc3NlZCgnZmFkZW91dCcsIGZhbHNlKTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gcmVzaXplU3ltYm9sc1doZXJlIChjb25kaXRpb24sIHNpemUpIHtcclxuICAgICAgICB2YXIgc3ltYm9scyA9IF9jaGFydC5jaGFydEJvZHlHKCkuc2VsZWN0QWxsKCcuY2hhcnQtYm9keSBwYXRoLnN5bWJvbCcpLmZpbHRlcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb25kaXRpb24oZDMuc2VsZWN0KHRoaXMpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgb2xkU2l6ZSA9IF9zeW1ib2wuc2l6ZSgpO1xyXG4gICAgICAgIF9zeW1ib2wuc2l6ZShNYXRoLnBvdyhzaXplLCAyKSk7XHJcbiAgICAgICAgZGMudHJhbnNpdGlvbihzeW1ib2xzLCBfY2hhcnQudHJhbnNpdGlvbkR1cmF0aW9uKCksIF9jaGFydC50cmFuc2l0aW9uRGVsYXkoKSkuYXR0cignZCcsIF9zeW1ib2wpO1xyXG4gICAgICAgIF9zeW1ib2wuc2l6ZShvbGRTaXplKTtcclxuICAgIH1cclxuXHJcbiAgICBfY2hhcnQuY3JlYXRlQnJ1c2hIYW5kbGVQYXRocyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBubyBoYW5kbGUgcGF0aHMgZm9yIHBvbHktYnJ1c2hlc1xyXG4gICAgfTtcclxuXHJcbiAgICBfY2hhcnQuZXh0ZW5kQnJ1c2ggPSBmdW5jdGlvbiAoYnJ1c2hTZWxlY3Rpb24pIHtcclxuICAgICAgICBpZiAoX2NoYXJ0LnJvdW5kKCkpIHtcclxuICAgICAgICAgICAgYnJ1c2hTZWxlY3Rpb25bMF0gPSBicnVzaFNlbGVjdGlvblswXS5tYXAoX2NoYXJ0LnJvdW5kKCkpO1xyXG4gICAgICAgICAgICBicnVzaFNlbGVjdGlvblsxXSA9IGJydXNoU2VsZWN0aW9uWzFdLm1hcChfY2hhcnQucm91bmQoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBicnVzaFNlbGVjdGlvbjtcclxuICAgIH07XHJcblxyXG4gICAgX2NoYXJ0LmJydXNoSXNFbXB0eSA9IGZ1bmN0aW9uIChicnVzaFNlbGVjdGlvbikge1xyXG4gICAgICAgIHJldHVybiAhYnJ1c2hTZWxlY3Rpb24gfHwgYnJ1c2hTZWxlY3Rpb25bMF1bMF0gPj0gYnJ1c2hTZWxlY3Rpb25bMV1bMF0gfHwgYnJ1c2hTZWxlY3Rpb25bMF1bMV0gPj0gYnJ1c2hTZWxlY3Rpb25bMV1bMV07XHJcbiAgICB9O1xyXG5cclxuICAgIF9jaGFydC5fYnJ1c2hpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gQXZvaWRzIGluZmluaXRlIHJlY3Vyc2lvbiAobXV0dWFsIHJlY3Vyc2lvbiBiZXR3ZWVuIHJhbmdlIGFuZCBmb2N1cyBvcGVyYXRpb25zKVxyXG4gICAgICAgIC8vIFNvdXJjZSBFdmVudCB3aWxsIGJlIG51bGwgd2hlbiBicnVzaC5tb3ZlIGlzIGNhbGxlZCBwcm9ncmFtbWF0aWNhbGx5IChzZWUgYmVsb3cgYXMgd2VsbCkuXHJcbiAgICAgICAgaWYgKCFkMy5ldmVudC5zb3VyY2VFdmVudCkgeyByZXR1cm47IH1cclxuXHJcbiAgICAgICAgLy8gSWdub3JlIGV2ZW50IGlmIHJlY3Vyc2l2ZSBldmVudCAtIGkuZS4gbm90IGRpcmVjdGx5IGdlbmVyYXRlZCBieSB1c2VyIGFjdGlvbiAobGlrZSBtb3VzZS90b3VjaCBldGMuKVxyXG4gICAgICAgIC8vIEluIHRoaXMgY2FzZSB3ZSBhcmUgbW9yZSB3b3JyaWVkIGFib3V0IHRoaXMgaGFuZGxlciBjYXVzaW5nIGJydXNoIG1vdmUgcHJvZ3JhbW1hdGljYWxseSB3aGljaCB3aWxsXHJcbiAgICAgICAgLy8gY2F1c2UgdGhpcyBoYW5kbGVyIHRvIGJlIGludm9rZWQgYWdhaW4gd2l0aCBhIG5ldyBkMy5ldmVudCAoYW5kIGN1cnJlbnQgZXZlbnQgc2V0IGFzIHNvdXJjZUV2ZW50KVxyXG4gICAgICAgIC8vIFRoaXMgY2hlY2sgYXZvaWRzIHJlY3Vyc2l2ZSBjYWxsc1xyXG4gICAgICAgIGlmIChkMy5ldmVudC5zb3VyY2VFdmVudC50eXBlICYmIFsnc3RhcnQnLCAnYnJ1c2gnLCAnZW5kJ10uaW5kZXhPZihkMy5ldmVudC5zb3VyY2VFdmVudC50eXBlKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGJydXNoU2VsZWN0aW9uID0gZDMuZXZlbnQuc2VsZWN0aW9uO1xyXG5cclxuICAgICAgICAvLyBUZXN0aW5nIHdpdGggcGl4ZWxzIGlzIG1vcmUgcmVsaWFibGVcclxuICAgICAgICB2YXIgYnJ1c2hJc0VtcHR5ID0gX2NoYXJ0LmJydXNoSXNFbXB0eShicnVzaFNlbGVjdGlvbik7XHJcblxyXG4gICAgICAgIGlmIChicnVzaFNlbGVjdGlvbikge1xyXG4gICAgICAgICAgICBicnVzaFNlbGVjdGlvbiA9IGJydXNoU2VsZWN0aW9uLm1hcChmdW5jdGlvbiAocG9pbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwb2ludC5tYXAoZnVuY3Rpb24gKGNvb3JkLCBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjYWxlID0gaSA9PT0gMCA/IF9jaGFydC54KCkgOiBfY2hhcnQueSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzY2FsZS5pbnZlcnQoY29vcmQpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgYnJ1c2hTZWxlY3Rpb24gPSBfY2hhcnQuZXh0ZW5kQnJ1c2goYnJ1c2hTZWxlY3Rpb24pO1xyXG5cclxuICAgICAgICAgICAgLy8gVGhlIHJvdW5kaW5nIHByb2Nlc3MgbWlnaHQgaGF2ZSBtYWRlIGJydXNoU2VsZWN0aW9uIGVtcHR5LCBzbyB3ZSBuZWVkIHRvIHJlY2hlY2tcclxuICAgICAgICAgICAgYnJ1c2hJc0VtcHR5ID0gYnJ1c2hJc0VtcHR5ICYmIF9jaGFydC5icnVzaElzRW1wdHkoYnJ1c2hTZWxlY3Rpb24pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgX2NoYXJ0LnJlZHJhd0JydXNoKGJydXNoU2VsZWN0aW9uLCBmYWxzZSk7XHJcblxyXG4gICAgICAgIHZhciByYW5nZWQyREZpbHRlciA9IGJydXNoSXNFbXB0eSA/IG51bGwgOiBkYy5maWx0ZXJzLlJhbmdlZFR3b0RpbWVuc2lvbmFsRmlsdGVyKGJydXNoU2VsZWN0aW9uKTtcclxuXHJcbiAgICAgICAgZGMuZXZlbnRzLnRyaWdnZXIoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfY2hhcnQucmVwbGFjZUZpbHRlcihyYW5nZWQyREZpbHRlcik7XHJcbiAgICAgICAgICAgIF9jaGFydC5yZWRyYXdHcm91cCgpO1xyXG4gICAgICAgIH0sIGRjLmNvbnN0YW50cy5FVkVOVF9ERUxBWSk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9jaGFydC5yZWRyYXdCcnVzaCA9IGZ1bmN0aW9uIChicnVzaFNlbGVjdGlvbiwgZG9UcmFuc2l0aW9uKSB7XHJcbiAgICAgICAgLy8gb3ZlcnJpZGUgZGVmYXVsdCB4IGF4aXMgYnJ1c2ggZnJvbSBwYXJlbnQgY2hhcnRcclxuICAgICAgICB2YXIgX2JydXNoID0gX2NoYXJ0LmJydXNoKCk7XHJcbiAgICAgICAgdmFyIF9nQnJ1c2ggPSBfY2hhcnQuZ0JydXNoKCk7XHJcblxyXG4gICAgICAgIGlmIChfY2hhcnQuYnJ1c2hPbigpICYmIF9nQnJ1c2gpIHtcclxuICAgICAgICAgICAgaWYgKF9jaGFydC5yZXNpemluZygpKSB7XHJcbiAgICAgICAgICAgICAgICBfY2hhcnQuc2V0QnJ1c2hFeHRlbnRzKGRvVHJhbnNpdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghYnJ1c2hTZWxlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIF9nQnJ1c2hcclxuICAgICAgICAgICAgICAgICAgICAuY2FsbChfYnJ1c2gubW92ZSwgYnJ1c2hTZWxlY3Rpb24pO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJydXNoU2VsZWN0aW9uID0gYnJ1c2hTZWxlY3Rpb24ubWFwKGZ1bmN0aW9uIChwb2ludCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwb2ludC5tYXAoZnVuY3Rpb24gKGNvb3JkLCBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY2FsZSA9IGkgPT09IDAgPyBfY2hhcnQueCgpIDogX2NoYXJ0LnkoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjYWxlKGNvb3JkKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBnQnJ1c2ggPVxyXG4gICAgICAgICAgICAgICAgICAgIGRjLm9wdGlvbmFsVHJhbnNpdGlvbihkb1RyYW5zaXRpb24sIF9jaGFydC50cmFuc2l0aW9uRHVyYXRpb24oKSwgX2NoYXJ0LnRyYW5zaXRpb25EZWxheSgpKShfZ0JydXNoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBnQnJ1c2hcclxuICAgICAgICAgICAgICAgICAgICAuY2FsbChfYnJ1c2gubW92ZSwgYnJ1c2hTZWxlY3Rpb24pO1xyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgX2NoYXJ0LmZhZGVEZXNlbGVjdGVkQXJlYShicnVzaFNlbGVjdGlvbik7XHJcbiAgICB9O1xyXG5cclxuICAgIF9jaGFydC5zZXRCcnVzaFkgPSBmdW5jdGlvbiAoZ0JydXNoKSB7XHJcbiAgICAgICAgZ0JydXNoLmNhbGwoX2NoYXJ0LmJydXNoKCkueShfY2hhcnQueSgpKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBfY2hhcnQuYW5jaG9yKHBhcmVudCwgY2hhcnRHcm91cCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQSBkaXNwbGF5IG9mIGEgc2luZ2xlIG51bWVyaWMgdmFsdWUuXHJcbiAqIFVubGlrZSBvdGhlciBjaGFydHMsIHlvdSBkbyBub3QgbmVlZCB0byBzZXQgYSBkaW1lbnNpb24uIEluc3RlYWQgYSBncm91cCBvYmplY3QgbXVzdCBiZSBwcm92aWRlZCBhbmRcclxuICogYSB2YWx1ZUFjY2Vzc29yIHRoYXQgcmV0dXJucyBhIHNpbmdsZSB2YWx1ZS5cclxuICogQGNsYXNzIG51bWJlckRpc3BsYXlcclxuICogQG1lbWJlcm9mIGRjXHJcbiAqIEBtaXhlcyBkYy5iYXNlTWl4aW5cclxuICogQGV4YW1wbGVcclxuICogLy8gY3JlYXRlIGEgbnVtYmVyIGRpc3BsYXkgdW5kZXIgI2NoYXJ0LWNvbnRhaW5lcjEgZWxlbWVudCB1c2luZyB0aGUgZGVmYXVsdCBnbG9iYWwgY2hhcnQgZ3JvdXBcclxuICogdmFyIGRpc3BsYXkxID0gZGMubnVtYmVyRGlzcGxheSgnI2NoYXJ0LWNvbnRhaW5lcjEnKTtcclxuICogQHBhcmFtIHtTdHJpbmd8bm9kZXxkMy5zZWxlY3Rpb259IHBhcmVudCAtIEFueSB2YWxpZFxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNlbGVjdGlvbi9ibG9iL21hc3Rlci9SRUFETUUubWQjc2VsZWN0IGQzIHNpbmdsZSBzZWxlY3Rvcn0gc3BlY2lmeWluZ1xyXG4gKiBhIGRvbSBibG9jayBlbGVtZW50IHN1Y2ggYXMgYSBkaXY7IG9yIGEgZG9tIGVsZW1lbnQgb3IgZDMgc2VsZWN0aW9uLlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gW2NoYXJ0R3JvdXBdIC0gVGhlIG5hbWUgb2YgdGhlIGNoYXJ0IGdyb3VwIHRoaXMgY2hhcnQgaW5zdGFuY2Ugc2hvdWxkIGJlIHBsYWNlZCBpbi5cclxuICogSW50ZXJhY3Rpb24gd2l0aCBhIGNoYXJ0IHdpbGwgb25seSB0cmlnZ2VyIGV2ZW50cyBhbmQgcmVkcmF3cyB3aXRoaW4gdGhlIGNoYXJ0J3MgZ3JvdXAuXHJcbiAqIEByZXR1cm5zIHtkYy5udW1iZXJEaXNwbGF5fVxyXG4gKi9cclxuZGMubnVtYmVyRGlzcGxheSA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoYXJ0R3JvdXApIHtcclxuICAgIHZhciBTUEFOX0NMQVNTID0gJ251bWJlci1kaXNwbGF5JztcclxuICAgIHZhciBfZm9ybWF0TnVtYmVyID0gZDMuZm9ybWF0KCcuMnMnKTtcclxuICAgIHZhciBfY2hhcnQgPSBkYy5iYXNlTWl4aW4oe30pO1xyXG4gICAgdmFyIF9odG1sID0ge29uZTogJycsIHNvbWU6ICcnLCBub25lOiAnJ307XHJcbiAgICB2YXIgX2xhc3RWYWx1ZTtcclxuXHJcbiAgICAvLyBkaW1lbnNpb24gbm90IHJlcXVpcmVkXHJcbiAgICBfY2hhcnQuX21hbmRhdG9yeUF0dHJpYnV0ZXMoWydncm91cCddKTtcclxuXHJcbiAgICAvLyBkZWZhdWx0IHRvIG9yZGVyaW5nIGJ5IHZhbHVlLCB0byBlbXVsYXRlIG9sZCBncm91cC50b3AoMSkgYmVoYXZpb3Igd2hlbiBtdWx0aXBsZSBncm91cHNcclxuICAgIF9jaGFydC5vcmRlcmluZyhmdW5jdGlvbiAoa3YpIHsgcmV0dXJuIGt2LnZhbHVlOyB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyBhbiBvcHRpb25hbCBvYmplY3Qgc3BlY2lmeWluZyBIVE1MIHRlbXBsYXRlcyB0byB1c2UgZGVwZW5kaW5nIG9uIHRoZSBudW1iZXJcclxuICAgICAqIGRpc3BsYXllZC4gIFRoZSB0ZXh0IGAlbnVtYmVyYCB3aWxsIGJlIHJlcGxhY2VkIHdpdGggdGhlIGN1cnJlbnQgdmFsdWUuXHJcbiAgICAgKiAtIG9uZTogSFRNTCB0ZW1wbGF0ZSB0byB1c2UgaWYgdGhlIG51bWJlciBpcyAxXHJcbiAgICAgKiAtIHplcm86IEhUTUwgdGVtcGxhdGUgdG8gdXNlIGlmIHRoZSBudW1iZXIgaXMgMFxyXG4gICAgICogLSBzb21lOiBIVE1MIHRlbXBsYXRlIHRvIHVzZSBvdGhlcndpc2VcclxuICAgICAqIEBtZXRob2QgaHRtbFxyXG4gICAgICogQG1lbWJlcm9mIGRjLm51bWJlckRpc3BsYXlcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIG51bWJlcldpZGdldC5odG1sKHtcclxuICAgICAqICAgICAgb25lOiclbnVtYmVyIHJlY29yZCcsXHJcbiAgICAgKiAgICAgIHNvbWU6JyVudW1iZXIgcmVjb3JkcycsXHJcbiAgICAgKiAgICAgIG5vbmU6J25vIHJlY29yZHMnfSlcclxuICAgICAqIEBwYXJhbSB7e29uZTpTdHJpbmcsIHNvbWU6U3RyaW5nLCBub25lOlN0cmluZ319IFtodG1sPXtvbmU6ICcnLCBzb21lOiAnJywgbm9uZTogJyd9XVxyXG4gICAgICogQHJldHVybnMge3tvbmU6U3RyaW5nLCBzb21lOlN0cmluZywgbm9uZTpTdHJpbmd9fGRjLm51bWJlckRpc3BsYXl9XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5odG1sID0gZnVuY3Rpb24gKGh0bWwpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9odG1sO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaHRtbC5ub25lKSB7XHJcbiAgICAgICAgICAgIF9odG1sLm5vbmUgPSBodG1sLm5vbmU7Ly9pZiBub25lIGF2YWlsYWJsZVxyXG4gICAgICAgIH0gZWxzZSBpZiAoaHRtbC5vbmUpIHtcclxuICAgICAgICAgICAgX2h0bWwubm9uZSA9IGh0bWwub25lOy8vaWYgbm9uZSBub3QgYXZhaWxhYmxlIHVzZSBvbmVcclxuICAgICAgICB9IGVsc2UgaWYgKGh0bWwuc29tZSkge1xyXG4gICAgICAgICAgICBfaHRtbC5ub25lID0gaHRtbC5zb21lOy8vaWYgbm9uZSBhbmQgb25lIG5vdCBhdmFpbGFibGUgdXNlIHNvbWVcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGh0bWwub25lKSB7XHJcbiAgICAgICAgICAgIF9odG1sLm9uZSA9IGh0bWwub25lOy8vaWYgb25lIGF2YWlsYWJsZVxyXG4gICAgICAgIH0gZWxzZSBpZiAoaHRtbC5zb21lKSB7XHJcbiAgICAgICAgICAgIF9odG1sLm9uZSA9IGh0bWwuc29tZTsvL2lmIG9uZSBub3QgYXZhaWxhYmxlIHVzZSBzb21lXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChodG1sLnNvbWUpIHtcclxuICAgICAgICAgICAgX2h0bWwuc29tZSA9IGh0bWwuc29tZTsvL2lmIHNvbWUgYXZhaWxhYmxlXHJcbiAgICAgICAgfSBlbHNlIGlmIChodG1sLm9uZSkge1xyXG4gICAgICAgICAgICBfaHRtbC5zb21lID0gaHRtbC5vbmU7Ly9pZiBzb21lIG5vdCBhdmFpbGFibGUgdXNlIG9uZVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZSBhbmQgcmV0dXJuIHRoZSB1bmRlcmx5aW5nIHZhbHVlIG9mIHRoZSBkaXNwbGF5LlxyXG4gICAgICogQG1ldGhvZCB2YWx1ZVxyXG4gICAgICogQG1lbWJlcm9mIGRjLm51bWJlckRpc3BsYXlcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHJldHVybnMge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LnZhbHVlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQuZGF0YSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBtYXhCaW4gKGFsbCkge1xyXG4gICAgICAgIGlmICghYWxsLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNvcnRlZCA9IF9jaGFydC5fY29tcHV0ZU9yZGVyZWRHcm91cHMoYWxsKTtcclxuICAgICAgICByZXR1cm4gc29ydGVkW3NvcnRlZC5sZW5ndGggLSAxXTtcclxuICAgIH1cclxuICAgIF9jaGFydC5kYXRhKGZ1bmN0aW9uIChncm91cCkge1xyXG4gICAgICAgIHZhciB2YWxPYmogPSBncm91cC52YWx1ZSA/IGdyb3VwLnZhbHVlKCkgOiBtYXhCaW4oZ3JvdXAuYWxsKCkpO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQudmFsdWVBY2Nlc3NvcigpKHZhbE9iaik7XHJcbiAgICB9KTtcclxuXHJcbiAgICBfY2hhcnQudHJhbnNpdGlvbkR1cmF0aW9uKDI1MCk7IC8vIGdvb2QgZGVmYXVsdFxyXG4gICAgX2NoYXJ0LnRyYW5zaXRpb25EZWxheSgwKTtcclxuXHJcbiAgICBfY2hhcnQuX2RvUmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IF9jaGFydC52YWx1ZSgpLFxyXG4gICAgICAgICAgICBzcGFuID0gX2NoYXJ0LnNlbGVjdEFsbCgnLicgKyBTUEFOX0NMQVNTKTtcclxuXHJcbiAgICAgICAgaWYgKHNwYW4uZW1wdHkoKSkge1xyXG4gICAgICAgICAgICBzcGFuID0gc3Bhbi5kYXRhKFswXSlcclxuICAgICAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgnc3BhbicpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgU1BBTl9DTEFTUylcclxuICAgICAgICAgICAgICAgIC5tZXJnZShzcGFuKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNwYW4udHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgIC5kdXJhdGlvbihfY2hhcnQudHJhbnNpdGlvbkR1cmF0aW9uKCkpXHJcbiAgICAgICAgICAgIC5kZWxheShfY2hhcnQudHJhbnNpdGlvbkRlbGF5KCkpXHJcbiAgICAgICAgICAgIC5lYXNlKGQzLmVhc2VRdWFkKVxyXG4gICAgICAgICAgICAudHdlZW4oJ3RleHQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBbWEFdIGRvbid0IHRyeSBhbmQgaW50ZXJwb2xhdGUgZnJvbSBJbmZpbml0eSwgZWxzZSB0aGlzIGJyZWFrcy5cclxuICAgICAgICAgICAgICAgIHZhciBpbnRlcnBTdGFydCA9IGlzRmluaXRlKF9sYXN0VmFsdWUpID8gX2xhc3RWYWx1ZSA6IDA7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW50ZXJwID0gZDMuaW50ZXJwb2xhdGVOdW1iZXIoaW50ZXJwU3RhcnQgfHwgMCwgbmV3VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgX2xhc3RWYWx1ZSA9IG5ld1ZhbHVlO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gc2F2ZSBpdCBpbiBEM3Y0XHJcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaHRtbCA9IG51bGwsIG51bSA9IF9jaGFydC5mb3JtYXROdW1iZXIoKShpbnRlcnAodCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gMCAmJiAoX2h0bWwubm9uZSAhPT0gJycpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWwgPSBfaHRtbC5ub25lO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV3VmFsdWUgPT09IDEgJiYgKF9odG1sLm9uZSAhPT0gJycpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWwgPSBfaHRtbC5vbmU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChfaHRtbC5zb21lICE9PSAnJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sID0gX2h0bWwuc29tZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5pbm5lckhUTUwgPSBodG1sID8gaHRtbC5yZXBsYWNlKCclbnVtYmVyJywgbnVtKSA6IG51bTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBfY2hhcnQuX2RvUmVkcmF3ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQuX2RvUmVuZGVyKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IG9yIHNldCBhIGZ1bmN0aW9uIHRvIGZvcm1hdCB0aGUgdmFsdWUgZm9yIHRoZSBkaXNwbGF5LlxyXG4gICAgICogQG1ldGhvZCBmb3JtYXROdW1iZXJcclxuICAgICAqIEBtZW1iZXJvZiBkYy5udW1iZXJEaXNwbGF5XHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1mb3JtYXQvYmxvYi9tYXN0ZXIvUkVBRE1FLm1kI2Zvcm1hdCBkMy5mb3JtYXR9XHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm9ybWF0dGVyPWQzLmZvcm1hdCgnLjJzJyldXHJcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb258ZGMubnVtYmVyRGlzcGxheX1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LmZvcm1hdE51bWJlciA9IGZ1bmN0aW9uIChmb3JtYXR0ZXIpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9mb3JtYXROdW1iZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9mb3JtYXROdW1iZXIgPSBmb3JtYXR0ZXI7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIF9jaGFydC5hbmNob3IocGFyZW50LCBjaGFydEdyb3VwKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBIGhlYXQgbWFwIGlzIG1hdHJpeCB0aGF0IHJlcHJlc2VudHMgdGhlIHZhbHVlcyBvZiB0d28gZGltZW5zaW9ucyBvZiBkYXRhIHVzaW5nIGNvbG9ycy5cclxuICogQGNsYXNzIGhlYXRNYXBcclxuICogQG1lbWJlcm9mIGRjXHJcbiAqIEBtaXhlcyBkYy5jb2xvck1peGluXHJcbiAqIEBtaXhlcyBkYy5tYXJnaW5NaXhpblxyXG4gKiBAbWl4ZXMgZGMuYmFzZU1peGluXHJcbiAqIEBleGFtcGxlXHJcbiAqIC8vIGNyZWF0ZSBhIGhlYXQgbWFwIHVuZGVyICNjaGFydC1jb250YWluZXIxIGVsZW1lbnQgdXNpbmcgdGhlIGRlZmF1bHQgZ2xvYmFsIGNoYXJ0IGdyb3VwXHJcbiAqIHZhciBoZWF0TWFwMSA9IGRjLmhlYXRNYXAoJyNjaGFydC1jb250YWluZXIxJyk7XHJcbiAqIC8vIGNyZWF0ZSBhIGhlYXQgbWFwIHVuZGVyICNjaGFydC1jb250YWluZXIyIGVsZW1lbnQgdXNpbmcgY2hhcnQgZ3JvdXAgQVxyXG4gKiB2YXIgaGVhdE1hcDIgPSBkYy5oZWF0TWFwKCcjY2hhcnQtY29udGFpbmVyMicsICdjaGFydEdyb3VwQScpO1xyXG4gKiBAcGFyYW0ge1N0cmluZ3xub2RlfGQzLnNlbGVjdGlvbn0gcGFyZW50IC0gQW55IHZhbGlkXHJcbiAqIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2VsZWN0aW9uL2Jsb2IvbWFzdGVyL1JFQURNRS5tZCNzZWxlY3QgZDMgc2luZ2xlIHNlbGVjdG9yfSBzcGVjaWZ5aW5nXHJcbiAqIGEgZG9tIGJsb2NrIGVsZW1lbnQgc3VjaCBhcyBhIGRpdjsgb3IgYSBkb20gZWxlbWVudCBvciBkMyBzZWxlY3Rpb24uXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbY2hhcnRHcm91cF0gLSBUaGUgbmFtZSBvZiB0aGUgY2hhcnQgZ3JvdXAgdGhpcyBjaGFydCBpbnN0YW5jZSBzaG91bGQgYmUgcGxhY2VkIGluLlxyXG4gKiBJbnRlcmFjdGlvbiB3aXRoIGEgY2hhcnQgd2lsbCBvbmx5IHRyaWdnZXIgZXZlbnRzIGFuZCByZWRyYXdzIHdpdGhpbiB0aGUgY2hhcnQncyBncm91cC5cclxuICogQHJldHVybnMge2RjLmhlYXRNYXB9XHJcbiAqL1xyXG5kYy5oZWF0TWFwID0gZnVuY3Rpb24gKHBhcmVudCwgY2hhcnRHcm91cCkge1xyXG5cclxuICAgIHZhciBERUZBVUxUX0JPUkRFUl9SQURJVVMgPSA2Ljc1O1xyXG5cclxuICAgIHZhciBfY2hhcnRCb2R5O1xyXG5cclxuICAgIHZhciBfY29scztcclxuICAgIHZhciBfcm93cztcclxuICAgIHZhciBfY29sT3JkZXJpbmcgPSBkMy5hc2NlbmRpbmc7XHJcbiAgICB2YXIgX3Jvd09yZGVyaW5nID0gZDMuYXNjZW5kaW5nO1xyXG4gICAgdmFyIF9jb2xTY2FsZSA9IGQzLnNjYWxlQmFuZCgpO1xyXG4gICAgdmFyIF9yb3dTY2FsZSA9IGQzLnNjYWxlQmFuZCgpO1xyXG5cclxuICAgIHZhciBfeEJvcmRlclJhZGl1cyA9IERFRkFVTFRfQk9SREVSX1JBRElVUztcclxuICAgIHZhciBfeUJvcmRlclJhZGl1cyA9IERFRkFVTFRfQk9SREVSX1JBRElVUztcclxuXHJcbiAgICB2YXIgX2NoYXJ0ID0gZGMuY29sb3JNaXhpbihkYy5tYXJnaW5NaXhpbihkYy5iYXNlTWl4aW4oe30pKSk7XHJcbiAgICBfY2hhcnQuX21hbmRhdG9yeUF0dHJpYnV0ZXMoWydncm91cCddKTtcclxuICAgIF9jaGFydC50aXRsZShfY2hhcnQuY29sb3JBY2Nlc3NvcigpKTtcclxuXHJcbiAgICB2YXIgX2NvbHNMYWJlbCA9IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgcmV0dXJuIGQ7XHJcbiAgICB9O1xyXG4gICAgdmFyIF9yb3dzTGFiZWwgPSBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIHJldHVybiBkO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBvciBnZXQgdGhlIGNvbHVtbiBsYWJlbCBmdW5jdGlvbi4gVGhlIGNoYXJ0IGNsYXNzIHVzZXMgdGhpcyBmdW5jdGlvbiB0byByZW5kZXJcclxuICAgICAqIGNvbHVtbiBsYWJlbHMgb24gdGhlIFggYXhpcy4gSXQgaXMgcGFzc2VkIHRoZSBjb2x1bW4gbmFtZS5cclxuICAgICAqIEBtZXRob2QgY29sc0xhYmVsXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuaGVhdE1hcFxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gdGhlIGRlZmF1bHQgbGFiZWwgZnVuY3Rpb24ganVzdCByZXR1cm5zIHRoZSBuYW1lXHJcbiAgICAgKiBjaGFydC5jb2xzTGFiZWwoZnVuY3Rpb24oZCkgeyByZXR1cm4gZDsgfSk7XHJcbiAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gW2xhYmVsRnVuY3Rpb249ZnVuY3Rpb24oZCkgeyByZXR1cm4gZDsgfV1cclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbnxkYy5oZWF0TWFwfVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQuY29sc0xhYmVsID0gZnVuY3Rpb24gKGxhYmVsRnVuY3Rpb24pIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9jb2xzTGFiZWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9jb2xzTGFiZWwgPSBsYWJlbEZ1bmN0aW9uO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IG9yIGdldCB0aGUgcm93IGxhYmVsIGZ1bmN0aW9uLiBUaGUgY2hhcnQgY2xhc3MgdXNlcyB0aGlzIGZ1bmN0aW9uIHRvIHJlbmRlclxyXG4gICAgICogcm93IGxhYmVscyBvbiB0aGUgWSBheGlzLiBJdCBpcyBwYXNzZWQgdGhlIHJvdyBuYW1lLlxyXG4gICAgICogQG1ldGhvZCByb3dzTGFiZWxcclxuICAgICAqIEBtZW1iZXJvZiBkYy5oZWF0TWFwXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyB0aGUgZGVmYXVsdCBsYWJlbCBmdW5jdGlvbiBqdXN0IHJldHVybnMgdGhlIG5hbWVcclxuICAgICAqIGNoYXJ0LnJvd3NMYWJlbChmdW5jdGlvbihkKSB7IHJldHVybiBkOyB9KTtcclxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBbbGFiZWxGdW5jdGlvbj1mdW5jdGlvbihkKSB7IHJldHVybiBkOyB9XVxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufGRjLmhlYXRNYXB9XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5yb3dzTGFiZWwgPSBmdW5jdGlvbiAobGFiZWxGdW5jdGlvbikge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3Jvd3NMYWJlbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3Jvd3NMYWJlbCA9IGxhYmVsRnVuY3Rpb247XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIF94QXhpc09uQ2xpY2sgPSBmdW5jdGlvbiAoZCkgeyBmaWx0ZXJBeGlzKDAsIGQpOyB9O1xyXG4gICAgdmFyIF95QXhpc09uQ2xpY2sgPSBmdW5jdGlvbiAoZCkgeyBmaWx0ZXJBeGlzKDEsIGQpOyB9O1xyXG4gICAgdmFyIF9ib3hPbkNsaWNrID0gZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICB2YXIgZmlsdGVyID0gZC5rZXk7XHJcbiAgICAgICAgZGMuZXZlbnRzLnRyaWdnZXIoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfY2hhcnQuZmlsdGVyKGZpbHRlcik7XHJcbiAgICAgICAgICAgIF9jaGFydC5yZWRyYXdHcm91cCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBmaWx0ZXJBeGlzIChheGlzLCB2YWx1ZSkge1xyXG4gICAgICAgIHZhciBjZWxsc09uQXhpcyA9IF9jaGFydC5zZWxlY3RBbGwoJy5ib3gtZ3JvdXAnKS5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGQua2V5W2F4aXNdID09PSB2YWx1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgdW5maWx0ZXJlZENlbGxzT25BeGlzID0gY2VsbHNPbkF4aXMuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhX2NoYXJ0Lmhhc0ZpbHRlcihkLmtleSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZGMuZXZlbnRzLnRyaWdnZXIoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gdW5maWx0ZXJlZENlbGxzT25BeGlzLmVtcHR5KCkgPyBjZWxsc09uQXhpcyA6IHVuZmlsdGVyZWRDZWxsc09uQXhpcztcclxuICAgICAgICAgICAgdmFyIGZpbHRlcnMgPSBzZWxlY3Rpb24uZGF0YSgpLm1hcChmdW5jdGlvbiAoa3YpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkYy5maWx0ZXJzLlR3b0RpbWVuc2lvbmFsRmlsdGVyKGt2LmtleSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBfY2hhcnQuX2ZpbHRlcihbZmlsdGVyc10pO1xyXG4gICAgICAgICAgICBfY2hhcnQucmVkcmF3R3JvdXAoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBkYy5vdmVycmlkZShfY2hhcnQsICdmaWx0ZXInLCBmdW5jdGlvbiAoZmlsdGVyKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfY2hhcnQuX2ZpbHRlcigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIF9jaGFydC5fZmlsdGVyKGRjLmZpbHRlcnMuVHdvRGltZW5zaW9uYWxGaWx0ZXIoZmlsdGVyKSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgdmFsdWVzIHVzZWQgdG8gY3JlYXRlIHRoZSByb3dzIG9mIHRoZSBoZWF0bWFwLCBhcyBhbiBhcnJheS4gQnkgZGVmYXVsdCwgYWxsXHJcbiAgICAgKiB0aGUgdmFsdWVzIHdpbGwgYmUgZmV0Y2hlZCBmcm9tIHRoZSBkYXRhIHVzaW5nIHRoZSB2YWx1ZSBhY2Nlc3Nvci5cclxuICAgICAqIEBtZXRob2Qgcm93c1xyXG4gICAgICogQG1lbWJlcm9mIGRjLmhlYXRNYXBcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtICB7QXJyYXk8U3RyaW5nfE51bWJlcj59IFtyb3dzXVxyXG4gICAgICogQHJldHVybnMge0FycmF5PFN0cmluZ3xOdW1iZXI+fGRjLmhlYXRNYXB9XHJcbiAgICAgKi9cclxuXHJcbiAgICBfY2hhcnQucm93cyA9IGZ1bmN0aW9uIChyb3dzKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfcm93cztcclxuICAgICAgICB9XHJcbiAgICAgICAgX3Jvd3MgPSByb3dzO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICMjIyMgLnJvd09yZGVyaW5nKFtvcmRlckZ1bmN0aW9uXSlcclxuICAgICBHZXQgb3Igc2V0IGFuIGFjY2Vzc29yIHRvIG9yZGVyIHRoZSByb3dzLiAgRGVmYXVsdCBpcyBkMy5hc2NlbmRpbmcuXHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5yb3dPcmRlcmluZyA9IGZ1bmN0aW9uIChfKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfcm93T3JkZXJpbmc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9yb3dPcmRlcmluZyA9IF87XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGtleXMgdXNlZCB0byBjcmVhdGUgdGhlIGNvbHVtbnMgb2YgdGhlIGhlYXRtYXAsIGFzIGFuIGFycmF5LiBCeSBkZWZhdWx0LCBhbGxcclxuICAgICAqIHRoZSB2YWx1ZXMgd2lsbCBiZSBmZXRjaGVkIGZyb20gdGhlIGRhdGEgdXNpbmcgdGhlIGtleSBhY2Nlc3Nvci5cclxuICAgICAqIEBtZXRob2QgY29sc1xyXG4gICAgICogQG1lbWJlcm9mIGRjLmhlYXRNYXBcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtICB7QXJyYXk8U3RyaW5nfE51bWJlcj59IFtjb2xzXVxyXG4gICAgICogQHJldHVybnMge0FycmF5PFN0cmluZ3xOdW1iZXI+fGRjLmhlYXRNYXB9XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5jb2xzID0gZnVuY3Rpb24gKGNvbHMpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9jb2xzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfY29scyA9IGNvbHM7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgIyMjIyAuY29sT3JkZXJpbmcoW29yZGVyRnVuY3Rpb25dKVxyXG4gICAgIEdldCBvciBzZXQgYW4gYWNjZXNzb3IgdG8gb3JkZXIgdGhlIGNvbHMuICBEZWZhdWx0IGlzIGFzY2VuZGluZy5cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LmNvbE9yZGVyaW5nID0gZnVuY3Rpb24gKF8pIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9jb2xPcmRlcmluZztcclxuICAgICAgICB9XHJcbiAgICAgICAgX2NvbE9yZGVyaW5nID0gXztcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICBfY2hhcnQuX2RvUmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9jaGFydC5yZXNldFN2ZygpO1xyXG5cclxuICAgICAgICBfY2hhcnRCb2R5ID0gX2NoYXJ0LnN2ZygpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnaGVhdG1hcCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBfY2hhcnQubWFyZ2lucygpLmxlZnQgKyAnLCcgKyBfY2hhcnQubWFyZ2lucygpLnRvcCArICcpJyk7XHJcblxyXG4gICAgICAgIHJldHVybiBfY2hhcnQuX2RvUmVkcmF3KCk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9jaGFydC5fZG9SZWRyYXcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSBfY2hhcnQuZGF0YSgpLFxyXG4gICAgICAgICAgICByb3dzID0gX2NoYXJ0LnJvd3MoKSB8fCBkYXRhLm1hcChfY2hhcnQudmFsdWVBY2Nlc3NvcigpKSxcclxuICAgICAgICAgICAgY29scyA9IF9jaGFydC5jb2xzKCkgfHwgZGF0YS5tYXAoX2NoYXJ0LmtleUFjY2Vzc29yKCkpO1xyXG4gICAgICAgIGlmIChfcm93T3JkZXJpbmcpIHtcclxuICAgICAgICAgICAgcm93cyA9IHJvd3Muc29ydChfcm93T3JkZXJpbmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoX2NvbE9yZGVyaW5nKSB7XHJcbiAgICAgICAgICAgIGNvbHMgPSBjb2xzLnNvcnQoX2NvbE9yZGVyaW5nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcm93cyA9IF9yb3dTY2FsZS5kb21haW4ocm93cyk7XHJcbiAgICAgICAgY29scyA9IF9jb2xTY2FsZS5kb21haW4oY29scyk7XHJcblxyXG4gICAgICAgIHZhciByb3dDb3VudCA9IHJvd3MuZG9tYWluKCkubGVuZ3RoLFxyXG4gICAgICAgICAgICBjb2xDb3VudCA9IGNvbHMuZG9tYWluKCkubGVuZ3RoLFxyXG4gICAgICAgICAgICBib3hXaWR0aCA9IE1hdGguZmxvb3IoX2NoYXJ0LmVmZmVjdGl2ZVdpZHRoKCkgLyBjb2xDb3VudCksXHJcbiAgICAgICAgICAgIGJveEhlaWdodCA9IE1hdGguZmxvb3IoX2NoYXJ0LmVmZmVjdGl2ZUhlaWdodCgpIC8gcm93Q291bnQpO1xyXG5cclxuICAgICAgICBjb2xzLnJhbmdlUm91bmQoWzAsIF9jaGFydC5lZmZlY3RpdmVXaWR0aCgpXSk7XHJcbiAgICAgICAgcm93cy5yYW5nZVJvdW5kKFtfY2hhcnQuZWZmZWN0aXZlSGVpZ2h0KCksIDBdKTtcclxuXHJcbiAgICAgICAgdmFyIGJveGVzID0gX2NoYXJ0Qm9keS5zZWxlY3RBbGwoJ2cuYm94LWdyb3VwJykuZGF0YShfY2hhcnQuZGF0YSgpLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2NoYXJ0LmtleUFjY2Vzc29yKCkoZCwgaSkgKyAnXFwwJyArIF9jaGFydC52YWx1ZUFjY2Vzc29yKCkoZCwgaSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGJveGVzLmV4aXQoKS5yZW1vdmUoKTtcclxuXHJcbiAgICAgICAgdmFyIGdFbnRlciA9IGJveGVzLmVudGVyKCkuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2JveC1ncm91cCcpO1xyXG5cclxuICAgICAgICBnRW50ZXIuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2hlYXQtYm94JylcclxuICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnd2hpdGUnKVxyXG4gICAgICAgICAgICAuYXR0cigneCcsIGZ1bmN0aW9uIChkLCBpKSB7IHJldHVybiBjb2xzKF9jaGFydC5rZXlBY2Nlc3NvcigpKGQsIGkpKTsgfSlcclxuICAgICAgICAgICAgLmF0dHIoJ3knLCBmdW5jdGlvbiAoZCwgaSkgeyByZXR1cm4gcm93cyhfY2hhcnQudmFsdWVBY2Nlc3NvcigpKGQsIGkpKTsgfSlcclxuICAgICAgICAgICAgLm9uKCdjbGljaycsIF9jaGFydC5ib3hPbkNsaWNrKCkpO1xyXG5cclxuICAgICAgICBpZiAoX2NoYXJ0LnJlbmRlclRpdGxlKCkpIHtcclxuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgndGl0bGUnKTtcclxuICAgICAgICAgICAgYm94ZXMuc2VsZWN0KCd0aXRsZScpLnRleHQoX2NoYXJ0LnRpdGxlKCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYm94ZXMgPSBnRW50ZXIubWVyZ2UoYm94ZXMpO1xyXG5cclxuICAgICAgICBkYy50cmFuc2l0aW9uKGJveGVzLnNlbGVjdCgncmVjdCcpLCBfY2hhcnQudHJhbnNpdGlvbkR1cmF0aW9uKCksIF9jaGFydC50cmFuc2l0aW9uRGVsYXkoKSlcclxuICAgICAgICAgICAgLmF0dHIoJ3gnLCBmdW5jdGlvbiAoZCwgaSkgeyByZXR1cm4gY29scyhfY2hhcnQua2V5QWNjZXNzb3IoKShkLCBpKSk7IH0pXHJcbiAgICAgICAgICAgIC5hdHRyKCd5JywgZnVuY3Rpb24gKGQsIGkpIHsgcmV0dXJuIHJvd3MoX2NoYXJ0LnZhbHVlQWNjZXNzb3IoKShkLCBpKSk7IH0pXHJcbiAgICAgICAgICAgIC5hdHRyKCdyeCcsIF94Qm9yZGVyUmFkaXVzKVxyXG4gICAgICAgICAgICAuYXR0cigncnknLCBfeUJvcmRlclJhZGl1cylcclxuICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCBfY2hhcnQuZ2V0Q29sb3IpXHJcbiAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIGJveFdpZHRoKVxyXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgYm94SGVpZ2h0KTtcclxuXHJcbiAgICAgICAgdmFyIGdDb2xzID0gX2NoYXJ0Qm9keS5zZWxlY3QoJ2cuY29scycpO1xyXG4gICAgICAgIGlmIChnQ29scy5lbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIGdDb2xzID0gX2NoYXJ0Qm9keS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdjb2xzIGF4aXMnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGdDb2xzVGV4dCA9IGdDb2xzLnNlbGVjdEFsbCgndGV4dCcpLmRhdGEoY29scy5kb21haW4oKSk7XHJcblxyXG4gICAgICAgIGdDb2xzVGV4dC5leGl0KCkucmVtb3ZlKCk7XHJcblxyXG4gICAgICAgIGdDb2xzVGV4dCA9IGdDb2xzVGV4dFxyXG4gICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbHMoZCkgKyBib3hXaWR0aCAvIDI7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBfY2hhcnQuZWZmZWN0aXZlSGVpZ2h0KCkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZHknLCAxMilcclxuICAgICAgICAgICAgICAgIC5vbignY2xpY2snLCBfY2hhcnQueEF4aXNPbkNsaWNrKCkpXHJcbiAgICAgICAgICAgICAgICAudGV4dChfY2hhcnQuY29sc0xhYmVsKCkpXHJcbiAgICAgICAgICAgIC5tZXJnZShnQ29sc1RleHQpO1xyXG5cclxuICAgICAgICBkYy50cmFuc2l0aW9uKGdDb2xzVGV4dCwgX2NoYXJ0LnRyYW5zaXRpb25EdXJhdGlvbigpLCBfY2hhcnQudHJhbnNpdGlvbkRlbGF5KCkpXHJcbiAgICAgICAgICAgICAgIC50ZXh0KF9jaGFydC5jb2xzTGFiZWwoKSlcclxuICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4gY29scyhkKSArIGJveFdpZHRoIC8gMjsgfSlcclxuICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBfY2hhcnQuZWZmZWN0aXZlSGVpZ2h0KCkpO1xyXG5cclxuICAgICAgICB2YXIgZ1Jvd3MgPSBfY2hhcnRCb2R5LnNlbGVjdCgnZy5yb3dzJyk7XHJcbiAgICAgICAgaWYgKGdSb3dzLmVtcHR5KCkpIHtcclxuICAgICAgICAgICAgZ1Jvd3MgPSBfY2hhcnRCb2R5LmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ3Jvd3MgYXhpcycpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGdSb3dzVGV4dCA9IGdSb3dzLnNlbGVjdEFsbCgndGV4dCcpLmRhdGEocm93cy5kb21haW4oKSk7XHJcblxyXG4gICAgICAgIGdSb3dzVGV4dC5leGl0KCkucmVtb3ZlKCk7XHJcblxyXG4gICAgICAgIGdSb3dzVGV4dCA9IGdSb3dzVGV4dFxyXG4gICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCAnZW5kJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgMClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdkeCcsIC0yKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4gcm93cyhkKSArIGJveEhlaWdodCAvIDI7IH0pXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZHknLCA2KVxyXG4gICAgICAgICAgICAgICAgLm9uKCdjbGljaycsIF9jaGFydC55QXhpc09uQ2xpY2soKSlcclxuICAgICAgICAgICAgICAgIC50ZXh0KF9jaGFydC5yb3dzTGFiZWwoKSlcclxuICAgICAgICAgICAgLm1lcmdlKGdSb3dzVGV4dCk7XHJcblxyXG4gICAgICAgIGRjLnRyYW5zaXRpb24oZ1Jvd3NUZXh0LCBfY2hhcnQudHJhbnNpdGlvbkR1cmF0aW9uKCksIF9jaGFydC50cmFuc2l0aW9uRGVsYXkoKSlcclxuICAgICAgICAgICAgICAudGV4dChfY2hhcnQucm93c0xhYmVsKCkpXHJcbiAgICAgICAgICAgICAgLmF0dHIoJ3knLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4gcm93cyhkKSArIGJveEhlaWdodCAvIDI7IH0pO1xyXG5cclxuICAgICAgICBpZiAoX2NoYXJ0Lmhhc0ZpbHRlcigpKSB7XHJcbiAgICAgICAgICAgIF9jaGFydC5zZWxlY3RBbGwoJ2cuYm94LWdyb3VwJykuZWFjaChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKF9jaGFydC5pc1NlbGVjdGVkTm9kZShkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIF9jaGFydC5oaWdobGlnaHRTZWxlY3RlZCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2NoYXJ0LmZhZGVEZXNlbGVjdGVkKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBfY2hhcnQuc2VsZWN0QWxsKCdnLmJveC1ncm91cCcpLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgX2NoYXJ0LnJlc2V0SGlnaGxpZ2h0KHRoaXMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGhhbmRsZXIgdGhhdCBmaXJlcyB3aGVuIGFuIGluZGl2aWR1YWwgY2VsbCBpcyBjbGlja2VkIGluIHRoZSBoZWF0bWFwLlxyXG4gICAgICogQnkgZGVmYXVsdCwgZmlsdGVyaW5nIG9mIHRoZSBjZWxsIHdpbGwgYmUgdG9nZ2xlZC5cclxuICAgICAqIEBtZXRob2QgYm94T25DbGlja1xyXG4gICAgICogQG1lbWJlcm9mIGRjLmhlYXRNYXBcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGRlZmF1bHQgYm94IG9uIGNsaWNrIGhhbmRsZXJcclxuICAgICAqIGNoYXJ0LmJveE9uQ2xpY2soZnVuY3Rpb24gKGQpIHtcclxuICAgICAqICAgICB2YXIgZmlsdGVyID0gZC5rZXk7XHJcbiAgICAgKiAgICAgZGMuZXZlbnRzLnRyaWdnZXIoZnVuY3Rpb24gKCkge1xyXG4gICAgICogICAgICAgICBfY2hhcnQuZmlsdGVyKGZpbHRlcik7XHJcbiAgICAgKiAgICAgICAgIF9jaGFydC5yZWRyYXdHcm91cCgpO1xyXG4gICAgICogICAgIH0pO1xyXG4gICAgICogfSk7XHJcbiAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gW2hhbmRsZXJdXHJcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb258ZGMuaGVhdE1hcH1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LmJveE9uQ2xpY2sgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2JveE9uQ2xpY2s7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9ib3hPbkNsaWNrID0gaGFuZGxlcjtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgaGFuZGxlciB0aGF0IGZpcmVzIHdoZW4gYSBjb2x1bW4gdGljayBpcyBjbGlja2VkIGluIHRoZSB4IGF4aXMuXHJcbiAgICAgKiBCeSBkZWZhdWx0LCBpZiBhbnkgY2VsbHMgaW4gdGhlIGNvbHVtbiBhcmUgdW5zZWxlY3RlZCwgdGhlIHdob2xlIGNvbHVtbiB3aWxsIGJlIHNlbGVjdGVkLFxyXG4gICAgICogb3RoZXJ3aXNlIHRoZSB3aG9sZSBjb2x1bW4gd2lsbCBiZSB1bnNlbGVjdGVkLlxyXG4gICAgICogQG1ldGhvZCB4QXhpc09uQ2xpY2tcclxuICAgICAqIEBtZW1iZXJvZiBkYy5oZWF0TWFwXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBbaGFuZGxlcl1cclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbnxkYy5oZWF0TWFwfVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQueEF4aXNPbkNsaWNrID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF94QXhpc09uQ2xpY2s7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF94QXhpc09uQ2xpY2sgPSBoYW5kbGVyO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBoYW5kbGVyIHRoYXQgZmlyZXMgd2hlbiBhIHJvdyB0aWNrIGlzIGNsaWNrZWQgaW4gdGhlIHkgYXhpcy5cclxuICAgICAqIEJ5IGRlZmF1bHQsIGlmIGFueSBjZWxscyBpbiB0aGUgcm93IGFyZSB1bnNlbGVjdGVkLCB0aGUgd2hvbGUgcm93IHdpbGwgYmUgc2VsZWN0ZWQsXHJcbiAgICAgKiBvdGhlcndpc2UgdGhlIHdob2xlIHJvdyB3aWxsIGJlIHVuc2VsZWN0ZWQuXHJcbiAgICAgKiBAbWV0aG9kIHlBeGlzT25DbGlja1xyXG4gICAgICogQG1lbWJlcm9mIGRjLmhlYXRNYXBcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IFtoYW5kbGVyXVxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufGRjLmhlYXRNYXB9XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC55QXhpc09uQ2xpY2sgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3lBeGlzT25DbGljaztcclxuICAgICAgICB9XHJcbiAgICAgICAgX3lBeGlzT25DbGljayA9IGhhbmRsZXI7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIFggYm9yZGVyIHJhZGl1cy4gIFNldCB0byAwIHRvIGdldCBmdWxsIHJlY3RhbmdsZXMuXHJcbiAgICAgKiBAbWV0aG9kIHhCb3JkZXJSYWRpdXNcclxuICAgICAqIEBtZW1iZXJvZiBkYy5oZWF0TWFwXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gW3hCb3JkZXJSYWRpdXM9Ni43NV1cclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ8ZGMuaGVhdE1hcH1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LnhCb3JkZXJSYWRpdXMgPSBmdW5jdGlvbiAoeEJvcmRlclJhZGl1cykge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3hCb3JkZXJSYWRpdXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF94Qm9yZGVyUmFkaXVzID0geEJvcmRlclJhZGl1cztcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgWSBib3JkZXIgcmFkaXVzLiAgU2V0IHRvIDAgdG8gZ2V0IGZ1bGwgcmVjdGFuZ2xlcy5cclxuICAgICAqIEBtZXRob2QgeUJvcmRlclJhZGl1c1xyXG4gICAgICogQG1lbWJlcm9mIGRjLmhlYXRNYXBcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBbeUJvcmRlclJhZGl1cz02Ljc1XVxyXG4gICAgICogQHJldHVybnMge051bWJlcnxkYy5oZWF0TWFwfVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQueUJvcmRlclJhZGl1cyA9IGZ1bmN0aW9uICh5Qm9yZGVyUmFkaXVzKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfeUJvcmRlclJhZGl1cztcclxuICAgICAgICB9XHJcbiAgICAgICAgX3lCb3JkZXJSYWRpdXMgPSB5Qm9yZGVyUmFkaXVzO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF9jaGFydC5pc1NlbGVjdGVkTm9kZSA9IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydC5oYXNGaWx0ZXIoZC5rZXkpO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gX2NoYXJ0LmFuY2hvcihwYXJlbnQsIGNoYXJ0R3JvdXApO1xyXG59O1xyXG5cclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXBsdWdpbnMvYmxvYi9tYXN0ZXIvYm94L2JveC5qc1xyXG4vLyAqIE9yaWdpbmFsIHNvdXJjZSBNYXJjaCAyMiwgMjAxM1xyXG4vLyAqIEVuaGFuY2VtZW50cyBpbnRlZ3JhdGVkIG9uIE1heSAxMywgMjAxOCBmb3IgZGMuanMgbGlicmFyeSBvbmx5XHJcblxyXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtcGx1Z2lucy9ibG9iL21hc3Rlci9MSUNFTlNFXHJcbi8vIENvcHlyaWdodCAoYykgMjAxMi0yMDE1LCBNaWNoYWVsIEJvc3RvY2tcclxuLy8gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuXHJcbi8vIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxyXG4vLyBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcclxuLy9cclxuLy8gKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcclxuLy8gICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cclxuLy9cclxuLy8gKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXHJcbi8vICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvblxyXG4vLyAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxyXG4vL1xyXG4vLyAqIFRoZSBuYW1lIE1pY2hhZWwgQm9zdG9jayBtYXkgbm90IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzXHJcbi8vICAgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXHJcbi8vXHJcbi8vIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXHJcbi8vIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcclxuLy8gSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXHJcbi8vIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIE1JQ0hBRUwgQk9TVE9DSyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsXHJcbi8vIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLFxyXG4vLyBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxyXG4vLyBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZXHJcbi8vIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXHJcbi8vIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSxcclxuLy8gRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cclxuKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAvLyBJbnNwaXJlZCBieSBodHRwOi8vaW5mb3JtYXRpb25hbmR2aXN1YWxpemF0aW9uLmRlL2Jsb2cvYm94LXBsb3RcclxuICAgIGQzLmJveCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgd2lkdGggPSAxLFxyXG4gICAgICAgICAgICBoZWlnaHQgPSAxLFxyXG4gICAgICAgICAgICBkdXJhdGlvbiA9IDAsXHJcbiAgICAgICAgICAgIGRlbGF5ID0gMCxcclxuICAgICAgICAgICAgZG9tYWluID0gbnVsbCxcclxuICAgICAgICAgICAgdmFsdWUgPSBOdW1iZXIsXHJcbiAgICAgICAgICAgIHdoaXNrZXJzID0gYm94V2hpc2tlcnMsXHJcbiAgICAgICAgICAgIHF1YXJ0aWxlcyA9IGJveFF1YXJ0aWxlcyxcclxuICAgICAgICAgICAgdGlja0Zvcm1hdCA9IG51bGwsXHJcblxyXG4gICAgICAgICAgICAvLyBFbmhhbmNlZCBhdHRyaWJ1dGVzXHJcbiAgICAgICAgICAgIHJlbmRlckRhdGFQb2ludHMgPSBmYWxzZSxcclxuICAgICAgICAgICAgZGF0YVJhZGl1cyA9IDMsXHJcbiAgICAgICAgICAgIGRhdGFPcGFjaXR5ID0gMC4zLFxyXG4gICAgICAgICAgICBkYXRhV2lkdGhQb3J0aW9uID0gMC44LFxyXG4gICAgICAgICAgICByZW5kZXJUaXRsZSA9IGZhbHNlLFxyXG4gICAgICAgICAgICBzaG93T3V0bGllcnMgPSB0cnVlLFxyXG4gICAgICAgICAgICBib2xkT3V0bGllciA9IGZhbHNlO1xyXG5cclxuICAgICAgICAvLyBGb3IgZWFjaCBzbWFsbCBtdWx0aXBsZeKAplxyXG4gICAgICAgIGZ1bmN0aW9uIGJveCAoZykge1xyXG4gICAgICAgICAgICAvKiBqc2hpbnQgLVcwNzQgKi9cclxuICAgICAgICAgICAgZy5lYWNoKGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICAgICAgICBkID0gZC5tYXAodmFsdWUpLnNvcnQoZDMuYXNjZW5kaW5nKTtcclxuICAgICAgICAgICAgICAgIHZhciBnID0gZDMuc2VsZWN0KHRoaXMpLFxyXG4gICAgICAgICAgICAgICAgICAgIG4gPSBkLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICBtaW4sXHJcbiAgICAgICAgICAgICAgICAgICAgbWF4O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIExlYXZlIGlmIHRoZXJlIGFyZSBubyBpdGVtcy5cclxuICAgICAgICAgICAgICAgIGlmIChuID09PSAwKSB7cmV0dXJuO31cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIHF1YXJ0aWxlcy4gTXVzdCByZXR1cm4gZXhhY3RseSAzIGVsZW1lbnRzLlxyXG4gICAgICAgICAgICAgICAgdmFyIHF1YXJ0aWxlRGF0YSA9IGQucXVhcnRpbGVzID0gcXVhcnRpbGVzKGQpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgd2hpc2tlcnMuIE11c3QgcmV0dXJuIGV4YWN0bHkgMiBlbGVtZW50cywgb3IgbnVsbC5cclxuICAgICAgICAgICAgICAgIHZhciB3aGlza2VySW5kaWNlcyA9IHdoaXNrZXJzICYmIHdoaXNrZXJzLmNhbGwodGhpcywgZCwgaSksXHJcbiAgICAgICAgICAgICAgICAgICAgd2hpc2tlckRhdGEgPSB3aGlza2VySW5kaWNlcyAmJiB3aGlza2VySW5kaWNlcy5tYXAoZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGRbaV07IH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgb3V0bGllcnMuIElmIG5vIHdoaXNrZXJzIGFyZSBzcGVjaWZpZWQsIGFsbCBkYXRhIGFyZSAnb3V0bGllcnMnLlxyXG4gICAgICAgICAgICAgICAgLy8gV2UgY29tcHV0ZSB0aGUgb3V0bGllcnMgYXMgaW5kaWNlcywgc28gdGhhdCB3ZSBjYW4gam9pbiBhY3Jvc3MgdHJhbnNpdGlvbnMhXHJcbiAgICAgICAgICAgICAgICB2YXIgb3V0bGllckluZGljZXMgPSB3aGlza2VySW5kaWNlcyA/XHJcbiAgICAgICAgICAgICAgICAgICAgZDMucmFuZ2UoMCwgd2hpc2tlckluZGljZXNbMF0pLmNvbmNhdChkMy5yYW5nZSh3aGlza2VySW5kaWNlc1sxXSArIDEsIG4pKSA6IGQzLnJhbmdlKG4pO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIERldGVybWluZSB0aGUgbWF4aW11bSB2YWx1ZSBiYXNlZCBvbiBpZiBvdXRsaWVycyBhcmUgc2hvd25cclxuICAgICAgICAgICAgICAgIGlmIChzaG93T3V0bGllcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBkWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIG1heCA9IGRbbiAtIDFdO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBkW3doaXNrZXJJbmRpY2VzWzBdXTtcclxuICAgICAgICAgICAgICAgICAgICBtYXggPSBkW3doaXNrZXJJbmRpY2VzWzFdXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBwb2ludEluZGljZXMgPSBkMy5yYW5nZSh3aGlza2VySW5kaWNlc1swXSwgd2hpc2tlckluZGljZXNbMV0gKyAxKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBuZXcgeC1zY2FsZS5cclxuICAgICAgICAgICAgICAgIHZhciB4MSA9IGQzLnNjYWxlTGluZWFyKClcclxuICAgICAgICAgICAgICAgICAgICAuZG9tYWluKGRvbWFpbiAmJiBkb21haW4uY2FsbCh0aGlzLCBkLCBpKSB8fCBbbWluLCBtYXhdKVxyXG4gICAgICAgICAgICAgICAgICAgIC5yYW5nZShbaGVpZ2h0LCAwXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmV0cmlldmUgdGhlIG9sZCB4LXNjYWxlLCBpZiB0aGlzIGlzIGFuIHVwZGF0ZS5cclxuICAgICAgICAgICAgICAgIHZhciB4MCA9IHRoaXMuX19jaGFydF9fIHx8IGQzLnNjYWxlTGluZWFyKClcclxuICAgICAgICAgICAgICAgICAgICAuZG9tYWluKFswLCBJbmZpbml0eV0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnJhbmdlKHgxLnJhbmdlKCkpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFN0YXNoIHRoZSBuZXcgc2NhbGUuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fY2hhcnRfXyA9IHgxO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIE5vdGU6IHRoZSBib3gsIG1lZGlhbiwgYW5kIGJveCB0aWNrIGVsZW1lbnRzIGFyZSBmaXhlZCBpbiBudW1iZXIsXHJcbiAgICAgICAgICAgICAgICAvLyBzbyB3ZSBvbmx5IGhhdmUgdG8gaGFuZGxlIGVudGVyIGFuZCB1cGRhdGUuIEluIGNvbnRyYXN0LCB0aGUgb3V0bGllcnNcclxuICAgICAgICAgICAgICAgIC8vIGFuZCBvdGhlciBlbGVtZW50cyBhcmUgdmFyaWFibGUsIHNvIHdlIG5lZWQgdG8gZXhpdCB0aGVtISBWYXJpYWJsZVxyXG4gICAgICAgICAgICAgICAgLy8gZWxlbWVudHMgYWxzbyBmYWRlIGluIGFuZCBvdXQuXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGNlbnRlciBsaW5lOiB0aGUgdmVydGljYWwgbGluZSBzcGFubmluZyB0aGUgd2hpc2tlcnMuXHJcbiAgICAgICAgICAgICAgICB2YXIgY2VudGVyID0gZy5zZWxlY3RBbGwoJ2xpbmUuY2VudGVyJylcclxuICAgICAgICAgICAgICAgICAgICAuZGF0YSh3aGlza2VyRGF0YSA/IFt3aGlza2VyRGF0YV0gOiBbXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgY2VudGVyLmVudGVyKCkuaW5zZXJ0KCdsaW5lJywgJ3JlY3QnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdjZW50ZXInKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIHdpZHRoIC8gMilcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTEnLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4geDAoZFswXSk7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgd2lkdGggLyAyKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIGZ1bmN0aW9uIChkKSB7IHJldHVybiB4MChkWzFdKTsgfSlcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAxZS02KVxyXG4gICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oZHVyYXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgLmRlbGF5KGRlbGF5KVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDEpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIHgxKGRbMF0pOyB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIGZ1bmN0aW9uIChkKSB7IHJldHVybiB4MShkWzFdKTsgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgY2VudGVyLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbihkdXJhdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAuZGVsYXkoZGVsYXkpXHJcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDEnLCB3aWR0aCAvIDIpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgd2lkdGggLyAyKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIGZ1bmN0aW9uIChkKSB7IHJldHVybiB4MShkWzBdKTsgfSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTInLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4geDEoZFsxXSk7IH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGNlbnRlci5leGl0KCkudHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKGR1cmF0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kZWxheShkZWxheSlcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAxZS02KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIGZ1bmN0aW9uIChkKSB7IHJldHVybiB4MShkWzBdKTsgfSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTInLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4geDEoZFsxXSk7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnJlbW92ZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBpbm5lcnF1YXJ0aWxlIGJveC5cclxuICAgICAgICAgICAgICAgIHZhciBib3ggPSBnLnNlbGVjdEFsbCgncmVjdC5ib3gnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kYXRhKFtxdWFydGlsZURhdGFdKTtcclxuXHJcbiAgICAgICAgICAgICAgICBib3guZW50ZXIoKS5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdib3gnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgMClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIGZ1bmN0aW9uIChkKSB7IHJldHVybiB4MChkWzJdKTsgfSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCB3aWR0aClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIHgwKGRbMF0pIC0geDAoZFsyXSk7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsLW9wYWNpdHknLCAocmVuZGVyRGF0YVBvaW50cykgPyAwLjEgOiAxKVxyXG4gICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oZHVyYXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgLmRlbGF5KGRlbGF5KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIHgxKGRbMl0pOyB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4geDEoZFswXSkgLSB4MShkWzJdKTsgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgYm94LnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbihkdXJhdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAuZGVsYXkoZGVsYXkpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgd2lkdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4geDEoZFsyXSk7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGZ1bmN0aW9uIChkKSB7IHJldHVybiB4MShkWzBdKSAtIHgxKGRbMl0pOyB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgbWVkaWFuIGxpbmUuXHJcbiAgICAgICAgICAgICAgICB2YXIgbWVkaWFuTGluZSA9IGcuc2VsZWN0QWxsKCdsaW5lLm1lZGlhbicpXHJcbiAgICAgICAgICAgICAgICAgICAgLmRhdGEoW3F1YXJ0aWxlRGF0YVsxXV0pO1xyXG5cclxuICAgICAgICAgICAgICAgIG1lZGlhbkxpbmUuZW50ZXIoKS5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdtZWRpYW4nKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIDApXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgeDApXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgd2lkdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgeDApXHJcbiAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbihkdXJhdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAuZGVsYXkoZGVsYXkpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgeDEpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgeDEpO1xyXG5cclxuICAgICAgICAgICAgICAgIG1lZGlhbkxpbmUudHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKGR1cmF0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kZWxheShkZWxheSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDEnLCAwKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MicsIHdpZHRoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIHgxKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIHgxKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgd2hpc2tlcnMuXHJcbiAgICAgICAgICAgICAgICB2YXIgd2hpc2tlciA9IGcuc2VsZWN0QWxsKCdsaW5lLndoaXNrZXInKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kYXRhKHdoaXNrZXJEYXRhIHx8IFtdKTtcclxuXHJcbiAgICAgICAgICAgICAgICB3aGlza2VyLmVudGVyKCkuaW5zZXJ0KCdsaW5lJywgJ2NpcmNsZSwgdGV4dCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3doaXNrZXInKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIDApXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgeDApXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgd2lkdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgeDApXHJcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMWUtNilcclxuICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKGR1cmF0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kZWxheShkZWxheSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTEnLCB4MSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTInLCB4MSlcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAxKTtcclxuXHJcbiAgICAgICAgICAgICAgICB3aGlza2VyLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbihkdXJhdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAuZGVsYXkoZGVsYXkpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgMClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDInLCB3aWR0aClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTEnLCB4MSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTInLCB4MSlcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAxKTtcclxuXHJcbiAgICAgICAgICAgICAgICB3aGlza2VyLmV4aXQoKS50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oZHVyYXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgLmRlbGF5KGRlbGF5KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIHgxKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIHgxKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDFlLTYpXHJcbiAgICAgICAgICAgICAgICAgICAgLnJlbW92ZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBvdXRsaWVycy5cclxuICAgICAgICAgICAgICAgIGlmIChzaG93T3V0bGllcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3V0bGllckNsYXNzID0gYm9sZE91dGxpZXIgPyAnb3V0bGllckJvbGQnIDogJ291dGxpZXInO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvdXRsaWVyU2l6ZSA9IGJvbGRPdXRsaWVyID8gMyA6IDU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG91dGxpZXJYID0gYm9sZE91dGxpZXIgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHdpZHRoICogZGF0YVdpZHRoUG9ydGlvbikgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMSArICgod2lkdGggLSAod2lkdGggKiBkYXRhV2lkdGhQb3J0aW9uKSkgLyAyKSk7IH0gOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiB3aWR0aCAvIDI7IH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvdXRsaWVyID0gZy5zZWxlY3RBbGwoJ2NpcmNsZS4nICsgb3V0bGllckNsYXNzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuZGF0YShvdXRsaWVySW5kaWNlcywgTnVtYmVyKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0bGllci5lbnRlcigpLmluc2VydCgnY2lyY2xlJywgJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCBvdXRsaWVyQ2xhc3MpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdyJywgb3V0bGllclNpemUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjeCcsIG91dGxpZXJYKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignY3knLCBmdW5jdGlvbiAoaSkgeyByZXR1cm4geDAoZFtpXSk7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDFlLTYpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKGR1cmF0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuZGVsYXkoZGVsYXkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjeScsIGZ1bmN0aW9uIChpKSB7IHJldHVybiB4MShkW2ldKTsgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMC42KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbmRlclRpdGxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dGxpZXIuc2VsZWN0QWxsKCd0aXRsZScpLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRsaWVyLmFwcGVuZCgndGl0bGUnKS50ZXh0KGZ1bmN0aW9uIChpKSB7cmV0dXJuIGRbaV07IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0bGllci50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKGR1cmF0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuZGVsYXkoZGVsYXkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjeCcsIG91dGxpZXJYKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignY3knLCBmdW5jdGlvbiAoaSkgeyByZXR1cm4geDEoZFtpXSk7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDAuNik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG91dGxpZXIuZXhpdCgpLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oZHVyYXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5kZWxheShkZWxheSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2N5JywgMCkgLy9mdW5jdGlvbiAoaSkgeyByZXR1cm4geDEoZFtpXSk7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDFlLTYpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgVmFsdWVzXHJcbiAgICAgICAgICAgICAgICBpZiAocmVuZGVyRGF0YVBvaW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwb2ludCA9IGcuc2VsZWN0QWxsKCdjaXJjbGUuZGF0YScpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5kYXRhKHBvaW50SW5kaWNlcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50LmVudGVyKCkuaW5zZXJ0KCdjaXJjbGUnLCAndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdkYXRhJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3InLCBkYXRhUmFkaXVzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignY3gnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHdpZHRoICogZGF0YVdpZHRoUG9ydGlvbikgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMSArICgod2lkdGggLSAod2lkdGggKiBkYXRhV2lkdGhQb3J0aW9uKSkgLyAyKSk7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjeScsIGZ1bmN0aW9uIChpKSB7IHJldHVybiB4MChkW2ldKTsgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMWUtNilcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oZHVyYXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5kZWxheShkZWxheSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2N5JywgZnVuY3Rpb24gKGkpIHsgcmV0dXJuIHgxKGRbaV0pOyB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCBkYXRhT3BhY2l0eSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZW5kZXJUaXRsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludC5zZWxlY3RBbGwoJ3RpdGxlJykucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50LmFwcGVuZCgndGl0bGUnKS50ZXh0KGZ1bmN0aW9uIChpKSB7IHJldHVybiBkW2ldOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50LnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oZHVyYXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5kZWxheShkZWxheSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2N4JywgZnVuY3Rpb24gKCkgeyByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICh3aWR0aCAqIGRhdGFXaWR0aFBvcnRpb24pICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEgKyAoKHdpZHRoIC0gKHdpZHRoICogZGF0YVdpZHRoUG9ydGlvbikpIC8gMikpOyB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignY3knLCBmdW5jdGlvbiAoaSkgeyByZXR1cm4geDEoZFtpXSk7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIGRhdGFPcGFjaXR5KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQuZXhpdCgpLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oZHVyYXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5kZWxheShkZWxheSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2N5JywgMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMWUtNilcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIHRpY2sgZm9ybWF0LlxyXG4gICAgICAgICAgICAgICAgdmFyIGZvcm1hdCA9IHRpY2tGb3JtYXQgfHwgeDEudGlja0Zvcm1hdCg4KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgYm94IHRpY2tzLlxyXG4gICAgICAgICAgICAgICAgdmFyIGJveFRpY2sgPSBnLnNlbGVjdEFsbCgndGV4dC5ib3gnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kYXRhKHF1YXJ0aWxlRGF0YSk7XHJcblxyXG4gICAgICAgICAgICAgICAgYm94VGljay5lbnRlcigpLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2JveCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgJy4zZW0nKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkeCcsIGZ1bmN0aW9uIChkLCBpKSB7IHJldHVybiBpICYgMSA/IDYgOiAtNjsgfSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIGZ1bmN0aW9uIChkLCBpKSB7IHJldHVybiBpICYgMSA/IHdpZHRoIDogMDsgfSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIHgwKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsIGZ1bmN0aW9uIChkLCBpKSB7IHJldHVybiBpICYgMSA/ICdzdGFydCcgOiAnZW5kJzsgfSlcclxuICAgICAgICAgICAgICAgICAgICAudGV4dChmb3JtYXQpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbihkdXJhdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAuZGVsYXkoZGVsYXkpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCB4MSk7XHJcblxyXG4gICAgICAgICAgICAgICAgYm94VGljay50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oZHVyYXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgLmRlbGF5KGRlbGF5KVxyXG4gICAgICAgICAgICAgICAgICAgIC50ZXh0KGZvcm1hdClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIGZ1bmN0aW9uIChkLCBpKSB7IHJldHVybiBpICYgMSA/IHdpZHRoIDogMDsgfSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIHgxKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgd2hpc2tlciB0aWNrcy4gVGhlc2UgYXJlIGhhbmRsZWQgc2VwYXJhdGVseSBmcm9tIHRoZSBib3hcclxuICAgICAgICAgICAgICAgIC8vIHRpY2tzIGJlY2F1c2UgdGhleSBtYXkgb3IgbWF5IG5vdCBleGlzdCwgYW5kIHdlIHdhbnQgZG9uJ3Qgd2FudFxyXG4gICAgICAgICAgICAgICAgLy8gdG8gam9pbiBib3ggdGlja3MgcHJlLXRyYW5zaXRpb24gd2l0aCB3aGlza2VyIHRpY2tzIHBvc3QtLlxyXG4gICAgICAgICAgICAgICAgdmFyIHdoaXNrZXJUaWNrID0gZy5zZWxlY3RBbGwoJ3RleHQud2hpc2tlcicpXHJcbiAgICAgICAgICAgICAgICAgICAgLmRhdGEod2hpc2tlckRhdGEgfHwgW10pO1xyXG5cclxuICAgICAgICAgICAgICAgIHdoaXNrZXJUaWNrLmVudGVyKCkuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnd2hpc2tlcicpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgJy4zZW0nKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkeCcsIDYpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCB3aWR0aClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIHgwKVxyXG4gICAgICAgICAgICAgICAgICAgIC50ZXh0KGZvcm1hdClcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAxZS02KVxyXG4gICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oZHVyYXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgLmRlbGF5KGRlbGF5KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgeDEpXHJcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgd2hpc2tlclRpY2sudHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKGR1cmF0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kZWxheShkZWxheSlcclxuICAgICAgICAgICAgICAgICAgICAudGV4dChmb3JtYXQpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCB3aWR0aClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIHgxKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDEpO1xyXG5cclxuICAgICAgICAgICAgICAgIHdoaXNrZXJUaWNrLmV4aXQoKS50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oZHVyYXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgLmRlbGF5KGRlbGF5KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgeDEpXHJcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMWUtNilcclxuICAgICAgICAgICAgICAgICAgICAucmVtb3ZlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRlbXBvcmFyeSBxdWFydGlsZXMgZWxlbWVudCBmcm9tIHdpdGhpbiBkYXRhIGFycmF5LlxyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGQucXVhcnRpbGVzO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLyoganNoaW50ICtXMDc0ICovXHJcbiAgICAgICAgICAgIGQzLnRpbWVyRmx1c2goKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGJveC53aWR0aCA9IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpZHRoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHdpZHRoID0geDtcclxuICAgICAgICAgICAgcmV0dXJuIGJveDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBib3guaGVpZ2h0ID0gZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGhlaWdodCA9IHg7XHJcbiAgICAgICAgICAgIHJldHVybiBib3g7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgYm94LnRpY2tGb3JtYXQgPSBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aWNrRm9ybWF0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRpY2tGb3JtYXQgPSB4O1xyXG4gICAgICAgICAgICByZXR1cm4gYm94O1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGJveC5zaG93T3V0bGllcnMgPSBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzaG93T3V0bGllcnM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2hvd091dGxpZXJzID0geDtcclxuICAgICAgICAgICAgcmV0dXJuIGJveDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBib3guYm9sZE91dGxpZXIgPSBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBib2xkT3V0bGllcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBib2xkT3V0bGllciA9IHg7XHJcbiAgICAgICAgICAgIHJldHVybiBib3g7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgYm94LnJlbmRlckRhdGFQb2ludHMgPSBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJEYXRhUG9pbnRzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlbmRlckRhdGFQb2ludHMgPSB4O1xyXG4gICAgICAgICAgICByZXR1cm4gYm94O1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGJveC5yZW5kZXJUaXRsZSA9IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlclRpdGxlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlbmRlclRpdGxlID0geDtcclxuICAgICAgICAgICAgcmV0dXJuIGJveDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBib3guZGF0YU9wYWNpdHkgPSBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhT3BhY2l0eTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkYXRhT3BhY2l0eSA9IHg7XHJcbiAgICAgICAgICAgIHJldHVybiBib3g7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgYm94LmRhdGFXaWR0aFBvcnRpb24gPSBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhV2lkdGhQb3J0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRhdGFXaWR0aFBvcnRpb24gPSB4O1xyXG4gICAgICAgICAgICByZXR1cm4gYm94O1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGJveC5kdXJhdGlvbiA9IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGR1cmF0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGR1cmF0aW9uID0geDtcclxuICAgICAgICAgICAgcmV0dXJuIGJveDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBib3guZG9tYWluID0gZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9tYWluO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRvbWFpbiA9IHggPT09IG51bGwgPyB4IDogIHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nID8geCA6IGRjLnV0aWxzLmNvbnN0YW50KHgpO1xyXG4gICAgICAgICAgICByZXR1cm4gYm94O1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGJveC52YWx1ZSA9IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhbHVlID0geDtcclxuICAgICAgICAgICAgcmV0dXJuIGJveDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBib3gud2hpc2tlcnMgPSBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB3aGlza2VycztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB3aGlza2VycyA9IHg7XHJcbiAgICAgICAgICAgIHJldHVybiBib3g7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgYm94LnF1YXJ0aWxlcyA9IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHF1YXJ0aWxlcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBxdWFydGlsZXMgPSB4O1xyXG4gICAgICAgICAgICByZXR1cm4gYm94O1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiBib3g7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGJveFdoaXNrZXJzIChkKSB7XHJcbiAgICAgICAgcmV0dXJuIFswLCBkLmxlbmd0aCAtIDFdO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGJveFF1YXJ0aWxlcyAoZCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIGQzLnF1YW50aWxlKGQsIDAuMjUpLFxyXG4gICAgICAgICAgICBkMy5xdWFudGlsZShkLCAwLjUpLFxyXG4gICAgICAgICAgICBkMy5xdWFudGlsZShkLCAwLjc1KVxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcblxyXG59KSgpO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogQSBib3ggcGxvdCBpcyBhIGNoYXJ0IHRoYXQgZGVwaWN0cyBudW1lcmljYWwgZGF0YSB2aWEgdGhlaXIgcXVhcnRpbGUgcmFuZ2VzLlxyXG4gKlxyXG4gKiBFeGFtcGxlczpcclxuICogLSB7QGxpbmsgaHR0cDovL2RjLWpzLmdpdGh1Yi5pby9kYy5qcy9leGFtcGxlcy9ib3hwbG90LWJhc2ljLmh0bWwgQm94cGxvdCBCYXNpYyBleGFtcGxlfVxyXG4gKiAtIHtAbGluayBodHRwOi8vZGMtanMuZ2l0aHViLmlvL2RjLmpzL2V4YW1wbGVzL2JveHBsb3QtZW5oYW5jZWQuaHRtbCBCb3hwbG90IEVuaGFuY2VkIGV4YW1wbGV9XHJcbiAqIC0ge0BsaW5rIGh0dHA6Ly9kYy1qcy5naXRodWIuaW8vZGMuanMvZXhhbXBsZXMvYm94cGxvdC1yZW5kZXItZGF0YS5odG1sIEJveHBsb3QgUmVuZGVyIERhdGEgZXhhbXBsZX1cclxuICogLSB7QGxpbmsgaHR0cDovL2RjLWpzLmdpdGh1Yi5pby9kYy5qcy9leGFtcGxlcy9ib3hwbG90LXRpbWUuaHRtbCBCb3hwbG90IHRpbWUgZXhhbXBsZX1cclxuICogQGNsYXNzIGJveFBsb3RcclxuICogQG1lbWJlcm9mIGRjXHJcbiAqIEBtaXhlcyBkYy5jb29yZGluYXRlR3JpZE1peGluXHJcbiAqIEBleGFtcGxlXHJcbiAqIC8vIGNyZWF0ZSBhIGJveCBwbG90IHVuZGVyICNjaGFydC1jb250YWluZXIxIGVsZW1lbnQgdXNpbmcgdGhlIGRlZmF1bHQgZ2xvYmFsIGNoYXJ0IGdyb3VwXHJcbiAqIHZhciBib3hQbG90MSA9IGRjLmJveFBsb3QoJyNjaGFydC1jb250YWluZXIxJyk7XHJcbiAqIC8vIGNyZWF0ZSBhIGJveCBwbG90IHVuZGVyICNjaGFydC1jb250YWluZXIyIGVsZW1lbnQgdXNpbmcgY2hhcnQgZ3JvdXAgQVxyXG4gKiB2YXIgYm94UGxvdDIgPSBkYy5ib3hQbG90KCcjY2hhcnQtY29udGFpbmVyMicsICdjaGFydEdyb3VwQScpO1xyXG4gKiBAcGFyYW0ge1N0cmluZ3xub2RlfGQzLnNlbGVjdGlvbn0gcGFyZW50IC0gQW55IHZhbGlkXHJcbiAqIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2VsZWN0aW9uL2Jsb2IvbWFzdGVyL1JFQURNRS5tZCNzZWxlY3QgZDMgc2luZ2xlIHNlbGVjdG9yfSBzcGVjaWZ5aW5nXHJcbiAqIGEgZG9tIGJsb2NrIGVsZW1lbnQgc3VjaCBhcyBhIGRpdjsgb3IgYSBkb20gZWxlbWVudCBvciBkMyBzZWxlY3Rpb24uXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbY2hhcnRHcm91cF0gLSBUaGUgbmFtZSBvZiB0aGUgY2hhcnQgZ3JvdXAgdGhpcyBjaGFydCBpbnN0YW5jZSBzaG91bGQgYmUgcGxhY2VkIGluLlxyXG4gKiBJbnRlcmFjdGlvbiB3aXRoIGEgY2hhcnQgd2lsbCBvbmx5IHRyaWdnZXIgZXZlbnRzIGFuZCByZWRyYXdzIHdpdGhpbiB0aGUgY2hhcnQncyBncm91cC5cclxuICogQHJldHVybnMge2RjLmJveFBsb3R9XHJcbiAqL1xyXG5kYy5ib3hQbG90ID0gZnVuY3Rpb24gKHBhcmVudCwgY2hhcnRHcm91cCkge1xyXG4gICAgdmFyIF9jaGFydCA9IGRjLmNvb3JkaW5hdGVHcmlkTWl4aW4oe30pO1xyXG5cclxuICAgIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0byBjb21wdXRlIHRoZSBpbnRlcnF1YXJ0aWxlIHJhbmdlLlxyXG4gICAgZnVuY3Rpb24gREVGQVVMVF9XSElTS0VSU19JUVIgKGspIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgdmFyIHExID0gZC5xdWFydGlsZXNbMF0sXHJcbiAgICAgICAgICAgICAgICBxMyA9IGQucXVhcnRpbGVzWzJdLFxyXG4gICAgICAgICAgICAgICAgaXFyID0gKHEzIC0gcTEpICogayxcclxuICAgICAgICAgICAgICAgIGkgPSAtMSxcclxuICAgICAgICAgICAgICAgIGogPSBkLmxlbmd0aDtcclxuICAgICAgICAgICAgZG8geyArK2k7IH0gd2hpbGUgKGRbaV0gPCBxMSAtIGlxcik7XHJcbiAgICAgICAgICAgIGRvIHsgLS1qOyB9IHdoaWxlIChkW2pdID4gcTMgKyBpcXIpO1xyXG4gICAgICAgICAgICByZXR1cm4gW2ksIGpdO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIF93aGlza2VySXFyRmFjdG9yID0gMS41O1xyXG4gICAgdmFyIF93aGlza2Vyc0lxciA9IERFRkFVTFRfV0hJU0tFUlNfSVFSO1xyXG4gICAgdmFyIF93aGlza2VycyA9IF93aGlza2Vyc0lxcihfd2hpc2tlcklxckZhY3Rvcik7XHJcblxyXG4gICAgdmFyIF9ib3ggPSBkMy5ib3goKTtcclxuICAgIHZhciBfdGlja0Zvcm1hdCA9IG51bGw7XHJcbiAgICB2YXIgX3JlbmRlckRhdGFQb2ludHMgPSBmYWxzZTtcclxuICAgIHZhciBfZGF0YU9wYWNpdHkgPSAwLjM7XHJcbiAgICB2YXIgX2RhdGFXaWR0aFBvcnRpb24gPSAwLjg7XHJcbiAgICB2YXIgX3Nob3dPdXRsaWVycyA9IHRydWU7XHJcbiAgICB2YXIgX2JvbGRPdXRsaWVyID0gZmFsc2U7XHJcblxyXG4gICAgLy8gVXNlZCBpbiB5QXhpc01pbiBhbmQgeUF4aXNNYXggdG8gYWRkIHBhZGRpbmcgaW4gcGl4ZWwgY29vcmRpbmF0ZXNcclxuICAgIC8vIHNvIHRoZSBtaW4gYW5kIG1heCBkYXRhIHBvaW50cy93aGlza2VycyBhcmUgd2l0aGluIHRoZSBjaGFydFxyXG4gICAgdmFyIF95UmFuZ2VQYWRkaW5nID0gODtcclxuXHJcbiAgICB2YXIgX2JveFdpZHRoID0gZnVuY3Rpb24gKGlubmVyQ2hhcnRXaWR0aCwgeFVuaXRzKSB7XHJcbiAgICAgICAgaWYgKF9jaGFydC5pc09yZGluYWwoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2NoYXJ0LngoKS5iYW5kd2lkdGgoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gaW5uZXJDaGFydFdpZHRoIC8gKDEgKyBfY2hhcnQuYm94UGFkZGluZygpKSAvIHhVbml0cztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIGRlZmF1bHQgdG8gb3JkaW5hbFxyXG4gICAgX2NoYXJ0LngoZDMuc2NhbGVCYW5kKCkpO1xyXG4gICAgX2NoYXJ0LnhVbml0cyhkYy51bml0cy5vcmRpbmFsKTtcclxuXHJcbiAgICAvLyB2YWx1ZUFjY2Vzc29yIHNob3VsZCByZXR1cm4gYW4gYXJyYXkgb2YgdmFsdWVzIHRoYXQgY2FuIGJlIGNvZXJjZWQgaW50byBudW1iZXJzXHJcbiAgICAvLyBvciBpZiBkYXRhIGlzIG92ZXJsb2FkZWQgZm9yIGEgc3RhdGljIGFycmF5IG9mIGFycmF5cywgaXQgc2hvdWxkIGJlIGBOdW1iZXJgLlxyXG4gICAgLy8gRW1wdHkgYXJyYXlzIGFyZSBub3QgaW5jbHVkZWQuXHJcbiAgICBfY2hhcnQuZGF0YShmdW5jdGlvbiAoZ3JvdXApIHtcclxuICAgICAgICByZXR1cm4gZ3JvdXAuYWxsKCkubWFwKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIGQubWFwID0gZnVuY3Rpb24gKGFjY2Vzc29yKSB7IHJldHVybiBhY2Nlc3Nvci5jYWxsKGQsIGQpOyB9O1xyXG4gICAgICAgICAgICByZXR1cm4gZDtcclxuICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IF9jaGFydC52YWx1ZUFjY2Vzc29yKCkoZCk7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXMubGVuZ3RoICE9PSAwO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgb3Igc2V0IHRoZSBzcGFjaW5nIGJldHdlZW4gYm94ZXMgYXMgYSBmcmFjdGlvbiBvZiBib3ggc2l6ZS4gVmFsaWQgdmFsdWVzIGFyZSB3aXRoaW4gMC0xLlxyXG4gICAgICogU2VlIHRoZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNjYWxlL2Jsb2IvbWFzdGVyL1JFQURNRS5tZCNzY2FsZUJhbmQgZDMgZG9jc31cclxuICAgICAqIGZvciBhIHZpc3VhbCBkZXNjcmlwdGlvbiBvZiBob3cgdGhlIHBhZGRpbmcgaXMgYXBwbGllZC5cclxuICAgICAqIEBtZXRob2QgYm94UGFkZGluZ1xyXG4gICAgICogQG1lbWJlcm9mIGRjLmJveFBsb3RcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNjYWxlL2Jsb2IvbWFzdGVyL1JFQURNRS5tZCNzY2FsZUJhbmQgZDMuc2NhbGVCYW5kfVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYWRkaW5nPTAuOF1cclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ8ZGMuYm94UGxvdH1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LmJveFBhZGRpbmcgPSBfY2hhcnQuX3JhbmdlQmFuZFBhZGRpbmc7XHJcbiAgICBfY2hhcnQuYm94UGFkZGluZygwLjgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IG9yIHNldCB0aGUgb3V0ZXIgcGFkZGluZyBvbiBhbiBvcmRpbmFsIGJveCBjaGFydC4gVGhpcyBzZXR0aW5nIGhhcyBubyBlZmZlY3Qgb24gbm9uLW9yZGluYWwgY2hhcnRzXHJcbiAgICAgKiBvciBvbiBjaGFydHMgd2l0aCBhIGN1c3RvbSB7QGxpbmsgZGMuYm94UGxvdCNib3hXaWR0aCAuYm94V2lkdGh9LiBXaWxsIHBhZCB0aGUgd2lkdGggYnlcclxuICAgICAqIGBwYWRkaW5nICogYmFyV2lkdGhgIG9uIGVhY2ggc2lkZSBvZiB0aGUgY2hhcnQuXHJcbiAgICAgKiBAbWV0aG9kIG91dGVyUGFkZGluZ1xyXG4gICAgICogQG1lbWJlcm9mIGRjLmJveFBsb3RcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYWRkaW5nPTAuNV1cclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ8ZGMuYm94UGxvdH1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0Lm91dGVyUGFkZGluZyA9IF9jaGFydC5fb3V0ZXJSYW5nZUJhbmRQYWRkaW5nO1xyXG4gICAgX2NoYXJ0Lm91dGVyUGFkZGluZygwLjUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IG9yIHNldCB0aGUgbnVtZXJpY2FsIHdpZHRoIG9mIHRoZSBib3hwbG90IGJveC4gVGhlIHdpZHRoIG1heSBhbHNvIGJlIGEgZnVuY3Rpb24gdGFraW5nIGFzXHJcbiAgICAgKiBwYXJhbWV0ZXJzIHRoZSBjaGFydCB3aWR0aCBleGNsdWRpbmcgdGhlIHJpZ2h0IGFuZCBsZWZ0IG1hcmdpbnMsIGFzIHdlbGwgYXMgdGhlIG51bWJlciBvZiB4XHJcbiAgICAgKiB1bml0cy5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBVc2luZyBudW1lcmljYWwgcGFyYW1ldGVyXHJcbiAgICAgKiBjaGFydC5ib3hXaWR0aCgxMCk7XHJcbiAgICAgKiAvLyBVc2luZyBmdW5jdGlvblxyXG4gICAgICogY2hhcnQuYm94V2lkdGgoKGlubmVyQ2hhcnRXaWR0aCwgeFVuaXRzKSB7IC4uLiB9KTtcclxuICAgICAqIEBtZXRob2QgYm94V2lkdGhcclxuICAgICAqIEBtZW1iZXJvZiBkYy5ib3hQbG90XHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfEZ1bmN0aW9ufSBbYm94V2lkdGg9MC41XVxyXG4gICAgICogQHJldHVybnMge051bWJlcnxGdW5jdGlvbnxkYy5ib3hQbG90fVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQuYm94V2lkdGggPSBmdW5jdGlvbiAoYm94V2lkdGgpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9ib3hXaWR0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgX2JveFdpZHRoID0gdHlwZW9mIGJveFdpZHRoID09PSAnZnVuY3Rpb24nID8gYm94V2lkdGggOiBkYy51dGlscy5jb25zdGFudChib3hXaWR0aCk7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGJveFRyYW5zZm9ybSA9IGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgdmFyIHhPZmZzZXQgPSBfY2hhcnQueCgpKF9jaGFydC5rZXlBY2Nlc3NvcigpKGQsIGkpKTtcclxuICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgeE9mZnNldCArICcsIDApJztcclxuICAgIH07XHJcblxyXG4gICAgX2NoYXJ0Ll9wcmVwcm9jZXNzRGF0YSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoX2NoYXJ0LmVsYXN0aWNYKCkpIHtcclxuICAgICAgICAgICAgX2NoYXJ0LngoKS5kb21haW4oW10pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgX2NoYXJ0LnBsb3REYXRhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfY2FsY3VsYXRlZEJveFdpZHRoID0gX2JveFdpZHRoKF9jaGFydC5lZmZlY3RpdmVXaWR0aCgpLCBfY2hhcnQueFVuaXRDb3VudCgpKTtcclxuXHJcbiAgICAgICAgX2JveC53aGlza2Vycyhfd2hpc2tlcnMpXHJcbiAgICAgICAgICAgIC53aWR0aChfY2FsY3VsYXRlZEJveFdpZHRoKVxyXG4gICAgICAgICAgICAuaGVpZ2h0KF9jaGFydC5lZmZlY3RpdmVIZWlnaHQoKSlcclxuICAgICAgICAgICAgLnZhbHVlKF9jaGFydC52YWx1ZUFjY2Vzc29yKCkpXHJcbiAgICAgICAgICAgIC5kb21haW4oX2NoYXJ0LnkoKS5kb21haW4oKSlcclxuICAgICAgICAgICAgLmR1cmF0aW9uKF9jaGFydC50cmFuc2l0aW9uRHVyYXRpb24oKSlcclxuICAgICAgICAgICAgLnRpY2tGb3JtYXQoX3RpY2tGb3JtYXQpXHJcbiAgICAgICAgICAgIC5yZW5kZXJEYXRhUG9pbnRzKF9yZW5kZXJEYXRhUG9pbnRzKVxyXG4gICAgICAgICAgICAuZGF0YU9wYWNpdHkoX2RhdGFPcGFjaXR5KVxyXG4gICAgICAgICAgICAuZGF0YVdpZHRoUG9ydGlvbihfZGF0YVdpZHRoUG9ydGlvbilcclxuICAgICAgICAgICAgLnJlbmRlclRpdGxlKF9jaGFydC5yZW5kZXJUaXRsZSgpKVxyXG4gICAgICAgICAgICAuc2hvd091dGxpZXJzKF9zaG93T3V0bGllcnMpXHJcbiAgICAgICAgICAgIC5ib2xkT3V0bGllcihfYm9sZE91dGxpZXIpO1xyXG5cclxuICAgICAgICB2YXIgYm94ZXNHID0gX2NoYXJ0LmNoYXJ0Qm9keUcoKS5zZWxlY3RBbGwoJ2cuYm94JykuZGF0YShfY2hhcnQuZGF0YSgpLCBfY2hhcnQua2V5QWNjZXNzb3IoKSk7XHJcblxyXG4gICAgICAgIHZhciBib3hlc0dFbnRlclVwZGF0ZSA9IHJlbmRlckJveGVzKGJveGVzRyk7XHJcbiAgICAgICAgdXBkYXRlQm94ZXMoYm94ZXNHRW50ZXJVcGRhdGUpO1xyXG4gICAgICAgIHJlbW92ZUJveGVzKGJveGVzRyk7XHJcblxyXG4gICAgICAgIF9jaGFydC5mYWRlRGVzZWxlY3RlZEFyZWEoX2NoYXJ0LmZpbHRlcigpKTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gcmVuZGVyQm94ZXMgKGJveGVzRykge1xyXG4gICAgICAgIHZhciBib3hlc0dFbnRlciA9IGJveGVzRy5lbnRlcigpLmFwcGVuZCgnZycpO1xyXG5cclxuICAgICAgICBib3hlc0dFbnRlclxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnYm94JylcclxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGJveFRyYW5zZm9ybSlcclxuICAgICAgICAgICAgLmNhbGwoX2JveClcclxuICAgICAgICAgICAgLm9uKCdjbGljaycsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICBfY2hhcnQuZmlsdGVyKF9jaGFydC5rZXlBY2Nlc3NvcigpKGQpKTtcclxuICAgICAgICAgICAgICAgIF9jaGFydC5yZWRyYXdHcm91cCgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gYm94ZXNHRW50ZXIubWVyZ2UoYm94ZXNHKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB1cGRhdGVCb3hlcyAoYm94ZXNHKSB7XHJcbiAgICAgICAgZGMudHJhbnNpdGlvbihib3hlc0csIF9jaGFydC50cmFuc2l0aW9uRHVyYXRpb24oKSwgX2NoYXJ0LnRyYW5zaXRpb25EZWxheSgpKVxyXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgYm94VHJhbnNmb3JtKVxyXG4gICAgICAgICAgICAuY2FsbChfYm94KVxyXG4gICAgICAgICAgICAuZWFjaChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gX2NoYXJ0LmdldENvbG9yKGQsIDApO1xyXG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnNlbGVjdCgncmVjdC5ib3gnKS5hdHRyKCdmaWxsJywgY29sb3IpO1xyXG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnNlbGVjdEFsbCgnY2lyY2xlLmRhdGEnKS5hdHRyKCdmaWxsJywgY29sb3IpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZW1vdmVCb3hlcyAoYm94ZXNHKSB7XHJcbiAgICAgICAgYm94ZXNHLmV4aXQoKS5yZW1vdmUoKS5jYWxsKF9ib3gpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1pbkRhdGFWYWx1ZSAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGQzLm1pbihfY2hhcnQuZGF0YSgpLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZDMubWluKF9jaGFydC52YWx1ZUFjY2Vzc29yKCkoZSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1heERhdGFWYWx1ZSAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGQzLm1heChfY2hhcnQuZGF0YSgpLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZDMubWF4KF9jaGFydC52YWx1ZUFjY2Vzc29yKCkoZSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHlBeGlzUmFuZ2VSYXRpbyAoKSB7XHJcbiAgICAgICAgcmV0dXJuICgobWF4RGF0YVZhbHVlKCkgLSBtaW5EYXRhVmFsdWUoKSkgLyBfY2hhcnQuZWZmZWN0aXZlSGVpZ2h0KCkpO1xyXG4gICAgfVxyXG5cclxuICAgIF9jaGFydC5mYWRlRGVzZWxlY3RlZEFyZWEgPSBmdW5jdGlvbiAoYnJ1c2hTZWxlY3Rpb24pIHtcclxuICAgICAgICBpZiAoX2NoYXJ0Lmhhc0ZpbHRlcigpKSB7XHJcbiAgICAgICAgICAgIGlmIChfY2hhcnQuaXNPcmRpbmFsKCkpIHtcclxuICAgICAgICAgICAgICAgIF9jaGFydC5nKCkuc2VsZWN0QWxsKCdnLmJveCcpLmVhY2goZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX2NoYXJ0LmlzU2VsZWN0ZWROb2RlKGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jaGFydC5oaWdobGlnaHRTZWxlY3RlZCh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfY2hhcnQuZmFkZURlc2VsZWN0ZWQodGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIShfY2hhcnQuYnJ1c2hPbigpIHx8IF9jaGFydC5wYXJlbnRCcnVzaE9uKCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gYnJ1c2hTZWxlY3Rpb25bMF07XHJcbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gYnJ1c2hTZWxlY3Rpb25bMV07XHJcbiAgICAgICAgICAgICAgICB2YXIga2V5QWNjZXNzb3IgPSBfY2hhcnQua2V5QWNjZXNzb3IoKTtcclxuICAgICAgICAgICAgICAgIF9jaGFydC5nKCkuc2VsZWN0QWxsKCdnLmJveCcpLmVhY2goZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5QWNjZXNzb3IoZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA8IHN0YXJ0IHx8IGtleSA+PSBlbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2NoYXJ0LmZhZGVEZXNlbGVjdGVkKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jaGFydC5oaWdobGlnaHRTZWxlY3RlZCh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIF9jaGFydC5nKCkuc2VsZWN0QWxsKCdnLmJveCcpLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgX2NoYXJ0LnJlc2V0SGlnaGxpZ2h0KHRoaXMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9jaGFydC5pc1NlbGVjdGVkTm9kZSA9IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydC5oYXNGaWx0ZXIoX2NoYXJ0LmtleUFjY2Vzc29yKCkoZCkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfY2hhcnQueUF4aXNNaW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHBhZGRpbmcgPSBfeVJhbmdlUGFkZGluZyAqIHlBeGlzUmFuZ2VSYXRpbygpO1xyXG4gICAgICAgIHJldHVybiBkYy51dGlscy5zdWJ0cmFjdChtaW5EYXRhVmFsdWUoKSAtIHBhZGRpbmcsIF9jaGFydC55QXhpc1BhZGRpbmcoKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9jaGFydC55QXhpc01heCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcGFkZGluZyA9IF95UmFuZ2VQYWRkaW5nICogeUF4aXNSYW5nZVJhdGlvKCk7XHJcbiAgICAgICAgcmV0dXJuIGRjLnV0aWxzLmFkZChtYXhEYXRhVmFsdWUoKSArIHBhZGRpbmcsIF9jaGFydC55QXhpc1BhZGRpbmcoKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IG9yIHNldCB0aGUgbnVtZXJpY2FsIGZvcm1hdCBvZiB0aGUgYm94cGxvdCBtZWRpYW4sIHdoaXNrZXJzIGFuZCBxdWFydGlsZSBsYWJlbHMuIERlZmF1bHRzXHJcbiAgICAgKiB0byBpbnRlZ2VyIGZvcm1hdHRpbmcuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gZm9ybWF0IHRpY2tzIHRvIDIgZGVjaW1hbCBwbGFjZXNcclxuICAgICAqIGNoYXJ0LnRpY2tGb3JtYXQoZDMuZm9ybWF0KCcuMmYnKSk7XHJcbiAgICAgKiBAbWV0aG9kIHRpY2tGb3JtYXRcclxuICAgICAqIEBtZW1iZXJvZiBkYy5ib3hQbG90XHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFt0aWNrRm9ybWF0XVxyXG4gICAgICogQHJldHVybnMge051bWJlcnxGdW5jdGlvbnxkYy5ib3hQbG90fVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQudGlja0Zvcm1hdCA9IGZ1bmN0aW9uICh0aWNrRm9ybWF0KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGlja0Zvcm1hdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3RpY2tGb3JtYXQgPSB0aWNrRm9ybWF0O1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IG9yIHNldCB0aGUgYW1vdW50IG9mIHBhZGRpbmcgdG8gYWRkLCBpbiBwaXhlbCBjb29yZGluYXRlcywgdG8gdGhlIHRvcCBhbmRcclxuICAgICAqIGJvdHRvbSBvZiB0aGUgY2hhcnQgdG8gYWNjb21tb2RhdGUgYm94L3doaXNrZXIgbGFiZWxzLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGFsbG93IG1vcmUgc3BhY2UgZm9yIGEgYmlnZ2VyIHdoaXNrZXIgZm9udFxyXG4gICAgICogY2hhcnQueVJhbmdlUGFkZGluZygxMik7XHJcbiAgICAgKiBAbWV0aG9kIHlSYW5nZVBhZGRpbmdcclxuICAgICAqIEBtZW1iZXJvZiBkYy5ib3hQbG90XHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFt5UmFuZ2VQYWRkaW5nID0gOF1cclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ8RnVuY3Rpb258ZGMuYm94UGxvdH1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LnlSYW5nZVBhZGRpbmcgPSBmdW5jdGlvbiAoeVJhbmdlUGFkZGluZykge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3lSYW5nZVBhZGRpbmc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF95UmFuZ2VQYWRkaW5nID0geVJhbmdlUGFkZGluZztcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBvciBzZXQgd2hldGhlciBpbmRpdmlkdWFsIGRhdGEgcG9pbnRzIHdpbGwgYmUgcmVuZGVyZWQuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gRW5hYmxlIHJlbmRlcmluZyBvZiBpbmRpdmlkdWFsIGRhdGEgcG9pbnRzXHJcbiAgICAgKiBjaGFydC5yZW5kZXJEYXRhUG9pbnRzKHRydWUpO1xyXG4gICAgICogQG1ldGhvZCByZW5kZXJEYXRhUG9pbnRzXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuYm94UGxvdFxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaG93PWZhbHNlXVxyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW58ZGMuYm94UGxvdH1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LnJlbmRlckRhdGFQb2ludHMgPSBmdW5jdGlvbiAoc2hvdykge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3JlbmRlckRhdGFQb2ludHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9yZW5kZXJEYXRhUG9pbnRzID0gc2hvdztcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBvciBzZXQgdGhlIG9wYWNpdHkgd2hlbiByZW5kZXJpbmcgZGF0YS5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBJZiBpbmRpdmlkdWFsIGRhdGEgcG9pbnRzIGFyZSByZW5kZXJlZCBpbmNyZWFzZSB0aGUgb3BhY2l0eS5cclxuICAgICAqIGNoYXJ0LmRhdGFPcGFjaXR5KDAuNyk7XHJcbiAgICAgKiBAbWV0aG9kIGRhdGFPcGFjaXR5XHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuYm94UGxvdFxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wYWNpdHk9MC4zXVxyXG4gICAgICogQHJldHVybnMge051bWJlcnxkYy5ib3hQbG90fVxyXG4gICAgICovXHJcbiAgICBfY2hhcnQuZGF0YU9wYWNpdHkgPSBmdW5jdGlvbiAob3BhY2l0eSkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2RhdGFPcGFjaXR5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBfZGF0YU9wYWNpdHkgPSBvcGFjaXR5O1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IG9yIHNldCB0aGUgcG9ydGlvbiBvZiB0aGUgd2lkdGggb2YgdGhlIGJveCB0byBzaG93IGRhdGEgcG9pbnRzLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIElmIGluZGl2aWR1YWwgZGF0YSBwb2ludHMgYXJlIHJlbmRlcmVkIGluY3JlYXNlIHRoZSBkYXRhIGJveC5cclxuICAgICAqIGNoYXJ0LmRhdGFXaWR0aFBvcnRpb24oMC45KTtcclxuICAgICAqIEBtZXRob2QgZGF0YVdpZHRoUG9ydGlvblxyXG4gICAgICogQG1lbWJlcm9mIGRjLmJveFBsb3RcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwZXJjZW50YWdlPTAuOF1cclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ8ZGMuYm94UGxvdH1cclxuICAgICAqL1xyXG4gICAgX2NoYXJ0LmRhdGFXaWR0aFBvcnRpb24gPSBmdW5jdGlvbiAocGVyY2VudGFnZSkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2RhdGFXaWR0aFBvcnRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9kYXRhV2lkdGhQb3J0aW9uID0gcGVyY2VudGFnZTtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBvciBzZXQgd2hldGhlciBvdXRsaWVycyB3aWxsIGJlIHJlbmRlcmVkLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIERpc2FibGUgcmVuZGVyaW5nIG9mIG91dGxpZXJzXHJcbiAgICAgKiBjaGFydC5zaG93T3V0bGllcnMoZmFsc2UpO1xyXG4gICAgICogQG1ldGhvZCBzaG93T3V0bGllcnNcclxuICAgICAqIEBtZW1iZXJvZiBkYy5ib3hQbG90XHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3Nob3c9dHJ1ZV1cclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufGRjLmJveFBsb3R9XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5zaG93T3V0bGllcnMgPSBmdW5jdGlvbiAoc2hvdykge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3Nob3dPdXRsaWVycztcclxuICAgICAgICB9XHJcbiAgICAgICAgX3Nob3dPdXRsaWVycyA9IHNob3c7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgb3Igc2V0IHdoZXRoZXIgb3V0bGllcnMgd2lsbCBiZSBkcmF3biBib2xkLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIElmIG91dGxpZXJzIGFyZSByZW5kZXJlZCBkaXNwbGF5IGFzIGJvbGRcclxuICAgICAqIGNoYXJ0LmJvbGRPdXRsaWVyKHRydWUpO1xyXG4gICAgICogQG1ldGhvZCBib2xkT3V0bGllclxyXG4gICAgICogQG1lbWJlcm9mIGRjLmJveFBsb3RcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2hvdz1mYWxzZV1cclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufGRjLmJveFBsb3R9XHJcbiAgICAgKi9cclxuICAgIF9jaGFydC5ib2xkT3V0bGllciA9IGZ1bmN0aW9uIChzaG93KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfYm9sZE91dGxpZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9ib2xkT3V0bGllciA9IHNob3c7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIF9jaGFydC5hbmNob3IocGFyZW50LCBjaGFydEdyb3VwKTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogVGhlIHNlbGVjdCBtZW51IGlzIGEgc2ltcGxlIHdpZGdldCBkZXNpZ25lZCB0byBmaWx0ZXIgYSBkaW1lbnNpb24gYnkgc2VsZWN0aW5nIGFuIG9wdGlvbiBmcm9tXHJcbiAqIGFuIEhUTUwgYDxzZWxlY3QvPmAgbWVudS4gVGhlIG1lbnUgY2FuIGJlIG9wdGlvbmFsbHkgdHVybmVkIGludG8gYSBtdWx0aXNlbGVjdC5cclxuICogQGNsYXNzIHNlbGVjdE1lbnVcclxuICogQG1lbWJlcm9mIGRjXHJcbiAqIEBtaXhlcyBkYy5iYXNlTWl4aW5cclxuICogQGV4YW1wbGVcclxuICogLy8gY3JlYXRlIGEgc2VsZWN0IG1lbnUgdW5kZXIgI3NlbGVjdC1jb250YWluZXIgdXNpbmcgdGhlIGRlZmF1bHQgZ2xvYmFsIGNoYXJ0IGdyb3VwXHJcbiAqIHZhciBzZWxlY3QgPSBkYy5zZWxlY3RNZW51KCcjc2VsZWN0LWNvbnRhaW5lcicpXHJcbiAqICAgICAgICAgICAgICAgIC5kaW1lbnNpb24oc3RhdGVzKVxyXG4gKiAgICAgICAgICAgICAgICAuZ3JvdXAoc3RhdGVHcm91cCk7XHJcbiAqIC8vIHRoZSBvcHRpb24gdGV4dCBjYW4gYmUgc2V0IHZpYSB0aGUgdGl0bGUoKSBmdW5jdGlvblxyXG4gKiAvLyBieSBkZWZhdWx0IHRoZSBvcHRpb24gdGV4dCBpcyAnYGtleWA6IGB2YWx1ZWAnXHJcbiAqIHNlbGVjdC50aXRsZShmdW5jdGlvbiAoZCl7XHJcbiAqICAgICByZXR1cm4gJ1NUQVRFOiAnICsgZC5rZXk7XHJcbiAqIH0pXHJcbiAqIEBwYXJhbSB7U3RyaW5nfG5vZGV8ZDMuc2VsZWN0aW9ufGRjLmNvbXBvc2l0ZUNoYXJ0fSBwYXJlbnQgLSBBbnkgdmFsaWRcclxuICogW2QzIHNpbmdsZSBzZWxlY3Rvcl0oaHR0cHM6Ly9naXRodWIuY29tL21ib3N0b2NrL2QzL3dpa2kvU2VsZWN0aW9ucyNzZWxlY3RpbmctZWxlbWVudHMpIHNwZWNpZnlpbmdcclxuICogYSBkb20gYmxvY2sgZWxlbWVudCBzdWNoIGFzIGEgZGl2OyBvciBhIGRvbSBlbGVtZW50IG9yIGQzIHNlbGVjdGlvbi5cclxuICogQHBhcmFtIHtTdHJpbmd9IFtjaGFydEdyb3VwXSAtIFRoZSBuYW1lIG9mIHRoZSBjaGFydCBncm91cCB0aGlzIHdpZGdldCBzaG91bGQgYmUgcGxhY2VkIGluLlxyXG4gKiBJbnRlcmFjdGlvbiB3aXRoIHRoZSB3aWRnZXQgd2lsbCBvbmx5IHRyaWdnZXIgZXZlbnRzIGFuZCByZWRyYXdzIHdpdGhpbiBpdHMgZ3JvdXAuXHJcbiAqIEByZXR1cm5zIHtzZWxlY3RNZW51fVxyXG4gKiovXHJcbmRjLnNlbGVjdE1lbnUgPSBmdW5jdGlvbiAocGFyZW50LCBjaGFydEdyb3VwKSB7XHJcbiAgICB2YXIgU0VMRUNUX0NTU19DTEFTUyA9ICdkYy1zZWxlY3QtbWVudSc7XHJcbiAgICB2YXIgT1BUSU9OX0NTU19DTEFTUyA9ICdkYy1zZWxlY3Qtb3B0aW9uJztcclxuXHJcbiAgICB2YXIgX2NoYXJ0ID0gZGMuYmFzZU1peGluKHt9KTtcclxuXHJcbiAgICB2YXIgX3NlbGVjdDtcclxuICAgIHZhciBfcHJvbXB0VGV4dCA9ICdTZWxlY3QgYWxsJztcclxuICAgIHZhciBfbXVsdGlwbGUgPSBmYWxzZTtcclxuICAgIHZhciBfcHJvbXB0VmFsdWUgPSBudWxsO1xyXG4gICAgdmFyIF9udW1iZXJWaXNpYmxlID0gbnVsbDtcclxuICAgIHZhciBfb3JkZXIgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQua2V5QWNjZXNzb3IoKShhKSA+IF9jaGFydC5rZXlBY2Nlc3NvcigpKGIpID9cclxuICAgICAgICAgICAgIDEgOiBfY2hhcnQua2V5QWNjZXNzb3IoKShiKSA+IF9jaGFydC5rZXlBY2Nlc3NvcigpKGEpID9cclxuICAgICAgICAgICAgLTEgOiAwO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgX2ZpbHRlckRpc3BsYXllZCA9IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydC52YWx1ZUFjY2Vzc29yKCkoZCkgPiAwO1xyXG4gICAgfTtcclxuXHJcbiAgICBfY2hhcnQuZGF0YShmdW5jdGlvbiAoZ3JvdXApIHtcclxuICAgICAgICByZXR1cm4gZ3JvdXAuYWxsKCkuZmlsdGVyKF9maWx0ZXJEaXNwbGF5ZWQpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgX2NoYXJ0Ll9kb1JlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfY2hhcnQuc2VsZWN0KCdzZWxlY3QnKS5yZW1vdmUoKTtcclxuICAgICAgICBfc2VsZWN0ID0gX2NoYXJ0LnJvb3QoKS5hcHBlbmQoJ3NlbGVjdCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jbGFzc2VkKFNFTEVDVF9DU1NfQ0xBU1MsIHRydWUpO1xyXG4gICAgICAgIF9zZWxlY3QuYXBwZW5kKCdvcHRpb24nKS50ZXh0KF9wcm9tcHRUZXh0KS5hdHRyKCd2YWx1ZScsICcnKTtcclxuXHJcbiAgICAgICAgX2NoYXJ0Ll9kb1JlZHJhdygpO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG4gICAgLy8gRml4aW5nIElFIDExIGNyYXNoIHdoZW4gcmVkcmF3aW5nIHRoZSBjaGFydFxyXG4gICAgLy8gc2VlIGhlcmUgZm9yIGxpc3Qgb2YgSUUgdXNlciBBZ2VudHMgOlxyXG4gICAgLy8gaHR0cDovL3d3dy51c2VyYWdlbnRzdHJpbmcuY29tL3BhZ2VzL3VzZXJhZ2VudHN0cmluZy5waHA/bmFtZT1JbnRlcm5ldCtFeHBsb3JlclxyXG4gICAgdmFyIHVhID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7XHJcbiAgICAvLyB0ZXN0IGZvciBJRSAxMSBidXQgbm90IGEgbG93ZXIgdmVyc2lvbiAod2hpY2ggY29udGFpbnMgTVNJRSBpbiBVQSlcclxuICAgIGlmICh1YS5pbmRleE9mKCdUcmlkZW50LycpID4gMCAmJiB1YS5pbmRleE9mKCdNU0lFJykgPT09IC0xKSB7XHJcbiAgICAgICAgX2NoYXJ0LnJlZHJhdyA9IF9jaGFydC5yZW5kZXI7XHJcbiAgICB9XHJcblxyXG4gICAgX2NoYXJ0Ll9kb1JlZHJhdyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZXRBdHRyaWJ1dGVzKCk7XHJcbiAgICAgICAgcmVuZGVyT3B0aW9ucygpO1xyXG4gICAgICAgIC8vIHNlbGVjdCB0aGUgb3B0aW9uKHMpIGNvcnJlc3BvbmRpbmcgdG8gY3VycmVudCBmaWx0ZXIocylcclxuICAgICAgICBpZiAoX2NoYXJ0Lmhhc0ZpbHRlcigpICYmIF9tdWx0aXBsZSkge1xyXG4gICAgICAgICAgICBfc2VsZWN0LnNlbGVjdEFsbCgnb3B0aW9uJylcclxuICAgICAgICAgICAgICAgIC5wcm9wZXJ0eSgnc2VsZWN0ZWQnLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgZCAhPT0gJ3VuZGVmaW5lZCcgJiYgX2NoYXJ0LmZpbHRlcnMoKS5pbmRleE9mKFN0cmluZyhfY2hhcnQua2V5QWNjZXNzb3IoKShkKSkpID49IDA7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2UgaWYgKF9jaGFydC5oYXNGaWx0ZXIoKSkge1xyXG4gICAgICAgICAgICBfc2VsZWN0LnByb3BlcnR5KCd2YWx1ZScsIF9jaGFydC5maWx0ZXIoKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgX3NlbGVjdC5wcm9wZXJ0eSgndmFsdWUnLCAnJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIHJlbmRlck9wdGlvbnMgKCkge1xyXG4gICAgICAgIHZhciBvcHRpb25zID0gX3NlbGVjdC5zZWxlY3RBbGwoJ29wdGlvbi4nICsgT1BUSU9OX0NTU19DTEFTUylcclxuICAgICAgICAgIC5kYXRhKF9jaGFydC5kYXRhKCksIGZ1bmN0aW9uIChkKSB7IHJldHVybiBfY2hhcnQua2V5QWNjZXNzb3IoKShkKTsgfSk7XHJcblxyXG4gICAgICAgIG9wdGlvbnMuZXhpdCgpLnJlbW92ZSgpO1xyXG5cclxuICAgICAgICBvcHRpb25zLmVudGVyKClcclxuICAgICAgICAgICAgICAuYXBwZW5kKCdvcHRpb24nKVxyXG4gICAgICAgICAgICAgIC5jbGFzc2VkKE9QVElPTl9DU1NfQ0xBU1MsIHRydWUpXHJcbiAgICAgICAgICAgICAgLmF0dHIoJ3ZhbHVlJywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIF9jaGFydC5rZXlBY2Nlc3NvcigpKGQpOyB9KVxyXG4gICAgICAgICAgICAubWVyZ2Uob3B0aW9ucylcclxuICAgICAgICAgICAgICAudGV4dChfY2hhcnQudGl0bGUoKSk7XHJcblxyXG4gICAgICAgIF9zZWxlY3Quc2VsZWN0QWxsKCdvcHRpb24uJyArIE9QVElPTl9DU1NfQ0xBU1MpLnNvcnQoX29yZGVyKTtcclxuXHJcbiAgICAgICAgX3NlbGVjdC5vbignY2hhbmdlJywgb25DaGFuZ2UpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG9uQ2hhbmdlIChkLCBpKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlcztcclxuICAgICAgICB2YXIgdGFyZ2V0ID0gZDMuZXZlbnQudGFyZ2V0O1xyXG4gICAgICAgIGlmICh0YXJnZXQuc2VsZWN0ZWRPcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZE9wdGlvbnMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0YXJnZXQuc2VsZWN0ZWRPcHRpb25zKTtcclxuICAgICAgICAgICAgdmFsdWVzID0gc2VsZWN0ZWRPcHRpb25zLm1hcChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQudmFsdWU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7IC8vIElFIGFuZCBvdGhlciBicm93c2VycyBkbyBub3Qgc3VwcG9ydCBzZWxlY3RlZE9wdGlvbnNcclxuICAgICAgICAgICAgLy8gYWRhcHRlZCBmcm9tIHRoaXMgcG9seWZpbGw6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2JyZXR0ejkvNDIxMjIxN1xyXG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IFtdLnNsaWNlLmNhbGwoZDMuZXZlbnQudGFyZ2V0Lm9wdGlvbnMpO1xyXG4gICAgICAgICAgICB2YWx1ZXMgPSBvcHRpb25zLmZpbHRlcihmdW5jdGlvbiAob3B0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9uLnNlbGVjdGVkO1xyXG4gICAgICAgICAgICB9KS5tYXAoZnVuY3Rpb24gKG9wdGlvbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbi52YWx1ZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHZhbHVlcyk7XHJcbiAgICAgICAgLy8gY2hlY2sgaWYgb25seSBwcm9tcHQgb3B0aW9uIGlzIHNlbGVjdGVkXHJcbiAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDEgJiYgdmFsdWVzWzBdID09PSAnJykge1xyXG4gICAgICAgICAgICB2YWx1ZXMgPSBfcHJvbXB0VmFsdWUgfHwgbnVsbDtcclxuICAgICAgICB9IGVsc2UgaWYgKCFfbXVsdGlwbGUgJiYgdmFsdWVzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXNbMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9jaGFydC5vbkNoYW5nZSh2YWx1ZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIF9jaGFydC5vbkNoYW5nZSA9IGZ1bmN0aW9uICh2YWwpIHtcclxuICAgICAgICBpZiAodmFsICYmIF9tdWx0aXBsZSkge1xyXG4gICAgICAgICAgICBfY2hhcnQucmVwbGFjZUZpbHRlcihbdmFsXSk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh2YWwpIHtcclxuICAgICAgICAgICAgX2NoYXJ0LnJlcGxhY2VGaWx0ZXIodmFsKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBfY2hhcnQuZmlsdGVyQWxsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRjLmV2ZW50cy50cmlnZ2VyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX2NoYXJ0LnJlZHJhd0dyb3VwKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIHNldEF0dHJpYnV0ZXMgKCkge1xyXG4gICAgICAgIGlmIChfbXVsdGlwbGUpIHtcclxuICAgICAgICAgICAgX3NlbGVjdC5hdHRyKCdtdWx0aXBsZScsIHRydWUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIF9zZWxlY3QuYXR0cignbXVsdGlwbGUnLCBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKF9udW1iZXJWaXNpYmxlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIF9zZWxlY3QuYXR0cignc2l6ZScsIF9udW1iZXJWaXNpYmxlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBfc2VsZWN0LmF0dHIoJ3NpemUnLCBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgb3Igc2V0IHRoZSBmdW5jdGlvbiB0aGF0IGNvbnRyb2xzIHRoZSBvcmRlcmluZyBvZiBvcHRpb24gdGFncyBpbiB0aGVcclxuICAgICAqIHNlbGVjdCBtZW51LiBCeSBkZWZhdWx0IG9wdGlvbnMgYXJlIG9yZGVyZWQgYnkgdGhlIGdyb3VwIGtleSBpbiBhc2NlbmRpbmdcclxuICAgICAqIG9yZGVyLlxyXG4gICAgICogQG5hbWUgb3JkZXJcclxuICAgICAqIEBtZW1iZXJvZiBkYy5zZWxlY3RNZW51XHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcmRlcl1cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBvcmRlciBieSB0aGUgZ3JvdXAncyB2YWx1ZVxyXG4gICAgICogY2hhcnQub3JkZXIoZnVuY3Rpb24gKGEsYikge1xyXG4gICAgICogICAgIHJldHVybiBhLnZhbHVlID4gYi52YWx1ZSA/IDEgOiBiLnZhbHVlID4gYS52YWx1ZSA/IC0xIDogMDtcclxuICAgICAqIH0pO1xyXG4gICAgICoqL1xyXG4gICAgX2NoYXJ0Lm9yZGVyID0gZnVuY3Rpb24gKG9yZGVyKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfb3JkZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9vcmRlciA9IG9yZGVyO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IG9yIHNldCB0aGUgdGV4dCBkaXNwbGF5ZWQgaW4gdGhlIG9wdGlvbnMgdXNlZCB0byBwcm9tcHQgc2VsZWN0aW9uLlxyXG4gICAgICogQG5hbWUgcHJvbXB0VGV4dFxyXG4gICAgICogQG1lbWJlcm9mIGRjLnNlbGVjdE1lbnVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtwcm9tcHRUZXh0PSdTZWxlY3QgYWxsJ11cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBjaGFydC5wcm9tcHRUZXh0KCdBbGwgc3RhdGVzJyk7XHJcbiAgICAgKiovXHJcbiAgICBfY2hhcnQucHJvbXB0VGV4dCA9IGZ1bmN0aW9uIChfKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfcHJvbXB0VGV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3Byb21wdFRleHQgPSBfO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IG9yIHNldCB0aGUgZnVuY3Rpb24gdGhhdCBmaWx0ZXJzIG9wdGlvbiB0YWdzIHByaW9yIHRvIGRpc3BsYXkuIEJ5IGRlZmF1bHQgb3B0aW9uc1xyXG4gICAgICogd2l0aCBhIHZhbHVlIG9mIDwgMSBhcmUgbm90IGRpc3BsYXllZC5cclxuICAgICAqIEBuYW1lIGZpbHRlckRpc3BsYXllZFxyXG4gICAgICogQG1lbWJlcm9mIGRjLnNlbGVjdE1lbnVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2ZpbHRlckRpc3BsYXllZF1cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBkaXNwbGF5IGFsbCBvcHRpb25zIG92ZXJyaWRlIHRoZSBgZmlsdGVyRGlzcGxheWVkYCBmdW5jdGlvbjpcclxuICAgICAqIGNoYXJ0LmZpbHRlckRpc3BsYXllZChmdW5jdGlvbiAoKSB7XHJcbiAgICAgKiAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgKiB9KTtcclxuICAgICAqKi9cclxuICAgIF9jaGFydC5maWx0ZXJEaXNwbGF5ZWQgPSBmdW5jdGlvbiAoZmlsdGVyRGlzcGxheWVkKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfZmlsdGVyRGlzcGxheWVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfZmlsdGVyRGlzcGxheWVkID0gZmlsdGVyRGlzcGxheWVkO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udHJvbHMgdGhlIHR5cGUgb2Ygc2VsZWN0IG1lbnUuIFNldHRpbmcgaXQgdG8gdHJ1ZSBjb252ZXJ0cyB0aGUgdW5kZXJseWluZ1xyXG4gICAgICogSFRNTCB0YWcgaW50byBhIG11bHRpcGxlIHNlbGVjdC5cclxuICAgICAqIEBuYW1lIG11bHRpcGxlXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuc2VsZWN0TWVudVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFttdWx0aXBsZT1mYWxzZV1cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBjaGFydC5tdWx0aXBsZSh0cnVlKTtcclxuICAgICAqKi9cclxuICAgIF9jaGFydC5tdWx0aXBsZSA9IGZ1bmN0aW9uIChtdWx0aXBsZSkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX211bHRpcGxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfbXVsdGlwbGUgPSBtdWx0aXBsZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb250cm9scyB0aGUgZGVmYXVsdCB2YWx1ZSB0byBiZSB1c2VkIGZvclxyXG4gICAgICogW2RpbWVuc2lvbi5maWx0ZXJdKGh0dHBzOi8vZ2l0aHViLmNvbS9jcm9zc2ZpbHRlci9jcm9zc2ZpbHRlci93aWtpL0FQSS1SZWZlcmVuY2UjZGltZW5zaW9uX2ZpbHRlcilcclxuICAgICAqIHdoZW4gb25seSB0aGUgcHJvbXB0IHZhbHVlIGlzIHNlbGVjdGVkLiBJZiBgbnVsbGAgKHRoZSBkZWZhdWx0KSwgbm8gZmlsdGVyaW5nIHdpbGwgb2NjdXIgd2hlblxyXG4gICAgICoganVzdCB0aGUgcHJvbXB0IGlzIHNlbGVjdGVkLlxyXG4gICAgICogQG5hbWUgcHJvbXB0VmFsdWVcclxuICAgICAqIEBtZW1iZXJvZiBkYy5zZWxlY3RNZW51XHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7Pyp9IFtwcm9tcHRWYWx1ZT1udWxsXVxyXG4gICAgICoqL1xyXG4gICAgX2NoYXJ0LnByb21wdFZhbHVlID0gZnVuY3Rpb24gKHByb21wdFZhbHVlKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfcHJvbXB0VmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9wcm9tcHRWYWx1ZSA9IHByb21wdFZhbHVlO1xyXG5cclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnRyb2xzIHRoZSBudW1iZXIgb2YgaXRlbXMgdG8gc2hvdyBpbiB0aGUgc2VsZWN0IG1lbnUsIHdoZW4gYC5tdWx0aXBsZSgpYCBpcyB0cnVlLiBUaGlzXHJcbiAgICAgKiBjb250cm9scyB0aGUgW2BzaXplYCBhdHRyaWJ1dGVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9zZWxlY3QjQXR0cmlidXRlcykgb2ZcclxuICAgICAqIHRoZSBgc2VsZWN0YCBlbGVtZW50LiBJZiBgbnVsbGAgKHRoZSBkZWZhdWx0KSwgdXNlcyB0aGUgYnJvd3NlcidzIGRlZmF1bHQgaGVpZ2h0LlxyXG4gICAgICogQG5hbWUgbnVtYmVySXRlbXNcclxuICAgICAqIEBtZW1iZXJvZiBkYy5zZWxlY3RNZW51XHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7P251bWJlcn0gW251bWJlclZpc2libGU9bnVsbF1cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBjaGFydC5udW1iZXJWaXNpYmxlKDEwKTtcclxuICAgICAqKi9cclxuICAgIF9jaGFydC5udW1iZXJWaXNpYmxlID0gZnVuY3Rpb24gKG51bWJlclZpc2libGUpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9udW1iZXJWaXNpYmxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfbnVtYmVyVmlzaWJsZSA9IG51bWJlclZpc2libGU7XHJcblxyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF9jaGFydC5zaXplID0gZGMubG9nZ2VyLmRlcHJlY2F0ZShfY2hhcnQubnVtYmVyVmlzaWJsZSwgJ3NlbGVjdE1lbnUuc2l6ZSBpcyBhbWJpZ3VvdXMgLSB1c2UgbnVtYmVyVmlzaWJsZSBpbnN0ZWFkJyk7XHJcblxyXG4gICAgcmV0dXJuIF9jaGFydC5hbmNob3IocGFyZW50LCBjaGFydEdyb3VwKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXh0IEZpbHRlciBXaWRnZXRcclxuICpcclxuICogVGhlIHRleHQgZmlsdGVyIHdpZGdldCBpcyBhIHNpbXBsZSB3aWRnZXQgZGVzaWduZWQgdG8gZGlzcGxheSBhbiBpbnB1dCBmaWVsZCBhbGxvd2luZyB0byBmaWx0ZXJcclxuICogZGF0YSB0aGF0IG1hdGNoZXMgdGhlIHRleHQgdHlwZWQuXHJcbiAqIEFzIG9wcG9zZWQgdG8gdGhlIG90aGVyIGNoYXJ0cywgdGhpcyBkb2Vzbid0IGRpc3BsYXkgYW55IHJlc3VsdCBhbmQgZG9lc24ndCB1cGRhdGUgaXRzIGRpc3BsYXksXHJcbiAqIGl0J3MganVzdCB0byBpbnB1dCBhbiBmaWx0ZXIgb3RoZXIgY2hhcnRzLlxyXG4gKlxyXG4gKiBAY2xhc3MgdGV4dEZpbHRlcldpZGdldFxyXG4gKiBAbWVtYmVyb2YgZGNcclxuICogQG1peGVzIGRjLmJhc2VNaXhpblxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiB2YXIgZGF0YSA9IFt7XCJmaXJzdE5hbWVcIjpcIkpvaG5cIixcImxhc3ROYW1lXCI6XCJDb2x0cmFuZVwifXtcImZpcnN0TmFtZVwiOlwiTWlsZXNcIixsYXN0TmFtZTpcIkRhdmlzXCJ9XVxyXG4gKiB2YXIgbmR4ID0gY3Jvc3NmaWx0ZXIoZGF0YSk7XHJcbiAqIHZhciBkaW1lbnNpb24gPSBuZHguZGltZW5zaW9uKGZ1bmN0aW9uKGQpIHtcclxuICogICAgIHJldHVybiBkLmxhc3ROYW1lLnRvTG93ZXJDYXNlKCkgKyAnICcgKyBkLmZpcnN0TmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gKiB9KTtcclxuICpcclxuICogZGMudGV4dEZpbHRlcldpZGdldCgnI3NlYXJjaCcpXHJcbiAqICAgICAuZGltZW5zaW9uKGRpbWVuc2lvbik7XHJcbiAqICAgICAvLyB5b3UgZG9uJ3QgbmVlZCB0aGUgZ3JvdXAoKSBmdW5jdGlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ3xub2RlfGQzLnNlbGVjdGlvbnxkYy5jb21wb3NpdGVDaGFydH0gcGFyZW50IC0gQW55IHZhbGlkXHJcbiAqIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2VsZWN0aW9uL2Jsb2IvbWFzdGVyL1JFQURNRS5tZCNzZWxlY3QgZDMgc2luZ2xlIHNlbGVjdG9yfVxyXG4gKiBzcGVjaWZ5aW5nIGEgZG9tIGJsb2NrIGVsZW1lbnQgc3VjaCBhcyBhIGRpdjsgb3IgYSBkb20gZWxlbWVudCBvciBkMyBzZWxlY3Rpb24uXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbY2hhcnRHcm91cF0gLSBUaGUgbmFtZSBvZiB0aGUgY2hhcnQgZ3JvdXAgdGhpcyBjaGFydCBpbnN0YW5jZSBzaG91bGQgYmUgcGxhY2VkIGluLlxyXG4gKiBJbnRlcmFjdGlvbiB3aXRoIGEgY2hhcnQgd2lsbCBvbmx5IHRyaWdnZXIgZXZlbnRzIGFuZCByZWRyYXdzIHdpdGhpbiB0aGUgY2hhcnQncyBncm91cC5cclxuICogQHJldHVybnMge2RjLnRleHRGaWx0ZXJXaWRnZXR9XHJcbiAqKi9cclxuXHJcbmRjLnRleHRGaWx0ZXJXaWRnZXQgPSBmdW5jdGlvbiAocGFyZW50LCBjaGFydEdyb3VwKSB7XHJcbiAgICB2YXIgSU5QVVRfQ1NTX0NMQVNTID0gJ2RjLXRleHQtZmlsdGVyLWlucHV0JztcclxuXHJcbiAgICB2YXIgX2NoYXJ0ID0gZGMuYmFzZU1peGluKHt9KTtcclxuXHJcbiAgICB2YXIgX25vcm1hbGl6ZSA9IGZ1bmN0aW9uIChzKSB7XHJcbiAgICAgICAgcmV0dXJuIHMudG9Mb3dlckNhc2UoKTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIF9maWx0ZXJGdW5jdGlvbkZhY3RvcnkgPSBmdW5jdGlvbiAocXVlcnkpIHtcclxuICAgICAgICBxdWVyeSA9IF9ub3JtYWxpemUocXVlcnkpO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX25vcm1hbGl6ZShkKS5pbmRleE9mKHF1ZXJ5KSAhPT0gLTE7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIF9wbGFjZUhvbGRlciA9ICdzZWFyY2gnO1xyXG5cclxuICAgIF9jaGFydC5ncm91cChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhyb3cgJ3RoZSBncm91cCBmdW5jdGlvbiBvbiB0ZXh0RmlsdGVyV2lkZ2V0IHNob3VsZCBuZXZlciBiZSBjYWxsZWQsIHBsZWFzZSByZXBvcnQgdGhlIGlzc3VlJztcclxuICAgIH0pO1xyXG5cclxuICAgIF9jaGFydC5fZG9SZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX2NoYXJ0LnNlbGVjdCgnaW5wdXQnKS5yZW1vdmUoKTtcclxuXHJcbiAgICAgICAgdmFyIF9pbnB1dCA9IF9jaGFydC5yb290KCkuYXBwZW5kKCdpbnB1dCcpXHJcbiAgICAgICAgICAgIC5jbGFzc2VkKElOUFVUX0NTU19DTEFTUywgdHJ1ZSk7XHJcblxyXG4gICAgICAgIF9pbnB1dC5vbignaW5wdXQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF9jaGFydC5kaW1lbnNpb24oKS5maWx0ZXJGdW5jdGlvbihfZmlsdGVyRnVuY3Rpb25GYWN0b3J5KHRoaXMudmFsdWUpKTtcclxuICAgICAgICAgICAgZGMuZXZlbnRzLnRyaWdnZXIoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgZGMucmVkcmF3QWxsKCk7XHJcbiAgICAgICAgICAgIH0sIGRjLmNvbnN0YW50cy5FVkVOVF9ERUxBWSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIF9jaGFydC5fZG9SZWRyYXcoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgX2NoYXJ0Ll9kb1JlZHJhdyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfY2hhcnQucm9vdCgpLnNlbGVjdEFsbCgnaW5wdXQnKVxyXG4gICAgICAgICAgICAuYXR0cigncGxhY2Vob2xkZXInLCBfcGxhY2VIb2xkZXIpO1xyXG5cclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgb24gdmFsdWVzIGJlZm9yZSBjYWxsaW5nIHRoZSBmaWx0ZXIgZnVuY3Rpb24uXHJcbiAgICAgKiBAbmFtZSBub3JtYWxpemVcclxuICAgICAqIEBtZW1iZXJvZiBkYy50ZXh0RmlsdGVyV2lkZ2V0XHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBUaGlzIGlzIHRoZSBkZWZhdWx0XHJcbiAgICAgKiBjaGFydC5ub3JtYWxpemUoZnVuY3Rpb24gKHMpIHtcclxuICAgICAqICAgcmV0dXJuIHMudG9Mb3dlckNhc2UoKTtcclxuICAgICAqIH0pO1xyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW25vcm1hbGl6ZV1cclxuICAgICAqIEByZXR1cm5zIHtkYy50ZXh0RmlsdGVyV2lkZ2V0fGZ1bmN0aW9ufVxyXG4gICAgICoqL1xyXG4gICAgX2NoYXJ0Lm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChub3JtYWxpemUpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9ub3JtYWxpemU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9ub3JtYWxpemUgPSBub3JtYWxpemU7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQbGFjZWhvbGRlciB0ZXh0IGluIHRoZSBzZWFyY2ggYm94LlxyXG4gICAgICogQG5hbWUgcGxhY2VIb2xkZXJcclxuICAgICAqIEBtZW1iZXJvZiBkYy50ZXh0RmlsdGVyV2lkZ2V0XHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBUaGlzIGlzIHRoZSBkZWZhdWx0XHJcbiAgICAgKiBjaGFydC5wbGFjZUhvbGRlcigndHlwZSB0byBmaWx0ZXInKTtcclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtwbGFjZUhvbGRlcj0nc2VhcmNoJ11cclxuICAgICAqIEByZXR1cm5zIHtkYy50ZXh0RmlsdGVyV2lkZ2V0fHN0cmluZ31cclxuICAgICAqKi9cclxuICAgIF9jaGFydC5wbGFjZUhvbGRlciA9IGZ1bmN0aW9uIChwbGFjZUhvbGRlcikge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3BsYWNlSG9sZGVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfcGxhY2VIb2xkZXIgPSBwbGFjZUhvbGRlcjtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgc2VhcmNoIHRleHQsIGl0IG5lZWRzIHRvIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSB1c2VkIHRvXHJcbiAgICAgKiBmaWx0ZXIgdGhlIGRhdGEuIFRoZSBkZWZhdWx0IGZ1bmN0aW9uIGNoZWNrcyBwcmVzZW5jZSBvZiB0aGUgc2VhcmNoIHRleHQuXHJcbiAgICAgKiBAbmFtZSBmaWx0ZXJGdW5jdGlvbkZhY3RvcnlcclxuICAgICAqIEBtZW1iZXJvZiBkYy50ZXh0RmlsdGVyV2lkZ2V0XHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBUaGlzIGlzIHRoZSBkZWZhdWx0XHJcbiAgICAgKiBmdW5jdGlvbiAocXVlcnkpIHtcclxuICAgICAqICAgICBxdWVyeSA9IF9ub3JtYWxpemUocXVlcnkpO1xyXG4gICAgICogICAgIHJldHVybiBmdW5jdGlvbiAoZCkge1xyXG4gICAgICogICAgICAgICByZXR1cm4gX25vcm1hbGl6ZShkKS5pbmRleE9mKHF1ZXJ5KSAhPT0gLTE7XHJcbiAgICAgKiAgICAgfTtcclxuICAgICAqIH07XHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbZmlsdGVyRnVuY3Rpb25GYWN0b3J5XVxyXG4gICAgICogQHJldHVybnMge2RjLnRleHRGaWx0ZXJXaWRnZXR8ZnVuY3Rpb259XHJcbiAgICAgKiovXHJcbiAgICBfY2hhcnQuZmlsdGVyRnVuY3Rpb25GYWN0b3J5ID0gZnVuY3Rpb24gKGZpbHRlckZ1bmN0aW9uRmFjdG9yeSkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2ZpbHRlckZ1bmN0aW9uRmFjdG9yeTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX2ZpbHRlckZ1bmN0aW9uRmFjdG9yeSA9IGZpbHRlckZ1bmN0aW9uRmFjdG9yeTtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gX2NoYXJ0LmFuY2hvcihwYXJlbnQsIGNoYXJ0R3JvdXApO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRoZSBjYm94TWVudSBpcyBhIHNpbXBsZSB3aWRnZXQgZGVzaWduZWQgdG8gZmlsdGVyIGEgZGltZW5zaW9uIGJ5XHJcbiAqIHNlbGVjdGluZyBvcHRpb24ocykgZnJvbSBhIHNldCBvZiBIVE1MIGA8aW5wdXQgLz5gIGVsZW1lbnRzLiBUaGUgbWVudSBjYW4gYmVcclxuICogbWFkZSBpbnRvIGEgc2V0IG9mIHJhZGlvIGJ1dHRvbnMgKHNpbmdsZSBzZWxlY3QpIG9yIGNoZWNrYm94ZXMgKG11bHRpcGxlKS5cclxuICogQGNsYXNzIGNib3hNZW51XHJcbiAqIEBtZW1iZXJvZiBkY1xyXG4gKiBAbWl4ZXMgZGMuYmFzZU1peGluXHJcbiAqIEBleGFtcGxlXHJcbiAqIC8vIGNyZWF0ZSBhIGNib3hNZW51IHVuZGVyICNjYm94LWNvbnRhaW5lciB1c2luZyB0aGUgZGVmYXVsdCBnbG9iYWwgY2hhcnQgZ3JvdXBcclxuICogdmFyIGNib3ggPSBkYy5jYm94TWVudSgnI2Nib3gtY29udGFpbmVyJylcclxuICogICAgICAgICAgICAgICAgLmRpbWVuc2lvbihzdGF0ZXMpXHJcbiAqICAgICAgICAgICAgICAgIC5ncm91cChzdGF0ZUdyb3VwKTtcclxuICogLy8gdGhlIG9wdGlvbiB0ZXh0IGNhbiBiZSBzZXQgdmlhIHRoZSB0aXRsZSgpIGZ1bmN0aW9uXHJcbiAqIC8vIGJ5IGRlZmF1bHQgdGhlIG9wdGlvbiB0ZXh0IGlzICdga2V5YDogYHZhbHVlYCdcclxuICogY2JveC50aXRsZShmdW5jdGlvbiAoZCl7XHJcbiAqICAgICByZXR1cm4gJ1NUQVRFOiAnICsgZC5rZXk7XHJcbiAqIH0pXHJcbiAqIEBwYXJhbSB7U3RyaW5nfG5vZGV8ZDMuc2VsZWN0aW9ufGRjLmNvbXBvc2l0ZUNoYXJ0fSBwYXJlbnQgLSBBbnkgdmFsaWRcclxuICogW2QzIHNpbmdsZSBzZWxlY3Rvcl0oaHR0cHM6Ly9naXRodWIuY29tL21ib3N0b2NrL2QzL3dpa2kvU2VsZWN0aW9ucyNzZWxlY3RpbmctZWxlbWVudHMpIHNwZWNpZnlpbmdcclxuICogYSBkb20gYmxvY2sgZWxlbWVudCBzdWNoIGFzIGEgZGl2OyBvciBhIGRvbSBlbGVtZW50IG9yIGQzIHNlbGVjdGlvbi5cclxuICogQHBhcmFtIHtTdHJpbmd9IFtjaGFydEdyb3VwXSAtIFRoZSBuYW1lIG9mIHRoZSBjaGFydCBncm91cCB0aGlzIHdpZGdldCBzaG91bGQgYmUgcGxhY2VkIGluLlxyXG4gKiBJbnRlcmFjdGlvbiB3aXRoIHRoZSB3aWRnZXQgd2lsbCBvbmx5IHRyaWdnZXIgZXZlbnRzIGFuZCByZWRyYXdzIHdpdGhpbiBpdHMgZ3JvdXAuXHJcbiAqIEByZXR1cm5zIHtjYm94TWVudX1cclxuICoqL1xyXG5kYy5jYm94TWVudSA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoYXJ0R3JvdXApIHtcclxuICAgIHZhciBHUk9VUF9DU1NfQ0xBU1MgPSAnZGMtY2JveC1ncm91cCc7XHJcbiAgICB2YXIgSVRFTV9DU1NfQ0xBU1MgPSAnZGMtY2JveC1pdGVtJztcclxuXHJcbiAgICB2YXIgX2NoYXJ0ID0gZGMuYmFzZU1peGluKHt9KTtcclxuXHJcbiAgICB2YXIgX2Nib3g7XHJcbiAgICB2YXIgX3Byb21wdFRleHQgPSAnU2VsZWN0IGFsbCc7XHJcbiAgICB2YXIgX211bHRpcGxlID0gZmFsc2U7XHJcbiAgICB2YXIgX2lucHV0VHlwZSA9ICdyYWRpbyc7XHJcbiAgICB2YXIgX3Byb21wdFZhbHVlID0gbnVsbDtcclxuICAgIC8vIGdlbmVyYXRlIGEgcmFuZG9tIG51bWJlciB0byB1c2UgYXMgYW4gSURcclxuICAgIHZhciBfcmFuZFZhbCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqICgxMDAwMDApKSArIDE7XHJcbiAgICB2YXIgX29yZGVyID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICByZXR1cm4gX2NoYXJ0LmtleUFjY2Vzc29yKCkoYSkgPiBfY2hhcnQua2V5QWNjZXNzb3IoKShiKSA/XHJcbiAgICAgICAgICAgICAxIDogX2NoYXJ0LmtleUFjY2Vzc29yKCkoYikgPiBfY2hhcnQua2V5QWNjZXNzb3IoKShhKSA/XHJcbiAgICAgICAgICAgIC0xIDogMDtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIF9maWx0ZXJEaXNwbGF5ZWQgPSBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQudmFsdWVBY2Nlc3NvcigpKGQpID4gMDtcclxuICAgIH07XHJcblxyXG4gICAgX2NoYXJ0LmRhdGEoZnVuY3Rpb24gKGdyb3VwKSB7XHJcbiAgICAgICAgcmV0dXJuIGdyb3VwLmFsbCgpLmZpbHRlcihfZmlsdGVyRGlzcGxheWVkKTtcclxuICAgIH0pO1xyXG5cclxuICAgIF9jaGFydC5fZG9SZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydC5fZG9SZWRyYXcoKTtcclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgLy8gSVMgVEhJUyBORUVERUQ/XHJcbiAgICAvLyBGaXhpbmcgSUUgMTEgY3Jhc2ggd2hlbiByZWRyYXdpbmcgdGhlIGNoYXJ0XHJcbiAgICAvLyBzZWUgaGVyZSBmb3IgbGlzdCBvZiBJRSB1c2VyIEFnZW50cyA6XHJcbiAgICAvLyBodHRwOi8vd3d3LnVzZXJhZ2VudHN0cmluZy5jb20vcGFnZXMvdXNlcmFnZW50c3RyaW5nLnBocD9uYW1lPUludGVybmV0K0V4cGxvcmVyXHJcbiAgICB2YXIgdWEgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcclxuICAgIC8vIHRlc3QgZm9yIElFIDExIGJ1dCBub3QgYSBsb3dlciB2ZXJzaW9uICh3aGljaCBjb250YWlucyBNU0lFIGluIFVBKVxyXG4gICAgaWYgKHVhLmluZGV4T2YoJ1RyaWRlbnQvJykgPiAwICYmIHVhLmluZGV4T2YoJ01TSUUnKSA9PT0gLTEpIHtcclxuICAgICAgICBfY2hhcnQucmVkcmF3ID0gX2NoYXJ0LnJlbmRlcjtcclxuICAgIH1cclxuICAgICovXHJcbiAgICBfY2hhcnQuX2RvUmVkcmF3ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9jaGFydC5zZWxlY3QoJ3VsJykucmVtb3ZlKCk7XHJcbiAgICAgICAgX2Nib3ggPSBfY2hhcnQucm9vdCgpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3VsJylcclxuICAgICAgICAgICAgLmNsYXNzZWQoR1JPVVBfQ1NTX0NMQVNTLCB0cnVlKTtcclxuICAgICAgICByZW5kZXJPcHRpb25zKCk7XHJcblxyXG4gICAgICAgIGlmIChfY2hhcnQuaGFzRmlsdGVyKCkgJiYgX211bHRpcGxlKSB7XHJcbiAgICAgICAgICAgIF9jYm94LnNlbGVjdEFsbCgnaW5wdXQnKVxyXG4gICAgICAgICAgICAgICAgLnByb3BlcnR5KCdjaGVja2VkJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBhZGRpbmcgYGZhbHNlYCBhdm9pZHMgZmFpbGluZyB0ZXN0IGNhc2VzIGluIHBoYW50b21qc1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkICYmIF9jaGFydC5maWx0ZXJzKCkuaW5kZXhPZihTdHJpbmcoX2NoYXJ0LmtleUFjY2Vzc29yKCkoZCkpKSA+PSAwIHx8IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChfY2hhcnQuaGFzRmlsdGVyKCkpIHtcclxuICAgICAgICAgICAgX2Nib3guc2VsZWN0QWxsKCdpbnB1dCcpXHJcbiAgICAgICAgICAgICAgICAucHJvcGVydHkoJ2NoZWNrZWQnLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfY2hhcnQua2V5QWNjZXNzb3IoKShkKSA9PT0gX2NoYXJ0LmZpbHRlcigpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIHJlbmRlck9wdGlvbnMgKCkge1xyXG4gICAgICAgIHZhciBvcHRpb25zID0gX2Nib3hcclxuICAgICAgICAuc2VsZWN0QWxsKCdsaS4nICsgSVRFTV9DU1NfQ0xBU1MpXHJcbiAgICAgICAgICAgIC5kYXRhKF9jaGFydC5kYXRhKCksIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfY2hhcnQua2V5QWNjZXNzb3IoKShkKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgb3B0aW9ucy5leGl0KCkucmVtb3ZlKCk7XHJcblxyXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zLmVudGVyKClcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2xpJylcclxuICAgICAgICAgICAgICAgIC5jbGFzc2VkKElURU1fQ1NTX0NMQVNTLCB0cnVlKVxyXG4gICAgICAgICAgICAubWVyZ2Uob3B0aW9ucyk7XHJcblxyXG4gICAgICAgIG9wdGlvbnNcclxuICAgICAgICAgICAgLmFwcGVuZCgnaW5wdXQnKVxyXG4gICAgICAgICAgICAuYXR0cigndHlwZScsIF9pbnB1dFR5cGUpXHJcbiAgICAgICAgICAgIC5hdHRyKCd2YWx1ZScsIGZ1bmN0aW9uIChkKSB7IHJldHVybiBfY2hhcnQua2V5QWNjZXNzb3IoKShkKTsgfSlcclxuICAgICAgICAgICAgLmF0dHIoJ25hbWUnLCAnZG9tYWluXycgKyBfcmFuZFZhbClcclxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnaW5wdXRfJyArIF9yYW5kVmFsICsgJ18nICsgaTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgb3B0aW9uc1xyXG4gICAgICAgICAgICAuYXBwZW5kKCdsYWJlbCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdmb3InLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdpbnB1dF8nICsgX3JhbmRWYWwgKyAnXycgKyBpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAudGV4dChfY2hhcnQudGl0bGUoKSk7XHJcblxyXG4gICAgICAgIC8vICdhbGwnIG9wdGlvblxyXG4gICAgICAgIGlmIChfbXVsdGlwbGUpIHtcclxuICAgICAgICAgICAgX2Nib3hcclxuICAgICAgICAgICAgLmFwcGVuZCgnbGknKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdpbnB1dCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0eXBlJywgJ3Jlc2V0JylcclxuICAgICAgICAgICAgLnRleHQoX3Byb21wdFRleHQpXHJcbiAgICAgICAgICAgIC5vbignY2xpY2snLCBvbkNoYW5nZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGxpID0gX2Nib3guYXBwZW5kKCdsaScpO1xyXG4gICAgICAgICAgICBsaS5hcHBlbmQoJ2lucHV0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd0eXBlJywgX2lucHV0VHlwZSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd2YWx1ZScsIF9wcm9tcHRWYWx1ZSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCduYW1lJywgJ2RvbWFpbl8nICsgX3JhbmRWYWwpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnaW5wdXRfJyArIF9yYW5kVmFsICsgJ19hbGwnO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5wcm9wZXJ0eSgnY2hlY2tlZCcsIHRydWUpO1xyXG4gICAgICAgICAgICBsaS5hcHBlbmQoJ2xhYmVsJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdmb3InLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnaW5wdXRfJyArIF9yYW5kVmFsICsgJ19hbGwnO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC50ZXh0KF9wcm9tcHRUZXh0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIF9jYm94XHJcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoJ2xpLicgKyBJVEVNX0NTU19DTEFTUylcclxuICAgICAgICAgICAgLnNvcnQoX29yZGVyKTtcclxuXHJcbiAgICAgICAgX2Nib3gub24oJ2NoYW5nZScsIG9uQ2hhbmdlKTtcclxuICAgICAgICByZXR1cm4gb3B0aW9ucztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBvbkNoYW5nZSAoZCwgaSkge1xyXG4gICAgICAgIHZhciB2YWx1ZXMsXHJcbiAgICAgICAgICAgIHRhcmdldCA9IGQzLnNlbGVjdChkMy5ldmVudC50YXJnZXQpLFxyXG4gICAgICAgICAgICBvcHRpb25zO1xyXG5cclxuICAgICAgICBpZiAoIXRhcmdldC5kYXR1bSgpKSB7XHJcbiAgICAgICAgICAgIHZhbHVlcyA9IF9wcm9tcHRWYWx1ZSB8fCBudWxsO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSBkMy5zZWxlY3QodGhpcykuc2VsZWN0QWxsKCdpbnB1dCcpXHJcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICAgICAgICAgIGlmIChvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tlZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHZhbHVlcyA9IG9wdGlvbnMubm9kZXMoKS5tYXAoZnVuY3Rpb24gKG9wdGlvbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbi52YWx1ZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIG9ubHkgcHJvbXB0IG9wdGlvbiBpcyBzZWxlY3RlZFxyXG4gICAgICAgICAgICBpZiAoIV9tdWx0aXBsZSAmJiB2YWx1ZXMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXNbMF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgX2NoYXJ0Lm9uQ2hhbmdlKHZhbHVlcyk7XHJcbiAgICB9XHJcblxyXG4gICAgX2NoYXJ0Lm9uQ2hhbmdlID0gZnVuY3Rpb24gKHZhbCkge1xyXG4gICAgICAgIGlmICh2YWwgJiYgX211bHRpcGxlKSB7XHJcbiAgICAgICAgICAgIF9jaGFydC5yZXBsYWNlRmlsdGVyKFt2YWxdKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHZhbCkge1xyXG4gICAgICAgICAgICBfY2hhcnQucmVwbGFjZUZpbHRlcih2YWwpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIF9jaGFydC5maWx0ZXJBbGwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGMuZXZlbnRzLnRyaWdnZXIoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfY2hhcnQucmVkcmF3R3JvdXAoKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgb3Igc2V0IHRoZSBmdW5jdGlvbiB0aGF0IGNvbnRyb2xzIHRoZSBvcmRlcmluZyBvZiBvcHRpb24gdGFncyBpbiB0aGVcclxuICAgICAqIGNib3ggbWVudS4gQnkgZGVmYXVsdCBvcHRpb25zIGFyZSBvcmRlcmVkIGJ5IHRoZSBncm91cCBrZXkgaW4gYXNjZW5kaW5nXHJcbiAgICAgKiBvcmRlci5cclxuICAgICAqIEBuYW1lIG9yZGVyXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuY2JveE1lbnVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29yZGVyXVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIG9yZGVyIGJ5IHRoZSBncm91cCdzIHZhbHVlXHJcbiAgICAgKiBjaGFydC5vcmRlcihmdW5jdGlvbiAoYSxiKSB7XHJcbiAgICAgKiAgICAgcmV0dXJuIGEudmFsdWUgPiBiLnZhbHVlID8gMSA6IGIudmFsdWUgPiBhLnZhbHVlID8gLTEgOiAwO1xyXG4gICAgICogfSk7XHJcbiAgICAgKiovXHJcbiAgICBfY2hhcnQub3JkZXIgPSBmdW5jdGlvbiAob3JkZXIpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9vcmRlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgX29yZGVyID0gb3JkZXI7XHJcbiAgICAgICAgcmV0dXJuIF9jaGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgb3Igc2V0IHRoZSB0ZXh0IGRpc3BsYXllZCBpbiB0aGUgb3B0aW9ucyB1c2VkIHRvIHByb21wdCBzZWxlY3Rpb24uXHJcbiAgICAgKiBAbmFtZSBwcm9tcHRUZXh0XHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuY2JveE1lbnVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtwcm9tcHRUZXh0PSdTZWxlY3QgYWxsJ11cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBjaGFydC5wcm9tcHRUZXh0KCdBbGwgc3RhdGVzJyk7XHJcbiAgICAgKiovXHJcbiAgICBfY2hhcnQucHJvbXB0VGV4dCA9IGZ1bmN0aW9uIChfKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfcHJvbXB0VGV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3Byb21wdFRleHQgPSBfO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IG9yIHNldCB0aGUgZnVuY3Rpb24gdGhhdCBmaWx0ZXJzIG9wdGlvbnMgcHJpb3IgdG8gZGlzcGxheS4gQnkgZGVmYXVsdCBvcHRpb25zXHJcbiAgICAgKiB3aXRoIGEgdmFsdWUgb2YgPCAxIGFyZSBub3QgZGlzcGxheWVkLlxyXG4gICAgICogQG5hbWUgZmlsdGVyRGlzcGxheWVkXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuY2JveE1lbnVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2ZpbHRlckRpc3BsYXllZF1cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBkaXNwbGF5IGFsbCBvcHRpb25zIG92ZXJyaWRlIHRoZSBgZmlsdGVyRGlzcGxheWVkYCBmdW5jdGlvbjpcclxuICAgICAqIGNoYXJ0LmZpbHRlckRpc3BsYXllZChmdW5jdGlvbiAoKSB7XHJcbiAgICAgKiAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgKiB9KTtcclxuICAgICAqKi9cclxuICAgIF9jaGFydC5maWx0ZXJEaXNwbGF5ZWQgPSBmdW5jdGlvbiAoZmlsdGVyRGlzcGxheWVkKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfZmlsdGVyRGlzcGxheWVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfZmlsdGVyRGlzcGxheWVkID0gZmlsdGVyRGlzcGxheWVkO1xyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udHJvbHMgdGhlIHR5cGUgb2YgaW5wdXQgZWxlbWVudC4gU2V0dGluZyBpdCB0byB0cnVlIGNvbnZlcnRzXHJcbiAgICAgKiB0aGUgSFRNTCBgaW5wdXRgIHRhZ3MgZnJvbSByYWRpbyBidXR0b25zIHRvIGNoZWNrYm94ZXMuXHJcbiAgICAgKiBAbmFtZSBtdWx0aXBsZVxyXG4gICAgICogQG1lbWJlcm9mIGRjLmNib3hNZW51XHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW211bHRpcGxlPWZhbHNlXVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGNoYXJ0Lm11bHRpcGxlKHRydWUpO1xyXG4gICAgICoqL1xyXG4gICAgX2NoYXJ0Lm11bHRpcGxlID0gZnVuY3Rpb24gKG11bHRpcGxlKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfbXVsdGlwbGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9tdWx0aXBsZSA9IG11bHRpcGxlO1xyXG4gICAgICAgIGlmIChfbXVsdGlwbGUpIHtcclxuICAgICAgICAgICAgX2lucHV0VHlwZSA9ICdjaGVja2JveCc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgX2lucHV0VHlwZSA9ICdyYWRpbyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udHJvbHMgdGhlIGRlZmF1bHQgdmFsdWUgdG8gYmUgdXNlZCBmb3JcclxuICAgICAqIFtkaW1lbnNpb24uZmlsdGVyXShodHRwczovL2dpdGh1Yi5jb20vY3Jvc3NmaWx0ZXIvY3Jvc3NmaWx0ZXIvd2lraS9BUEktUmVmZXJlbmNlI2RpbWVuc2lvbl9maWx0ZXIpXHJcbiAgICAgKiB3aGVuIG9ubHkgdGhlIHByb21wdCB2YWx1ZSBpcyBzZWxlY3RlZC4gSWYgYG51bGxgICh0aGUgZGVmYXVsdCksIG5vIGZpbHRlcmluZyB3aWxsIG9jY3VyIHdoZW5cclxuICAgICAqIGp1c3QgdGhlIHByb21wdCBpcyBzZWxlY3RlZC5cclxuICAgICAqIEBuYW1lIHByb21wdFZhbHVlXHJcbiAgICAgKiBAbWVtYmVyb2YgZGMuY2JveE1lbnVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHs/Kn0gW3Byb21wdFZhbHVlPW51bGxdXHJcbiAgICAgKiovXHJcbiAgICBfY2hhcnQucHJvbXB0VmFsdWUgPSBmdW5jdGlvbiAocHJvbXB0VmFsdWUpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9wcm9tcHRWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3Byb21wdFZhbHVlID0gcHJvbXB0VmFsdWU7XHJcblxyXG4gICAgICAgIHJldHVybiBfY2hhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBfY2hhcnQuYW5jaG9yKHBhcmVudCwgY2hhcnRHcm91cCk7XHJcbn07XHJcblxyXG4vLyBSZW5hbWVkIGZ1bmN0aW9uc1xyXG5cclxuZGMuYWJzdHJhY3RCdWJibGVDaGFydCA9IGRjLmJ1YmJsZU1peGluO1xyXG5kYy5iYXNlQ2hhcnQgPSBkYy5iYXNlTWl4aW47XHJcbmRjLmNhcHBlZCA9IGRjLmNhcE1peGluO1xyXG5kYy5jb2xvckNoYXJ0ID0gZGMuY29sb3JNaXhpbjtcclxuZGMuY29vcmRpbmF0ZUdyaWRDaGFydCA9IGRjLmNvb3JkaW5hdGVHcmlkTWl4aW47XHJcbmRjLm1hcmdpbmFibGUgPSBkYy5tYXJnaW5NaXhpbjtcclxuZGMuc3RhY2thYmxlQ2hhcnQgPSBkYy5zdGFja01peGluO1xyXG5cclxuLy8gRXhwb3NlIGQzIGFuZCBjcm9zc2ZpbHRlciwgc28gdGhhdCBjbGllbnRzIGluIGJyb3dzZXJpZnlcclxuLy8gY2FzZSBjYW4gb2J0YWluIHRoZW0gaWYgdGhleSBuZWVkIHRoZW0uXHJcbmRjLmQzID0gZDM7XHJcbmRjLmNyb3NzZmlsdGVyID0gY3Jvc3NmaWx0ZXI7XHJcblxyXG5cclxuZXhwb3J0e2RjfTtcclxuXHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRjLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTtBQUNBOzs7Ozs7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFZQTtBQWRBO0FBZ0JBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQXpFQTtBQTJFQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1QkE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUJBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBK0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUErQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQWNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQStCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBOEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBYkE7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBTUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQStCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFKQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBK0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQStCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQURBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFJQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBSUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBT0E7QUFFQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQUE7QUFDQTtBQUtBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBWEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQUE7QUFFQTtBQUFBO0FBTUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBTUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBSUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFBQTtBQUVBO0FBQUE7QUFLQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFJQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQVdBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBYUE7QUFDQTtBQVFBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQUE7QUFLQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFFQTtBQUNBO0FBQUE7QUFLQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFNQTtBQUlBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBYUE7QUFDQTtBQU9BO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFFQTtBQUNBO0FBR0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFLQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQStCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFHQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/vendor/dc.js\n");

/***/ }),

/***/ "./src/vendor/slick.dataview.js":
/*!**************************************!*\
  !*** ./src/vendor/slick.dataview.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Aggregators = exports.DataView = undefined;\n\nvar _slickGrid = __webpack_require__(/*! ./slick.grid.js */ \"./src/vendor/slick.grid.js\");\n\n/***\r\n * A sample Model implementation.\r\n * Provides a filtered view of the underlying data.\r\n *\r\n * Relies on the data item having an \"id\" property uniquely identifying it.\r\n */\nfunction DataView(options) {\n  var self = this;\n\n  var defaults = {\n    groupItemMetadataProvider: null,\n    inlineFilters: false\n  };\n\n  // private\n  var idProperty = \"id\"; // property holding a unique row id\n  var items = []; // data by index\n  var rows = []; // data by row\n  var idxById = {}; // indexes by id\n  var rowsById = null; // rows by id; lazy-calculated\n  var filter = null; // filter function\n  var updated = null; // updated item ids\n  var suspend = false; // suspends the recalculation\n  var sortAsc = true;\n  var fastSortField;\n  var sortComparer;\n  var refreshHints = {};\n  var prevRefreshHints = {};\n  var filterArgs;\n  var filteredItems = [];\n  var compiledFilter;\n  var compiledFilterWithCaching;\n  var filterCache = [];\n\n  // grouping\n  var groupingInfoDefaults = {\n    getter: null,\n    formatter: null,\n    comparer: function comparer(a, b) {\n      return a.value === b.value ? 0 : a.value > b.value ? 1 : -1;\n    },\n    predefinedValues: [],\n    aggregators: [],\n    aggregateEmpty: false,\n    aggregateCollapsed: false,\n    aggregateChildGroups: false,\n    collapsed: false,\n    displayTotalsRow: true,\n    lazyTotalsCalculation: false\n  };\n  var groupingInfos = [];\n  var groups = [];\n  var toggledGroupsByLevel = [];\n  var groupingDelimiter = ':|:';\n\n  var pagesize = 0;\n  var pagenum = 0;\n  var totalRows = 0;\n\n  // events\n  var onRowCountChanged = new _slickGrid.Slick.Event();\n  var onRowsChanged = new _slickGrid.Slick.Event();\n  var onPagingInfoChanged = new _slickGrid.Slick.Event();\n\n  options = $.extend(true, {}, defaults, options);\n\n  function beginUpdate() {\n    suspend = true;\n  }\n\n  function endUpdate() {\n    suspend = false;\n    refresh();\n  }\n\n  function setRefreshHints(hints) {\n    refreshHints = hints;\n  }\n\n  function setFilterArgs(args) {\n    filterArgs = args;\n  }\n\n  function updateIdxById(startingIndex) {\n    startingIndex = startingIndex || 0;\n    var id;\n    for (var i = startingIndex, l = items.length; i < l; i++) {\n      id = items[i][idProperty];\n      if (id === undefined) {\n        throw new Error(\"Each data element must implement a unique 'id' property\");\n      }\n      idxById[id] = i;\n    }\n  }\n\n  function ensureIdUniqueness() {\n    var id;\n    for (var i = 0, l = items.length; i < l; i++) {\n      id = items[i][idProperty];\n      if (id === undefined || idxById[id] !== i) {\n        throw new Error(\"Each data element must implement a unique 'id' property\");\n      }\n    }\n  }\n\n  function getItems() {\n    return items;\n  }\n\n  function setItems(data, objectIdProperty) {\n    if (objectIdProperty !== undefined) {\n      idProperty = objectIdProperty;\n    }\n    items = filteredItems = data;\n    idxById = {};\n    updateIdxById();\n    ensureIdUniqueness();\n    refresh();\n  }\n\n  function setPagingOptions(args) {\n    if (args.pageSize != undefined) {\n      pagesize = args.pageSize;\n      pagenum = pagesize ? Math.min(pagenum, Math.max(0, Math.ceil(totalRows / pagesize) - 1)) : 0;\n    }\n\n    if (args.pageNum != undefined) {\n      pagenum = Math.min(args.pageNum, Math.max(0, Math.ceil(totalRows / pagesize) - 1));\n    }\n\n    onPagingInfoChanged.notify(getPagingInfo(), null, self);\n\n    refresh();\n  }\n\n  function getPagingInfo() {\n    var totalPages = pagesize ? Math.max(1, Math.ceil(totalRows / pagesize)) : 1;\n    return { pageSize: pagesize, pageNum: pagenum, totalRows: totalRows, totalPages: totalPages, dataView: self };\n  }\n\n  function sort(comparer, ascending) {\n    sortAsc = ascending;\n    sortComparer = comparer;\n    fastSortField = null;\n    if (ascending === false) {\n      items.reverse();\n    }\n    items.sort(comparer);\n    if (ascending === false) {\n      items.reverse();\n    }\n    idxById = {};\n    updateIdxById();\n    refresh();\n  }\n\n  /***\r\n   * Provides a workaround for the extremely slow sorting in IE.\r\n   * Does a [lexicographic] sort on a give column by temporarily overriding Object.prototype.toString\r\n   * to return the value of that field and then doing a native Array.sort().\r\n   */\n  function fastSort(field, ascending) {\n    sortAsc = ascending;\n    fastSortField = field;\n    sortComparer = null;\n    var oldToString = Object.prototype.toString;\n    Object.prototype.toString = typeof field == \"function\" ? field : function () {\n      return this[field];\n    };\n    // an extra reversal for descending sort keeps the sort stable\n    // (assuming a stable native sort implementation, which isn't true in some cases)\n    if (ascending === false) {\n      items.reverse();\n    }\n    items.sort();\n    Object.prototype.toString = oldToString;\n    if (ascending === false) {\n      items.reverse();\n    }\n    idxById = {};\n    updateIdxById();\n    refresh();\n  }\n\n  function reSort() {\n    if (sortComparer) {\n      sort(sortComparer, sortAsc);\n    } else if (fastSortField) {\n      fastSort(fastSortField, sortAsc);\n    }\n  }\n\n  function getFilteredItems() {\n    return filteredItems;\n  }\n\n  function getFilter() {\n    return filter;\n  }\n\n  function setFilter(filterFn) {\n    filter = filterFn;\n    if (options.inlineFilters) {\n      compiledFilter = compileFilter();\n      compiledFilterWithCaching = compileFilterWithCaching();\n    }\n    refresh();\n  }\n\n  function getGrouping() {\n    return groupingInfos;\n  }\n\n  function setGrouping(groupingInfo) {\n    if (!options.groupItemMetadataProvider) {\n      options.groupItemMetadataProvider = new _slickGrid.Slick.Data.GroupItemMetadataProvider();\n    }\n\n    groups = [];\n    toggledGroupsByLevel = [];\n    groupingInfo = groupingInfo || [];\n    groupingInfos = groupingInfo instanceof Array ? groupingInfo : [groupingInfo];\n\n    for (var i = 0; i < groupingInfos.length; i++) {\n      var gi = groupingInfos[i] = $.extend(true, {}, groupingInfoDefaults, groupingInfos[i]);\n      gi.getterIsAFn = typeof gi.getter === \"function\";\n\n      // pre-compile accumulator loops\n      gi.compiledAccumulators = [];\n      var idx = gi.aggregators.length;\n      while (idx--) {\n        gi.compiledAccumulators[idx] = compileAccumulatorLoop(gi.aggregators[idx]);\n      }\n\n      toggledGroupsByLevel[i] = {};\n    }\n\n    refresh();\n  }\n\n  /**\r\n   * @deprecated Please use {@link setGrouping}.\r\n   */\n  function groupBy(valueGetter, valueFormatter, sortComparer) {\n    if (valueGetter == null) {\n      setGrouping([]);\n      return;\n    }\n\n    setGrouping({\n      getter: valueGetter,\n      formatter: valueFormatter,\n      comparer: sortComparer\n    });\n  }\n\n  /**\r\n   * @deprecated Please use {@link setGrouping}.\r\n   */\n  function setAggregators(groupAggregators, includeCollapsed) {\n    if (!groupingInfos.length) {\n      throw new Error(\"At least one grouping must be specified before calling setAggregators().\");\n    }\n\n    groupingInfos[0].aggregators = groupAggregators;\n    groupingInfos[0].aggregateCollapsed = includeCollapsed;\n\n    setGrouping(groupingInfos);\n  }\n\n  function getItemByIdx(i) {\n    return items[i];\n  }\n\n  function getIdxById(id) {\n    return idxById[id];\n  }\n\n  function ensureRowsByIdCache() {\n    if (!rowsById) {\n      rowsById = {};\n      for (var i = 0, l = rows.length; i < l; i++) {\n        rowsById[rows[i][idProperty]] = i;\n      }\n    }\n  }\n\n  function getRowByItem(item) {\n    ensureRowsByIdCache();\n    return rowsById[item[idProperty]];\n  }\n\n  function getRowById(id) {\n    ensureRowsByIdCache();\n    return rowsById[id];\n  }\n\n  function getItemById(id) {\n    return items[idxById[id]];\n  }\n\n  function mapItemsToRows(itemArray) {\n    var rows = [];\n    ensureRowsByIdCache();\n    for (var i = 0, l = itemArray.length; i < l; i++) {\n      var row = rowsById[itemArray[i][idProperty]];\n      if (row != null) {\n        rows[rows.length] = row;\n      }\n    }\n    return rows;\n  }\n\n  function mapIdsToRows(idArray) {\n    var rows = [];\n    ensureRowsByIdCache();\n    for (var i = 0, l = idArray.length; i < l; i++) {\n      var row = rowsById[idArray[i]];\n      if (row != null) {\n        rows[rows.length] = row;\n      }\n    }\n    return rows;\n  }\n\n  function mapRowsToIds(rowArray) {\n    var ids = [];\n    for (var i = 0, l = rowArray.length; i < l; i++) {\n      if (rowArray[i] < rows.length) {\n        ids[ids.length] = rows[rowArray[i]][idProperty];\n      }\n    }\n    return ids;\n  }\n\n  function updateItem(id, item) {\n    if (idxById[id] === undefined || id !== item[idProperty]) {\n      throw new Error(\"Invalid or non-matching id\");\n    }\n    items[idxById[id]] = item;\n    if (!updated) {\n      updated = {};\n    }\n    updated[id] = true;\n    refresh();\n  }\n\n  function insertItem(insertBefore, item) {\n    items.splice(insertBefore, 0, item);\n    updateIdxById(insertBefore);\n    refresh();\n  }\n\n  function addItem(item) {\n    items.push(item);\n    updateIdxById(items.length - 1);\n    refresh();\n  }\n\n  function deleteItem(id) {\n    var idx = idxById[id];\n    if (idx === undefined) {\n      throw new Error(\"Invalid id\");\n    }\n    delete idxById[id];\n    items.splice(idx, 1);\n    updateIdxById(idx);\n    refresh();\n  }\n\n  function sortedAddItem(item) {\n    if (!sortComparer) {\n      throw new Error(\"sortedAddItem() requires a sort comparer, use sort()\");\n    }\n    insertItem(sortedIndex(item), item);\n  }\n\n  function sortedUpdateItem(id, item) {\n    if (idxById[id] === undefined || id !== item[idProperty]) {\n      throw new Error(\"Invalid or non-matching id \" + idxById[id]);\n    }\n    if (!sortComparer) {\n      throw new Error(\"sortedUpdateItem() requires a sort comparer, use sort()\");\n    }\n    var oldItem = getItemById(id);\n    if (sortComparer(oldItem, item) !== 0) {\n      // item affects sorting -> must use sorted add\n      deleteItem(id);\n      sortedAddItem(item);\n    } else {\n      // update does not affect sorting -> regular update works fine\n      updateItem(id, item);\n    }\n  }\n\n  function sortedIndex(searchItem) {\n    var low = 0,\n        high = items.length;\n\n    while (low < high) {\n      var mid = low + high >>> 1;\n      if (sortComparer(items[mid], searchItem) === -1) {\n        low = mid + 1;\n      } else {\n        high = mid;\n      }\n    }\n    return low;\n  }\n\n  function getLength() {\n    return rows.length;\n  }\n\n  function getItem(i) {\n    var item = rows[i];\n\n    // if this is a group row, make sure totals are calculated and update the title\n    if (item && item.__group && item.totals && !item.totals.initialized) {\n      var gi = groupingInfos[item.level];\n      if (!gi.displayTotalsRow) {\n        calculateTotals(item.totals);\n        item.title = gi.formatter ? gi.formatter(item) : item.value;\n      }\n    }\n    // if this is a totals row, make sure it's calculated\n    else if (item && item.__groupTotals && !item.initialized) {\n        calculateTotals(item);\n      }\n\n    return item;\n  }\n\n  function getItemMetadata(i) {\n    var item = rows[i];\n    if (item === undefined) {\n      return null;\n    }\n\n    // overrides for grouping rows\n    if (item.__group) {\n      return options.groupItemMetadataProvider.getGroupRowMetadata(item);\n    }\n\n    // overrides for totals rows\n    if (item.__groupTotals) {\n      return options.groupItemMetadataProvider.getTotalsRowMetadata(item);\n    }\n\n    return null;\n  }\n\n  function expandCollapseAllGroups(level, collapse) {\n    if (level == null) {\n      for (var i = 0; i < groupingInfos.length; i++) {\n        toggledGroupsByLevel[i] = {};\n        groupingInfos[i].collapsed = collapse;\n      }\n    } else {\n      toggledGroupsByLevel[level] = {};\n      groupingInfos[level].collapsed = collapse;\n    }\n    refresh();\n  }\n\n  /**\r\n   * @param level {Number} Optional level to collapse.  If not specified, applies to all levels.\r\n   */\n  function collapseAllGroups(level) {\n    expandCollapseAllGroups(level, true);\n  }\n\n  /**\r\n   * @param level {Number} Optional level to expand.  If not specified, applies to all levels.\r\n   */\n  function expandAllGroups(level) {\n    expandCollapseAllGroups(level, false);\n  }\n\n  function expandCollapseGroup(level, groupingKey, collapse) {\n    toggledGroupsByLevel[level][groupingKey] = groupingInfos[level].collapsed ^ collapse;\n    refresh();\n  }\n\n  /**\r\n   * @param varArgs Either a Slick.Group's \"groupingKey\" property, or a\r\n   *     variable argument list of grouping values denoting a unique path to the row.  For\r\n   *     example, calling collapseGroup('high', '10%') will collapse the '10%' subgroup of\r\n   *     the 'high' group.\r\n   */\n  function collapseGroup(varArgs) {\n    var args = Array.prototype.slice.call(arguments);\n    var arg0 = args[0];\n    if (args.length == 1 && arg0.indexOf(groupingDelimiter) != -1) {\n      expandCollapseGroup(arg0.split(groupingDelimiter).length - 1, arg0, true);\n    } else {\n      expandCollapseGroup(args.length - 1, args.join(groupingDelimiter), true);\n    }\n  }\n\n  /**\r\n   * @param varArgs Either a Slick.Group's \"groupingKey\" property, or a\r\n   *     variable argument list of grouping values denoting a unique path to the row.  For\r\n   *     example, calling expandGroup('high', '10%') will expand the '10%' subgroup of\r\n   *     the 'high' group.\r\n   */\n  function expandGroup(varArgs) {\n    var args = Array.prototype.slice.call(arguments);\n    var arg0 = args[0];\n    if (args.length == 1 && arg0.indexOf(groupingDelimiter) != -1) {\n      expandCollapseGroup(arg0.split(groupingDelimiter).length - 1, arg0, false);\n    } else {\n      expandCollapseGroup(args.length - 1, args.join(groupingDelimiter), false);\n    }\n  }\n\n  function getGroups() {\n    return groups;\n  }\n\n  function extractGroups(rows, parentGroup) {\n    var group;\n    var val;\n    var groups = [];\n    var groupsByVal = {};\n    var r;\n    var level = parentGroup ? parentGroup.level + 1 : 0;\n    var gi = groupingInfos[level];\n\n    for (var i = 0, l = gi.predefinedValues.length; i < l; i++) {\n      val = gi.predefinedValues[i];\n      group = groupsByVal[val];\n      if (!group) {\n        group = new _slickGrid.Slick.Group();\n        group.value = val;\n        group.level = level;\n        group.groupingKey = (parentGroup ? parentGroup.groupingKey + groupingDelimiter : '') + val;\n        groups[groups.length] = group;\n        groupsByVal[val] = group;\n      }\n    }\n\n    for (var i = 0, l = rows.length; i < l; i++) {\n      r = rows[i];\n      val = gi.getterIsAFn ? gi.getter(r) : r[gi.getter];\n      group = groupsByVal[val];\n      if (!group) {\n        group = new _slickGrid.Slick.Group();\n        group.value = val;\n        group.level = level;\n        group.groupingKey = (parentGroup ? parentGroup.groupingKey + groupingDelimiter : '') + val;\n        groups[groups.length] = group;\n        groupsByVal[val] = group;\n      }\n\n      group.rows[group.count++] = r;\n    }\n\n    if (level < groupingInfos.length - 1) {\n      for (var i = 0; i < groups.length; i++) {\n        group = groups[i];\n        group.groups = extractGroups(group.rows, group);\n      }\n    }\n\n    groups.sort(groupingInfos[level].comparer);\n\n    return groups;\n  }\n\n  function calculateTotals(totals) {\n    var group = totals.group;\n    var gi = groupingInfos[group.level];\n    var isLeafLevel = group.level == groupingInfos.length;\n    var agg,\n        idx = gi.aggregators.length;\n\n    if (!isLeafLevel && gi.aggregateChildGroups) {\n      // make sure all the subgroups are calculated\n      var i = group.groups.length;\n      while (i--) {\n        if (!group.groups[i].totals.initialized) {\n          calculateTotals(group.groups[i].totals);\n        }\n      }\n    }\n\n    while (idx--) {\n      agg = gi.aggregators[idx];\n      agg.init();\n      if (!isLeafLevel && gi.aggregateChildGroups) {\n        gi.compiledAccumulators[idx].call(agg, group.groups);\n      } else {\n        gi.compiledAccumulators[idx].call(agg, group.rows);\n      }\n      agg.storeResult(totals);\n    }\n    totals.initialized = true;\n  }\n\n  function addGroupTotals(group) {\n    var gi = groupingInfos[group.level];\n    var totals = new _slickGrid.Slick.GroupTotals();\n    totals.group = group;\n    group.totals = totals;\n    if (!gi.lazyTotalsCalculation) {\n      calculateTotals(totals);\n    }\n  }\n\n  function addTotals(groups, level) {\n    level = level || 0;\n    var gi = groupingInfos[level];\n    var groupCollapsed = gi.collapsed;\n    var toggledGroups = toggledGroupsByLevel[level];\n    var idx = groups.length,\n        g;\n    while (idx--) {\n      g = groups[idx];\n\n      if (g.collapsed && !gi.aggregateCollapsed) {\n        continue;\n      }\n\n      // Do a depth-first aggregation so that parent group aggregators can access subgroup totals.\n      if (g.groups) {\n        addTotals(g.groups, level + 1);\n      }\n\n      if (gi.aggregators.length && (gi.aggregateEmpty || g.rows.length || g.groups && g.groups.length)) {\n        addGroupTotals(g);\n      }\n\n      g.collapsed = groupCollapsed ^ toggledGroups[g.groupingKey];\n      g.title = gi.formatter ? gi.formatter(g) : g.value;\n    }\n  }\n\n  function flattenGroupedRows(groups, level) {\n    level = level || 0;\n    var gi = groupingInfos[level];\n    var groupedRows = [],\n        rows,\n        gl = 0,\n        g;\n    for (var i = 0, l = groups.length; i < l; i++) {\n      g = groups[i];\n      groupedRows[gl++] = g;\n\n      if (!g.collapsed) {\n        rows = g.groups ? flattenGroupedRows(g.groups, level + 1) : g.rows;\n        for (var j = 0, jj = rows.length; j < jj; j++) {\n          groupedRows[gl++] = rows[j];\n        }\n      }\n\n      if (g.totals && gi.displayTotalsRow && (!g.collapsed || gi.aggregateCollapsed)) {\n        groupedRows[gl++] = g.totals;\n      }\n    }\n    return groupedRows;\n  }\n\n  function getFunctionInfo(fn) {\n    var fnRegex = /^function[^(]*\\(([^)]*)\\)\\s*{([\\s\\S]*)}$/;\n    var matches = fn.toString().match(fnRegex);\n    return {\n      params: matches[1].split(\",\"),\n      body: matches[2]\n    };\n  }\n\n  function compileAccumulatorLoop(aggregator) {\n    var accumulatorInfo = getFunctionInfo(aggregator.accumulate);\n    var fn = new Function(\"_items\", \"for (var \" + accumulatorInfo.params[0] + \", _i=0, _il=_items.length; _i<_il; _i++) {\" + accumulatorInfo.params[0] + \" = _items[_i]; \" + accumulatorInfo.body + \"}\");\n    fn.displayName = fn.name = \"compiledAccumulatorLoop\";\n    return fn;\n  }\n\n  function compileFilter() {\n    var filterInfo = getFunctionInfo(filter);\n\n    var filterPath1 = \"{ continue _coreloop; }$1\";\n    var filterPath2 = \"{ _retval[_idx++] = $item$; continue _coreloop; }$1\";\n    // make some allowances for minification - there's only so far we can go with RegEx\n    var filterBody = filterInfo.body.replace(/return false\\s*([;}]|\\}|$)/gi, filterPath1).replace(/return!1([;}]|\\}|$)/gi, filterPath1).replace(/return true\\s*([;}]|\\}|$)/gi, filterPath2).replace(/return!0([;}]|\\}|$)/gi, filterPath2).replace(/return ([^;}]+?)\\s*([;}]|$)/gi, \"{ if ($1) { _retval[_idx++] = $item$; }; continue _coreloop; }$2\");\n\n    // This preserves the function template code after JS compression,\n    // so that replace() commands still work as expected.\n    var tpl = [\n    //\"function(_items, _args) { \",\n    \"var _retval = [], _idx = 0; \", \"var $item$, $args$ = _args; \", \"_coreloop: \", \"for (var _i = 0, _il = _items.length; _i < _il; _i++) { \", \"$item$ = _items[_i]; \", \"$filter$; \", \"} \", \"return _retval; \"\n    //\"}\"\n    ].join(\"\");\n    tpl = tpl.replace(/\\$filter\\$/gi, filterBody);\n    tpl = tpl.replace(/\\$item\\$/gi, filterInfo.params[0]);\n    tpl = tpl.replace(/\\$args\\$/gi, filterInfo.params[1]);\n\n    var fn = new Function(\"_items,_args\", tpl);\n    fn.displayName = fn.name = \"compiledFilter\";\n    return fn;\n  }\n\n  function compileFilterWithCaching() {\n    var filterInfo = getFunctionInfo(filter);\n\n    var filterPath1 = \"{ continue _coreloop; }$1\";\n    var filterPath2 = \"{ _cache[_i] = true;_retval[_idx++] = $item$; continue _coreloop; }$1\";\n    // make some allowances for minification - there's only so far we can go with RegEx\n    var filterBody = filterInfo.body.replace(/return false\\s*([;}]|\\}|$)/gi, filterPath1).replace(/return!1([;}]|\\}|$)/gi, filterPath1).replace(/return true\\s*([;}]|\\}|$)/gi, filterPath2).replace(/return!0([;}]|\\}|$)/gi, filterPath2).replace(/return ([^;}]+?)\\s*([;}]|$)/gi, \"{ if ((_cache[_i] = $1)) { _retval[_idx++] = $item$; }; continue _coreloop; }$2\");\n\n    // This preserves the function template code after JS compression,\n    // so that replace() commands still work as expected.\n    var tpl = [\n    //\"function(_items, _args, _cache) { \",\n    \"var _retval = [], _idx = 0; \", \"var $item$, $args$ = _args; \", \"_coreloop: \", \"for (var _i = 0, _il = _items.length; _i < _il; _i++) { \", \"$item$ = _items[_i]; \", \"if (_cache[_i]) { \", \"_retval[_idx++] = $item$; \", \"continue _coreloop; \", \"} \", \"$filter$; \", \"} \", \"return _retval; \"\n    //\"}\"\n    ].join(\"\");\n    tpl = tpl.replace(/\\$filter\\$/gi, filterBody);\n    tpl = tpl.replace(/\\$item\\$/gi, filterInfo.params[0]);\n    tpl = tpl.replace(/\\$args\\$/gi, filterInfo.params[1]);\n\n    var fn = new Function(\"_items,_args,_cache\", tpl);\n    fn.displayName = fn.name = \"compiledFilterWithCaching\";\n    return fn;\n  }\n\n  function uncompiledFilter(items, args) {\n    var retval = [],\n        idx = 0;\n\n    for (var i = 0, ii = items.length; i < ii; i++) {\n      if (filter(items[i], args)) {\n        retval[idx++] = items[i];\n      }\n    }\n\n    return retval;\n  }\n\n  function uncompiledFilterWithCaching(items, args, cache) {\n    var retval = [],\n        idx = 0,\n        item;\n\n    for (var i = 0, ii = items.length; i < ii; i++) {\n      item = items[i];\n      if (cache[i]) {\n        retval[idx++] = item;\n      } else if (filter(item, args)) {\n        retval[idx++] = item;\n        cache[i] = true;\n      }\n    }\n\n    return retval;\n  }\n\n  function getFilteredAndPagedItems(items) {\n    if (filter) {\n      var batchFilter = options.inlineFilters ? compiledFilter : uncompiledFilter;\n      var batchFilterWithCaching = options.inlineFilters ? compiledFilterWithCaching : uncompiledFilterWithCaching;\n\n      if (refreshHints.isFilterNarrowing) {\n        filteredItems = batchFilter(filteredItems, filterArgs);\n      } else if (refreshHints.isFilterExpanding) {\n        filteredItems = batchFilterWithCaching(items, filterArgs, filterCache);\n      } else if (!refreshHints.isFilterUnchanged) {\n        filteredItems = batchFilter(items, filterArgs);\n      }\n    } else {\n      // special case:  if not filtering and not paging, the resulting\n      // rows collection needs to be a copy so that changes due to sort\n      // can be caught\n      filteredItems = pagesize ? items : items.concat();\n    }\n\n    // get the current page\n    var paged;\n    if (pagesize) {\n      if (filteredItems.length <= pagenum * pagesize) {\n        if (filteredItems.length === 0) {\n          pagenum = 0;\n        } else {\n          pagenum = Math.floor((filteredItems.length - 1) / pagesize);\n        }\n      }\n      paged = filteredItems.slice(pagesize * pagenum, pagesize * pagenum + pagesize);\n    } else {\n      paged = filteredItems;\n    }\n    return { totalRows: filteredItems.length, rows: paged };\n  }\n\n  function getRowDiffs(rows, newRows) {\n    var item,\n        r,\n        eitherIsNonData,\n        diff = [];\n    var from = 0,\n        to = newRows.length;\n\n    if (refreshHints && refreshHints.ignoreDiffsBefore) {\n      from = Math.max(0, Math.min(newRows.length, refreshHints.ignoreDiffsBefore));\n    }\n\n    if (refreshHints && refreshHints.ignoreDiffsAfter) {\n      to = Math.min(newRows.length, Math.max(0, refreshHints.ignoreDiffsAfter));\n    }\n\n    for (var i = from, rl = rows.length; i < to; i++) {\n      if (i >= rl) {\n        diff[diff.length] = i;\n      } else {\n        item = newRows[i];\n        r = rows[i];\n\n        if (groupingInfos.length && (eitherIsNonData = item.__nonDataRow || r.__nonDataRow) && item.__group !== r.__group || item.__group && !item.equals(r) || eitherIsNonData && (\n        // no good way to compare totals since they are arbitrary DTOs\n        // deep object comparison is pretty expensive\n        // always considering them 'dirty' seems easier for the time being\n        item.__groupTotals || r.__groupTotals) || item[idProperty] != r[idProperty] || updated && updated[item[idProperty]]) {\n          diff[diff.length] = i;\n        }\n      }\n    }\n    return diff;\n  }\n\n  function recalc(_items) {\n    rowsById = null;\n\n    if (refreshHints.isFilterNarrowing != prevRefreshHints.isFilterNarrowing || refreshHints.isFilterExpanding != prevRefreshHints.isFilterExpanding) {\n      filterCache = [];\n    }\n\n    var filteredItems = getFilteredAndPagedItems(_items);\n    totalRows = filteredItems.totalRows;\n    var newRows = filteredItems.rows;\n\n    groups = [];\n    if (groupingInfos.length) {\n      groups = extractGroups(newRows);\n      if (groups.length) {\n        addTotals(groups);\n        newRows = flattenGroupedRows(groups);\n      }\n    }\n\n    var diff = getRowDiffs(rows, newRows);\n\n    rows = newRows;\n\n    return diff;\n  }\n\n  function refresh() {\n    if (suspend) {\n      return;\n    }\n\n    var countBefore = rows.length;\n    var totalRowsBefore = totalRows;\n\n    var diff = recalc(items, filter); // pass as direct refs to avoid closure perf hit\n\n    // if the current page is no longer valid, go to last page and recalc\n    // we suffer a performance penalty here, but the main loop (recalc) remains highly optimized\n    if (pagesize && totalRows < pagenum * pagesize) {\n      pagenum = Math.max(0, Math.ceil(totalRows / pagesize) - 1);\n      diff = recalc(items, filter);\n    }\n\n    updated = null;\n    prevRefreshHints = refreshHints;\n    refreshHints = {};\n\n    if (totalRowsBefore !== totalRows) {\n      onPagingInfoChanged.notify(getPagingInfo(), null, self);\n    }\n    if (countBefore !== rows.length) {\n      onRowCountChanged.notify({ previous: countBefore, current: rows.length, dataView: self }, null, self);\n    }\n    if (diff.length > 0) {\n      onRowsChanged.notify({ rows: diff, dataView: self }, null, self);\n    }\n  }\n\n  /***\r\n   * Wires the grid and the DataView together to keep row selection tied to item ids.\r\n   * This is useful since, without it, the grid only knows about rows, so if the items\r\n   * move around, the same rows stay selected instead of the selection moving along\r\n   * with the items.\r\n   *\r\n   * NOTE:  This doesn't work with cell selection model.\r\n   *\r\n   * @param grid {Slick.Grid} The grid to sync selection with.\r\n   * @param preserveHidden {Boolean} Whether to keep selected items that go out of the\r\n   *     view due to them getting filtered out.\r\n   * @param preserveHiddenOnSelectionChange {Boolean} Whether to keep selected items\r\n   *     that are currently out of the view (see preserveHidden) as selected when selection\r\n   *     changes.\r\n   * @return {Slick.Event} An event that notifies when an internal list of selected row ids\r\n   *     changes.  This is useful since, in combination with the above two options, it allows\r\n   *     access to the full list selected row ids, and not just the ones visible to the grid.\r\n   * @method syncGridSelection\r\n   */\n  function syncGridSelection(grid, preserveHidden, preserveHiddenOnSelectionChange) {\n    var self = this;\n    var inHandler;\n    var selectedRowIds = self.mapRowsToIds(grid.getSelectedRows());\n    var onSelectedRowIdsChanged = new _slickGrid.Slick.Event();\n\n    function setSelectedRowIds(rowIds) {\n      if (selectedRowIds.join(\",\") == rowIds.join(\",\")) {\n        return;\n      }\n\n      selectedRowIds = rowIds;\n\n      onSelectedRowIdsChanged.notify({\n        \"grid\": grid,\n        \"ids\": selectedRowIds,\n        \"dataView\": self\n      }, new _slickGrid.Slick.EventData(), self);\n    }\n\n    function update() {\n      if (selectedRowIds.length > 0) {\n        inHandler = true;\n        var selectedRows = self.mapIdsToRows(selectedRowIds);\n        if (!preserveHidden) {\n          setSelectedRowIds(self.mapRowsToIds(selectedRows));\n        }\n        grid.setSelectedRows(selectedRows);\n        inHandler = false;\n      }\n    }\n\n    grid.onSelectedRowsChanged.subscribe(function (e, args) {\n      if (inHandler) {\n        return;\n      }\n      var newSelectedRowIds = self.mapRowsToIds(grid.getSelectedRows());\n      if (!preserveHiddenOnSelectionChange || !grid.getOptions().multiSelect) {\n        setSelectedRowIds(newSelectedRowIds);\n      } else {\n        // keep the ones that are hidden\n        var existing = $.grep(selectedRowIds, function (id) {\n          return self.getRowById(id) === undefined;\n        });\n        // add the newly selected ones\n        setSelectedRowIds(existing.concat(newSelectedRowIds));\n      }\n    });\n\n    this.onRowsChanged.subscribe(update);\n\n    this.onRowCountChanged.subscribe(update);\n\n    return onSelectedRowIdsChanged;\n  }\n\n  function syncGridCellCssStyles(grid, key) {\n    var hashById;\n    var inHandler;\n\n    // since this method can be called after the cell styles have been set,\n    // get the existing ones right away\n    storeCellCssStyles(grid.getCellCssStyles(key));\n\n    function storeCellCssStyles(hash) {\n      hashById = {};\n      for (var row in hash) {\n        var id = rows[row][idProperty];\n        hashById[id] = hash[row];\n      }\n    }\n\n    function update() {\n      if (hashById) {\n        inHandler = true;\n        ensureRowsByIdCache();\n        var newHash = {};\n        for (var id in hashById) {\n          var row = rowsById[id];\n          if (row != undefined) {\n            newHash[row] = hashById[id];\n          }\n        }\n        grid.setCellCssStyles(key, newHash);\n        inHandler = false;\n      }\n    }\n\n    grid.onCellCssStylesChanged.subscribe(function (e, args) {\n      if (inHandler) {\n        return;\n      }\n      if (key != args.key) {\n        return;\n      }\n      if (args.hash) {\n        storeCellCssStyles(args.hash);\n      } else {\n        grid.onCellCssStylesChanged.unsubscribe(styleChanged);\n        self.onRowsChanged.unsubscribe(update);\n        self.onRowCountChanged.unsubscribe(update);\n      }\n    });\n\n    this.onRowsChanged.subscribe(update);\n\n    this.onRowCountChanged.subscribe(update);\n  }\n\n  $.extend(this, {\n    // methods\n    \"beginUpdate\": beginUpdate,\n    \"endUpdate\": endUpdate,\n    \"setPagingOptions\": setPagingOptions,\n    \"getPagingInfo\": getPagingInfo,\n    \"getItems\": getItems,\n    \"setItems\": setItems,\n    \"setFilter\": setFilter,\n    \"getFilter\": getFilter,\n    \"getFilteredItems\": getFilteredItems,\n    \"sort\": sort,\n    \"fastSort\": fastSort,\n    \"reSort\": reSort,\n    \"setGrouping\": setGrouping,\n    \"getGrouping\": getGrouping,\n    \"groupBy\": groupBy,\n    \"setAggregators\": setAggregators,\n    \"collapseAllGroups\": collapseAllGroups,\n    \"expandAllGroups\": expandAllGroups,\n    \"collapseGroup\": collapseGroup,\n    \"expandGroup\": expandGroup,\n    \"getGroups\": getGroups,\n    \"getIdxById\": getIdxById,\n    \"getRowByItem\": getRowByItem,\n    \"getRowById\": getRowById,\n    \"getItemById\": getItemById,\n    \"getItemByIdx\": getItemByIdx,\n    \"mapItemsToRows\": mapItemsToRows,\n    \"mapRowsToIds\": mapRowsToIds,\n    \"mapIdsToRows\": mapIdsToRows,\n    \"setRefreshHints\": setRefreshHints,\n    \"setFilterArgs\": setFilterArgs,\n    \"refresh\": refresh,\n    \"updateItem\": updateItem,\n    \"insertItem\": insertItem,\n    \"addItem\": addItem,\n    \"deleteItem\": deleteItem,\n    \"sortedAddItem\": sortedAddItem,\n    \"sortedUpdateItem\": sortedUpdateItem,\n    \"syncGridSelection\": syncGridSelection,\n    \"syncGridCellCssStyles\": syncGridCellCssStyles,\n\n    // data provider methods\n    \"getLength\": getLength,\n    \"getItem\": getItem,\n    \"getItemMetadata\": getItemMetadata,\n\n    // events\n    \"onRowCountChanged\": onRowCountChanged,\n    \"onRowsChanged\": onRowsChanged,\n    \"onPagingInfoChanged\": onPagingInfoChanged\n  });\n}\n\nfunction AvgAggregator(field) {\n  this.field_ = field;\n\n  this.init = function () {\n    this.count_ = 0;\n    this.nonNullCount_ = 0;\n    this.sum_ = 0;\n  };\n\n  this.accumulate = function (item) {\n    var val = item[this.field_];\n    this.count_++;\n    if (val != null && val !== \"\" && !isNaN(val)) {\n      this.nonNullCount_++;\n      this.sum_ += parseFloat(val);\n    }\n  };\n\n  this.storeResult = function (groupTotals) {\n    if (!groupTotals.avg) {\n      groupTotals.avg = {};\n    }\n    if (this.nonNullCount_ != 0) {\n      groupTotals.avg[this.field_] = this.sum_ / this.nonNullCount_;\n    }\n  };\n}\n\nfunction MinAggregator(field) {\n  this.field_ = field;\n\n  this.init = function () {\n    this.min_ = null;\n  };\n\n  this.accumulate = function (item) {\n    var val = item[this.field_];\n    if (val != null && val !== \"\" && !isNaN(val)) {\n      if (this.min_ == null || val < this.min_) {\n        this.min_ = val;\n      }\n    }\n  };\n\n  this.storeResult = function (groupTotals) {\n    if (!groupTotals.min) {\n      groupTotals.min = {};\n    }\n    groupTotals.min[this.field_] = this.min_;\n  };\n}\n\nfunction MaxAggregator(field) {\n  this.field_ = field;\n\n  this.init = function () {\n    this.max_ = null;\n  };\n\n  this.accumulate = function (item) {\n    var val = item[this.field_];\n    if (val != null && val !== \"\" && !isNaN(val)) {\n      if (this.max_ == null || val > this.max_) {\n        this.max_ = val;\n      }\n    }\n  };\n\n  this.storeResult = function (groupTotals) {\n    if (!groupTotals.max) {\n      groupTotals.max = {};\n    }\n    groupTotals.max[this.field_] = this.max_;\n  };\n}\n\nfunction SumAggregator(field) {\n  this.field_ = field;\n\n  this.init = function () {\n    this.sum_ = null;\n  };\n\n  this.accumulate = function (item) {\n    var val = item[this.field_];\n    if (val != null && val !== \"\" && !isNaN(val)) {\n      this.sum_ += parseFloat(val);\n    }\n  };\n\n  this.storeResult = function (groupTotals) {\n    if (!groupTotals.sum) {\n      groupTotals.sum = {};\n    }\n    groupTotals.sum[this.field_] = this.sum_;\n  };\n}\n\n// TODO:  add more built-in aggregators\n// TODO:  merge common aggregators in one to prevent needles iterating\nvar Aggregators = {\n  Avg: AvgAggregator,\n  Min: MinAggregator,\n  Max: MaxAggregator,\n  Sum: SumAggregator\n};\n\nexports.DataView = DataView;\nexports.Aggregators = Aggregators;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdmVuZG9yL3NsaWNrLmRhdGF2aWV3LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3NyYy92ZW5kb3Ivc2xpY2suZGF0YXZpZXcuanM/YTYzOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1NsaWNrfSBmcm9tIFwiLi9zbGljay5ncmlkLmpzXCI7XHJcbiAgXHJcbiAgICBcclxuICAgIFxyXG5cclxuXHJcbiAgLyoqKlxyXG4gICAqIEEgc2FtcGxlIE1vZGVsIGltcGxlbWVudGF0aW9uLlxyXG4gICAqIFByb3ZpZGVzIGEgZmlsdGVyZWQgdmlldyBvZiB0aGUgdW5kZXJseWluZyBkYXRhLlxyXG4gICAqXHJcbiAgICogUmVsaWVzIG9uIHRoZSBkYXRhIGl0ZW0gaGF2aW5nIGFuIFwiaWRcIiBwcm9wZXJ0eSB1bmlxdWVseSBpZGVudGlmeWluZyBpdC5cclxuICAgKi9cclxuICBmdW5jdGlvbiBEYXRhVmlldyhvcHRpb25zKSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgdmFyIGRlZmF1bHRzID0ge1xyXG4gICAgICBncm91cEl0ZW1NZXRhZGF0YVByb3ZpZGVyOiBudWxsLFxyXG4gICAgICBpbmxpbmVGaWx0ZXJzOiBmYWxzZVxyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLy8gcHJpdmF0ZVxyXG4gICAgdmFyIGlkUHJvcGVydHkgPSBcImlkXCI7ICAvLyBwcm9wZXJ0eSBob2xkaW5nIGEgdW5pcXVlIHJvdyBpZFxyXG4gICAgdmFyIGl0ZW1zID0gW107ICAgICAgICAgLy8gZGF0YSBieSBpbmRleFxyXG4gICAgdmFyIHJvd3MgPSBbXTsgICAgICAgICAgLy8gZGF0YSBieSByb3dcclxuICAgIHZhciBpZHhCeUlkID0ge307ICAgICAgIC8vIGluZGV4ZXMgYnkgaWRcclxuICAgIHZhciByb3dzQnlJZCA9IG51bGw7ICAgIC8vIHJvd3MgYnkgaWQ7IGxhenktY2FsY3VsYXRlZFxyXG4gICAgdmFyIGZpbHRlciA9IG51bGw7ICAgICAgLy8gZmlsdGVyIGZ1bmN0aW9uXHJcbiAgICB2YXIgdXBkYXRlZCA9IG51bGw7ICAgICAvLyB1cGRhdGVkIGl0ZW0gaWRzXHJcbiAgICB2YXIgc3VzcGVuZCA9IGZhbHNlOyAgICAvLyBzdXNwZW5kcyB0aGUgcmVjYWxjdWxhdGlvblxyXG4gICAgdmFyIHNvcnRBc2MgPSB0cnVlO1xyXG4gICAgdmFyIGZhc3RTb3J0RmllbGQ7XHJcbiAgICB2YXIgc29ydENvbXBhcmVyO1xyXG4gICAgdmFyIHJlZnJlc2hIaW50cyA9IHt9O1xyXG4gICAgdmFyIHByZXZSZWZyZXNoSGludHMgPSB7fTtcclxuICAgIHZhciBmaWx0ZXJBcmdzO1xyXG4gICAgdmFyIGZpbHRlcmVkSXRlbXMgPSBbXTtcclxuICAgIHZhciBjb21waWxlZEZpbHRlcjtcclxuICAgIHZhciBjb21waWxlZEZpbHRlcldpdGhDYWNoaW5nO1xyXG4gICAgdmFyIGZpbHRlckNhY2hlID0gW107XHJcblxyXG4gICAgLy8gZ3JvdXBpbmdcclxuICAgIHZhciBncm91cGluZ0luZm9EZWZhdWx0cyA9IHtcclxuICAgICAgZ2V0dGVyOiBudWxsLFxyXG4gICAgICBmb3JtYXR0ZXI6IG51bGwsXHJcbiAgICAgIGNvbXBhcmVyOiBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIChhLnZhbHVlID09PSBiLnZhbHVlID8gMCA6XHJcbiAgICAgICAgICAoYS52YWx1ZSA+IGIudmFsdWUgPyAxIDogLTEpXHJcbiAgICAgICAgKTtcclxuICAgICAgfSxcclxuICAgICAgcHJlZGVmaW5lZFZhbHVlczogW10sXHJcbiAgICAgIGFnZ3JlZ2F0b3JzOiBbXSxcclxuICAgICAgYWdncmVnYXRlRW1wdHk6IGZhbHNlLFxyXG4gICAgICBhZ2dyZWdhdGVDb2xsYXBzZWQ6IGZhbHNlLFxyXG4gICAgICBhZ2dyZWdhdGVDaGlsZEdyb3VwczogZmFsc2UsXHJcbiAgICAgIGNvbGxhcHNlZDogZmFsc2UsXHJcbiAgICAgIGRpc3BsYXlUb3RhbHNSb3c6IHRydWUsXHJcbiAgICAgIGxhenlUb3RhbHNDYWxjdWxhdGlvbjogZmFsc2VcclxuICAgIH07XHJcbiAgICB2YXIgZ3JvdXBpbmdJbmZvcyA9IFtdO1xyXG4gICAgdmFyIGdyb3VwcyA9IFtdO1xyXG4gICAgdmFyIHRvZ2dsZWRHcm91cHNCeUxldmVsID0gW107XHJcbiAgICB2YXIgZ3JvdXBpbmdEZWxpbWl0ZXIgPSAnOnw6JztcclxuXHJcbiAgICB2YXIgcGFnZXNpemUgPSAwO1xyXG4gICAgdmFyIHBhZ2VudW0gPSAwO1xyXG4gICAgdmFyIHRvdGFsUm93cyA9IDA7XHJcblxyXG4gICAgLy8gZXZlbnRzXHJcbiAgICB2YXIgb25Sb3dDb3VudENoYW5nZWQgPSBuZXcgU2xpY2suRXZlbnQoKTtcclxuICAgIHZhciBvblJvd3NDaGFuZ2VkID0gbmV3IFNsaWNrLkV2ZW50KCk7XHJcbiAgICB2YXIgb25QYWdpbmdJbmZvQ2hhbmdlZCA9IG5ldyBTbGljay5FdmVudCgpO1xyXG5cclxuICAgIG9wdGlvbnMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBiZWdpblVwZGF0ZSgpIHtcclxuICAgICAgc3VzcGVuZCA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZW5kVXBkYXRlKCkge1xyXG4gICAgICBzdXNwZW5kID0gZmFsc2U7XHJcbiAgICAgIHJlZnJlc2goKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzZXRSZWZyZXNoSGludHMoaGludHMpIHtcclxuICAgICAgcmVmcmVzaEhpbnRzID0gaGludHM7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2V0RmlsdGVyQXJncyhhcmdzKSB7XHJcbiAgICAgIGZpbHRlckFyZ3MgPSBhcmdzO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZUlkeEJ5SWQoc3RhcnRpbmdJbmRleCkge1xyXG4gICAgICBzdGFydGluZ0luZGV4ID0gc3RhcnRpbmdJbmRleCB8fCAwO1xyXG4gICAgICB2YXIgaWQ7XHJcbiAgICAgIGZvciAodmFyIGkgPSBzdGFydGluZ0luZGV4LCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgaWQgPSBpdGVtc1tpXVtpZFByb3BlcnR5XTtcclxuICAgICAgICBpZiAoaWQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRWFjaCBkYXRhIGVsZW1lbnQgbXVzdCBpbXBsZW1lbnQgYSB1bmlxdWUgJ2lkJyBwcm9wZXJ0eVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWR4QnlJZFtpZF0gPSBpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZW5zdXJlSWRVbmlxdWVuZXNzKCkge1xyXG4gICAgICB2YXIgaWQ7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgaWQgPSBpdGVtc1tpXVtpZFByb3BlcnR5XTtcclxuICAgICAgICBpZiAoaWQgPT09IHVuZGVmaW5lZCB8fCBpZHhCeUlkW2lkXSAhPT0gaSkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRWFjaCBkYXRhIGVsZW1lbnQgbXVzdCBpbXBsZW1lbnQgYSB1bmlxdWUgJ2lkJyBwcm9wZXJ0eVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRJdGVtcygpIHtcclxuICAgICAgcmV0dXJuIGl0ZW1zO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNldEl0ZW1zKGRhdGEsIG9iamVjdElkUHJvcGVydHkpIHtcclxuICAgICAgaWYgKG9iamVjdElkUHJvcGVydHkgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGlkUHJvcGVydHkgPSBvYmplY3RJZFByb3BlcnR5O1xyXG4gICAgICB9XHJcbiAgICAgIGl0ZW1zID0gZmlsdGVyZWRJdGVtcyA9IGRhdGE7XHJcbiAgICAgIGlkeEJ5SWQgPSB7fTtcclxuICAgICAgdXBkYXRlSWR4QnlJZCgpO1xyXG4gICAgICBlbnN1cmVJZFVuaXF1ZW5lc3MoKTtcclxuICAgICAgcmVmcmVzaCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNldFBhZ2luZ09wdGlvbnMoYXJncykge1xyXG4gICAgICBpZiAoYXJncy5wYWdlU2l6ZSAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICBwYWdlc2l6ZSA9IGFyZ3MucGFnZVNpemU7XHJcbiAgICAgICAgcGFnZW51bSA9IHBhZ2VzaXplID8gTWF0aC5taW4ocGFnZW51bSwgTWF0aC5tYXgoMCwgTWF0aC5jZWlsKHRvdGFsUm93cyAvIHBhZ2VzaXplKSAtIDEpKSA6IDA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChhcmdzLnBhZ2VOdW0gIT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcGFnZW51bSA9IE1hdGgubWluKGFyZ3MucGFnZU51bSwgTWF0aC5tYXgoMCwgTWF0aC5jZWlsKHRvdGFsUm93cyAvIHBhZ2VzaXplKSAtIDEpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgb25QYWdpbmdJbmZvQ2hhbmdlZC5ub3RpZnkoZ2V0UGFnaW5nSW5mbygpLCBudWxsLCBzZWxmKTtcclxuXHJcbiAgICAgIHJlZnJlc2goKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRQYWdpbmdJbmZvKCkge1xyXG4gICAgICB2YXIgdG90YWxQYWdlcyA9IHBhZ2VzaXplID8gTWF0aC5tYXgoMSwgTWF0aC5jZWlsKHRvdGFsUm93cyAvIHBhZ2VzaXplKSkgOiAxO1xyXG4gICAgICByZXR1cm4ge3BhZ2VTaXplOiBwYWdlc2l6ZSwgcGFnZU51bTogcGFnZW51bSwgdG90YWxSb3dzOiB0b3RhbFJvd3MsIHRvdGFsUGFnZXM6IHRvdGFsUGFnZXMsIGRhdGFWaWV3OiBzZWxmfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzb3J0KGNvbXBhcmVyLCBhc2NlbmRpbmcpIHtcclxuICAgICAgc29ydEFzYyA9IGFzY2VuZGluZztcclxuICAgICAgc29ydENvbXBhcmVyID0gY29tcGFyZXI7XHJcbiAgICAgIGZhc3RTb3J0RmllbGQgPSBudWxsO1xyXG4gICAgICBpZiAoYXNjZW5kaW5nID09PSBmYWxzZSkge1xyXG4gICAgICAgIGl0ZW1zLnJldmVyc2UoKTtcclxuICAgICAgfVxyXG4gICAgICBpdGVtcy5zb3J0KGNvbXBhcmVyKTtcclxuICAgICAgaWYgKGFzY2VuZGluZyA9PT0gZmFsc2UpIHtcclxuICAgICAgICBpdGVtcy5yZXZlcnNlKCk7XHJcbiAgICAgIH1cclxuICAgICAgaWR4QnlJZCA9IHt9O1xyXG4gICAgICB1cGRhdGVJZHhCeUlkKCk7XHJcbiAgICAgIHJlZnJlc2goKTtcclxuICAgIH1cclxuXHJcbiAgICAvKioqXHJcbiAgICAgKiBQcm92aWRlcyBhIHdvcmthcm91bmQgZm9yIHRoZSBleHRyZW1lbHkgc2xvdyBzb3J0aW5nIGluIElFLlxyXG4gICAgICogRG9lcyBhIFtsZXhpY29ncmFwaGljXSBzb3J0IG9uIGEgZ2l2ZSBjb2x1bW4gYnkgdGVtcG9yYXJpbHkgb3ZlcnJpZGluZyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXHJcbiAgICAgKiB0byByZXR1cm4gdGhlIHZhbHVlIG9mIHRoYXQgZmllbGQgYW5kIHRoZW4gZG9pbmcgYSBuYXRpdmUgQXJyYXkuc29ydCgpLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBmYXN0U29ydChmaWVsZCwgYXNjZW5kaW5nKSB7XHJcbiAgICAgIHNvcnRBc2MgPSBhc2NlbmRpbmc7XHJcbiAgICAgIGZhc3RTb3J0RmllbGQgPSBmaWVsZDtcclxuICAgICAgc29ydENvbXBhcmVyID0gbnVsbDtcclxuICAgICAgdmFyIG9sZFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcclxuICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyA9ICh0eXBlb2YgZmllbGQgPT0gXCJmdW5jdGlvblwiKSA/IGZpZWxkIDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzW2ZpZWxkXVxyXG4gICAgICB9O1xyXG4gICAgICAvLyBhbiBleHRyYSByZXZlcnNhbCBmb3IgZGVzY2VuZGluZyBzb3J0IGtlZXBzIHRoZSBzb3J0IHN0YWJsZVxyXG4gICAgICAvLyAoYXNzdW1pbmcgYSBzdGFibGUgbmF0aXZlIHNvcnQgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzbid0IHRydWUgaW4gc29tZSBjYXNlcylcclxuICAgICAgaWYgKGFzY2VuZGluZyA9PT0gZmFsc2UpIHtcclxuICAgICAgICBpdGVtcy5yZXZlcnNlKCk7XHJcbiAgICAgIH1cclxuICAgICAgaXRlbXMuc29ydCgpO1xyXG4gICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nID0gb2xkVG9TdHJpbmc7XHJcbiAgICAgIGlmIChhc2NlbmRpbmcgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgaXRlbXMucmV2ZXJzZSgpO1xyXG4gICAgICB9XHJcbiAgICAgIGlkeEJ5SWQgPSB7fTtcclxuICAgICAgdXBkYXRlSWR4QnlJZCgpO1xyXG4gICAgICByZWZyZXNoKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVTb3J0KCkge1xyXG4gICAgICBpZiAoc29ydENvbXBhcmVyKSB7XHJcbiAgICAgICAgc29ydChzb3J0Q29tcGFyZXIsIHNvcnRBc2MpO1xyXG4gICAgICB9IGVsc2UgaWYgKGZhc3RTb3J0RmllbGQpIHtcclxuICAgICAgICBmYXN0U29ydChmYXN0U29ydEZpZWxkLCBzb3J0QXNjKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldEZpbHRlcmVkSXRlbXMoKXtcclxuICAgICAgcmV0dXJuIGZpbHRlcmVkSXRlbXM7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGdldEZpbHRlcigpe1xyXG4gICAgICByZXR1cm4gZmlsdGVyO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBzZXRGaWx0ZXIoZmlsdGVyRm4pIHtcclxuICAgICAgZmlsdGVyID0gZmlsdGVyRm47XHJcbiAgICAgIGlmIChvcHRpb25zLmlubGluZUZpbHRlcnMpIHtcclxuICAgICAgICBjb21waWxlZEZpbHRlciA9IGNvbXBpbGVGaWx0ZXIoKTtcclxuICAgICAgICBjb21waWxlZEZpbHRlcldpdGhDYWNoaW5nID0gY29tcGlsZUZpbHRlcldpdGhDYWNoaW5nKCk7XHJcbiAgICAgIH1cclxuICAgICAgcmVmcmVzaCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldEdyb3VwaW5nKCkge1xyXG4gICAgICByZXR1cm4gZ3JvdXBpbmdJbmZvcztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzZXRHcm91cGluZyhncm91cGluZ0luZm8pIHtcclxuICAgICAgaWYgKCFvcHRpb25zLmdyb3VwSXRlbU1ldGFkYXRhUHJvdmlkZXIpIHtcclxuICAgICAgICBvcHRpb25zLmdyb3VwSXRlbU1ldGFkYXRhUHJvdmlkZXIgPSBuZXcgU2xpY2suRGF0YS5Hcm91cEl0ZW1NZXRhZGF0YVByb3ZpZGVyKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGdyb3VwcyA9IFtdO1xyXG4gICAgICB0b2dnbGVkR3JvdXBzQnlMZXZlbCA9IFtdO1xyXG4gICAgICBncm91cGluZ0luZm8gPSBncm91cGluZ0luZm8gfHwgW107XHJcbiAgICAgIGdyb3VwaW5nSW5mb3MgPSAoZ3JvdXBpbmdJbmZvIGluc3RhbmNlb2YgQXJyYXkpID8gZ3JvdXBpbmdJbmZvIDogW2dyb3VwaW5nSW5mb107XHJcblxyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwaW5nSW5mb3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgZ2kgPSBncm91cGluZ0luZm9zW2ldID0gJC5leHRlbmQodHJ1ZSwge30sIGdyb3VwaW5nSW5mb0RlZmF1bHRzLCBncm91cGluZ0luZm9zW2ldKTtcclxuICAgICAgICBnaS5nZXR0ZXJJc0FGbiA9IHR5cGVvZiBnaS5nZXR0ZXIgPT09IFwiZnVuY3Rpb25cIjtcclxuXHJcbiAgICAgICAgLy8gcHJlLWNvbXBpbGUgYWNjdW11bGF0b3IgbG9vcHNcclxuICAgICAgICBnaS5jb21waWxlZEFjY3VtdWxhdG9ycyA9IFtdO1xyXG4gICAgICAgIHZhciBpZHggPSBnaS5hZ2dyZWdhdG9ycy5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKGlkeC0tKSB7XHJcbiAgICAgICAgICBnaS5jb21waWxlZEFjY3VtdWxhdG9yc1tpZHhdID0gY29tcGlsZUFjY3VtdWxhdG9yTG9vcChnaS5hZ2dyZWdhdG9yc1tpZHhdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRvZ2dsZWRHcm91cHNCeUxldmVsW2ldID0ge307XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJlZnJlc2goKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBkZXByZWNhdGVkIFBsZWFzZSB1c2Uge0BsaW5rIHNldEdyb3VwaW5nfS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ3JvdXBCeSh2YWx1ZUdldHRlciwgdmFsdWVGb3JtYXR0ZXIsIHNvcnRDb21wYXJlcikge1xyXG4gICAgICBpZiAodmFsdWVHZXR0ZXIgPT0gbnVsbCkge1xyXG4gICAgICAgIHNldEdyb3VwaW5nKFtdKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHNldEdyb3VwaW5nKHtcclxuICAgICAgICBnZXR0ZXI6IHZhbHVlR2V0dGVyLFxyXG4gICAgICAgIGZvcm1hdHRlcjogdmFsdWVGb3JtYXR0ZXIsXHJcbiAgICAgICAgY29tcGFyZXI6IHNvcnRDb21wYXJlclxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBkZXByZWNhdGVkIFBsZWFzZSB1c2Uge0BsaW5rIHNldEdyb3VwaW5nfS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gc2V0QWdncmVnYXRvcnMoZ3JvdXBBZ2dyZWdhdG9ycywgaW5jbHVkZUNvbGxhcHNlZCkge1xyXG4gICAgICBpZiAoIWdyb3VwaW5nSW5mb3MubGVuZ3RoKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXQgbGVhc3Qgb25lIGdyb3VwaW5nIG11c3QgYmUgc3BlY2lmaWVkIGJlZm9yZSBjYWxsaW5nIHNldEFnZ3JlZ2F0b3JzKCkuXCIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBncm91cGluZ0luZm9zWzBdLmFnZ3JlZ2F0b3JzID0gZ3JvdXBBZ2dyZWdhdG9ycztcclxuICAgICAgZ3JvdXBpbmdJbmZvc1swXS5hZ2dyZWdhdGVDb2xsYXBzZWQgPSBpbmNsdWRlQ29sbGFwc2VkO1xyXG5cclxuICAgICAgc2V0R3JvdXBpbmcoZ3JvdXBpbmdJbmZvcyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0SXRlbUJ5SWR4KGkpIHtcclxuICAgICAgcmV0dXJuIGl0ZW1zW2ldO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldElkeEJ5SWQoaWQpIHtcclxuICAgICAgcmV0dXJuIGlkeEJ5SWRbaWRdO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGVuc3VyZVJvd3NCeUlkQ2FjaGUoKSB7XHJcbiAgICAgIGlmICghcm93c0J5SWQpIHtcclxuICAgICAgICByb3dzQnlJZCA9IHt9O1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcm93cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgIHJvd3NCeUlkW3Jvd3NbaV1baWRQcm9wZXJ0eV1dID0gaTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRSb3dCeUl0ZW0oaXRlbSkge1xyXG4gICAgICBlbnN1cmVSb3dzQnlJZENhY2hlKCk7XHJcbiAgICAgIHJldHVybiByb3dzQnlJZFtpdGVtW2lkUHJvcGVydHldXTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRSb3dCeUlkKGlkKSB7XHJcbiAgICAgIGVuc3VyZVJvd3NCeUlkQ2FjaGUoKTtcclxuICAgICAgcmV0dXJuIHJvd3NCeUlkW2lkXTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRJdGVtQnlJZChpZCkge1xyXG4gICAgICByZXR1cm4gaXRlbXNbaWR4QnlJZFtpZF1dO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1hcEl0ZW1zVG9Sb3dzKGl0ZW1BcnJheSkge1xyXG4gICAgICB2YXIgcm93cyA9IFtdO1xyXG4gICAgICBlbnN1cmVSb3dzQnlJZENhY2hlKCk7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaXRlbUFycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIHZhciByb3cgPSByb3dzQnlJZFtpdGVtQXJyYXlbaV1baWRQcm9wZXJ0eV1dO1xyXG4gICAgICAgIGlmIChyb3cgIT0gbnVsbCkge1xyXG4gICAgICAgICAgcm93c1tyb3dzLmxlbmd0aF0gPSByb3c7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByb3dzO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1hcElkc1RvUm93cyhpZEFycmF5KSB7XHJcbiAgICAgIHZhciByb3dzID0gW107XHJcbiAgICAgIGVuc3VyZVJvd3NCeUlkQ2FjaGUoKTtcclxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBpZEFycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIHZhciByb3cgPSByb3dzQnlJZFtpZEFycmF5W2ldXTtcclxuICAgICAgICBpZiAocm93ICE9IG51bGwpIHtcclxuICAgICAgICAgIHJvd3Nbcm93cy5sZW5ndGhdID0gcm93O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcm93cztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBtYXBSb3dzVG9JZHMocm93QXJyYXkpIHtcclxuICAgICAgdmFyIGlkcyA9IFtdO1xyXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHJvd0FycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGlmIChyb3dBcnJheVtpXSA8IHJvd3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICBpZHNbaWRzLmxlbmd0aF0gPSByb3dzW3Jvd0FycmF5W2ldXVtpZFByb3BlcnR5XTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGlkcztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB1cGRhdGVJdGVtKGlkLCBpdGVtKSB7XHJcbiAgICAgIGlmIChpZHhCeUlkW2lkXSA9PT0gdW5kZWZpbmVkIHx8IGlkICE9PSBpdGVtW2lkUHJvcGVydHldKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBvciBub24tbWF0Y2hpbmcgaWRcIik7XHJcbiAgICAgIH1cclxuICAgICAgaXRlbXNbaWR4QnlJZFtpZF1dID0gaXRlbTtcclxuICAgICAgaWYgKCF1cGRhdGVkKSB7XHJcbiAgICAgICAgdXBkYXRlZCA9IHt9O1xyXG4gICAgICB9XHJcbiAgICAgIHVwZGF0ZWRbaWRdID0gdHJ1ZTtcclxuICAgICAgcmVmcmVzaCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGluc2VydEl0ZW0oaW5zZXJ0QmVmb3JlLCBpdGVtKSB7XHJcbiAgICAgIGl0ZW1zLnNwbGljZShpbnNlcnRCZWZvcmUsIDAsIGl0ZW0pO1xyXG4gICAgICB1cGRhdGVJZHhCeUlkKGluc2VydEJlZm9yZSk7XHJcbiAgICAgIHJlZnJlc2goKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhZGRJdGVtKGl0ZW0pIHtcclxuICAgICAgaXRlbXMucHVzaChpdGVtKTtcclxuICAgICAgdXBkYXRlSWR4QnlJZChpdGVtcy5sZW5ndGggLSAxKTtcclxuICAgICAgcmVmcmVzaCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRlbGV0ZUl0ZW0oaWQpIHtcclxuICAgICAgdmFyIGlkeCA9IGlkeEJ5SWRbaWRdO1xyXG4gICAgICBpZiAoaWR4ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlkXCIpO1xyXG4gICAgICB9XHJcbiAgICAgIGRlbGV0ZSBpZHhCeUlkW2lkXTtcclxuICAgICAgaXRlbXMuc3BsaWNlKGlkeCwgMSk7XHJcbiAgICAgIHVwZGF0ZUlkeEJ5SWQoaWR4KTtcclxuICAgICAgcmVmcmVzaCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNvcnRlZEFkZEl0ZW0oaXRlbSkge1xyXG4gICAgICBpZighc29ydENvbXBhcmVyKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic29ydGVkQWRkSXRlbSgpIHJlcXVpcmVzIGEgc29ydCBjb21wYXJlciwgdXNlIHNvcnQoKVwiKTtcclxuICAgICAgfVxyXG4gICAgICBpbnNlcnRJdGVtKHNvcnRlZEluZGV4KGl0ZW0pLCBpdGVtKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzb3J0ZWRVcGRhdGVJdGVtKGlkLCBpdGVtKSB7XHJcbiAgICAgIGlmIChpZHhCeUlkW2lkXSA9PT0gdW5kZWZpbmVkIHx8IGlkICE9PSBpdGVtW2lkUHJvcGVydHldKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBvciBub24tbWF0Y2hpbmcgaWQgXCIgKyBpZHhCeUlkW2lkXSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYoIXNvcnRDb21wYXJlcikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInNvcnRlZFVwZGF0ZUl0ZW0oKSByZXF1aXJlcyBhIHNvcnQgY29tcGFyZXIsIHVzZSBzb3J0KClcIik7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIG9sZEl0ZW0gPSBnZXRJdGVtQnlJZChpZCk7XHJcbiAgICAgIGlmKHNvcnRDb21wYXJlcihvbGRJdGVtLCBpdGVtKSAhPT0gMCkge1xyXG4gICAgICAgIC8vIGl0ZW0gYWZmZWN0cyBzb3J0aW5nIC0+IG11c3QgdXNlIHNvcnRlZCBhZGRcclxuICAgICAgICBkZWxldGVJdGVtKGlkKTtcclxuICAgICAgICBzb3J0ZWRBZGRJdGVtKGl0ZW0pO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgeyAvLyB1cGRhdGUgZG9lcyBub3QgYWZmZWN0IHNvcnRpbmcgLT4gcmVndWxhciB1cGRhdGUgd29ya3MgZmluZVxyXG4gICAgICAgIHVwZGF0ZUl0ZW0oaWQsIGl0ZW0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc29ydGVkSW5kZXgoc2VhcmNoSXRlbSkge1xyXG4gICAgICB2YXIgbG93ID0gMCwgaGlnaCA9IGl0ZW1zLmxlbmd0aDtcclxuXHJcbiAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XHJcbiAgICAgICAgdmFyIG1pZCA9IGxvdyArIGhpZ2ggPj4+IDE7XHJcbiAgICAgICAgaWYgKHNvcnRDb21wYXJlcihpdGVtc1ttaWRdLCBzZWFyY2hJdGVtKSA9PT0gLTEpIHtcclxuICAgICAgICAgIGxvdyA9IG1pZCArIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgaGlnaCA9IG1pZDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGxvdztcclxuICAgIH1cclxuICAgICAgXHJcbiAgICBmdW5jdGlvbiBnZXRMZW5ndGgoKSB7XHJcbiAgICAgIHJldHVybiByb3dzLmxlbmd0aDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRJdGVtKGkpIHtcclxuICAgICAgdmFyIGl0ZW0gPSByb3dzW2ldO1xyXG5cclxuICAgICAgLy8gaWYgdGhpcyBpcyBhIGdyb3VwIHJvdywgbWFrZSBzdXJlIHRvdGFscyBhcmUgY2FsY3VsYXRlZCBhbmQgdXBkYXRlIHRoZSB0aXRsZVxyXG4gICAgICBpZiAoaXRlbSAmJiBpdGVtLl9fZ3JvdXAgJiYgaXRlbS50b3RhbHMgJiYgIWl0ZW0udG90YWxzLmluaXRpYWxpemVkKSB7XHJcbiAgICAgICAgdmFyIGdpID0gZ3JvdXBpbmdJbmZvc1tpdGVtLmxldmVsXTtcclxuICAgICAgICBpZiAoIWdpLmRpc3BsYXlUb3RhbHNSb3cpIHtcclxuICAgICAgICAgIGNhbGN1bGF0ZVRvdGFscyhpdGVtLnRvdGFscyk7XHJcbiAgICAgICAgICBpdGVtLnRpdGxlID0gZ2kuZm9ybWF0dGVyID8gZ2kuZm9ybWF0dGVyKGl0ZW0pIDogaXRlbS52YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgLy8gaWYgdGhpcyBpcyBhIHRvdGFscyByb3csIG1ha2Ugc3VyZSBpdCdzIGNhbGN1bGF0ZWRcclxuICAgICAgZWxzZSBpZiAoaXRlbSAmJiBpdGVtLl9fZ3JvdXBUb3RhbHMgJiYgIWl0ZW0uaW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICBjYWxjdWxhdGVUb3RhbHMoaXRlbSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBpdGVtO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldEl0ZW1NZXRhZGF0YShpKSB7XHJcbiAgICAgIHZhciBpdGVtID0gcm93c1tpXTtcclxuICAgICAgaWYgKGl0ZW0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBvdmVycmlkZXMgZm9yIGdyb3VwaW5nIHJvd3NcclxuICAgICAgaWYgKGl0ZW0uX19ncm91cCkge1xyXG4gICAgICAgIHJldHVybiBvcHRpb25zLmdyb3VwSXRlbU1ldGFkYXRhUHJvdmlkZXIuZ2V0R3JvdXBSb3dNZXRhZGF0YShpdGVtKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gb3ZlcnJpZGVzIGZvciB0b3RhbHMgcm93c1xyXG4gICAgICBpZiAoaXRlbS5fX2dyb3VwVG90YWxzKSB7XHJcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuZ3JvdXBJdGVtTWV0YWRhdGFQcm92aWRlci5nZXRUb3RhbHNSb3dNZXRhZGF0YShpdGVtKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZXhwYW5kQ29sbGFwc2VBbGxHcm91cHMobGV2ZWwsIGNvbGxhcHNlKSB7XHJcbiAgICAgIGlmIChsZXZlbCA9PSBudWxsKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cGluZ0luZm9zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICB0b2dnbGVkR3JvdXBzQnlMZXZlbFtpXSA9IHt9O1xyXG4gICAgICAgICAgZ3JvdXBpbmdJbmZvc1tpXS5jb2xsYXBzZWQgPSBjb2xsYXBzZTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdG9nZ2xlZEdyb3Vwc0J5TGV2ZWxbbGV2ZWxdID0ge307XHJcbiAgICAgICAgZ3JvdXBpbmdJbmZvc1tsZXZlbF0uY29sbGFwc2VkID0gY29sbGFwc2U7XHJcbiAgICAgIH1cclxuICAgICAgcmVmcmVzaCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGxldmVsIHtOdW1iZXJ9IE9wdGlvbmFsIGxldmVsIHRvIGNvbGxhcHNlLiAgSWYgbm90IHNwZWNpZmllZCwgYXBwbGllcyB0byBhbGwgbGV2ZWxzLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjb2xsYXBzZUFsbEdyb3VwcyhsZXZlbCkge1xyXG4gICAgICBleHBhbmRDb2xsYXBzZUFsbEdyb3VwcyhsZXZlbCwgdHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gbGV2ZWwge051bWJlcn0gT3B0aW9uYWwgbGV2ZWwgdG8gZXhwYW5kLiAgSWYgbm90IHNwZWNpZmllZCwgYXBwbGllcyB0byBhbGwgbGV2ZWxzLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBleHBhbmRBbGxHcm91cHMobGV2ZWwpIHtcclxuICAgICAgZXhwYW5kQ29sbGFwc2VBbGxHcm91cHMobGV2ZWwsIGZhbHNlKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBleHBhbmRDb2xsYXBzZUdyb3VwKGxldmVsLCBncm91cGluZ0tleSwgY29sbGFwc2UpIHtcclxuICAgICAgdG9nZ2xlZEdyb3Vwc0J5TGV2ZWxbbGV2ZWxdW2dyb3VwaW5nS2V5XSA9IGdyb3VwaW5nSW5mb3NbbGV2ZWxdLmNvbGxhcHNlZCBeIGNvbGxhcHNlO1xyXG4gICAgICByZWZyZXNoKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gdmFyQXJncyBFaXRoZXIgYSBTbGljay5Hcm91cCdzIFwiZ3JvdXBpbmdLZXlcIiBwcm9wZXJ0eSwgb3IgYVxyXG4gICAgICogICAgIHZhcmlhYmxlIGFyZ3VtZW50IGxpc3Qgb2YgZ3JvdXBpbmcgdmFsdWVzIGRlbm90aW5nIGEgdW5pcXVlIHBhdGggdG8gdGhlIHJvdy4gIEZvclxyXG4gICAgICogICAgIGV4YW1wbGUsIGNhbGxpbmcgY29sbGFwc2VHcm91cCgnaGlnaCcsICcxMCUnKSB3aWxsIGNvbGxhcHNlIHRoZSAnMTAlJyBzdWJncm91cCBvZlxyXG4gICAgICogICAgIHRoZSAnaGlnaCcgZ3JvdXAuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNvbGxhcHNlR3JvdXAodmFyQXJncykge1xyXG4gICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XHJcbiAgICAgIHZhciBhcmcwID0gYXJnc1swXTtcclxuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09IDEgJiYgYXJnMC5pbmRleE9mKGdyb3VwaW5nRGVsaW1pdGVyKSAhPSAtMSkge1xyXG4gICAgICAgIGV4cGFuZENvbGxhcHNlR3JvdXAoYXJnMC5zcGxpdChncm91cGluZ0RlbGltaXRlcikubGVuZ3RoIC0gMSwgYXJnMCwgdHJ1ZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZXhwYW5kQ29sbGFwc2VHcm91cChhcmdzLmxlbmd0aCAtIDEsIGFyZ3Muam9pbihncm91cGluZ0RlbGltaXRlciksIHRydWUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gdmFyQXJncyBFaXRoZXIgYSBTbGljay5Hcm91cCdzIFwiZ3JvdXBpbmdLZXlcIiBwcm9wZXJ0eSwgb3IgYVxyXG4gICAgICogICAgIHZhcmlhYmxlIGFyZ3VtZW50IGxpc3Qgb2YgZ3JvdXBpbmcgdmFsdWVzIGRlbm90aW5nIGEgdW5pcXVlIHBhdGggdG8gdGhlIHJvdy4gIEZvclxyXG4gICAgICogICAgIGV4YW1wbGUsIGNhbGxpbmcgZXhwYW5kR3JvdXAoJ2hpZ2gnLCAnMTAlJykgd2lsbCBleHBhbmQgdGhlICcxMCUnIHN1Ymdyb3VwIG9mXHJcbiAgICAgKiAgICAgdGhlICdoaWdoJyBncm91cC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZXhwYW5kR3JvdXAodmFyQXJncykge1xyXG4gICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XHJcbiAgICAgIHZhciBhcmcwID0gYXJnc1swXTtcclxuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09IDEgJiYgYXJnMC5pbmRleE9mKGdyb3VwaW5nRGVsaW1pdGVyKSAhPSAtMSkge1xyXG4gICAgICAgIGV4cGFuZENvbGxhcHNlR3JvdXAoYXJnMC5zcGxpdChncm91cGluZ0RlbGltaXRlcikubGVuZ3RoIC0gMSwgYXJnMCwgZmFsc2UpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGV4cGFuZENvbGxhcHNlR3JvdXAoYXJncy5sZW5ndGggLSAxLCBhcmdzLmpvaW4oZ3JvdXBpbmdEZWxpbWl0ZXIpLCBmYWxzZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRHcm91cHMoKSB7XHJcbiAgICAgIHJldHVybiBncm91cHM7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZXh0cmFjdEdyb3Vwcyhyb3dzLCBwYXJlbnRHcm91cCkge1xyXG4gICAgICB2YXIgZ3JvdXA7XHJcbiAgICAgIHZhciB2YWw7XHJcbiAgICAgIHZhciBncm91cHMgPSBbXTtcclxuICAgICAgdmFyIGdyb3Vwc0J5VmFsID0ge307XHJcbiAgICAgIHZhciByO1xyXG4gICAgICB2YXIgbGV2ZWwgPSBwYXJlbnRHcm91cCA/IHBhcmVudEdyb3VwLmxldmVsICsgMSA6IDA7XHJcbiAgICAgIHZhciBnaSA9IGdyb3VwaW5nSW5mb3NbbGV2ZWxdO1xyXG5cclxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBnaS5wcmVkZWZpbmVkVmFsdWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIHZhbCA9IGdpLnByZWRlZmluZWRWYWx1ZXNbaV07XHJcbiAgICAgICAgZ3JvdXAgPSBncm91cHNCeVZhbFt2YWxdO1xyXG4gICAgICAgIGlmICghZ3JvdXApIHtcclxuICAgICAgICAgIGdyb3VwID0gbmV3IFNsaWNrLkdyb3VwKCk7XHJcbiAgICAgICAgICBncm91cC52YWx1ZSA9IHZhbDtcclxuICAgICAgICAgIGdyb3VwLmxldmVsID0gbGV2ZWw7XHJcbiAgICAgICAgICBncm91cC5ncm91cGluZ0tleSA9IChwYXJlbnRHcm91cCA/IHBhcmVudEdyb3VwLmdyb3VwaW5nS2V5ICsgZ3JvdXBpbmdEZWxpbWl0ZXIgOiAnJykgKyB2YWw7XHJcbiAgICAgICAgICBncm91cHNbZ3JvdXBzLmxlbmd0aF0gPSBncm91cDtcclxuICAgICAgICAgIGdyb3Vwc0J5VmFsW3ZhbF0gPSBncm91cDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcm93cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICByID0gcm93c1tpXTtcclxuICAgICAgICB2YWwgPSBnaS5nZXR0ZXJJc0FGbiA/IGdpLmdldHRlcihyKSA6IHJbZ2kuZ2V0dGVyXTtcclxuICAgICAgICBncm91cCA9IGdyb3Vwc0J5VmFsW3ZhbF07XHJcbiAgICAgICAgaWYgKCFncm91cCkge1xyXG4gICAgICAgICAgZ3JvdXAgPSBuZXcgU2xpY2suR3JvdXAoKTtcclxuICAgICAgICAgIGdyb3VwLnZhbHVlID0gdmFsO1xyXG4gICAgICAgICAgZ3JvdXAubGV2ZWwgPSBsZXZlbDtcclxuICAgICAgICAgIGdyb3VwLmdyb3VwaW5nS2V5ID0gKHBhcmVudEdyb3VwID8gcGFyZW50R3JvdXAuZ3JvdXBpbmdLZXkgKyBncm91cGluZ0RlbGltaXRlciA6ICcnKSArIHZhbDtcclxuICAgICAgICAgIGdyb3Vwc1tncm91cHMubGVuZ3RoXSA9IGdyb3VwO1xyXG4gICAgICAgICAgZ3JvdXBzQnlWYWxbdmFsXSA9IGdyb3VwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZ3JvdXAucm93c1tncm91cC5jb3VudCsrXSA9IHI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChsZXZlbCA8IGdyb3VwaW5nSW5mb3MubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBncm91cCA9IGdyb3Vwc1tpXTtcclxuICAgICAgICAgIGdyb3VwLmdyb3VwcyA9IGV4dHJhY3RHcm91cHMoZ3JvdXAucm93cywgZ3JvdXApO1xyXG4gICAgICAgIH1cclxuICAgICAgfSAgICAgIFxyXG5cclxuICAgICAgZ3JvdXBzLnNvcnQoZ3JvdXBpbmdJbmZvc1tsZXZlbF0uY29tcGFyZXIpO1xyXG5cclxuICAgICAgcmV0dXJuIGdyb3VwcztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjYWxjdWxhdGVUb3RhbHModG90YWxzKSB7XHJcbiAgICAgIHZhciBncm91cCA9IHRvdGFscy5ncm91cDtcclxuICAgICAgdmFyIGdpID0gZ3JvdXBpbmdJbmZvc1tncm91cC5sZXZlbF07XHJcbiAgICAgIHZhciBpc0xlYWZMZXZlbCA9IChncm91cC5sZXZlbCA9PSBncm91cGluZ0luZm9zLmxlbmd0aCk7XHJcbiAgICAgIHZhciBhZ2csIGlkeCA9IGdpLmFnZ3JlZ2F0b3JzLmxlbmd0aDtcclxuXHJcbiAgICAgIGlmICghaXNMZWFmTGV2ZWwgJiYgZ2kuYWdncmVnYXRlQ2hpbGRHcm91cHMpIHtcclxuICAgICAgICAvLyBtYWtlIHN1cmUgYWxsIHRoZSBzdWJncm91cHMgYXJlIGNhbGN1bGF0ZWRcclxuICAgICAgICB2YXIgaSA9IGdyb3VwLmdyb3Vwcy5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgaWYgKCFncm91cC5ncm91cHNbaV0udG90YWxzLmluaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICAgIGNhbGN1bGF0ZVRvdGFscyhncm91cC5ncm91cHNbaV0udG90YWxzKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHdoaWxlIChpZHgtLSkge1xyXG4gICAgICAgIGFnZyA9IGdpLmFnZ3JlZ2F0b3JzW2lkeF07XHJcbiAgICAgICAgYWdnLmluaXQoKTtcclxuICAgICAgICBpZiAoIWlzTGVhZkxldmVsICYmIGdpLmFnZ3JlZ2F0ZUNoaWxkR3JvdXBzKSB7XHJcbiAgICAgICAgICBnaS5jb21waWxlZEFjY3VtdWxhdG9yc1tpZHhdLmNhbGwoYWdnLCBncm91cC5ncm91cHMpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBnaS5jb21waWxlZEFjY3VtdWxhdG9yc1tpZHhdLmNhbGwoYWdnLCBncm91cC5yb3dzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYWdnLnN0b3JlUmVzdWx0KHRvdGFscyk7XHJcbiAgICAgIH1cclxuICAgICAgdG90YWxzLmluaXRpYWxpemVkID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhZGRHcm91cFRvdGFscyhncm91cCkge1xyXG4gICAgICB2YXIgZ2kgPSBncm91cGluZ0luZm9zW2dyb3VwLmxldmVsXTtcclxuICAgICAgdmFyIHRvdGFscyA9IG5ldyBTbGljay5Hcm91cFRvdGFscygpO1xyXG4gICAgICB0b3RhbHMuZ3JvdXAgPSBncm91cDtcclxuICAgICAgZ3JvdXAudG90YWxzID0gdG90YWxzO1xyXG4gICAgICBpZiAoIWdpLmxhenlUb3RhbHNDYWxjdWxhdGlvbikge1xyXG4gICAgICAgIGNhbGN1bGF0ZVRvdGFscyh0b3RhbHMpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYWRkVG90YWxzKGdyb3VwcywgbGV2ZWwpIHtcclxuICAgICAgbGV2ZWwgPSBsZXZlbCB8fCAwO1xyXG4gICAgICB2YXIgZ2kgPSBncm91cGluZ0luZm9zW2xldmVsXTtcclxuICAgICAgdmFyIGdyb3VwQ29sbGFwc2VkID0gZ2kuY29sbGFwc2VkO1xyXG4gICAgICB2YXIgdG9nZ2xlZEdyb3VwcyA9IHRvZ2dsZWRHcm91cHNCeUxldmVsW2xldmVsXTsgICAgICBcclxuICAgICAgdmFyIGlkeCA9IGdyb3Vwcy5sZW5ndGgsIGc7XHJcbiAgICAgIHdoaWxlIChpZHgtLSkge1xyXG4gICAgICAgIGcgPSBncm91cHNbaWR4XTtcclxuXHJcbiAgICAgICAgaWYgKGcuY29sbGFwc2VkICYmICFnaS5hZ2dyZWdhdGVDb2xsYXBzZWQpIHtcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRG8gYSBkZXB0aC1maXJzdCBhZ2dyZWdhdGlvbiBzbyB0aGF0IHBhcmVudCBncm91cCBhZ2dyZWdhdG9ycyBjYW4gYWNjZXNzIHN1Ymdyb3VwIHRvdGFscy5cclxuICAgICAgICBpZiAoZy5ncm91cHMpIHtcclxuICAgICAgICAgIGFkZFRvdGFscyhnLmdyb3VwcywgbGV2ZWwgKyAxKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChnaS5hZ2dyZWdhdG9ycy5sZW5ndGggJiYgKFxyXG4gICAgICAgICAgICBnaS5hZ2dyZWdhdGVFbXB0eSB8fCBnLnJvd3MubGVuZ3RoIHx8IChnLmdyb3VwcyAmJiBnLmdyb3Vwcy5sZW5ndGgpKSkge1xyXG4gICAgICAgICAgYWRkR3JvdXBUb3RhbHMoZyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBnLmNvbGxhcHNlZCA9IGdyb3VwQ29sbGFwc2VkIF4gdG9nZ2xlZEdyb3Vwc1tnLmdyb3VwaW5nS2V5XTtcclxuICAgICAgICBnLnRpdGxlID0gZ2kuZm9ybWF0dGVyID8gZ2kuZm9ybWF0dGVyKGcpIDogZy52YWx1ZTtcclxuICAgICAgfVxyXG4gICAgfSBcclxuXHJcbiAgICBmdW5jdGlvbiBmbGF0dGVuR3JvdXBlZFJvd3MoZ3JvdXBzLCBsZXZlbCkge1xyXG4gICAgICBsZXZlbCA9IGxldmVsIHx8IDA7XHJcbiAgICAgIHZhciBnaSA9IGdyb3VwaW5nSW5mb3NbbGV2ZWxdO1xyXG4gICAgICB2YXIgZ3JvdXBlZFJvd3MgPSBbXSwgcm93cywgZ2wgPSAwLCBnO1xyXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBnID0gZ3JvdXBzW2ldO1xyXG4gICAgICAgIGdyb3VwZWRSb3dzW2dsKytdID0gZztcclxuXHJcbiAgICAgICAgaWYgKCFnLmNvbGxhcHNlZCkge1xyXG4gICAgICAgICAgcm93cyA9IGcuZ3JvdXBzID8gZmxhdHRlbkdyb3VwZWRSb3dzKGcuZ3JvdXBzLCBsZXZlbCArIDEpIDogZy5yb3dzO1xyXG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpqID0gcm93cy5sZW5ndGg7IGogPCBqajsgaisrKSB7XHJcbiAgICAgICAgICAgIGdyb3VwZWRSb3dzW2dsKytdID0gcm93c1tqXTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChnLnRvdGFscyAmJiBnaS5kaXNwbGF5VG90YWxzUm93ICYmICghZy5jb2xsYXBzZWQgfHwgZ2kuYWdncmVnYXRlQ29sbGFwc2VkKSkge1xyXG4gICAgICAgICAgZ3JvdXBlZFJvd3NbZ2wrK10gPSBnLnRvdGFscztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGdyb3VwZWRSb3dzO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldEZ1bmN0aW9uSW5mbyhmbikge1xyXG4gICAgICB2YXIgZm5SZWdleCA9IC9eZnVuY3Rpb25bXihdKlxcKChbXildKilcXClcXHMqeyhbXFxzXFxTXSopfSQvO1xyXG4gICAgICB2YXIgbWF0Y2hlcyA9IGZuLnRvU3RyaW5nKCkubWF0Y2goZm5SZWdleCk7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgcGFyYW1zOiBtYXRjaGVzWzFdLnNwbGl0KFwiLFwiKSxcclxuICAgICAgICBib2R5OiBtYXRjaGVzWzJdXHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY29tcGlsZUFjY3VtdWxhdG9yTG9vcChhZ2dyZWdhdG9yKSB7XHJcbiAgICAgIHZhciBhY2N1bXVsYXRvckluZm8gPSBnZXRGdW5jdGlvbkluZm8oYWdncmVnYXRvci5hY2N1bXVsYXRlKTtcclxuICAgICAgdmFyIGZuID0gbmV3IEZ1bmN0aW9uKFxyXG4gICAgICAgICAgXCJfaXRlbXNcIixcclxuICAgICAgICAgIFwiZm9yICh2YXIgXCIgKyBhY2N1bXVsYXRvckluZm8ucGFyYW1zWzBdICsgXCIsIF9pPTAsIF9pbD1faXRlbXMubGVuZ3RoOyBfaTxfaWw7IF9pKyspIHtcIiArXHJcbiAgICAgICAgICAgICAgYWNjdW11bGF0b3JJbmZvLnBhcmFtc1swXSArIFwiID0gX2l0ZW1zW19pXTsgXCIgK1xyXG4gICAgICAgICAgICAgIGFjY3VtdWxhdG9ySW5mby5ib2R5ICtcclxuICAgICAgICAgIFwifVwiXHJcbiAgICAgICk7XHJcbiAgICAgIGZuLmRpc3BsYXlOYW1lID0gZm4ubmFtZSA9IFwiY29tcGlsZWRBY2N1bXVsYXRvckxvb3BcIjtcclxuICAgICAgcmV0dXJuIGZuO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbXBpbGVGaWx0ZXIoKSB7XHJcbiAgICAgIHZhciBmaWx0ZXJJbmZvID0gZ2V0RnVuY3Rpb25JbmZvKGZpbHRlcik7XHJcblxyXG4gICAgICB2YXIgZmlsdGVyUGF0aDEgPSBcInsgY29udGludWUgX2NvcmVsb29wOyB9JDFcIjtcclxuICAgICAgdmFyIGZpbHRlclBhdGgyID0gXCJ7IF9yZXR2YWxbX2lkeCsrXSA9ICRpdGVtJDsgY29udGludWUgX2NvcmVsb29wOyB9JDFcIjtcclxuICAgICAgLy8gbWFrZSBzb21lIGFsbG93YW5jZXMgZm9yIG1pbmlmaWNhdGlvbiAtIHRoZXJlJ3Mgb25seSBzbyBmYXIgd2UgY2FuIGdvIHdpdGggUmVnRXhcclxuICAgICAgdmFyIGZpbHRlckJvZHkgPSBmaWx0ZXJJbmZvLmJvZHlcclxuICAgICAgICAgIC5yZXBsYWNlKC9yZXR1cm4gZmFsc2VcXHMqKFs7fV18XFx9fCQpL2dpLCBmaWx0ZXJQYXRoMSlcclxuICAgICAgICAgIC5yZXBsYWNlKC9yZXR1cm4hMShbO31dfFxcfXwkKS9naSwgZmlsdGVyUGF0aDEpXHJcbiAgICAgICAgICAucmVwbGFjZSgvcmV0dXJuIHRydWVcXHMqKFs7fV18XFx9fCQpL2dpLCBmaWx0ZXJQYXRoMilcclxuICAgICAgICAgIC5yZXBsYWNlKC9yZXR1cm4hMChbO31dfFxcfXwkKS9naSwgZmlsdGVyUGF0aDIpXHJcbiAgICAgICAgICAucmVwbGFjZSgvcmV0dXJuIChbXjt9XSs/KVxccyooWzt9XXwkKS9naSxcclxuICAgICAgICAgIFwieyBpZiAoJDEpIHsgX3JldHZhbFtfaWR4KytdID0gJGl0ZW0kOyB9OyBjb250aW51ZSBfY29yZWxvb3A7IH0kMlwiKTtcclxuXHJcbiAgICAgIC8vIFRoaXMgcHJlc2VydmVzIHRoZSBmdW5jdGlvbiB0ZW1wbGF0ZSBjb2RlIGFmdGVyIEpTIGNvbXByZXNzaW9uLFxyXG4gICAgICAvLyBzbyB0aGF0IHJlcGxhY2UoKSBjb21tYW5kcyBzdGlsbCB3b3JrIGFzIGV4cGVjdGVkLlxyXG4gICAgICB2YXIgdHBsID0gW1xyXG4gICAgICAgIC8vXCJmdW5jdGlvbihfaXRlbXMsIF9hcmdzKSB7IFwiLFxyXG4gICAgICAgIFwidmFyIF9yZXR2YWwgPSBbXSwgX2lkeCA9IDA7IFwiLFxyXG4gICAgICAgIFwidmFyICRpdGVtJCwgJGFyZ3MkID0gX2FyZ3M7IFwiLFxyXG4gICAgICAgIFwiX2NvcmVsb29wOiBcIixcclxuICAgICAgICBcImZvciAodmFyIF9pID0gMCwgX2lsID0gX2l0ZW1zLmxlbmd0aDsgX2kgPCBfaWw7IF9pKyspIHsgXCIsXHJcbiAgICAgICAgXCIkaXRlbSQgPSBfaXRlbXNbX2ldOyBcIixcclxuICAgICAgICBcIiRmaWx0ZXIkOyBcIixcclxuICAgICAgICBcIn0gXCIsXHJcbiAgICAgICAgXCJyZXR1cm4gX3JldHZhbDsgXCJcclxuICAgICAgICAvL1wifVwiXHJcbiAgICAgIF0uam9pbihcIlwiKTtcclxuICAgICAgdHBsID0gdHBsLnJlcGxhY2UoL1xcJGZpbHRlclxcJC9naSwgZmlsdGVyQm9keSk7XHJcbiAgICAgIHRwbCA9IHRwbC5yZXBsYWNlKC9cXCRpdGVtXFwkL2dpLCBmaWx0ZXJJbmZvLnBhcmFtc1swXSk7XHJcbiAgICAgIHRwbCA9IHRwbC5yZXBsYWNlKC9cXCRhcmdzXFwkL2dpLCBmaWx0ZXJJbmZvLnBhcmFtc1sxXSk7XHJcblxyXG4gICAgICB2YXIgZm4gPSBuZXcgRnVuY3Rpb24oXCJfaXRlbXMsX2FyZ3NcIiwgdHBsKTtcclxuICAgICAgZm4uZGlzcGxheU5hbWUgPSBmbi5uYW1lID0gXCJjb21waWxlZEZpbHRlclwiO1xyXG4gICAgICByZXR1cm4gZm47XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY29tcGlsZUZpbHRlcldpdGhDYWNoaW5nKCkge1xyXG4gICAgICB2YXIgZmlsdGVySW5mbyA9IGdldEZ1bmN0aW9uSW5mbyhmaWx0ZXIpO1xyXG5cclxuICAgICAgdmFyIGZpbHRlclBhdGgxID0gXCJ7IGNvbnRpbnVlIF9jb3JlbG9vcDsgfSQxXCI7XHJcbiAgICAgIHZhciBmaWx0ZXJQYXRoMiA9IFwieyBfY2FjaGVbX2ldID0gdHJ1ZTtfcmV0dmFsW19pZHgrK10gPSAkaXRlbSQ7IGNvbnRpbnVlIF9jb3JlbG9vcDsgfSQxXCI7XHJcbiAgICAgIC8vIG1ha2Ugc29tZSBhbGxvd2FuY2VzIGZvciBtaW5pZmljYXRpb24gLSB0aGVyZSdzIG9ubHkgc28gZmFyIHdlIGNhbiBnbyB3aXRoIFJlZ0V4XHJcbiAgICAgIHZhciBmaWx0ZXJCb2R5ID0gZmlsdGVySW5mby5ib2R5XHJcbiAgICAgICAgICAucmVwbGFjZSgvcmV0dXJuIGZhbHNlXFxzKihbO31dfFxcfXwkKS9naSwgZmlsdGVyUGF0aDEpXHJcbiAgICAgICAgICAucmVwbGFjZSgvcmV0dXJuITEoWzt9XXxcXH18JCkvZ2ksIGZpbHRlclBhdGgxKVxyXG4gICAgICAgICAgLnJlcGxhY2UoL3JldHVybiB0cnVlXFxzKihbO31dfFxcfXwkKS9naSwgZmlsdGVyUGF0aDIpXHJcbiAgICAgICAgICAucmVwbGFjZSgvcmV0dXJuITAoWzt9XXxcXH18JCkvZ2ksIGZpbHRlclBhdGgyKVxyXG4gICAgICAgICAgLnJlcGxhY2UoL3JldHVybiAoW147fV0rPylcXHMqKFs7fV18JCkvZ2ksXHJcbiAgICAgICAgICBcInsgaWYgKChfY2FjaGVbX2ldID0gJDEpKSB7IF9yZXR2YWxbX2lkeCsrXSA9ICRpdGVtJDsgfTsgY29udGludWUgX2NvcmVsb29wOyB9JDJcIik7XHJcblxyXG4gICAgICAvLyBUaGlzIHByZXNlcnZlcyB0aGUgZnVuY3Rpb24gdGVtcGxhdGUgY29kZSBhZnRlciBKUyBjb21wcmVzc2lvbixcclxuICAgICAgLy8gc28gdGhhdCByZXBsYWNlKCkgY29tbWFuZHMgc3RpbGwgd29yayBhcyBleHBlY3RlZC5cclxuICAgICAgdmFyIHRwbCA9IFtcclxuICAgICAgICAvL1wiZnVuY3Rpb24oX2l0ZW1zLCBfYXJncywgX2NhY2hlKSB7IFwiLFxyXG4gICAgICAgIFwidmFyIF9yZXR2YWwgPSBbXSwgX2lkeCA9IDA7IFwiLFxyXG4gICAgICAgIFwidmFyICRpdGVtJCwgJGFyZ3MkID0gX2FyZ3M7IFwiLFxyXG4gICAgICAgIFwiX2NvcmVsb29wOiBcIixcclxuICAgICAgICBcImZvciAodmFyIF9pID0gMCwgX2lsID0gX2l0ZW1zLmxlbmd0aDsgX2kgPCBfaWw7IF9pKyspIHsgXCIsXHJcbiAgICAgICAgXCIkaXRlbSQgPSBfaXRlbXNbX2ldOyBcIixcclxuICAgICAgICBcImlmIChfY2FjaGVbX2ldKSB7IFwiLFxyXG4gICAgICAgIFwiX3JldHZhbFtfaWR4KytdID0gJGl0ZW0kOyBcIixcclxuICAgICAgICBcImNvbnRpbnVlIF9jb3JlbG9vcDsgXCIsXHJcbiAgICAgICAgXCJ9IFwiLFxyXG4gICAgICAgIFwiJGZpbHRlciQ7IFwiLFxyXG4gICAgICAgIFwifSBcIixcclxuICAgICAgICBcInJldHVybiBfcmV0dmFsOyBcIlxyXG4gICAgICAgIC8vXCJ9XCJcclxuICAgICAgXS5qb2luKFwiXCIpO1xyXG4gICAgICB0cGwgPSB0cGwucmVwbGFjZSgvXFwkZmlsdGVyXFwkL2dpLCBmaWx0ZXJCb2R5KTtcclxuICAgICAgdHBsID0gdHBsLnJlcGxhY2UoL1xcJGl0ZW1cXCQvZ2ksIGZpbHRlckluZm8ucGFyYW1zWzBdKTtcclxuICAgICAgdHBsID0gdHBsLnJlcGxhY2UoL1xcJGFyZ3NcXCQvZ2ksIGZpbHRlckluZm8ucGFyYW1zWzFdKTtcclxuXHJcbiAgICAgIHZhciBmbiA9IG5ldyBGdW5jdGlvbihcIl9pdGVtcyxfYXJncyxfY2FjaGVcIiwgdHBsKTtcclxuICAgICAgZm4uZGlzcGxheU5hbWUgPSBmbi5uYW1lID0gXCJjb21waWxlZEZpbHRlcldpdGhDYWNoaW5nXCI7XHJcbiAgICAgIHJldHVybiBmbjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB1bmNvbXBpbGVkRmlsdGVyKGl0ZW1zLCBhcmdzKSB7XHJcbiAgICAgIHZhciByZXR2YWwgPSBbXSwgaWR4ID0gMDtcclxuXHJcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcclxuICAgICAgICBpZiAoZmlsdGVyKGl0ZW1zW2ldLCBhcmdzKSkge1xyXG4gICAgICAgICAgcmV0dmFsW2lkeCsrXSA9IGl0ZW1zW2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJldHZhbDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB1bmNvbXBpbGVkRmlsdGVyV2l0aENhY2hpbmcoaXRlbXMsIGFyZ3MsIGNhY2hlKSB7XHJcbiAgICAgIHZhciByZXR2YWwgPSBbXSwgaWR4ID0gMCwgaXRlbTtcclxuXHJcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcclxuICAgICAgICBpdGVtID0gaXRlbXNbaV07XHJcbiAgICAgICAgaWYgKGNhY2hlW2ldKSB7XHJcbiAgICAgICAgICByZXR2YWxbaWR4KytdID0gaXRlbTtcclxuICAgICAgICB9IGVsc2UgaWYgKGZpbHRlcihpdGVtLCBhcmdzKSkge1xyXG4gICAgICAgICAgcmV0dmFsW2lkeCsrXSA9IGl0ZW07XHJcbiAgICAgICAgICBjYWNoZVtpXSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldEZpbHRlcmVkQW5kUGFnZWRJdGVtcyhpdGVtcykge1xyXG4gICAgICBpZiAoZmlsdGVyKSB7XHJcbiAgICAgICAgdmFyIGJhdGNoRmlsdGVyID0gb3B0aW9ucy5pbmxpbmVGaWx0ZXJzID8gY29tcGlsZWRGaWx0ZXIgOiB1bmNvbXBpbGVkRmlsdGVyO1xyXG4gICAgICAgIHZhciBiYXRjaEZpbHRlcldpdGhDYWNoaW5nID0gb3B0aW9ucy5pbmxpbmVGaWx0ZXJzID8gY29tcGlsZWRGaWx0ZXJXaXRoQ2FjaGluZyA6IHVuY29tcGlsZWRGaWx0ZXJXaXRoQ2FjaGluZztcclxuXHJcbiAgICAgICAgaWYgKHJlZnJlc2hIaW50cy5pc0ZpbHRlck5hcnJvd2luZykge1xyXG4gICAgICAgICAgZmlsdGVyZWRJdGVtcyA9IGJhdGNoRmlsdGVyKGZpbHRlcmVkSXRlbXMsIGZpbHRlckFyZ3MpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocmVmcmVzaEhpbnRzLmlzRmlsdGVyRXhwYW5kaW5nKSB7XHJcbiAgICAgICAgICBmaWx0ZXJlZEl0ZW1zID0gYmF0Y2hGaWx0ZXJXaXRoQ2FjaGluZyhpdGVtcywgZmlsdGVyQXJncywgZmlsdGVyQ2FjaGUpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIXJlZnJlc2hIaW50cy5pc0ZpbHRlclVuY2hhbmdlZCkge1xyXG4gICAgICAgICAgZmlsdGVyZWRJdGVtcyA9IGJhdGNoRmlsdGVyKGl0ZW1zLCBmaWx0ZXJBcmdzKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gc3BlY2lhbCBjYXNlOiAgaWYgbm90IGZpbHRlcmluZyBhbmQgbm90IHBhZ2luZywgdGhlIHJlc3VsdGluZ1xyXG4gICAgICAgIC8vIHJvd3MgY29sbGVjdGlvbiBuZWVkcyB0byBiZSBhIGNvcHkgc28gdGhhdCBjaGFuZ2VzIGR1ZSB0byBzb3J0XHJcbiAgICAgICAgLy8gY2FuIGJlIGNhdWdodFxyXG4gICAgICAgIGZpbHRlcmVkSXRlbXMgPSBwYWdlc2l6ZSA/IGl0ZW1zIDogaXRlbXMuY29uY2F0KCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGdldCB0aGUgY3VycmVudCBwYWdlXHJcbiAgICAgIHZhciBwYWdlZDtcclxuICAgICAgaWYgKHBhZ2VzaXplKSB7XHJcbiAgICAgICAgaWYgKGZpbHRlcmVkSXRlbXMubGVuZ3RoIDw9IHBhZ2VudW0gKiBwYWdlc2l6ZSkge1xyXG4gICAgICAgICAgaWYgKGZpbHRlcmVkSXRlbXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHBhZ2VudW0gPSAwO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcGFnZW51bSA9IE1hdGguZmxvb3IoKGZpbHRlcmVkSXRlbXMubGVuZ3RoIC0gMSkgLyBwYWdlc2l6ZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBhZ2VkID0gZmlsdGVyZWRJdGVtcy5zbGljZShwYWdlc2l6ZSAqIHBhZ2VudW0sIHBhZ2VzaXplICogcGFnZW51bSArIHBhZ2VzaXplKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBwYWdlZCA9IGZpbHRlcmVkSXRlbXM7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHt0b3RhbFJvd3M6IGZpbHRlcmVkSXRlbXMubGVuZ3RoLCByb3dzOiBwYWdlZH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0Um93RGlmZnMocm93cywgbmV3Um93cykge1xyXG4gICAgICB2YXIgaXRlbSwgciwgZWl0aGVySXNOb25EYXRhLCBkaWZmID0gW107XHJcbiAgICAgIHZhciBmcm9tID0gMCwgdG8gPSBuZXdSb3dzLmxlbmd0aDtcclxuXHJcbiAgICAgIGlmIChyZWZyZXNoSGludHMgJiYgcmVmcmVzaEhpbnRzLmlnbm9yZURpZmZzQmVmb3JlKSB7XHJcbiAgICAgICAgZnJvbSA9IE1hdGgubWF4KDAsXHJcbiAgICAgICAgICAgIE1hdGgubWluKG5ld1Jvd3MubGVuZ3RoLCByZWZyZXNoSGludHMuaWdub3JlRGlmZnNCZWZvcmUpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHJlZnJlc2hIaW50cyAmJiByZWZyZXNoSGludHMuaWdub3JlRGlmZnNBZnRlcikge1xyXG4gICAgICAgIHRvID0gTWF0aC5taW4obmV3Um93cy5sZW5ndGgsXHJcbiAgICAgICAgICAgIE1hdGgubWF4KDAsIHJlZnJlc2hIaW50cy5pZ25vcmVEaWZmc0FmdGVyKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvciAodmFyIGkgPSBmcm9tLCBybCA9IHJvd3MubGVuZ3RoOyBpIDwgdG87IGkrKykge1xyXG4gICAgICAgIGlmIChpID49IHJsKSB7XHJcbiAgICAgICAgICBkaWZmW2RpZmYubGVuZ3RoXSA9IGk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGl0ZW0gPSBuZXdSb3dzW2ldO1xyXG4gICAgICAgICAgciA9IHJvd3NbaV07XHJcblxyXG4gICAgICAgICAgaWYgKChncm91cGluZ0luZm9zLmxlbmd0aCAmJiAoZWl0aGVySXNOb25EYXRhID0gKGl0ZW0uX19ub25EYXRhUm93KSB8fCAoci5fX25vbkRhdGFSb3cpKSAmJlxyXG4gICAgICAgICAgICAgIGl0ZW0uX19ncm91cCAhPT0gci5fX2dyb3VwIHx8XHJcbiAgICAgICAgICAgICAgaXRlbS5fX2dyb3VwICYmICFpdGVtLmVxdWFscyhyKSlcclxuICAgICAgICAgICAgICB8fCAoZWl0aGVySXNOb25EYXRhICYmXHJcbiAgICAgICAgICAgICAgLy8gbm8gZ29vZCB3YXkgdG8gY29tcGFyZSB0b3RhbHMgc2luY2UgdGhleSBhcmUgYXJiaXRyYXJ5IERUT3NcclxuICAgICAgICAgICAgICAvLyBkZWVwIG9iamVjdCBjb21wYXJpc29uIGlzIHByZXR0eSBleHBlbnNpdmVcclxuICAgICAgICAgICAgICAvLyBhbHdheXMgY29uc2lkZXJpbmcgdGhlbSAnZGlydHknIHNlZW1zIGVhc2llciBmb3IgdGhlIHRpbWUgYmVpbmdcclxuICAgICAgICAgICAgICAoaXRlbS5fX2dyb3VwVG90YWxzIHx8IHIuX19ncm91cFRvdGFscykpXHJcbiAgICAgICAgICAgICAgfHwgaXRlbVtpZFByb3BlcnR5XSAhPSByW2lkUHJvcGVydHldXHJcbiAgICAgICAgICAgICAgfHwgKHVwZGF0ZWQgJiYgdXBkYXRlZFtpdGVtW2lkUHJvcGVydHldXSlcclxuICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgZGlmZltkaWZmLmxlbmd0aF0gPSBpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZGlmZjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZWNhbGMoX2l0ZW1zKSB7XHJcbiAgICAgIHJvd3NCeUlkID0gbnVsbDtcclxuXHJcbiAgICAgIGlmIChyZWZyZXNoSGludHMuaXNGaWx0ZXJOYXJyb3dpbmcgIT0gcHJldlJlZnJlc2hIaW50cy5pc0ZpbHRlck5hcnJvd2luZyB8fFxyXG4gICAgICAgICAgcmVmcmVzaEhpbnRzLmlzRmlsdGVyRXhwYW5kaW5nICE9IHByZXZSZWZyZXNoSGludHMuaXNGaWx0ZXJFeHBhbmRpbmcpIHtcclxuICAgICAgICBmaWx0ZXJDYWNoZSA9IFtdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgZmlsdGVyZWRJdGVtcyA9IGdldEZpbHRlcmVkQW5kUGFnZWRJdGVtcyhfaXRlbXMpO1xyXG4gICAgICB0b3RhbFJvd3MgPSBmaWx0ZXJlZEl0ZW1zLnRvdGFsUm93cztcclxuICAgICAgdmFyIG5ld1Jvd3MgPSBmaWx0ZXJlZEl0ZW1zLnJvd3M7XHJcblxyXG4gICAgICBncm91cHMgPSBbXTtcclxuICAgICAgaWYgKGdyb3VwaW5nSW5mb3MubGVuZ3RoKSB7XHJcbiAgICAgICAgZ3JvdXBzID0gZXh0cmFjdEdyb3VwcyhuZXdSb3dzKTtcclxuICAgICAgICBpZiAoZ3JvdXBzLmxlbmd0aCkge1xyXG4gICAgICAgICAgYWRkVG90YWxzKGdyb3Vwcyk7XHJcbiAgICAgICAgICBuZXdSb3dzID0gZmxhdHRlbkdyb3VwZWRSb3dzKGdyb3Vwcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgZGlmZiA9IGdldFJvd0RpZmZzKHJvd3MsIG5ld1Jvd3MpO1xyXG5cclxuICAgICAgcm93cyA9IG5ld1Jvd3M7XHJcblxyXG4gICAgICByZXR1cm4gZGlmZjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZWZyZXNoKCkge1xyXG4gICAgICBpZiAoc3VzcGVuZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGNvdW50QmVmb3JlID0gcm93cy5sZW5ndGg7XHJcbiAgICAgIHZhciB0b3RhbFJvd3NCZWZvcmUgPSB0b3RhbFJvd3M7XHJcblxyXG4gICAgICB2YXIgZGlmZiA9IHJlY2FsYyhpdGVtcywgZmlsdGVyKTsgLy8gcGFzcyBhcyBkaXJlY3QgcmVmcyB0byBhdm9pZCBjbG9zdXJlIHBlcmYgaGl0XHJcblxyXG4gICAgICAvLyBpZiB0aGUgY3VycmVudCBwYWdlIGlzIG5vIGxvbmdlciB2YWxpZCwgZ28gdG8gbGFzdCBwYWdlIGFuZCByZWNhbGNcclxuICAgICAgLy8gd2Ugc3VmZmVyIGEgcGVyZm9ybWFuY2UgcGVuYWx0eSBoZXJlLCBidXQgdGhlIG1haW4gbG9vcCAocmVjYWxjKSByZW1haW5zIGhpZ2hseSBvcHRpbWl6ZWRcclxuICAgICAgaWYgKHBhZ2VzaXplICYmIHRvdGFsUm93cyA8IHBhZ2VudW0gKiBwYWdlc2l6ZSkge1xyXG4gICAgICAgIHBhZ2VudW0gPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwodG90YWxSb3dzIC8gcGFnZXNpemUpIC0gMSk7XHJcbiAgICAgICAgZGlmZiA9IHJlY2FsYyhpdGVtcywgZmlsdGVyKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdXBkYXRlZCA9IG51bGw7XHJcbiAgICAgIHByZXZSZWZyZXNoSGludHMgPSByZWZyZXNoSGludHM7XHJcbiAgICAgIHJlZnJlc2hIaW50cyA9IHt9O1xyXG5cclxuICAgICAgaWYgKHRvdGFsUm93c0JlZm9yZSAhPT0gdG90YWxSb3dzKSB7XHJcbiAgICAgICAgb25QYWdpbmdJbmZvQ2hhbmdlZC5ub3RpZnkoZ2V0UGFnaW5nSW5mbygpLCBudWxsLCBzZWxmKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoY291bnRCZWZvcmUgIT09IHJvd3MubGVuZ3RoKSB7XHJcbiAgICAgICAgb25Sb3dDb3VudENoYW5nZWQubm90aWZ5KHtwcmV2aW91czogY291bnRCZWZvcmUsIGN1cnJlbnQ6IHJvd3MubGVuZ3RoLCBkYXRhVmlldzogc2VsZn0sIG51bGwsIHNlbGYpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChkaWZmLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBvblJvd3NDaGFuZ2VkLm5vdGlmeSh7cm93czogZGlmZiwgZGF0YVZpZXc6IHNlbGZ9LCBudWxsLCBzZWxmKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKipcclxuICAgICAqIFdpcmVzIHRoZSBncmlkIGFuZCB0aGUgRGF0YVZpZXcgdG9nZXRoZXIgdG8ga2VlcCByb3cgc2VsZWN0aW9uIHRpZWQgdG8gaXRlbSBpZHMuXHJcbiAgICAgKiBUaGlzIGlzIHVzZWZ1bCBzaW5jZSwgd2l0aG91dCBpdCwgdGhlIGdyaWQgb25seSBrbm93cyBhYm91dCByb3dzLCBzbyBpZiB0aGUgaXRlbXNcclxuICAgICAqIG1vdmUgYXJvdW5kLCB0aGUgc2FtZSByb3dzIHN0YXkgc2VsZWN0ZWQgaW5zdGVhZCBvZiB0aGUgc2VsZWN0aW9uIG1vdmluZyBhbG9uZ1xyXG4gICAgICogd2l0aCB0aGUgaXRlbXMuXHJcbiAgICAgKlxyXG4gICAgICogTk9URTogIFRoaXMgZG9lc24ndCB3b3JrIHdpdGggY2VsbCBzZWxlY3Rpb24gbW9kZWwuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGdyaWQge1NsaWNrLkdyaWR9IFRoZSBncmlkIHRvIHN5bmMgc2VsZWN0aW9uIHdpdGguXHJcbiAgICAgKiBAcGFyYW0gcHJlc2VydmVIaWRkZW4ge0Jvb2xlYW59IFdoZXRoZXIgdG8ga2VlcCBzZWxlY3RlZCBpdGVtcyB0aGF0IGdvIG91dCBvZiB0aGVcclxuICAgICAqICAgICB2aWV3IGR1ZSB0byB0aGVtIGdldHRpbmcgZmlsdGVyZWQgb3V0LlxyXG4gICAgICogQHBhcmFtIHByZXNlcnZlSGlkZGVuT25TZWxlY3Rpb25DaGFuZ2Uge0Jvb2xlYW59IFdoZXRoZXIgdG8ga2VlcCBzZWxlY3RlZCBpdGVtc1xyXG4gICAgICogICAgIHRoYXQgYXJlIGN1cnJlbnRseSBvdXQgb2YgdGhlIHZpZXcgKHNlZSBwcmVzZXJ2ZUhpZGRlbikgYXMgc2VsZWN0ZWQgd2hlbiBzZWxlY3Rpb25cclxuICAgICAqICAgICBjaGFuZ2VzLlxyXG4gICAgICogQHJldHVybiB7U2xpY2suRXZlbnR9IEFuIGV2ZW50IHRoYXQgbm90aWZpZXMgd2hlbiBhbiBpbnRlcm5hbCBsaXN0IG9mIHNlbGVjdGVkIHJvdyBpZHNcclxuICAgICAqICAgICBjaGFuZ2VzLiAgVGhpcyBpcyB1c2VmdWwgc2luY2UsIGluIGNvbWJpbmF0aW9uIHdpdGggdGhlIGFib3ZlIHR3byBvcHRpb25zLCBpdCBhbGxvd3NcclxuICAgICAqICAgICBhY2Nlc3MgdG8gdGhlIGZ1bGwgbGlzdCBzZWxlY3RlZCByb3cgaWRzLCBhbmQgbm90IGp1c3QgdGhlIG9uZXMgdmlzaWJsZSB0byB0aGUgZ3JpZC5cclxuICAgICAqIEBtZXRob2Qgc3luY0dyaWRTZWxlY3Rpb25cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gc3luY0dyaWRTZWxlY3Rpb24oZ3JpZCwgcHJlc2VydmVIaWRkZW4sIHByZXNlcnZlSGlkZGVuT25TZWxlY3Rpb25DaGFuZ2UpIHtcclxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICB2YXIgaW5IYW5kbGVyO1xyXG4gICAgICB2YXIgc2VsZWN0ZWRSb3dJZHMgPSBzZWxmLm1hcFJvd3NUb0lkcyhncmlkLmdldFNlbGVjdGVkUm93cygpKTtcclxuICAgICAgdmFyIG9uU2VsZWN0ZWRSb3dJZHNDaGFuZ2VkID0gbmV3IFNsaWNrLkV2ZW50KCk7XHJcblxyXG4gICAgICBmdW5jdGlvbiBzZXRTZWxlY3RlZFJvd0lkcyhyb3dJZHMpIHtcclxuICAgICAgICBpZiAoc2VsZWN0ZWRSb3dJZHMuam9pbihcIixcIikgPT0gcm93SWRzLmpvaW4oXCIsXCIpKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzZWxlY3RlZFJvd0lkcyA9IHJvd0lkcztcclxuXHJcbiAgICAgICAgb25TZWxlY3RlZFJvd0lkc0NoYW5nZWQubm90aWZ5KHtcclxuICAgICAgICAgIFwiZ3JpZFwiOiBncmlkLFxyXG4gICAgICAgICAgXCJpZHNcIjogc2VsZWN0ZWRSb3dJZHMsXHJcbiAgICAgICAgICBcImRhdGFWaWV3XCI6IHNlbGZcclxuICAgICAgICB9LCBuZXcgU2xpY2suRXZlbnREYXRhKCksIHNlbGYpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiB1cGRhdGUoKSB7XHJcbiAgICAgICAgaWYgKHNlbGVjdGVkUm93SWRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIGluSGFuZGxlciA9IHRydWU7XHJcbiAgICAgICAgICB2YXIgc2VsZWN0ZWRSb3dzID0gc2VsZi5tYXBJZHNUb1Jvd3Moc2VsZWN0ZWRSb3dJZHMpO1xyXG4gICAgICAgICAgaWYgKCFwcmVzZXJ2ZUhpZGRlbikge1xyXG4gICAgICAgICAgICBzZXRTZWxlY3RlZFJvd0lkcyhzZWxmLm1hcFJvd3NUb0lkcyhzZWxlY3RlZFJvd3MpKTsgICAgICAgXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBncmlkLnNldFNlbGVjdGVkUm93cyhzZWxlY3RlZFJvd3MpO1xyXG4gICAgICAgICAgaW5IYW5kbGVyID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBncmlkLm9uU2VsZWN0ZWRSb3dzQ2hhbmdlZC5zdWJzY3JpYmUoZnVuY3Rpb24oZSwgYXJncykge1xyXG4gICAgICAgIGlmIChpbkhhbmRsZXIpIHsgcmV0dXJuOyB9XHJcbiAgICAgICAgdmFyIG5ld1NlbGVjdGVkUm93SWRzID0gc2VsZi5tYXBSb3dzVG9JZHMoZ3JpZC5nZXRTZWxlY3RlZFJvd3MoKSk7XHJcbiAgICAgICAgaWYgKCFwcmVzZXJ2ZUhpZGRlbk9uU2VsZWN0aW9uQ2hhbmdlIHx8ICFncmlkLmdldE9wdGlvbnMoKS5tdWx0aVNlbGVjdCkge1xyXG4gICAgICAgICAgc2V0U2VsZWN0ZWRSb3dJZHMobmV3U2VsZWN0ZWRSb3dJZHMpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBrZWVwIHRoZSBvbmVzIHRoYXQgYXJlIGhpZGRlblxyXG4gICAgICAgICAgdmFyIGV4aXN0aW5nID0gJC5ncmVwKHNlbGVjdGVkUm93SWRzLCBmdW5jdGlvbihpZCkgeyByZXR1cm4gc2VsZi5nZXRSb3dCeUlkKGlkKSA9PT0gdW5kZWZpbmVkOyB9KTtcclxuICAgICAgICAgIC8vIGFkZCB0aGUgbmV3bHkgc2VsZWN0ZWQgb25lc1xyXG4gICAgICAgICAgc2V0U2VsZWN0ZWRSb3dJZHMoZXhpc3RpbmcuY29uY2F0KG5ld1NlbGVjdGVkUm93SWRzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHRoaXMub25Sb3dzQ2hhbmdlZC5zdWJzY3JpYmUodXBkYXRlKTtcclxuXHJcbiAgICAgIHRoaXMub25Sb3dDb3VudENoYW5nZWQuc3Vic2NyaWJlKHVwZGF0ZSk7XHJcblxyXG4gICAgICByZXR1cm4gb25TZWxlY3RlZFJvd0lkc0NoYW5nZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc3luY0dyaWRDZWxsQ3NzU3R5bGVzKGdyaWQsIGtleSkge1xyXG4gICAgICB2YXIgaGFzaEJ5SWQ7XHJcbiAgICAgIHZhciBpbkhhbmRsZXI7XHJcblxyXG4gICAgICAvLyBzaW5jZSB0aGlzIG1ldGhvZCBjYW4gYmUgY2FsbGVkIGFmdGVyIHRoZSBjZWxsIHN0eWxlcyBoYXZlIGJlZW4gc2V0LFxyXG4gICAgICAvLyBnZXQgdGhlIGV4aXN0aW5nIG9uZXMgcmlnaHQgYXdheVxyXG4gICAgICBzdG9yZUNlbGxDc3NTdHlsZXMoZ3JpZC5nZXRDZWxsQ3NzU3R5bGVzKGtleSkpO1xyXG5cclxuICAgICAgZnVuY3Rpb24gc3RvcmVDZWxsQ3NzU3R5bGVzKGhhc2gpIHtcclxuICAgICAgICBoYXNoQnlJZCA9IHt9O1xyXG4gICAgICAgIGZvciAodmFyIHJvdyBpbiBoYXNoKSB7XHJcbiAgICAgICAgICB2YXIgaWQgPSByb3dzW3Jvd11baWRQcm9wZXJ0eV07XHJcbiAgICAgICAgICBoYXNoQnlJZFtpZF0gPSBoYXNoW3Jvd107XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiB1cGRhdGUoKSB7XHJcbiAgICAgICAgaWYgKGhhc2hCeUlkKSB7XHJcbiAgICAgICAgICBpbkhhbmRsZXIgPSB0cnVlO1xyXG4gICAgICAgICAgZW5zdXJlUm93c0J5SWRDYWNoZSgpO1xyXG4gICAgICAgICAgdmFyIG5ld0hhc2ggPSB7fTtcclxuICAgICAgICAgIGZvciAodmFyIGlkIGluIGhhc2hCeUlkKSB7XHJcbiAgICAgICAgICAgIHZhciByb3cgPSByb3dzQnlJZFtpZF07XHJcbiAgICAgICAgICAgIGlmIChyb3cgIT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgbmV3SGFzaFtyb3ddID0gaGFzaEJ5SWRbaWRdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBncmlkLnNldENlbGxDc3NTdHlsZXMoa2V5LCBuZXdIYXNoKTtcclxuICAgICAgICAgIGluSGFuZGxlciA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgZ3JpZC5vbkNlbGxDc3NTdHlsZXNDaGFuZ2VkLnN1YnNjcmliZShmdW5jdGlvbihlLCBhcmdzKSB7XHJcbiAgICAgICAgaWYgKGluSGFuZGxlcikgeyByZXR1cm47IH1cclxuICAgICAgICBpZiAoa2V5ICE9IGFyZ3Mua2V5KSB7IHJldHVybjsgfVxyXG4gICAgICAgIGlmIChhcmdzLmhhc2gpIHtcclxuICAgICAgICAgIHN0b3JlQ2VsbENzc1N0eWxlcyhhcmdzLmhhc2gpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBncmlkLm9uQ2VsbENzc1N0eWxlc0NoYW5nZWQudW5zdWJzY3JpYmUoc3R5bGVDaGFuZ2VkKTtcclxuICAgICAgICAgIHNlbGYub25Sb3dzQ2hhbmdlZC51bnN1YnNjcmliZSh1cGRhdGUpO1xyXG4gICAgICAgICAgc2VsZi5vblJvd0NvdW50Q2hhbmdlZC51bnN1YnNjcmliZSh1cGRhdGUpOyAgICAgICAgICBcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdGhpcy5vblJvd3NDaGFuZ2VkLnN1YnNjcmliZSh1cGRhdGUpO1xyXG5cclxuICAgICAgdGhpcy5vblJvd0NvdW50Q2hhbmdlZC5zdWJzY3JpYmUodXBkYXRlKTtcclxuICAgIH1cclxuXHJcbiAgICAkLmV4dGVuZCh0aGlzLCB7XHJcbiAgICAgIC8vIG1ldGhvZHNcclxuICAgICAgXCJiZWdpblVwZGF0ZVwiOiBiZWdpblVwZGF0ZSxcclxuICAgICAgXCJlbmRVcGRhdGVcIjogZW5kVXBkYXRlLFxyXG4gICAgICBcInNldFBhZ2luZ09wdGlvbnNcIjogc2V0UGFnaW5nT3B0aW9ucyxcclxuICAgICAgXCJnZXRQYWdpbmdJbmZvXCI6IGdldFBhZ2luZ0luZm8sXHJcbiAgICAgIFwiZ2V0SXRlbXNcIjogZ2V0SXRlbXMsXHJcbiAgICAgIFwic2V0SXRlbXNcIjogc2V0SXRlbXMsXHJcbiAgICAgIFwic2V0RmlsdGVyXCI6IHNldEZpbHRlcixcclxuICAgICAgXCJnZXRGaWx0ZXJcIjogZ2V0RmlsdGVyLFxyXG4gICAgICBcImdldEZpbHRlcmVkSXRlbXNcIjogZ2V0RmlsdGVyZWRJdGVtcyxcclxuICAgICAgXCJzb3J0XCI6IHNvcnQsXHJcbiAgICAgIFwiZmFzdFNvcnRcIjogZmFzdFNvcnQsXHJcbiAgICAgIFwicmVTb3J0XCI6IHJlU29ydCxcclxuICAgICAgXCJzZXRHcm91cGluZ1wiOiBzZXRHcm91cGluZyxcclxuICAgICAgXCJnZXRHcm91cGluZ1wiOiBnZXRHcm91cGluZyxcclxuICAgICAgXCJncm91cEJ5XCI6IGdyb3VwQnksXHJcbiAgICAgIFwic2V0QWdncmVnYXRvcnNcIjogc2V0QWdncmVnYXRvcnMsXHJcbiAgICAgIFwiY29sbGFwc2VBbGxHcm91cHNcIjogY29sbGFwc2VBbGxHcm91cHMsXHJcbiAgICAgIFwiZXhwYW5kQWxsR3JvdXBzXCI6IGV4cGFuZEFsbEdyb3VwcyxcclxuICAgICAgXCJjb2xsYXBzZUdyb3VwXCI6IGNvbGxhcHNlR3JvdXAsXHJcbiAgICAgIFwiZXhwYW5kR3JvdXBcIjogZXhwYW5kR3JvdXAsXHJcbiAgICAgIFwiZ2V0R3JvdXBzXCI6IGdldEdyb3VwcyxcclxuICAgICAgXCJnZXRJZHhCeUlkXCI6IGdldElkeEJ5SWQsXHJcbiAgICAgIFwiZ2V0Um93QnlJdGVtXCI6IGdldFJvd0J5SXRlbSxcclxuICAgICAgXCJnZXRSb3dCeUlkXCI6IGdldFJvd0J5SWQsXHJcbiAgICAgIFwiZ2V0SXRlbUJ5SWRcIjogZ2V0SXRlbUJ5SWQsXHJcbiAgICAgIFwiZ2V0SXRlbUJ5SWR4XCI6IGdldEl0ZW1CeUlkeCxcclxuICAgICAgXCJtYXBJdGVtc1RvUm93c1wiOiBtYXBJdGVtc1RvUm93cyxcclxuICAgICAgXCJtYXBSb3dzVG9JZHNcIjogbWFwUm93c1RvSWRzLFxyXG4gICAgICBcIm1hcElkc1RvUm93c1wiOiBtYXBJZHNUb1Jvd3MsXHJcbiAgICAgIFwic2V0UmVmcmVzaEhpbnRzXCI6IHNldFJlZnJlc2hIaW50cyxcclxuICAgICAgXCJzZXRGaWx0ZXJBcmdzXCI6IHNldEZpbHRlckFyZ3MsXHJcbiAgICAgIFwicmVmcmVzaFwiOiByZWZyZXNoLFxyXG4gICAgICBcInVwZGF0ZUl0ZW1cIjogdXBkYXRlSXRlbSxcclxuICAgICAgXCJpbnNlcnRJdGVtXCI6IGluc2VydEl0ZW0sXHJcbiAgICAgIFwiYWRkSXRlbVwiOiBhZGRJdGVtLFxyXG4gICAgICBcImRlbGV0ZUl0ZW1cIjogZGVsZXRlSXRlbSxcclxuICAgICAgXCJzb3J0ZWRBZGRJdGVtXCI6IHNvcnRlZEFkZEl0ZW0sXHJcbiAgICAgIFwic29ydGVkVXBkYXRlSXRlbVwiOiBzb3J0ZWRVcGRhdGVJdGVtLFxyXG4gICAgICBcInN5bmNHcmlkU2VsZWN0aW9uXCI6IHN5bmNHcmlkU2VsZWN0aW9uLFxyXG4gICAgICBcInN5bmNHcmlkQ2VsbENzc1N0eWxlc1wiOiBzeW5jR3JpZENlbGxDc3NTdHlsZXMsXHJcblxyXG4gICAgICAvLyBkYXRhIHByb3ZpZGVyIG1ldGhvZHNcclxuICAgICAgXCJnZXRMZW5ndGhcIjogZ2V0TGVuZ3RoLFxyXG4gICAgICBcImdldEl0ZW1cIjogZ2V0SXRlbSxcclxuICAgICAgXCJnZXRJdGVtTWV0YWRhdGFcIjogZ2V0SXRlbU1ldGFkYXRhLFxyXG5cclxuICAgICAgLy8gZXZlbnRzXHJcbiAgICAgIFwib25Sb3dDb3VudENoYW5nZWRcIjogb25Sb3dDb3VudENoYW5nZWQsXHJcbiAgICAgIFwib25Sb3dzQ2hhbmdlZFwiOiBvblJvd3NDaGFuZ2VkLFxyXG4gICAgICBcIm9uUGFnaW5nSW5mb0NoYW5nZWRcIjogb25QYWdpbmdJbmZvQ2hhbmdlZFxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBBdmdBZ2dyZWdhdG9yKGZpZWxkKSB7XHJcbiAgICB0aGlzLmZpZWxkXyA9IGZpZWxkO1xyXG5cclxuICAgIHRoaXMuaW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5jb3VudF8gPSAwO1xyXG4gICAgICB0aGlzLm5vbk51bGxDb3VudF8gPSAwO1xyXG4gICAgICB0aGlzLnN1bV8gPSAwO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmFjY3VtdWxhdGUgPSBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICB2YXIgdmFsID0gaXRlbVt0aGlzLmZpZWxkX107XHJcbiAgICAgIHRoaXMuY291bnRfKys7XHJcbiAgICAgIGlmICh2YWwgIT0gbnVsbCAmJiB2YWwgIT09IFwiXCIgJiYgIWlzTmFOKHZhbCkpIHtcclxuICAgICAgICB0aGlzLm5vbk51bGxDb3VudF8rKztcclxuICAgICAgICB0aGlzLnN1bV8gKz0gcGFyc2VGbG9hdCh2YWwpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuc3RvcmVSZXN1bHQgPSBmdW5jdGlvbiAoZ3JvdXBUb3RhbHMpIHtcclxuICAgICAgaWYgKCFncm91cFRvdGFscy5hdmcpIHtcclxuICAgICAgICBncm91cFRvdGFscy5hdmcgPSB7fTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5ub25OdWxsQ291bnRfICE9IDApIHtcclxuICAgICAgICBncm91cFRvdGFscy5hdmdbdGhpcy5maWVsZF9dID0gdGhpcy5zdW1fIC8gdGhpcy5ub25OdWxsQ291bnRfO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gTWluQWdncmVnYXRvcihmaWVsZCkge1xyXG4gICAgdGhpcy5maWVsZF8gPSBmaWVsZDtcclxuXHJcbiAgICB0aGlzLmluaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRoaXMubWluXyA9IG51bGw7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuYWNjdW11bGF0ZSA9IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgIHZhciB2YWwgPSBpdGVtW3RoaXMuZmllbGRfXTtcclxuICAgICAgaWYgKHZhbCAhPSBudWxsICYmIHZhbCAhPT0gXCJcIiAmJiAhaXNOYU4odmFsKSkge1xyXG4gICAgICAgIGlmICh0aGlzLm1pbl8gPT0gbnVsbCB8fCB2YWwgPCB0aGlzLm1pbl8pIHtcclxuICAgICAgICAgIHRoaXMubWluXyA9IHZhbDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5zdG9yZVJlc3VsdCA9IGZ1bmN0aW9uIChncm91cFRvdGFscykge1xyXG4gICAgICBpZiAoIWdyb3VwVG90YWxzLm1pbikge1xyXG4gICAgICAgIGdyb3VwVG90YWxzLm1pbiA9IHt9O1xyXG4gICAgICB9XHJcbiAgICAgIGdyb3VwVG90YWxzLm1pblt0aGlzLmZpZWxkX10gPSB0aGlzLm1pbl87XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBNYXhBZ2dyZWdhdG9yKGZpZWxkKSB7XHJcbiAgICB0aGlzLmZpZWxkXyA9IGZpZWxkO1xyXG5cclxuICAgIHRoaXMuaW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5tYXhfID0gbnVsbDtcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5hY2N1bXVsYXRlID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgdmFyIHZhbCA9IGl0ZW1bdGhpcy5maWVsZF9dO1xyXG4gICAgICBpZiAodmFsICE9IG51bGwgJiYgdmFsICE9PSBcIlwiICYmICFpc05hTih2YWwpKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubWF4XyA9PSBudWxsIHx8IHZhbCA+IHRoaXMubWF4Xykge1xyXG4gICAgICAgICAgdGhpcy5tYXhfID0gdmFsO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnN0b3JlUmVzdWx0ID0gZnVuY3Rpb24gKGdyb3VwVG90YWxzKSB7XHJcbiAgICAgIGlmICghZ3JvdXBUb3RhbHMubWF4KSB7XHJcbiAgICAgICAgZ3JvdXBUb3RhbHMubWF4ID0ge307XHJcbiAgICAgIH1cclxuICAgICAgZ3JvdXBUb3RhbHMubWF4W3RoaXMuZmllbGRfXSA9IHRoaXMubWF4XztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIFN1bUFnZ3JlZ2F0b3IoZmllbGQpIHtcclxuICAgIHRoaXMuZmllbGRfID0gZmllbGQ7XHJcblxyXG4gICAgdGhpcy5pbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLnN1bV8gPSBudWxsO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmFjY3VtdWxhdGUgPSBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICB2YXIgdmFsID0gaXRlbVt0aGlzLmZpZWxkX107XHJcbiAgICAgIGlmICh2YWwgIT0gbnVsbCAmJiB2YWwgIT09IFwiXCIgJiYgIWlzTmFOKHZhbCkpIHtcclxuICAgICAgICB0aGlzLnN1bV8gKz0gcGFyc2VGbG9hdCh2YWwpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuc3RvcmVSZXN1bHQgPSBmdW5jdGlvbiAoZ3JvdXBUb3RhbHMpIHtcclxuICAgICAgaWYgKCFncm91cFRvdGFscy5zdW0pIHtcclxuICAgICAgICBncm91cFRvdGFscy5zdW0gPSB7fTtcclxuICAgICAgfVxyXG4gICAgICBncm91cFRvdGFscy5zdW1bdGhpcy5maWVsZF9dID0gdGhpcy5zdW1fO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gVE9ETzogIGFkZCBtb3JlIGJ1aWx0LWluIGFnZ3JlZ2F0b3JzXHJcbiAgLy8gVE9ETzogIG1lcmdlIGNvbW1vbiBhZ2dyZWdhdG9ycyBpbiBvbmUgdG8gcHJldmVudCBuZWVkbGVzIGl0ZXJhdGluZ1xyXG4gIGxldCBBZ2dyZWdhdG9ycyA9IHtcclxuICAgICAgICAgIEF2ZzogQXZnQWdncmVnYXRvcixcclxuICAgICAgICAgIE1pbjogTWluQWdncmVnYXRvcixcclxuICAgICAgICAgIE1heDogTWF4QWdncmVnYXRvcixcclxuICAgICAgICAgIFN1bTogU3VtQWdncmVnYXRvclxyXG4gIH07XHJcbiAgIFxyXG4gIGV4cG9ydCB7RGF0YVZpZXcsQWdncmVnYXRvcnN9O1xyXG4gICAgXHJcblxyXG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBS0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZkE7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQVZBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFZQTtBQWRBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbkRBO0FBcURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7QUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/vendor/slick.dataview.js\n");

/***/ }),

/***/ "./src/vendor/slick.grid.js":
/*!**********************************!*\
  !*** ./src/vendor/slick.grid.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*!\r\n * jquery.event.drag - v 2.3.0\r\n * Copyright (c) 2010 Three Dub Media - http://threedubmedia.com\r\n * Open Source MIT License - http://threedubmedia.com/code/license\r\n */\n// Created: 2008-06-04\n// Updated: 2012-05-21\n// Updated: 2016-08-16   Luiz Gonzaga dos Santos Filho\n// REQUIRES: jquery 1.8 +, , event.drag 2.3.0\n// TESTED WITH: jQuery 1.8.3, 1.11.2, 2.2.4, and 3.1.0\n\n;(function ($) {\n  // add the jquery instance method\n  $.fn.drag = function (str, arg, opts) {\n    // figure out the event type\n    var type = typeof str == \"string\" ? str : \"\",\n\n    // figure out the event handler...\n    fn = $.isFunction(str) ? str : $.isFunction(arg) ? arg : null;\n    // fix the event type\n    if (type.indexOf(\"drag\") !== 0) type = \"drag\" + type;\n    // were options passed\n    opts = (str == fn ? arg : opts) || {};\n    // trigger or bind event handler\n    return fn ? this.on(type, opts, fn) : this.trigger(type);\n  };\n\n  // local refs (increase compression)\n  var $event = $.event,\n      $special = $event.special,\n\n  // configure the drag special event\n  drag = $special.drag = {\n\n    // these are the default settings\n    defaults: {\n      which: 1, // mouse button pressed to start drag sequence\n      distance: 0, // distance dragged before dragstart\n      not: ':input', // selector to suppress dragging on target elements\n      handle: null, // selector to match handle target elements\n      relative: false, // true to use \"position\", false to use \"offset\"\n      drop: true, // false to suppress drop events, true or selector to allow\n      click: false // false to suppress click events after dragend (no proxy)\n    },\n\n    // the key name for stored drag data\n    datakey: \"dragdata\",\n\n    // prevent bubbling for better performance\n    noBubble: true,\n\n    // count bound related events\n    add: function add(obj) {\n      // read the interaction data\n      var data = $.data(this, drag.datakey),\n\n      // read any passed options\n      opts = obj.data || {};\n      // count another realted event\n      data.related += 1;\n      // extend data options bound with this event\n      // don't iterate \"opts\" in case it is a node\n      $.each(drag.defaults, function (key, def) {\n        if (opts[key] !== undefined) data[key] = opts[key];\n      });\n    },\n\n    // forget unbound related events\n    remove: function remove() {\n      $.data(this, drag.datakey).related -= 1;\n    },\n\n    // configure interaction, capture settings\n    setup: function setup() {\n      // check for related events\n      if ($.data(this, drag.datakey)) return;\n      // initialize the drag data with copied defaults\n      var data = $.extend({ related: 0 }, drag.defaults);\n      // store the interaction data\n      $.data(this, drag.datakey, data);\n      // bind the mousedown event, which starts drag interactions\n      $event.add(this, \"touchstart mousedown\", drag.init, data);\n      // prevent image dragging in IE...\n      if (this.attachEvent) this.attachEvent(\"ondragstart\", drag.dontstart);\n    },\n\n    // destroy configured interaction\n    teardown: function teardown() {\n      var data = $.data(this, drag.datakey) || {};\n      // check for related events\n      if (data.related) return;\n      // remove the stored data\n      $.removeData(this, drag.datakey);\n      // remove the mousedown event\n      $event.remove(this, \"touchstart mousedown\", drag.init);\n      // enable text selection\n      drag.textselect(true);\n      // un-prevent image dragging in IE...\n      if (this.detachEvent) this.detachEvent(\"ondragstart\", drag.dontstart);\n    },\n\n    // initialize the interaction\n    init: function init(event) {\n      // sorry, only one touch at a time\n      if (drag.touched) return;\n      // the drag/drop interaction data\n      var dd = event.data,\n          results;\n      // check the which directive\n      if (event.which != 0 && dd.which > 0 && event.which != dd.which) return;\n      // check for suppressed selector\n      if ($(event.target).is(dd.not)) return;\n      // check for handle selector\n      if (dd.handle && !$(event.target).closest(dd.handle, event.currentTarget).length) return;\n\n      drag.touched = event.type == 'touchstart' ? this : null;\n      dd.propagates = 1;\n      dd.mousedown = this;\n      dd.interactions = [drag.interaction(this, dd)];\n      dd.target = event.target;\n      dd.pageX = event.pageX;\n      dd.pageY = event.pageY;\n      dd.dragging = null;\n      // handle draginit event...\n      results = drag.hijack(event, \"draginit\", dd);\n      // early cancel\n      if (!dd.propagates) return;\n      // flatten the result set\n      results = drag.flatten(results);\n      // insert new interaction elements\n      if (results && results.length) {\n        dd.interactions = [];\n        $.each(results, function () {\n          dd.interactions.push(drag.interaction(this, dd));\n        });\n      }\n      // remember how many interactions are propagating\n      dd.propagates = dd.interactions.length;\n      // locate and init the drop targets\n      if (dd.drop !== false && $special.drop) $special.drop.handler(event, dd);\n      // disable text selection\n      drag.textselect(false);\n      // bind additional events...\n      if (drag.touched) $event.add(drag.touched, \"touchmove touchend\", drag.handler, dd);else $event.add(document, \"mousemove mouseup\", drag.handler, dd);\n      // helps prevent text selection or scrolling\n      if (!drag.touched || dd.live) return false;\n    },\n\n    // returns an interaction object\n    interaction: function interaction(elem, dd) {\n      var offset = elem && elem.ownerDocument ? $(elem)[dd.relative ? \"position\" : \"offset\"]() || { top: 0, left: 0 } : { top: 0, left: 0 };\n      return {\n        drag: elem,\n        callback: new drag.callback(),\n        droppable: [],\n        offset: offset\n      };\n    },\n\n    // handle drag-releatd DOM events\n    handler: function handler(event) {\n      // read the data before hijacking anything\n      var dd = event.data;\n      // handle various events\n      switch (event.type) {\n        // mousemove, check distance, start dragging\n        case !dd.dragging && 'touchmove':\n          event.preventDefault();\n        case !dd.dragging && 'mousemove':\n          //  drag tolerance, x² + y² = distance²\n          if (Math.pow(event.pageX - dd.pageX, 2) + Math.pow(event.pageY - dd.pageY, 2) < Math.pow(dd.distance, 2)) break; // distance tolerance not reached\n          event.target = dd.target; // force target from \"mousedown\" event (fix distance issue)\n          drag.hijack(event, \"dragstart\", dd); // trigger \"dragstart\"\n          if (dd.propagates) // \"dragstart\" not rejected\n            dd.dragging = true; // activate interaction\n        // mousemove, dragging\n        case 'touchmove':\n          event.preventDefault();\n        case 'mousemove':\n          if (dd.dragging) {\n            // trigger \"drag\"\n            drag.hijack(event, \"drag\", dd);\n            if (dd.propagates) {\n              // manage drop events\n              if (dd.drop !== false && $special.drop) $special.drop.handler(event, dd); // \"dropstart\", \"dropend\"\n              break; // \"drag\" not rejected, stop\n            }\n            event.type = \"mouseup\"; // helps \"drop\" handler behave\n          }\n        // mouseup, stop dragging\n        case 'touchend':\n        case 'mouseup':\n        default:\n          if (drag.touched) $event.remove(drag.touched, \"touchmove touchend\", drag.handler); // remove touch events\n          else $event.remove(document, \"mousemove mouseup\", drag.handler); // remove page events\n          if (dd.dragging) {\n            if (dd.drop !== false && $special.drop) $special.drop.handler(event, dd); // \"drop\"\n            drag.hijack(event, \"dragend\", dd); // trigger \"dragend\"\n          }\n          drag.textselect(true); // enable text selection\n          // if suppressing click events...\n          if (dd.click === false && dd.dragging) $.data(dd.mousedown, \"suppress.click\", new Date().getTime() + 5);\n          dd.dragging = drag.touched = false; // deactivate element\n          break;\n      }\n    },\n\n    // re-use event object for custom events\n    hijack: function hijack(event, type, dd, x, elem) {\n      // not configured\n      if (!dd) return;\n      // remember the original event and type\n      var orig = { event: event.originalEvent, type: event.type },\n\n      // is the event drag related or drog related?\n      mode = type.indexOf(\"drop\") ? \"drag\" : \"drop\",\n\n      // iteration vars\n      result,\n          i = x || 0,\n          ia,\n          $elems,\n          callback,\n          len = !isNaN(x) ? x : dd.interactions.length;\n      // modify the event type\n      event.type = type;\n      // protects originalEvent from side-effects\n      var noop = function noop() {};\n      event.originalEvent = new jQuery.Event(orig.event, {\n        preventDefault: noop,\n        stopPropagation: noop,\n        stopImmediatePropagation: noop\n      });\n      // initialize the results\n      dd.results = [];\n      // handle each interacted element\n      do {\n        if (ia = dd.interactions[i]) {\n          // validate the interaction\n          if (type !== \"dragend\" && ia.cancelled) continue;\n          // set the dragdrop properties on the event object\n          callback = drag.properties(event, dd, ia);\n          // prepare for more results\n          ia.results = [];\n          // handle each element\n          $(elem || ia[mode] || dd.droppable).each(function (p, subject) {\n            // identify drag or drop targets individually\n            callback.target = subject;\n            // force propagtion of the custom event\n            event.isPropagationStopped = function () {\n              return false;\n            };\n            // handle the event\n            result = subject ? $event.dispatch.call(subject, event, callback) : null;\n            // stop the drag interaction for this element\n            if (result === false) {\n              if (mode == \"drag\") {\n                ia.cancelled = true;\n                dd.propagates -= 1;\n              }\n              if (type == \"drop\") {\n                ia[mode][p] = null;\n              }\n            }\n            // assign any dropinit elements\n            else if (type == \"dropinit\") ia.droppable.push(drag.element(result) || subject);\n            // accept a returned proxy element\n            if (type == \"dragstart\") ia.proxy = $(drag.element(result) || ia.drag)[0];\n            // remember this result\n            ia.results.push(result);\n            // forget the event result, for recycling\n            delete event.result;\n            // break on cancelled handler\n            if (type !== \"dropinit\") return result;\n          });\n          // flatten the results\n          dd.results[i] = drag.flatten(ia.results);\n          // accept a set of valid drop targets\n          if (type == \"dropinit\") ia.droppable = drag.flatten(ia.droppable);\n          // locate drop targets\n          if (type == \"dragstart\" && !ia.cancelled) callback.update();\n        }\n      } while (++i < len);\n      // restore the original event & type\n      event.type = orig.type;\n      event.originalEvent = orig.event;\n      // return all handler results\n      return drag.flatten(dd.results);\n    },\n\n    // extend the callback object with drag/drop properties...\n    properties: function properties(event, dd, ia) {\n      var obj = ia.callback;\n      // elements\n      obj.drag = ia.drag;\n      obj.proxy = ia.proxy || ia.drag;\n      // starting mouse position\n      obj.startX = dd.pageX;\n      obj.startY = dd.pageY;\n      // current distance dragged\n      obj.deltaX = event.pageX - dd.pageX;\n      obj.deltaY = event.pageY - dd.pageY;\n      // original element position\n      obj.originalX = ia.offset.left;\n      obj.originalY = ia.offset.top;\n      // adjusted element position\n      obj.offsetX = obj.originalX + obj.deltaX;\n      obj.offsetY = obj.originalY + obj.deltaY;\n      // assign the drop targets information\n      obj.drop = drag.flatten((ia.drop || []).slice());\n      obj.available = drag.flatten((ia.droppable || []).slice());\n      return obj;\n    },\n\n    // determine is the argument is an element or jquery instance\n    element: function element(arg) {\n      if (arg && (arg.jquery || arg.nodeType == 1)) return arg;\n    },\n\n    // flatten nested jquery objects and arrays into a single dimension array\n    flatten: function flatten(arr) {\n      return $.map(arr, function (member) {\n        return member && member.jquery ? $.makeArray(member) : member && member.length ? drag.flatten(member) : member;\n      });\n    },\n\n    // toggles text selection attributes ON (true) or OFF (false)\n    textselect: function textselect(bool) {\n      $(document)[bool ? \"off\" : \"on\"](\"selectstart\", drag.dontstart).css(\"MozUserSelect\", bool ? \"\" : \"none\");\n      // .attr(\"unselectable\", bool ? \"off\" : \"on\" )\n      document.unselectable = bool ? \"off\" : \"on\";\n    },\n\n    // suppress \"selectstart\" and \"ondragstart\" events\n    dontstart: function dontstart() {\n      return false;\n    },\n\n    // a callback instance contructor\n    callback: function callback() {}\n\n  };\n\n  // callback methods\n  drag.callback.prototype = {\n    update: function update() {\n      if ($special.drop && this.available.length) $.each(this.available, function (i) {\n        $special.drop.locate(this, i);\n      });\n    }\n  };\n\n  // patch $.event.$dispatch to allow suppressing clicks\n  var $dispatch = $event.dispatch;\n  $event.dispatch = function (event) {\n    if ($.data(this, \"suppress.\" + event.type) - new Date().getTime() > 0) {\n      $.removeData(this, \"suppress.\" + event.type);\n      return;\n    }\n    return $dispatch.apply(this, arguments);\n  };\n\n  // share the same special event configuration with related events...\n  $special.draginit = $special.dragstart = $special.dragend = drag;\n})(jQuery);\n\n/***\r\n * Contains core SlickGrid classes.\r\n * @module Core\r\n * @namespace Slick\r\n */\n//import $ from 'jquery'\n//let jQuery=$;\n//import 'jquery-ui'\n\n\n/***\r\n * An event object for passing data to event handlers and letting them control propagation.\r\n * <p>This is pretty much identical to how W3C and jQuery implement events.</p>\r\n * @class EventData\r\n * @constructor\r\n */\nfunction EventData() {\n  var isPropagationStopped = false;\n  var isImmediatePropagationStopped = false;\n\n  /***\r\n   * Stops event from propagating up the DOM tree.\r\n   * @method stopPropagation\r\n   */\n  this.stopPropagation = function () {\n    isPropagationStopped = true;\n  };\n\n  /***\r\n   * Returns whether stopPropagation was called on this event object.\r\n   * @method isPropagationStopped\r\n   * @return {Boolean}\r\n   */\n  this.isPropagationStopped = function () {\n    return isPropagationStopped;\n  };\n\n  /***\r\n   * Prevents the rest of the handlers from being executed.\r\n   * @method stopImmediatePropagation\r\n   */\n  this.stopImmediatePropagation = function () {\n    isImmediatePropagationStopped = true;\n  };\n\n  /***\r\n   * Returns whether stopImmediatePropagation was called on this event object.\\\r\n   * @method isImmediatePropagationStopped\r\n   * @return {Boolean}\r\n   */\n  this.isImmediatePropagationStopped = function () {\n    return isImmediatePropagationStopped;\n  };\n}\n\n/***\r\n * A simple publisher-subscriber implementation.\r\n * @class Event\r\n * @constructor\r\n */\nfunction Event() {\n  var handlers = [];\n\n  /***\r\n   * Adds an event handler to be called when the event is fired.\r\n   * <p>Event handler will receive two arguments - an <code>EventData</code> and the <code>data</code>\r\n   * object the event was fired with.<p>\r\n   * @method subscribe\r\n   * @param fn {Function} Event handler.\r\n   */\n  this.subscribe = function (fn) {\n    handlers.push(fn);\n  };\n\n  /***\r\n   * Removes an event handler added with <code>subscribe(fn)</code>.\r\n   * @method unsubscribe\r\n   * @param fn {Function} Event handler to be removed.\r\n   */\n  this.unsubscribe = function (fn) {\n    for (var i = handlers.length - 1; i >= 0; i--) {\n      if (handlers[i] === fn) {\n        handlers.splice(i, 1);\n      }\n    }\n  };\n\n  /***\r\n   * Fires an event notifying all subscribers.\r\n   * @method notify\r\n   * @param args {Object} Additional data object to be passed to all handlers.\r\n   * @param e {EventData}\r\n   *      Optional.\r\n   *      An <code>EventData</code> object to be passed to all handlers.\r\n   *      For DOM events, an existing W3C/jQuery event object can be passed in.\r\n   * @param scope {Object}\r\n   *      Optional.\r\n   *      The scope (\"this\") within which the handler will be executed.\r\n   *      If not specified, the scope will be set to the <code>Event</code> instance.\r\n   */\n  this.notify = function (args, e, scope) {\n    e = e || new EventData();\n    scope = scope || this;\n\n    var returnValue;\n    for (var i = 0; i < handlers.length && !(e.isPropagationStopped() || e.isImmediatePropagationStopped()); i++) {\n      returnValue = handlers[i].call(scope, e, args);\n    }\n\n    return returnValue;\n  };\n}\n\nfunction EventHandler() {\n  var handlers = [];\n\n  this.subscribe = function (event, handler) {\n    handlers.push({\n      event: event,\n      handler: handler\n    });\n    event.subscribe(handler);\n\n    return this; // allow chaining\n  };\n\n  this.unsubscribe = function (event, handler) {\n    var i = handlers.length;\n    while (i--) {\n      if (handlers[i].event === event && handlers[i].handler === handler) {\n        handlers.splice(i, 1);\n        event.unsubscribe(handler);\n        return;\n      }\n    }\n\n    return this; // allow chaining\n  };\n\n  this.unsubscribeAll = function () {\n    var i = handlers.length;\n    while (i--) {\n      handlers[i].event.unsubscribe(handlers[i].handler);\n    }\n    handlers = [];\n\n    return this; // allow chaining\n  };\n}\n\n/***\r\n * A structure containing a range of cells.\r\n * @class Range\r\n * @constructor\r\n * @param fromRow {Integer} Starting row.\r\n * @param fromCell {Integer} Starting cell.\r\n * @param toRow {Integer} Optional. Ending row. Defaults to <code>fromRow</code>.\r\n * @param toCell {Integer} Optional. Ending cell. Defaults to <code>fromCell</code>.\r\n */\nfunction Range(fromRow, fromCell, toRow, toCell) {\n  if (toRow === undefined && toCell === undefined) {\n    toRow = fromRow;\n    toCell = fromCell;\n  }\n\n  /***\r\n   * @property fromRow\r\n   * @type {Integer}\r\n   */\n  this.fromRow = Math.min(fromRow, toRow);\n\n  /***\r\n   * @property fromCell\r\n   * @type {Integer}\r\n   */\n  this.fromCell = Math.min(fromCell, toCell);\n\n  /***\r\n   * @property toRow\r\n   * @type {Integer}\r\n   */\n  this.toRow = Math.max(fromRow, toRow);\n\n  /***\r\n   * @property toCell\r\n   * @type {Integer}\r\n   */\n  this.toCell = Math.max(fromCell, toCell);\n\n  /***\r\n   * Returns whether a range represents a single row.\r\n   * @method isSingleRow\r\n   * @return {Boolean}\r\n   */\n  this.isSingleRow = function () {\n    return this.fromRow == this.toRow;\n  };\n\n  /***\r\n   * Returns whether a range represents a single cell.\r\n   * @method isSingleCell\r\n   * @return {Boolean}\r\n   */\n  this.isSingleCell = function () {\n    return this.fromRow == this.toRow && this.fromCell == this.toCell;\n  };\n\n  /***\r\n   * Returns whether a range contains a given cell.\r\n   * @method contains\r\n   * @param row {Integer}\r\n   * @param cell {Integer}\r\n   * @return {Boolean}\r\n   */\n  this.contains = function (row, cell) {\n    return row >= this.fromRow && row <= this.toRow && cell >= this.fromCell && cell <= this.toCell;\n  };\n\n  /***\r\n   * Returns a readable representation of a range.\r\n   * @method toString\r\n   * @return {String}\r\n   */\n  this.toString = function () {\n    if (this.isSingleCell()) {\n      return \"(\" + this.fromRow + \":\" + this.fromCell + \")\";\n    } else {\n      return \"(\" + this.fromRow + \":\" + this.fromCell + \" - \" + this.toRow + \":\" + this.toCell + \")\";\n    }\n  };\n}\n\n/***\r\n * A base class that all special / non-data rows (like Group and GroupTotals) derive from.\r\n * @class NonDataItem\r\n * @constructor\r\n */\nfunction NonDataItem() {\n  this.__nonDataRow = true;\n}\n\n/***\r\n * Information about a group of rows.\r\n * @class Group\r\n * @extends Slick.NonDataItem\r\n * @constructor\r\n */\nfunction Group() {\n  this.__group = true;\n\n  /**\r\n   * Grouping level, starting with 0.\r\n   * @property level\r\n   * @type {Number}\r\n   */\n  this.level = 0;\n\n  /***\r\n   * Number of rows in the group.\r\n   * @property count\r\n   * @type {Integer}\r\n   */\n  this.count = 0;\n\n  /***\r\n   * Grouping value.\r\n   * @property value\r\n   * @type {Object}\r\n   */\n  this.value = null;\n\n  /***\r\n   * Formatted display value of the group.\r\n   * @property title\r\n   * @type {String}\r\n   */\n  this.title = null;\n\n  /***\r\n   * Whether a group is collapsed.\r\n   * @property collapsed\r\n   * @type {Boolean}\r\n   */\n  this.collapsed = false;\n\n  /***\r\n   * Whether a group selection checkbox is checked.\r\n   * @property selectChecked\r\n   * @type {Boolean}\r\n   */\n  this.selectChecked = false;\n\n  /***\r\n   * GroupTotals, if any.\r\n   * @property totals\r\n   * @type {GroupTotals}\r\n   */\n  this.totals = null;\n\n  /**\r\n   * Rows that are part of the group.\r\n   * @property rows\r\n   * @type {Array}\r\n   */\n  this.rows = [];\n\n  /**\r\n   * Sub-groups that are part of the group.\r\n   * @property groups\r\n   * @type {Array}\r\n   */\n  this.groups = null;\n\n  /**\r\n   * A unique key used to identify the group.  This key can be used in calls to DataView\r\n   * collapseGroup() or expandGroup().\r\n   * @property groupingKey\r\n   * @type {Object}\r\n   */\n  this.groupingKey = null;\n}\n\nGroup.prototype = new NonDataItem();\n\n/***\r\n * Compares two Group instances.\r\n * @method equals\r\n * @return {Boolean}\r\n * @param group {Group} Group instance to compare to.\r\n */\nGroup.prototype.equals = function (group) {\n  return this.value === group.value && this.count === group.count && this.collapsed === group.collapsed && this.title === group.title;\n};\n\n/***\r\n * Information about group totals.\r\n * An instance of GroupTotals will be created for each totals row and passed to the aggregators\r\n * so that they can store arbitrary data in it.  That data can later be accessed by group totals\r\n * formatters during the display.\r\n * @class GroupTotals\r\n * @extends Slick.NonDataItem\r\n * @constructor\r\n */\nfunction GroupTotals() {\n  this.__groupTotals = true;\n\n  /***\r\n   * Parent Group.\r\n   * @param group\r\n   * @type {Group}\r\n   */\n  this.group = null;\n\n  /***\r\n   * Whether the totals have been fully initialized / calculated.\r\n   * Will be set to false for lazy-calculated group totals.\r\n   * @param initialized\r\n   * @type {Boolean}\r\n   */\n  this.initialized = false;\n}\n\nGroupTotals.prototype = new NonDataItem();\n\n/***\r\n * A locking helper to track the active edit controller and ensure that only a single controller\r\n * can be active at a time.  This prevents a whole class of state and validation synchronization\r\n * issues.  An edit controller (such as SlickGrid) can query if an active edit is in progress\r\n * and attempt a commit or cancel before proceeding.\r\n * @class EditorLock\r\n * @constructor\r\n */\nfunction EditorLock() {\n  var activeEditController = null;\n\n  /***\r\n   * Returns true if a specified edit controller is active (has the edit lock).\r\n   * If the parameter is not specified, returns true if any edit controller is active.\r\n   * @method isActive\r\n   * @param editController {EditController}\r\n   * @return {Boolean}\r\n   */\n  this.isActive = function (editController) {\n    return editController ? activeEditController === editController : activeEditController !== null;\n  };\n\n  /***\r\n   * Sets the specified edit controller as the active edit controller (acquire edit lock).\r\n   * If another edit controller is already active, and exception will be throw new Error(.\r\n   * @method activate\r\n   * @param editController {EditController} edit controller acquiring the lock\r\n   */\n  this.activate = function (editController) {\n    if (editController === activeEditController) {\n      // already activated?\n      return;\n    }\n    if (activeEditController !== null) {\n      throw new Error(\"SlickGrid.EditorLock.activate: an editController is still active, can't activate another editController\");\n    }\n    if (!editController.commitCurrentEdit) {\n      throw new Error(\"SlickGrid.EditorLock.activate: editController must implement .commitCurrentEdit()\");\n    }\n    if (!editController.cancelCurrentEdit) {\n      throw new Error(\"SlickGrid.EditorLock.activate: editController must implement .cancelCurrentEdit()\");\n    }\n    activeEditController = editController;\n  };\n\n  /***\r\n   * Unsets the specified edit controller as the active edit controller (release edit lock).\r\n   * If the specified edit controller is not the active one, an exception will be throw new Error(.\r\n   * @method deactivate\r\n   * @param editController {EditController} edit controller releasing the lock\r\n   */\n  this.deactivate = function (editController) {\n    if (activeEditController !== editController) {\n      throw new Error(\"SlickGrid.EditorLock.deactivate: specified editController is not the currently active one\");\n    }\n    activeEditController = null;\n  };\n\n  /***\r\n   * Attempts to commit the current edit by calling \"commitCurrentEdit\" method on the active edit\r\n   * controller and returns whether the commit attempt was successful (commit may fail due to validation\r\n   * errors, etc.).  Edit controller's \"commitCurrentEdit\" must return true if the commit has succeeded\r\n   * and false otherwise.  If no edit controller is active, returns true.\r\n   * @method commitCurrentEdit\r\n   * @return {Boolean}\r\n   */\n  this.commitCurrentEdit = function () {\n    return activeEditController ? activeEditController.commitCurrentEdit() : true;\n  };\n\n  /***\r\n   * Attempts to cancel the current edit by calling \"cancelCurrentEdit\" method on the active edit\r\n   * controller and returns whether the edit was successfully cancelled.  If no edit controller is\r\n   * active, returns true.\r\n   * @method cancelCurrentEdit\r\n   * @return {Boolean}\r\n   */\n  this.cancelCurrentEdit = function cancelCurrentEdit() {\n    return activeEditController ? activeEditController.cancelCurrentEdit() : true;\n  };\n}\n\nvar Slick = {\n  \"Event\": Event,\n  \"EventData\": EventData,\n  \"EventHandler\": EventHandler,\n  \"Range\": Range,\n  \"NonDataRow\": NonDataItem,\n  \"Group\": Group,\n  \"GroupTotals\": GroupTotals,\n  \"EditorLock\": EditorLock,\n\n  /***\r\n   * A global singleton editor lock.\r\n   * @class GlobalEditorLock\r\n   * @static\r\n   * @constructor\r\n   */\n  \"GlobalEditorLock\": new EditorLock(),\n\n  \"keyCode\": {\n    BACKSPACE: 8,\n    DELETE: 46,\n    DOWN: 40,\n    END: 35,\n    ENTER: 13,\n    ESCAPE: 27,\n    HOME: 36,\n    INSERT: 45,\n    LEFT: 37,\n    PAGE_DOWN: 34,\n    PAGE_UP: 33,\n    RIGHT: 39,\n    TAB: 9,\n    UP: 38,\n    A: 65\n  },\n  \"preClickClassName\": \"slick-edit-preclick\"\n};\n\n/**\r\n * @license\r\n * (c) 2009-2016 Michael Leibman\r\n * michael{dot}leibman{at}gmail{dot}com\r\n * http://github.com/mleibman/slickgrid\r\n *\r\n * Distributed under MIT license.\r\n * All rights reserved.\r\n *\r\n * SlickGrid v2.3\r\n *\r\n * NOTES:\r\n *     Cell/row DOM manipulations are done directly bypassing jQuery's DOM manipulation methods.\r\n *     This increases the speed dramatically, but can only be done safely because there are no event handlers\r\n *     or data associated with any cell/row DOM nodes.  Cell editors must make sure they implement .destroy()\r\n *     and do proper cleanup.\r\n */\n\n// make sure required JavaScript modules are loaded\n\n\nif (typeof jQuery === \"undefined\") {\n  throw new Error(\"SlickGrid requires jquery module to be loaded\");\n}\nif (!jQuery.fn.drag) {\n  throw new Error(\"SlickGrid requires jquery.event.drag module to be loaded\");\n}\nif (typeof Slick === \"undefined\") {\n  throw new Error(\"slick.core.js not loaded\");\n}\n\n// shared across all grids on the page\nvar scrollbarDimensions;\nvar maxSupportedCssHeight; // browser's breaking point\n\n//////////////////////////////////////////////////////////////////////////////////////////////\n// SlickGrid class implementation (available as Slick.Grid)\n\n/**\r\n * Creates a new instance of the grid.\r\n * @class SlickGrid\r\n * @constructor\r\n * @param {Node}              container   Container node to create the grid in.\r\n * @param {Array,Object}      data        An array of objects for databinding.\r\n * @param {Array}             columns     An array of column definitions.\r\n * @param {Object}            options     Grid options.\r\n **/\nfunction SlickGrid(container, data, columns, options) {\n  // settings\n  var defaults = {\n    alwaysShowVerticalScroll: false,\n    explicitInitialization: false,\n    rowHeight: 25,\n    defaultColumnWidth: 80,\n    enableAddRow: false,\n    leaveSpaceForNewRows: false,\n    editable: false,\n    autoEdit: true,\n    suppressActiveCellChangeOnEdit: false,\n    enableCellNavigation: true,\n    enableColumnReorder: true,\n    asyncEditorLoading: false,\n    asyncEditorLoadDelay: 100,\n    forceFitColumns: false,\n    enableAsyncPostRender: false,\n    asyncPostRenderDelay: 50,\n    enableAsyncPostRenderCleanup: false,\n    asyncPostRenderCleanupDelay: 40,\n    autoHeight: false,\n    editorLock: Slick.GlobalEditorLock,\n    showHeaderRow: false,\n    headerRowHeight: 25,\n    createFooterRow: false,\n    showFooterRow: false,\n    footerRowHeight: 25,\n    createPreHeaderPanel: false,\n    showPreHeaderPanel: false,\n    preHeaderPanelHeight: 25,\n    showTopPanel: false,\n    topPanelHeight: 25,\n    formatterFactory: null,\n    editorFactory: null,\n    cellFlashingCssClass: \"flashing\",\n    selectedCellCssClass: \"selected\",\n    multiSelect: true,\n    enableTextSelectionOnCells: false,\n    dataItemColumnValueExtractor: null,\n    fullWidthRows: false,\n    multiColumnSort: false,\n    numberedMultiColumnSort: false,\n    tristateMultiColumnSort: false,\n    sortColNumberInSeparateSpan: false,\n    defaultFormatter: defaultFormatter,\n    forceSyncScrolling: false,\n    addNewRowCssClass: \"new-row\",\n    preserveCopiedSelectionOnPaste: false,\n    showCellSelection: true,\n    viewportClass: null,\n    minRowBuffer: 3,\n    emulatePagingWhenScrolling: true, // when scrolling off bottom of viewport, place new row at top of viewport\n    editorCellNavOnLRKeys: false\n  };\n\n  var columnDefaults = {\n    name: \"\",\n    resizable: true,\n    sortable: false,\n    minWidth: 30,\n    rerenderOnResize: false,\n    headerCssClass: null,\n    defaultSortAsc: true,\n    focusable: true,\n    selectable: true\n  };\n\n  // scroller\n  var th; // virtual height\n  var h; // real scrollable height\n  var ph; // page height\n  var n; // number of pages\n  var cj; // \"jumpiness\" coefficient\n\n  var page = 0; // current page\n  var offset = 0; // current page offset\n  var vScrollDir = 1;\n\n  // private\n  var initialized = false;\n  var $container;\n  var uid = \"slickgrid_\" + Math.round(1000000 * Math.random());\n  var self = this;\n  var $focusSink, $focusSink2;\n  var $headerScroller;\n  var $headers;\n  var $headerRow, $headerRowScroller, $headerRowSpacer;\n  var $footerRow, $footerRowScroller, $footerRowSpacer;\n  var $preHeaderPanel, $preHeaderPanelScroller, $preHeaderPanelSpacer;\n  var $topPanelScroller;\n  var $topPanel;\n  var $viewport;\n  var $canvas;\n  var $style;\n  var $boundAncestors;\n  var stylesheet, columnCssRulesL, columnCssRulesR;\n  var viewportH, viewportW;\n  var canvasWidth;\n  var viewportHasHScroll, viewportHasVScroll;\n  var headerColumnWidthDiff = 0,\n      headerColumnHeightDiff = 0,\n      // border+padding\n  cellWidthDiff = 0,\n      cellHeightDiff = 0,\n      jQueryNewWidthBehaviour = false;\n  var absoluteColumnMinWidth;\n\n  var tabbingDirection = 1;\n  var activePosX;\n  var activeRow, activeCell;\n  var activeCellNode = null;\n  var currentEditor = null;\n  var serializedEditorValue;\n  var editController;\n\n  var rowsCache = {};\n  var renderedRows = 0;\n  var numVisibleRows;\n  var prevScrollTop = 0;\n  var scrollTop = 0;\n  var lastRenderedScrollTop = 0;\n  var lastRenderedScrollLeft = 0;\n  var prevScrollLeft = 0;\n  var scrollLeft = 0;\n\n  var selectionModel;\n  var selectedRows = [];\n\n  var plugins = [];\n  var cellCssClasses = {};\n\n  var columnsById = {};\n  var sortColumns = [];\n  var columnPosLeft = [];\n  var columnPosRight = [];\n\n  var pagingActive = false;\n  var pagingIsLastPage = false;\n\n  // async call handles\n  var h_editorLoader = null;\n  var h_render = null;\n  var h_postrender = null;\n  var h_postrenderCleanup = null;\n  var postProcessedRows = {};\n  var postProcessToRow = null;\n  var postProcessFromRow = null;\n  var postProcessedCleanupQueue = [];\n  var postProcessgroupId = 0;\n\n  // perf counters\n  var counter_rows_rendered = 0;\n  var counter_rows_removed = 0;\n\n  // These two variables work around a bug with inertial scrolling in Webkit/Blink on Mac.\n  // See http://crbug.com/312427.\n  var rowNodeFromLastMouseWheelEvent; // this node must not be deleted while inertial scrolling\n  var zombieRowNodeFromLastMouseWheelEvent; // node that was hidden instead of getting deleted\n  var zombieRowCacheFromLastMouseWheelEvent; // row cache for above node\n  var zombieRowPostProcessedFromLastMouseWheelEvent; // post processing references for above node\n\n  // store css attributes if display:none is active in container or parent\n  var cssShow = { position: 'absolute', visibility: 'hidden', display: 'block' };\n  var $hiddenParents;\n  var oldProps = [];\n  var columnResizeDragging = false;\n\n  //////////////////////////////////////////////////////////////////////////////////////////////\n  // Initialization\n\n  function init() {\n    if (container instanceof jQuery) {\n      $container = container;\n    } else {\n      $container = $(container);\n    }\n    if ($container.length < 1) {\n      throw new Error(\"SlickGrid requires a valid container, \" + container + \" does not exist in the DOM.\");\n    }\n\n    cacheCssForHiddenInit();\n\n    // calculate these only once and share between grid instances\n    maxSupportedCssHeight = maxSupportedCssHeight || getMaxSupportedCssHeight();\n\n    options = $.extend({}, defaults, options);\n    validateAndEnforceOptions();\n    columnDefaults.width = options.defaultColumnWidth;\n\n    columnsById = {};\n    for (var i = 0; i < columns.length; i++) {\n      var m = columns[i] = $.extend({}, columnDefaults, columns[i]);\n      columnsById[m.id] = i;\n      if (m.minWidth && m.width < m.minWidth) {\n        m.width = m.minWidth;\n      }\n      if (m.maxWidth && m.width > m.maxWidth) {\n        m.width = m.maxWidth;\n      }\n    }\n\n    // validate loaded JavaScript modules against requested options\n    if (options.enableColumnReorder && !$.fn.sortable) {\n      throw new Error(\"SlickGrid's 'enableColumnReorder = true' option requires jquery-ui.sortable module to be loaded\");\n    }\n\n    editController = {\n      \"commitCurrentEdit\": commitCurrentEdit,\n      \"cancelCurrentEdit\": cancelCurrentEdit\n    };\n\n    $container.empty().css(\"overflow\", \"hidden\").css(\"outline\", 0).addClass(uid).addClass(\"ui-widget\");\n\n    // set up a positioning container if needed\n    if (!/relative|absolute|fixed/.test($container.css(\"position\"))) {\n      $container.css(\"position\", \"relative\");\n    }\n\n    $focusSink = $(\"<div tabIndex='0' hideFocus style='position:fixed;width:0;height:0;top:0;left:0;outline:0;'></div>\").appendTo($container);\n\n    if (options.createPreHeaderPanel) {\n      $preHeaderPanelScroller = $(\"<div class='slick-preheader-panel ui-state-default' style='overflow:hidden;position:relative;' />\").appendTo($container);\n      $preHeaderPanel = $(\"<div />\").appendTo($preHeaderPanelScroller);\n      $preHeaderPanelSpacer = $(\"<div style='display:block;height:1px;position:absolute;top:0;left:0;'></div>\").appendTo($preHeaderPanelScroller);\n\n      if (!options.showPreHeaderPanel) {\n        $preHeaderPanelScroller.hide();\n      }\n    }\n\n    $headerScroller = $(\"<div class='slick-header ui-state-default' />\").appendTo($container);\n    $headers = $(\"<div class='slick-header-columns' style='left:-1000px' />\").appendTo($headerScroller);\n\n    $headerRowScroller = $(\"<div class='slick-headerrow ui-state-default' />\").appendTo($container);\n    $headerRow = $(\"<div class='slick-headerrow-columns' />\").appendTo($headerRowScroller);\n    $headerRowSpacer = $(\"<div style='display:block;height:1px;position:absolute;top:0;left:0;'></div>\").appendTo($headerRowScroller);\n\n    $topPanelScroller = $(\"<div class='slick-top-panel-scroller ui-state-default' />\").appendTo($container);\n    $topPanel = $(\"<div class='slick-top-panel' style='width:10000px' />\").appendTo($topPanelScroller);\n\n    if (!options.showTopPanel) {\n      $topPanelScroller.hide();\n    }\n\n    if (!options.showHeaderRow) {\n      $headerRowScroller.hide();\n    }\n\n    $viewport = $(\"<div class='slick-viewport' style='width:100%;overflow:auto;outline:0;position:relative;;'>\").appendTo($container);\n    $viewport.css(\"overflow-y\", options.alwaysShowVerticalScroll ? \"scroll\" : options.autoHeight ? \"hidden\" : \"auto\");\n    $viewport.css(\"overflow-x\", options.forceFitColumns ? \"hidden\" : \"auto\");\n    if (options.viewportClass) $viewport.toggleClass(options.viewportClass, true);\n\n    $canvas = $(\"<div class='grid-canvas' />\").appendTo($viewport);\n\n    scrollbarDimensions = scrollbarDimensions || measureScrollbar();\n\n    if ($preHeaderPanelSpacer) $preHeaderPanelSpacer.css(\"width\", getCanvasWidth() + scrollbarDimensions.width + \"px\");\n    $headers.width(getHeadersWidth());\n    $headerRowSpacer.css(\"width\", getCanvasWidth() + scrollbarDimensions.width + \"px\");\n\n    if (options.createFooterRow) {\n      $footerRowScroller = $(\"<div class='slick-footerrow ui-state-default' />\").appendTo($container);\n      $footerRow = $(\"<div class='slick-footerrow-columns' />\").appendTo($footerRowScroller);\n      $footerRowSpacer = $(\"<div style='display:block;height:1px;position:absolute;top:0;left:0;'></div>\").css(\"width\", getCanvasWidth() + scrollbarDimensions.width + \"px\").appendTo($footerRowScroller);\n\n      if (!options.showFooterRow) {\n        $footerRowScroller.hide();\n      }\n    }\n\n    $focusSink2 = $focusSink.clone().appendTo($container);\n\n    if (!options.explicitInitialization) {\n      finishInitialization();\n    }\n  }\n\n  function finishInitialization() {\n    if (!initialized) {\n      initialized = true;\n\n      viewportW = parseFloat($.css($container[0], \"width\", true));\n\n      // header columns and cells may have different padding/border skewing width calculations (box-sizing, hello?)\n      // calculate the diff so we can set consistent sizes\n      measureCellPaddingAndBorder();\n\n      // for usability reasons, all text selection in SlickGrid is disabled\n      // with the exception of input and textarea elements (selection must\n      // be enabled there so that editors work as expected); note that\n      // selection in grid cells (grid body) is already unavailable in\n      // all browsers except IE\n      disableSelection($headers); // disable all text selection in header (including input and textarea)\n\n      if (!options.enableTextSelectionOnCells) {\n        // disable text selection in grid cells except in input and textarea elements\n        // (this is IE-specific, because selectstart event will only fire in IE)\n        $viewport.on(\"selectstart.ui\", function (event) {\n          return $(event.target).is(\"input,textarea\");\n        });\n      }\n\n      updateColumnCaches();\n      createColumnHeaders();\n      setupColumnSort();\n      createCssRules();\n      resizeCanvas();\n      bindAncestorScrollEvents();\n\n      $container.on(\"resize.slickgrid\", resizeCanvas);\n      $viewport\n      //.on(\"click\", handleClick)\n      .on(\"scroll\", handleScroll);\n      $headerScroller\n      //.on(\"scroll\", handleHeaderScroll)\n      .on(\"contextmenu\", handleHeaderContextMenu).on(\"click\", handleHeaderClick).on(\"mouseenter\", \".slick-header-column\", handleHeaderMouseEnter).on(\"mouseleave\", \".slick-header-column\", handleHeaderMouseLeave);\n      $headerRowScroller.on(\"scroll\", handleHeaderRowScroll);\n\n      if (options.createFooterRow) {\n        $footerRowScroller.on(\"scroll\", handleFooterRowScroll);\n      }\n\n      if (options.createPreHeaderPanel) {\n        $preHeaderPanelScroller.on(\"scroll\", handlePreHeaderPanelScroll);\n      }\n\n      $focusSink.add($focusSink2).on(\"keydown\", handleKeyDown);\n      $canvas.on(\"keydown\", handleKeyDown).on(\"click\", handleClick).on(\"dblclick\", handleDblClick).on(\"contextmenu\", handleContextMenu).on(\"draginit\", handleDragInit).on(\"dragstart\", { distance: 3 }, handleDragStart).on(\"drag\", handleDrag).on(\"dragend\", handleDragEnd).on(\"mouseenter\", \".slick-cell\", handleMouseEnter).on(\"mouseleave\", \".slick-cell\", handleMouseLeave);\n\n      // Work around http://crbug.com/312427.\n      if (navigator.userAgent.toLowerCase().match(/webkit/) && navigator.userAgent.toLowerCase().match(/macintosh/)) {\n        $canvas.on(\"mousewheel\", handleMouseWheel);\n      }\n      restoreCssFromHiddenInit();\n    }\n  }\n\n  function cacheCssForHiddenInit() {\n    // handle display:none on container or container parents\n    $hiddenParents = $container.parents().addBack().not(':visible');\n    $hiddenParents.each(function () {\n      var old = {};\n      for (var name in cssShow) {\n        old[name] = this.style[name];\n        this.style[name] = cssShow[name];\n      }\n      oldProps.push(old);\n    });\n  }\n\n  function restoreCssFromHiddenInit() {\n    // finish handle display:none on container or container parents\n    // - put values back the way they were\n    $hiddenParents.each(function (i) {\n      var old = oldProps[i];\n      for (var name in cssShow) {\n        this.style[name] = old[name];\n      }\n    });\n  }\n\n  function registerPlugin(plugin) {\n    plugins.unshift(plugin);\n    plugin.init(self);\n  }\n\n  function unregisterPlugin(plugin) {\n    for (var i = plugins.length; i >= 0; i--) {\n      if (plugins[i] === plugin) {\n        if (plugins[i].destroy) {\n          plugins[i].destroy();\n        }\n        plugins.splice(i, 1);\n        break;\n      }\n    }\n  }\n\n  function setSelectionModel(model) {\n    if (selectionModel) {\n      selectionModel.onSelectedRangesChanged.unsubscribe(handleSelectedRangesChanged);\n      if (selectionModel.destroy) {\n        selectionModel.destroy();\n      }\n    }\n\n    selectionModel = model;\n    if (selectionModel) {\n      selectionModel.init(self);\n      selectionModel.onSelectedRangesChanged.subscribe(handleSelectedRangesChanged);\n    }\n  }\n\n  function getSelectionModel() {\n    return selectionModel;\n  }\n\n  function getCanvasNode() {\n    return $canvas[0];\n  }\n\n  function measureScrollbar() {\n    var $outerdiv = $('<div class=\"' + $viewport.className + '\" style=\"position:absolute; top:-10000px; left:-10000px; overflow:auto; width:100px; height:100px;\"></div>').appendTo($viewport);\n    var $innerdiv = $('<div style=\"width:200px; height:200px; overflow:auto;\"></div>').appendTo($outerdiv);\n    var dim = {\n      width: $outerdiv[0].offsetWidth - $outerdiv[0].clientWidth,\n      height: $outerdiv[0].offsetHeight - $outerdiv[0].clientHeight\n    };\n    $innerdiv.remove();\n    $outerdiv.remove();\n    return dim;\n  }\n\n  function getColumnTotalWidth(includeScrollbar) {\n    var totalWidth = 0;\n    for (var i = 0, ii = columns.length; i < ii; i++) {\n      var width = columns[i].width;\n      totalWidth += width;\n    }\n    if (includeScrollbar) {\n      totalWidth += scrollbarDimensions.width;\n    }\n    return totalWidth;\n  }\n\n  function getHeadersWidth() {\n    var headersWidth = getColumnTotalWidth(!options.autoHeight);\n    return Math.max(headersWidth, viewportW) + 1000;\n  }\n\n  function getCanvasWidth() {\n    var availableWidth = viewportHasVScroll ? viewportW - scrollbarDimensions.width : viewportW;\n    var rowWidth = 0;\n    var i = columns.length;\n    while (i--) {\n      rowWidth += columns[i].width;\n    }\n    return options.fullWidthRows ? Math.max(rowWidth, availableWidth) : rowWidth;\n  }\n\n  function updateCanvasWidth(forceColumnWidthsUpdate) {\n    var oldCanvasWidth = canvasWidth;\n    canvasWidth = getCanvasWidth();\n\n    if (canvasWidth != oldCanvasWidth) {\n      $canvas.width(canvasWidth);\n      $headerRow.width(canvasWidth);\n      if (options.createFooterRow) {\n        $footerRow.width(canvasWidth);\n      }\n      if (options.createPreHeaderPanel) {\n        $preHeaderPanel.width(canvasWidth);\n      }\n      $headers.width(getHeadersWidth());\n      viewportHasHScroll = canvasWidth > viewportW - scrollbarDimensions.width;\n    }\n\n    var w = canvasWidth + (viewportHasVScroll ? scrollbarDimensions.width : 0);\n    $headerRowSpacer.width(w);\n    if (options.createFooterRow) {\n      $footerRowSpacer.width(w);\n    }\n    if (options.createPreHeaderPanel) {\n      $preHeaderPanelSpacer.width(w);\n    }\n\n    if (canvasWidth != oldCanvasWidth || forceColumnWidthsUpdate) {\n      applyColumnWidths();\n    }\n  }\n\n  function disableSelection($target) {\n    if ($target && $target.jquery) {\n      $target.attr(\"unselectable\", \"on\").css(\"MozUserSelect\", \"none\").on(\"selectstart.ui\", function () {\n        return false;\n      }); // from jquery:ui.core.js 1.7.2\n    }\n  }\n\n  function getMaxSupportedCssHeight() {\n    var supportedHeight = 1000000;\n    // FF reports the height back but still renders blank after ~6M px\n    var testUpTo = navigator.userAgent.toLowerCase().match(/firefox/) ? 6000000 : 1000000000;\n    var div = $(\"<div style='display:none' />\").appendTo(document.body);\n\n    while (true) {\n      var test = supportedHeight * 2;\n      div.css(\"height\", test);\n      if (test > testUpTo || div.height() !== test) {\n        break;\n      } else {\n        supportedHeight = test;\n      }\n    }\n\n    div.remove();\n    return supportedHeight;\n  }\n\n  function getUID() {\n    return uid;\n  }\n\n  function getHeaderColumnWidthDiff() {\n    return headerColumnWidthDiff;\n  }\n\n  function getScrollbarDimensions() {\n    return scrollbarDimensions;\n  }\n\n  // TODO:  this is static.  need to handle page mutation.\n  function bindAncestorScrollEvents() {\n    var elem = $canvas[0];\n    while ((elem = elem.parentNode) != document.body && elem != null) {\n      // bind to scroll containers only\n      if (elem == $viewport[0] || elem.scrollWidth != elem.clientWidth || elem.scrollHeight != elem.clientHeight) {\n        var $elem = $(elem);\n        if (!$boundAncestors) {\n          $boundAncestors = $elem;\n        } else {\n          $boundAncestors = $boundAncestors.add($elem);\n        }\n        $elem.on(\"scroll.\" + uid, handleActiveCellPositionChange);\n      }\n    }\n  }\n\n  function unbindAncestorScrollEvents() {\n    if (!$boundAncestors) {\n      return;\n    }\n    $boundAncestors.off(\"scroll.\" + uid);\n    $boundAncestors = null;\n  }\n\n  function updateColumnHeader(columnId, title, toolTip) {\n    if (!initialized) {\n      return;\n    }\n    var idx = getColumnIndex(columnId);\n    if (idx == null) {\n      return;\n    }\n\n    var columnDef = columns[idx];\n    var $header = $headers.children().eq(idx);\n    if ($header) {\n      if (title !== undefined) {\n        columns[idx].name = title;\n      }\n      if (toolTip !== undefined) {\n        columns[idx].toolTip = toolTip;\n      }\n\n      trigger(self.onBeforeHeaderCellDestroy, {\n        \"node\": $header[0],\n        \"column\": columnDef,\n        \"grid\": self\n      });\n\n      $header.attr(\"title\", toolTip || \"\").children().eq(0).html(title);\n\n      trigger(self.onHeaderCellRendered, {\n        \"node\": $header[0],\n        \"column\": columnDef,\n        \"grid\": self\n      });\n    }\n  }\n\n  function getHeader() {\n    return $headers[0];\n  }\n\n  function getHeaderColumn(columnIdOrIdx) {\n    var idx = typeof columnIdOrIdx === \"number\" ? columnIdOrIdx : getColumnIndex(columnIdOrIdx);\n    var $rtn = $headers.children().eq(idx);\n    return $rtn && $rtn[0];\n  }\n\n  function getHeaderRow() {\n    return $headerRow[0];\n  }\n\n  function getFooterRow() {\n    return $footerRow[0];\n  }\n\n  function getPreHeaderPanel() {\n    return $preHeaderPanel[0];\n  }\n\n  function getHeaderRowColumn(columnIdOrIdx) {\n    var idx = typeof columnIdOrIdx === \"number\" ? columnIdOrIdx : getColumnIndex(columnIdOrIdx);\n    var $rtn = $headerRow.children().eq(idx);\n    return $rtn && $rtn[0];\n  }\n\n  function getFooterRowColumn(columnIdOrIdx) {\n    var idx = typeof columnIdOrIdx === \"number\" ? columnIdOrIdx : getColumnIndex(columnIdOrIdx);\n    var $rtn = $footerRow.children().eq(idx);\n    return $rtn && $rtn[0];\n  }\n\n  function createColumnHeaders() {\n    function onMouseEnter() {\n      $(this).addClass(\"ui-state-hover\");\n    }\n\n    function onMouseLeave() {\n      $(this).removeClass(\"ui-state-hover\");\n    }\n\n    $headers.find(\".slick-header-column\").each(function () {\n      var columnDef = $(this).data(\"column\");\n      if (columnDef) {\n        trigger(self.onBeforeHeaderCellDestroy, {\n          \"node\": this,\n          \"column\": columnDef,\n          \"grid\": self\n        });\n      }\n    });\n    $headers.empty();\n    $headers.width(getHeadersWidth());\n\n    $headerRow.find(\".slick-headerrow-column\").each(function () {\n      var columnDef = $(this).data(\"column\");\n      if (columnDef) {\n        trigger(self.onBeforeHeaderRowCellDestroy, {\n          \"node\": this,\n          \"column\": columnDef,\n          \"grid\": self\n        });\n      }\n    });\n    $headerRow.empty();\n\n    if (options.createFooterRow) {\n      $footerRow.find(\".slick-footerrow-column\").each(function () {\n        var columnDef = $(this).data(\"column\");\n        if (columnDef) {\n          trigger(self.onBeforeFooterRowCellDestroy, {\n            \"node\": this,\n            \"column\": columnDef\n          });\n        }\n      });\n      $footerRow.empty();\n    }\n\n    for (var i = 0; i < columns.length; i++) {\n      var m = columns[i];\n\n      var header = $(\"<div class='ui-state-default slick-header-column' />\").html(\"<span class='slick-column-name'>\" + m.name + \"</span>\").width(m.width - headerColumnWidthDiff).attr(\"id\", \"\" + uid + m.id).attr(\"title\", m.toolTip || \"\").data(\"column\", m).addClass(m.headerCssClass || \"\").appendTo($headers);\n\n      if (options.enableColumnReorder || m.sortable) {\n        header.on('mouseenter', onMouseEnter).on('mouseleave', onMouseLeave);\n      }\n\n      if (m.sortable) {\n        header.addClass(\"slick-header-sortable\");\n        header.append(\"<span class='slick-sort-indicator\" + (options.numberedMultiColumnSort && !options.sortColNumberInSeparateSpan ? \" slick-sort-indicator-numbered\" : \"\") + \"' />\");\n        if (options.numberedMultiColumnSort && options.sortColNumberInSeparateSpan) {\n          header.append(\"<span class='slick-sort-indicator-numbered' />\");\n        }\n      }\n\n      trigger(self.onHeaderCellRendered, {\n        \"node\": header[0],\n        \"column\": m,\n        \"grid\": self\n      });\n\n      if (options.showHeaderRow) {\n        var headerRowCell = $(\"<div class='ui-state-default slick-headerrow-column l\" + i + \" r\" + i + \"'></div>\").data(\"column\", m).appendTo($headerRow);\n\n        trigger(self.onHeaderRowCellRendered, {\n          \"node\": headerRowCell[0],\n          \"column\": m,\n          \"grid\": self\n        });\n      }\n      if (options.createFooterRow && options.showFooterRow) {\n        var footerRowCell = $(\"<div class='ui-state-default slick-footerrow-column l\" + i + \" r\" + i + \"'></div>\").data(\"column\", m).appendTo($footerRow);\n\n        trigger(self.onFooterRowCellRendered, {\n          \"node\": footerRowCell[0],\n          \"column\": m\n        });\n      }\n    }\n\n    setSortColumns(sortColumns);\n    setupColumnResize();\n    if (options.enableColumnReorder) {\n      if (typeof options.enableColumnReorder == 'function') {\n        options.enableColumnReorder(self, $headers, headerColumnWidthDiff, setColumns, setupColumnResize, columns, getColumnIndex, uid, trigger);\n      } else {\n        setupColumnReorder();\n      }\n    }\n  }\n\n  function setupColumnSort() {\n    $headers.click(function (e) {\n      if (columnResizeDragging) return;\n      // temporary workaround for a bug in jQuery 1.7.1 (http://bugs.jquery.com/ticket/11328)\n      e.metaKey = e.metaKey || e.ctrlKey;\n\n      if ($(e.target).hasClass(\"slick-resizable-handle\")) {\n        return;\n      }\n\n      var $col = $(e.target).closest(\".slick-header-column\");\n      if (!$col.length) {\n        return;\n      }\n\n      var column = $col.data(\"column\");\n      if (column.sortable) {\n        if (!getEditorLock().commitCurrentEdit()) {\n          return;\n        }\n\n        var sortColumn = null;\n        var i = 0;\n        for (; i < sortColumns.length; i++) {\n          if (sortColumns[i].columnId == column.id) {\n            sortColumn = sortColumns[i];\n            sortColumn.sortAsc = !sortColumn.sortAsc;\n            break;\n          }\n        }\n        var hadSortCol = !!sortColumn;\n\n        if (options.tristateMultiColumnSort) {\n          if (!sortColumn) {\n            sortColumn = { columnId: column.id, sortAsc: column.defaultSortAsc };\n          }\n          if (hadSortCol && sortColumn.sortAsc) {\n            // three state: remove sort rather than go back to ASC\n            sortColumns.splice(i, 1);\n            sortColumn = null;\n          }\n          if (!options.multiColumnSort) {\n            sortColumns = [];\n          }\n          if (sortColumn && (!hadSortCol || !options.multiColumnSort)) {\n            sortColumns.push(sortColumn);\n          }\n        } else {\n          // legacy behaviour\n          if (e.metaKey && options.multiColumnSort) {\n            if (sortColumn) {\n              sortColumns.splice(i, 1);\n            }\n          } else {\n            if (!e.shiftKey && !e.metaKey || !options.multiColumnSort) {\n              sortColumns = [];\n            }\n\n            if (!sortColumn) {\n              sortColumn = { columnId: column.id, sortAsc: column.defaultSortAsc };\n              sortColumns.push(sortColumn);\n            } else if (sortColumns.length == 0) {\n              sortColumns.push(sortColumn);\n            }\n          }\n        }\n\n        setSortColumns(sortColumns);\n\n        if (!options.multiColumnSort) {\n          trigger(self.onSort, {\n            multiColumnSort: false,\n            sortCol: sortColumns.length > 0 ? column : null,\n            sortAsc: sortColumns.length > 0 ? sortColumns[0].sortAsc : true,\n            grid: self }, e);\n        } else {\n          trigger(self.onSort, {\n            multiColumnSort: true,\n            sortCols: $.map(sortColumns, function (col) {\n              return { sortCol: columns[getColumnIndex(col.columnId)], sortAsc: col.sortAsc };\n            }),\n            grid: self }, e);\n        }\n      }\n    });\n  }\n\n  function setupColumnReorder() {\n    $headers.filter(\":ui-sortable\").sortable(\"destroy\");\n    $headers.sortable({\n      containment: \"parent\",\n      distance: 3,\n      axis: \"x\",\n      cursor: \"default\",\n      tolerance: \"intersection\",\n      helper: \"clone\",\n      placeholder: \"slick-sortable-placeholder ui-state-default slick-header-column\",\n      start: function start(e, ui) {\n        ui.placeholder.width(ui.helper.outerWidth() - headerColumnWidthDiff);\n        $(ui.helper).addClass(\"slick-header-column-active\");\n      },\n      beforeStop: function beforeStop(e, ui) {\n        $(ui.helper).removeClass(\"slick-header-column-active\");\n      },\n      stop: function stop(e) {\n        if (!getEditorLock().commitCurrentEdit()) {\n          $(this).sortable(\"cancel\");\n          return;\n        }\n\n        var reorderedIds = $headers.sortable(\"toArray\");\n        var reorderedColumns = [];\n        for (var i = 0; i < reorderedIds.length; i++) {\n          reorderedColumns.push(columns[getColumnIndex(reorderedIds[i].replace(uid, \"\"))]);\n        }\n        setColumns(reorderedColumns);\n\n        trigger(self.onColumnsReordered, { grid: self });\n        e.stopPropagation();\n        setupColumnResize();\n      }\n    });\n  }\n\n  function setupColumnResize() {\n    var $col, j, c, pageX, columnElements, minPageX, maxPageX, firstResizable, lastResizable;\n    columnElements = $headers.children();\n    columnElements.find(\".slick-resizable-handle\").remove();\n    columnElements.each(function (i, e) {\n      if (i >= columns.length) {\n        return;\n      }\n      if (columns[i].resizable) {\n        if (firstResizable === undefined) {\n          firstResizable = i;\n        }\n        lastResizable = i;\n      }\n    });\n    if (firstResizable === undefined) {\n      return;\n    }\n    columnElements.each(function (i, e) {\n      if (i >= columns.length) {\n        return;\n      }\n      if (i < firstResizable || options.forceFitColumns && i >= lastResizable) {\n        return;\n      }\n      $col = $(e);\n      $(\"<div class='slick-resizable-handle' />\").appendTo(e).on(\"dragstart\", function (e, dd) {\n        if (!getEditorLock().commitCurrentEdit()) {\n          return false;\n        }\n        pageX = e.pageX;\n        $(this).parent().addClass(\"slick-header-column-active\");\n        var shrinkLeewayOnRight = null,\n            stretchLeewayOnRight = null;\n        // lock each column's width option to current width\n        columnElements.each(function (i, e) {\n          if (i >= columns.length) {\n            return;\n          }\n          columns[i].previousWidth = $(e).outerWidth();\n        });\n        if (options.forceFitColumns) {\n          shrinkLeewayOnRight = 0;\n          stretchLeewayOnRight = 0;\n          // colums on right affect maxPageX/minPageX\n          for (j = i + 1; j < columns.length; j++) {\n            c = columns[j];\n            if (c.resizable) {\n              if (stretchLeewayOnRight !== null) {\n                if (c.maxWidth) {\n                  stretchLeewayOnRight += c.maxWidth - c.previousWidth;\n                } else {\n                  stretchLeewayOnRight = null;\n                }\n              }\n              shrinkLeewayOnRight += c.previousWidth - Math.max(c.minWidth || 0, absoluteColumnMinWidth);\n            }\n          }\n        }\n        var shrinkLeewayOnLeft = 0,\n            stretchLeewayOnLeft = 0;\n        for (j = 0; j <= i; j++) {\n          // columns on left only affect minPageX\n          c = columns[j];\n          if (c.resizable) {\n            if (stretchLeewayOnLeft !== null) {\n              if (c.maxWidth) {\n                stretchLeewayOnLeft += c.maxWidth - c.previousWidth;\n              } else {\n                stretchLeewayOnLeft = null;\n              }\n            }\n            shrinkLeewayOnLeft += c.previousWidth - Math.max(c.minWidth || 0, absoluteColumnMinWidth);\n          }\n        }\n        if (shrinkLeewayOnRight === null) {\n          shrinkLeewayOnRight = 100000;\n        }\n        if (shrinkLeewayOnLeft === null) {\n          shrinkLeewayOnLeft = 100000;\n        }\n        if (stretchLeewayOnRight === null) {\n          stretchLeewayOnRight = 100000;\n        }\n        if (stretchLeewayOnLeft === null) {\n          stretchLeewayOnLeft = 100000;\n        }\n        maxPageX = pageX + Math.min(shrinkLeewayOnRight, stretchLeewayOnLeft);\n        minPageX = pageX - Math.min(shrinkLeewayOnLeft, stretchLeewayOnRight);\n      }).on(\"drag\", function (e, dd) {\n        columnResizeDragging = true;\n        var actualMinWidth,\n            d = Math.min(maxPageX, Math.max(minPageX, e.pageX)) - pageX,\n            x;\n        if (d < 0) {\n          // shrink column\n          x = d;\n          for (j = i; j >= 0; j--) {\n            c = columns[j];\n            if (c.resizable) {\n              actualMinWidth = Math.max(c.minWidth || 0, absoluteColumnMinWidth);\n              if (x && c.previousWidth + x < actualMinWidth) {\n                x += c.previousWidth - actualMinWidth;\n                c.width = actualMinWidth;\n              } else {\n                c.width = c.previousWidth + x;\n                x = 0;\n              }\n            }\n          }\n\n          if (options.forceFitColumns) {\n            x = -d;\n            for (j = i + 1; j < columns.length; j++) {\n              c = columns[j];\n              if (c.resizable) {\n                if (x && c.maxWidth && c.maxWidth - c.previousWidth < x) {\n                  x -= c.maxWidth - c.previousWidth;\n                  c.width = c.maxWidth;\n                } else {\n                  c.width = c.previousWidth + x;\n                  x = 0;\n                }\n              }\n            }\n          }\n        } else {\n          // stretch column\n          x = d;\n          for (j = i; j >= 0; j--) {\n            c = columns[j];\n            if (c.resizable) {\n              if (x && c.maxWidth && c.maxWidth - c.previousWidth < x) {\n                x -= c.maxWidth - c.previousWidth;\n                c.width = c.maxWidth;\n              } else {\n                c.width = c.previousWidth + x;\n                x = 0;\n              }\n            }\n          }\n\n          if (options.forceFitColumns) {\n            x = -d;\n            for (j = i + 1; j < columns.length; j++) {\n              c = columns[j];\n              if (c.resizable) {\n                actualMinWidth = Math.max(c.minWidth || 0, absoluteColumnMinWidth);\n                if (x && c.previousWidth + x < actualMinWidth) {\n                  x += c.previousWidth - actualMinWidth;\n                  c.width = actualMinWidth;\n                } else {\n                  c.width = c.previousWidth + x;\n                  x = 0;\n                }\n              }\n            }\n          }\n        }\n        applyColumnHeaderWidths();\n        if (options.syncColumnCellResize) {\n          applyColumnWidths();\n        }\n      }).on(\"dragend\", function (e, dd) {\n        var newWidth;\n        $(this).parent().removeClass(\"slick-header-column-active\");\n        for (j = 0; j < columns.length; j++) {\n          c = columns[j];\n          newWidth = $(columnElements[j]).outerWidth();\n\n          if (c.previousWidth !== newWidth && c.rerenderOnResize) {\n            invalidateAllRows();\n          }\n        }\n        updateCanvasWidth(true);\n        render();\n        trigger(self.onColumnsResized, { grid: self });\n        setTimeout(function () {\n          columnResizeDragging = false;\n        }, 300);\n      });\n    });\n  }\n\n  function getVBoxDelta($el) {\n    var p = [\"borderTopWidth\", \"borderBottomWidth\", \"paddingTop\", \"paddingBottom\"];\n    var delta = 0;\n    $.each(p, function (n, val) {\n      delta += parseFloat($el.css(val)) || 0;\n    });\n    return delta;\n  }\n\n  function measureCellPaddingAndBorder() {\n    var el;\n    var h = [\"borderLeftWidth\", \"borderRightWidth\", \"paddingLeft\", \"paddingRight\"];\n    var v = [\"borderTopWidth\", \"borderBottomWidth\", \"paddingTop\", \"paddingBottom\"];\n\n    // jquery prior to version 1.8 handles .width setter/getter as a direct css write/read\n    // jquery 1.8 changed .width to read the true inner element width if box-sizing is set to border-box, and introduced a setter for .outerWidth\n    // so for equivalent functionality, prior to 1.8 use .width, and after use .outerWidth\n    var verArray = $.fn.jquery.split('.');\n    jQueryNewWidthBehaviour = verArray[0] == 1 && verArray[1] >= 8 || verArray[0] >= 2;\n\n    el = $(\"<div class='ui-state-default slick-header-column' style='visibility:hidden'>-</div>\").appendTo($headers);\n    headerColumnWidthDiff = headerColumnHeightDiff = 0;\n    if (el.css(\"box-sizing\") != \"border-box\" && el.css(\"-moz-box-sizing\") != \"border-box\" && el.css(\"-webkit-box-sizing\") != \"border-box\") {\n      $.each(h, function (n, val) {\n        headerColumnWidthDiff += parseFloat(el.css(val)) || 0;\n      });\n      $.each(v, function (n, val) {\n        headerColumnHeightDiff += parseFloat(el.css(val)) || 0;\n      });\n    }\n    el.remove();\n\n    var r = $(\"<div class='slick-row' />\").appendTo($canvas);\n    el = $(\"<div class='slick-cell' id='' style='visibility:hidden'>-</div>\").appendTo(r);\n    cellWidthDiff = cellHeightDiff = 0;\n    if (el.css(\"box-sizing\") != \"border-box\" && el.css(\"-moz-box-sizing\") != \"border-box\" && el.css(\"-webkit-box-sizing\") != \"border-box\") {\n      $.each(h, function (n, val) {\n        cellWidthDiff += parseFloat(el.css(val)) || 0;\n      });\n      $.each(v, function (n, val) {\n        cellHeightDiff += parseFloat(el.css(val)) || 0;\n      });\n    }\n    r.remove();\n\n    absoluteColumnMinWidth = Math.max(headerColumnWidthDiff, cellWidthDiff);\n  }\n\n  function createCssRules() {\n    $style = $(\"<style type='text/css' rel='stylesheet' />\").appendTo($(\"head\"));\n    var rowHeight = options.rowHeight - cellHeightDiff;\n    var rules = [\".\" + uid + \" .slick-header-column { left: 1000px; }\", \".\" + uid + \" .slick-top-panel { height:\" + options.topPanelHeight + \"px; }\", \".\" + uid + \" .slick-preheader-panel { height:\" + options.preHeaderPanelHeight + \"px; }\", \".\" + uid + \" .slick-headerrow-columns { height:\" + options.headerRowHeight + \"px; }\", \".\" + uid + \" .slick-footerrow-columns { height:\" + options.footerRowHeight + \"px; }\", \".\" + uid + \" .slick-cell { height:\" + rowHeight + \"px; }\", \".\" + uid + \" .slick-row { height:\" + options.rowHeight + \"px; }\"];\n\n    for (var i = 0; i < columns.length; i++) {\n      rules.push(\".\" + uid + \" .l\" + i + \" { }\");\n      rules.push(\".\" + uid + \" .r\" + i + \" { }\");\n    }\n\n    if ($style[0].styleSheet) {\n      // IE\n      $style[0].styleSheet.cssText = rules.join(\" \");\n    } else {\n      $style[0].appendChild(document.createTextNode(rules.join(\" \")));\n    }\n  }\n\n  function getColumnCssRules(idx) {\n    var i;\n    if (!stylesheet) {\n      var sheets = document.styleSheets;\n      for (i = 0; i < sheets.length; i++) {\n        if ((sheets[i].ownerNode || sheets[i].owningElement) == $style[0]) {\n          stylesheet = sheets[i];\n          break;\n        }\n      }\n\n      if (!stylesheet) {\n        throw new Error(\"Cannot find stylesheet.\");\n      }\n\n      // find and cache column CSS rules\n      columnCssRulesL = [];\n      columnCssRulesR = [];\n      var cssRules = stylesheet.cssRules || stylesheet.rules;\n      var matches, columnIdx;\n      for (i = 0; i < cssRules.length; i++) {\n        var selector = cssRules[i].selectorText;\n        if (matches = /\\.l\\d+/.exec(selector)) {\n          columnIdx = parseInt(matches[0].substr(2, matches[0].length - 2), 10);\n          columnCssRulesL[columnIdx] = cssRules[i];\n        } else if (matches = /\\.r\\d+/.exec(selector)) {\n          columnIdx = parseInt(matches[0].substr(2, matches[0].length - 2), 10);\n          columnCssRulesR[columnIdx] = cssRules[i];\n        }\n      }\n    }\n\n    return {\n      \"left\": columnCssRulesL[idx],\n      \"right\": columnCssRulesR[idx]\n    };\n  }\n\n  function removeCssRules() {\n    $style.remove();\n    stylesheet = null;\n  }\n\n  function destroy() {\n    getEditorLock().cancelCurrentEdit();\n\n    trigger(self.onBeforeDestroy, { grid: self });\n\n    var i = plugins.length;\n    while (i--) {\n      unregisterPlugin(plugins[i]);\n    }\n\n    if (options.enableColumnReorder) {\n      $headers.filter(\":ui-sortable\").sortable(\"destroy\");\n    }\n\n    unbindAncestorScrollEvents();\n    $container.off(\".slickgrid\");\n    removeCssRules();\n\n    $canvas.off(\"draginit dragstart dragend drag\");\n    $container.empty().removeClass(uid);\n  }\n\n  //////////////////////////////////////////////////////////////////////////////////////////////\n  // General\n\n  function trigger(evt, args, e) {\n    e = e || new Slick.EventData();\n    args = args || {};\n    args.grid = self;\n    return evt.notify(args, e, self);\n  }\n\n  function getEditorLock() {\n    return options.editorLock;\n  }\n\n  function getEditController() {\n    return editController;\n  }\n\n  function getColumnIndex(id) {\n    return columnsById[id];\n  }\n\n  function autosizeColumns() {\n    var i,\n        c,\n        widths = [],\n        shrinkLeeway = 0,\n        total = 0,\n        prevTotal,\n        availWidth = viewportHasVScroll ? viewportW - scrollbarDimensions.width : viewportW;\n\n    for (i = 0; i < columns.length; i++) {\n      c = columns[i];\n      widths.push(c.width);\n      total += c.width;\n      if (c.resizable) {\n        shrinkLeeway += c.width - Math.max(c.minWidth, absoluteColumnMinWidth);\n      }\n    }\n\n    // shrink\n    prevTotal = total;\n    while (total > availWidth && shrinkLeeway) {\n      var shrinkProportion = (total - availWidth) / shrinkLeeway;\n      for (i = 0; i < columns.length && total > availWidth; i++) {\n        c = columns[i];\n        var width = widths[i];\n        if (!c.resizable || width <= c.minWidth || width <= absoluteColumnMinWidth) {\n          continue;\n        }\n        var absMinWidth = Math.max(c.minWidth, absoluteColumnMinWidth);\n        var shrinkSize = Math.floor(shrinkProportion * (width - absMinWidth)) || 1;\n        shrinkSize = Math.min(shrinkSize, width - absMinWidth);\n        total -= shrinkSize;\n        shrinkLeeway -= shrinkSize;\n        widths[i] -= shrinkSize;\n      }\n      if (prevTotal <= total) {\n        // avoid infinite loop\n        break;\n      }\n      prevTotal = total;\n    }\n\n    // grow\n    prevTotal = total;\n    while (total < availWidth) {\n      var growProportion = availWidth / total;\n      for (i = 0; i < columns.length && total < availWidth; i++) {\n        c = columns[i];\n        var currentWidth = widths[i];\n        var growSize;\n\n        if (!c.resizable || c.maxWidth <= currentWidth) {\n          growSize = 0;\n        } else {\n          growSize = Math.min(Math.floor(growProportion * currentWidth) - currentWidth, c.maxWidth - currentWidth || 1000000) || 1;\n        }\n        total += growSize;\n        widths[i] += total <= availWidth ? growSize : 0;\n      }\n      if (prevTotal >= total) {\n        // avoid infinite loop\n        break;\n      }\n      prevTotal = total;\n    }\n\n    var reRender = false;\n    for (i = 0; i < columns.length; i++) {\n      if (columns[i].rerenderOnResize && columns[i].width != widths[i]) {\n        reRender = true;\n      }\n      columns[i].width = widths[i];\n    }\n\n    applyColumnHeaderWidths();\n    updateCanvasWidth(true);\n    if (reRender) {\n      invalidateAllRows();\n      render();\n    }\n  }\n\n  function applyColumnHeaderWidths() {\n    if (!initialized) {\n      return;\n    }\n    var h;\n\n    for (var i = 0, headers = $headers.children(), ii = columns.length; i < ii; i++) {\n      h = $(headers[i]);\n      if (jQueryNewWidthBehaviour) {\n        if (h.outerWidth() !== columns[i].width) {\n          h.outerWidth(columns[i].width);\n        }\n      } else {\n        if (h.width() !== columns[i].width - headerColumnWidthDiff) {\n          h.width(columns[i].width - headerColumnWidthDiff);\n        }\n      }\n    }\n\n    updateColumnCaches();\n  }\n\n  function applyColumnWidths() {\n    var x = 0,\n        w,\n        rule;\n    for (var i = 0; i < columns.length; i++) {\n      w = columns[i].width;\n\n      rule = getColumnCssRules(i);\n      rule.left.style.left = x + \"px\";\n      rule.right.style.right = canvasWidth - x - w + \"px\";\n\n      x += columns[i].width;\n    }\n  }\n\n  function setSortColumn(columnId, ascending) {\n    setSortColumns([{ columnId: columnId, sortAsc: ascending }]);\n  }\n\n  function setSortColumns(cols) {\n    sortColumns = cols;\n    var numberCols = options.numberedMultiColumnSort && sortColumns.length > 1;\n    var headerColumnEls = $headers.children();\n    headerColumnEls.removeClass(\"slick-header-column-sorted\").find(\".slick-sort-indicator\").removeClass(\"slick-sort-indicator-asc slick-sort-indicator-desc\");\n    headerColumnEls.find(\".slick-sort-indicator-numbered\").text('');\n\n    $.each(sortColumns, function (i, col) {\n      if (col.sortAsc == null) {\n        col.sortAsc = true;\n      }\n      var columnIndex = getColumnIndex(col.columnId);\n      if (columnIndex != null) {\n        headerColumnEls.eq(columnIndex).addClass(\"slick-header-column-sorted\").find(\".slick-sort-indicator\").addClass(col.sortAsc ? \"slick-sort-indicator-asc\" : \"slick-sort-indicator-desc\");\n        if (numberCols) {\n          headerColumnEls.eq(columnIndex).find(\".slick-sort-indicator-numbered\").text(i + 1);\n        }\n      }\n    });\n  }\n\n  function getSortColumns() {\n    return sortColumns;\n  }\n\n  function handleSelectedRangesChanged(e, ranges) {\n    selectedRows = [];\n    var hash = {};\n    for (var i = 0; i < ranges.length; i++) {\n      for (var j = ranges[i].fromRow; j <= ranges[i].toRow; j++) {\n        if (!hash[j]) {\n          // prevent duplicates\n          selectedRows.push(j);\n          hash[j] = {};\n        }\n        for (var k = ranges[i].fromCell; k <= ranges[i].toCell; k++) {\n          if (canCellBeSelected(j, k)) {\n            hash[j][columns[k].id] = options.selectedCellCssClass;\n          }\n        }\n      }\n    }\n\n    setCellCssStyles(options.selectedCellCssClass, hash);\n\n    trigger(self.onSelectedRowsChanged, { rows: getSelectedRows(), grid: self }, e);\n  }\n\n  function getColumns() {\n    return columns;\n  }\n\n  function updateColumnCaches() {\n    // Pre-calculate cell boundaries.\n    columnPosLeft = [];\n    columnPosRight = [];\n    var x = 0;\n    for (var i = 0, ii = columns.length; i < ii; i++) {\n      columnPosLeft[i] = x;\n      columnPosRight[i] = x + columns[i].width;\n      x += columns[i].width;\n    }\n  }\n\n  function setColumns(columnDefinitions) {\n    columns = columnDefinitions;\n\n    columnsById = {};\n    for (var i = 0; i < columns.length; i++) {\n      var m = columns[i] = $.extend({}, columnDefaults, columns[i]);\n      columnsById[m.id] = i;\n      if (m.minWidth && m.width < m.minWidth) {\n        m.width = m.minWidth;\n      }\n      if (m.maxWidth && m.width > m.maxWidth) {\n        m.width = m.maxWidth;\n      }\n    }\n\n    updateColumnCaches();\n\n    if (initialized) {\n      invalidateAllRows();\n      createColumnHeaders();\n      removeCssRules();\n      createCssRules();\n      resizeCanvas();\n      applyColumnWidths();\n      handleScroll();\n    }\n  }\n\n  function getOptions() {\n    return options;\n  }\n\n  function setOptions(args, suppressRender) {\n    if (!getEditorLock().commitCurrentEdit()) {\n      return;\n    }\n\n    makeActiveCellNormal();\n\n    if (options.enableAddRow !== args.enableAddRow) {\n      invalidateRow(getDataLength());\n    }\n\n    options = $.extend(options, args);\n    validateAndEnforceOptions();\n\n    $viewport.css(\"overflow-y\", options.autoHeight ? \"hidden\" : \"auto\");\n    if (!suppressRender) {\n      render();\n    }\n  }\n\n  function validateAndEnforceOptions() {\n    if (options.autoHeight) {\n      options.leaveSpaceForNewRows = false;\n    }\n  }\n\n  function setData(newData, scrollToTop) {\n    data = newData;\n    invalidateAllRows();\n    updateRowCount();\n    if (scrollToTop) {\n      scrollTo(0);\n    }\n  }\n\n  function getData() {\n    return data;\n  }\n\n  function getDataLength() {\n    if (data.getLength) {\n      return data.getLength();\n    } else {\n      return data.length;\n    }\n  }\n\n  function getDataLengthIncludingAddNew() {\n    return getDataLength() + (!options.enableAddRow ? 0 : !pagingActive || pagingIsLastPage ? 1 : 0);\n  }\n\n  function getDataItem(i) {\n    if (data.getItem) {\n      return data.getItem(i);\n    } else {\n      return data[i];\n    }\n  }\n\n  function getTopPanel() {\n    return $topPanel[0];\n  }\n\n  function setTopPanelVisibility(visible) {\n    if (options.showTopPanel != visible) {\n      options.showTopPanel = visible;\n      if (visible) {\n        $topPanelScroller.slideDown(\"fast\", resizeCanvas);\n      } else {\n        $topPanelScroller.slideUp(\"fast\", resizeCanvas);\n      }\n    }\n  }\n\n  function setHeaderRowVisibility(visible) {\n    if (options.showHeaderRow != visible) {\n      options.showHeaderRow = visible;\n      if (visible) {\n        $headerRowScroller.slideDown(\"fast\", resizeCanvas);\n      } else {\n        $headerRowScroller.slideUp(\"fast\", resizeCanvas);\n      }\n    }\n  }\n\n  function setFooterRowVisibility(visible) {\n    if (options.showFooterRow != visible) {\n      options.showFooterRow = visible;\n      if (visible) {\n        $footerRowScroller.slideDown(\"fast\", resizeCanvas);\n      } else {\n        $footerRowScroller.slideUp(\"fast\", resizeCanvas);\n      }\n    }\n  }\n\n  function setPreHeaderPanelVisibility(visible) {\n    if (options.showPreHeaderPanel != visible) {\n      options.showPreHeaderPanel = visible;\n      if (visible) {\n        $preHeaderPanelScroller.slideDown(\"fast\", resizeCanvas);\n      } else {\n        $preHeaderPanelScroller.slideUp(\"fast\", resizeCanvas);\n      }\n    }\n  }\n\n  function getContainerNode() {\n    return $container.get(0);\n  }\n\n  //////////////////////////////////////////////////////////////////////////////////////////////\n  // Rendering / Scrolling\n\n  function getRowTop(row) {\n    return options.rowHeight * row - offset;\n  }\n\n  function getRowFromPosition(y) {\n    return Math.floor((y + offset) / options.rowHeight);\n  }\n\n  function scrollTo(y) {\n    y = Math.max(y, 0);\n    y = Math.min(y, th - viewportH + (viewportHasHScroll ? scrollbarDimensions.height : 0));\n\n    var oldOffset = offset;\n\n    page = Math.min(n - 1, Math.floor(y / ph));\n    offset = Math.round(page * cj);\n    var newScrollTop = y - offset;\n\n    if (offset != oldOffset) {\n      var range = getVisibleRange(newScrollTop);\n      cleanupRows(range);\n      updateRowPositions();\n    }\n\n    if (prevScrollTop != newScrollTop) {\n      vScrollDir = prevScrollTop + oldOffset < newScrollTop + offset ? 1 : -1;\n      $viewport[0].scrollTop = lastRenderedScrollTop = scrollTop = prevScrollTop = newScrollTop;\n\n      trigger(self.onViewportChanged, { grid: self });\n    }\n  }\n\n  function defaultFormatter(row, cell, value, columnDef, dataContext, grid) {\n    if (value == null) {\n      return \"\";\n    } else {\n      return (value + \"\").replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n    }\n  }\n\n  function getFormatter(row, column) {\n    var rowMetadata = data.getItemMetadata && data.getItemMetadata(row);\n\n    // look up by id, then index\n    var columnOverrides = rowMetadata && rowMetadata.columns && (rowMetadata.columns[column.id] || rowMetadata.columns[getColumnIndex(column.id)]);\n\n    return columnOverrides && columnOverrides.formatter || rowMetadata && rowMetadata.formatter || column.formatter || options.formatterFactory && options.formatterFactory.getFormatter(column) || options.defaultFormatter;\n  }\n\n  function getEditor(row, cell) {\n    var column = columns[cell];\n    var rowMetadata = data.getItemMetadata && data.getItemMetadata(row);\n    var columnMetadata = rowMetadata && rowMetadata.columns;\n\n    if (columnMetadata && columnMetadata[column.id] && columnMetadata[column.id].editor !== undefined) {\n      return columnMetadata[column.id].editor;\n    }\n    if (columnMetadata && columnMetadata[cell] && columnMetadata[cell].editor !== undefined) {\n      return columnMetadata[cell].editor;\n    }\n\n    return column.editor || options.editorFactory && options.editorFactory.getEditor(column);\n  }\n\n  function getDataItemValueForColumn(item, columnDef) {\n    if (options.dataItemColumnValueExtractor) {\n      return options.dataItemColumnValueExtractor(item, columnDef);\n    }\n    return item[columnDef.field];\n  }\n\n  function appendRowHtml(stringArray, row, range, dataLength) {\n    var d = getDataItem(row);\n    var dataLoading = row < dataLength && !d;\n    var rowCss = \"slick-row\" + (dataLoading ? \" loading\" : \"\") + (row === activeRow && options.showCellSelection ? \" active\" : \"\") + (row % 2 == 1 ? \" odd\" : \" even\");\n\n    if (!d) {\n      rowCss += \" \" + options.addNewRowCssClass;\n    }\n\n    var metadata = data.getItemMetadata && data.getItemMetadata(row);\n\n    if (metadata && metadata.cssClasses) {\n      rowCss += \" \" + metadata.cssClasses;\n    }\n\n    stringArray.push(\"<div class='ui-widget-content \" + rowCss + \"' style='top:\" + getRowTop(row) + \"px'>\");\n\n    var colspan, m;\n    for (var i = 0, ii = columns.length; i < ii; i++) {\n      m = columns[i];\n      colspan = 1;\n      if (metadata && metadata.columns) {\n        var columnData = metadata.columns[m.id] || metadata.columns[i];\n        colspan = columnData && columnData.colspan || 1;\n        if (colspan === \"*\") {\n          colspan = ii - i;\n        }\n      }\n\n      // Do not render cells outside of the viewport.\n      if (columnPosRight[Math.min(ii - 1, i + colspan - 1)] > range.leftPx) {\n        if (columnPosLeft[i] > range.rightPx) {\n          // All columns to the right are outside the range.\n          break;\n        }\n\n        appendCellHtml(stringArray, row, i, colspan, d);\n      }\n\n      if (colspan > 1) {\n        i += colspan - 1;\n      }\n    }\n\n    stringArray.push(\"</div>\");\n  }\n\n  function appendCellHtml(stringArray, row, cell, colspan, item) {\n    // stringArray: stringBuilder containing the HTML parts\n    // row, cell: row and column index\n    // colspan: HTML colspan\n    // item: grid data for row\n\n    var m = columns[cell];\n    var cellCss = \"slick-cell l\" + cell + \" r\" + Math.min(columns.length - 1, cell + colspan - 1) + (m.cssClass ? \" \" + m.cssClass : \"\");\n    if (row === activeRow && cell === activeCell && options.showCellSelection) {\n      cellCss += \" active\";\n    }\n\n    // TODO:  merge them together in the setter\n    for (var key in cellCssClasses) {\n      if (cellCssClasses[key][row] && cellCssClasses[key][row][m.id]) {\n        cellCss += \" \" + cellCssClasses[key][row][m.id];\n      }\n    }\n\n    var value = null,\n        formatterResult = '';\n    if (item) {\n      value = getDataItemValueForColumn(item, m);\n      formatterResult = getFormatter(row, m)(row, cell, value, m, item, self);\n      if (formatterResult === null || formatterResult === undefined) {\n        formatterResult = '';\n      }\n    }\n\n    // get addl css class names from object type formatter return and from string type return of onBeforeAppendCell\n    var addlCssClasses = trigger(self.onBeforeAppendCell, { row: row, cell: cell, grid: self, value: value, dataContext: item }) || '';\n    addlCssClasses += formatterResult && formatterResult.addClasses ? (addlCssClasses ? ' ' : '') + formatterResult.addClasses : '';\n\n    stringArray.push(\"<div class='\" + cellCss + (addlCssClasses ? ' ' + addlCssClasses : '') + \"'>\");\n\n    // if there is a corresponding row (if not, this is the Add New row or this data hasn't been loaded yet)\n    if (item) {\n      stringArray.push(Object.prototype.toString.call(formatterResult) !== '[object Object]' ? formatterResult : formatterResult.text);\n    }\n\n    stringArray.push(\"</div>\");\n\n    rowsCache[row].cellRenderQueue.push(cell);\n    rowsCache[row].cellColSpans[cell] = colspan;\n  }\n\n  function cleanupRows(rangeToKeep) {\n    for (var i in rowsCache) {\n      if ((i = parseInt(i, 10)) !== activeRow && (i < rangeToKeep.top || i > rangeToKeep.bottom)) {\n        removeRowFromCache(i);\n      }\n    }\n    if (options.enableAsyncPostRenderCleanup) {\n      startPostProcessingCleanup();\n    }\n  }\n\n  function invalidate() {\n    updateRowCount();\n    invalidateAllRows();\n    render();\n  }\n\n  function invalidateAllRows() {\n    if (currentEditor) {\n      makeActiveCellNormal();\n    }\n    for (var row in rowsCache) {\n      removeRowFromCache(row);\n    }\n    if (options.enableAsyncPostRenderCleanup) {\n      startPostProcessingCleanup();\n    }\n  }\n\n  function queuePostProcessedRowForCleanup(cacheEntry, postProcessedRow, rowIdx) {\n    postProcessgroupId++;\n\n    // store and detach node for later async cleanup\n    for (var columnIdx in postProcessedRow) {\n      if (postProcessedRow.hasOwnProperty(columnIdx)) {\n        postProcessedCleanupQueue.push({\n          actionType: 'C',\n          groupId: postProcessgroupId,\n          node: cacheEntry.cellNodesByColumnIdx[columnIdx | 0],\n          columnIdx: columnIdx | 0,\n          rowIdx: rowIdx\n        });\n      }\n    }\n    postProcessedCleanupQueue.push({\n      actionType: 'R',\n      groupId: postProcessgroupId,\n      node: cacheEntry.rowNode\n    });\n    $(cacheEntry.rowNode).detach();\n  }\n\n  function queuePostProcessedCellForCleanup(cellnode, columnIdx, rowIdx) {\n    postProcessedCleanupQueue.push({\n      actionType: 'C',\n      groupId: postProcessgroupId,\n      node: cellnode,\n      columnIdx: columnIdx,\n      rowIdx: rowIdx\n    });\n    $(cellnode).detach();\n  }\n\n  function removeRowFromCache(row) {\n    var cacheEntry = rowsCache[row];\n    if (!cacheEntry) {\n      return;\n    }\n\n    if (cacheEntry.rowNode) {\n      if (rowNodeFromLastMouseWheelEvent === cacheEntry.rowNode) {\n        cacheEntry.rowNode.style.display = 'none';\n        zombieRowNodeFromLastMouseWheelEvent = rowNodeFromLastMouseWheelEvent;\n        zombieRowCacheFromLastMouseWheelEvent = cacheEntry;\n        zombieRowPostProcessedFromLastMouseWheelEvent = postProcessedRows[row];\n        // ignore post processing cleanup in this case - it will be dealt with later\n      } else {\n        if (options.enableAsyncPostRenderCleanup && postProcessedRows[row]) {\n          queuePostProcessedRowForCleanup(cacheEntry, postProcessedRows[row], row);\n        } else {\n          $canvas[0].removeChild(cacheEntry.rowNode);\n        }\n      }\n    }\n\n    delete rowsCache[row];\n    delete postProcessedRows[row];\n    renderedRows--;\n    counter_rows_removed++;\n  }\n\n  function invalidateRows(rows) {\n    var i, rl;\n    if (!rows || !rows.length) {\n      return;\n    }\n    vScrollDir = 0;\n    rl = rows.length;\n    for (i = 0; i < rl; i++) {\n      if (currentEditor && activeRow === rows[i]) {\n        makeActiveCellNormal();\n      }\n      if (rowsCache[rows[i]]) {\n        removeRowFromCache(rows[i]);\n      }\n    }\n    if (options.enableAsyncPostRenderCleanup) {\n      startPostProcessingCleanup();\n    }\n  }\n\n  function invalidateRow(row) {\n    if (!row && row !== 0) {\n      return;\n    }\n    invalidateRows([row]);\n  }\n\n  function applyFormatResultToCellNode(formatterResult, cellNode, suppressRemove) {\n    if (formatterResult === null || formatterResult === undefined) {\n      formatterResult = '';\n    }\n    if (Object.prototype.toString.call(formatterResult) !== '[object Object]') {\n      cellNode.innerHTML = formatterResult;\n      return;\n    }\n    cellNode.innerHTML = formatterResult.text;\n    if (formatterResult.removeClasses && !suppressRemove) {\n      $(cellNode).removeClass(formatterResult.removeClasses);\n    }\n    if (formatterResult.addClasses) {\n      $(cellNode).addClass(formatterResult.addClasses);\n    }\n  }\n\n  function updateCell(row, cell) {\n    var cellNode = getCellNode(row, cell);\n    if (!cellNode) {\n      return;\n    }\n\n    var m = columns[cell],\n        d = getDataItem(row);\n    if (currentEditor && activeRow === row && activeCell === cell) {\n      currentEditor.loadValue(d);\n    } else {\n      var formatterResult = d ? getFormatter(row, m)(row, cell, getDataItemValueForColumn(d, m), m, d, self) : \"\";\n      applyFormatResultToCellNode(formatterResult, cellNode);\n      invalidatePostProcessingResults(row);\n    }\n  }\n\n  function updateRow(row) {\n    var cacheEntry = rowsCache[row];\n    if (!cacheEntry) {\n      return;\n    }\n\n    ensureCellNodesInRowsCache(row);\n\n    var formatterResult,\n        d = getDataItem(row);\n\n    for (var columnIdx in cacheEntry.cellNodesByColumnIdx) {\n      if (!cacheEntry.cellNodesByColumnIdx.hasOwnProperty(columnIdx)) {\n        continue;\n      }\n\n      columnIdx = columnIdx | 0;\n      var m = columns[columnIdx],\n          node = cacheEntry.cellNodesByColumnIdx[columnIdx];\n\n      if (row === activeRow && columnIdx === activeCell && currentEditor) {\n        currentEditor.loadValue(d);\n      } else if (d) {\n        formatterResult = getFormatter(row, m)(row, columnIdx, getDataItemValueForColumn(d, m), m, d, self);\n        applyFormatResultToCellNode(formatterResult, node);\n      } else {\n        node.innerHTML = \"\";\n      }\n    }\n\n    invalidatePostProcessingResults(row);\n  }\n\n  function getViewportHeight() {\n    return parseFloat($.css($container[0], \"height\", true)) - parseFloat($.css($container[0], \"paddingTop\", true)) - parseFloat($.css($container[0], \"paddingBottom\", true)) - parseFloat($.css($headerScroller[0], \"height\")) - getVBoxDelta($headerScroller) - (options.showTopPanel ? options.topPanelHeight + getVBoxDelta($topPanelScroller) : 0) - (options.showHeaderRow ? options.headerRowHeight + getVBoxDelta($headerRowScroller) : 0) - (options.createFooterRow && options.showFooterRow ? options.footerRowHeight + getVBoxDelta($footerRowScroller) : 0) - (options.createPreHeaderPanel && options.showPreHeaderPanel ? options.preHeaderPanelHeight + getVBoxDelta($preHeaderPanelScroller) : 0);\n  }\n\n  function resizeCanvas() {\n    if (!initialized) {\n      return;\n    }\n    if (options.autoHeight) {\n      viewportH = options.rowHeight * getDataLengthIncludingAddNew();\n    } else {\n      viewportH = getViewportHeight();\n    }\n\n    numVisibleRows = Math.ceil(viewportH / options.rowHeight);\n    viewportW = parseFloat($.css($container[0], \"width\", true));\n    if (!options.autoHeight) {\n      $viewport.height(viewportH);\n    }\n\n    if (!scrollbarDimensions || !scrollbarDimensions.width) {\n      scrollbarDimensions = measureScrollbar();\n    }\n\n    if (options.forceFitColumns) {\n      autosizeColumns();\n    }\n\n    updateRowCount();\n    handleScroll();\n    // Since the width has changed, force the render() to reevaluate virtually rendered cells.\n    lastRenderedScrollLeft = -1;\n    render();\n  }\n\n  function updatePagingStatusFromView(pagingInfo) {\n    pagingActive = pagingInfo.pageSize !== 0;\n    pagingIsLastPage = pagingInfo.pageNum == pagingInfo.totalPages - 1;\n  }\n\n  function updateRowCount() {\n    if (!initialized) {\n      return;\n    }\n\n    var dataLength = getDataLength();\n    var dataLengthIncludingAddNew = getDataLengthIncludingAddNew();\n    var numberOfRows = dataLengthIncludingAddNew + (options.leaveSpaceForNewRows ? numVisibleRows - 1 : 0);\n\n    var oldViewportHasVScroll = viewportHasVScroll;\n    // with autoHeight, we do not need to accommodate the vertical scroll bar\n    viewportHasVScroll = options.alwaysShowVerticalScroll || !options.autoHeight && numberOfRows * options.rowHeight > viewportH;\n    viewportHasHScroll = canvasWidth > viewportW - scrollbarDimensions.width;\n\n    makeActiveCellNormal();\n\n    // remove the rows that are now outside of the data range\n    // this helps avoid redundant calls to .removeRow() when the size of the data decreased by thousands of rows\n    var r1 = dataLength - 1;\n    for (var i in rowsCache) {\n      if (i > r1) {\n        removeRowFromCache(i);\n      }\n    }\n    if (options.enableAsyncPostRenderCleanup) {\n      startPostProcessingCleanup();\n    }\n\n    if (activeCellNode && activeRow > r1) {\n      resetActiveCell();\n    }\n\n    var oldH = h;\n    th = Math.max(options.rowHeight * numberOfRows, viewportH - scrollbarDimensions.height);\n    if (th < maxSupportedCssHeight) {\n      // just one page\n      h = ph = th;\n      n = 1;\n      cj = 0;\n    } else {\n      // break into pages\n      h = maxSupportedCssHeight;\n      ph = h / 100;\n      n = Math.floor(th / ph);\n      cj = (th - h) / (n - 1);\n    }\n\n    if (h !== oldH) {\n      $canvas.css(\"height\", h);\n      scrollTop = $viewport[0].scrollTop;\n    }\n\n    var oldScrollTopInRange = scrollTop + offset <= th - viewportH;\n\n    if (th == 0 || scrollTop == 0) {\n      page = offset = 0;\n    } else if (oldScrollTopInRange) {\n      // maintain virtual position\n      scrollTo(scrollTop + offset);\n    } else {\n      // scroll to bottom\n      scrollTo(th - viewportH);\n    }\n\n    if (h != oldH && options.autoHeight) {\n      resizeCanvas();\n    }\n\n    if (options.forceFitColumns && oldViewportHasVScroll != viewportHasVScroll) {\n      autosizeColumns();\n    }\n    updateCanvasWidth(false);\n  }\n\n  function getVisibleRange(viewportTop, viewportLeft) {\n    if (viewportTop == null) {\n      viewportTop = scrollTop;\n    }\n    if (viewportLeft == null) {\n      viewportLeft = scrollLeft;\n    }\n\n    return {\n      top: getRowFromPosition(viewportTop),\n      bottom: getRowFromPosition(viewportTop + viewportH) + 1,\n      leftPx: viewportLeft,\n      rightPx: viewportLeft + viewportW\n    };\n  }\n\n  function getRenderedRange(viewportTop, viewportLeft) {\n    var range = getVisibleRange(viewportTop, viewportLeft);\n    var buffer = Math.round(viewportH / options.rowHeight);\n    var minBuffer = options.minRowBuffer;\n\n    if (vScrollDir == -1) {\n      range.top -= buffer;\n      range.bottom += minBuffer;\n    } else if (vScrollDir == 1) {\n      range.top -= minBuffer;\n      range.bottom += buffer;\n    } else {\n      range.top -= minBuffer;\n      range.bottom += minBuffer;\n    }\n\n    range.top = Math.max(0, range.top);\n    range.bottom = Math.min(getDataLengthIncludingAddNew() - 1, range.bottom);\n\n    range.leftPx -= viewportW;\n    range.rightPx += viewportW;\n\n    range.leftPx = Math.max(0, range.leftPx);\n    range.rightPx = Math.min(canvasWidth, range.rightPx);\n\n    return range;\n  }\n\n  function ensureCellNodesInRowsCache(row) {\n    var cacheEntry = rowsCache[row];\n    if (cacheEntry) {\n      if (cacheEntry.cellRenderQueue.length) {\n        var lastChild = cacheEntry.rowNode.lastChild;\n        while (cacheEntry.cellRenderQueue.length) {\n          var columnIdx = cacheEntry.cellRenderQueue.pop();\n          cacheEntry.cellNodesByColumnIdx[columnIdx] = lastChild;\n          lastChild = lastChild.previousSibling;\n        }\n      }\n    }\n  }\n\n  function cleanUpCells(range, row) {\n    var totalCellsRemoved = 0;\n    var cacheEntry = rowsCache[row];\n\n    // Remove cells outside the range.\n    var cellsToRemove = [];\n    for (var i in cacheEntry.cellNodesByColumnIdx) {\n      // I really hate it when people mess with Array.prototype.\n      if (!cacheEntry.cellNodesByColumnIdx.hasOwnProperty(i)) {\n        continue;\n      }\n\n      // This is a string, so it needs to be cast back to a number.\n      i = i | 0;\n\n      var colspan = cacheEntry.cellColSpans[i];\n      if (columnPosLeft[i] > range.rightPx || columnPosRight[Math.min(columns.length - 1, i + colspan - 1)] < range.leftPx) {\n        if (!(row == activeRow && i == activeCell)) {\n          cellsToRemove.push(i);\n        }\n      }\n    }\n\n    var cellToRemove, node;\n    postProcessgroupId++;\n    while ((cellToRemove = cellsToRemove.pop()) != null) {\n      node = cacheEntry.cellNodesByColumnIdx[cellToRemove];\n      if (options.enableAsyncPostRenderCleanup && postProcessedRows[row] && postProcessedRows[row][cellToRemove]) {\n        queuePostProcessedCellForCleanup(node, cellToRemove, row);\n      } else {\n        cacheEntry.rowNode.removeChild(node);\n      }\n\n      delete cacheEntry.cellColSpans[cellToRemove];\n      delete cacheEntry.cellNodesByColumnIdx[cellToRemove];\n      if (postProcessedRows[row]) {\n        delete postProcessedRows[row][cellToRemove];\n      }\n      totalCellsRemoved++;\n    }\n  }\n\n  function cleanUpAndRenderCells(range) {\n    var cacheEntry;\n    var stringArray = [];\n    var processedRows = [];\n    var cellsAdded;\n    var totalCellsAdded = 0;\n    var colspan;\n\n    for (var row = range.top, btm = range.bottom; row <= btm; row++) {\n      cacheEntry = rowsCache[row];\n      if (!cacheEntry) {\n        continue;\n      }\n\n      // cellRenderQueue populated in renderRows() needs to be cleared first\n      ensureCellNodesInRowsCache(row);\n\n      cleanUpCells(range, row);\n\n      // Render missing cells.\n      cellsAdded = 0;\n\n      var metadata = data.getItemMetadata && data.getItemMetadata(row);\n      metadata = metadata && metadata.columns;\n\n      var d = getDataItem(row);\n\n      // TODO:  shorten this loop (index? heuristics? binary search?)\n      for (var i = 0, ii = columns.length; i < ii; i++) {\n        // Cells to the right are outside the range.\n        if (columnPosLeft[i] > range.rightPx) {\n          break;\n        }\n\n        // Already rendered.\n        if ((colspan = cacheEntry.cellColSpans[i]) != null) {\n          i += colspan > 1 ? colspan - 1 : 0;\n          continue;\n        }\n\n        colspan = 1;\n        if (metadata) {\n          var columnData = metadata[columns[i].id] || metadata[i];\n          colspan = columnData && columnData.colspan || 1;\n          if (colspan === \"*\") {\n            colspan = ii - i;\n          }\n        }\n\n        if (columnPosRight[Math.min(ii - 1, i + colspan - 1)] > range.leftPx) {\n          appendCellHtml(stringArray, row, i, colspan, d);\n          cellsAdded++;\n        }\n\n        i += colspan > 1 ? colspan - 1 : 0;\n      }\n\n      if (cellsAdded) {\n        totalCellsAdded += cellsAdded;\n        processedRows.push(row);\n      }\n    }\n\n    if (!stringArray.length) {\n      return;\n    }\n\n    var x = document.createElement(\"div\");\n    x.innerHTML = stringArray.join(\"\");\n\n    var processedRow;\n    var node;\n    while ((processedRow = processedRows.pop()) != null) {\n      cacheEntry = rowsCache[processedRow];\n      var columnIdx;\n      while ((columnIdx = cacheEntry.cellRenderQueue.pop()) != null) {\n        node = x.lastChild;\n        cacheEntry.rowNode.appendChild(node);\n        cacheEntry.cellNodesByColumnIdx[columnIdx] = node;\n      }\n    }\n  }\n\n  function renderRows(range) {\n    var parentNode = $canvas[0],\n        stringArray = [],\n        rows = [],\n        needToReselectCell = false,\n        dataLength = getDataLength();\n\n    for (var i = range.top, ii = range.bottom; i <= ii; i++) {\n      if (rowsCache[i]) {\n        continue;\n      }\n      renderedRows++;\n      rows.push(i);\n\n      // Create an entry right away so that appendRowHtml() can\n      // start populatating it.\n      rowsCache[i] = {\n        \"rowNode\": null,\n\n        // ColSpans of rendered cells (by column idx).\n        // Can also be used for checking whether a cell has been rendered.\n        \"cellColSpans\": [],\n\n        // Cell nodes (by column idx).  Lazy-populated by ensureCellNodesInRowsCache().\n        \"cellNodesByColumnIdx\": [],\n\n        // Column indices of cell nodes that have been rendered, but not yet indexed in\n        // cellNodesByColumnIdx.  These are in the same order as cell nodes added at the\n        // end of the row.\n        \"cellRenderQueue\": []\n      };\n\n      appendRowHtml(stringArray, i, range, dataLength);\n      if (activeCellNode && activeRow === i) {\n        needToReselectCell = true;\n      }\n      counter_rows_rendered++;\n    }\n\n    if (!rows.length) {\n      return;\n    }\n\n    var x = document.createElement(\"div\");\n    x.innerHTML = stringArray.join(\"\");\n\n    for (var i = 0, ii = rows.length; i < ii; i++) {\n      rowsCache[rows[i]].rowNode = parentNode.appendChild(x.firstChild);\n    }\n\n    if (needToReselectCell) {\n      activeCellNode = getCellNode(activeRow, activeCell);\n    }\n  }\n\n  function startPostProcessing() {\n    if (!options.enableAsyncPostRender) {\n      return;\n    }\n    clearTimeout(h_postrender);\n    h_postrender = setTimeout(asyncPostProcessRows, options.asyncPostRenderDelay);\n  }\n\n  function startPostProcessingCleanup() {\n    if (!options.enableAsyncPostRenderCleanup) {\n      return;\n    }\n    clearTimeout(h_postrenderCleanup);\n    h_postrenderCleanup = setTimeout(asyncPostProcessCleanupRows, options.asyncPostRenderCleanupDelay);\n  }\n\n  function invalidatePostProcessingResults(row) {\n    // change status of columns to be re-rendered\n    for (var columnIdx in postProcessedRows[row]) {\n      if (postProcessedRows[row].hasOwnProperty(columnIdx)) {\n        postProcessedRows[row][columnIdx] = 'C';\n      }\n    }\n    postProcessFromRow = Math.min(postProcessFromRow, row);\n    postProcessToRow = Math.max(postProcessToRow, row);\n    startPostProcessing();\n  }\n\n  function updateRowPositions() {\n    for (var row in rowsCache) {\n      rowsCache[row].rowNode.style.top = getRowTop(row) + \"px\";\n    }\n  }\n\n  function render() {\n    if (!initialized) {\n      return;\n    }\n    var visible = getVisibleRange();\n    var rendered = getRenderedRange();\n\n    // remove rows no longer in the viewport\n    cleanupRows(rendered);\n\n    // add new rows & missing cells in existing rows\n    if (lastRenderedScrollLeft != scrollLeft) {\n      cleanUpAndRenderCells(rendered);\n    }\n\n    // render missing rows\n    renderRows(rendered);\n\n    postProcessFromRow = visible.top;\n    postProcessToRow = Math.min(getDataLengthIncludingAddNew() - 1, visible.bottom);\n    startPostProcessing();\n\n    lastRenderedScrollTop = scrollTop;\n    lastRenderedScrollLeft = scrollLeft;\n    h_render = null;\n  }\n\n  function handleHeaderScroll() {\n    handleElementScroll($headerScroller[0]);\n  }\n\n  function handleHeaderRowScroll() {\n    handleElementScroll($headerRowScroller[0]);\n  }\n\n  function handleFooterRowScroll() {\n    handleElementScroll($footerRowScroller[0]);\n  }\n\n  function handlePreHeaderPanelScroll() {\n    handleElementScroll($preHeaderPanelScroller[0]);\n  }\n\n  function handleElementScroll(element) {\n    var scrollLeft = element.scrollLeft;\n    if (scrollLeft != $viewport[0].scrollLeft) {\n      $viewport[0].scrollLeft = scrollLeft;\n    }\n  }\n\n  function handleScroll() {\n    scrollTop = $viewport[0].scrollTop;\n    scrollLeft = $viewport[0].scrollLeft;\n    var vScrollDist = Math.abs(scrollTop - prevScrollTop);\n    var hScrollDist = Math.abs(scrollLeft - prevScrollLeft);\n\n    if (hScrollDist) {\n      prevScrollLeft = scrollLeft;\n      $headerScroller[0].scrollLeft = scrollLeft;\n      $topPanelScroller[0].scrollLeft = scrollLeft;\n      $headerRowScroller[0].scrollLeft = scrollLeft;\n      if (options.createFooterRow) {\n        $footerRowScroller[0].scrollLeft = scrollLeft;\n      }\n      if (options.createPreHeaderPanel) {\n        $preHeaderPanelScroller[0].scrollLeft = scrollLeft;\n      }\n    }\n\n    if (vScrollDist) {\n      vScrollDir = prevScrollTop < scrollTop ? 1 : -1;\n      prevScrollTop = scrollTop;\n\n      // switch virtual pages if needed\n      if (vScrollDist < viewportH) {\n        scrollTo(scrollTop + offset);\n      } else {\n        var oldOffset = offset;\n        if (h == viewportH) {\n          page = 0;\n        } else {\n          page = Math.min(n - 1, Math.floor(scrollTop * ((th - viewportH) / (h - viewportH)) * (1 / ph)));\n        }\n        offset = Math.round(page * cj);\n        if (oldOffset != offset) {\n          invalidateAllRows();\n        }\n      }\n    }\n\n    if (hScrollDist || vScrollDist) {\n      if (h_render) {\n        clearTimeout(h_render);\n      }\n\n      if (Math.abs(lastRenderedScrollTop - scrollTop) > 20 || Math.abs(lastRenderedScrollLeft - scrollLeft) > 20) {\n        if (options.forceSyncScrolling || Math.abs(lastRenderedScrollTop - scrollTop) < viewportH && Math.abs(lastRenderedScrollLeft - scrollLeft) < viewportW) {\n          render();\n        } else {\n          h_render = setTimeout(render, 50);\n        }\n\n        trigger(self.onViewportChanged, { grid: self });\n      }\n    }\n\n    trigger(self.onScroll, { scrollLeft: scrollLeft, scrollTop: scrollTop, grid: self });\n  }\n\n  function asyncPostProcessRows() {\n    var dataLength = getDataLength();\n    while (postProcessFromRow <= postProcessToRow) {\n      var row = vScrollDir >= 0 ? postProcessFromRow++ : postProcessToRow--;\n      var cacheEntry = rowsCache[row];\n      if (!cacheEntry || row >= dataLength) {\n        continue;\n      }\n\n      if (!postProcessedRows[row]) {\n        postProcessedRows[row] = {};\n      }\n\n      ensureCellNodesInRowsCache(row);\n      for (var columnIdx in cacheEntry.cellNodesByColumnIdx) {\n        if (!cacheEntry.cellNodesByColumnIdx.hasOwnProperty(columnIdx)) {\n          continue;\n        }\n\n        columnIdx = columnIdx | 0;\n\n        var m = columns[columnIdx];\n        var processedStatus = postProcessedRows[row][columnIdx]; // C=cleanup and re-render, R=rendered\n        if (m.asyncPostRender && processedStatus !== 'R') {\n          var node = cacheEntry.cellNodesByColumnIdx[columnIdx];\n          if (node) {\n            m.asyncPostRender(node, row, getDataItem(row), m, processedStatus === 'C');\n          }\n          postProcessedRows[row][columnIdx] = 'R';\n        }\n      }\n\n      h_postrender = setTimeout(asyncPostProcessRows, options.asyncPostRenderDelay);\n      return;\n    }\n  }\n\n  function asyncPostProcessCleanupRows() {\n    if (postProcessedCleanupQueue.length > 0) {\n      var groupId = postProcessedCleanupQueue[0].groupId;\n\n      // loop through all queue members with this groupID\n      while (postProcessedCleanupQueue.length > 0 && postProcessedCleanupQueue[0].groupId == groupId) {\n        var entry = postProcessedCleanupQueue.shift();\n        if (entry.actionType == 'R') {\n          $(entry.node).remove();\n        }\n        if (entry.actionType == 'C') {\n          var column = columns[entry.columnIdx];\n          if (column.asyncPostRenderCleanup && entry.node) {\n            // cleanup must also remove element\n            column.asyncPostRenderCleanup(entry.node, entry.rowIdx, column);\n          }\n        }\n      }\n\n      // call this function again after the specified delay\n      h_postrenderCleanup = setTimeout(asyncPostProcessCleanupRows, options.asyncPostRenderCleanupDelay);\n    }\n  }\n\n  function updateCellCssStylesOnRenderedRows(addedHash, removedHash) {\n    var node, columnId, addedRowHash, removedRowHash;\n    for (var row in rowsCache) {\n      removedRowHash = removedHash && removedHash[row];\n      addedRowHash = addedHash && addedHash[row];\n\n      if (removedRowHash) {\n        for (columnId in removedRowHash) {\n          if (!addedRowHash || removedRowHash[columnId] != addedRowHash[columnId]) {\n            node = getCellNode(row, getColumnIndex(columnId));\n            if (node) {\n              $(node).removeClass(removedRowHash[columnId]);\n            }\n          }\n        }\n      }\n\n      if (addedRowHash) {\n        for (columnId in addedRowHash) {\n          if (!removedRowHash || removedRowHash[columnId] != addedRowHash[columnId]) {\n            node = getCellNode(row, getColumnIndex(columnId));\n            if (node) {\n              $(node).addClass(addedRowHash[columnId]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  function addCellCssStyles(key, hash) {\n    if (cellCssClasses[key]) {\n      throw new Error(\"addCellCssStyles: cell CSS hash with key '\" + key + \"' already exists.\");\n    }\n\n    cellCssClasses[key] = hash;\n    updateCellCssStylesOnRenderedRows(hash, null);\n\n    trigger(self.onCellCssStylesChanged, { \"key\": key, \"hash\": hash, \"grid\": self });\n  }\n\n  function removeCellCssStyles(key) {\n    if (!cellCssClasses[key]) {\n      return;\n    }\n\n    updateCellCssStylesOnRenderedRows(null, cellCssClasses[key]);\n    delete cellCssClasses[key];\n\n    trigger(self.onCellCssStylesChanged, { \"key\": key, \"hash\": null, \"grid\": self });\n  }\n\n  function setCellCssStyles(key, hash) {\n    var prevHash = cellCssClasses[key];\n\n    cellCssClasses[key] = hash;\n    updateCellCssStylesOnRenderedRows(hash, prevHash);\n\n    trigger(self.onCellCssStylesChanged, { \"key\": key, \"hash\": hash, \"grid\": self });\n  }\n\n  function getCellCssStyles(key) {\n    return cellCssClasses[key];\n  }\n\n  function flashCell(row, cell, speed) {\n    speed = speed || 100;\n    if (rowsCache[row]) {\n      var toggleCellClass = function toggleCellClass(times) {\n        if (!times) {\n          return;\n        }\n        setTimeout(function () {\n          $cell.queue(function () {\n            $cell.toggleClass(options.cellFlashingCssClass).dequeue();\n            toggleCellClass(times - 1);\n          });\n        }, speed);\n      };\n\n      var $cell = $(getCellNode(row, cell));\n\n      toggleCellClass(4);\n    }\n  }\n\n  //////////////////////////////////////////////////////////////////////////////////////////////\n  // Interactivity\n\n  function handleMouseWheel(e) {\n    var rowNode = $(e.target).closest(\".slick-row\")[0];\n    if (rowNode != rowNodeFromLastMouseWheelEvent) {\n      if (zombieRowNodeFromLastMouseWheelEvent && zombieRowNodeFromLastMouseWheelEvent != rowNode) {\n        if (options.enableAsyncPostRenderCleanup && zombieRowPostProcessedFromLastMouseWheelEvent) {\n          queuePostProcessedRowForCleanup(zombieRowCacheFromLastMouseWheelEvent, zombieRowPostProcessedFromLastMouseWheelEvent);\n        } else {\n          $canvas[0].removeChild(zombieRowNodeFromLastMouseWheelEvent);\n        }\n        zombieRowNodeFromLastMouseWheelEvent = null;\n        zombieRowCacheFromLastMouseWheelEvent = null;\n        zombieRowPostProcessedFromLastMouseWheelEvent = null;\n\n        if (options.enableAsyncPostRenderCleanup) {\n          startPostProcessingCleanup();\n        }\n      }\n      rowNodeFromLastMouseWheelEvent = rowNode;\n    }\n  }\n\n  function handleDragInit(e, dd) {\n    var cell = getCellFromEvent(e);\n    if (!cell || !cellExists(cell.row, cell.cell)) {\n      return false;\n    }\n\n    var retval = trigger(self.onDragInit, dd, e);\n    if (e.isImmediatePropagationStopped()) {\n      return retval;\n    }\n\n    // if nobody claims to be handling drag'n'drop by stopping immediate propagation,\n    // cancel out of it\n    return false;\n  }\n\n  function handleDragStart(e, dd) {\n    var cell = getCellFromEvent(e);\n    if (!cell || !cellExists(cell.row, cell.cell)) {\n      return false;\n    }\n\n    var retval = trigger(self.onDragStart, dd, e);\n    if (e.isImmediatePropagationStopped()) {\n      return retval;\n    }\n\n    return false;\n  }\n\n  function handleDrag(e, dd) {\n    return trigger(self.onDrag, dd, e);\n  }\n\n  function handleDragEnd(e, dd) {\n    trigger(self.onDragEnd, dd, e);\n  }\n\n  function handleKeyDown(e) {\n    trigger(self.onKeyDown, { row: activeRow, cell: activeCell, grid: self }, e);\n    var handled = e.isImmediatePropagationStopped();\n    var keyCode = Slick.keyCode;\n\n    if (!handled) {\n      if (!e.shiftKey && !e.altKey) {\n        if (options.editable && currentEditor && currentEditor.keyCaptureList) {\n          if (currentEditor.keyCaptureList.indexOf(e.which) > -1) {\n            return;\n          }\n        }\n        if (e.which == keyCode.HOME) {\n          handled = e.ctrlKey ? navigateTop() : navigateRowStart();\n        } else if (e.which == keyCode.END) {\n          handled = e.ctrlKey ? navigateBottom() : navigateRowEnd();\n        }\n      }\n    }\n    if (!handled) {\n      if (!e.shiftKey && !e.altKey && !e.ctrlKey) {\n        // editor may specify an array of keys to bubble\n        if (options.editable && currentEditor && currentEditor.keyCaptureList) {\n          if (currentEditor.keyCaptureList.indexOf(e.which) > -1) {\n            return;\n          }\n        }\n        if (e.which == keyCode.ESCAPE) {\n          if (!getEditorLock().isActive()) {\n            return; // no editing mode to cancel, allow bubbling and default processing (exit without cancelling the event)\n          }\n          cancelEditAndSetFocus();\n        } else if (e.which == keyCode.PAGE_DOWN) {\n          navigatePageDown();\n          handled = true;\n        } else if (e.which == keyCode.PAGE_UP) {\n          navigatePageUp();\n          handled = true;\n        } else if (e.which == keyCode.LEFT) {\n          handled = navigateLeft();\n        } else if (e.which == keyCode.RIGHT) {\n          handled = navigateRight();\n        } else if (e.which == keyCode.UP) {\n          handled = navigateUp();\n        } else if (e.which == keyCode.DOWN) {\n          handled = navigateDown();\n        } else if (e.which == keyCode.TAB) {\n          handled = navigateNext();\n        } else if (e.which == keyCode.ENTER) {\n          if (options.editable) {\n            if (currentEditor) {\n              // adding new row\n              if (activeRow === getDataLength()) {\n                navigateDown();\n              } else {\n                commitEditAndSetFocus();\n              }\n            } else {\n              if (getEditorLock().commitCurrentEdit()) {\n                makeActiveCellEditable();\n              }\n            }\n          }\n          handled = true;\n        }\n      } else if (e.which == keyCode.TAB && e.shiftKey && !e.ctrlKey && !e.altKey) {\n        handled = navigatePrev();\n      }\n    }\n\n    if (handled) {\n      // the event has been handled so don't let parent element (bubbling/propagation) or browser (default) handle it\n      e.stopPropagation();\n      e.preventDefault();\n      try {\n        e.originalEvent.keyCode = 0; // prevent default behaviour for special keys in IE browsers (F3, F5, etc.)\n      }\n      // ignore exceptions - setting the original event's keycode throws access denied exception for \"Ctrl\"\n      // (hitting control key only, nothing else), \"Shift\" (maybe others)\n      catch (error) {}\n    }\n  }\n\n  function handleClick(e) {\n    if (!currentEditor) {\n      // if this click resulted in some cell child node getting focus,\n      // don't steal it back - keyboard events will still bubble up\n      // IE9+ seems to default DIVs to tabIndex=0 instead of -1, so check for cell clicks directly.\n      if (e.target != document.activeElement || $(e.target).hasClass(\"slick-cell\")) {\n        setFocus();\n      }\n    }\n\n    var cell = getCellFromEvent(e);\n    if (!cell || currentEditor !== null && activeRow == cell.row && activeCell == cell.cell) {\n      return;\n    }\n\n    trigger(self.onClick, { row: cell.row, cell: cell.cell, grid: self }, e);\n    if (e.isImmediatePropagationStopped()) {\n      return;\n    }\n\n    // this optimisation causes trouble - MLeibman #329\n    //if ((activeCell != cell.cell || activeRow != cell.row) && canCellBeActive(cell.row, cell.cell)) {\n    if (canCellBeActive(cell.row, cell.cell)) {\n      if (!getEditorLock().isActive() || getEditorLock().commitCurrentEdit()) {\n        scrollRowIntoView(cell.row, false);\n\n        var preClickModeOn = e.target && e.target.className === Slick.preClickClassName;\n        var column = columns[cell.cell];\n        var suppressActiveCellChangedEvent = options.editable && column && column.editor && options.suppressActiveCellChangeOnEdit ? true : false;\n        setActiveCellInternal(getCellNode(cell.row, cell.cell), null, preClickModeOn, suppressActiveCellChangedEvent);\n      }\n    }\n  }\n\n  function handleContextMenu(e) {\n    var $cell = $(e.target).closest(\".slick-cell\", $canvas);\n    if ($cell.length === 0) {\n      return;\n    }\n\n    // are we editing this cell?\n    if (activeCellNode === $cell[0] && currentEditor !== null) {\n      return;\n    }\n\n    trigger(self.onContextMenu, { grid: self }, e);\n  }\n\n  function handleDblClick(e) {\n    var cell = getCellFromEvent(e);\n    if (!cell || currentEditor !== null && activeRow == cell.row && activeCell == cell.cell) {\n      return;\n    }\n\n    trigger(self.onDblClick, { row: cell.row, cell: cell.cell, grid: self }, e);\n    if (e.isImmediatePropagationStopped()) {\n      return;\n    }\n\n    if (options.editable) {\n      gotoCell(cell.row, cell.cell, true);\n    }\n  }\n\n  function handleHeaderMouseEnter(e) {\n    trigger(self.onHeaderMouseEnter, {\n      \"column\": $(this).data(\"column\"),\n      \"grid\": self\n    }, e);\n  }\n\n  function handleHeaderMouseLeave(e) {\n    trigger(self.onHeaderMouseLeave, {\n      \"column\": $(this).data(\"column\"),\n      \"grid\": self\n    }, e);\n  }\n\n  function handleHeaderContextMenu(e) {\n    var $header = $(e.target).closest(\".slick-header-column\", \".slick-header-columns\");\n    var column = $header && $header.data(\"column\");\n    trigger(self.onHeaderContextMenu, { column: column, grid: self }, e);\n  }\n\n  function handleHeaderClick(e) {\n    if (columnResizeDragging) return;\n    var $header = $(e.target).closest(\".slick-header-column\", \".slick-header-columns\");\n    var column = $header && $header.data(\"column\");\n    if (column) {\n      trigger(self.onHeaderClick, { column: column, grid: self }, e);\n    }\n  }\n\n  function handleMouseEnter(e) {\n    trigger(self.onMouseEnter, { grid: self }, e);\n  }\n\n  function handleMouseLeave(e) {\n    trigger(self.onMouseLeave, { grid: self }, e);\n  }\n\n  function cellExists(row, cell) {\n    return !(row < 0 || row >= getDataLength() || cell < 0 || cell >= columns.length);\n  }\n\n  function getCellFromPoint(x, y) {\n    var row = getRowFromPosition(y);\n    var cell = 0;\n\n    var w = 0;\n    for (var i = 0; i < columns.length && w < x; i++) {\n      w += columns[i].width;\n      cell++;\n    }\n\n    if (cell < 0) {\n      cell = 0;\n    }\n\n    return { row: row, cell: cell - 1 };\n  }\n\n  function getCellFromNode(cellNode) {\n    // read column number from .l<columnNumber> CSS class\n    var cls = /l\\d+/.exec(cellNode.className);\n    if (!cls) {\n      throw new Error(\"getCellFromNode: cannot get cell - \" + cellNode.className);\n    }\n    return parseInt(cls[0].substr(1, cls[0].length - 1), 10);\n  }\n\n  function getRowFromNode(rowNode) {\n    for (var row in rowsCache) {\n      if (rowsCache[row].rowNode === rowNode) {\n        return row | 0;\n      }\n    }\n\n    return null;\n  }\n\n  function getCellFromEvent(e) {\n    var $cell = $(e.target).closest(\".slick-cell\", $canvas);\n    if (!$cell.length) {\n      return null;\n    }\n\n    var row = getRowFromNode($cell[0].parentNode);\n    var cell = getCellFromNode($cell[0]);\n\n    if (row == null || cell == null) {\n      return null;\n    } else {\n      return {\n        \"row\": row,\n        \"cell\": cell\n      };\n    }\n  }\n\n  function getCellNodeBox(row, cell) {\n    if (!cellExists(row, cell)) {\n      return null;\n    }\n\n    var y1 = getRowTop(row);\n    var y2 = y1 + options.rowHeight - 1;\n    var x1 = 0;\n    for (var i = 0; i < cell; i++) {\n      x1 += columns[i].width;\n    }\n    var x2 = x1 + columns[cell].width;\n\n    return {\n      top: y1,\n      left: x1,\n      bottom: y2,\n      right: x2\n    };\n  }\n\n  //////////////////////////////////////////////////////////////////////////////////////////////\n  // Cell switching\n\n  function resetActiveCell() {\n    setActiveCellInternal(null, false);\n  }\n\n  function setFocus() {\n    if (tabbingDirection == -1) {\n      $focusSink[0].focus();\n    } else {\n      $focusSink2[0].focus();\n    }\n  }\n\n  function scrollCellIntoView(row, cell, doPaging) {\n    scrollRowIntoView(row, doPaging);\n\n    var colspan = getColspan(row, cell);\n    internalScrollColumnIntoView(columnPosLeft[cell], columnPosRight[cell + (colspan > 1 ? colspan - 1 : 0)]);\n  }\n\n  function internalScrollColumnIntoView(left, right) {\n    var scrollRight = scrollLeft + viewportW;\n\n    if (left < scrollLeft) {\n      $viewport.scrollLeft(left);\n      handleScroll();\n      render();\n    } else if (right > scrollRight) {\n      $viewport.scrollLeft(Math.min(left, right - $viewport[0].clientWidth));\n      handleScroll();\n      render();\n    }\n  }\n\n  function scrollColumnIntoView(cell) {\n    internalScrollColumnIntoView(columnPosLeft[cell], columnPosRight[cell]);\n  }\n\n  function setActiveCellInternal(newCell, opt_editMode, preClickModeOn, suppressActiveCellChangedEvent) {\n    if (activeCellNode !== null) {\n      makeActiveCellNormal();\n      $(activeCellNode).removeClass(\"active\");\n      if (rowsCache[activeRow]) {\n        $(rowsCache[activeRow].rowNode).removeClass(\"active\");\n      }\n    }\n\n    var activeCellChanged = activeCellNode !== newCell;\n    activeCellNode = newCell;\n\n    if (activeCellNode != null) {\n      activeRow = getRowFromNode(activeCellNode.parentNode);\n      activeCell = activePosX = getCellFromNode(activeCellNode);\n\n      if (opt_editMode == null) {\n        opt_editMode = activeRow == getDataLength() || options.autoEdit;\n      }\n\n      if (options.showCellSelection) {\n        $(activeCellNode).addClass(\"active\");\n        $(rowsCache[activeRow].rowNode).addClass(\"active\");\n      }\n\n      if (options.editable && opt_editMode && isCellPotentiallyEditable(activeRow, activeCell)) {\n        clearTimeout(h_editorLoader);\n\n        if (options.asyncEditorLoading) {\n          h_editorLoader = setTimeout(function () {\n            makeActiveCellEditable(undefined, preClickModeOn);\n          }, options.asyncEditorLoadDelay);\n        } else {\n          makeActiveCellEditable(undefined, preClickModeOn);\n        }\n      }\n    } else {\n      activeRow = activeCell = null;\n    }\n\n    // this optimisation causes trouble - MLeibman #329\n    //if (activeCellChanged) {\n    if (!suppressActiveCellChangedEvent) {\n      trigger(self.onActiveCellChanged, getActiveCell());\n    }\n    //}\n  }\n\n  function clearTextSelection() {\n    if (document.selection && document.selection.empty) {\n      try {\n        //IE fails here if selected element is not in dom\n        document.selection.empty();\n      } catch (e) {}\n    } else if (window.getSelection) {\n      var sel = window.getSelection();\n      if (sel && sel.removeAllRanges) {\n        sel.removeAllRanges();\n      }\n    }\n  }\n\n  function isCellPotentiallyEditable(row, cell) {\n    var dataLength = getDataLength();\n    // is the data for this row loaded?\n    if (row < dataLength && !getDataItem(row)) {\n      return false;\n    }\n\n    // are we in the Add New row?  can we create new from this cell?\n    if (columns[cell].cannotTriggerInsert && row >= dataLength) {\n      return false;\n    }\n\n    // does this cell have an editor?\n    if (!getEditor(row, cell)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  function makeActiveCellNormal() {\n    if (!currentEditor) {\n      return;\n    }\n    trigger(self.onBeforeCellEditorDestroy, { editor: currentEditor, grid: self });\n    currentEditor.destroy();\n    currentEditor = null;\n\n    if (activeCellNode) {\n      var d = getDataItem(activeRow);\n      $(activeCellNode).removeClass(\"editable invalid\");\n      if (d) {\n        var column = columns[activeCell];\n        var formatter = getFormatter(activeRow, column);\n        var formatterResult = formatter(activeRow, activeCell, getDataItemValueForColumn(d, column), column, d, self);\n        applyFormatResultToCellNode(formatterResult, activeCellNode);\n        invalidatePostProcessingResults(activeRow);\n      }\n    }\n\n    // if there previously was text selected on a page (such as selected text in the edit cell just removed),\n    // IE can't set focus to anything else correctly\n    if (navigator.userAgent.toLowerCase().match(/msie/)) {\n      clearTextSelection();\n    }\n\n    getEditorLock().deactivate(editController);\n  }\n\n  function makeActiveCellEditable(editor, preClickModeOn) {\n    if (!activeCellNode) {\n      return;\n    }\n    if (!options.editable) {\n      throw new Error(\"Grid : makeActiveCellEditable : should never get called when options.editable is false\");\n    }\n\n    // cancel pending async call if there is one\n    clearTimeout(h_editorLoader);\n\n    if (!isCellPotentiallyEditable(activeRow, activeCell)) {\n      return;\n    }\n\n    var columnDef = columns[activeCell];\n    var item = getDataItem(activeRow);\n\n    if (trigger(self.onBeforeEditCell, { row: activeRow, cell: activeCell, item: item, column: columnDef, grid: self }) === false) {\n      setFocus();\n      return;\n    }\n\n    getEditorLock().activate(editController);\n    $(activeCellNode).addClass(\"editable\");\n\n    var useEditor = editor || getEditor(activeRow, activeCell);\n\n    // don't clear the cell if a custom editor is passed through\n    if (!editor && !useEditor.suppressClearOnEdit) {\n      activeCellNode.innerHTML = \"\";\n    }\n\n    currentEditor = new useEditor({\n      grid: self,\n      gridPosition: absBox($container[0]),\n      position: absBox(activeCellNode),\n      container: activeCellNode,\n      column: columnDef,\n      item: item || {},\n      commitChanges: commitEditAndSetFocus,\n      cancelChanges: cancelEditAndSetFocus\n    });\n\n    if (item) {\n      currentEditor.loadValue(item);\n      if (preClickModeOn && currentEditor.preClick) {\n        currentEditor.preClick();\n      }\n    }\n\n    serializedEditorValue = currentEditor.serializeValue();\n\n    if (currentEditor.position) {\n      handleActiveCellPositionChange();\n    }\n  }\n\n  function commitEditAndSetFocus() {\n    // if the commit fails, it would do so due to a validation error\n    // if so, do not steal the focus from the editor\n    if (getEditorLock().commitCurrentEdit()) {\n      setFocus();\n      if (options.autoEdit) {\n        navigateDown();\n      }\n    }\n  }\n\n  function cancelEditAndSetFocus() {\n    if (getEditorLock().cancelCurrentEdit()) {\n      setFocus();\n    }\n  }\n\n  function absBox(elem) {\n    var box = {\n      top: elem.offsetTop,\n      left: elem.offsetLeft,\n      bottom: 0,\n      right: 0,\n      width: $(elem).outerWidth(),\n      height: $(elem).outerHeight(),\n      visible: true };\n    box.bottom = box.top + box.height;\n    box.right = box.left + box.width;\n\n    // walk up the tree\n    var offsetParent = elem.offsetParent;\n    while ((elem = elem.parentNode) != document.body) {\n      if (elem == null) break;\n\n      if (box.visible && elem.scrollHeight != elem.offsetHeight && $(elem).css(\"overflowY\") != \"visible\") {\n        box.visible = box.bottom > elem.scrollTop && box.top < elem.scrollTop + elem.clientHeight;\n      }\n\n      if (box.visible && elem.scrollWidth != elem.offsetWidth && $(elem).css(\"overflowX\") != \"visible\") {\n        box.visible = box.right > elem.scrollLeft && box.left < elem.scrollLeft + elem.clientWidth;\n      }\n\n      box.left -= elem.scrollLeft;\n      box.top -= elem.scrollTop;\n\n      if (elem === offsetParent) {\n        box.left += elem.offsetLeft;\n        box.top += elem.offsetTop;\n        offsetParent = elem.offsetParent;\n      }\n\n      box.bottom = box.top + box.height;\n      box.right = box.left + box.width;\n    }\n\n    return box;\n  }\n\n  function getActiveCellPosition() {\n    return absBox(activeCellNode);\n  }\n\n  function getGridPosition() {\n    return absBox($container[0]);\n  }\n\n  function handleActiveCellPositionChange() {\n    if (!activeCellNode) {\n      return;\n    }\n\n    trigger(self.onActiveCellPositionChanged, { grid: self });\n\n    if (currentEditor) {\n      var cellBox = getActiveCellPosition();\n      if (currentEditor.show && currentEditor.hide) {\n        if (!cellBox.visible) {\n          currentEditor.hide();\n        } else {\n          currentEditor.show();\n        }\n      }\n\n      if (currentEditor.position) {\n        currentEditor.position(cellBox);\n      }\n    }\n  }\n\n  function getCellEditor() {\n    return currentEditor;\n  }\n\n  function getActiveCell() {\n    if (!activeCellNode) {\n      return null;\n    } else {\n      return { row: activeRow, cell: activeCell, grid: self };\n    }\n  }\n\n  function getActiveCellNode() {\n    return activeCellNode;\n  }\n\n  function scrollRowIntoView(row, doPaging) {\n    var rowAtTop = row * options.rowHeight;\n    var rowAtBottom = (row + 1) * options.rowHeight - viewportH + (viewportHasHScroll ? scrollbarDimensions.height : 0);\n\n    // need to page down?\n    if ((row + 1) * options.rowHeight > scrollTop + viewportH + offset) {\n      scrollTo(doPaging ? rowAtTop : rowAtBottom);\n      render();\n    }\n    // or page up?\n    else if (row * options.rowHeight < scrollTop + offset) {\n        scrollTo(doPaging ? rowAtBottom : rowAtTop);\n        render();\n      }\n  }\n\n  function scrollRowToTop(row) {\n    scrollTo(row * options.rowHeight);\n    render();\n  }\n\n  function scrollPage(dir) {\n    var deltaRows = dir * numVisibleRows;\n    scrollTo((getRowFromPosition(scrollTop) + deltaRows) * options.rowHeight);\n    render();\n\n    if (options.enableCellNavigation && activeRow != null) {\n      var row = activeRow + deltaRows;\n      var dataLengthIncludingAddNew = getDataLengthIncludingAddNew();\n      if (row >= dataLengthIncludingAddNew) {\n        row = dataLengthIncludingAddNew - 1;\n      }\n      if (row < 0) {\n        row = 0;\n      }\n\n      var cell = 0,\n          prevCell = null;\n      var prevActivePosX = activePosX;\n      while (cell <= activePosX) {\n        if (canCellBeActive(row, cell)) {\n          prevCell = cell;\n        }\n        cell += getColspan(row, cell);\n      }\n\n      if (prevCell !== null) {\n        setActiveCellInternal(getCellNode(row, prevCell));\n        activePosX = prevActivePosX;\n      } else {\n        resetActiveCell();\n      }\n    }\n  }\n\n  function navigatePageDown() {\n    scrollPage(1);\n  }\n\n  function navigatePageUp() {\n    scrollPage(-1);\n  }\n\n  function navigateTop() {\n    navigateToRow(0);\n  }\n\n  function navigateBottom() {\n    navigateToRow(getDataLength() - 1);\n  }\n\n  function navigateToRow(row) {\n    var num_rows = getDataLength();\n    if (!num_rows) return true;\n\n    if (row < 0) row = 0;else if (row >= num_rows) row = num_rows - 1;\n\n    scrollCellIntoView(row, 0, true);\n    if (options.enableCellNavigation && activeRow != null) {\n      var cell = 0,\n          prevCell = null;\n      var prevActivePosX = activePosX;\n      while (cell <= activePosX) {\n        if (canCellBeActive(row, cell)) {\n          prevCell = cell;\n        }\n        cell += getColspan(row, cell);\n      }\n\n      if (prevCell !== null) {\n        setActiveCellInternal(getCellNode(row, prevCell));\n        activePosX = prevActivePosX;\n      } else {\n        resetActiveCell();\n      }\n    }\n    return true;\n  }\n\n  function getColspan(row, cell) {\n    var metadata = data.getItemMetadata && data.getItemMetadata(row);\n    if (!metadata || !metadata.columns) {\n      return 1;\n    }\n\n    var columnData = metadata.columns[columns[cell].id] || metadata.columns[cell];\n    var colspan = columnData && columnData.colspan;\n    if (colspan === \"*\") {\n      colspan = columns.length - cell;\n    } else {\n      colspan = colspan || 1;\n    }\n\n    return colspan;\n  }\n\n  function findFirstFocusableCell(row) {\n    var cell = 0;\n    while (cell < columns.length) {\n      if (canCellBeActive(row, cell)) {\n        return cell;\n      }\n      cell += getColspan(row, cell);\n    }\n    return null;\n  }\n\n  function findLastFocusableCell(row) {\n    var cell = 0;\n    var lastFocusableCell = null;\n    while (cell < columns.length) {\n      if (canCellBeActive(row, cell)) {\n        lastFocusableCell = cell;\n      }\n      cell += getColspan(row, cell);\n    }\n    return lastFocusableCell;\n  }\n\n  function gotoRight(row, cell, posX) {\n    if (cell >= columns.length) {\n      return null;\n    }\n\n    do {\n      cell += getColspan(row, cell);\n    } while (cell < columns.length && !canCellBeActive(row, cell));\n\n    if (cell < columns.length) {\n      return {\n        \"row\": row,\n        \"cell\": cell,\n        \"posX\": cell\n      };\n    }\n    return null;\n  }\n\n  function gotoLeft(row, cell, posX) {\n    if (cell <= 0) {\n      return null;\n    }\n\n    var firstFocusableCell = findFirstFocusableCell(row);\n    if (firstFocusableCell === null || firstFocusableCell >= cell) {\n      return null;\n    }\n\n    var prev = {\n      \"row\": row,\n      \"cell\": firstFocusableCell,\n      \"posX\": firstFocusableCell\n    };\n    var pos;\n    while (true) {\n      pos = gotoRight(prev.row, prev.cell, prev.posX);\n      if (!pos) {\n        return null;\n      }\n      if (pos.cell >= cell) {\n        return prev;\n      }\n      prev = pos;\n    }\n  }\n\n  function gotoDown(row, cell, posX) {\n    var prevCell;\n    var dataLengthIncludingAddNew = getDataLengthIncludingAddNew();\n    while (true) {\n      if (++row >= dataLengthIncludingAddNew) {\n        return null;\n      }\n\n      prevCell = cell = 0;\n      while (cell <= posX) {\n        prevCell = cell;\n        cell += getColspan(row, cell);\n      }\n\n      if (canCellBeActive(row, prevCell)) {\n        return {\n          \"row\": row,\n          \"cell\": prevCell,\n          \"posX\": posX\n        };\n      }\n    }\n  }\n\n  function gotoUp(row, cell, posX) {\n    var prevCell;\n    while (true) {\n      if (--row < 0) {\n        return null;\n      }\n\n      prevCell = cell = 0;\n      while (cell <= posX) {\n        prevCell = cell;\n        cell += getColspan(row, cell);\n      }\n\n      if (canCellBeActive(row, prevCell)) {\n        return {\n          \"row\": row,\n          \"cell\": prevCell,\n          \"posX\": posX\n        };\n      }\n    }\n  }\n\n  function gotoNext(row, cell, posX) {\n    if (row == null && cell == null) {\n      row = cell = posX = 0;\n      if (canCellBeActive(row, cell)) {\n        return {\n          \"row\": row,\n          \"cell\": cell,\n          \"posX\": cell\n        };\n      }\n    }\n\n    var pos = gotoRight(row, cell, posX);\n    if (pos) {\n      return pos;\n    }\n\n    var firstFocusableCell = null;\n    var dataLengthIncludingAddNew = getDataLengthIncludingAddNew();\n\n    // if at last row, cycle through columns rather than get stuck in the last one\n    if (row === dataLengthIncludingAddNew - 1) {\n      row--;\n    }\n\n    while (++row < dataLengthIncludingAddNew) {\n      firstFocusableCell = findFirstFocusableCell(row);\n      if (firstFocusableCell !== null) {\n        return {\n          \"row\": row,\n          \"cell\": firstFocusableCell,\n          \"posX\": firstFocusableCell\n        };\n      }\n    }\n    return null;\n  }\n\n  function gotoPrev(row, cell, posX) {\n    if (row == null && cell == null) {\n      row = getDataLengthIncludingAddNew() - 1;\n      cell = posX = columns.length - 1;\n      if (canCellBeActive(row, cell)) {\n        return {\n          \"row\": row,\n          \"cell\": cell,\n          \"posX\": cell\n        };\n      }\n    }\n\n    var pos;\n    var lastSelectableCell;\n    while (!pos) {\n      pos = gotoLeft(row, cell, posX);\n      if (pos) {\n        break;\n      }\n      if (--row < 0) {\n        return null;\n      }\n\n      cell = 0;\n      lastSelectableCell = findLastFocusableCell(row);\n      if (lastSelectableCell !== null) {\n        pos = {\n          \"row\": row,\n          \"cell\": lastSelectableCell,\n          \"posX\": lastSelectableCell\n        };\n      }\n    }\n    return pos;\n  }\n\n  function gotoRowStart(row, cell, posX) {\n    var newCell = findFirstFocusableCell(row);\n    if (newCell === null) return null;\n\n    return {\n      \"row\": row,\n      \"cell\": newCell,\n      \"posX\": posX\n    };\n  }\n\n  function gotoRowEnd(row, cell, posX) {\n    var newCell = findLastFocusableCell(row);\n    if (newCell === null) return null;\n\n    return {\n      \"row\": row,\n      \"cell\": newCell,\n      \"posX\": posX\n    };\n  }\n\n  function navigateRight() {\n    return navigate(\"right\");\n  }\n\n  function navigateLeft() {\n    return navigate(\"left\");\n  }\n\n  function navigateDown() {\n    return navigate(\"down\");\n  }\n\n  function navigateUp() {\n    return navigate(\"up\");\n  }\n\n  function navigateNext() {\n    return navigate(\"next\");\n  }\n\n  function navigatePrev() {\n    return navigate(\"prev\");\n  }\n\n  function navigateRowStart() {\n    return navigate(\"home\");\n  }\n\n  function navigateRowEnd() {\n    return navigate(\"end\");\n  }\n\n  /**\r\n   * @param {string} dir Navigation direction.\r\n   * @return {boolean} Whether navigation resulted in a change of active cell.\r\n   */\n  function navigate(dir) {\n    if (!options.enableCellNavigation) {\n      return false;\n    }\n\n    if (!activeCellNode && dir != \"prev\" && dir != \"next\") {\n      return false;\n    }\n\n    if (!getEditorLock().commitCurrentEdit()) {\n      return true;\n    }\n    setFocus();\n\n    var tabbingDirections = {\n      \"up\": -1,\n      \"down\": 1,\n      \"left\": -1,\n      \"right\": 1,\n      \"prev\": -1,\n      \"next\": 1,\n      \"home\": -1,\n      \"end\": 1\n    };\n    tabbingDirection = tabbingDirections[dir];\n\n    var stepFunctions = {\n      \"up\": gotoUp,\n      \"down\": gotoDown,\n      \"left\": gotoLeft,\n      \"right\": gotoRight,\n      \"prev\": gotoPrev,\n      \"next\": gotoNext,\n      \"home\": gotoRowStart,\n      \"end\": gotoRowEnd\n    };\n    var stepFn = stepFunctions[dir];\n    var pos = stepFn(activeRow, activeCell, activePosX);\n    if (pos) {\n      var isAddNewRow = pos.row == getDataLength();\n      scrollCellIntoView(pos.row, pos.cell, !isAddNewRow && options.emulatePagingWhenScrolling);\n      setActiveCellInternal(getCellNode(pos.row, pos.cell));\n      activePosX = pos.posX;\n      return true;\n    } else {\n      setActiveCellInternal(getCellNode(activeRow, activeCell));\n      return false;\n    }\n  }\n\n  function getCellNode(row, cell) {\n    if (rowsCache[row]) {\n      ensureCellNodesInRowsCache(row);\n      return rowsCache[row].cellNodesByColumnIdx[cell];\n    }\n    return null;\n  }\n\n  function setActiveCell(row, cell, opt_editMode, preClickModeOn, suppressActiveCellChangedEvent) {\n    if (!initialized) {\n      return;\n    }\n    if (row > getDataLength() || row < 0 || cell >= columns.length || cell < 0) {\n      return;\n    }\n\n    if (!options.enableCellNavigation) {\n      return;\n    }\n\n    scrollCellIntoView(row, cell, false);\n    setActiveCellInternal(getCellNode(row, cell), opt_editMode, preClickModeOn, suppressActiveCellChangedEvent);\n  }\n\n  function canCellBeActive(row, cell) {\n    if (!options.enableCellNavigation || row >= getDataLengthIncludingAddNew() || row < 0 || cell >= columns.length || cell < 0) {\n      return false;\n    }\n\n    var rowMetadata = data.getItemMetadata && data.getItemMetadata(row);\n    if (rowMetadata && typeof rowMetadata.focusable !== \"undefined\") {\n      return !!rowMetadata.focusable;\n    }\n\n    var columnMetadata = rowMetadata && rowMetadata.columns;\n    if (columnMetadata && columnMetadata[columns[cell].id] && typeof columnMetadata[columns[cell].id].focusable !== \"undefined\") {\n      return !!columnMetadata[columns[cell].id].focusable;\n    }\n    if (columnMetadata && columnMetadata[cell] && typeof columnMetadata[cell].focusable !== \"undefined\") {\n      return !!columnMetadata[cell].focusable;\n    }\n\n    return !!columns[cell].focusable;\n  }\n\n  function canCellBeSelected(row, cell) {\n    if (row >= getDataLength() || row < 0 || cell >= columns.length || cell < 0) {\n      return false;\n    }\n\n    var rowMetadata = data.getItemMetadata && data.getItemMetadata(row);\n    if (rowMetadata && typeof rowMetadata.selectable !== \"undefined\") {\n      return !!rowMetadata.selectable;\n    }\n\n    var columnMetadata = rowMetadata && rowMetadata.columns && (rowMetadata.columns[columns[cell].id] || rowMetadata.columns[cell]);\n    if (columnMetadata && typeof columnMetadata.selectable !== \"undefined\") {\n      return !!columnMetadata.selectable;\n    }\n\n    return !!columns[cell].selectable;\n  }\n\n  function gotoCell(row, cell, forceEdit) {\n    if (!initialized) {\n      return;\n    }\n    if (!canCellBeActive(row, cell)) {\n      return;\n    }\n\n    if (!getEditorLock().commitCurrentEdit()) {\n      return;\n    }\n\n    scrollCellIntoView(row, cell, false);\n\n    var newCell = getCellNode(row, cell);\n\n    // if selecting the 'add new' row, start editing right away\n    setActiveCellInternal(newCell, forceEdit || row === getDataLength() || options.autoEdit, null, options.editable);\n\n    // if no editor was created, set the focus back on the grid\n    if (!currentEditor) {\n      setFocus();\n    }\n  }\n\n  //////////////////////////////////////////////////////////////////////////////////////////////\n  // IEditor implementation for the editor lock\n\n  function commitCurrentEdit() {\n    var item = getDataItem(activeRow);\n    var column = columns[activeCell];\n\n    if (currentEditor) {\n      if (currentEditor.isValueChanged()) {\n        var validationResults = currentEditor.validate();\n\n        if (validationResults.valid) {\n          if (activeRow < getDataLength()) {\n            var editCommand = {\n              row: activeRow,\n              cell: activeCell,\n              editor: currentEditor,\n              serializedValue: currentEditor.serializeValue(),\n              prevSerializedValue: serializedEditorValue,\n              execute: function execute() {\n                this.editor.applyValue(item, this.serializedValue);\n                updateRow(this.row);\n                trigger(self.onCellChange, {\n                  row: this.row,\n                  cell: this.cell,\n                  item: item,\n                  grid: self\n                });\n              },\n              undo: function undo() {\n                this.editor.applyValue(item, this.prevSerializedValue);\n                updateRow(this.row);\n                trigger(self.onCellChange, {\n                  row: this.row,\n                  cell: this.cell,\n                  item: item,\n                  grid: self\n                });\n              }\n            };\n\n            if (options.editCommandHandler) {\n              makeActiveCellNormal();\n              options.editCommandHandler(item, column, editCommand);\n            } else {\n              editCommand.execute();\n              makeActiveCellNormal();\n            }\n          } else {\n            var newItem = {};\n            currentEditor.applyValue(newItem, currentEditor.serializeValue());\n            makeActiveCellNormal();\n            trigger(self.onAddNewRow, { item: newItem, column: column, grid: self });\n          }\n\n          // check whether the lock has been re-acquired by event handlers\n          return !getEditorLock().isActive();\n        } else {\n          // Re-add the CSS class to trigger transitions, if any.\n          $(activeCellNode).removeClass(\"invalid\");\n          $(activeCellNode).width(); // force layout\n          $(activeCellNode).addClass(\"invalid\");\n\n          trigger(self.onValidationError, {\n            editor: currentEditor,\n            cellNode: activeCellNode,\n            validationResults: validationResults,\n            row: activeRow,\n            cell: activeCell,\n            column: column,\n            grid: self\n          });\n\n          currentEditor.focus();\n          return false;\n        }\n      }\n\n      makeActiveCellNormal();\n    }\n    return true;\n  }\n\n  function cancelCurrentEdit() {\n    makeActiveCellNormal();\n    return true;\n  }\n\n  function rowsToRanges(rows) {\n    var ranges = [];\n    var lastCell = columns.length - 1;\n    for (var i = 0; i < rows.length; i++) {\n      ranges.push(new Slick.Range(rows[i], 0, rows[i], lastCell));\n    }\n    return ranges;\n  }\n\n  function getSelectedRows() {\n    if (!selectionModel) {\n      throw new Error(\"Selection model is not set\");\n    }\n    return selectedRows;\n  }\n\n  function setSelectedRows(rows) {\n    if (!selectionModel) {\n      throw new Error(\"Selection model is not set\");\n    }\n    selectionModel.setSelectedRanges(rowsToRanges(rows));\n  }\n\n  //////////////////////////////////////////////////////////////////////////////////////////////\n  // Debug\n\n  this.debug = function () {\n    var s = \"\";\n\n    s += \"\\n\" + \"counter_rows_rendered:  \" + counter_rows_rendered;\n    s += \"\\n\" + \"counter_rows_removed:  \" + counter_rows_removed;\n    s += \"\\n\" + \"renderedRows:  \" + renderedRows;\n    s += \"\\n\" + \"numVisibleRows:  \" + numVisibleRows;\n    s += \"\\n\" + \"maxSupportedCssHeight:  \" + maxSupportedCssHeight;\n    s += \"\\n\" + \"n(umber of pages):  \" + n;\n    s += \"\\n\" + \"(current) page:  \" + page;\n    s += \"\\n\" + \"page height (ph):  \" + ph;\n    s += \"\\n\" + \"vScrollDir:  \" + vScrollDir;\n\n    alert(s);\n  };\n\n  // a debug helper to be able to access private members\n  this.eval = function (expr) {\n    return eval(expr);\n  };\n\n  //////////////////////////////////////////////////////////////////////////////////////////////\n  // Public API\n\n  $.extend(this, {\n    \"slickGridVersion\": \"2.3.19\",\n\n    // Events\n    \"onScroll\": new Slick.Event(),\n    \"onSort\": new Slick.Event(),\n    \"onHeaderMouseEnter\": new Slick.Event(),\n    \"onHeaderMouseLeave\": new Slick.Event(),\n    \"onHeaderContextMenu\": new Slick.Event(),\n    \"onHeaderClick\": new Slick.Event(),\n    \"onHeaderCellRendered\": new Slick.Event(),\n    \"onBeforeHeaderCellDestroy\": new Slick.Event(),\n    \"onHeaderRowCellRendered\": new Slick.Event(),\n    \"onFooterRowCellRendered\": new Slick.Event(),\n    \"onBeforeHeaderRowCellDestroy\": new Slick.Event(),\n    \"onBeforeFooterRowCellDestroy\": new Slick.Event(),\n    \"onMouseEnter\": new Slick.Event(),\n    \"onMouseLeave\": new Slick.Event(),\n    \"onClick\": new Slick.Event(),\n    \"onDblClick\": new Slick.Event(),\n    \"onContextMenu\": new Slick.Event(),\n    \"onKeyDown\": new Slick.Event(),\n    \"onAddNewRow\": new Slick.Event(),\n    \"onBeforeAppendCell\": new Slick.Event(),\n    \"onValidationError\": new Slick.Event(),\n    \"onViewportChanged\": new Slick.Event(),\n    \"onColumnsReordered\": new Slick.Event(),\n    \"onColumnsResized\": new Slick.Event(),\n    \"onCellChange\": new Slick.Event(),\n    \"onBeforeEditCell\": new Slick.Event(),\n    \"onBeforeCellEditorDestroy\": new Slick.Event(),\n    \"onBeforeDestroy\": new Slick.Event(),\n    \"onActiveCellChanged\": new Slick.Event(),\n    \"onActiveCellPositionChanged\": new Slick.Event(),\n    \"onDragInit\": new Slick.Event(),\n    \"onDragStart\": new Slick.Event(),\n    \"onDrag\": new Slick.Event(),\n    \"onDragEnd\": new Slick.Event(),\n    \"onSelectedRowsChanged\": new Slick.Event(),\n    \"onCellCssStylesChanged\": new Slick.Event(),\n\n    // Methods\n    \"registerPlugin\": registerPlugin,\n    \"unregisterPlugin\": unregisterPlugin,\n    \"getColumns\": getColumns,\n    \"setColumns\": setColumns,\n    \"getColumnIndex\": getColumnIndex,\n    \"updateColumnHeader\": updateColumnHeader,\n    \"setSortColumn\": setSortColumn,\n    \"setSortColumns\": setSortColumns,\n    \"getSortColumns\": getSortColumns,\n    \"autosizeColumns\": autosizeColumns,\n    \"getOptions\": getOptions,\n    \"setOptions\": setOptions,\n    \"getData\": getData,\n    \"getDataLength\": getDataLength,\n    \"getDataItem\": getDataItem,\n    \"setData\": setData,\n    \"getSelectionModel\": getSelectionModel,\n    \"setSelectionModel\": setSelectionModel,\n    \"getSelectedRows\": getSelectedRows,\n    \"setSelectedRows\": setSelectedRows,\n    \"getContainerNode\": getContainerNode,\n    \"updatePagingStatusFromView\": updatePagingStatusFromView,\n\n    \"render\": render,\n    \"invalidate\": invalidate,\n    \"invalidateRow\": invalidateRow,\n    \"invalidateRows\": invalidateRows,\n    \"invalidateAllRows\": invalidateAllRows,\n    \"updateCell\": updateCell,\n    \"updateRow\": updateRow,\n    \"getViewport\": getVisibleRange,\n    \"getRenderedRange\": getRenderedRange,\n    \"resizeCanvas\": resizeCanvas,\n    \"updateRowCount\": updateRowCount,\n    \"scrollRowIntoView\": scrollRowIntoView,\n    \"scrollRowToTop\": scrollRowToTop,\n    \"scrollCellIntoView\": scrollCellIntoView,\n    \"scrollColumnIntoView\": scrollColumnIntoView,\n    \"getCanvasNode\": getCanvasNode,\n    \"getUID\": getUID,\n    \"getHeaderColumnWidthDiff\": getHeaderColumnWidthDiff,\n    \"getScrollbarDimensions\": getScrollbarDimensions,\n    \"getHeadersWidth\": getHeadersWidth,\n    \"getCanvasWidth\": getCanvasWidth,\n    \"focus\": setFocus,\n    \"scrollTo\": scrollTo,\n\n    \"getCellFromPoint\": getCellFromPoint,\n    \"getCellFromEvent\": getCellFromEvent,\n    \"getActiveCell\": getActiveCell,\n    \"setActiveCell\": setActiveCell,\n    \"getActiveCellNode\": getActiveCellNode,\n    \"getActiveCellPosition\": getActiveCellPosition,\n    \"resetActiveCell\": resetActiveCell,\n    \"editActiveCell\": makeActiveCellEditable,\n    \"getCellEditor\": getCellEditor,\n    \"getCellNode\": getCellNode,\n    \"getCellNodeBox\": getCellNodeBox,\n    \"canCellBeSelected\": canCellBeSelected,\n    \"canCellBeActive\": canCellBeActive,\n    \"navigatePrev\": navigatePrev,\n    \"navigateNext\": navigateNext,\n    \"navigateUp\": navigateUp,\n    \"navigateDown\": navigateDown,\n    \"navigateLeft\": navigateLeft,\n    \"navigateRight\": navigateRight,\n    \"navigatePageUp\": navigatePageUp,\n    \"navigatePageDown\": navigatePageDown,\n    \"navigateTop\": navigateTop,\n    \"navigateBottom\": navigateBottom,\n    \"navigateRowStart\": navigateRowStart,\n    \"navigateRowEnd\": navigateRowEnd,\n    \"gotoCell\": gotoCell,\n    \"getTopPanel\": getTopPanel,\n    \"setTopPanelVisibility\": setTopPanelVisibility,\n    \"getPreHeaderPanel\": getPreHeaderPanel,\n    \"setPreHeaderPanelVisibility\": setPreHeaderPanelVisibility,\n    \"getHeader\": getHeader,\n    \"getHeaderColumn\": getHeaderColumn,\n    \"setHeaderRowVisibility\": setHeaderRowVisibility,\n    \"getHeaderRow\": getHeaderRow,\n    \"getHeaderRowColumn\": getHeaderRowColumn,\n    \"setFooterRowVisibility\": setFooterRowVisibility,\n    \"getFooterRow\": getFooterRow,\n    \"getFooterRowColumn\": getFooterRowColumn,\n    \"getGridPosition\": getGridPosition,\n    \"flashCell\": flashCell,\n    \"addCellCssStyles\": addCellCssStyles,\n    \"setCellCssStyles\": setCellCssStyles,\n    \"removeCellCssStyles\": removeCellCssStyles,\n    \"getCellCssStyles\": getCellCssStyles,\n\n    \"init\": finishInitialization,\n    \"destroy\": destroy,\n\n    // IEditor implementation\n    \"getEditorLock\": getEditorLock,\n    \"getEditController\": getEditController\n  });\n\n  init();\n}\n\n//Slick.Grid=SlickGrid;\nexports.Slick = Slick;\nexports.SlickGrid = SlickGrid;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdmVuZG9yL3NsaWNrLmdyaWQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL3ZlbmRvci9zbGljay5ncmlkLmpzP2E4MDciXSwic291cmNlc0NvbnRlbnQiOlsiLyohXHJcbiAqIGpxdWVyeS5ldmVudC5kcmFnIC0gdiAyLjMuMFxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAgVGhyZWUgRHViIE1lZGlhIC0gaHR0cDovL3RocmVlZHVibWVkaWEuY29tXHJcbiAqIE9wZW4gU291cmNlIE1JVCBMaWNlbnNlIC0gaHR0cDovL3RocmVlZHVibWVkaWEuY29tL2NvZGUvbGljZW5zZVxyXG4gKi9cclxuLy8gQ3JlYXRlZDogMjAwOC0wNi0wNFxyXG4vLyBVcGRhdGVkOiAyMDEyLTA1LTIxXHJcbi8vIFVwZGF0ZWQ6IDIwMTYtMDgtMTYgICBMdWl6IEdvbnphZ2EgZG9zIFNhbnRvcyBGaWxob1xyXG4vLyBSRVFVSVJFUzoganF1ZXJ5IDEuOCArLCAsIGV2ZW50LmRyYWcgMi4zLjBcclxuLy8gVEVTVEVEIFdJVEg6IGpRdWVyeSAxLjguMywgMS4xMS4yLCAyLjIuNCwgYW5kIDMuMS4wXHJcblxyXG47KGZ1bmN0aW9uKCAkICkge1xyXG4gICAgLy8gYWRkIHRoZSBqcXVlcnkgaW5zdGFuY2UgbWV0aG9kXHJcbiAgICAkLmZuLmRyYWcgPSBmdW5jdGlvbiggc3RyLCBhcmcsIG9wdHMgKXtcclxuICAgICAgICAvLyBmaWd1cmUgb3V0IHRoZSBldmVudCB0eXBlXHJcbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2Ygc3RyID09IFwic3RyaW5nXCIgPyBzdHIgOiBcIlwiLFxyXG4gICAgICAgICAgICAvLyBmaWd1cmUgb3V0IHRoZSBldmVudCBoYW5kbGVyLi4uXHJcbiAgICAgICAgICAgIGZuID0gJC5pc0Z1bmN0aW9uKCBzdHIgKSA/IHN0ciA6ICQuaXNGdW5jdGlvbiggYXJnICkgPyBhcmcgOiBudWxsO1xyXG4gICAgICAgIC8vIGZpeCB0aGUgZXZlbnQgdHlwZVxyXG4gICAgICAgIGlmICggdHlwZS5pbmRleE9mKFwiZHJhZ1wiKSAhPT0gMCApXHJcbiAgICAgICAgICAgIHR5cGUgPSBcImRyYWdcIisgdHlwZTtcclxuICAgICAgICAvLyB3ZXJlIG9wdGlvbnMgcGFzc2VkXHJcbiAgICAgICAgb3B0cyA9ICggc3RyID09IGZuID8gYXJnIDogb3B0cyApIHx8IHt9O1xyXG4gICAgICAgIC8vIHRyaWdnZXIgb3IgYmluZCBldmVudCBoYW5kbGVyXHJcbiAgICAgICAgcmV0dXJuIGZuID8gdGhpcy5vbiggdHlwZSwgb3B0cywgZm4gKSA6IHRoaXMudHJpZ2dlciggdHlwZSApO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBsb2NhbCByZWZzIChpbmNyZWFzZSBjb21wcmVzc2lvbilcclxuICAgIHZhciAkZXZlbnQgPSAkLmV2ZW50LFxyXG4gICAgICAgICRzcGVjaWFsID0gJGV2ZW50LnNwZWNpYWwsXHJcbiAgICAgICAgLy8gY29uZmlndXJlIHRoZSBkcmFnIHNwZWNpYWwgZXZlbnRcclxuICAgICAgICBkcmFnID0gJHNwZWNpYWwuZHJhZyA9IHtcclxuXHJcbiAgICAgICAgICAgIC8vIHRoZXNlIGFyZSB0aGUgZGVmYXVsdCBzZXR0aW5nc1xyXG4gICAgICAgICAgICBkZWZhdWx0czoge1xyXG4gICAgICAgICAgICAgICAgd2hpY2g6IDEsIC8vIG1vdXNlIGJ1dHRvbiBwcmVzc2VkIHRvIHN0YXJ0IGRyYWcgc2VxdWVuY2VcclxuICAgICAgICAgICAgICAgIGRpc3RhbmNlOiAwLCAvLyBkaXN0YW5jZSBkcmFnZ2VkIGJlZm9yZSBkcmFnc3RhcnRcclxuICAgICAgICAgICAgICAgIG5vdDogJzppbnB1dCcsIC8vIHNlbGVjdG9yIHRvIHN1cHByZXNzIGRyYWdnaW5nIG9uIHRhcmdldCBlbGVtZW50c1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlOiBudWxsLCAvLyBzZWxlY3RvciB0byBtYXRjaCBoYW5kbGUgdGFyZ2V0IGVsZW1lbnRzXHJcbiAgICAgICAgICAgICAgICByZWxhdGl2ZTogZmFsc2UsIC8vIHRydWUgdG8gdXNlIFwicG9zaXRpb25cIiwgZmFsc2UgdG8gdXNlIFwib2Zmc2V0XCJcclxuICAgICAgICAgICAgICAgIGRyb3A6IHRydWUsIC8vIGZhbHNlIHRvIHN1cHByZXNzIGRyb3AgZXZlbnRzLCB0cnVlIG9yIHNlbGVjdG9yIHRvIGFsbG93XHJcbiAgICAgICAgICAgICAgICBjbGljazogZmFsc2UgLy8gZmFsc2UgdG8gc3VwcHJlc3MgY2xpY2sgZXZlbnRzIGFmdGVyIGRyYWdlbmQgKG5vIHByb3h5KVxyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgLy8gdGhlIGtleSBuYW1lIGZvciBzdG9yZWQgZHJhZyBkYXRhXHJcbiAgICAgICAgICAgIGRhdGFrZXk6IFwiZHJhZ2RhdGFcIixcclxuXHJcbiAgICAgICAgICAgIC8vIHByZXZlbnQgYnViYmxpbmcgZm9yIGJldHRlciBwZXJmb3JtYW5jZVxyXG4gICAgICAgICAgICBub0J1YmJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgICAgIC8vIGNvdW50IGJvdW5kIHJlbGF0ZWQgZXZlbnRzXHJcbiAgICAgICAgICAgIGFkZDogZnVuY3Rpb24oIG9iaiApe1xyXG4gICAgICAgICAgICAgICAgLy8gcmVhZCB0aGUgaW50ZXJhY3Rpb24gZGF0YVxyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSAkLmRhdGEoIHRoaXMsIGRyYWcuZGF0YWtleSApLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlYWQgYW55IHBhc3NlZCBvcHRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgb3B0cyA9IG9iai5kYXRhIHx8IHt9O1xyXG4gICAgICAgICAgICAgICAgLy8gY291bnQgYW5vdGhlciByZWFsdGVkIGV2ZW50XHJcbiAgICAgICAgICAgICAgICBkYXRhLnJlbGF0ZWQgKz0gMTtcclxuICAgICAgICAgICAgICAgIC8vIGV4dGVuZCBkYXRhIG9wdGlvbnMgYm91bmQgd2l0aCB0aGlzIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAvLyBkb24ndCBpdGVyYXRlIFwib3B0c1wiIGluIGNhc2UgaXQgaXMgYSBub2RlXHJcbiAgICAgICAgICAgICAgICAkLmVhY2goIGRyYWcuZGVmYXVsdHMsIGZ1bmN0aW9uKCBrZXksIGRlZiApe1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggb3B0c1sga2V5IF0gIT09IHVuZGVmaW5lZCApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbIGtleSBdID0gb3B0c1sga2V5IF07XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIC8vIGZvcmdldCB1bmJvdW5kIHJlbGF0ZWQgZXZlbnRzXHJcbiAgICAgICAgICAgIHJlbW92ZTogZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgICQuZGF0YSggdGhpcywgZHJhZy5kYXRha2V5ICkucmVsYXRlZCAtPSAxO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgLy8gY29uZmlndXJlIGludGVyYWN0aW9uLCBjYXB0dXJlIHNldHRpbmdzXHJcbiAgICAgICAgICAgIHNldHVwOiBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHJlbGF0ZWQgZXZlbnRzXHJcbiAgICAgICAgICAgICAgICBpZiAoICQuZGF0YSggdGhpcywgZHJhZy5kYXRha2V5ICkgKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIC8vIGluaXRpYWxpemUgdGhlIGRyYWcgZGF0YSB3aXRoIGNvcGllZCBkZWZhdWx0c1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSAkLmV4dGVuZCh7IHJlbGF0ZWQ6MCB9LCBkcmFnLmRlZmF1bHRzICk7XHJcbiAgICAgICAgICAgICAgICAvLyBzdG9yZSB0aGUgaW50ZXJhY3Rpb24gZGF0YVxyXG4gICAgICAgICAgICAgICAgJC5kYXRhKCB0aGlzLCBkcmFnLmRhdGFrZXksIGRhdGEgKTtcclxuICAgICAgICAgICAgICAgIC8vIGJpbmQgdGhlIG1vdXNlZG93biBldmVudCwgd2hpY2ggc3RhcnRzIGRyYWcgaW50ZXJhY3Rpb25zXHJcbiAgICAgICAgICAgICAgICAkZXZlbnQuYWRkKCB0aGlzLCBcInRvdWNoc3RhcnQgbW91c2Vkb3duXCIsIGRyYWcuaW5pdCwgZGF0YSApO1xyXG4gICAgICAgICAgICAgICAgLy8gcHJldmVudCBpbWFnZSBkcmFnZ2luZyBpbiBJRS4uLlxyXG4gICAgICAgICAgICAgICAgaWYgKCB0aGlzLmF0dGFjaEV2ZW50IClcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaEV2ZW50KFwib25kcmFnc3RhcnRcIiwgZHJhZy5kb250c3RhcnQgKTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIC8vIGRlc3Ryb3kgY29uZmlndXJlZCBpbnRlcmFjdGlvblxyXG4gICAgICAgICAgICB0ZWFyZG93bjogZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gJC5kYXRhKCB0aGlzLCBkcmFnLmRhdGFrZXkgKSB8fCB7fTtcclxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciByZWxhdGVkIGV2ZW50c1xyXG4gICAgICAgICAgICAgICAgaWYgKCBkYXRhLnJlbGF0ZWQgKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgc3RvcmVkIGRhdGFcclxuICAgICAgICAgICAgICAgICQucmVtb3ZlRGF0YSggdGhpcywgZHJhZy5kYXRha2V5ICk7XHJcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIG1vdXNlZG93biBldmVudFxyXG4gICAgICAgICAgICAgICAgJGV2ZW50LnJlbW92ZSggdGhpcywgXCJ0b3VjaHN0YXJ0IG1vdXNlZG93blwiLCBkcmFnLmluaXQgKTtcclxuICAgICAgICAgICAgICAgIC8vIGVuYWJsZSB0ZXh0IHNlbGVjdGlvblxyXG4gICAgICAgICAgICAgICAgZHJhZy50ZXh0c2VsZWN0KCB0cnVlICk7XHJcbiAgICAgICAgICAgICAgICAvLyB1bi1wcmV2ZW50IGltYWdlIGRyYWdnaW5nIGluIElFLi4uXHJcbiAgICAgICAgICAgICAgICBpZiAoIHRoaXMuZGV0YWNoRXZlbnQgKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGV0YWNoRXZlbnQoXCJvbmRyYWdzdGFydFwiLCBkcmFnLmRvbnRzdGFydCApO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgLy8gaW5pdGlhbGl6ZSB0aGUgaW50ZXJhY3Rpb25cclxuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24oIGV2ZW50ICl7XHJcbiAgICAgICAgICAgICAgICAvLyBzb3JyeSwgb25seSBvbmUgdG91Y2ggYXQgYSB0aW1lXHJcbiAgICAgICAgICAgICAgICBpZiAoIGRyYWcudG91Y2hlZCApXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgLy8gdGhlIGRyYWcvZHJvcCBpbnRlcmFjdGlvbiBkYXRhXHJcbiAgICAgICAgICAgICAgICB2YXIgZGQgPSBldmVudC5kYXRhLCByZXN1bHRzO1xyXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgdGhlIHdoaWNoIGRpcmVjdGl2ZVxyXG4gICAgICAgICAgICAgICAgaWYgKCBldmVudC53aGljaCAhPSAwICYmIGRkLndoaWNoID4gMCAmJiBldmVudC53aGljaCAhPSBkZC53aGljaCApXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHN1cHByZXNzZWQgc2VsZWN0b3JcclxuICAgICAgICAgICAgICAgIGlmICggJCggZXZlbnQudGFyZ2V0ICkuaXMoIGRkLm5vdCApIClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgaGFuZGxlIHNlbGVjdG9yXHJcbiAgICAgICAgICAgICAgICBpZiAoIGRkLmhhbmRsZSAmJiAhJCggZXZlbnQudGFyZ2V0ICkuY2xvc2VzdCggZGQuaGFuZGxlLCBldmVudC5jdXJyZW50VGFyZ2V0ICkubGVuZ3RoIClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgZHJhZy50b3VjaGVkID0gZXZlbnQudHlwZSA9PSAndG91Y2hzdGFydCcgPyB0aGlzIDogbnVsbDtcclxuICAgICAgICAgICAgICAgIGRkLnByb3BhZ2F0ZXMgPSAxO1xyXG4gICAgICAgICAgICAgICAgZGQubW91c2Vkb3duID0gdGhpcztcclxuICAgICAgICAgICAgICAgIGRkLmludGVyYWN0aW9ucyA9IFsgZHJhZy5pbnRlcmFjdGlvbiggdGhpcywgZGQgKSBdO1xyXG4gICAgICAgICAgICAgICAgZGQudGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgZGQucGFnZVggPSBldmVudC5wYWdlWDtcclxuICAgICAgICAgICAgICAgIGRkLnBhZ2VZID0gZXZlbnQucGFnZVk7XHJcbiAgICAgICAgICAgICAgICBkZC5kcmFnZ2luZyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgZHJhZ2luaXQgZXZlbnQuLi5cclxuICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBkcmFnLmhpamFjayggZXZlbnQsIFwiZHJhZ2luaXRcIiwgZGQgKTtcclxuICAgICAgICAgICAgICAgIC8vIGVhcmx5IGNhbmNlbFxyXG4gICAgICAgICAgICAgICAgaWYgKCAhZGQucHJvcGFnYXRlcyApXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgLy8gZmxhdHRlbiB0aGUgcmVzdWx0IHNldFxyXG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IGRyYWcuZmxhdHRlbiggcmVzdWx0cyApO1xyXG4gICAgICAgICAgICAgICAgLy8gaW5zZXJ0IG5ldyBpbnRlcmFjdGlvbiBlbGVtZW50c1xyXG4gICAgICAgICAgICAgICAgaWYgKCByZXN1bHRzICYmIHJlc3VsdHMubGVuZ3RoICl7XHJcbiAgICAgICAgICAgICAgICAgICAgZGQuaW50ZXJhY3Rpb25zID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgJC5lYWNoKCByZXN1bHRzLCBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZC5pbnRlcmFjdGlvbnMucHVzaCggZHJhZy5pbnRlcmFjdGlvbiggdGhpcywgZGQgKSApO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gcmVtZW1iZXIgaG93IG1hbnkgaW50ZXJhY3Rpb25zIGFyZSBwcm9wYWdhdGluZ1xyXG4gICAgICAgICAgICAgICAgZGQucHJvcGFnYXRlcyA9IGRkLmludGVyYWN0aW9ucy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAvLyBsb2NhdGUgYW5kIGluaXQgdGhlIGRyb3AgdGFyZ2V0c1xyXG4gICAgICAgICAgICAgICAgaWYgKCBkZC5kcm9wICE9PSBmYWxzZSAmJiAkc3BlY2lhbC5kcm9wIClcclxuICAgICAgICAgICAgICAgICAgICAkc3BlY2lhbC5kcm9wLmhhbmRsZXIoIGV2ZW50LCBkZCApO1xyXG4gICAgICAgICAgICAgICAgLy8gZGlzYWJsZSB0ZXh0IHNlbGVjdGlvblxyXG4gICAgICAgICAgICAgICAgZHJhZy50ZXh0c2VsZWN0KCBmYWxzZSApO1xyXG4gICAgICAgICAgICAgICAgLy8gYmluZCBhZGRpdGlvbmFsIGV2ZW50cy4uLlxyXG4gICAgICAgICAgICAgICAgaWYgKCBkcmFnLnRvdWNoZWQgKVxyXG4gICAgICAgICAgICAgICAgICAgICRldmVudC5hZGQoIGRyYWcudG91Y2hlZCwgXCJ0b3VjaG1vdmUgdG91Y2hlbmRcIiwgZHJhZy5oYW5kbGVyLCBkZCApO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICRldmVudC5hZGQoIGRvY3VtZW50LCBcIm1vdXNlbW92ZSBtb3VzZXVwXCIsIGRyYWcuaGFuZGxlciwgZGQgKTtcclxuICAgICAgICAgICAgICAgIC8vIGhlbHBzIHByZXZlbnQgdGV4dCBzZWxlY3Rpb24gb3Igc2Nyb2xsaW5nXHJcbiAgICAgICAgICAgICAgICBpZiAoICFkcmFnLnRvdWNoZWQgfHwgZGQubGl2ZSApXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgLy8gcmV0dXJucyBhbiBpbnRlcmFjdGlvbiBvYmplY3RcclxuICAgICAgICAgICAgaW50ZXJhY3Rpb246IGZ1bmN0aW9uKCBlbGVtLCBkZCApe1xyXG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IChlbGVtICYmIGVsZW0ub3duZXJEb2N1bWVudCkgXHJcbiAgICAgICAgICAgICAgICAgICAgPyAkKCBlbGVtIClbIGRkLnJlbGF0aXZlID8gXCJwb3NpdGlvblwiIDogXCJvZmZzZXRcIiBdKCkgfHwgeyB0b3A6MCwgbGVmdDowIH1cclxuICAgICAgICAgICAgICAgICAgICA6IHsgdG9wOiAwLCBsZWZ0OiAwIH07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGRyYWc6IGVsZW0sXHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IG5ldyBkcmFnLmNhbGxiYWNrKCksXHJcbiAgICAgICAgICAgICAgICAgICAgZHJvcHBhYmxlOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IG9mZnNldFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIC8vIGhhbmRsZSBkcmFnLXJlbGVhdGQgRE9NIGV2ZW50c1xyXG4gICAgICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbiggZXZlbnQgKXtcclxuICAgICAgICAgICAgICAgIC8vIHJlYWQgdGhlIGRhdGEgYmVmb3JlIGhpamFja2luZyBhbnl0aGluZ1xyXG4gICAgICAgICAgICAgICAgdmFyIGRkID0gZXZlbnQuZGF0YTtcclxuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSB2YXJpb3VzIGV2ZW50c1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoICggZXZlbnQudHlwZSApe1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdXNlbW92ZSwgY2hlY2sgZGlzdGFuY2UsIHN0YXJ0IGRyYWdnaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAhZGQuZHJhZ2dpbmcgJiYgJ3RvdWNobW92ZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAhZGQuZHJhZ2dpbmcgJiYgJ21vdXNlbW92ZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICBkcmFnIHRvbGVyYW5jZSwgeMKyICsgecKyID0gZGlzdGFuY2XCslxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIE1hdGgucG93KCAgZXZlbnQucGFnZVgtZGQucGFnZVgsIDIgKSArIE1hdGgucG93KCAgZXZlbnQucGFnZVktZGQucGFnZVksIDIgKSA8IE1hdGgucG93KCBkZC5kaXN0YW5jZSwgMiApIClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBkaXN0YW5jZSB0b2xlcmFuY2Ugbm90IHJlYWNoZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0ID0gZGQudGFyZ2V0OyAvLyBmb3JjZSB0YXJnZXQgZnJvbSBcIm1vdXNlZG93blwiIGV2ZW50IChmaXggZGlzdGFuY2UgaXNzdWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWcuaGlqYWNrKCBldmVudCwgXCJkcmFnc3RhcnRcIiwgZGQgKTsgLy8gdHJpZ2dlciBcImRyYWdzdGFydFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZGQucHJvcGFnYXRlcyApIC8vIFwiZHJhZ3N0YXJ0XCIgbm90IHJlamVjdGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZC5kcmFnZ2luZyA9IHRydWU7IC8vIGFjdGl2YXRlIGludGVyYWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1vdXNlbW92ZSwgZHJhZ2dpbmdcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICd0b3VjaG1vdmUnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21vdXNlbW92ZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZGQuZHJhZ2dpbmcgKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyaWdnZXIgXCJkcmFnXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYWcuaGlqYWNrKCBldmVudCwgXCJkcmFnXCIsIGRkICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGRkLnByb3BhZ2F0ZXMgKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtYW5hZ2UgZHJvcCBldmVudHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGRkLmRyb3AgIT09IGZhbHNlICYmICRzcGVjaWFsLmRyb3AgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc3BlY2lhbC5kcm9wLmhhbmRsZXIoIGV2ZW50LCBkZCApOyAvLyBcImRyb3BzdGFydFwiLCBcImRyb3BlbmRcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBcImRyYWdcIiBub3QgcmVqZWN0ZWQsIHN0b3BcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnR5cGUgPSBcIm1vdXNldXBcIjsgLy8gaGVscHMgXCJkcm9wXCIgaGFuZGxlciBiZWhhdmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtb3VzZXVwLCBzdG9wIGRyYWdnaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndG91Y2hlbmQnOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21vdXNldXAnOlxyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZHJhZy50b3VjaGVkIClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRldmVudC5yZW1vdmUoIGRyYWcudG91Y2hlZCwgXCJ0b3VjaG1vdmUgdG91Y2hlbmRcIiwgZHJhZy5oYW5kbGVyICk7IC8vIHJlbW92ZSB0b3VjaCBldmVudHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGV2ZW50LnJlbW92ZSggZG9jdW1lbnQsIFwibW91c2Vtb3ZlIG1vdXNldXBcIiwgZHJhZy5oYW5kbGVyICk7IC8vIHJlbW92ZSBwYWdlIGV2ZW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGRkLmRyYWdnaW5nICl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGRkLmRyb3AgIT09IGZhbHNlICYmICRzcGVjaWFsLmRyb3AgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzcGVjaWFsLmRyb3AuaGFuZGxlciggZXZlbnQsIGRkICk7IC8vIFwiZHJvcFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcmFnLmhpamFjayggZXZlbnQsIFwiZHJhZ2VuZFwiLCBkZCApOyAvLyB0cmlnZ2VyIFwiZHJhZ2VuZFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZy50ZXh0c2VsZWN0KCB0cnVlICk7IC8vIGVuYWJsZSB0ZXh0IHNlbGVjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBzdXBwcmVzc2luZyBjbGljayBldmVudHMuLi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBkZC5jbGljayA9PT0gZmFsc2UgJiYgZGQuZHJhZ2dpbmcgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJC5kYXRhKCBkZC5tb3VzZWRvd24sIFwic3VwcHJlc3MuY2xpY2tcIiwgbmV3IERhdGUoKS5nZXRUaW1lKCkgKyA1ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRkLmRyYWdnaW5nID0gZHJhZy50b3VjaGVkID0gZmFsc2U7IC8vIGRlYWN0aXZhdGUgZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIC8vIHJlLXVzZSBldmVudCBvYmplY3QgZm9yIGN1c3RvbSBldmVudHNcclxuICAgICAgICAgICAgaGlqYWNrOiBmdW5jdGlvbiggZXZlbnQsIHR5cGUsIGRkLCB4LCBlbGVtICl7XHJcbiAgICAgICAgICAgICAgICAvLyBub3QgY29uZmlndXJlZFxyXG4gICAgICAgICAgICAgICAgaWYgKCAhZGQgKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIC8vIHJlbWVtYmVyIHRoZSBvcmlnaW5hbCBldmVudCBhbmQgdHlwZVxyXG4gICAgICAgICAgICAgICAgdmFyIG9yaWcgPSB7IGV2ZW50OmV2ZW50Lm9yaWdpbmFsRXZlbnQsIHR5cGU6ZXZlbnQudHlwZSB9LFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlzIHRoZSBldmVudCBkcmFnIHJlbGF0ZWQgb3IgZHJvZyByZWxhdGVkP1xyXG4gICAgICAgICAgICAgICAgICAgIG1vZGUgPSB0eXBlLmluZGV4T2YoXCJkcm9wXCIpID8gXCJkcmFnXCIgOiBcImRyb3BcIixcclxuICAgICAgICAgICAgICAgICAgICAvLyBpdGVyYXRpb24gdmFyc1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCwgaSA9IHggfHwgMCwgaWEsICRlbGVtcywgY2FsbGJhY2ssXHJcbiAgICAgICAgICAgICAgICAgICAgbGVuID0gIWlzTmFOKCB4ICkgPyB4IDogZGQuaW50ZXJhY3Rpb25zLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIC8vIG1vZGlmeSB0aGUgZXZlbnQgdHlwZVxyXG4gICAgICAgICAgICAgICAgZXZlbnQudHlwZSA9IHR5cGU7XHJcbiAgICAgICAgICAgICAgICAvLyBwcm90ZWN0cyBvcmlnaW5hbEV2ZW50IGZyb20gc2lkZS1lZmZlY3RzXHJcbiAgICAgICAgICAgICAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uKCl7fTtcclxuICAgICAgICAgICAgICAgIGV2ZW50Lm9yaWdpbmFsRXZlbnQgPSBuZXcgalF1ZXJ5LkV2ZW50KG9yaWcuZXZlbnQsIHtcclxuICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdDogbm9vcCxcclxuICAgICAgICAgICAgICAgICAgICBzdG9wUHJvcGFnYXRpb246IG5vb3AsXHJcbiAgICAgICAgICAgICAgICAgICAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBub29wXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIC8vIGluaXRpYWxpemUgdGhlIHJlc3VsdHNcclxuICAgICAgICAgICAgICAgIGRkLnJlc3VsdHMgPSBbXTtcclxuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBlYWNoIGludGVyYWN0ZWQgZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgZG8gaWYgKCBpYSA9IGRkLmludGVyYWN0aW9uc1sgaSBdICl7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFsaWRhdGUgdGhlIGludGVyYWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0eXBlICE9PSBcImRyYWdlbmRcIiAmJiBpYS5jYW5jZWxsZWQgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBzZXQgdGhlIGRyYWdkcm9wIHByb3BlcnRpZXMgb24gdGhlIGV2ZW50IG9iamVjdFxyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZHJhZy5wcm9wZXJ0aWVzKCBldmVudCwgZGQsIGlhICk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJlcGFyZSBmb3IgbW9yZSByZXN1bHRzXHJcbiAgICAgICAgICAgICAgICAgICAgaWEucmVzdWx0cyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBlYWNoIGVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAkKCBlbGVtIHx8IGlhWyBtb2RlIF0gfHwgZGQuZHJvcHBhYmxlICkuZWFjaChmdW5jdGlvbiggcCwgc3ViamVjdCApe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZGVudGlmeSBkcmFnIG9yIGRyb3AgdGFyZ2V0cyBpbmRpdmlkdWFsbHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sudGFyZ2V0ID0gc3ViamVjdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yY2UgcHJvcGFndGlvbiBvZiB0aGUgY3VzdG9tIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkID0gZnVuY3Rpb24oKXsgcmV0dXJuIGZhbHNlOyB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGUgdGhlIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHN1YmplY3QgPyAkZXZlbnQuZGlzcGF0Y2guY2FsbCggc3ViamVjdCwgZXZlbnQsIGNhbGxiYWNrICkgOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdG9wIHRoZSBkcmFnIGludGVyYWN0aW9uIGZvciB0aGlzIGVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCByZXN1bHQgPT09IGZhbHNlICl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG1vZGUgPT0gXCJkcmFnXCIgKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpYS5jYW5jZWxsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRkLnByb3BhZ2F0ZXMgLT0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdHlwZSA9PSBcImRyb3BcIiApe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlhWyBtb2RlIF1bcF0gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFzc2lnbiBhbnkgZHJvcGluaXQgZWxlbWVudHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIHR5cGUgPT0gXCJkcm9waW5pdFwiIClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlhLmRyb3BwYWJsZS5wdXNoKCBkcmFnLmVsZW1lbnQoIHJlc3VsdCApIHx8IHN1YmplY3QgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWNjZXB0IGEgcmV0dXJuZWQgcHJveHkgZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHR5cGUgPT0gXCJkcmFnc3RhcnRcIiApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpYS5wcm94eSA9ICQoIGRyYWcuZWxlbWVudCggcmVzdWx0ICkgfHwgaWEuZHJhZyApWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1lbWJlciB0aGlzIHJlc3VsdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpYS5yZXN1bHRzLnB1c2goIHJlc3VsdCApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3JnZXQgdGhlIGV2ZW50IHJlc3VsdCwgZm9yIHJlY3ljbGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZXZlbnQucmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBicmVhayBvbiBjYW5jZWxsZWQgaGFuZGxlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHR5cGUgIT09IFwiZHJvcGluaXRcIiApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGZsYXR0ZW4gdGhlIHJlc3VsdHNcclxuICAgICAgICAgICAgICAgICAgICBkZC5yZXN1bHRzWyBpIF0gPSBkcmFnLmZsYXR0ZW4oIGlhLnJlc3VsdHMgKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBhY2NlcHQgYSBzZXQgb2YgdmFsaWQgZHJvcCB0YXJnZXRzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0eXBlID09IFwiZHJvcGluaXRcIiApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlhLmRyb3BwYWJsZSA9IGRyYWcuZmxhdHRlbiggaWEuZHJvcHBhYmxlICk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbG9jYXRlIGRyb3AgdGFyZ2V0c1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggdHlwZSA9PSBcImRyYWdzdGFydFwiICYmICFpYS5jYW5jZWxsZWQgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay51cGRhdGUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHdoaWxlICggKytpIDwgbGVuIClcclxuICAgICAgICAgICAgICAgICAgICAvLyByZXN0b3JlIHRoZSBvcmlnaW5hbCBldmVudCAmIHR5cGVcclxuICAgICAgICAgICAgICAgICAgICBldmVudC50eXBlID0gb3JpZy50eXBlO1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50Lm9yaWdpbmFsRXZlbnQgPSBvcmlnLmV2ZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJldHVybiBhbGwgaGFuZGxlciByZXN1bHRzXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRyYWcuZmxhdHRlbiggZGQucmVzdWx0cyApO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgLy8gZXh0ZW5kIHRoZSBjYWxsYmFjayBvYmplY3Qgd2l0aCBkcmFnL2Ryb3AgcHJvcGVydGllcy4uLlxyXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBmdW5jdGlvbiggZXZlbnQsIGRkLCBpYSApe1xyXG4gICAgICAgICAgICAgICAgdmFyIG9iaiA9IGlhLmNhbGxiYWNrO1xyXG4gICAgICAgICAgICAgICAgLy8gZWxlbWVudHNcclxuICAgICAgICAgICAgICAgIG9iai5kcmFnID0gaWEuZHJhZztcclxuICAgICAgICAgICAgICAgIG9iai5wcm94eSA9IGlhLnByb3h5IHx8IGlhLmRyYWc7XHJcbiAgICAgICAgICAgICAgICAvLyBzdGFydGluZyBtb3VzZSBwb3NpdGlvblxyXG4gICAgICAgICAgICAgICAgb2JqLnN0YXJ0WCA9IGRkLnBhZ2VYO1xyXG4gICAgICAgICAgICAgICAgb2JqLnN0YXJ0WSA9IGRkLnBhZ2VZO1xyXG4gICAgICAgICAgICAgICAgLy8gY3VycmVudCBkaXN0YW5jZSBkcmFnZ2VkXHJcbiAgICAgICAgICAgICAgICBvYmouZGVsdGFYID0gZXZlbnQucGFnZVggLSBkZC5wYWdlWDtcclxuICAgICAgICAgICAgICAgIG9iai5kZWx0YVkgPSBldmVudC5wYWdlWSAtIGRkLnBhZ2VZO1xyXG4gICAgICAgICAgICAgICAgLy8gb3JpZ2luYWwgZWxlbWVudCBwb3NpdGlvblxyXG4gICAgICAgICAgICAgICAgb2JqLm9yaWdpbmFsWCA9IGlhLm9mZnNldC5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgb2JqLm9yaWdpbmFsWSA9IGlhLm9mZnNldC50b3A7XHJcbiAgICAgICAgICAgICAgICAvLyBhZGp1c3RlZCBlbGVtZW50IHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICBvYmoub2Zmc2V0WCA9IG9iai5vcmlnaW5hbFggKyBvYmouZGVsdGFYO1xyXG4gICAgICAgICAgICAgICAgb2JqLm9mZnNldFkgPSBvYmoub3JpZ2luYWxZICsgb2JqLmRlbHRhWTtcclxuICAgICAgICAgICAgICAgIC8vIGFzc2lnbiB0aGUgZHJvcCB0YXJnZXRzIGluZm9ybWF0aW9uXHJcbiAgICAgICAgICAgICAgICBvYmouZHJvcCA9IGRyYWcuZmxhdHRlbiggKCBpYS5kcm9wIHx8IFtdICkuc2xpY2UoKSApO1xyXG4gICAgICAgICAgICAgICAgb2JqLmF2YWlsYWJsZSA9IGRyYWcuZmxhdHRlbiggKCBpYS5kcm9wcGFibGUgfHwgW10gKS5zbGljZSgpICk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIGlzIHRoZSBhcmd1bWVudCBpcyBhbiBlbGVtZW50IG9yIGpxdWVyeSBpbnN0YW5jZVxyXG4gICAgICAgICAgICBlbGVtZW50OiBmdW5jdGlvbiggYXJnICl7XHJcbiAgICAgICAgICAgICAgICBpZiAoIGFyZyAmJiAoIGFyZy5qcXVlcnkgfHwgYXJnLm5vZGVUeXBlID09IDEgKSApXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZztcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIC8vIGZsYXR0ZW4gbmVzdGVkIGpxdWVyeSBvYmplY3RzIGFuZCBhcnJheXMgaW50byBhIHNpbmdsZSBkaW1lbnNpb24gYXJyYXlcclxuICAgICAgICAgICAgZmxhdHRlbjogZnVuY3Rpb24oIGFyciApe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICQubWFwKCBhcnIsIGZ1bmN0aW9uKCBtZW1iZXIgKXtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVtYmVyICYmIG1lbWJlci5qcXVlcnkgPyAkLm1ha2VBcnJheSggbWVtYmVyICkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZW1iZXIgJiYgbWVtYmVyLmxlbmd0aCA/IGRyYWcuZmxhdHRlbiggbWVtYmVyICkgOiBtZW1iZXI7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIC8vIHRvZ2dsZXMgdGV4dCBzZWxlY3Rpb24gYXR0cmlidXRlcyBPTiAodHJ1ZSkgb3IgT0ZGIChmYWxzZSlcclxuICAgICAgICAgICAgdGV4dHNlbGVjdDogZnVuY3Rpb24oIGJvb2wgKXtcclxuICAgICAgICAgICAgICAgICQoIGRvY3VtZW50IClbIGJvb2wgPyBcIm9mZlwiIDogXCJvblwiIF0oXCJzZWxlY3RzdGFydFwiLCBkcmFnLmRvbnRzdGFydCApXHJcbiAgICAgICAgICAgICAgICAgICAgLmNzcyhcIk1velVzZXJTZWxlY3RcIiwgYm9vbCA/IFwiXCIgOiBcIm5vbmVcIiApO1xyXG4gICAgICAgICAgICAgICAgLy8gLmF0dHIoXCJ1bnNlbGVjdGFibGVcIiwgYm9vbCA/IFwib2ZmXCIgOiBcIm9uXCIgKVxyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQudW5zZWxlY3RhYmxlID0gYm9vbCA/IFwib2ZmXCIgOiBcIm9uXCI7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAvLyBzdXBwcmVzcyBcInNlbGVjdHN0YXJ0XCIgYW5kIFwib25kcmFnc3RhcnRcIiBldmVudHNcclxuICAgICAgICAgICAgZG9udHN0YXJ0OiBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgLy8gYSBjYWxsYmFjayBpbnN0YW5jZSBjb250cnVjdG9yXHJcbiAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbigpe31cclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gY2FsbGJhY2sgbWV0aG9kc1xyXG4gICAgICAgIGRyYWcuY2FsbGJhY2sucHJvdG90eXBlID0ge1xyXG4gICAgICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICBpZiAoICRzcGVjaWFsLmRyb3AgJiYgdGhpcy5hdmFpbGFibGUubGVuZ3RoIClcclxuICAgICAgICAgICAgICAgICAgICAkLmVhY2goIHRoaXMuYXZhaWxhYmxlLCBmdW5jdGlvbiggaSApe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkc3BlY2lhbC5kcm9wLmxvY2F0ZSggdGhpcywgaSApO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gcGF0Y2ggJC5ldmVudC4kZGlzcGF0Y2ggdG8gYWxsb3cgc3VwcHJlc3NpbmcgY2xpY2tzXHJcbiAgICAgICAgdmFyICRkaXNwYXRjaCA9ICRldmVudC5kaXNwYXRjaDtcclxuICAgICAgICAkZXZlbnQuZGlzcGF0Y2ggPSBmdW5jdGlvbiggZXZlbnQgKXtcclxuICAgICAgICAgICAgaWYgKCAkLmRhdGEoIHRoaXMsIFwic3VwcHJlc3MuXCIrIGV2ZW50LnR5cGUgKSAtIG5ldyBEYXRlKCkuZ2V0VGltZSgpID4gMCApe1xyXG4gICAgICAgICAgICAgICAgJC5yZW1vdmVEYXRhKCB0aGlzLCBcInN1cHByZXNzLlwiKyBldmVudC50eXBlICk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuICRkaXNwYXRjaC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gc2hhcmUgdGhlIHNhbWUgc3BlY2lhbCBldmVudCBjb25maWd1cmF0aW9uIHdpdGggcmVsYXRlZCBldmVudHMuLi5cclxuICAgICAgICAkc3BlY2lhbC5kcmFnaW5pdCA9ICRzcGVjaWFsLmRyYWdzdGFydCA9ICRzcGVjaWFsLmRyYWdlbmQgPSBkcmFnO1xyXG59KSggalF1ZXJ5ICk7XHJcblxyXG5cclxuXHJcblxyXG4vKioqXHJcbiAqIENvbnRhaW5zIGNvcmUgU2xpY2tHcmlkIGNsYXNzZXMuXHJcbiAqIEBtb2R1bGUgQ29yZVxyXG4gKiBAbmFtZXNwYWNlIFNsaWNrXHJcbiAqL1xyXG4vL2ltcG9ydCAkIGZyb20gJ2pxdWVyeSdcclxuLy9sZXQgalF1ZXJ5PSQ7XHJcbi8vaW1wb3J0ICdqcXVlcnktdWknXHJcblxyXG4gIFxyXG5cclxuICAvKioqXHJcbiAgICogQW4gZXZlbnQgb2JqZWN0IGZvciBwYXNzaW5nIGRhdGEgdG8gZXZlbnQgaGFuZGxlcnMgYW5kIGxldHRpbmcgdGhlbSBjb250cm9sIHByb3BhZ2F0aW9uLlxyXG4gICAqIDxwPlRoaXMgaXMgcHJldHR5IG11Y2ggaWRlbnRpY2FsIHRvIGhvdyBXM0MgYW5kIGpRdWVyeSBpbXBsZW1lbnQgZXZlbnRzLjwvcD5cclxuICAgKiBAY2xhc3MgRXZlbnREYXRhXHJcbiAgICogQGNvbnN0cnVjdG9yXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gRXZlbnREYXRhKCkge1xyXG4gICAgdmFyIGlzUHJvcGFnYXRpb25TdG9wcGVkID0gZmFsc2U7XHJcbiAgICB2YXIgaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSBmYWxzZTtcclxuXHJcbiAgICAvKioqXHJcbiAgICAgKiBTdG9wcyBldmVudCBmcm9tIHByb3BhZ2F0aW5nIHVwIHRoZSBET00gdHJlZS5cclxuICAgICAqIEBtZXRob2Qgc3RvcFByb3BhZ2F0aW9uXHJcbiAgICAgKi9cclxuICAgIHRoaXMuc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICBpc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHRydWU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKipcclxuICAgICAqIFJldHVybnMgd2hldGhlciBzdG9wUHJvcGFnYXRpb24gd2FzIGNhbGxlZCBvbiB0aGlzIGV2ZW50IG9iamVjdC5cclxuICAgICAqIEBtZXRob2QgaXNQcm9wYWdhdGlvblN0b3BwZWRcclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBpc1Byb3BhZ2F0aW9uU3RvcHBlZDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqKlxyXG4gICAgICogUHJldmVudHMgdGhlIHJlc3Qgb2YgdGhlIGhhbmRsZXJzIGZyb20gYmVpbmcgZXhlY3V0ZWQuXHJcbiAgICAgKiBAbWV0aG9kIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvblxyXG4gICAgICovXHJcbiAgICB0aGlzLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSB0cnVlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKioqXHJcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIHdhcyBjYWxsZWQgb24gdGhpcyBldmVudCBvYmplY3QuXFxcclxuICAgICAqIEBtZXRob2QgaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWRcclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKipcclxuICAgKiBBIHNpbXBsZSBwdWJsaXNoZXItc3Vic2NyaWJlciBpbXBsZW1lbnRhdGlvbi5cclxuICAgKiBAY2xhc3MgRXZlbnRcclxuICAgKiBAY29uc3RydWN0b3JcclxuICAgKi9cclxuICBmdW5jdGlvbiBFdmVudCgpIHtcclxuICAgIHZhciBoYW5kbGVycyA9IFtdO1xyXG5cclxuICAgIC8qKipcclxuICAgICAqIEFkZHMgYW4gZXZlbnQgaGFuZGxlciB0byBiZSBjYWxsZWQgd2hlbiB0aGUgZXZlbnQgaXMgZmlyZWQuXHJcbiAgICAgKiA8cD5FdmVudCBoYW5kbGVyIHdpbGwgcmVjZWl2ZSB0d28gYXJndW1lbnRzIC0gYW4gPGNvZGU+RXZlbnREYXRhPC9jb2RlPiBhbmQgdGhlIDxjb2RlPmRhdGE8L2NvZGU+XHJcbiAgICAgKiBvYmplY3QgdGhlIGV2ZW50IHdhcyBmaXJlZCB3aXRoLjxwPlxyXG4gICAgICogQG1ldGhvZCBzdWJzY3JpYmVcclxuICAgICAqIEBwYXJhbSBmbiB7RnVuY3Rpb259IEV2ZW50IGhhbmRsZXIuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuc3Vic2NyaWJlID0gZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgIGhhbmRsZXJzLnB1c2goZm4pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKioqXHJcbiAgICAgKiBSZW1vdmVzIGFuIGV2ZW50IGhhbmRsZXIgYWRkZWQgd2l0aCA8Y29kZT5zdWJzY3JpYmUoZm4pPC9jb2RlPi5cclxuICAgICAqIEBtZXRob2QgdW5zdWJzY3JpYmVcclxuICAgICAqIEBwYXJhbSBmbiB7RnVuY3Rpb259IEV2ZW50IGhhbmRsZXIgdG8gYmUgcmVtb3ZlZC5cclxuICAgICAqL1xyXG4gICAgdGhpcy51bnN1YnNjcmliZSA9IGZ1bmN0aW9uIChmbikge1xyXG4gICAgICBmb3IgKHZhciBpID0gaGFuZGxlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICBpZiAoaGFuZGxlcnNbaV0gPT09IGZuKSB7XHJcbiAgICAgICAgICBoYW5kbGVycy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKipcclxuICAgICAqIEZpcmVzIGFuIGV2ZW50IG5vdGlmeWluZyBhbGwgc3Vic2NyaWJlcnMuXHJcbiAgICAgKiBAbWV0aG9kIG5vdGlmeVxyXG4gICAgICogQHBhcmFtIGFyZ3Mge09iamVjdH0gQWRkaXRpb25hbCBkYXRhIG9iamVjdCB0byBiZSBwYXNzZWQgdG8gYWxsIGhhbmRsZXJzLlxyXG4gICAgICogQHBhcmFtIGUge0V2ZW50RGF0YX1cclxuICAgICAqICAgICAgT3B0aW9uYWwuXHJcbiAgICAgKiAgICAgIEFuIDxjb2RlPkV2ZW50RGF0YTwvY29kZT4gb2JqZWN0IHRvIGJlIHBhc3NlZCB0byBhbGwgaGFuZGxlcnMuXHJcbiAgICAgKiAgICAgIEZvciBET00gZXZlbnRzLCBhbiBleGlzdGluZyBXM0MvalF1ZXJ5IGV2ZW50IG9iamVjdCBjYW4gYmUgcGFzc2VkIGluLlxyXG4gICAgICogQHBhcmFtIHNjb3BlIHtPYmplY3R9XHJcbiAgICAgKiAgICAgIE9wdGlvbmFsLlxyXG4gICAgICogICAgICBUaGUgc2NvcGUgKFwidGhpc1wiKSB3aXRoaW4gd2hpY2ggdGhlIGhhbmRsZXIgd2lsbCBiZSBleGVjdXRlZC5cclxuICAgICAqICAgICAgSWYgbm90IHNwZWNpZmllZCwgdGhlIHNjb3BlIHdpbGwgYmUgc2V0IHRvIHRoZSA8Y29kZT5FdmVudDwvY29kZT4gaW5zdGFuY2UuXHJcbiAgICAgKi9cclxuICAgIHRoaXMubm90aWZ5ID0gZnVuY3Rpb24gKGFyZ3MsIGUsIHNjb3BlKSB7XHJcbiAgICAgIGUgPSBlIHx8IG5ldyBFdmVudERhdGEoKTtcclxuICAgICAgc2NvcGUgPSBzY29wZSB8fCB0aGlzO1xyXG5cclxuICAgICAgdmFyIHJldHVyblZhbHVlO1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXJzLmxlbmd0aCAmJiAhKGUuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSB8fCBlLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkpOyBpKyspIHtcclxuICAgICAgICByZXR1cm5WYWx1ZSA9IGhhbmRsZXJzW2ldLmNhbGwoc2NvcGUsIGUsIGFyZ3MpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gRXZlbnRIYW5kbGVyKCkge1xyXG4gICAgdmFyIGhhbmRsZXJzID0gW107XHJcblxyXG4gICAgdGhpcy5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoZXZlbnQsIGhhbmRsZXIpIHtcclxuICAgICAgaGFuZGxlcnMucHVzaCh7XHJcbiAgICAgICAgZXZlbnQ6IGV2ZW50LFxyXG4gICAgICAgIGhhbmRsZXI6IGhhbmRsZXJcclxuICAgICAgfSk7XHJcbiAgICAgIGV2ZW50LnN1YnNjcmliZShoYW5kbGVyKTtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzOyAgLy8gYWxsb3cgY2hhaW5pbmdcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy51bnN1YnNjcmliZSA9IGZ1bmN0aW9uIChldmVudCwgaGFuZGxlcikge1xyXG4gICAgICB2YXIgaSA9IGhhbmRsZXJzLmxlbmd0aDtcclxuICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgIGlmIChoYW5kbGVyc1tpXS5ldmVudCA9PT0gZXZlbnQgJiZcclxuICAgICAgICAgICAgaGFuZGxlcnNbaV0uaGFuZGxlciA9PT0gaGFuZGxlcikge1xyXG4gICAgICAgICAgaGFuZGxlcnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgZXZlbnQudW5zdWJzY3JpYmUoaGFuZGxlcik7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGhpczsgIC8vIGFsbG93IGNoYWluaW5nXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMudW5zdWJzY3JpYmVBbGwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBpID0gaGFuZGxlcnMubGVuZ3RoO1xyXG4gICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgaGFuZGxlcnNbaV0uZXZlbnQudW5zdWJzY3JpYmUoaGFuZGxlcnNbaV0uaGFuZGxlcik7XHJcbiAgICAgIH1cclxuICAgICAgaGFuZGxlcnMgPSBbXTtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzOyAgLy8gYWxsb3cgY2hhaW5pbmdcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKipcclxuICAgKiBBIHN0cnVjdHVyZSBjb250YWluaW5nIGEgcmFuZ2Ugb2YgY2VsbHMuXHJcbiAgICogQGNsYXNzIFJhbmdlXHJcbiAgICogQGNvbnN0cnVjdG9yXHJcbiAgICogQHBhcmFtIGZyb21Sb3cge0ludGVnZXJ9IFN0YXJ0aW5nIHJvdy5cclxuICAgKiBAcGFyYW0gZnJvbUNlbGwge0ludGVnZXJ9IFN0YXJ0aW5nIGNlbGwuXHJcbiAgICogQHBhcmFtIHRvUm93IHtJbnRlZ2VyfSBPcHRpb25hbC4gRW5kaW5nIHJvdy4gRGVmYXVsdHMgdG8gPGNvZGU+ZnJvbVJvdzwvY29kZT4uXHJcbiAgICogQHBhcmFtIHRvQ2VsbCB7SW50ZWdlcn0gT3B0aW9uYWwuIEVuZGluZyBjZWxsLiBEZWZhdWx0cyB0byA8Y29kZT5mcm9tQ2VsbDwvY29kZT4uXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gUmFuZ2UoZnJvbVJvdywgZnJvbUNlbGwsIHRvUm93LCB0b0NlbGwpIHtcclxuICAgIGlmICh0b1JvdyA9PT0gdW5kZWZpbmVkICYmIHRvQ2VsbCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRvUm93ID0gZnJvbVJvdztcclxuICAgICAgdG9DZWxsID0gZnJvbUNlbGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqKlxyXG4gICAgICogQHByb3BlcnR5IGZyb21Sb3dcclxuICAgICAqIEB0eXBlIHtJbnRlZ2VyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmZyb21Sb3cgPSBNYXRoLm1pbihmcm9tUm93LCB0b1Jvdyk7XHJcblxyXG4gICAgLyoqKlxyXG4gICAgICogQHByb3BlcnR5IGZyb21DZWxsXHJcbiAgICAgKiBAdHlwZSB7SW50ZWdlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5mcm9tQ2VsbCA9IE1hdGgubWluKGZyb21DZWxsLCB0b0NlbGwpO1xyXG5cclxuICAgIC8qKipcclxuICAgICAqIEBwcm9wZXJ0eSB0b1Jvd1xyXG4gICAgICogQHR5cGUge0ludGVnZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMudG9Sb3cgPSBNYXRoLm1heChmcm9tUm93LCB0b1Jvdyk7XHJcblxyXG4gICAgLyoqKlxyXG4gICAgICogQHByb3BlcnR5IHRvQ2VsbFxyXG4gICAgICogQHR5cGUge0ludGVnZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMudG9DZWxsID0gTWF0aC5tYXgoZnJvbUNlbGwsIHRvQ2VsbCk7XHJcblxyXG4gICAgLyoqKlxyXG4gICAgICogUmV0dXJucyB3aGV0aGVyIGEgcmFuZ2UgcmVwcmVzZW50cyBhIHNpbmdsZSByb3cuXHJcbiAgICAgKiBAbWV0aG9kIGlzU2luZ2xlUm93XHJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLmlzU2luZ2xlUm93ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5mcm9tUm93ID09IHRoaXMudG9Sb3c7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKipcclxuICAgICAqIFJldHVybnMgd2hldGhlciBhIHJhbmdlIHJlcHJlc2VudHMgYSBzaW5nbGUgY2VsbC5cclxuICAgICAqIEBtZXRob2QgaXNTaW5nbGVDZWxsXHJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLmlzU2luZ2xlQ2VsbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZnJvbVJvdyA9PSB0aGlzLnRvUm93ICYmIHRoaXMuZnJvbUNlbGwgPT0gdGhpcy50b0NlbGw7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKipcclxuICAgICAqIFJldHVybnMgd2hldGhlciBhIHJhbmdlIGNvbnRhaW5zIGEgZ2l2ZW4gY2VsbC5cclxuICAgICAqIEBtZXRob2QgY29udGFpbnNcclxuICAgICAqIEBwYXJhbSByb3cge0ludGVnZXJ9XHJcbiAgICAgKiBAcGFyYW0gY2VsbCB7SW50ZWdlcn1cclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMuY29udGFpbnMgPSBmdW5jdGlvbiAocm93LCBjZWxsKSB7XHJcbiAgICAgIHJldHVybiByb3cgPj0gdGhpcy5mcm9tUm93ICYmIHJvdyA8PSB0aGlzLnRvUm93ICYmXHJcbiAgICAgICAgICBjZWxsID49IHRoaXMuZnJvbUNlbGwgJiYgY2VsbCA8PSB0aGlzLnRvQ2VsbDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqKlxyXG4gICAgICogUmV0dXJucyBhIHJlYWRhYmxlIHJlcHJlc2VudGF0aW9uIG9mIGEgcmFuZ2UuXHJcbiAgICAgKiBAbWV0aG9kIHRvU3RyaW5nXHJcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIHRoaXMudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGlmICh0aGlzLmlzU2luZ2xlQ2VsbCgpKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiKFwiICsgdGhpcy5mcm9tUm93ICsgXCI6XCIgKyB0aGlzLmZyb21DZWxsICsgXCIpXCI7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIFwiKFwiICsgdGhpcy5mcm9tUm93ICsgXCI6XCIgKyB0aGlzLmZyb21DZWxsICsgXCIgLSBcIiArIHRoaXMudG9Sb3cgKyBcIjpcIiArIHRoaXMudG9DZWxsICsgXCIpXCI7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG5cclxuICAvKioqXHJcbiAgICogQSBiYXNlIGNsYXNzIHRoYXQgYWxsIHNwZWNpYWwgLyBub24tZGF0YSByb3dzIChsaWtlIEdyb3VwIGFuZCBHcm91cFRvdGFscykgZGVyaXZlIGZyb20uXHJcbiAgICogQGNsYXNzIE5vbkRhdGFJdGVtXHJcbiAgICogQGNvbnN0cnVjdG9yXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gTm9uRGF0YUl0ZW0oKSB7XHJcbiAgICB0aGlzLl9fbm9uRGF0YVJvdyA9IHRydWU7XHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqKlxyXG4gICAqIEluZm9ybWF0aW9uIGFib3V0IGEgZ3JvdXAgb2Ygcm93cy5cclxuICAgKiBAY2xhc3MgR3JvdXBcclxuICAgKiBAZXh0ZW5kcyBTbGljay5Ob25EYXRhSXRlbVxyXG4gICAqIEBjb25zdHJ1Y3RvclxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIEdyb3VwKCkge1xyXG4gICAgdGhpcy5fX2dyb3VwID0gdHJ1ZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdyb3VwaW5nIGxldmVsLCBzdGFydGluZyB3aXRoIDAuXHJcbiAgICAgKiBAcHJvcGVydHkgbGV2ZWxcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubGV2ZWwgPSAwO1xyXG5cclxuICAgIC8qKipcclxuICAgICAqIE51bWJlciBvZiByb3dzIGluIHRoZSBncm91cC5cclxuICAgICAqIEBwcm9wZXJ0eSBjb3VudFxyXG4gICAgICogQHR5cGUge0ludGVnZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuY291bnQgPSAwO1xyXG5cclxuICAgIC8qKipcclxuICAgICAqIEdyb3VwaW5nIHZhbHVlLlxyXG4gICAgICogQHByb3BlcnR5IHZhbHVlXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICovXHJcbiAgICB0aGlzLnZhbHVlID0gbnVsbDtcclxuXHJcbiAgICAvKioqXHJcbiAgICAgKiBGb3JtYXR0ZWQgZGlzcGxheSB2YWx1ZSBvZiB0aGUgZ3JvdXAuXHJcbiAgICAgKiBAcHJvcGVydHkgdGl0bGVcclxuICAgICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIHRoaXMudGl0bGUgPSBudWxsO1xyXG5cclxuICAgIC8qKipcclxuICAgICAqIFdoZXRoZXIgYSBncm91cCBpcyBjb2xsYXBzZWQuXHJcbiAgICAgKiBAcHJvcGVydHkgY29sbGFwc2VkXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5jb2xsYXBzZWQgPSBmYWxzZTtcclxuXHJcbiAgICAvKioqXHJcbiAgICAgKiBXaGV0aGVyIGEgZ3JvdXAgc2VsZWN0aW9uIGNoZWNrYm94IGlzIGNoZWNrZWQuXHJcbiAgICAgKiBAcHJvcGVydHkgc2VsZWN0Q2hlY2tlZFxyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2VsZWN0Q2hlY2tlZCA9IGZhbHNlO1xyXG5cclxuICAgIC8qKipcclxuICAgICAqIEdyb3VwVG90YWxzLCBpZiBhbnkuXHJcbiAgICAgKiBAcHJvcGVydHkgdG90YWxzXHJcbiAgICAgKiBAdHlwZSB7R3JvdXBUb3RhbHN9XHJcbiAgICAgKi9cclxuICAgIHRoaXMudG90YWxzID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJvd3MgdGhhdCBhcmUgcGFydCBvZiB0aGUgZ3JvdXAuXHJcbiAgICAgKiBAcHJvcGVydHkgcm93c1xyXG4gICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICovXHJcbiAgICB0aGlzLnJvd3MgPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN1Yi1ncm91cHMgdGhhdCBhcmUgcGFydCBvZiB0aGUgZ3JvdXAuXHJcbiAgICAgKiBAcHJvcGVydHkgZ3JvdXBzXHJcbiAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuZ3JvdXBzID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgdW5pcXVlIGtleSB1c2VkIHRvIGlkZW50aWZ5IHRoZSBncm91cC4gIFRoaXMga2V5IGNhbiBiZSB1c2VkIGluIGNhbGxzIHRvIERhdGFWaWV3XHJcbiAgICAgKiBjb2xsYXBzZUdyb3VwKCkgb3IgZXhwYW5kR3JvdXAoKS5cclxuICAgICAqIEBwcm9wZXJ0eSBncm91cGluZ0tleVxyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5ncm91cGluZ0tleSA9IG51bGw7XHJcbiAgfVxyXG5cclxuICBHcm91cC5wcm90b3R5cGUgPSBuZXcgTm9uRGF0YUl0ZW0oKTtcclxuXHJcbiAgLyoqKlxyXG4gICAqIENvbXBhcmVzIHR3byBHcm91cCBpbnN0YW5jZXMuXHJcbiAgICogQG1ldGhvZCBlcXVhbHNcclxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAqIEBwYXJhbSBncm91cCB7R3JvdXB9IEdyb3VwIGluc3RhbmNlIHRvIGNvbXBhcmUgdG8uXHJcbiAgICovXHJcbiAgR3JvdXAucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChncm91cCkge1xyXG4gICAgcmV0dXJuIHRoaXMudmFsdWUgPT09IGdyb3VwLnZhbHVlICYmXHJcbiAgICAgICAgdGhpcy5jb3VudCA9PT0gZ3JvdXAuY291bnQgJiZcclxuICAgICAgICB0aGlzLmNvbGxhcHNlZCA9PT0gZ3JvdXAuY29sbGFwc2VkICYmXHJcbiAgICAgICAgdGhpcy50aXRsZSA9PT0gZ3JvdXAudGl0bGU7XHJcbiAgfTtcclxuXHJcbiAgLyoqKlxyXG4gICAqIEluZm9ybWF0aW9uIGFib3V0IGdyb3VwIHRvdGFscy5cclxuICAgKiBBbiBpbnN0YW5jZSBvZiBHcm91cFRvdGFscyB3aWxsIGJlIGNyZWF0ZWQgZm9yIGVhY2ggdG90YWxzIHJvdyBhbmQgcGFzc2VkIHRvIHRoZSBhZ2dyZWdhdG9yc1xyXG4gICAqIHNvIHRoYXQgdGhleSBjYW4gc3RvcmUgYXJiaXRyYXJ5IGRhdGEgaW4gaXQuICBUaGF0IGRhdGEgY2FuIGxhdGVyIGJlIGFjY2Vzc2VkIGJ5IGdyb3VwIHRvdGFsc1xyXG4gICAqIGZvcm1hdHRlcnMgZHVyaW5nIHRoZSBkaXNwbGF5LlxyXG4gICAqIEBjbGFzcyBHcm91cFRvdGFsc1xyXG4gICAqIEBleHRlbmRzIFNsaWNrLk5vbkRhdGFJdGVtXHJcbiAgICogQGNvbnN0cnVjdG9yXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gR3JvdXBUb3RhbHMoKSB7XHJcbiAgICB0aGlzLl9fZ3JvdXBUb3RhbHMgPSB0cnVlO1xyXG5cclxuICAgIC8qKipcclxuICAgICAqIFBhcmVudCBHcm91cC5cclxuICAgICAqIEBwYXJhbSBncm91cFxyXG4gICAgICogQHR5cGUge0dyb3VwfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmdyb3VwID0gbnVsbDtcclxuXHJcbiAgICAvKioqXHJcbiAgICAgKiBXaGV0aGVyIHRoZSB0b3RhbHMgaGF2ZSBiZWVuIGZ1bGx5IGluaXRpYWxpemVkIC8gY2FsY3VsYXRlZC5cclxuICAgICAqIFdpbGwgYmUgc2V0IHRvIGZhbHNlIGZvciBsYXp5LWNhbGN1bGF0ZWQgZ3JvdXAgdG90YWxzLlxyXG4gICAgICogQHBhcmFtIGluaXRpYWxpemVkXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgR3JvdXBUb3RhbHMucHJvdG90eXBlID0gbmV3IE5vbkRhdGFJdGVtKCk7XHJcblxyXG4gIC8qKipcclxuICAgKiBBIGxvY2tpbmcgaGVscGVyIHRvIHRyYWNrIHRoZSBhY3RpdmUgZWRpdCBjb250cm9sbGVyIGFuZCBlbnN1cmUgdGhhdCBvbmx5IGEgc2luZ2xlIGNvbnRyb2xsZXJcclxuICAgKiBjYW4gYmUgYWN0aXZlIGF0IGEgdGltZS4gIFRoaXMgcHJldmVudHMgYSB3aG9sZSBjbGFzcyBvZiBzdGF0ZSBhbmQgdmFsaWRhdGlvbiBzeW5jaHJvbml6YXRpb25cclxuICAgKiBpc3N1ZXMuICBBbiBlZGl0IGNvbnRyb2xsZXIgKHN1Y2ggYXMgU2xpY2tHcmlkKSBjYW4gcXVlcnkgaWYgYW4gYWN0aXZlIGVkaXQgaXMgaW4gcHJvZ3Jlc3NcclxuICAgKiBhbmQgYXR0ZW1wdCBhIGNvbW1pdCBvciBjYW5jZWwgYmVmb3JlIHByb2NlZWRpbmcuXHJcbiAgICogQGNsYXNzIEVkaXRvckxvY2tcclxuICAgKiBAY29uc3RydWN0b3JcclxuICAgKi9cclxuICBmdW5jdGlvbiBFZGl0b3JMb2NrKCkge1xyXG4gICAgdmFyIGFjdGl2ZUVkaXRDb250cm9sbGVyID0gbnVsbDtcclxuXHJcbiAgICAvKioqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgYSBzcGVjaWZpZWQgZWRpdCBjb250cm9sbGVyIGlzIGFjdGl2ZSAoaGFzIHRoZSBlZGl0IGxvY2spLlxyXG4gICAgICogSWYgdGhlIHBhcmFtZXRlciBpcyBub3Qgc3BlY2lmaWVkLCByZXR1cm5zIHRydWUgaWYgYW55IGVkaXQgY29udHJvbGxlciBpcyBhY3RpdmUuXHJcbiAgICAgKiBAbWV0aG9kIGlzQWN0aXZlXHJcbiAgICAgKiBAcGFyYW0gZWRpdENvbnRyb2xsZXIge0VkaXRDb250cm9sbGVyfVxyXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5pc0FjdGl2ZSA9IGZ1bmN0aW9uIChlZGl0Q29udHJvbGxlcikge1xyXG4gICAgICByZXR1cm4gKGVkaXRDb250cm9sbGVyID8gYWN0aXZlRWRpdENvbnRyb2xsZXIgPT09IGVkaXRDb250cm9sbGVyIDogYWN0aXZlRWRpdENvbnRyb2xsZXIgIT09IG51bGwpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKioqXHJcbiAgICAgKiBTZXRzIHRoZSBzcGVjaWZpZWQgZWRpdCBjb250cm9sbGVyIGFzIHRoZSBhY3RpdmUgZWRpdCBjb250cm9sbGVyIChhY3F1aXJlIGVkaXQgbG9jaykuXHJcbiAgICAgKiBJZiBhbm90aGVyIGVkaXQgY29udHJvbGxlciBpcyBhbHJlYWR5IGFjdGl2ZSwgYW5kIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93IG5ldyBFcnJvciguXHJcbiAgICAgKiBAbWV0aG9kIGFjdGl2YXRlXHJcbiAgICAgKiBAcGFyYW0gZWRpdENvbnRyb2xsZXIge0VkaXRDb250cm9sbGVyfSBlZGl0IGNvbnRyb2xsZXIgYWNxdWlyaW5nIHRoZSBsb2NrXHJcbiAgICAgKi9cclxuICAgIHRoaXMuYWN0aXZhdGUgPSBmdW5jdGlvbiAoZWRpdENvbnRyb2xsZXIpIHtcclxuICAgICAgaWYgKGVkaXRDb250cm9sbGVyID09PSBhY3RpdmVFZGl0Q29udHJvbGxlcikgeyAvLyBhbHJlYWR5IGFjdGl2YXRlZD9cclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGFjdGl2ZUVkaXRDb250cm9sbGVyICE9PSBudWxsKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2xpY2tHcmlkLkVkaXRvckxvY2suYWN0aXZhdGU6IGFuIGVkaXRDb250cm9sbGVyIGlzIHN0aWxsIGFjdGl2ZSwgY2FuJ3QgYWN0aXZhdGUgYW5vdGhlciBlZGl0Q29udHJvbGxlclwiKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIWVkaXRDb250cm9sbGVyLmNvbW1pdEN1cnJlbnRFZGl0KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2xpY2tHcmlkLkVkaXRvckxvY2suYWN0aXZhdGU6IGVkaXRDb250cm9sbGVyIG11c3QgaW1wbGVtZW50IC5jb21taXRDdXJyZW50RWRpdCgpXCIpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghZWRpdENvbnRyb2xsZXIuY2FuY2VsQ3VycmVudEVkaXQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTbGlja0dyaWQuRWRpdG9yTG9jay5hY3RpdmF0ZTogZWRpdENvbnRyb2xsZXIgbXVzdCBpbXBsZW1lbnQgLmNhbmNlbEN1cnJlbnRFZGl0KClcIik7XHJcbiAgICAgIH1cclxuICAgICAgYWN0aXZlRWRpdENvbnRyb2xsZXIgPSBlZGl0Q29udHJvbGxlcjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqKlxyXG4gICAgICogVW5zZXRzIHRoZSBzcGVjaWZpZWQgZWRpdCBjb250cm9sbGVyIGFzIHRoZSBhY3RpdmUgZWRpdCBjb250cm9sbGVyIChyZWxlYXNlIGVkaXQgbG9jaykuXHJcbiAgICAgKiBJZiB0aGUgc3BlY2lmaWVkIGVkaXQgY29udHJvbGxlciBpcyBub3QgdGhlIGFjdGl2ZSBvbmUsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93IG5ldyBFcnJvciguXHJcbiAgICAgKiBAbWV0aG9kIGRlYWN0aXZhdGVcclxuICAgICAqIEBwYXJhbSBlZGl0Q29udHJvbGxlciB7RWRpdENvbnRyb2xsZXJ9IGVkaXQgY29udHJvbGxlciByZWxlYXNpbmcgdGhlIGxvY2tcclxuICAgICAqL1xyXG4gICAgdGhpcy5kZWFjdGl2YXRlID0gZnVuY3Rpb24gKGVkaXRDb250cm9sbGVyKSB7XHJcbiAgICAgIGlmIChhY3RpdmVFZGl0Q29udHJvbGxlciAhPT0gZWRpdENvbnRyb2xsZXIpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTbGlja0dyaWQuRWRpdG9yTG9jay5kZWFjdGl2YXRlOiBzcGVjaWZpZWQgZWRpdENvbnRyb2xsZXIgaXMgbm90IHRoZSBjdXJyZW50bHkgYWN0aXZlIG9uZVwiKTtcclxuICAgICAgfVxyXG4gICAgICBhY3RpdmVFZGl0Q29udHJvbGxlciA9IG51bGw7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKipcclxuICAgICAqIEF0dGVtcHRzIHRvIGNvbW1pdCB0aGUgY3VycmVudCBlZGl0IGJ5IGNhbGxpbmcgXCJjb21taXRDdXJyZW50RWRpdFwiIG1ldGhvZCBvbiB0aGUgYWN0aXZlIGVkaXRcclxuICAgICAqIGNvbnRyb2xsZXIgYW5kIHJldHVybnMgd2hldGhlciB0aGUgY29tbWl0IGF0dGVtcHQgd2FzIHN1Y2Nlc3NmdWwgKGNvbW1pdCBtYXkgZmFpbCBkdWUgdG8gdmFsaWRhdGlvblxyXG4gICAgICogZXJyb3JzLCBldGMuKS4gIEVkaXQgY29udHJvbGxlcidzIFwiY29tbWl0Q3VycmVudEVkaXRcIiBtdXN0IHJldHVybiB0cnVlIGlmIHRoZSBjb21taXQgaGFzIHN1Y2NlZWRlZFxyXG4gICAgICogYW5kIGZhbHNlIG90aGVyd2lzZS4gIElmIG5vIGVkaXQgY29udHJvbGxlciBpcyBhY3RpdmUsIHJldHVybnMgdHJ1ZS5cclxuICAgICAqIEBtZXRob2QgY29tbWl0Q3VycmVudEVkaXRcclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMuY29tbWl0Q3VycmVudEVkaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiAoYWN0aXZlRWRpdENvbnRyb2xsZXIgPyBhY3RpdmVFZGl0Q29udHJvbGxlci5jb21taXRDdXJyZW50RWRpdCgpIDogdHJ1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKipcclxuICAgICAqIEF0dGVtcHRzIHRvIGNhbmNlbCB0aGUgY3VycmVudCBlZGl0IGJ5IGNhbGxpbmcgXCJjYW5jZWxDdXJyZW50RWRpdFwiIG1ldGhvZCBvbiB0aGUgYWN0aXZlIGVkaXRcclxuICAgICAqIGNvbnRyb2xsZXIgYW5kIHJldHVybnMgd2hldGhlciB0aGUgZWRpdCB3YXMgc3VjY2Vzc2Z1bGx5IGNhbmNlbGxlZC4gIElmIG5vIGVkaXQgY29udHJvbGxlciBpc1xyXG4gICAgICogYWN0aXZlLCByZXR1cm5zIHRydWUuXHJcbiAgICAgKiBAbWV0aG9kIGNhbmNlbEN1cnJlbnRFZGl0XHJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLmNhbmNlbEN1cnJlbnRFZGl0ID0gZnVuY3Rpb24gY2FuY2VsQ3VycmVudEVkaXQoKSB7XHJcbiAgICAgIHJldHVybiAoYWN0aXZlRWRpdENvbnRyb2xsZXIgPyBhY3RpdmVFZGl0Q29udHJvbGxlci5jYW5jZWxDdXJyZW50RWRpdCgpIDogdHJ1ZSk7XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgIGxldCBTbGljayA9e1xyXG4gICAgICBcIkV2ZW50XCI6IEV2ZW50LFxyXG4gICAgICBcIkV2ZW50RGF0YVwiOiBFdmVudERhdGEsXHJcbiAgICAgIFwiRXZlbnRIYW5kbGVyXCI6IEV2ZW50SGFuZGxlcixcclxuICAgICAgXCJSYW5nZVwiOiBSYW5nZSxcclxuICAgICAgXCJOb25EYXRhUm93XCI6IE5vbkRhdGFJdGVtLFxyXG4gICAgICBcIkdyb3VwXCI6IEdyb3VwLFxyXG4gICAgICBcIkdyb3VwVG90YWxzXCI6IEdyb3VwVG90YWxzLFxyXG4gICAgICBcIkVkaXRvckxvY2tcIjogRWRpdG9yTG9jayxcclxuXHJcbiAgICAgIC8qKipcclxuICAgICAgICogQSBnbG9iYWwgc2luZ2xldG9uIGVkaXRvciBsb2NrLlxyXG4gICAgICAgKiBAY2xhc3MgR2xvYmFsRWRpdG9yTG9ja1xyXG4gICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgKi9cclxuICAgICAgXCJHbG9iYWxFZGl0b3JMb2NrXCI6IG5ldyBFZGl0b3JMb2NrKCksXHJcblxyXG4gICAgICBcImtleUNvZGVcIjoge1xyXG4gICAgICAgIEJBQ0tTUEFDRTogOCxcclxuICAgICAgICBERUxFVEU6IDQ2LFxyXG4gICAgICAgIERPV046IDQwLFxyXG4gICAgICAgIEVORDogMzUsXHJcbiAgICAgICAgRU5URVI6IDEzLFxyXG4gICAgICAgIEVTQ0FQRTogMjcsXHJcbiAgICAgICAgSE9NRTogMzYsXHJcbiAgICAgICAgSU5TRVJUOiA0NSxcclxuICAgICAgICBMRUZUOiAzNyxcclxuICAgICAgICBQQUdFX0RPV046IDM0LFxyXG4gICAgICAgIFBBR0VfVVA6IDMzLFxyXG4gICAgICAgIFJJR0hUOiAzOSxcclxuICAgICAgICBUQUI6IDksXHJcbiAgICAgICAgVVA6IDM4LFxyXG4gICAgICAgIEE6IDY1XHJcbiAgICAgIH0sXHJcbiAgICAgIFwicHJlQ2xpY2tDbGFzc05hbWVcIiA6IFwic2xpY2stZWRpdC1wcmVjbGlja1wiXHJcbiAgICB9O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiAoYykgMjAwOS0yMDE2IE1pY2hhZWwgTGVpYm1hblxyXG4gKiBtaWNoYWVse2RvdH1sZWlibWFue2F0fWdtYWlse2RvdH1jb21cclxuICogaHR0cDovL2dpdGh1Yi5jb20vbWxlaWJtYW4vc2xpY2tncmlkXHJcbiAqXHJcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIE1JVCBsaWNlbnNlLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBTbGlja0dyaWQgdjIuM1xyXG4gKlxyXG4gKiBOT1RFUzpcclxuICogICAgIENlbGwvcm93IERPTSBtYW5pcHVsYXRpb25zIGFyZSBkb25lIGRpcmVjdGx5IGJ5cGFzc2luZyBqUXVlcnkncyBET00gbWFuaXB1bGF0aW9uIG1ldGhvZHMuXHJcbiAqICAgICBUaGlzIGluY3JlYXNlcyB0aGUgc3BlZWQgZHJhbWF0aWNhbGx5LCBidXQgY2FuIG9ubHkgYmUgZG9uZSBzYWZlbHkgYmVjYXVzZSB0aGVyZSBhcmUgbm8gZXZlbnQgaGFuZGxlcnNcclxuICogICAgIG9yIGRhdGEgYXNzb2NpYXRlZCB3aXRoIGFueSBjZWxsL3JvdyBET00gbm9kZXMuICBDZWxsIGVkaXRvcnMgbXVzdCBtYWtlIHN1cmUgdGhleSBpbXBsZW1lbnQgLmRlc3Ryb3koKVxyXG4gKiAgICAgYW5kIGRvIHByb3BlciBjbGVhbnVwLlxyXG4gKi9cclxuXHJcbi8vIG1ha2Ugc3VyZSByZXF1aXJlZCBKYXZhU2NyaXB0IG1vZHVsZXMgYXJlIGxvYWRlZFxyXG5cclxuXHJcbmlmICh0eXBlb2YgalF1ZXJ5ID09PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgdGhyb3cgbmV3IEVycm9yKFwiU2xpY2tHcmlkIHJlcXVpcmVzIGpxdWVyeSBtb2R1bGUgdG8gYmUgbG9hZGVkXCIpO1xyXG59XHJcbmlmICghalF1ZXJ5LmZuLmRyYWcpIHtcclxuICB0aHJvdyBuZXcgRXJyb3IoXCJTbGlja0dyaWQgcmVxdWlyZXMganF1ZXJ5LmV2ZW50LmRyYWcgbW9kdWxlIHRvIGJlIGxvYWRlZFwiKTtcclxufVxyXG5pZiAodHlwZW9mIFNsaWNrID09PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgdGhyb3cgbmV3IEVycm9yKFwic2xpY2suY29yZS5qcyBub3QgbG9hZGVkXCIpO1xyXG59XHJcblxyXG5cclxuXHJcblxyXG5cclxuICAvLyBzaGFyZWQgYWNyb3NzIGFsbCBncmlkcyBvbiB0aGUgcGFnZVxyXG4gIHZhciBzY3JvbGxiYXJEaW1lbnNpb25zO1xyXG4gIHZhciBtYXhTdXBwb3J0ZWRDc3NIZWlnaHQ7ICAvLyBicm93c2VyJ3MgYnJlYWtpbmcgcG9pbnRcclxuXHJcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gIC8vIFNsaWNrR3JpZCBjbGFzcyBpbXBsZW1lbnRhdGlvbiAoYXZhaWxhYmxlIGFzIFNsaWNrLkdyaWQpXHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGdyaWQuXHJcbiAgICogQGNsYXNzIFNsaWNrR3JpZFxyXG4gICAqIEBjb25zdHJ1Y3RvclxyXG4gICAqIEBwYXJhbSB7Tm9kZX0gICAgICAgICAgICAgIGNvbnRhaW5lciAgIENvbnRhaW5lciBub2RlIHRvIGNyZWF0ZSB0aGUgZ3JpZCBpbi5cclxuICAgKiBAcGFyYW0ge0FycmF5LE9iamVjdH0gICAgICBkYXRhICAgICAgICBBbiBhcnJheSBvZiBvYmplY3RzIGZvciBkYXRhYmluZGluZy5cclxuICAgKiBAcGFyYW0ge0FycmF5fSAgICAgICAgICAgICBjb2x1bW5zICAgICBBbiBhcnJheSBvZiBjb2x1bW4gZGVmaW5pdGlvbnMuXHJcbiAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgICAgb3B0aW9ucyAgICAgR3JpZCBvcHRpb25zLlxyXG4gICAqKi9cclxuICBmdW5jdGlvbiBTbGlja0dyaWQoY29udGFpbmVyLCBkYXRhLCBjb2x1bW5zLCBvcHRpb25zKSB7XHJcbiAgICAvLyBzZXR0aW5nc1xyXG4gICAgdmFyIGRlZmF1bHRzID0ge1xyXG4gICAgICBhbHdheXNTaG93VmVydGljYWxTY3JvbGw6IGZhbHNlLFxyXG4gICAgICBleHBsaWNpdEluaXRpYWxpemF0aW9uOiBmYWxzZSxcclxuICAgICAgcm93SGVpZ2h0OiAyNSxcclxuICAgICAgZGVmYXVsdENvbHVtbldpZHRoOiA4MCxcclxuICAgICAgZW5hYmxlQWRkUm93OiBmYWxzZSxcclxuICAgICAgbGVhdmVTcGFjZUZvck5ld1Jvd3M6IGZhbHNlLFxyXG4gICAgICBlZGl0YWJsZTogZmFsc2UsXHJcbiAgICAgIGF1dG9FZGl0OiB0cnVlLFxyXG4gICAgICBzdXBwcmVzc0FjdGl2ZUNlbGxDaGFuZ2VPbkVkaXQ6IGZhbHNlLFxyXG4gICAgICBlbmFibGVDZWxsTmF2aWdhdGlvbjogdHJ1ZSxcclxuICAgICAgZW5hYmxlQ29sdW1uUmVvcmRlcjogdHJ1ZSxcclxuICAgICAgYXN5bmNFZGl0b3JMb2FkaW5nOiBmYWxzZSxcclxuICAgICAgYXN5bmNFZGl0b3JMb2FkRGVsYXk6IDEwMCxcclxuICAgICAgZm9yY2VGaXRDb2x1bW5zOiBmYWxzZSxcclxuICAgICAgZW5hYmxlQXN5bmNQb3N0UmVuZGVyOiBmYWxzZSxcclxuICAgICAgYXN5bmNQb3N0UmVuZGVyRGVsYXk6IDUwLFxyXG4gICAgICBlbmFibGVBc3luY1Bvc3RSZW5kZXJDbGVhbnVwOiBmYWxzZSxcclxuICAgICAgYXN5bmNQb3N0UmVuZGVyQ2xlYW51cERlbGF5OiA0MCxcclxuICAgICAgYXV0b0hlaWdodDogZmFsc2UsXHJcbiAgICAgIGVkaXRvckxvY2s6IFNsaWNrLkdsb2JhbEVkaXRvckxvY2ssXHJcbiAgICAgIHNob3dIZWFkZXJSb3c6IGZhbHNlLFxyXG4gICAgICBoZWFkZXJSb3dIZWlnaHQ6IDI1LFxyXG4gICAgICBjcmVhdGVGb290ZXJSb3c6IGZhbHNlLFxyXG4gICAgICBzaG93Rm9vdGVyUm93OiBmYWxzZSxcclxuICAgICAgZm9vdGVyUm93SGVpZ2h0OiAyNSxcclxuICAgICAgY3JlYXRlUHJlSGVhZGVyUGFuZWw6IGZhbHNlLFxyXG4gICAgICBzaG93UHJlSGVhZGVyUGFuZWw6IGZhbHNlLFxyXG4gICAgICBwcmVIZWFkZXJQYW5lbEhlaWdodDogMjUsXHJcbiAgICAgIHNob3dUb3BQYW5lbDogZmFsc2UsXHJcbiAgICAgIHRvcFBhbmVsSGVpZ2h0OiAyNSxcclxuICAgICAgZm9ybWF0dGVyRmFjdG9yeTogbnVsbCxcclxuICAgICAgZWRpdG9yRmFjdG9yeTogbnVsbCxcclxuICAgICAgY2VsbEZsYXNoaW5nQ3NzQ2xhc3M6IFwiZmxhc2hpbmdcIixcclxuICAgICAgc2VsZWN0ZWRDZWxsQ3NzQ2xhc3M6IFwic2VsZWN0ZWRcIixcclxuICAgICAgbXVsdGlTZWxlY3Q6IHRydWUsXHJcbiAgICAgIGVuYWJsZVRleHRTZWxlY3Rpb25PbkNlbGxzOiBmYWxzZSxcclxuICAgICAgZGF0YUl0ZW1Db2x1bW5WYWx1ZUV4dHJhY3RvcjogbnVsbCxcclxuICAgICAgZnVsbFdpZHRoUm93czogZmFsc2UsXHJcbiAgICAgIG11bHRpQ29sdW1uU29ydDogZmFsc2UsXHJcbiAgICAgIG51bWJlcmVkTXVsdGlDb2x1bW5Tb3J0OiBmYWxzZSxcclxuICAgICAgdHJpc3RhdGVNdWx0aUNvbHVtblNvcnQ6IGZhbHNlLFxyXG4gICAgICBzb3J0Q29sTnVtYmVySW5TZXBhcmF0ZVNwYW46IGZhbHNlLFxyXG4gICAgICBkZWZhdWx0Rm9ybWF0dGVyOiBkZWZhdWx0Rm9ybWF0dGVyLFxyXG4gICAgICBmb3JjZVN5bmNTY3JvbGxpbmc6IGZhbHNlLFxyXG4gICAgICBhZGROZXdSb3dDc3NDbGFzczogXCJuZXctcm93XCIsXHJcbiAgICAgIHByZXNlcnZlQ29waWVkU2VsZWN0aW9uT25QYXN0ZTogZmFsc2UsXHJcbiAgICAgIHNob3dDZWxsU2VsZWN0aW9uOiB0cnVlLFxyXG4gICAgICB2aWV3cG9ydENsYXNzOiBudWxsLFxyXG4gICAgICBtaW5Sb3dCdWZmZXI6IDMsXHJcbiAgICAgIGVtdWxhdGVQYWdpbmdXaGVuU2Nyb2xsaW5nOiB0cnVlLCAvLyB3aGVuIHNjcm9sbGluZyBvZmYgYm90dG9tIG9mIHZpZXdwb3J0LCBwbGFjZSBuZXcgcm93IGF0IHRvcCBvZiB2aWV3cG9ydFxyXG4gICAgICBlZGl0b3JDZWxsTmF2T25MUktleXM6IGZhbHNlXHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBjb2x1bW5EZWZhdWx0cyA9IHtcclxuICAgICAgbmFtZTogXCJcIixcclxuICAgICAgcmVzaXphYmxlOiB0cnVlLFxyXG4gICAgICBzb3J0YWJsZTogZmFsc2UsXHJcbiAgICAgIG1pbldpZHRoOiAzMCxcclxuICAgICAgcmVyZW5kZXJPblJlc2l6ZTogZmFsc2UsXHJcbiAgICAgIGhlYWRlckNzc0NsYXNzOiBudWxsLFxyXG4gICAgICBkZWZhdWx0U29ydEFzYzogdHJ1ZSxcclxuICAgICAgZm9jdXNhYmxlOiB0cnVlLFxyXG4gICAgICBzZWxlY3RhYmxlOiB0cnVlXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIHNjcm9sbGVyXHJcbiAgICB2YXIgdGg7ICAgLy8gdmlydHVhbCBoZWlnaHRcclxuICAgIHZhciBoOyAgICAvLyByZWFsIHNjcm9sbGFibGUgaGVpZ2h0XHJcbiAgICB2YXIgcGg7ICAgLy8gcGFnZSBoZWlnaHRcclxuICAgIHZhciBuOyAgICAvLyBudW1iZXIgb2YgcGFnZXNcclxuICAgIHZhciBjajsgICAvLyBcImp1bXBpbmVzc1wiIGNvZWZmaWNpZW50XHJcblxyXG4gICAgdmFyIHBhZ2UgPSAwOyAgICAgICAvLyBjdXJyZW50IHBhZ2VcclxuICAgIHZhciBvZmZzZXQgPSAwOyAgICAgLy8gY3VycmVudCBwYWdlIG9mZnNldFxyXG4gICAgdmFyIHZTY3JvbGxEaXIgPSAxO1xyXG5cclxuICAgIC8vIHByaXZhdGVcclxuICAgIHZhciBpbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gICAgdmFyICRjb250YWluZXI7XHJcbiAgICB2YXIgdWlkID0gXCJzbGlja2dyaWRfXCIgKyBNYXRoLnJvdW5kKDEwMDAwMDAgKiBNYXRoLnJhbmRvbSgpKTtcclxuICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgIHZhciAkZm9jdXNTaW5rLCAkZm9jdXNTaW5rMjtcclxuICAgIHZhciAkaGVhZGVyU2Nyb2xsZXI7XHJcbiAgICB2YXIgJGhlYWRlcnM7XHJcbiAgICB2YXIgJGhlYWRlclJvdywgJGhlYWRlclJvd1Njcm9sbGVyLCAkaGVhZGVyUm93U3BhY2VyO1xyXG4gICAgdmFyICRmb290ZXJSb3csICRmb290ZXJSb3dTY3JvbGxlciwgJGZvb3RlclJvd1NwYWNlcjtcclxuICAgIHZhciAkcHJlSGVhZGVyUGFuZWwsICRwcmVIZWFkZXJQYW5lbFNjcm9sbGVyLCAkcHJlSGVhZGVyUGFuZWxTcGFjZXI7XHJcbiAgICB2YXIgJHRvcFBhbmVsU2Nyb2xsZXI7XHJcbiAgICB2YXIgJHRvcFBhbmVsO1xyXG4gICAgdmFyICR2aWV3cG9ydDtcclxuICAgIHZhciAkY2FudmFzO1xyXG4gICAgdmFyICRzdHlsZTtcclxuICAgIHZhciAkYm91bmRBbmNlc3RvcnM7XHJcbiAgICB2YXIgc3R5bGVzaGVldCwgY29sdW1uQ3NzUnVsZXNMLCBjb2x1bW5Dc3NSdWxlc1I7XHJcbiAgICB2YXIgdmlld3BvcnRILCB2aWV3cG9ydFc7XHJcbiAgICB2YXIgY2FudmFzV2lkdGg7XHJcbiAgICB2YXIgdmlld3BvcnRIYXNIU2Nyb2xsLCB2aWV3cG9ydEhhc1ZTY3JvbGw7XHJcbiAgICB2YXIgaGVhZGVyQ29sdW1uV2lkdGhEaWZmID0gMCwgaGVhZGVyQ29sdW1uSGVpZ2h0RGlmZiA9IDAsIC8vIGJvcmRlcitwYWRkaW5nXHJcbiAgICAgICAgY2VsbFdpZHRoRGlmZiA9IDAsIGNlbGxIZWlnaHREaWZmID0gMCwgalF1ZXJ5TmV3V2lkdGhCZWhhdmlvdXIgPSBmYWxzZTtcclxuICAgIHZhciBhYnNvbHV0ZUNvbHVtbk1pbldpZHRoO1xyXG4gICAgXHJcbiAgICB2YXIgdGFiYmluZ0RpcmVjdGlvbiA9IDE7XHJcbiAgICB2YXIgYWN0aXZlUG9zWDtcclxuICAgIHZhciBhY3RpdmVSb3csIGFjdGl2ZUNlbGw7XHJcbiAgICB2YXIgYWN0aXZlQ2VsbE5vZGUgPSBudWxsO1xyXG4gICAgdmFyIGN1cnJlbnRFZGl0b3IgPSBudWxsO1xyXG4gICAgdmFyIHNlcmlhbGl6ZWRFZGl0b3JWYWx1ZTtcclxuICAgIHZhciBlZGl0Q29udHJvbGxlcjtcclxuXHJcbiAgICB2YXIgcm93c0NhY2hlID0ge307XHJcbiAgICB2YXIgcmVuZGVyZWRSb3dzID0gMDtcclxuICAgIHZhciBudW1WaXNpYmxlUm93cztcclxuICAgIHZhciBwcmV2U2Nyb2xsVG9wID0gMDtcclxuICAgIHZhciBzY3JvbGxUb3AgPSAwO1xyXG4gICAgdmFyIGxhc3RSZW5kZXJlZFNjcm9sbFRvcCA9IDA7XHJcbiAgICB2YXIgbGFzdFJlbmRlcmVkU2Nyb2xsTGVmdCA9IDA7XHJcbiAgICB2YXIgcHJldlNjcm9sbExlZnQgPSAwO1xyXG4gICAgdmFyIHNjcm9sbExlZnQgPSAwO1xyXG5cclxuICAgIHZhciBzZWxlY3Rpb25Nb2RlbDtcclxuICAgIHZhciBzZWxlY3RlZFJvd3MgPSBbXTtcclxuXHJcbiAgICB2YXIgcGx1Z2lucyA9IFtdO1xyXG4gICAgdmFyIGNlbGxDc3NDbGFzc2VzID0ge307XHJcblxyXG4gICAgdmFyIGNvbHVtbnNCeUlkID0ge307XHJcbiAgICB2YXIgc29ydENvbHVtbnMgPSBbXTtcclxuICAgIHZhciBjb2x1bW5Qb3NMZWZ0ID0gW107XHJcbiAgICB2YXIgY29sdW1uUG9zUmlnaHQgPSBbXTtcclxuXHJcbiAgICB2YXIgcGFnaW5nQWN0aXZlID0gZmFsc2U7XHJcbiAgICB2YXIgcGFnaW5nSXNMYXN0UGFnZSA9IGZhbHNlO1xyXG4gICAgXHJcbiAgICAvLyBhc3luYyBjYWxsIGhhbmRsZXNcclxuICAgIHZhciBoX2VkaXRvckxvYWRlciA9IG51bGw7XHJcbiAgICB2YXIgaF9yZW5kZXIgPSBudWxsO1xyXG4gICAgdmFyIGhfcG9zdHJlbmRlciA9IG51bGw7XHJcbiAgICB2YXIgaF9wb3N0cmVuZGVyQ2xlYW51cCA9IG51bGw7XHJcbiAgICB2YXIgcG9zdFByb2Nlc3NlZFJvd3MgPSB7fTtcclxuICAgIHZhciBwb3N0UHJvY2Vzc1RvUm93ID0gbnVsbDtcclxuICAgIHZhciBwb3N0UHJvY2Vzc0Zyb21Sb3cgPSBudWxsO1xyXG4gICAgdmFyIHBvc3RQcm9jZXNzZWRDbGVhbnVwUXVldWUgPSBbXTtcclxuICAgIHZhciBwb3N0UHJvY2Vzc2dyb3VwSWQgPSAwO1xyXG5cclxuICAgIC8vIHBlcmYgY291bnRlcnNcclxuICAgIHZhciBjb3VudGVyX3Jvd3NfcmVuZGVyZWQgPSAwO1xyXG4gICAgdmFyIGNvdW50ZXJfcm93c19yZW1vdmVkID0gMDtcclxuXHJcbiAgICAvLyBUaGVzZSB0d28gdmFyaWFibGVzIHdvcmsgYXJvdW5kIGEgYnVnIHdpdGggaW5lcnRpYWwgc2Nyb2xsaW5nIGluIFdlYmtpdC9CbGluayBvbiBNYWMuXHJcbiAgICAvLyBTZWUgaHR0cDovL2NyYnVnLmNvbS8zMTI0MjcuXHJcbiAgICB2YXIgcm93Tm9kZUZyb21MYXN0TW91c2VXaGVlbEV2ZW50OyAgLy8gdGhpcyBub2RlIG11c3Qgbm90IGJlIGRlbGV0ZWQgd2hpbGUgaW5lcnRpYWwgc2Nyb2xsaW5nXHJcbiAgICB2YXIgem9tYmllUm93Tm9kZUZyb21MYXN0TW91c2VXaGVlbEV2ZW50OyAgLy8gbm9kZSB0aGF0IHdhcyBoaWRkZW4gaW5zdGVhZCBvZiBnZXR0aW5nIGRlbGV0ZWRcclxuICAgIHZhciB6b21iaWVSb3dDYWNoZUZyb21MYXN0TW91c2VXaGVlbEV2ZW50OyAgLy8gcm93IGNhY2hlIGZvciBhYm92ZSBub2RlXHJcbiAgICB2YXIgem9tYmllUm93UG9zdFByb2Nlc3NlZEZyb21MYXN0TW91c2VXaGVlbEV2ZW50OyAgLy8gcG9zdCBwcm9jZXNzaW5nIHJlZmVyZW5jZXMgZm9yIGFib3ZlIG5vZGVcclxuXHJcbiAgICAvLyBzdG9yZSBjc3MgYXR0cmlidXRlcyBpZiBkaXNwbGF5Om5vbmUgaXMgYWN0aXZlIGluIGNvbnRhaW5lciBvciBwYXJlbnRcclxuICAgIHZhciBjc3NTaG93ID0geyBwb3NpdGlvbjogJ2Fic29sdXRlJywgdmlzaWJpbGl0eTogJ2hpZGRlbicsIGRpc3BsYXk6ICdibG9jaycgfTtcclxuICAgIHZhciAkaGlkZGVuUGFyZW50cztcclxuICAgIHZhciBvbGRQcm9wcyA9IFtdO1xyXG4gICAgdmFyIGNvbHVtblJlc2l6ZURyYWdnaW5nID0gZmFsc2U7XHJcblxyXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gICAgLy8gSW5pdGlhbGl6YXRpb25cclxuXHJcbiAgICBmdW5jdGlvbiBpbml0KCkge1xyXG4gICAgICBpZiAoY29udGFpbmVyIGluc3RhbmNlb2YgalF1ZXJ5KSB7IFxyXG4gICAgICAgICRjb250YWluZXIgPSBjb250YWluZXI7IFxyXG4gICAgICB9IGVsc2UgeyBcclxuICAgICAgICAkY29udGFpbmVyID0gJChjb250YWluZXIpOyBcclxuICAgICAgfVxyXG4gICAgICBpZiAoJGNvbnRhaW5lci5sZW5ndGggPCAxKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2xpY2tHcmlkIHJlcXVpcmVzIGEgdmFsaWQgY29udGFpbmVyLCBcIiArIGNvbnRhaW5lciArIFwiIGRvZXMgbm90IGV4aXN0IGluIHRoZSBET00uXCIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjYWNoZUNzc0ZvckhpZGRlbkluaXQoKTtcclxuXHJcbiAgICAgIC8vIGNhbGN1bGF0ZSB0aGVzZSBvbmx5IG9uY2UgYW5kIHNoYXJlIGJldHdlZW4gZ3JpZCBpbnN0YW5jZXNcclxuICAgICAgbWF4U3VwcG9ydGVkQ3NzSGVpZ2h0ID0gbWF4U3VwcG9ydGVkQ3NzSGVpZ2h0IHx8IGdldE1heFN1cHBvcnRlZENzc0hlaWdodCgpO1xyXG5cclxuICAgICAgb3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XHJcbiAgICAgIHZhbGlkYXRlQW5kRW5mb3JjZU9wdGlvbnMoKTtcclxuICAgICAgY29sdW1uRGVmYXVsdHMud2lkdGggPSBvcHRpb25zLmRlZmF1bHRDb2x1bW5XaWR0aDtcclxuXHJcbiAgICAgIGNvbHVtbnNCeUlkID0ge307XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sdW1ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBtID0gY29sdW1uc1tpXSA9ICQuZXh0ZW5kKHt9LCBjb2x1bW5EZWZhdWx0cywgY29sdW1uc1tpXSk7XHJcbiAgICAgICAgY29sdW1uc0J5SWRbbS5pZF0gPSBpO1xyXG4gICAgICAgIGlmIChtLm1pbldpZHRoICYmIG0ud2lkdGggPCBtLm1pbldpZHRoKSB7XHJcbiAgICAgICAgICBtLndpZHRoID0gbS5taW5XaWR0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG0ubWF4V2lkdGggJiYgbS53aWR0aCA+IG0ubWF4V2lkdGgpIHtcclxuICAgICAgICAgIG0ud2lkdGggPSBtLm1heFdpZHRoO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gdmFsaWRhdGUgbG9hZGVkIEphdmFTY3JpcHQgbW9kdWxlcyBhZ2FpbnN0IHJlcXVlc3RlZCBvcHRpb25zXHJcbiAgICAgIGlmIChvcHRpb25zLmVuYWJsZUNvbHVtblJlb3JkZXIgJiYgISQuZm4uc29ydGFibGUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTbGlja0dyaWQncyAnZW5hYmxlQ29sdW1uUmVvcmRlciA9IHRydWUnIG9wdGlvbiByZXF1aXJlcyBqcXVlcnktdWkuc29ydGFibGUgbW9kdWxlIHRvIGJlIGxvYWRlZFwiKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZWRpdENvbnRyb2xsZXIgPSB7XHJcbiAgICAgICAgXCJjb21taXRDdXJyZW50RWRpdFwiOiBjb21taXRDdXJyZW50RWRpdCxcclxuICAgICAgICBcImNhbmNlbEN1cnJlbnRFZGl0XCI6IGNhbmNlbEN1cnJlbnRFZGl0XHJcbiAgICAgIH07XHJcblxyXG4gICAgICAkY29udGFpbmVyXHJcbiAgICAgICAgICAuZW1wdHkoKVxyXG4gICAgICAgICAgLmNzcyhcIm92ZXJmbG93XCIsIFwiaGlkZGVuXCIpXHJcbiAgICAgICAgICAuY3NzKFwib3V0bGluZVwiLCAwKVxyXG4gICAgICAgICAgLmFkZENsYXNzKHVpZClcclxuICAgICAgICAgIC5hZGRDbGFzcyhcInVpLXdpZGdldFwiKTtcclxuXHJcbiAgICAgIC8vIHNldCB1cCBhIHBvc2l0aW9uaW5nIGNvbnRhaW5lciBpZiBuZWVkZWRcclxuICAgICAgaWYgKCEvcmVsYXRpdmV8YWJzb2x1dGV8Zml4ZWQvLnRlc3QoJGNvbnRhaW5lci5jc3MoXCJwb3NpdGlvblwiKSkpIHtcclxuICAgICAgICAkY29udGFpbmVyLmNzcyhcInBvc2l0aW9uXCIsIFwicmVsYXRpdmVcIik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgICRmb2N1c1NpbmsgPSAkKFwiPGRpdiB0YWJJbmRleD0nMCcgaGlkZUZvY3VzIHN0eWxlPSdwb3NpdGlvbjpmaXhlZDt3aWR0aDowO2hlaWdodDowO3RvcDowO2xlZnQ6MDtvdXRsaW5lOjA7Jz48L2Rpdj5cIikuYXBwZW5kVG8oJGNvbnRhaW5lcik7XHJcblxyXG4gICAgICBpZiAob3B0aW9ucy5jcmVhdGVQcmVIZWFkZXJQYW5lbCkge1xyXG4gICAgICAgICRwcmVIZWFkZXJQYW5lbFNjcm9sbGVyID0gJChcIjxkaXYgY2xhc3M9J3NsaWNrLXByZWhlYWRlci1wYW5lbCB1aS1zdGF0ZS1kZWZhdWx0JyBzdHlsZT0nb3ZlcmZsb3c6aGlkZGVuO3Bvc2l0aW9uOnJlbGF0aXZlOycgLz5cIikuYXBwZW5kVG8oJGNvbnRhaW5lcik7XHJcbiAgICAgICAgJHByZUhlYWRlclBhbmVsID0gJChcIjxkaXYgLz5cIikuYXBwZW5kVG8oJHByZUhlYWRlclBhbmVsU2Nyb2xsZXIpO1xyXG4gICAgICAgICRwcmVIZWFkZXJQYW5lbFNwYWNlciA9ICQoXCI8ZGl2IHN0eWxlPSdkaXNwbGF5OmJsb2NrO2hlaWdodDoxcHg7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDowOyc+PC9kaXY+XCIpXHJcbiAgICAgICAgICAgIC5hcHBlbmRUbygkcHJlSGVhZGVyUGFuZWxTY3JvbGxlcik7XHJcblxyXG4gICAgICAgIGlmICghb3B0aW9ucy5zaG93UHJlSGVhZGVyUGFuZWwpIHtcclxuICAgICAgICAgICRwcmVIZWFkZXJQYW5lbFNjcm9sbGVyLmhpZGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgICRoZWFkZXJTY3JvbGxlciA9ICQoXCI8ZGl2IGNsYXNzPSdzbGljay1oZWFkZXIgdWktc3RhdGUtZGVmYXVsdCcgLz5cIikuYXBwZW5kVG8oJGNvbnRhaW5lcik7XHJcbiAgICAgICRoZWFkZXJzID0gJChcIjxkaXYgY2xhc3M9J3NsaWNrLWhlYWRlci1jb2x1bW5zJyBzdHlsZT0nbGVmdDotMTAwMHB4JyAvPlwiKS5hcHBlbmRUbygkaGVhZGVyU2Nyb2xsZXIpO1xyXG5cclxuICAgICAgJGhlYWRlclJvd1Njcm9sbGVyID0gJChcIjxkaXYgY2xhc3M9J3NsaWNrLWhlYWRlcnJvdyB1aS1zdGF0ZS1kZWZhdWx0JyAvPlwiKS5hcHBlbmRUbygkY29udGFpbmVyKTtcclxuICAgICAgJGhlYWRlclJvdyA9ICQoXCI8ZGl2IGNsYXNzPSdzbGljay1oZWFkZXJyb3ctY29sdW1ucycgLz5cIikuYXBwZW5kVG8oJGhlYWRlclJvd1Njcm9sbGVyKTtcclxuICAgICAgJGhlYWRlclJvd1NwYWNlciA9ICQoXCI8ZGl2IHN0eWxlPSdkaXNwbGF5OmJsb2NrO2hlaWdodDoxcHg7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDowOyc+PC9kaXY+XCIpXHJcbiAgICAgICAgICAuYXBwZW5kVG8oJGhlYWRlclJvd1Njcm9sbGVyKTtcclxuXHJcbiAgICAgICR0b3BQYW5lbFNjcm9sbGVyID0gJChcIjxkaXYgY2xhc3M9J3NsaWNrLXRvcC1wYW5lbC1zY3JvbGxlciB1aS1zdGF0ZS1kZWZhdWx0JyAvPlwiKS5hcHBlbmRUbygkY29udGFpbmVyKTtcclxuICAgICAgJHRvcFBhbmVsID0gJChcIjxkaXYgY2xhc3M9J3NsaWNrLXRvcC1wYW5lbCcgc3R5bGU9J3dpZHRoOjEwMDAwcHgnIC8+XCIpLmFwcGVuZFRvKCR0b3BQYW5lbFNjcm9sbGVyKTtcclxuXHJcbiAgICAgIGlmICghb3B0aW9ucy5zaG93VG9wUGFuZWwpIHtcclxuICAgICAgICAkdG9wUGFuZWxTY3JvbGxlci5oaWRlKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghb3B0aW9ucy5zaG93SGVhZGVyUm93KSB7XHJcbiAgICAgICAgJGhlYWRlclJvd1Njcm9sbGVyLmhpZGUoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgJHZpZXdwb3J0ID0gJChcIjxkaXYgY2xhc3M9J3NsaWNrLXZpZXdwb3J0JyBzdHlsZT0nd2lkdGg6MTAwJTtvdmVyZmxvdzphdXRvO291dGxpbmU6MDtwb3NpdGlvbjpyZWxhdGl2ZTs7Jz5cIikuYXBwZW5kVG8oJGNvbnRhaW5lcik7XHJcbiAgICAgICR2aWV3cG9ydC5jc3MoXCJvdmVyZmxvdy15XCIsIG9wdGlvbnMuYWx3YXlzU2hvd1ZlcnRpY2FsU2Nyb2xsID8gXCJzY3JvbGxcIiA6IChvcHRpb25zLmF1dG9IZWlnaHQgPyBcImhpZGRlblwiIDogXCJhdXRvXCIpKTtcclxuICAgICAgJHZpZXdwb3J0LmNzcyhcIm92ZXJmbG93LXhcIiwgb3B0aW9ucy5mb3JjZUZpdENvbHVtbnMgPyBcImhpZGRlblwiIDogXCJhdXRvXCIpO1xyXG4gICAgICBpZiAob3B0aW9ucy52aWV3cG9ydENsYXNzKSAkdmlld3BvcnQudG9nZ2xlQ2xhc3Mob3B0aW9ucy52aWV3cG9ydENsYXNzLCB0cnVlKTtcclxuXHJcbiAgICAgICRjYW52YXMgPSAkKFwiPGRpdiBjbGFzcz0nZ3JpZC1jYW52YXMnIC8+XCIpLmFwcGVuZFRvKCR2aWV3cG9ydCk7XHJcblxyXG4gICAgICBzY3JvbGxiYXJEaW1lbnNpb25zID0gc2Nyb2xsYmFyRGltZW5zaW9ucyB8fCBtZWFzdXJlU2Nyb2xsYmFyKCk7XHJcblxyXG4gICAgICBpZiAoJHByZUhlYWRlclBhbmVsU3BhY2VyKSAkcHJlSGVhZGVyUGFuZWxTcGFjZXIuY3NzKFwid2lkdGhcIiwgZ2V0Q2FudmFzV2lkdGgoKSArIHNjcm9sbGJhckRpbWVuc2lvbnMud2lkdGggKyBcInB4XCIpO1xyXG4gICAgICAkaGVhZGVycy53aWR0aChnZXRIZWFkZXJzV2lkdGgoKSk7XHJcbiAgICAgICRoZWFkZXJSb3dTcGFjZXIuY3NzKFwid2lkdGhcIiwgZ2V0Q2FudmFzV2lkdGgoKSArIHNjcm9sbGJhckRpbWVuc2lvbnMud2lkdGggKyBcInB4XCIpO1xyXG5cclxuXHJcblxyXG4gICAgICBpZiAob3B0aW9ucy5jcmVhdGVGb290ZXJSb3cpIHtcclxuICAgICAgICAkZm9vdGVyUm93U2Nyb2xsZXIgPSAkKFwiPGRpdiBjbGFzcz0nc2xpY2stZm9vdGVycm93IHVpLXN0YXRlLWRlZmF1bHQnIC8+XCIpLmFwcGVuZFRvKCRjb250YWluZXIpO1xyXG4gICAgICAgICRmb290ZXJSb3cgPSAkKFwiPGRpdiBjbGFzcz0nc2xpY2stZm9vdGVycm93LWNvbHVtbnMnIC8+XCIpLmFwcGVuZFRvKCRmb290ZXJSb3dTY3JvbGxlcik7XHJcbiAgICAgICAgJGZvb3RlclJvd1NwYWNlciA9ICQoXCI8ZGl2IHN0eWxlPSdkaXNwbGF5OmJsb2NrO2hlaWdodDoxcHg7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDowOyc+PC9kaXY+XCIpXHJcbiAgICAgICAgICAgIC5jc3MoXCJ3aWR0aFwiLCBnZXRDYW52YXNXaWR0aCgpICsgc2Nyb2xsYmFyRGltZW5zaW9ucy53aWR0aCArIFwicHhcIilcclxuICAgICAgICAgICAgLmFwcGVuZFRvKCRmb290ZXJSb3dTY3JvbGxlcik7XHJcblxyXG4gICAgICAgIGlmICghb3B0aW9ucy5zaG93Rm9vdGVyUm93KSB7XHJcbiAgICAgICAgICAkZm9vdGVyUm93U2Nyb2xsZXIuaGlkZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgJGZvY3VzU2luazIgPSAkZm9jdXNTaW5rLmNsb25lKCkuYXBwZW5kVG8oJGNvbnRhaW5lcik7XHJcblxyXG4gICAgICBpZiAoIW9wdGlvbnMuZXhwbGljaXRJbml0aWFsaXphdGlvbikge1xyXG4gICAgICAgIGZpbmlzaEluaXRpYWxpemF0aW9uKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBmaW5pc2hJbml0aWFsaXphdGlvbigpIHtcclxuICAgICAgaWYgKCFpbml0aWFsaXplZCkge1xyXG4gICAgICAgIGluaXRpYWxpemVkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgdmlld3BvcnRXID0gcGFyc2VGbG9hdCgkLmNzcygkY29udGFpbmVyWzBdLCBcIndpZHRoXCIsIHRydWUpKTtcclxuXHJcbiAgICAgICAgLy8gaGVhZGVyIGNvbHVtbnMgYW5kIGNlbGxzIG1heSBoYXZlIGRpZmZlcmVudCBwYWRkaW5nL2JvcmRlciBza2V3aW5nIHdpZHRoIGNhbGN1bGF0aW9ucyAoYm94LXNpemluZywgaGVsbG8/KVxyXG4gICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgZGlmZiBzbyB3ZSBjYW4gc2V0IGNvbnNpc3RlbnQgc2l6ZXNcclxuICAgICAgICBtZWFzdXJlQ2VsbFBhZGRpbmdBbmRCb3JkZXIoKTtcclxuXHJcbiAgICAgICAgLy8gZm9yIHVzYWJpbGl0eSByZWFzb25zLCBhbGwgdGV4dCBzZWxlY3Rpb24gaW4gU2xpY2tHcmlkIGlzIGRpc2FibGVkXHJcbiAgICAgICAgLy8gd2l0aCB0aGUgZXhjZXB0aW9uIG9mIGlucHV0IGFuZCB0ZXh0YXJlYSBlbGVtZW50cyAoc2VsZWN0aW9uIG11c3RcclxuICAgICAgICAvLyBiZSBlbmFibGVkIHRoZXJlIHNvIHRoYXQgZWRpdG9ycyB3b3JrIGFzIGV4cGVjdGVkKTsgbm90ZSB0aGF0XHJcbiAgICAgICAgLy8gc2VsZWN0aW9uIGluIGdyaWQgY2VsbHMgKGdyaWQgYm9keSkgaXMgYWxyZWFkeSB1bmF2YWlsYWJsZSBpblxyXG4gICAgICAgIC8vIGFsbCBicm93c2VycyBleGNlcHQgSUVcclxuICAgICAgICBkaXNhYmxlU2VsZWN0aW9uKCRoZWFkZXJzKTsgLy8gZGlzYWJsZSBhbGwgdGV4dCBzZWxlY3Rpb24gaW4gaGVhZGVyIChpbmNsdWRpbmcgaW5wdXQgYW5kIHRleHRhcmVhKVxyXG5cclxuICAgICAgICBpZiAoIW9wdGlvbnMuZW5hYmxlVGV4dFNlbGVjdGlvbk9uQ2VsbHMpIHtcclxuICAgICAgICAgIC8vIGRpc2FibGUgdGV4dCBzZWxlY3Rpb24gaW4gZ3JpZCBjZWxscyBleGNlcHQgaW4gaW5wdXQgYW5kIHRleHRhcmVhIGVsZW1lbnRzXHJcbiAgICAgICAgICAvLyAodGhpcyBpcyBJRS1zcGVjaWZpYywgYmVjYXVzZSBzZWxlY3RzdGFydCBldmVudCB3aWxsIG9ubHkgZmlyZSBpbiBJRSlcclxuICAgICAgICAgICR2aWV3cG9ydC5vbihcInNlbGVjdHN0YXJ0LnVpXCIsIGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJChldmVudC50YXJnZXQpLmlzKFwiaW5wdXQsdGV4dGFyZWFcIik7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHVwZGF0ZUNvbHVtbkNhY2hlcygpO1xyXG4gICAgICAgIGNyZWF0ZUNvbHVtbkhlYWRlcnMoKTtcclxuICAgICAgICBzZXR1cENvbHVtblNvcnQoKTtcclxuICAgICAgICBjcmVhdGVDc3NSdWxlcygpO1xyXG4gICAgICAgIHJlc2l6ZUNhbnZhcygpO1xyXG4gICAgICAgIGJpbmRBbmNlc3RvclNjcm9sbEV2ZW50cygpO1xyXG5cclxuICAgICAgICAkY29udGFpbmVyXHJcbiAgICAgICAgICAgIC5vbihcInJlc2l6ZS5zbGlja2dyaWRcIiwgcmVzaXplQ2FudmFzKTtcclxuICAgICAgICAkdmlld3BvcnRcclxuICAgICAgICAgICAgLy8ub24oXCJjbGlja1wiLCBoYW5kbGVDbGljaylcclxuICAgICAgICAgICAgLm9uKFwic2Nyb2xsXCIsIGhhbmRsZVNjcm9sbCk7XHJcbiAgICAgICAgJGhlYWRlclNjcm9sbGVyXHJcbiAgICAgICAgICAgIC8vLm9uKFwic2Nyb2xsXCIsIGhhbmRsZUhlYWRlclNjcm9sbClcclxuICAgICAgICAgICAgLm9uKFwiY29udGV4dG1lbnVcIiwgaGFuZGxlSGVhZGVyQ29udGV4dE1lbnUpXHJcbiAgICAgICAgICAgIC5vbihcImNsaWNrXCIsIGhhbmRsZUhlYWRlckNsaWNrKVxyXG4gICAgICAgICAgICAub24oXCJtb3VzZWVudGVyXCIsIFwiLnNsaWNrLWhlYWRlci1jb2x1bW5cIiwgaGFuZGxlSGVhZGVyTW91c2VFbnRlcilcclxuICAgICAgICAgICAgLm9uKFwibW91c2VsZWF2ZVwiLCBcIi5zbGljay1oZWFkZXItY29sdW1uXCIsIGhhbmRsZUhlYWRlck1vdXNlTGVhdmUpO1xyXG4gICAgICAgICRoZWFkZXJSb3dTY3JvbGxlclxyXG4gICAgICAgICAgICAub24oXCJzY3JvbGxcIiwgaGFuZGxlSGVhZGVyUm93U2Nyb2xsKTtcclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMuY3JlYXRlRm9vdGVyUm93KSB7XHJcbiAgICAgICAgICAkZm9vdGVyUm93U2Nyb2xsZXJcclxuICAgICAgICAgICAgICAub24oXCJzY3JvbGxcIiwgaGFuZGxlRm9vdGVyUm93U2Nyb2xsKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLmNyZWF0ZVByZUhlYWRlclBhbmVsKSB7XHJcbiAgICAgICAgICAkcHJlSGVhZGVyUGFuZWxTY3JvbGxlclxyXG4gICAgICAgICAgICAgIC5vbihcInNjcm9sbFwiLCBoYW5kbGVQcmVIZWFkZXJQYW5lbFNjcm9sbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAkZm9jdXNTaW5rLmFkZCgkZm9jdXNTaW5rMilcclxuICAgICAgICAgICAgLm9uKFwia2V5ZG93blwiLCBoYW5kbGVLZXlEb3duKTtcclxuICAgICAgICAkY2FudmFzXHJcbiAgICAgICAgICAgIC5vbihcImtleWRvd25cIiwgaGFuZGxlS2V5RG93bilcclxuICAgICAgICAgICAgLm9uKFwiY2xpY2tcIiwgaGFuZGxlQ2xpY2spXHJcbiAgICAgICAgICAgIC5vbihcImRibGNsaWNrXCIsIGhhbmRsZURibENsaWNrKVxyXG4gICAgICAgICAgICAub24oXCJjb250ZXh0bWVudVwiLCBoYW5kbGVDb250ZXh0TWVudSlcclxuICAgICAgICAgICAgLm9uKFwiZHJhZ2luaXRcIiwgaGFuZGxlRHJhZ0luaXQpXHJcbiAgICAgICAgICAgIC5vbihcImRyYWdzdGFydFwiLCB7ZGlzdGFuY2U6IDN9LCBoYW5kbGVEcmFnU3RhcnQpXHJcbiAgICAgICAgICAgIC5vbihcImRyYWdcIiwgaGFuZGxlRHJhZylcclxuICAgICAgICAgICAgLm9uKFwiZHJhZ2VuZFwiLCBoYW5kbGVEcmFnRW5kKVxyXG4gICAgICAgICAgICAub24oXCJtb3VzZWVudGVyXCIsIFwiLnNsaWNrLWNlbGxcIiwgaGFuZGxlTW91c2VFbnRlcilcclxuICAgICAgICAgICAgLm9uKFwibW91c2VsZWF2ZVwiLCBcIi5zbGljay1jZWxsXCIsIGhhbmRsZU1vdXNlTGVhdmUpO1xyXG5cclxuICAgICAgICAvLyBXb3JrIGFyb3VuZCBodHRwOi8vY3JidWcuY29tLzMxMjQyNy5cclxuICAgICAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC93ZWJraXQvKSAmJlxyXG4gICAgICAgICAgICBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL21hY2ludG9zaC8pKSB7XHJcbiAgICAgICAgICAkY2FudmFzLm9uKFwibW91c2V3aGVlbFwiLCBoYW5kbGVNb3VzZVdoZWVsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdG9yZUNzc0Zyb21IaWRkZW5Jbml0KCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjYWNoZUNzc0ZvckhpZGRlbkluaXQoKSB7XHJcbiAgICAgIC8vIGhhbmRsZSBkaXNwbGF5Om5vbmUgb24gY29udGFpbmVyIG9yIGNvbnRhaW5lciBwYXJlbnRzXHJcbiAgICAgICRoaWRkZW5QYXJlbnRzID0gJGNvbnRhaW5lci5wYXJlbnRzKCkuYWRkQmFjaygpLm5vdCgnOnZpc2libGUnKTtcclxuICAgICAgJGhpZGRlblBhcmVudHMuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgb2xkID0ge307XHJcbiAgICAgICAgZm9yICggdmFyIG5hbWUgaW4gY3NzU2hvdyApIHtcclxuICAgICAgICAgIG9sZFsgbmFtZSBdID0gdGhpcy5zdHlsZVsgbmFtZSBdO1xyXG4gICAgICAgICAgdGhpcy5zdHlsZVsgbmFtZSBdID0gY3NzU2hvd1sgbmFtZSBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvbGRQcm9wcy5wdXNoKG9sZCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlc3RvcmVDc3NGcm9tSGlkZGVuSW5pdCgpIHtcclxuICAgICAgLy8gZmluaXNoIGhhbmRsZSBkaXNwbGF5Om5vbmUgb24gY29udGFpbmVyIG9yIGNvbnRhaW5lciBwYXJlbnRzXHJcbiAgICAgIC8vIC0gcHV0IHZhbHVlcyBiYWNrIHRoZSB3YXkgdGhleSB3ZXJlXHJcbiAgICAgICRoaWRkZW5QYXJlbnRzLmVhY2goZnVuY3Rpb24oaSkge1xyXG4gICAgICAgIHZhciBvbGQgPSBvbGRQcm9wc1tpXTtcclxuICAgICAgICBmb3IgKCB2YXIgbmFtZSBpbiBjc3NTaG93ICkge1xyXG4gICAgICAgICAgdGhpcy5zdHlsZVsgbmFtZSBdID0gb2xkWyBuYW1lIF07XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZWdpc3RlclBsdWdpbihwbHVnaW4pIHtcclxuICAgICAgcGx1Z2lucy51bnNoaWZ0KHBsdWdpbik7XHJcbiAgICAgIHBsdWdpbi5pbml0KHNlbGYpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHVucmVnaXN0ZXJQbHVnaW4ocGx1Z2luKSB7XHJcbiAgICAgIGZvciAodmFyIGkgPSBwbHVnaW5zLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICBpZiAocGx1Z2luc1tpXSA9PT0gcGx1Z2luKSB7XHJcbiAgICAgICAgICBpZiAocGx1Z2luc1tpXS5kZXN0cm95KSB7XHJcbiAgICAgICAgICAgIHBsdWdpbnNbaV0uZGVzdHJveSgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcGx1Z2lucy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzZXRTZWxlY3Rpb25Nb2RlbChtb2RlbCkge1xyXG4gICAgICBpZiAoc2VsZWN0aW9uTW9kZWwpIHtcclxuICAgICAgICBzZWxlY3Rpb25Nb2RlbC5vblNlbGVjdGVkUmFuZ2VzQ2hhbmdlZC51bnN1YnNjcmliZShoYW5kbGVTZWxlY3RlZFJhbmdlc0NoYW5nZWQpO1xyXG4gICAgICAgIGlmIChzZWxlY3Rpb25Nb2RlbC5kZXN0cm95KSB7XHJcbiAgICAgICAgICBzZWxlY3Rpb25Nb2RlbC5kZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBzZWxlY3Rpb25Nb2RlbCA9IG1vZGVsO1xyXG4gICAgICBpZiAoc2VsZWN0aW9uTW9kZWwpIHtcclxuICAgICAgICBzZWxlY3Rpb25Nb2RlbC5pbml0KHNlbGYpO1xyXG4gICAgICAgIHNlbGVjdGlvbk1vZGVsLm9uU2VsZWN0ZWRSYW5nZXNDaGFuZ2VkLnN1YnNjcmliZShoYW5kbGVTZWxlY3RlZFJhbmdlc0NoYW5nZWQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0U2VsZWN0aW9uTW9kZWwoKSB7XHJcbiAgICAgIHJldHVybiBzZWxlY3Rpb25Nb2RlbDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRDYW52YXNOb2RlKCkge1xyXG4gICAgICByZXR1cm4gJGNhbnZhc1swXTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBtZWFzdXJlU2Nyb2xsYmFyKCkge1xyXG4gICAgICB2YXIgJG91dGVyZGl2ID0gJCgnPGRpdiBjbGFzcz1cIicgKyAkdmlld3BvcnQuY2xhc3NOYW1lICsgJ1wiIHN0eWxlPVwicG9zaXRpb246YWJzb2x1dGU7IHRvcDotMTAwMDBweDsgbGVmdDotMTAwMDBweDsgb3ZlcmZsb3c6YXV0bzsgd2lkdGg6MTAwcHg7IGhlaWdodDoxMDBweDtcIj48L2Rpdj4nKS5hcHBlbmRUbygkdmlld3BvcnQpO1xyXG4gICAgICB2YXIgJGlubmVyZGl2ID0gJCgnPGRpdiBzdHlsZT1cIndpZHRoOjIwMHB4OyBoZWlnaHQ6MjAwcHg7IG92ZXJmbG93OmF1dG87XCI+PC9kaXY+JykuYXBwZW5kVG8oJG91dGVyZGl2KTtcclxuICAgICAgdmFyIGRpbSA9IHtcclxuXHR3aWR0aDogJG91dGVyZGl2WzBdLm9mZnNldFdpZHRoIC0gJG91dGVyZGl2WzBdLmNsaWVudFdpZHRoLFxyXG5cdGhlaWdodDogJG91dGVyZGl2WzBdLm9mZnNldEhlaWdodCAtICRvdXRlcmRpdlswXS5jbGllbnRIZWlnaHRcclxuICAgICAgfTtcclxuICAgICAgJGlubmVyZGl2LnJlbW92ZSgpO1xyXG4gICAgICAkb3V0ZXJkaXYucmVtb3ZlKCk7XHJcbiAgICAgIHJldHVybiBkaW07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0Q29sdW1uVG90YWxXaWR0aChpbmNsdWRlU2Nyb2xsYmFyKSB7XHJcbiAgICAgIHZhciB0b3RhbFdpZHRoID0gMDtcclxuICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gY29sdW1ucy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gY29sdW1uc1tpXS53aWR0aDtcclxuICAgICAgICB0b3RhbFdpZHRoICs9IHdpZHRoO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpbmNsdWRlU2Nyb2xsYmFyKSB7XHJcbiAgICAgICAgdG90YWxXaWR0aCArPSBzY3JvbGxiYXJEaW1lbnNpb25zLndpZHRoO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0b3RhbFdpZHRoO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldEhlYWRlcnNXaWR0aCgpIHtcclxuICAgICAgdmFyIGhlYWRlcnNXaWR0aCA9IGdldENvbHVtblRvdGFsV2lkdGgoIW9wdGlvbnMuYXV0b0hlaWdodCk7XHJcbiAgICAgIHJldHVybiBNYXRoLm1heChoZWFkZXJzV2lkdGgsIHZpZXdwb3J0VykgKyAxMDAwO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldENhbnZhc1dpZHRoKCkge1xyXG4gICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSB2aWV3cG9ydEhhc1ZTY3JvbGwgPyB2aWV3cG9ydFcgLSBzY3JvbGxiYXJEaW1lbnNpb25zLndpZHRoIDogdmlld3BvcnRXO1xyXG4gICAgICB2YXIgcm93V2lkdGggPSAwO1xyXG4gICAgICB2YXIgaSA9IGNvbHVtbnMubGVuZ3RoO1xyXG4gICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgcm93V2lkdGggKz0gY29sdW1uc1tpXS53aWR0aDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gb3B0aW9ucy5mdWxsV2lkdGhSb3dzID8gTWF0aC5tYXgocm93V2lkdGgsIGF2YWlsYWJsZVdpZHRoKSA6IHJvd1dpZHRoO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZUNhbnZhc1dpZHRoKGZvcmNlQ29sdW1uV2lkdGhzVXBkYXRlKSB7XHJcbiAgICAgIHZhciBvbGRDYW52YXNXaWR0aCA9IGNhbnZhc1dpZHRoO1xyXG4gICAgICBjYW52YXNXaWR0aCA9IGdldENhbnZhc1dpZHRoKCk7XHJcblxyXG4gICAgICBpZiAoY2FudmFzV2lkdGggIT0gb2xkQ2FudmFzV2lkdGgpIHtcclxuICAgICAgICAkY2FudmFzLndpZHRoKGNhbnZhc1dpZHRoKTtcclxuICAgICAgICAkaGVhZGVyUm93LndpZHRoKGNhbnZhc1dpZHRoKTtcclxuICAgICAgICBpZiAob3B0aW9ucy5jcmVhdGVGb290ZXJSb3cpIHsgJGZvb3RlclJvdy53aWR0aChjYW52YXNXaWR0aCk7IH1cclxuICAgICAgICBpZiAob3B0aW9ucy5jcmVhdGVQcmVIZWFkZXJQYW5lbCkgeyAkcHJlSGVhZGVyUGFuZWwud2lkdGgoY2FudmFzV2lkdGgpOyB9XHJcbiAgICAgICAgJGhlYWRlcnMud2lkdGgoZ2V0SGVhZGVyc1dpZHRoKCkpO1xyXG4gICAgICAgIHZpZXdwb3J0SGFzSFNjcm9sbCA9IChjYW52YXNXaWR0aCA+IHZpZXdwb3J0VyAtIHNjcm9sbGJhckRpbWVuc2lvbnMud2lkdGgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAgdmFyIHc9Y2FudmFzV2lkdGggKyAodmlld3BvcnRIYXNWU2Nyb2xsID8gc2Nyb2xsYmFyRGltZW5zaW9ucy53aWR0aCA6IDApO1xyXG4gICAgICAgJGhlYWRlclJvd1NwYWNlci53aWR0aCh3KTtcclxuICAgICAgIGlmIChvcHRpb25zLmNyZWF0ZUZvb3RlclJvdykgeyAkZm9vdGVyUm93U3BhY2VyLndpZHRoKHcpOyB9XHJcbiAgICAgICBpZiAob3B0aW9ucy5jcmVhdGVQcmVIZWFkZXJQYW5lbCkgeyAkcHJlSGVhZGVyUGFuZWxTcGFjZXIud2lkdGgodyk7IH1cclxuXHJcbiAgICAgIGlmIChjYW52YXNXaWR0aCAhPSBvbGRDYW52YXNXaWR0aCB8fCBmb3JjZUNvbHVtbldpZHRoc1VwZGF0ZSkge1xyXG4gICAgICAgIGFwcGx5Q29sdW1uV2lkdGhzKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkaXNhYmxlU2VsZWN0aW9uKCR0YXJnZXQpIHtcclxuICAgICAgaWYgKCR0YXJnZXQgJiYgJHRhcmdldC5qcXVlcnkpIHtcclxuICAgICAgICAkdGFyZ2V0XHJcbiAgICAgICAgICAgIC5hdHRyKFwidW5zZWxlY3RhYmxlXCIsIFwib25cIilcclxuICAgICAgICAgICAgLmNzcyhcIk1velVzZXJTZWxlY3RcIiwgXCJub25lXCIpXHJcbiAgICAgICAgICAgIC5vbihcInNlbGVjdHN0YXJ0LnVpXCIsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH0pOyAvLyBmcm9tIGpxdWVyeTp1aS5jb3JlLmpzIDEuNy4yXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRNYXhTdXBwb3J0ZWRDc3NIZWlnaHQoKSB7XHJcbiAgICAgIHZhciBzdXBwb3J0ZWRIZWlnaHQgPSAxMDAwMDAwO1xyXG4gICAgICAvLyBGRiByZXBvcnRzIHRoZSBoZWlnaHQgYmFjayBidXQgc3RpbGwgcmVuZGVycyBibGFuayBhZnRlciB+Nk0gcHhcclxuICAgICAgdmFyIHRlc3RVcFRvID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94LykgPyA2MDAwMDAwIDogMTAwMDAwMDAwMDtcclxuICAgICAgdmFyIGRpdiA9ICQoXCI8ZGl2IHN0eWxlPSdkaXNwbGF5Om5vbmUnIC8+XCIpLmFwcGVuZFRvKGRvY3VtZW50LmJvZHkpO1xyXG5cclxuICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICB2YXIgdGVzdCA9IHN1cHBvcnRlZEhlaWdodCAqIDI7XHJcbiAgICAgICAgZGl2LmNzcyhcImhlaWdodFwiLCB0ZXN0KTtcclxuICAgICAgICBpZiAodGVzdCA+IHRlc3RVcFRvIHx8IGRpdi5oZWlnaHQoKSAhPT0gdGVzdCkge1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHN1cHBvcnRlZEhlaWdodCA9IHRlc3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBkaXYucmVtb3ZlKCk7XHJcbiAgICAgIHJldHVybiBzdXBwb3J0ZWRIZWlnaHQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0VUlEKCkge1xyXG4gICAgICByZXR1cm4gdWlkO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldEhlYWRlckNvbHVtbldpZHRoRGlmZigpIHtcclxuICAgICAgcmV0dXJuIGhlYWRlckNvbHVtbldpZHRoRGlmZjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRTY3JvbGxiYXJEaW1lbnNpb25zKCkge1xyXG4gICAgICByZXR1cm4gc2Nyb2xsYmFyRGltZW5zaW9ucztcclxuICAgIH1cclxuXHJcbiAgICAvLyBUT0RPOiAgdGhpcyBpcyBzdGF0aWMuICBuZWVkIHRvIGhhbmRsZSBwYWdlIG11dGF0aW9uLlxyXG4gICAgZnVuY3Rpb24gYmluZEFuY2VzdG9yU2Nyb2xsRXZlbnRzKCkge1xyXG4gICAgICB2YXIgZWxlbSA9ICRjYW52YXNbMF07XHJcbiAgICAgIHdoaWxlICgoZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSkgIT0gZG9jdW1lbnQuYm9keSAmJiBlbGVtICE9IG51bGwpIHtcclxuICAgICAgICAvLyBiaW5kIHRvIHNjcm9sbCBjb250YWluZXJzIG9ubHlcclxuICAgICAgICBpZiAoZWxlbSA9PSAkdmlld3BvcnRbMF0gfHwgZWxlbS5zY3JvbGxXaWR0aCAhPSBlbGVtLmNsaWVudFdpZHRoIHx8IGVsZW0uc2Nyb2xsSGVpZ2h0ICE9IGVsZW0uY2xpZW50SGVpZ2h0KSB7XHJcbiAgICAgICAgICB2YXIgJGVsZW0gPSAkKGVsZW0pO1xyXG4gICAgICAgICAgaWYgKCEkYm91bmRBbmNlc3RvcnMpIHtcclxuICAgICAgICAgICAgJGJvdW5kQW5jZXN0b3JzID0gJGVsZW07XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAkYm91bmRBbmNlc3RvcnMgPSAkYm91bmRBbmNlc3RvcnMuYWRkKCRlbGVtKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgICRlbGVtLm9uKFwic2Nyb2xsLlwiICsgdWlkLCBoYW5kbGVBY3RpdmVDZWxsUG9zaXRpb25DaGFuZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHVuYmluZEFuY2VzdG9yU2Nyb2xsRXZlbnRzKCkge1xyXG4gICAgICBpZiAoISRib3VuZEFuY2VzdG9ycykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICAkYm91bmRBbmNlc3RvcnMub2ZmKFwic2Nyb2xsLlwiICsgdWlkKTtcclxuICAgICAgJGJvdW5kQW5jZXN0b3JzID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB1cGRhdGVDb2x1bW5IZWFkZXIoY29sdW1uSWQsIHRpdGxlLCB0b29sVGlwKSB7XHJcbiAgICAgIGlmICghaW5pdGlhbGl6ZWQpIHsgcmV0dXJuOyB9XHJcbiAgICAgIHZhciBpZHggPSBnZXRDb2x1bW5JbmRleChjb2x1bW5JZCk7XHJcbiAgICAgIGlmIChpZHggPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGNvbHVtbkRlZiA9IGNvbHVtbnNbaWR4XTtcclxuICAgICAgdmFyICRoZWFkZXIgPSAkaGVhZGVycy5jaGlsZHJlbigpLmVxKGlkeCk7XHJcbiAgICAgIGlmICgkaGVhZGVyKSB7XHJcbiAgICAgICAgaWYgKHRpdGxlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIGNvbHVtbnNbaWR4XS5uYW1lID0gdGl0bGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0b29sVGlwICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIGNvbHVtbnNbaWR4XS50b29sVGlwID0gdG9vbFRpcDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRyaWdnZXIoc2VsZi5vbkJlZm9yZUhlYWRlckNlbGxEZXN0cm95LCB7XHJcbiAgICAgICAgICBcIm5vZGVcIjogJGhlYWRlclswXSxcclxuICAgICAgICAgIFwiY29sdW1uXCI6IGNvbHVtbkRlZixcclxuICAgICAgICAgIFwiZ3JpZFwiOiBzZWxmXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICRoZWFkZXJcclxuICAgICAgICAgICAgLmF0dHIoXCJ0aXRsZVwiLCB0b29sVGlwIHx8IFwiXCIpXHJcbiAgICAgICAgICAgIC5jaGlsZHJlbigpLmVxKDApLmh0bWwodGl0bGUpO1xyXG5cclxuICAgICAgICB0cmlnZ2VyKHNlbGYub25IZWFkZXJDZWxsUmVuZGVyZWQsIHtcclxuICAgICAgICAgIFwibm9kZVwiOiAkaGVhZGVyWzBdLFxyXG4gICAgICAgICAgXCJjb2x1bW5cIjogY29sdW1uRGVmLFxyXG4gICAgICAgICAgXCJncmlkXCI6IHNlbGZcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldEhlYWRlcigpIHtcclxuICAgICAgcmV0dXJuICRoZWFkZXJzWzBdO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldEhlYWRlckNvbHVtbihjb2x1bW5JZE9ySWR4KSB7XHJcbiAgICAgIHZhciBpZHggPSAodHlwZW9mIGNvbHVtbklkT3JJZHggPT09IFwibnVtYmVyXCIgPyBjb2x1bW5JZE9ySWR4IDogZ2V0Q29sdW1uSW5kZXgoY29sdW1uSWRPcklkeCkpO1xyXG4gICAgICB2YXIgJHJ0biA9ICRoZWFkZXJzLmNoaWxkcmVuKCkuZXEoaWR4KTtcclxuICAgICAgcmV0dXJuICRydG4gJiYgJHJ0blswXTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRIZWFkZXJSb3coKSB7XHJcbiAgICAgIHJldHVybiAkaGVhZGVyUm93WzBdO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldEZvb3RlclJvdygpIHtcclxuICAgICAgcmV0dXJuICRmb290ZXJSb3dbMF07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0UHJlSGVhZGVyUGFuZWwoKSB7XHJcbiAgICAgIHJldHVybiAkcHJlSGVhZGVyUGFuZWxbMF07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0SGVhZGVyUm93Q29sdW1uKGNvbHVtbklkT3JJZHgpIHtcclxuICAgICAgdmFyIGlkeCA9ICh0eXBlb2YgY29sdW1uSWRPcklkeCA9PT0gXCJudW1iZXJcIiA/IGNvbHVtbklkT3JJZHggOiBnZXRDb2x1bW5JbmRleChjb2x1bW5JZE9ySWR4KSk7XHJcbiAgICAgIHZhciAkcnRuID0gJGhlYWRlclJvdy5jaGlsZHJlbigpLmVxKGlkeCk7XHJcbiAgICAgIHJldHVybiAkcnRuICYmICRydG5bMF07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0Rm9vdGVyUm93Q29sdW1uKGNvbHVtbklkT3JJZHgpIHtcclxuICAgICAgdmFyIGlkeCA9ICh0eXBlb2YgY29sdW1uSWRPcklkeCA9PT0gXCJudW1iZXJcIiA/IGNvbHVtbklkT3JJZHggOiBnZXRDb2x1bW5JbmRleChjb2x1bW5JZE9ySWR4KSk7XHJcbiAgICAgIHZhciAkcnRuID0gJGZvb3RlclJvdy5jaGlsZHJlbigpLmVxKGlkeCk7XHJcbiAgICAgIHJldHVybiAkcnRuICYmICRydG5bMF07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlQ29sdW1uSGVhZGVycygpIHtcclxuICAgICAgZnVuY3Rpb24gb25Nb3VzZUVudGVyKCkge1xyXG4gICAgICAgICQodGhpcykuYWRkQ2xhc3MoXCJ1aS1zdGF0ZS1ob3ZlclwiKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gb25Nb3VzZUxlYXZlKCkge1xyXG4gICAgICAgICQodGhpcykucmVtb3ZlQ2xhc3MoXCJ1aS1zdGF0ZS1ob3ZlclwiKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgJGhlYWRlcnMuZmluZChcIi5zbGljay1oZWFkZXItY29sdW1uXCIpXHJcbiAgICAgICAgLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICB2YXIgY29sdW1uRGVmID0gJCh0aGlzKS5kYXRhKFwiY29sdW1uXCIpO1xyXG4gICAgICAgICAgaWYgKGNvbHVtbkRlZikge1xyXG4gICAgICAgICAgICB0cmlnZ2VyKHNlbGYub25CZWZvcmVIZWFkZXJDZWxsRGVzdHJveSwge1xyXG4gICAgICAgICAgICAgIFwibm9kZVwiOiB0aGlzLFxyXG4gICAgICAgICAgICAgIFwiY29sdW1uXCI6IGNvbHVtbkRlZixcclxuICAgICAgICAgICAgICBcImdyaWRcIjogc2VsZlxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgJGhlYWRlcnMuZW1wdHkoKTtcclxuICAgICAgJGhlYWRlcnMud2lkdGgoZ2V0SGVhZGVyc1dpZHRoKCkpO1xyXG5cclxuICAgICAgJGhlYWRlclJvdy5maW5kKFwiLnNsaWNrLWhlYWRlcnJvdy1jb2x1bW5cIilcclxuICAgICAgICAuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHZhciBjb2x1bW5EZWYgPSAkKHRoaXMpLmRhdGEoXCJjb2x1bW5cIik7XHJcbiAgICAgICAgICBpZiAoY29sdW1uRGVmKSB7XHJcbiAgICAgICAgICAgIHRyaWdnZXIoc2VsZi5vbkJlZm9yZUhlYWRlclJvd0NlbGxEZXN0cm95LCB7XHJcbiAgICAgICAgICAgICAgXCJub2RlXCI6IHRoaXMsXHJcbiAgICAgICAgICAgICAgXCJjb2x1bW5cIjogY29sdW1uRGVmLFxyXG4gICAgICAgICAgICAgIFwiZ3JpZFwiOiBzZWxmXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAkaGVhZGVyUm93LmVtcHR5KCk7XHJcblxyXG4gICAgICBpZiAob3B0aW9ucy5jcmVhdGVGb290ZXJSb3cpIHtcclxuICAgICAgICAkZm9vdGVyUm93LmZpbmQoXCIuc2xpY2stZm9vdGVycm93LWNvbHVtblwiKVxyXG4gICAgICAgICAgLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBjb2x1bW5EZWYgPSAkKHRoaXMpLmRhdGEoXCJjb2x1bW5cIik7XHJcbiAgICAgICAgICAgIGlmIChjb2x1bW5EZWYpIHtcclxuICAgICAgICAgICAgICB0cmlnZ2VyKHNlbGYub25CZWZvcmVGb290ZXJSb3dDZWxsRGVzdHJveSwge1xyXG4gICAgICAgICAgICAgICAgXCJub2RlXCI6IHRoaXMsXHJcbiAgICAgICAgICAgICAgICBcImNvbHVtblwiOiBjb2x1bW5EZWZcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgJGZvb3RlclJvdy5lbXB0eSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbHVtbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgbSA9IGNvbHVtbnNbaV07XHJcblxyXG4gICAgICAgIHZhciBoZWFkZXIgPSAkKFwiPGRpdiBjbGFzcz0ndWktc3RhdGUtZGVmYXVsdCBzbGljay1oZWFkZXItY29sdW1uJyAvPlwiKVxyXG4gICAgICAgICAgICAuaHRtbChcIjxzcGFuIGNsYXNzPSdzbGljay1jb2x1bW4tbmFtZSc+XCIgKyBtLm5hbWUgKyBcIjwvc3Bhbj5cIilcclxuICAgICAgICAgICAgLndpZHRoKG0ud2lkdGggLSBoZWFkZXJDb2x1bW5XaWR0aERpZmYpXHJcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgXCJcIiArIHVpZCArIG0uaWQpXHJcbiAgICAgICAgICAgIC5hdHRyKFwidGl0bGVcIiwgbS50b29sVGlwIHx8IFwiXCIpXHJcbiAgICAgICAgICAgIC5kYXRhKFwiY29sdW1uXCIsIG0pXHJcbiAgICAgICAgICAgIC5hZGRDbGFzcyhtLmhlYWRlckNzc0NsYXNzIHx8IFwiXCIpXHJcbiAgICAgICAgICAgIC5hcHBlbmRUbygkaGVhZGVycyk7XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLmVuYWJsZUNvbHVtblJlb3JkZXIgfHwgbS5zb3J0YWJsZSkge1xyXG4gICAgICAgICAgaGVhZGVyXHJcbiAgICAgICAgICAgIC5vbignbW91c2VlbnRlcicsIG9uTW91c2VFbnRlcilcclxuICAgICAgICAgICAgLm9uKCdtb3VzZWxlYXZlJywgb25Nb3VzZUxlYXZlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChtLnNvcnRhYmxlKSB7XHJcbiAgICAgICAgICBoZWFkZXIuYWRkQ2xhc3MoXCJzbGljay1oZWFkZXItc29ydGFibGVcIik7XHJcbiAgICAgICAgICBoZWFkZXIuYXBwZW5kKFwiPHNwYW4gY2xhc3M9J3NsaWNrLXNvcnQtaW5kaWNhdG9yXCIgXHJcbiAgICAgICAgICAgICsgKG9wdGlvbnMubnVtYmVyZWRNdWx0aUNvbHVtblNvcnQgJiYgIW9wdGlvbnMuc29ydENvbE51bWJlckluU2VwYXJhdGVTcGFuID8gXCIgc2xpY2stc29ydC1pbmRpY2F0b3ItbnVtYmVyZWRcIiA6IFwiXCIgKSArIFwiJyAvPlwiKTtcclxuICAgICAgICAgIGlmIChvcHRpb25zLm51bWJlcmVkTXVsdGlDb2x1bW5Tb3J0ICYmIG9wdGlvbnMuc29ydENvbE51bWJlckluU2VwYXJhdGVTcGFuKSB7IGhlYWRlci5hcHBlbmQoXCI8c3BhbiBjbGFzcz0nc2xpY2stc29ydC1pbmRpY2F0b3ItbnVtYmVyZWQnIC8+XCIpOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0cmlnZ2VyKHNlbGYub25IZWFkZXJDZWxsUmVuZGVyZWQsIHtcclxuICAgICAgICAgIFwibm9kZVwiOiBoZWFkZXJbMF0sXHJcbiAgICAgICAgICBcImNvbHVtblwiOiBtLFxyXG4gICAgICAgICAgXCJncmlkXCI6IHNlbGZcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMuc2hvd0hlYWRlclJvdykge1xyXG4gICAgICAgICAgdmFyIGhlYWRlclJvd0NlbGwgPSAkKFwiPGRpdiBjbGFzcz0ndWktc3RhdGUtZGVmYXVsdCBzbGljay1oZWFkZXJyb3ctY29sdW1uIGxcIiArIGkgKyBcIiByXCIgKyBpICsgXCInPjwvZGl2PlwiKVxyXG4gICAgICAgICAgICAgIC5kYXRhKFwiY29sdW1uXCIsIG0pXHJcbiAgICAgICAgICAgICAgLmFwcGVuZFRvKCRoZWFkZXJSb3cpO1xyXG5cclxuICAgICAgICAgIHRyaWdnZXIoc2VsZi5vbkhlYWRlclJvd0NlbGxSZW5kZXJlZCwge1xyXG4gICAgICAgICAgICBcIm5vZGVcIjogaGVhZGVyUm93Q2VsbFswXSxcclxuICAgICAgICAgICAgXCJjb2x1bW5cIjogbSxcclxuICAgICAgICAgICAgXCJncmlkXCI6IHNlbGZcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0aW9ucy5jcmVhdGVGb290ZXJSb3cgJiYgb3B0aW9ucy5zaG93Rm9vdGVyUm93KSB7XHJcbiAgICAgICAgICB2YXIgZm9vdGVyUm93Q2VsbCA9ICQoXCI8ZGl2IGNsYXNzPSd1aS1zdGF0ZS1kZWZhdWx0IHNsaWNrLWZvb3RlcnJvdy1jb2x1bW4gbFwiICsgaSAgICsgXCIgclwiICsgaSArIFwiJz48L2Rpdj5cIilcclxuICAgICAgICAgICAgICAuZGF0YShcImNvbHVtblwiLCBtKVxyXG4gICAgICAgICAgICAgIC5hcHBlbmRUbygkZm9vdGVyUm93KTtcclxuXHJcbiAgICAgICAgICB0cmlnZ2VyKHNlbGYub25Gb290ZXJSb3dDZWxsUmVuZGVyZWQsIHtcclxuICAgICAgICAgICAgXCJub2RlXCI6IGZvb3RlclJvd0NlbGxbMF0sXHJcbiAgICAgICAgICAgIFwiY29sdW1uXCI6IG1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgc2V0U29ydENvbHVtbnMoc29ydENvbHVtbnMpO1xyXG4gICAgICBzZXR1cENvbHVtblJlc2l6ZSgpO1xyXG4gICAgICBpZiAob3B0aW9ucy5lbmFibGVDb2x1bW5SZW9yZGVyKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmVuYWJsZUNvbHVtblJlb3JkZXIgPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBvcHRpb25zLmVuYWJsZUNvbHVtblJlb3JkZXIoc2VsZiwgJGhlYWRlcnMsIGhlYWRlckNvbHVtbldpZHRoRGlmZiwgc2V0Q29sdW1ucywgc2V0dXBDb2x1bW5SZXNpemUsIGNvbHVtbnMsIGdldENvbHVtbkluZGV4LCB1aWQsIHRyaWdnZXIpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHNldHVwQ29sdW1uUmVvcmRlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBzZXR1cENvbHVtblNvcnQoKSB7XHJcbiAgICAgICRoZWFkZXJzLmNsaWNrKGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgaWYgKGNvbHVtblJlc2l6ZURyYWdnaW5nKSByZXR1cm47XHJcbiAgICAgICAgLy8gdGVtcG9yYXJ5IHdvcmthcm91bmQgZm9yIGEgYnVnIGluIGpRdWVyeSAxLjcuMSAoaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTEzMjgpXHJcbiAgICAgICAgZS5tZXRhS2V5ID0gZS5tZXRhS2V5IHx8IGUuY3RybEtleTtcclxuXHJcbiAgICAgICAgaWYgKCQoZS50YXJnZXQpLmhhc0NsYXNzKFwic2xpY2stcmVzaXphYmxlLWhhbmRsZVwiKSkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyICRjb2wgPSAkKGUudGFyZ2V0KS5jbG9zZXN0KFwiLnNsaWNrLWhlYWRlci1jb2x1bW5cIik7XHJcbiAgICAgICAgaWYgKCEkY29sLmxlbmd0aCkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGNvbHVtbiA9ICRjb2wuZGF0YShcImNvbHVtblwiKTtcclxuICAgICAgICBpZiAoY29sdW1uLnNvcnRhYmxlKSB7XHJcbiAgICAgICAgICBpZiAoIWdldEVkaXRvckxvY2soKS5jb21taXRDdXJyZW50RWRpdCgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB2YXIgc29ydENvbHVtbiA9IG51bGw7XHJcbiAgICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgICBmb3IgKDsgaSA8IHNvcnRDb2x1bW5zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChzb3J0Q29sdW1uc1tpXS5jb2x1bW5JZCA9PSBjb2x1bW4uaWQpIHtcclxuICAgICAgICAgICAgICBzb3J0Q29sdW1uID0gc29ydENvbHVtbnNbaV07XHJcbiAgICAgICAgICAgICAgc29ydENvbHVtbi5zb3J0QXNjID0gIXNvcnRDb2x1bW4uc29ydEFzYztcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdmFyIGhhZFNvcnRDb2wgPSAhIXNvcnRDb2x1bW47XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGlmIChvcHRpb25zLnRyaXN0YXRlTXVsdGlDb2x1bW5Tb3J0KSB7XHJcbiAgICAgICAgICAgICAgaWYgKCFzb3J0Q29sdW1uKSB7IFxyXG4gICAgICAgICAgICAgICAgc29ydENvbHVtbiA9IHsgY29sdW1uSWQ6IGNvbHVtbi5pZCwgc29ydEFzYzogY29sdW1uLmRlZmF1bHRTb3J0QXNjIH07IFxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBpZiAoaGFkU29ydENvbCAmJiBzb3J0Q29sdW1uLnNvcnRBc2MpIHtcclxuICAgICAgICAgICAgICAgIC8vIHRocmVlIHN0YXRlOiByZW1vdmUgc29ydCByYXRoZXIgdGhhbiBnbyBiYWNrIHRvIEFTQ1xyXG4gICAgICAgICAgICAgICAgc29ydENvbHVtbnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgc29ydENvbHVtbiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGlmICghb3B0aW9ucy5tdWx0aUNvbHVtblNvcnQpIHsgc29ydENvbHVtbnMgPSBbXTsgfVxyXG4gICAgICAgICAgICAgIGlmIChzb3J0Q29sdW1uICYmICghaGFkU29ydENvbCB8fCAhb3B0aW9ucy5tdWx0aUNvbHVtblNvcnQpKSB7IFxyXG4gICAgICAgICAgICAgICAgc29ydENvbHVtbnMucHVzaChzb3J0Q29sdW1uKTsgXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAvLyBsZWdhY3kgYmVoYXZpb3VyXHJcbiAgICAgICAgICAgICAgaWYgKGUubWV0YUtleSAmJiBvcHRpb25zLm11bHRpQ29sdW1uU29ydCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNvcnRDb2x1bW4pIHtcclxuICAgICAgICAgICAgICAgICAgc29ydENvbHVtbnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICgoIWUuc2hpZnRLZXkgJiYgIWUubWV0YUtleSkgfHwgIW9wdGlvbnMubXVsdGlDb2x1bW5Tb3J0KSB7XHJcbiAgICAgICAgICAgICAgICAgIHNvcnRDb2x1bW5zID0gW107XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFzb3J0Q29sdW1uKSB7XHJcbiAgICAgICAgICAgICAgICAgIHNvcnRDb2x1bW4gPSB7IGNvbHVtbklkOiBjb2x1bW4uaWQsIHNvcnRBc2M6IGNvbHVtbi5kZWZhdWx0U29ydEFzYyB9O1xyXG4gICAgICAgICAgICAgICAgICBzb3J0Q29sdW1ucy5wdXNoKHNvcnRDb2x1bW4pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3J0Q29sdW1ucy5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICBzb3J0Q29sdW1ucy5wdXNoKHNvcnRDb2x1bW4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBzZXRTb3J0Q29sdW1ucyhzb3J0Q29sdW1ucyk7XHJcblxyXG4gICAgICAgICAgaWYgKCFvcHRpb25zLm11bHRpQ29sdW1uU29ydCkge1xyXG4gICAgICAgICAgICB0cmlnZ2VyKHNlbGYub25Tb3J0LCB7XHJcbiAgICAgICAgICAgICAgbXVsdGlDb2x1bW5Tb3J0OiBmYWxzZSxcclxuICAgICAgICAgICAgICBzb3J0Q29sOiAoc29ydENvbHVtbnMubGVuZ3RoID4gMCA/IGNvbHVtbiA6IG51bGwpLFxyXG4gICAgICAgICAgICAgIHNvcnRBc2M6IChzb3J0Q29sdW1ucy5sZW5ndGggPiAwID8gc29ydENvbHVtbnNbMF0uc29ydEFzYyA6IHRydWUpLFxyXG4gICAgICAgICAgICAgIGdyaWQ6IHNlbGZ9LCBlKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRyaWdnZXIoc2VsZi5vblNvcnQsIHtcclxuICAgICAgICAgICAgICBtdWx0aUNvbHVtblNvcnQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgc29ydENvbHM6ICQubWFwKHNvcnRDb2x1bW5zLCBmdW5jdGlvbihjb2wpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7c29ydENvbDogY29sdW1uc1tnZXRDb2x1bW5JbmRleChjb2wuY29sdW1uSWQpXSwgc29ydEFzYzogY29sLnNvcnRBc2MgfTtcclxuICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICBncmlkOiBzZWxmfSwgZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzZXR1cENvbHVtblJlb3JkZXIoKSB7XHJcbiAgICAgICRoZWFkZXJzLmZpbHRlcihcIjp1aS1zb3J0YWJsZVwiKS5zb3J0YWJsZShcImRlc3Ryb3lcIik7XHJcbiAgICAgICRoZWFkZXJzLnNvcnRhYmxlKHtcclxuICAgICAgICBjb250YWlubWVudDogXCJwYXJlbnRcIixcclxuICAgICAgICBkaXN0YW5jZTogMyxcclxuICAgICAgICBheGlzOiBcInhcIixcclxuICAgICAgICBjdXJzb3I6IFwiZGVmYXVsdFwiLFxyXG4gICAgICAgIHRvbGVyYW5jZTogXCJpbnRlcnNlY3Rpb25cIixcclxuICAgICAgICBoZWxwZXI6IFwiY2xvbmVcIixcclxuICAgICAgICBwbGFjZWhvbGRlcjogXCJzbGljay1zb3J0YWJsZS1wbGFjZWhvbGRlciB1aS1zdGF0ZS1kZWZhdWx0IHNsaWNrLWhlYWRlci1jb2x1bW5cIixcclxuICAgICAgICBzdGFydDogZnVuY3Rpb24gKGUsIHVpKSB7XHJcbiAgICAgICAgICB1aS5wbGFjZWhvbGRlci53aWR0aCh1aS5oZWxwZXIub3V0ZXJXaWR0aCgpIC0gaGVhZGVyQ29sdW1uV2lkdGhEaWZmKTtcclxuICAgICAgICAgICQodWkuaGVscGVyKS5hZGRDbGFzcyhcInNsaWNrLWhlYWRlci1jb2x1bW4tYWN0aXZlXCIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYmVmb3JlU3RvcDogZnVuY3Rpb24gKGUsIHVpKSB7XHJcbiAgICAgICAgICAkKHVpLmhlbHBlcikucmVtb3ZlQ2xhc3MoXCJzbGljay1oZWFkZXItY29sdW1uLWFjdGl2ZVwiKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHN0b3A6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICBpZiAoIWdldEVkaXRvckxvY2soKS5jb21taXRDdXJyZW50RWRpdCgpKSB7XHJcbiAgICAgICAgICAgICQodGhpcykuc29ydGFibGUoXCJjYW5jZWxcIik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB2YXIgcmVvcmRlcmVkSWRzID0gJGhlYWRlcnMuc29ydGFibGUoXCJ0b0FycmF5XCIpO1xyXG4gICAgICAgICAgdmFyIHJlb3JkZXJlZENvbHVtbnMgPSBbXTtcclxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVvcmRlcmVkSWRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJlb3JkZXJlZENvbHVtbnMucHVzaChjb2x1bW5zW2dldENvbHVtbkluZGV4KHJlb3JkZXJlZElkc1tpXS5yZXBsYWNlKHVpZCwgXCJcIikpXSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBzZXRDb2x1bW5zKHJlb3JkZXJlZENvbHVtbnMpO1xyXG5cclxuICAgICAgICAgIHRyaWdnZXIoc2VsZi5vbkNvbHVtbnNSZW9yZGVyZWQsIHtncmlkOiBzZWxmfSk7XHJcbiAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgc2V0dXBDb2x1bW5SZXNpemUoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNldHVwQ29sdW1uUmVzaXplKCkge1xyXG4gICAgICB2YXIgJGNvbCwgaiwgYywgcGFnZVgsIGNvbHVtbkVsZW1lbnRzLCBtaW5QYWdlWCwgbWF4UGFnZVgsIGZpcnN0UmVzaXphYmxlLCBsYXN0UmVzaXphYmxlO1xyXG4gICAgICBjb2x1bW5FbGVtZW50cyA9ICRoZWFkZXJzLmNoaWxkcmVuKCk7XHJcbiAgICAgIGNvbHVtbkVsZW1lbnRzLmZpbmQoXCIuc2xpY2stcmVzaXphYmxlLWhhbmRsZVwiKS5yZW1vdmUoKTtcclxuICAgICAgY29sdW1uRWxlbWVudHMuZWFjaChmdW5jdGlvbiAoaSwgZSkge1xyXG4gICAgICAgIGlmIChpID49IGNvbHVtbnMubGVuZ3RoKSB7IHJldHVybjsgfVxyXG4gICAgICAgIGlmIChjb2x1bW5zW2ldLnJlc2l6YWJsZSkge1xyXG4gICAgICAgICAgaWYgKGZpcnN0UmVzaXphYmxlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgZmlyc3RSZXNpemFibGUgPSBpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgbGFzdFJlc2l6YWJsZSA9IGk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgaWYgKGZpcnN0UmVzaXphYmxlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgY29sdW1uRWxlbWVudHMuZWFjaChmdW5jdGlvbiAoaSwgZSkge1xyXG4gICAgICAgIGlmIChpID49IGNvbHVtbnMubGVuZ3RoKSB7IHJldHVybjsgfVxyXG4gICAgICAgIGlmIChpIDwgZmlyc3RSZXNpemFibGUgfHwgKG9wdGlvbnMuZm9yY2VGaXRDb2x1bW5zICYmIGkgPj0gbGFzdFJlc2l6YWJsZSkpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgJGNvbCA9ICQoZSk7XHJcbiAgICAgICAgJChcIjxkaXYgY2xhc3M9J3NsaWNrLXJlc2l6YWJsZS1oYW5kbGUnIC8+XCIpXHJcbiAgICAgICAgICAgIC5hcHBlbmRUbyhlKVxyXG4gICAgICAgICAgICAub24oXCJkcmFnc3RhcnRcIiwgZnVuY3Rpb24gKGUsIGRkKSB7XHJcbiAgICAgICAgICAgICAgaWYgKCFnZXRFZGl0b3JMb2NrKCkuY29tbWl0Q3VycmVudEVkaXQoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBwYWdlWCA9IGUucGFnZVg7XHJcbiAgICAgICAgICAgICAgJCh0aGlzKS5wYXJlbnQoKS5hZGRDbGFzcyhcInNsaWNrLWhlYWRlci1jb2x1bW4tYWN0aXZlXCIpO1xyXG4gICAgICAgICAgICAgIHZhciBzaHJpbmtMZWV3YXlPblJpZ2h0ID0gbnVsbCwgc3RyZXRjaExlZXdheU9uUmlnaHQgPSBudWxsO1xyXG4gICAgICAgICAgICAgIC8vIGxvY2sgZWFjaCBjb2x1bW4ncyB3aWR0aCBvcHRpb24gdG8gY3VycmVudCB3aWR0aFxyXG4gICAgICAgICAgICAgIGNvbHVtbkVsZW1lbnRzLmVhY2goZnVuY3Rpb24gKGksIGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpID49IGNvbHVtbnMubGVuZ3RoKSB7IHJldHVybjsgfVxyXG4gICAgICAgICAgICAgICAgY29sdW1uc1tpXS5wcmV2aW91c1dpZHRoID0gJChlKS5vdXRlcldpZHRoKCk7XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZm9yY2VGaXRDb2x1bW5zKSB7XHJcbiAgICAgICAgICAgICAgICBzaHJpbmtMZWV3YXlPblJpZ2h0ID0gMDtcclxuICAgICAgICAgICAgICAgIHN0cmV0Y2hMZWV3YXlPblJpZ2h0ID0gMDtcclxuICAgICAgICAgICAgICAgIC8vIGNvbHVtcyBvbiByaWdodCBhZmZlY3QgbWF4UGFnZVgvbWluUGFnZVhcclxuICAgICAgICAgICAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgY29sdW1ucy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICBjID0gY29sdW1uc1tqXTtcclxuICAgICAgICAgICAgICAgICAgaWYgKGMucmVzaXphYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmV0Y2hMZWV3YXlPblJpZ2h0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoYy5tYXhXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJldGNoTGVld2F5T25SaWdodCArPSBjLm1heFdpZHRoIC0gYy5wcmV2aW91c1dpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyZXRjaExlZXdheU9uUmlnaHQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzaHJpbmtMZWV3YXlPblJpZ2h0ICs9IGMucHJldmlvdXNXaWR0aCAtIE1hdGgubWF4KGMubWluV2lkdGggfHwgMCwgYWJzb2x1dGVDb2x1bW5NaW5XaWR0aCk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgdmFyIHNocmlua0xlZXdheU9uTGVmdCA9IDAsIHN0cmV0Y2hMZWV3YXlPbkxlZnQgPSAwO1xyXG4gICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPD0gaTsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjb2x1bW5zIG9uIGxlZnQgb25seSBhZmZlY3QgbWluUGFnZVhcclxuICAgICAgICAgICAgICAgIGMgPSBjb2x1bW5zW2pdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGMucmVzaXphYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChzdHJldGNoTGVld2F5T25MZWZ0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMubWF4V2lkdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHN0cmV0Y2hMZWV3YXlPbkxlZnQgKz0gYy5tYXhXaWR0aCAtIGMucHJldmlvdXNXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgc3RyZXRjaExlZXdheU9uTGVmdCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIHNocmlua0xlZXdheU9uTGVmdCArPSBjLnByZXZpb3VzV2lkdGggLSBNYXRoLm1heChjLm1pbldpZHRoIHx8IDAsIGFic29sdXRlQ29sdW1uTWluV2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBpZiAoc2hyaW5rTGVld2F5T25SaWdodCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgc2hyaW5rTGVld2F5T25SaWdodCA9IDEwMDAwMDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgaWYgKHNocmlua0xlZXdheU9uTGVmdCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgc2hyaW5rTGVld2F5T25MZWZ0ID0gMTAwMDAwO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBpZiAoc3RyZXRjaExlZXdheU9uUmlnaHQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHN0cmV0Y2hMZWV3YXlPblJpZ2h0ID0gMTAwMDAwO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBpZiAoc3RyZXRjaExlZXdheU9uTGVmdCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgc3RyZXRjaExlZXdheU9uTGVmdCA9IDEwMDAwMDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgbWF4UGFnZVggPSBwYWdlWCArIE1hdGgubWluKHNocmlua0xlZXdheU9uUmlnaHQsIHN0cmV0Y2hMZWV3YXlPbkxlZnQpO1xyXG4gICAgICAgICAgICAgIG1pblBhZ2VYID0gcGFnZVggLSBNYXRoLm1pbihzaHJpbmtMZWV3YXlPbkxlZnQsIHN0cmV0Y2hMZWV3YXlPblJpZ2h0KTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLm9uKFwiZHJhZ1wiLCBmdW5jdGlvbiAoZSwgZGQpIHtcclxuICAgICAgICAgICAgICBjb2x1bW5SZXNpemVEcmFnZ2luZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgdmFyIGFjdHVhbE1pbldpZHRoLCBkID0gTWF0aC5taW4obWF4UGFnZVgsIE1hdGgubWF4KG1pblBhZ2VYLCBlLnBhZ2VYKSkgLSBwYWdlWCwgeDtcclxuICAgICAgICAgICAgICBpZiAoZCA8IDApIHsgLy8gc2hyaW5rIGNvbHVtblxyXG4gICAgICAgICAgICAgICAgeCA9IGQ7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGogPSBpOyBqID49IDA7IGotLSkge1xyXG4gICAgICAgICAgICAgICAgICBjID0gY29sdW1uc1tqXTtcclxuICAgICAgICAgICAgICAgICAgaWYgKGMucmVzaXphYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0dWFsTWluV2lkdGggPSBNYXRoLm1heChjLm1pbldpZHRoIHx8IDAsIGFic29sdXRlQ29sdW1uTWluV2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh4ICYmIGMucHJldmlvdXNXaWR0aCArIHggPCBhY3R1YWxNaW5XaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgeCArPSBjLnByZXZpb3VzV2lkdGggLSBhY3R1YWxNaW5XaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgIGMud2lkdGggPSBhY3R1YWxNaW5XaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgYy53aWR0aCA9IGMucHJldmlvdXNXaWR0aCArIHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICB4ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5mb3JjZUZpdENvbHVtbnMpIHtcclxuICAgICAgICAgICAgICAgICAgeCA9IC1kO1xyXG4gICAgICAgICAgICAgICAgICBmb3IgKGogPSBpICsgMTsgaiA8IGNvbHVtbnMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjID0gY29sdW1uc1tqXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYy5yZXNpemFibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGlmICh4ICYmIGMubWF4V2lkdGggJiYgKGMubWF4V2lkdGggLSBjLnByZXZpb3VzV2lkdGggPCB4KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4IC09IGMubWF4V2lkdGggLSBjLnByZXZpb3VzV2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGMud2lkdGggPSBjLm1heFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYy53aWR0aCA9IGMucHJldmlvdXNXaWR0aCArIHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0gZWxzZSB7IC8vIHN0cmV0Y2ggY29sdW1uXHJcbiAgICAgICAgICAgICAgICB4ID0gZDtcclxuICAgICAgICAgICAgICAgIGZvciAoaiA9IGk7IGogPj0gMDsgai0tKSB7XHJcbiAgICAgICAgICAgICAgICAgIGMgPSBjb2x1bW5zW2pdO1xyXG4gICAgICAgICAgICAgICAgICBpZiAoYy5yZXNpemFibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeCAmJiBjLm1heFdpZHRoICYmIChjLm1heFdpZHRoIC0gYy5wcmV2aW91c1dpZHRoIDwgeCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHggLT0gYy5tYXhXaWR0aCAtIGMucHJldmlvdXNXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgIGMud2lkdGggPSBjLm1heFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBjLndpZHRoID0gYy5wcmV2aW91c1dpZHRoICsgeDtcclxuICAgICAgICAgICAgICAgICAgICAgIHggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmZvcmNlRml0Q29sdW1ucykge1xyXG4gICAgICAgICAgICAgICAgICB4ID0gLWQ7XHJcbiAgICAgICAgICAgICAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgY29sdW1ucy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGMgPSBjb2x1bW5zW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjLnJlc2l6YWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgYWN0dWFsTWluV2lkdGggPSBNYXRoLm1heChjLm1pbldpZHRoIHx8IDAsIGFic29sdXRlQ29sdW1uTWluV2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHggJiYgYy5wcmV2aW91c1dpZHRoICsgeCA8IGFjdHVhbE1pbldpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHggKz0gYy5wcmV2aW91c1dpZHRoIC0gYWN0dWFsTWluV2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGMud2lkdGggPSBhY3R1YWxNaW5XaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGMud2lkdGggPSBjLnByZXZpb3VzV2lkdGggKyB4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgYXBwbHlDb2x1bW5IZWFkZXJXaWR0aHMoKTtcclxuICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zeW5jQ29sdW1uQ2VsbFJlc2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgYXBwbHlDb2x1bW5XaWR0aHMoKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5vbihcImRyYWdlbmRcIiwgZnVuY3Rpb24gKGUsIGRkKSB7XHJcbiAgICAgICAgICAgICAgdmFyIG5ld1dpZHRoO1xyXG4gICAgICAgICAgICAgICQodGhpcykucGFyZW50KCkucmVtb3ZlQ2xhc3MoXCJzbGljay1oZWFkZXItY29sdW1uLWFjdGl2ZVwiKTtcclxuICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY29sdW1ucy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgYyA9IGNvbHVtbnNbal07XHJcbiAgICAgICAgICAgICAgICBuZXdXaWR0aCA9ICQoY29sdW1uRWxlbWVudHNbal0pLm91dGVyV2lkdGgoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoYy5wcmV2aW91c1dpZHRoICE9PSBuZXdXaWR0aCAmJiBjLnJlcmVuZGVyT25SZXNpemUpIHtcclxuICAgICAgICAgICAgICAgICAgaW52YWxpZGF0ZUFsbFJvd3MoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgdXBkYXRlQ2FudmFzV2lkdGgodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgcmVuZGVyKCk7XHJcbiAgICAgICAgICAgICAgdHJpZ2dlcihzZWxmLm9uQ29sdW1uc1Jlc2l6ZWQsIHtncmlkOiBzZWxmfSk7XHJcbiAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IGNvbHVtblJlc2l6ZURyYWdnaW5nID0gZmFsc2U7IH0sIDMwMCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRWQm94RGVsdGEoJGVsKSB7XHJcbiAgICAgIHZhciBwID0gW1wiYm9yZGVyVG9wV2lkdGhcIiwgXCJib3JkZXJCb3R0b21XaWR0aFwiLCBcInBhZGRpbmdUb3BcIiwgXCJwYWRkaW5nQm90dG9tXCJdO1xyXG4gICAgICB2YXIgZGVsdGEgPSAwO1xyXG4gICAgICAkLmVhY2gocCwgZnVuY3Rpb24gKG4sIHZhbCkge1xyXG4gICAgICAgIGRlbHRhICs9IHBhcnNlRmxvYXQoJGVsLmNzcyh2YWwpKSB8fCAwO1xyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIGRlbHRhO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1lYXN1cmVDZWxsUGFkZGluZ0FuZEJvcmRlcigpIHtcclxuICAgICAgdmFyIGVsO1xyXG4gICAgICB2YXIgaCA9IFtcImJvcmRlckxlZnRXaWR0aFwiLCBcImJvcmRlclJpZ2h0V2lkdGhcIiwgXCJwYWRkaW5nTGVmdFwiLCBcInBhZGRpbmdSaWdodFwiXTtcclxuICAgICAgdmFyIHYgPSBbXCJib3JkZXJUb3BXaWR0aFwiLCBcImJvcmRlckJvdHRvbVdpZHRoXCIsIFwicGFkZGluZ1RvcFwiLCBcInBhZGRpbmdCb3R0b21cIl07XHJcblxyXG4gICAgICAvLyBqcXVlcnkgcHJpb3IgdG8gdmVyc2lvbiAxLjggaGFuZGxlcyAud2lkdGggc2V0dGVyL2dldHRlciBhcyBhIGRpcmVjdCBjc3Mgd3JpdGUvcmVhZFxyXG4gICAgICAvLyBqcXVlcnkgMS44IGNoYW5nZWQgLndpZHRoIHRvIHJlYWQgdGhlIHRydWUgaW5uZXIgZWxlbWVudCB3aWR0aCBpZiBib3gtc2l6aW5nIGlzIHNldCB0byBib3JkZXItYm94LCBhbmQgaW50cm9kdWNlZCBhIHNldHRlciBmb3IgLm91dGVyV2lkdGhcclxuICAgICAgLy8gc28gZm9yIGVxdWl2YWxlbnQgZnVuY3Rpb25hbGl0eSwgcHJpb3IgdG8gMS44IHVzZSAud2lkdGgsIGFuZCBhZnRlciB1c2UgLm91dGVyV2lkdGhcclxuICAgICAgdmFyIHZlckFycmF5ID0gJC5mbi5qcXVlcnkuc3BsaXQoJy4nKTtcclxuICAgICAgalF1ZXJ5TmV3V2lkdGhCZWhhdmlvdXIgPSAodmVyQXJyYXlbMF09PTEgJiYgdmVyQXJyYXlbMV0+PTgpIHx8ICB2ZXJBcnJheVswXSA+PTI7XHJcblxyXG4gICAgICBlbCA9ICQoXCI8ZGl2IGNsYXNzPSd1aS1zdGF0ZS1kZWZhdWx0IHNsaWNrLWhlYWRlci1jb2x1bW4nIHN0eWxlPSd2aXNpYmlsaXR5OmhpZGRlbic+LTwvZGl2PlwiKS5hcHBlbmRUbygkaGVhZGVycyk7XHJcbiAgICAgIGhlYWRlckNvbHVtbldpZHRoRGlmZiA9IGhlYWRlckNvbHVtbkhlaWdodERpZmYgPSAwO1xyXG4gICAgICBpZiAoZWwuY3NzKFwiYm94LXNpemluZ1wiKSAhPSBcImJvcmRlci1ib3hcIiAmJiBlbC5jc3MoXCItbW96LWJveC1zaXppbmdcIikgIT0gXCJib3JkZXItYm94XCIgJiYgZWwuY3NzKFwiLXdlYmtpdC1ib3gtc2l6aW5nXCIpICE9IFwiYm9yZGVyLWJveFwiKSB7XHJcbiAgICAgICAgJC5lYWNoKGgsIGZ1bmN0aW9uIChuLCB2YWwpIHtcclxuICAgICAgICAgIGhlYWRlckNvbHVtbldpZHRoRGlmZiArPSBwYXJzZUZsb2F0KGVsLmNzcyh2YWwpKSB8fCAwO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgICQuZWFjaCh2LCBmdW5jdGlvbiAobiwgdmFsKSB7XHJcbiAgICAgICAgICBoZWFkZXJDb2x1bW5IZWlnaHREaWZmICs9IHBhcnNlRmxvYXQoZWwuY3NzKHZhbCkpIHx8IDA7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgZWwucmVtb3ZlKCk7XHJcblxyXG4gICAgICB2YXIgciA9ICQoXCI8ZGl2IGNsYXNzPSdzbGljay1yb3cnIC8+XCIpLmFwcGVuZFRvKCRjYW52YXMpO1xyXG4gICAgICBlbCA9ICQoXCI8ZGl2IGNsYXNzPSdzbGljay1jZWxsJyBpZD0nJyBzdHlsZT0ndmlzaWJpbGl0eTpoaWRkZW4nPi08L2Rpdj5cIikuYXBwZW5kVG8ocik7XHJcbiAgICAgIGNlbGxXaWR0aERpZmYgPSBjZWxsSGVpZ2h0RGlmZiA9IDA7XHJcbiAgICAgIGlmIChlbC5jc3MoXCJib3gtc2l6aW5nXCIpICE9IFwiYm9yZGVyLWJveFwiICYmIGVsLmNzcyhcIi1tb3otYm94LXNpemluZ1wiKSAhPSBcImJvcmRlci1ib3hcIiAmJiBlbC5jc3MoXCItd2Via2l0LWJveC1zaXppbmdcIikgIT0gXCJib3JkZXItYm94XCIpIHtcclxuICAgICAgICAkLmVhY2goaCwgZnVuY3Rpb24gKG4sIHZhbCkge1xyXG4gICAgICAgICAgY2VsbFdpZHRoRGlmZiArPSBwYXJzZUZsb2F0KGVsLmNzcyh2YWwpKSB8fCAwO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgICQuZWFjaCh2LCBmdW5jdGlvbiAobiwgdmFsKSB7XHJcbiAgICAgICAgICBjZWxsSGVpZ2h0RGlmZiArPSBwYXJzZUZsb2F0KGVsLmNzcyh2YWwpKSB8fCAwO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIHIucmVtb3ZlKCk7XHJcblxyXG4gICAgICBhYnNvbHV0ZUNvbHVtbk1pbldpZHRoID0gTWF0aC5tYXgoaGVhZGVyQ29sdW1uV2lkdGhEaWZmLCBjZWxsV2lkdGhEaWZmKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVDc3NSdWxlcygpIHtcclxuICAgICAgJHN0eWxlID0gJChcIjxzdHlsZSB0eXBlPSd0ZXh0L2NzcycgcmVsPSdzdHlsZXNoZWV0JyAvPlwiKS5hcHBlbmRUbygkKFwiaGVhZFwiKSk7XHJcbiAgICAgIHZhciByb3dIZWlnaHQgPSAob3B0aW9ucy5yb3dIZWlnaHQgLSBjZWxsSGVpZ2h0RGlmZik7XHJcbiAgICAgIHZhciBydWxlcyA9IFtcclxuICAgICAgICBcIi5cIiArIHVpZCArIFwiIC5zbGljay1oZWFkZXItY29sdW1uIHsgbGVmdDogMTAwMHB4OyB9XCIsXHJcbiAgICAgICAgXCIuXCIgKyB1aWQgKyBcIiAuc2xpY2stdG9wLXBhbmVsIHsgaGVpZ2h0OlwiICsgb3B0aW9ucy50b3BQYW5lbEhlaWdodCArIFwicHg7IH1cIixcclxuICAgICAgICBcIi5cIiArIHVpZCArIFwiIC5zbGljay1wcmVoZWFkZXItcGFuZWwgeyBoZWlnaHQ6XCIgKyBvcHRpb25zLnByZUhlYWRlclBhbmVsSGVpZ2h0ICsgXCJweDsgfVwiLFxyXG4gICAgICAgIFwiLlwiICsgdWlkICsgXCIgLnNsaWNrLWhlYWRlcnJvdy1jb2x1bW5zIHsgaGVpZ2h0OlwiICsgb3B0aW9ucy5oZWFkZXJSb3dIZWlnaHQgKyBcInB4OyB9XCIsXHJcbiAgICAgICAgXCIuXCIgKyB1aWQgKyBcIiAuc2xpY2stZm9vdGVycm93LWNvbHVtbnMgeyBoZWlnaHQ6XCIgKyBvcHRpb25zLmZvb3RlclJvd0hlaWdodCArIFwicHg7IH1cIixcclxuICAgICAgICBcIi5cIiArIHVpZCArIFwiIC5zbGljay1jZWxsIHsgaGVpZ2h0OlwiICsgcm93SGVpZ2h0ICsgXCJweDsgfVwiLFxyXG4gICAgICAgIFwiLlwiICsgdWlkICsgXCIgLnNsaWNrLXJvdyB7IGhlaWdodDpcIiArIG9wdGlvbnMucm93SGVpZ2h0ICsgXCJweDsgfVwiXHJcbiAgICAgIF07XHJcblxyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbHVtbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBydWxlcy5wdXNoKFwiLlwiICsgdWlkICsgXCIgLmxcIiArIGkgKyBcIiB7IH1cIik7XHJcbiAgICAgICAgcnVsZXMucHVzaChcIi5cIiArIHVpZCArIFwiIC5yXCIgKyBpICsgXCIgeyB9XCIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoJHN0eWxlWzBdLnN0eWxlU2hlZXQpIHsgLy8gSUVcclxuICAgICAgICAkc3R5bGVbMF0uc3R5bGVTaGVldC5jc3NUZXh0ID0gcnVsZXMuam9pbihcIiBcIik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgJHN0eWxlWzBdLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHJ1bGVzLmpvaW4oXCIgXCIpKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRDb2x1bW5Dc3NSdWxlcyhpZHgpIHtcclxuICAgICAgdmFyIGk7XHJcbiAgICAgIGlmICghc3R5bGVzaGVldCkge1xyXG4gICAgICAgIHZhciBzaGVldHMgPSBkb2N1bWVudC5zdHlsZVNoZWV0cztcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2hlZXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBpZiAoKHNoZWV0c1tpXS5vd25lck5vZGUgfHwgc2hlZXRzW2ldLm93bmluZ0VsZW1lbnQpID09ICRzdHlsZVswXSkge1xyXG4gICAgICAgICAgICBzdHlsZXNoZWV0ID0gc2hlZXRzW2ldO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghc3R5bGVzaGVldCkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgc3R5bGVzaGVldC5cIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBmaW5kIGFuZCBjYWNoZSBjb2x1bW4gQ1NTIHJ1bGVzXHJcbiAgICAgICAgY29sdW1uQ3NzUnVsZXNMID0gW107XHJcbiAgICAgICAgY29sdW1uQ3NzUnVsZXNSID0gW107XHJcbiAgICAgICAgdmFyIGNzc1J1bGVzID0gKHN0eWxlc2hlZXQuY3NzUnVsZXMgfHwgc3R5bGVzaGVldC5ydWxlcyk7XHJcbiAgICAgICAgdmFyIG1hdGNoZXMsIGNvbHVtbklkeDtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY3NzUnVsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIHZhciBzZWxlY3RvciA9IGNzc1J1bGVzW2ldLnNlbGVjdG9yVGV4dDtcclxuICAgICAgICAgIGlmIChtYXRjaGVzID0gL1xcLmxcXGQrLy5leGVjKHNlbGVjdG9yKSkge1xyXG4gICAgICAgICAgICBjb2x1bW5JZHggPSBwYXJzZUludChtYXRjaGVzWzBdLnN1YnN0cigyLCBtYXRjaGVzWzBdLmxlbmd0aCAtIDIpLCAxMCk7XHJcbiAgICAgICAgICAgIGNvbHVtbkNzc1J1bGVzTFtjb2x1bW5JZHhdID0gY3NzUnVsZXNbaV07XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoZXMgPSAvXFwuclxcZCsvLmV4ZWMoc2VsZWN0b3IpKSB7XHJcbiAgICAgICAgICAgIGNvbHVtbklkeCA9IHBhcnNlSW50KG1hdGNoZXNbMF0uc3Vic3RyKDIsIG1hdGNoZXNbMF0ubGVuZ3RoIC0gMiksIDEwKTtcclxuICAgICAgICAgICAgY29sdW1uQ3NzUnVsZXNSW2NvbHVtbklkeF0gPSBjc3NSdWxlc1tpXTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgXCJsZWZ0XCI6IGNvbHVtbkNzc1J1bGVzTFtpZHhdLFxyXG4gICAgICAgIFwicmlnaHRcIjogY29sdW1uQ3NzUnVsZXNSW2lkeF1cclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZW1vdmVDc3NSdWxlcygpIHtcclxuICAgICAgJHN0eWxlLnJlbW92ZSgpO1xyXG4gICAgICBzdHlsZXNoZWV0ID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkZXN0cm95KCkge1xyXG4gICAgICBnZXRFZGl0b3JMb2NrKCkuY2FuY2VsQ3VycmVudEVkaXQoKTtcclxuXHJcbiAgICAgIHRyaWdnZXIoc2VsZi5vbkJlZm9yZURlc3Ryb3ksIHtncmlkOiBzZWxmfSk7XHJcblxyXG4gICAgICB2YXIgaSA9IHBsdWdpbnMubGVuZ3RoO1xyXG4gICAgICB3aGlsZShpLS0pIHtcclxuICAgICAgICB1bnJlZ2lzdGVyUGx1Z2luKHBsdWdpbnNbaV0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAob3B0aW9ucy5lbmFibGVDb2x1bW5SZW9yZGVyKSB7XHJcbiAgICAgICAgICAkaGVhZGVycy5maWx0ZXIoXCI6dWktc29ydGFibGVcIikuc29ydGFibGUoXCJkZXN0cm95XCIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB1bmJpbmRBbmNlc3RvclNjcm9sbEV2ZW50cygpO1xyXG4gICAgICAkY29udGFpbmVyLm9mZihcIi5zbGlja2dyaWRcIik7XHJcbiAgICAgIHJlbW92ZUNzc1J1bGVzKCk7XHJcblxyXG4gICAgICAkY2FudmFzLm9mZihcImRyYWdpbml0IGRyYWdzdGFydCBkcmFnZW5kIGRyYWdcIik7XHJcbiAgICAgICRjb250YWluZXIuZW1wdHkoKS5yZW1vdmVDbGFzcyh1aWQpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbiAgICAvLyBHZW5lcmFsXHJcblxyXG4gICAgZnVuY3Rpb24gdHJpZ2dlcihldnQsIGFyZ3MsIGUpIHtcclxuICAgICAgZSA9IGUgfHwgbmV3IFNsaWNrLkV2ZW50RGF0YSgpO1xyXG4gICAgICBhcmdzID0gYXJncyB8fCB7fTtcclxuICAgICAgYXJncy5ncmlkID0gc2VsZjtcclxuICAgICAgcmV0dXJuIGV2dC5ub3RpZnkoYXJncywgZSwgc2VsZik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0RWRpdG9yTG9jaygpIHtcclxuICAgICAgcmV0dXJuIG9wdGlvbnMuZWRpdG9yTG9jaztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRFZGl0Q29udHJvbGxlcigpIHtcclxuICAgICAgcmV0dXJuIGVkaXRDb250cm9sbGVyO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldENvbHVtbkluZGV4KGlkKSB7XHJcbiAgICAgIHJldHVybiBjb2x1bW5zQnlJZFtpZF07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYXV0b3NpemVDb2x1bW5zKCkge1xyXG4gICAgICB2YXIgaSwgYyxcclxuICAgICAgICAgIHdpZHRocyA9IFtdLFxyXG4gICAgICAgICAgc2hyaW5rTGVld2F5ID0gMCxcclxuICAgICAgICAgIHRvdGFsID0gMCxcclxuICAgICAgICAgIHByZXZUb3RhbCxcclxuICAgICAgICAgIGF2YWlsV2lkdGggPSB2aWV3cG9ydEhhc1ZTY3JvbGwgPyB2aWV3cG9ydFcgLSBzY3JvbGxiYXJEaW1lbnNpb25zLndpZHRoIDogdmlld3BvcnRXO1xyXG5cclxuICAgICAgZm9yIChpID0gMDsgaSA8IGNvbHVtbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjID0gY29sdW1uc1tpXTtcclxuICAgICAgICB3aWR0aHMucHVzaChjLndpZHRoKTtcclxuICAgICAgICB0b3RhbCArPSBjLndpZHRoO1xyXG4gICAgICAgIGlmIChjLnJlc2l6YWJsZSkge1xyXG4gICAgICAgICAgc2hyaW5rTGVld2F5ICs9IGMud2lkdGggLSBNYXRoLm1heChjLm1pbldpZHRoLCBhYnNvbHV0ZUNvbHVtbk1pbldpZHRoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHNocmlua1xyXG4gICAgICBwcmV2VG90YWwgPSB0b3RhbDtcclxuICAgICAgd2hpbGUgKHRvdGFsID4gYXZhaWxXaWR0aCAmJiBzaHJpbmtMZWV3YXkpIHtcclxuICAgICAgICB2YXIgc2hyaW5rUHJvcG9ydGlvbiA9ICh0b3RhbCAtIGF2YWlsV2lkdGgpIC8gc2hyaW5rTGVld2F5O1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb2x1bW5zLmxlbmd0aCAmJiB0b3RhbCA+IGF2YWlsV2lkdGg7IGkrKykge1xyXG4gICAgICAgICAgYyA9IGNvbHVtbnNbaV07XHJcbiAgICAgICAgICB2YXIgd2lkdGggPSB3aWR0aHNbaV07XHJcbiAgICAgICAgICBpZiAoIWMucmVzaXphYmxlIHx8IHdpZHRoIDw9IGMubWluV2lkdGggfHwgd2lkdGggPD0gYWJzb2x1dGVDb2x1bW5NaW5XaWR0aCkge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHZhciBhYnNNaW5XaWR0aCA9IE1hdGgubWF4KGMubWluV2lkdGgsIGFic29sdXRlQ29sdW1uTWluV2lkdGgpO1xyXG4gICAgICAgICAgdmFyIHNocmlua1NpemUgPSBNYXRoLmZsb29yKHNocmlua1Byb3BvcnRpb24gKiAod2lkdGggLSBhYnNNaW5XaWR0aCkpIHx8IDE7XHJcbiAgICAgICAgICBzaHJpbmtTaXplID0gTWF0aC5taW4oc2hyaW5rU2l6ZSwgd2lkdGggLSBhYnNNaW5XaWR0aCk7XHJcbiAgICAgICAgICB0b3RhbCAtPSBzaHJpbmtTaXplO1xyXG4gICAgICAgICAgc2hyaW5rTGVld2F5IC09IHNocmlua1NpemU7XHJcbiAgICAgICAgICB3aWR0aHNbaV0gLT0gc2hyaW5rU2l6ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHByZXZUb3RhbCA8PSB0b3RhbCkgeyAgLy8gYXZvaWQgaW5maW5pdGUgbG9vcFxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByZXZUb3RhbCA9IHRvdGFsO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBncm93XHJcbiAgICAgIHByZXZUb3RhbCA9IHRvdGFsO1xyXG4gICAgICB3aGlsZSAodG90YWwgPCBhdmFpbFdpZHRoKSB7XHJcbiAgICAgICAgdmFyIGdyb3dQcm9wb3J0aW9uID0gYXZhaWxXaWR0aCAvIHRvdGFsO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb2x1bW5zLmxlbmd0aCAmJiB0b3RhbCA8IGF2YWlsV2lkdGg7IGkrKykge1xyXG4gICAgICAgICAgYyA9IGNvbHVtbnNbaV07XHJcbiAgICAgICAgICB2YXIgY3VycmVudFdpZHRoID0gd2lkdGhzW2ldO1xyXG4gICAgICAgICAgdmFyIGdyb3dTaXplO1xyXG5cclxuICAgICAgICAgIGlmICghYy5yZXNpemFibGUgfHwgYy5tYXhXaWR0aCA8PSBjdXJyZW50V2lkdGgpIHtcclxuICAgICAgICAgICAgZ3Jvd1NpemUgPSAwO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZ3Jvd1NpemUgPSBNYXRoLm1pbihNYXRoLmZsb29yKGdyb3dQcm9wb3J0aW9uICogY3VycmVudFdpZHRoKSAtIGN1cnJlbnRXaWR0aCwgKGMubWF4V2lkdGggLSBjdXJyZW50V2lkdGgpIHx8IDEwMDAwMDApIHx8IDE7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0b3RhbCArPSBncm93U2l6ZTtcclxuICAgICAgICAgIHdpZHRoc1tpXSArPSAodG90YWwgPD0gYXZhaWxXaWR0aCA/IGdyb3dTaXplIDogMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcmV2VG90YWwgPj0gdG90YWwpIHsgIC8vIGF2b2lkIGluZmluaXRlIGxvb3BcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwcmV2VG90YWwgPSB0b3RhbDtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHJlUmVuZGVyID0gZmFsc2U7XHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjb2x1bW5zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGNvbHVtbnNbaV0ucmVyZW5kZXJPblJlc2l6ZSAmJiBjb2x1bW5zW2ldLndpZHRoICE9IHdpZHRoc1tpXSkge1xyXG4gICAgICAgICAgcmVSZW5kZXIgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb2x1bW5zW2ldLndpZHRoID0gd2lkdGhzW2ldO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBhcHBseUNvbHVtbkhlYWRlcldpZHRocygpO1xyXG4gICAgICB1cGRhdGVDYW52YXNXaWR0aCh0cnVlKTtcclxuICAgICAgaWYgKHJlUmVuZGVyKSB7XHJcbiAgICAgICAgaW52YWxpZGF0ZUFsbFJvd3MoKTtcclxuICAgICAgICByZW5kZXIoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFwcGx5Q29sdW1uSGVhZGVyV2lkdGhzKCkge1xyXG4gICAgICBpZiAoIWluaXRpYWxpemVkKSB7IHJldHVybjsgfVxyXG4gICAgICB2YXIgaDtcclxuXHJcbiAgICAgIGZvciAodmFyIGkgPSAwLCBoZWFkZXJzID0gJGhlYWRlcnMuY2hpbGRyZW4oKSwgaWkgPSBjb2x1bW5zLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcclxuICAgICAgICBoID0gJChoZWFkZXJzW2ldKTtcclxuICAgICAgICBpZiAoalF1ZXJ5TmV3V2lkdGhCZWhhdmlvdXIpIHtcclxuICAgICAgICAgICAgaWYgKGgub3V0ZXJXaWR0aCgpICE9PSBjb2x1bW5zW2ldLndpZHRoKSB7XHJcbiAgICAgICAgICAgICAgaC5vdXRlcldpZHRoKGNvbHVtbnNbaV0ud2lkdGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGgud2lkdGgoKSAhPT0gY29sdW1uc1tpXS53aWR0aCAtIGhlYWRlckNvbHVtbldpZHRoRGlmZikge1xyXG4gICAgICAgICAgICAgIGgud2lkdGgoY29sdW1uc1tpXS53aWR0aCAtIGhlYWRlckNvbHVtbldpZHRoRGlmZik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHVwZGF0ZUNvbHVtbkNhY2hlcygpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFwcGx5Q29sdW1uV2lkdGhzKCkge1xyXG4gICAgICB2YXIgeCA9IDAsIHcsIHJ1bGU7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sdW1ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHcgPSBjb2x1bW5zW2ldLndpZHRoO1xyXG5cclxuICAgICAgICBydWxlID0gZ2V0Q29sdW1uQ3NzUnVsZXMoaSk7XHJcbiAgICAgICAgcnVsZS5sZWZ0LnN0eWxlLmxlZnQgPSB4ICsgXCJweFwiO1xyXG4gICAgICAgIHJ1bGUucmlnaHQuc3R5bGUucmlnaHQgPSAoY2FudmFzV2lkdGggLSB4IC0gdykgKyBcInB4XCI7XHJcblxyXG4gICAgICAgIHggKz0gY29sdW1uc1tpXS53aWR0aDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNldFNvcnRDb2x1bW4oY29sdW1uSWQsIGFzY2VuZGluZykge1xyXG4gICAgICBzZXRTb3J0Q29sdW1ucyhbeyBjb2x1bW5JZDogY29sdW1uSWQsIHNvcnRBc2M6IGFzY2VuZGluZ31dKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzZXRTb3J0Q29sdW1ucyhjb2xzKSB7XHJcbiAgICAgIHNvcnRDb2x1bW5zID0gY29scztcclxuICAgICAgdmFyIG51bWJlckNvbHMgPSBvcHRpb25zLm51bWJlcmVkTXVsdGlDb2x1bW5Tb3J0ICYmIHNvcnRDb2x1bW5zLmxlbmd0aCA+IDE7XHJcbiAgICAgIHZhciBoZWFkZXJDb2x1bW5FbHMgPSAkaGVhZGVycy5jaGlsZHJlbigpO1xyXG4gICAgICBoZWFkZXJDb2x1bW5FbHNcclxuICAgICAgICAucmVtb3ZlQ2xhc3MoXCJzbGljay1oZWFkZXItY29sdW1uLXNvcnRlZFwiKVxyXG4gICAgICAgIC5maW5kKFwiLnNsaWNrLXNvcnQtaW5kaWNhdG9yXCIpXHJcbiAgICAgICAgICAucmVtb3ZlQ2xhc3MoXCJzbGljay1zb3J0LWluZGljYXRvci1hc2Mgc2xpY2stc29ydC1pbmRpY2F0b3ItZGVzY1wiKTtcclxuICAgICAgaGVhZGVyQ29sdW1uRWxzXHJcbiAgICAgICAgLmZpbmQoXCIuc2xpY2stc29ydC1pbmRpY2F0b3ItbnVtYmVyZWRcIilcclxuICAgICAgICAgIC50ZXh0KCcnKTtcclxuXHJcbiAgICAgICQuZWFjaChzb3J0Q29sdW1ucywgZnVuY3Rpb24oaSwgY29sKSB7XHJcbiAgICAgICAgaWYgKGNvbC5zb3J0QXNjID09IG51bGwpIHtcclxuICAgICAgICAgIGNvbC5zb3J0QXNjID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNvbHVtbkluZGV4ID0gZ2V0Q29sdW1uSW5kZXgoY29sLmNvbHVtbklkKTtcclxuICAgICAgICBpZiAoY29sdW1uSW5kZXggIT0gbnVsbCkge1xyXG4gICAgICAgICAgaGVhZGVyQ29sdW1uRWxzLmVxKGNvbHVtbkluZGV4KVxyXG4gICAgICAgICAgICAuYWRkQ2xhc3MoXCJzbGljay1oZWFkZXItY29sdW1uLXNvcnRlZFwiKVxyXG4gICAgICAgICAgICAgIC5maW5kKFwiLnNsaWNrLXNvcnQtaW5kaWNhdG9yXCIpXHJcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoY29sLnNvcnRBc2MgPyBcInNsaWNrLXNvcnQtaW5kaWNhdG9yLWFzY1wiIDogXCJzbGljay1zb3J0LWluZGljYXRvci1kZXNjXCIpO1xyXG4gICAgICAgICAgaWYgKG51bWJlckNvbHMpIHsgXHJcbiAgICAgICAgICAgIGhlYWRlckNvbHVtbkVscy5lcShjb2x1bW5JbmRleClcclxuICAgICAgICAgICAgICAuZmluZChcIi5zbGljay1zb3J0LWluZGljYXRvci1udW1iZXJlZFwiKVxyXG4gICAgICAgICAgICAgICAgLnRleHQoaSsxKTsgXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRTb3J0Q29sdW1ucygpIHtcclxuICAgICAgcmV0dXJuIHNvcnRDb2x1bW5zO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGhhbmRsZVNlbGVjdGVkUmFuZ2VzQ2hhbmdlZChlLCByYW5nZXMpIHtcclxuICAgICAgc2VsZWN0ZWRSb3dzID0gW107XHJcbiAgICAgIHZhciBoYXNoID0ge307XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaiA9IHJhbmdlc1tpXS5mcm9tUm93OyBqIDw9IHJhbmdlc1tpXS50b1JvdzsgaisrKSB7XHJcbiAgICAgICAgICBpZiAoIWhhc2hbal0pIHsgIC8vIHByZXZlbnQgZHVwbGljYXRlc1xyXG4gICAgICAgICAgICBzZWxlY3RlZFJvd3MucHVzaChqKTtcclxuICAgICAgICAgICAgaGFzaFtqXSA9IHt9O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZm9yICh2YXIgayA9IHJhbmdlc1tpXS5mcm9tQ2VsbDsgayA8PSByYW5nZXNbaV0udG9DZWxsOyBrKyspIHtcclxuICAgICAgICAgICAgaWYgKGNhbkNlbGxCZVNlbGVjdGVkKGosIGspKSB7XHJcbiAgICAgICAgICAgICAgaGFzaFtqXVtjb2x1bW5zW2tdLmlkXSA9IG9wdGlvbnMuc2VsZWN0ZWRDZWxsQ3NzQ2xhc3M7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHNldENlbGxDc3NTdHlsZXMob3B0aW9ucy5zZWxlY3RlZENlbGxDc3NDbGFzcywgaGFzaCk7XHJcblxyXG4gICAgICB0cmlnZ2VyKHNlbGYub25TZWxlY3RlZFJvd3NDaGFuZ2VkLCB7cm93czogZ2V0U2VsZWN0ZWRSb3dzKCksIGdyaWQ6IHNlbGZ9LCBlKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRDb2x1bW5zKCkge1xyXG4gICAgICByZXR1cm4gY29sdW1ucztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB1cGRhdGVDb2x1bW5DYWNoZXMoKSB7XHJcbiAgICAgIC8vIFByZS1jYWxjdWxhdGUgY2VsbCBib3VuZGFyaWVzLlxyXG4gICAgICBjb2x1bW5Qb3NMZWZ0ID0gW107XHJcbiAgICAgIGNvbHVtblBvc1JpZ2h0ID0gW107XHJcbiAgICAgIHZhciB4ID0gMDtcclxuICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gY29sdW1ucy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XHJcbiAgICAgICAgY29sdW1uUG9zTGVmdFtpXSA9IHg7XHJcbiAgICAgICAgY29sdW1uUG9zUmlnaHRbaV0gPSB4ICsgY29sdW1uc1tpXS53aWR0aDtcclxuICAgICAgICB4ICs9IGNvbHVtbnNbaV0ud2lkdGg7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzZXRDb2x1bW5zKGNvbHVtbkRlZmluaXRpb25zKSB7XHJcbiAgICAgIGNvbHVtbnMgPSBjb2x1bW5EZWZpbml0aW9ucztcclxuXHJcbiAgICAgIGNvbHVtbnNCeUlkID0ge307XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sdW1ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBtID0gY29sdW1uc1tpXSA9ICQuZXh0ZW5kKHt9LCBjb2x1bW5EZWZhdWx0cywgY29sdW1uc1tpXSk7XHJcbiAgICAgICAgY29sdW1uc0J5SWRbbS5pZF0gPSBpO1xyXG4gICAgICAgIGlmIChtLm1pbldpZHRoICYmIG0ud2lkdGggPCBtLm1pbldpZHRoKSB7XHJcbiAgICAgICAgICBtLndpZHRoID0gbS5taW5XaWR0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG0ubWF4V2lkdGggJiYgbS53aWR0aCA+IG0ubWF4V2lkdGgpIHtcclxuICAgICAgICAgIG0ud2lkdGggPSBtLm1heFdpZHRoO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgdXBkYXRlQ29sdW1uQ2FjaGVzKCk7XHJcblxyXG4gICAgICBpZiAoaW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICBpbnZhbGlkYXRlQWxsUm93cygpO1xyXG4gICAgICAgIGNyZWF0ZUNvbHVtbkhlYWRlcnMoKTtcclxuICAgICAgICByZW1vdmVDc3NSdWxlcygpO1xyXG4gICAgICAgIGNyZWF0ZUNzc1J1bGVzKCk7XHJcbiAgICAgICAgcmVzaXplQ2FudmFzKCk7XHJcbiAgICAgICAgYXBwbHlDb2x1bW5XaWR0aHMoKTtcclxuICAgICAgICBoYW5kbGVTY3JvbGwoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldE9wdGlvbnMoKSB7XHJcbiAgICAgIHJldHVybiBvcHRpb25zO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNldE9wdGlvbnMoYXJncywgc3VwcHJlc3NSZW5kZXIpIHtcclxuICAgICAgaWYgKCFnZXRFZGl0b3JMb2NrKCkuY29tbWl0Q3VycmVudEVkaXQoKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgbWFrZUFjdGl2ZUNlbGxOb3JtYWwoKTtcclxuXHJcbiAgICAgIGlmIChvcHRpb25zLmVuYWJsZUFkZFJvdyAhPT0gYXJncy5lbmFibGVBZGRSb3cpIHtcclxuICAgICAgICBpbnZhbGlkYXRlUm93KGdldERhdGFMZW5ndGgoKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG9wdGlvbnMgPSAkLmV4dGVuZChvcHRpb25zLCBhcmdzKTtcclxuICAgICAgdmFsaWRhdGVBbmRFbmZvcmNlT3B0aW9ucygpO1xyXG5cclxuICAgICAgJHZpZXdwb3J0LmNzcyhcIm92ZXJmbG93LXlcIiwgb3B0aW9ucy5hdXRvSGVpZ2h0ID8gXCJoaWRkZW5cIiA6IFwiYXV0b1wiKTtcclxuICAgICAgaWYgKCFzdXBwcmVzc1JlbmRlcikgeyByZW5kZXIoKTsgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlQW5kRW5mb3JjZU9wdGlvbnMoKSB7XHJcbiAgICAgIGlmIChvcHRpb25zLmF1dG9IZWlnaHQpIHtcclxuICAgICAgICBvcHRpb25zLmxlYXZlU3BhY2VGb3JOZXdSb3dzID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzZXREYXRhKG5ld0RhdGEsIHNjcm9sbFRvVG9wKSB7XHJcbiAgICAgIGRhdGEgPSBuZXdEYXRhO1xyXG4gICAgICBpbnZhbGlkYXRlQWxsUm93cygpO1xyXG4gICAgICB1cGRhdGVSb3dDb3VudCgpO1xyXG4gICAgICBpZiAoc2Nyb2xsVG9Ub3ApIHtcclxuICAgICAgICBzY3JvbGxUbygwKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldERhdGEoKSB7XHJcbiAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldERhdGFMZW5ndGgoKSB7XHJcbiAgICAgIGlmIChkYXRhLmdldExlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBkYXRhLmdldExlbmd0aCgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBkYXRhLmxlbmd0aDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldERhdGFMZW5ndGhJbmNsdWRpbmdBZGROZXcoKSB7XHJcbiAgICAgIHJldHVybiBnZXREYXRhTGVuZ3RoKCkgKyAoIW9wdGlvbnMuZW5hYmxlQWRkUm93ID8gMFxyXG4gICAgICAgIDogKCFwYWdpbmdBY3RpdmUgfHwgcGFnaW5nSXNMYXN0UGFnZSA/IDEgOiAwKVxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldERhdGFJdGVtKGkpIHtcclxuICAgICAgaWYgKGRhdGEuZ2V0SXRlbSkge1xyXG4gICAgICAgIHJldHVybiBkYXRhLmdldEl0ZW0oaSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGRhdGFbaV07XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRUb3BQYW5lbCgpIHtcclxuICAgICAgcmV0dXJuICR0b3BQYW5lbFswXTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzZXRUb3BQYW5lbFZpc2liaWxpdHkodmlzaWJsZSkge1xyXG4gICAgICBpZiAob3B0aW9ucy5zaG93VG9wUGFuZWwgIT0gdmlzaWJsZSkge1xyXG4gICAgICAgIG9wdGlvbnMuc2hvd1RvcFBhbmVsID0gdmlzaWJsZTtcclxuICAgICAgICBpZiAodmlzaWJsZSkge1xyXG4gICAgICAgICAgJHRvcFBhbmVsU2Nyb2xsZXIuc2xpZGVEb3duKFwiZmFzdFwiLCByZXNpemVDYW52YXMpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAkdG9wUGFuZWxTY3JvbGxlci5zbGlkZVVwKFwiZmFzdFwiLCByZXNpemVDYW52YXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNldEhlYWRlclJvd1Zpc2liaWxpdHkodmlzaWJsZSkge1xyXG4gICAgICBpZiAob3B0aW9ucy5zaG93SGVhZGVyUm93ICE9IHZpc2libGUpIHtcclxuICAgICAgICBvcHRpb25zLnNob3dIZWFkZXJSb3cgPSB2aXNpYmxlO1xyXG4gICAgICAgIGlmICh2aXNpYmxlKSB7XHJcbiAgICAgICAgICAkaGVhZGVyUm93U2Nyb2xsZXIuc2xpZGVEb3duKFwiZmFzdFwiLCByZXNpemVDYW52YXMpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAkaGVhZGVyUm93U2Nyb2xsZXIuc2xpZGVVcChcImZhc3RcIiwgcmVzaXplQ2FudmFzKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzZXRGb290ZXJSb3dWaXNpYmlsaXR5KHZpc2libGUpIHtcclxuICAgICAgaWYgKG9wdGlvbnMuc2hvd0Zvb3RlclJvdyAhPSB2aXNpYmxlKSB7XHJcbiAgICAgICAgb3B0aW9ucy5zaG93Rm9vdGVyUm93ID0gdmlzaWJsZTtcclxuICAgICAgICBpZiAodmlzaWJsZSkge1xyXG4gICAgICAgICAgJGZvb3RlclJvd1Njcm9sbGVyLnNsaWRlRG93bihcImZhc3RcIiwgcmVzaXplQ2FudmFzKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgJGZvb3RlclJvd1Njcm9sbGVyLnNsaWRlVXAoXCJmYXN0XCIsIHJlc2l6ZUNhbnZhcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2V0UHJlSGVhZGVyUGFuZWxWaXNpYmlsaXR5KHZpc2libGUpIHtcclxuICAgICAgaWYgKG9wdGlvbnMuc2hvd1ByZUhlYWRlclBhbmVsICE9IHZpc2libGUpIHtcclxuICAgICAgICBvcHRpb25zLnNob3dQcmVIZWFkZXJQYW5lbCA9IHZpc2libGU7XHJcbiAgICAgICAgaWYgKHZpc2libGUpIHtcclxuICAgICAgICAgICRwcmVIZWFkZXJQYW5lbFNjcm9sbGVyLnNsaWRlRG93bihcImZhc3RcIiwgcmVzaXplQ2FudmFzKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgJHByZUhlYWRlclBhbmVsU2Nyb2xsZXIuc2xpZGVVcChcImZhc3RcIiwgcmVzaXplQ2FudmFzKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRDb250YWluZXJOb2RlKCkge1xyXG4gICAgICByZXR1cm4gJGNvbnRhaW5lci5nZXQoMCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gICAgLy8gUmVuZGVyaW5nIC8gU2Nyb2xsaW5nXHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0Um93VG9wKHJvdykge1xyXG4gICAgICByZXR1cm4gb3B0aW9ucy5yb3dIZWlnaHQgKiByb3cgLSBvZmZzZXQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0Um93RnJvbVBvc2l0aW9uKHkpIHtcclxuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKHkgKyBvZmZzZXQpIC8gb3B0aW9ucy5yb3dIZWlnaHQpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNjcm9sbFRvKHkpIHtcclxuICAgICAgeSA9IE1hdGgubWF4KHksIDApO1xyXG4gICAgICB5ID0gTWF0aC5taW4oeSwgdGggLSB2aWV3cG9ydEggKyAodmlld3BvcnRIYXNIU2Nyb2xsID8gc2Nyb2xsYmFyRGltZW5zaW9ucy5oZWlnaHQgOiAwKSk7XHJcblxyXG4gICAgICB2YXIgb2xkT2Zmc2V0ID0gb2Zmc2V0O1xyXG5cclxuICAgICAgcGFnZSA9IE1hdGgubWluKG4gLSAxLCBNYXRoLmZsb29yKHkgLyBwaCkpO1xyXG4gICAgICBvZmZzZXQgPSBNYXRoLnJvdW5kKHBhZ2UgKiBjaik7XHJcbiAgICAgIHZhciBuZXdTY3JvbGxUb3AgPSB5IC0gb2Zmc2V0O1xyXG5cclxuICAgICAgaWYgKG9mZnNldCAhPSBvbGRPZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmFuZ2UgPSBnZXRWaXNpYmxlUmFuZ2UobmV3U2Nyb2xsVG9wKTtcclxuICAgICAgICBjbGVhbnVwUm93cyhyYW5nZSk7XHJcbiAgICAgICAgdXBkYXRlUm93UG9zaXRpb25zKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChwcmV2U2Nyb2xsVG9wICE9IG5ld1Njcm9sbFRvcCkge1xyXG4gICAgICAgIHZTY3JvbGxEaXIgPSAocHJldlNjcm9sbFRvcCArIG9sZE9mZnNldCA8IG5ld1Njcm9sbFRvcCArIG9mZnNldCkgPyAxIDogLTE7XHJcbiAgICAgICAgJHZpZXdwb3J0WzBdLnNjcm9sbFRvcCA9IChsYXN0UmVuZGVyZWRTY3JvbGxUb3AgPSBzY3JvbGxUb3AgPSBwcmV2U2Nyb2xsVG9wID0gbmV3U2Nyb2xsVG9wKTtcclxuXHJcbiAgICAgICAgdHJpZ2dlcihzZWxmLm9uVmlld3BvcnRDaGFuZ2VkLCB7Z3JpZDogc2VsZn0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZGVmYXVsdEZvcm1hdHRlcihyb3csIGNlbGwsIHZhbHVlLCBjb2x1bW5EZWYsIGRhdGFDb250ZXh0LCBncmlkKSB7XHJcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuICh2YWx1ZSArIFwiXCIpLnJlcGxhY2UoLyYvZyxcIiZhbXA7XCIpLnJlcGxhY2UoLzwvZyxcIiZsdDtcIikucmVwbGFjZSgvPi9nLFwiJmd0O1wiKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldEZvcm1hdHRlcihyb3csIGNvbHVtbikge1xyXG4gICAgICB2YXIgcm93TWV0YWRhdGEgPSBkYXRhLmdldEl0ZW1NZXRhZGF0YSAmJiBkYXRhLmdldEl0ZW1NZXRhZGF0YShyb3cpO1xyXG5cclxuICAgICAgLy8gbG9vayB1cCBieSBpZCwgdGhlbiBpbmRleFxyXG4gICAgICB2YXIgY29sdW1uT3ZlcnJpZGVzID0gcm93TWV0YWRhdGEgJiZcclxuICAgICAgICAgIHJvd01ldGFkYXRhLmNvbHVtbnMgJiZcclxuICAgICAgICAgIChyb3dNZXRhZGF0YS5jb2x1bW5zW2NvbHVtbi5pZF0gfHwgcm93TWV0YWRhdGEuY29sdW1uc1tnZXRDb2x1bW5JbmRleChjb2x1bW4uaWQpXSk7XHJcblxyXG4gICAgICByZXR1cm4gKGNvbHVtbk92ZXJyaWRlcyAmJiBjb2x1bW5PdmVycmlkZXMuZm9ybWF0dGVyKSB8fFxyXG4gICAgICAgICAgKHJvd01ldGFkYXRhICYmIHJvd01ldGFkYXRhLmZvcm1hdHRlcikgfHxcclxuICAgICAgICAgIGNvbHVtbi5mb3JtYXR0ZXIgfHxcclxuICAgICAgICAgIChvcHRpb25zLmZvcm1hdHRlckZhY3RvcnkgJiYgb3B0aW9ucy5mb3JtYXR0ZXJGYWN0b3J5LmdldEZvcm1hdHRlcihjb2x1bW4pKSB8fFxyXG4gICAgICAgICAgb3B0aW9ucy5kZWZhdWx0Rm9ybWF0dGVyO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldEVkaXRvcihyb3csIGNlbGwpIHtcclxuICAgICAgdmFyIGNvbHVtbiA9IGNvbHVtbnNbY2VsbF07XHJcbiAgICAgIHZhciByb3dNZXRhZGF0YSA9IGRhdGEuZ2V0SXRlbU1ldGFkYXRhICYmIGRhdGEuZ2V0SXRlbU1ldGFkYXRhKHJvdyk7XHJcbiAgICAgIHZhciBjb2x1bW5NZXRhZGF0YSA9IHJvd01ldGFkYXRhICYmIHJvd01ldGFkYXRhLmNvbHVtbnM7XHJcblxyXG4gICAgICBpZiAoY29sdW1uTWV0YWRhdGEgJiYgY29sdW1uTWV0YWRhdGFbY29sdW1uLmlkXSAmJiBjb2x1bW5NZXRhZGF0YVtjb2x1bW4uaWRdLmVkaXRvciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbHVtbk1ldGFkYXRhW2NvbHVtbi5pZF0uZWRpdG9yO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChjb2x1bW5NZXRhZGF0YSAmJiBjb2x1bW5NZXRhZGF0YVtjZWxsXSAmJiBjb2x1bW5NZXRhZGF0YVtjZWxsXS5lZGl0b3IgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiBjb2x1bW5NZXRhZGF0YVtjZWxsXS5lZGl0b3I7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBjb2x1bW4uZWRpdG9yIHx8IChvcHRpb25zLmVkaXRvckZhY3RvcnkgJiYgb3B0aW9ucy5lZGl0b3JGYWN0b3J5LmdldEVkaXRvcihjb2x1bW4pKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXREYXRhSXRlbVZhbHVlRm9yQ29sdW1uKGl0ZW0sIGNvbHVtbkRlZikge1xyXG4gICAgICBpZiAob3B0aW9ucy5kYXRhSXRlbUNvbHVtblZhbHVlRXh0cmFjdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuZGF0YUl0ZW1Db2x1bW5WYWx1ZUV4dHJhY3RvcihpdGVtLCBjb2x1bW5EZWYpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBpdGVtW2NvbHVtbkRlZi5maWVsZF07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYXBwZW5kUm93SHRtbChzdHJpbmdBcnJheSwgcm93LCByYW5nZSwgZGF0YUxlbmd0aCkge1xyXG4gICAgICB2YXIgZCA9IGdldERhdGFJdGVtKHJvdyk7XHJcbiAgICAgIHZhciBkYXRhTG9hZGluZyA9IHJvdyA8IGRhdGFMZW5ndGggJiYgIWQ7XHJcbiAgICAgIHZhciByb3dDc3MgPSBcInNsaWNrLXJvd1wiICtcclxuICAgICAgICAgIChkYXRhTG9hZGluZyA/IFwiIGxvYWRpbmdcIiA6IFwiXCIpICtcclxuICAgICAgICAgIChyb3cgPT09IGFjdGl2ZVJvdyAmJiBvcHRpb25zLnNob3dDZWxsU2VsZWN0aW9uID8gXCIgYWN0aXZlXCIgOiBcIlwiKSArXHJcbiAgICAgICAgICAocm93ICUgMiA9PSAxID8gXCIgb2RkXCIgOiBcIiBldmVuXCIpO1xyXG5cclxuICAgICAgaWYgKCFkKSB7XHJcbiAgICAgICAgcm93Q3NzICs9IFwiIFwiICsgb3B0aW9ucy5hZGROZXdSb3dDc3NDbGFzcztcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIG1ldGFkYXRhID0gZGF0YS5nZXRJdGVtTWV0YWRhdGEgJiYgZGF0YS5nZXRJdGVtTWV0YWRhdGEocm93KTtcclxuXHJcbiAgICAgIGlmIChtZXRhZGF0YSAmJiBtZXRhZGF0YS5jc3NDbGFzc2VzKSB7XHJcbiAgICAgICAgcm93Q3NzICs9IFwiIFwiICsgbWV0YWRhdGEuY3NzQ2xhc3NlcztcclxuICAgICAgfVxyXG5cclxuICAgICAgc3RyaW5nQXJyYXkucHVzaChcIjxkaXYgY2xhc3M9J3VpLXdpZGdldC1jb250ZW50IFwiICsgcm93Q3NzICsgXCInIHN0eWxlPSd0b3A6XCIgKyBnZXRSb3dUb3Aocm93KSArIFwicHgnPlwiKTtcclxuXHJcbiAgICAgIHZhciBjb2xzcGFuLCBtO1xyXG4gICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBjb2x1bW5zLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcclxuICAgICAgICBtID0gY29sdW1uc1tpXTtcclxuICAgICAgICBjb2xzcGFuID0gMTtcclxuICAgICAgICBpZiAobWV0YWRhdGEgJiYgbWV0YWRhdGEuY29sdW1ucykge1xyXG4gICAgICAgICAgdmFyIGNvbHVtbkRhdGEgPSBtZXRhZGF0YS5jb2x1bW5zW20uaWRdIHx8IG1ldGFkYXRhLmNvbHVtbnNbaV07XHJcbiAgICAgICAgICBjb2xzcGFuID0gKGNvbHVtbkRhdGEgJiYgY29sdW1uRGF0YS5jb2xzcGFuKSB8fCAxO1xyXG4gICAgICAgICAgaWYgKGNvbHNwYW4gPT09IFwiKlwiKSB7XHJcbiAgICAgICAgICAgIGNvbHNwYW4gPSBpaSAtIGk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEbyBub3QgcmVuZGVyIGNlbGxzIG91dHNpZGUgb2YgdGhlIHZpZXdwb3J0LlxyXG4gICAgICAgIGlmIChjb2x1bW5Qb3NSaWdodFtNYXRoLm1pbihpaSAtIDEsIGkgKyBjb2xzcGFuIC0gMSldID4gcmFuZ2UubGVmdFB4KSB7XHJcbiAgICAgICAgICBpZiAoY29sdW1uUG9zTGVmdFtpXSA+IHJhbmdlLnJpZ2h0UHgpIHtcclxuICAgICAgICAgICAgLy8gQWxsIGNvbHVtbnMgdG8gdGhlIHJpZ2h0IGFyZSBvdXRzaWRlIHRoZSByYW5nZS5cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgYXBwZW5kQ2VsbEh0bWwoc3RyaW5nQXJyYXksIHJvdywgaSwgY29sc3BhbiwgZCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY29sc3BhbiA+IDEpIHtcclxuICAgICAgICAgIGkgKz0gKGNvbHNwYW4gLSAxKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHN0cmluZ0FycmF5LnB1c2goXCI8L2Rpdj5cIik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYXBwZW5kQ2VsbEh0bWwoc3RyaW5nQXJyYXksIHJvdywgY2VsbCwgY29sc3BhbiwgaXRlbSkge1xyXG4gICAgICAvLyBzdHJpbmdBcnJheTogc3RyaW5nQnVpbGRlciBjb250YWluaW5nIHRoZSBIVE1MIHBhcnRzXHJcbiAgICAgIC8vIHJvdywgY2VsbDogcm93IGFuZCBjb2x1bW4gaW5kZXhcclxuICAgICAgLy8gY29sc3BhbjogSFRNTCBjb2xzcGFuXHJcbiAgICAgIC8vIGl0ZW06IGdyaWQgZGF0YSBmb3Igcm93XHJcblxyXG4gICAgICB2YXIgbSA9IGNvbHVtbnNbY2VsbF07XHJcbiAgICAgIHZhciBjZWxsQ3NzID0gXCJzbGljay1jZWxsIGxcIiArIGNlbGwgKyBcIiByXCIgKyBNYXRoLm1pbihjb2x1bW5zLmxlbmd0aCAtIDEsIGNlbGwgKyBjb2xzcGFuIC0gMSkgK1xyXG4gICAgICAgICAgKG0uY3NzQ2xhc3MgPyBcIiBcIiArIG0uY3NzQ2xhc3MgOiBcIlwiKTtcclxuICAgICAgaWYgKHJvdyA9PT0gYWN0aXZlUm93ICYmIGNlbGwgPT09IGFjdGl2ZUNlbGwgJiYgb3B0aW9ucy5zaG93Q2VsbFNlbGVjdGlvbikge1xyXG4gICAgICAgIGNlbGxDc3MgKz0gKFwiIGFjdGl2ZVwiKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVE9ETzogIG1lcmdlIHRoZW0gdG9nZXRoZXIgaW4gdGhlIHNldHRlclxyXG4gICAgICBmb3IgKHZhciBrZXkgaW4gY2VsbENzc0NsYXNzZXMpIHtcclxuICAgICAgICBpZiAoY2VsbENzc0NsYXNzZXNba2V5XVtyb3ddICYmIGNlbGxDc3NDbGFzc2VzW2tleV1bcm93XVttLmlkXSkge1xyXG4gICAgICAgICAgY2VsbENzcyArPSAoXCIgXCIgKyBjZWxsQ3NzQ2xhc3Nlc1trZXldW3Jvd11bbS5pZF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHZhbHVlID0gbnVsbCwgZm9ybWF0dGVyUmVzdWx0ID0gJyc7XHJcbiAgICAgIGlmIChpdGVtKSB7IFxyXG4gICAgICAgIHZhbHVlID0gZ2V0RGF0YUl0ZW1WYWx1ZUZvckNvbHVtbihpdGVtLCBtKTtcclxuICAgICAgICBmb3JtYXR0ZXJSZXN1bHQgPSAgZ2V0Rm9ybWF0dGVyKHJvdywgbSkocm93LCBjZWxsLCB2YWx1ZSwgbSwgaXRlbSwgc2VsZik7XHJcbiAgICAgICAgaWYgKGZvcm1hdHRlclJlc3VsdCA9PT0gbnVsbCB8fCBmb3JtYXR0ZXJSZXN1bHQgPT09IHVuZGVmaW5lZCkgeyBmb3JtYXR0ZXJSZXN1bHQgPSAnJzsgfVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBnZXQgYWRkbCBjc3MgY2xhc3MgbmFtZXMgZnJvbSBvYmplY3QgdHlwZSBmb3JtYXR0ZXIgcmV0dXJuIGFuZCBmcm9tIHN0cmluZyB0eXBlIHJldHVybiBvZiBvbkJlZm9yZUFwcGVuZENlbGxcclxuICAgICAgdmFyIGFkZGxDc3NDbGFzc2VzID0gdHJpZ2dlcihzZWxmLm9uQmVmb3JlQXBwZW5kQ2VsbCwgeyByb3c6IHJvdywgY2VsbDogY2VsbCwgZ3JpZDogc2VsZiwgdmFsdWU6IHZhbHVlLCBkYXRhQ29udGV4dDogaXRlbSB9KSB8fCAnJztcclxuICAgICAgYWRkbENzc0NsYXNzZXMgKz0gKGZvcm1hdHRlclJlc3VsdCAmJiBmb3JtYXR0ZXJSZXN1bHQuYWRkQ2xhc3NlcyA/IChhZGRsQ3NzQ2xhc3NlcyA/ICcgJyA6ICcnKSArIGZvcm1hdHRlclJlc3VsdC5hZGRDbGFzc2VzIDogJycpO1xyXG4gICAgICBcclxuICAgICAgc3RyaW5nQXJyYXkucHVzaChcIjxkaXYgY2xhc3M9J1wiICsgY2VsbENzcyArIChhZGRsQ3NzQ2xhc3NlcyA/ICcgJyArIGFkZGxDc3NDbGFzc2VzIDogJycpICsgXCInPlwiKTtcclxuXHJcbiAgICAgIC8vIGlmIHRoZXJlIGlzIGEgY29ycmVzcG9uZGluZyByb3cgKGlmIG5vdCwgdGhpcyBpcyB0aGUgQWRkIE5ldyByb3cgb3IgdGhpcyBkYXRhIGhhc24ndCBiZWVuIGxvYWRlZCB5ZXQpXHJcbiAgICAgIGlmIChpdGVtKSB7XHJcbiAgICAgICAgc3RyaW5nQXJyYXkucHVzaChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZm9ybWF0dGVyUmVzdWx0KSAgIT09ICdbb2JqZWN0IE9iamVjdF0nID8gZm9ybWF0dGVyUmVzdWx0IDogZm9ybWF0dGVyUmVzdWx0LnRleHQpO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBzdHJpbmdBcnJheS5wdXNoKFwiPC9kaXY+XCIpO1xyXG5cclxuICAgICAgcm93c0NhY2hlW3Jvd10uY2VsbFJlbmRlclF1ZXVlLnB1c2goY2VsbCk7XHJcbiAgICAgIHJvd3NDYWNoZVtyb3ddLmNlbGxDb2xTcGFuc1tjZWxsXSA9IGNvbHNwYW47XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGNsZWFudXBSb3dzKHJhbmdlVG9LZWVwKSB7XHJcbiAgICAgIGZvciAodmFyIGkgaW4gcm93c0NhY2hlKSB7XHJcbiAgICAgICAgaWYgKCgoaSA9IHBhcnNlSW50KGksIDEwKSkgIT09IGFjdGl2ZVJvdykgJiYgKGkgPCByYW5nZVRvS2VlcC50b3AgfHwgaSA+IHJhbmdlVG9LZWVwLmJvdHRvbSkpIHtcclxuICAgICAgICAgIHJlbW92ZVJvd0Zyb21DYWNoZShpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKG9wdGlvbnMuZW5hYmxlQXN5bmNQb3N0UmVuZGVyQ2xlYW51cCkgeyBzdGFydFBvc3RQcm9jZXNzaW5nQ2xlYW51cCgpOyB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaW52YWxpZGF0ZSgpIHtcclxuICAgICAgdXBkYXRlUm93Q291bnQoKTtcclxuICAgICAgaW52YWxpZGF0ZUFsbFJvd3MoKTtcclxuICAgICAgcmVuZGVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaW52YWxpZGF0ZUFsbFJvd3MoKSB7XHJcbiAgICAgIGlmIChjdXJyZW50RWRpdG9yKSB7XHJcbiAgICAgICAgbWFrZUFjdGl2ZUNlbGxOb3JtYWwoKTtcclxuICAgICAgfVxyXG4gICAgICBmb3IgKHZhciByb3cgaW4gcm93c0NhY2hlKSB7XHJcbiAgICAgICAgcmVtb3ZlUm93RnJvbUNhY2hlKHJvdyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKG9wdGlvbnMuZW5hYmxlQXN5bmNQb3N0UmVuZGVyQ2xlYW51cCkgeyBzdGFydFBvc3RQcm9jZXNzaW5nQ2xlYW51cCgpOyB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcXVldWVQb3N0UHJvY2Vzc2VkUm93Rm9yQ2xlYW51cChjYWNoZUVudHJ5LCBwb3N0UHJvY2Vzc2VkUm93LCByb3dJZHgpIHtcclxuICAgICAgcG9zdFByb2Nlc3Nncm91cElkKys7XHJcblxyXG4gICAgICAvLyBzdG9yZSBhbmQgZGV0YWNoIG5vZGUgZm9yIGxhdGVyIGFzeW5jIGNsZWFudXBcclxuICAgICAgZm9yICh2YXIgY29sdW1uSWR4IGluIHBvc3RQcm9jZXNzZWRSb3cpIHtcclxuICAgICAgICBpZiAocG9zdFByb2Nlc3NlZFJvdy5oYXNPd25Qcm9wZXJ0eShjb2x1bW5JZHgpKSB7XHJcbiAgICAgICAgICBwb3N0UHJvY2Vzc2VkQ2xlYW51cFF1ZXVlLnB1c2goe1xyXG4gICAgICAgICAgICBhY3Rpb25UeXBlOiAnQycsXHJcbiAgICAgICAgICAgIGdyb3VwSWQ6IHBvc3RQcm9jZXNzZ3JvdXBJZCxcclxuICAgICAgICAgICAgbm9kZTogY2FjaGVFbnRyeS5jZWxsTm9kZXNCeUNvbHVtbklkeFsgY29sdW1uSWR4IHwgMF0sXHJcbiAgICAgICAgICAgIGNvbHVtbklkeDogY29sdW1uSWR4IHwgMCxcclxuICAgICAgICAgICAgcm93SWR4OiByb3dJZHhcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBwb3N0UHJvY2Vzc2VkQ2xlYW51cFF1ZXVlLnB1c2goe1xyXG4gICAgICAgIGFjdGlvblR5cGU6ICdSJyxcclxuICAgICAgICBncm91cElkOiBwb3N0UHJvY2Vzc2dyb3VwSWQsXHJcbiAgICAgICAgbm9kZTogY2FjaGVFbnRyeS5yb3dOb2RlXHJcbiAgICAgIH0pO1xyXG4gICAgICAkKGNhY2hlRW50cnkucm93Tm9kZSkuZGV0YWNoKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcXVldWVQb3N0UHJvY2Vzc2VkQ2VsbEZvckNsZWFudXAoY2VsbG5vZGUsIGNvbHVtbklkeCwgcm93SWR4KSB7XHJcbiAgICAgIHBvc3RQcm9jZXNzZWRDbGVhbnVwUXVldWUucHVzaCh7XHJcbiAgICAgICAgYWN0aW9uVHlwZTogJ0MnLFxyXG4gICAgICAgIGdyb3VwSWQ6IHBvc3RQcm9jZXNzZ3JvdXBJZCxcclxuICAgICAgICBub2RlOiBjZWxsbm9kZSxcclxuICAgICAgICBjb2x1bW5JZHg6IGNvbHVtbklkeCxcclxuICAgICAgICByb3dJZHg6IHJvd0lkeFxyXG4gICAgICB9KTtcclxuICAgICAgJChjZWxsbm9kZSkuZGV0YWNoKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVtb3ZlUm93RnJvbUNhY2hlKHJvdykge1xyXG4gICAgICB2YXIgY2FjaGVFbnRyeSA9IHJvd3NDYWNoZVtyb3ddO1xyXG4gICAgICBpZiAoIWNhY2hlRW50cnkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChjYWNoZUVudHJ5LnJvd05vZGUpIHtcclxuICAgICAgICBpZiAocm93Tm9kZUZyb21MYXN0TW91c2VXaGVlbEV2ZW50ID09PSBjYWNoZUVudHJ5LnJvd05vZGUpIHtcclxuICAgICAgICAgIGNhY2hlRW50cnkucm93Tm9kZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICAgICAgem9tYmllUm93Tm9kZUZyb21MYXN0TW91c2VXaGVlbEV2ZW50ID0gcm93Tm9kZUZyb21MYXN0TW91c2VXaGVlbEV2ZW50O1xyXG4gICAgICAgICAgem9tYmllUm93Q2FjaGVGcm9tTGFzdE1vdXNlV2hlZWxFdmVudCA9IGNhY2hlRW50cnk7XHJcbiAgICAgICAgICB6b21iaWVSb3dQb3N0UHJvY2Vzc2VkRnJvbUxhc3RNb3VzZVdoZWVsRXZlbnQgPSBwb3N0UHJvY2Vzc2VkUm93c1tyb3ddO1xyXG4gICAgICAgICAgLy8gaWdub3JlIHBvc3QgcHJvY2Vzc2luZyBjbGVhbnVwIGluIHRoaXMgY2FzZSAtIGl0IHdpbGwgYmUgZGVhbHQgd2l0aCBsYXRlclxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpZiAob3B0aW9ucy5lbmFibGVBc3luY1Bvc3RSZW5kZXJDbGVhbnVwICYmIHBvc3RQcm9jZXNzZWRSb3dzW3Jvd10pIHtcclxuICAgICAgICAgICAgcXVldWVQb3N0UHJvY2Vzc2VkUm93Rm9yQ2xlYW51cChjYWNoZUVudHJ5LCBwb3N0UHJvY2Vzc2VkUm93c1tyb3ddLCByb3cpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgJGNhbnZhc1swXS5yZW1vdmVDaGlsZChjYWNoZUVudHJ5LnJvd05vZGUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgZGVsZXRlIHJvd3NDYWNoZVtyb3ddO1xyXG4gICAgICBkZWxldGUgcG9zdFByb2Nlc3NlZFJvd3Nbcm93XTtcclxuICAgICAgcmVuZGVyZWRSb3dzLS07XHJcbiAgICAgIGNvdW50ZXJfcm93c19yZW1vdmVkKys7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaW52YWxpZGF0ZVJvd3Mocm93cykge1xyXG4gICAgICB2YXIgaSwgcmw7XHJcbiAgICAgIGlmICghcm93cyB8fCAhcm93cy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdlNjcm9sbERpciA9IDA7XHJcbiAgICAgIHJsID0gcm93cy5sZW5ndGg7XHJcbiAgICAgIGZvciAoaSA9IDA7ICBpIDwgcmw7IGkrKykge1xyXG4gICAgICAgIGlmIChjdXJyZW50RWRpdG9yICYmIGFjdGl2ZVJvdyA9PT0gcm93c1tpXSkge1xyXG4gICAgICAgICAgbWFrZUFjdGl2ZUNlbGxOb3JtYWwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJvd3NDYWNoZVtyb3dzW2ldXSkge1xyXG4gICAgICAgICAgcmVtb3ZlUm93RnJvbUNhY2hlKHJvd3NbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAob3B0aW9ucy5lbmFibGVBc3luY1Bvc3RSZW5kZXJDbGVhbnVwKSB7IHN0YXJ0UG9zdFByb2Nlc3NpbmdDbGVhbnVwKCk7IH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpbnZhbGlkYXRlUm93KHJvdykge1xyXG4gICAgICBpZiAoIXJvdyAmJiByb3cgIT09IDApIHsgcmV0dXJuOyB9XHJcbiAgICAgIGludmFsaWRhdGVSb3dzKFtyb3ddKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhcHBseUZvcm1hdFJlc3VsdFRvQ2VsbE5vZGUoZm9ybWF0dGVyUmVzdWx0LCBjZWxsTm9kZSwgc3VwcHJlc3NSZW1vdmUpIHtcclxuICAgICAgICBpZiAoZm9ybWF0dGVyUmVzdWx0ID09PSBudWxsIHx8IGZvcm1hdHRlclJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7IGZvcm1hdHRlclJlc3VsdCA9ICcnOyB9XHJcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChmb3JtYXR0ZXJSZXN1bHQpICAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHsgXHJcbiAgICAgICAgICAgIGNlbGxOb2RlLmlubmVySFRNTCA9IGZvcm1hdHRlclJlc3VsdDtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjZWxsTm9kZS5pbm5lckhUTUwgPSBmb3JtYXR0ZXJSZXN1bHQudGV4dDtcclxuICAgICAgICBpZiAoZm9ybWF0dGVyUmVzdWx0LnJlbW92ZUNsYXNzZXMgJiYgIXN1cHByZXNzUmVtb3ZlKSB7IFxyXG4gICAgICAgICAgICAkKGNlbGxOb2RlKS5yZW1vdmVDbGFzcyhmb3JtYXR0ZXJSZXN1bHQucmVtb3ZlQ2xhc3Nlcyk7IFxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZm9ybWF0dGVyUmVzdWx0LmFkZENsYXNzZXMpIHsgXHJcbiAgICAgICAgICAgICQoY2VsbE5vZGUpLmFkZENsYXNzKGZvcm1hdHRlclJlc3VsdC5hZGRDbGFzc2VzKTsgXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZUNlbGwocm93LCBjZWxsKSB7XHJcbiAgICAgIHZhciBjZWxsTm9kZSA9IGdldENlbGxOb2RlKHJvdywgY2VsbCk7XHJcbiAgICAgIGlmICghY2VsbE5vZGUpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBtID0gY29sdW1uc1tjZWxsXSwgZCA9IGdldERhdGFJdGVtKHJvdyk7XHJcbiAgICAgIGlmIChjdXJyZW50RWRpdG9yICYmIGFjdGl2ZVJvdyA9PT0gcm93ICYmIGFjdGl2ZUNlbGwgPT09IGNlbGwpIHtcclxuICAgICAgICBjdXJyZW50RWRpdG9yLmxvYWRWYWx1ZShkKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB2YXIgZm9ybWF0dGVyUmVzdWx0ID0gIGQgPyBnZXRGb3JtYXR0ZXIocm93LCBtKShyb3csIGNlbGwsIGdldERhdGFJdGVtVmFsdWVGb3JDb2x1bW4oZCwgbSksIG0sIGQsIHNlbGYpIDogXCJcIjtcclxuICAgICAgICBhcHBseUZvcm1hdFJlc3VsdFRvQ2VsbE5vZGUoZm9ybWF0dGVyUmVzdWx0LCBjZWxsTm9kZSk7XHJcbiAgICAgICAgaW52YWxpZGF0ZVBvc3RQcm9jZXNzaW5nUmVzdWx0cyhyb3cpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdXBkYXRlUm93KHJvdykge1xyXG4gICAgICB2YXIgY2FjaGVFbnRyeSA9IHJvd3NDYWNoZVtyb3ddO1xyXG4gICAgICBpZiAoIWNhY2hlRW50cnkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGVuc3VyZUNlbGxOb2Rlc0luUm93c0NhY2hlKHJvdyk7XHJcblxyXG4gICAgICB2YXIgZm9ybWF0dGVyUmVzdWx0LCBkID0gZ2V0RGF0YUl0ZW0ocm93KTtcclxuICAgIFxyXG4gICAgICBmb3IgKHZhciBjb2x1bW5JZHggaW4gY2FjaGVFbnRyeS5jZWxsTm9kZXNCeUNvbHVtbklkeCkge1xyXG4gICAgICAgIGlmICghY2FjaGVFbnRyeS5jZWxsTm9kZXNCeUNvbHVtbklkeC5oYXNPd25Qcm9wZXJ0eShjb2x1bW5JZHgpKSB7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbHVtbklkeCA9IGNvbHVtbklkeCB8IDA7XHJcbiAgICAgICAgdmFyIG0gPSBjb2x1bW5zW2NvbHVtbklkeF0sXHJcbiAgICAgICAgICAgIG5vZGUgPSBjYWNoZUVudHJ5LmNlbGxOb2Rlc0J5Q29sdW1uSWR4W2NvbHVtbklkeF07XHJcblxyXG4gICAgICAgIGlmIChyb3cgPT09IGFjdGl2ZVJvdyAmJiBjb2x1bW5JZHggPT09IGFjdGl2ZUNlbGwgJiYgY3VycmVudEVkaXRvcikge1xyXG4gICAgICAgICAgY3VycmVudEVkaXRvci5sb2FkVmFsdWUoZCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChkKSB7XHJcbiAgICAgICAgICBmb3JtYXR0ZXJSZXN1bHQgPSAgZ2V0Rm9ybWF0dGVyKHJvdywgbSkocm93LCBjb2x1bW5JZHgsIGdldERhdGFJdGVtVmFsdWVGb3JDb2x1bW4oZCwgbSksIG0sIGQsIHNlbGYpO1xyXG4gICAgICAgICAgYXBwbHlGb3JtYXRSZXN1bHRUb0NlbGxOb2RlKGZvcm1hdHRlclJlc3VsdCwgbm9kZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG5vZGUuaW5uZXJIVE1MID0gXCJcIjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGludmFsaWRhdGVQb3N0UHJvY2Vzc2luZ1Jlc3VsdHMocm93KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRWaWV3cG9ydEhlaWdodCgpIHtcclxuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoJC5jc3MoJGNvbnRhaW5lclswXSwgXCJoZWlnaHRcIiwgdHJ1ZSkpIC1cclxuICAgICAgICAgIHBhcnNlRmxvYXQoJC5jc3MoJGNvbnRhaW5lclswXSwgXCJwYWRkaW5nVG9wXCIsIHRydWUpKSAtXHJcbiAgICAgICAgICBwYXJzZUZsb2F0KCQuY3NzKCRjb250YWluZXJbMF0sIFwicGFkZGluZ0JvdHRvbVwiLCB0cnVlKSkgLVxyXG4gICAgICAgICAgcGFyc2VGbG9hdCgkLmNzcygkaGVhZGVyU2Nyb2xsZXJbMF0sIFwiaGVpZ2h0XCIpKSAtIGdldFZCb3hEZWx0YSgkaGVhZGVyU2Nyb2xsZXIpIC1cclxuICAgICAgICAgIChvcHRpb25zLnNob3dUb3BQYW5lbCA/IG9wdGlvbnMudG9wUGFuZWxIZWlnaHQgKyBnZXRWQm94RGVsdGEoJHRvcFBhbmVsU2Nyb2xsZXIpIDogMCkgLVxyXG4gICAgICAgICAgKG9wdGlvbnMuc2hvd0hlYWRlclJvdyA/IG9wdGlvbnMuaGVhZGVyUm93SGVpZ2h0ICsgZ2V0VkJveERlbHRhKCRoZWFkZXJSb3dTY3JvbGxlcikgOiAwKSAtXHJcbiAgICAgICAgICAob3B0aW9ucy5jcmVhdGVGb290ZXJSb3cgJiYgb3B0aW9ucy5zaG93Rm9vdGVyUm93ID8gb3B0aW9ucy5mb290ZXJSb3dIZWlnaHQgKyBnZXRWQm94RGVsdGEoJGZvb3RlclJvd1Njcm9sbGVyKSA6IDApIC1cclxuICAgICAgICAgIChvcHRpb25zLmNyZWF0ZVByZUhlYWRlclBhbmVsICYmIG9wdGlvbnMuc2hvd1ByZUhlYWRlclBhbmVsID8gb3B0aW9ucy5wcmVIZWFkZXJQYW5lbEhlaWdodCArIGdldFZCb3hEZWx0YSgkcHJlSGVhZGVyUGFuZWxTY3JvbGxlcikgOiAwKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZXNpemVDYW52YXMoKSB7XHJcbiAgICAgIGlmICghaW5pdGlhbGl6ZWQpIHsgcmV0dXJuOyB9XHJcbiAgICAgIGlmIChvcHRpb25zLmF1dG9IZWlnaHQpIHtcclxuICAgICAgICB2aWV3cG9ydEggPSBvcHRpb25zLnJvd0hlaWdodCAqIGdldERhdGFMZW5ndGhJbmNsdWRpbmdBZGROZXcoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB2aWV3cG9ydEggPSBnZXRWaWV3cG9ydEhlaWdodCgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBudW1WaXNpYmxlUm93cyA9IE1hdGguY2VpbCh2aWV3cG9ydEggLyBvcHRpb25zLnJvd0hlaWdodCk7XHJcbiAgICAgIHZpZXdwb3J0VyA9IHBhcnNlRmxvYXQoJC5jc3MoJGNvbnRhaW5lclswXSwgXCJ3aWR0aFwiLCB0cnVlKSk7XHJcbiAgICAgIGlmICghb3B0aW9ucy5hdXRvSGVpZ2h0KSB7XHJcbiAgICAgICAgJHZpZXdwb3J0LmhlaWdodCh2aWV3cG9ydEgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIXNjcm9sbGJhckRpbWVuc2lvbnMgfHwgIXNjcm9sbGJhckRpbWVuc2lvbnMud2lkdGgpIHtcclxuICAgICAgICBzY3JvbGxiYXJEaW1lbnNpb25zID0gbWVhc3VyZVNjcm9sbGJhcigpO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBpZiAob3B0aW9ucy5mb3JjZUZpdENvbHVtbnMpIHtcclxuICAgICAgICBhdXRvc2l6ZUNvbHVtbnMoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdXBkYXRlUm93Q291bnQoKTtcclxuICAgICAgaGFuZGxlU2Nyb2xsKCk7XHJcbiAgICAgIC8vIFNpbmNlIHRoZSB3aWR0aCBoYXMgY2hhbmdlZCwgZm9yY2UgdGhlIHJlbmRlcigpIHRvIHJlZXZhbHVhdGUgdmlydHVhbGx5IHJlbmRlcmVkIGNlbGxzLlxyXG4gICAgICBsYXN0UmVuZGVyZWRTY3JvbGxMZWZ0ID0gLTE7XHJcbiAgICAgIHJlbmRlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZVBhZ2luZ1N0YXR1c0Zyb21WaWV3KCBwYWdpbmdJbmZvICkge1xyXG4gICAgICAgIHBhZ2luZ0FjdGl2ZSA9IChwYWdpbmdJbmZvLnBhZ2VTaXplICE9PSAwKTtcclxuICAgICAgICBwYWdpbmdJc0xhc3RQYWdlID0gKHBhZ2luZ0luZm8ucGFnZU51bSA9PSBwYWdpbmdJbmZvLnRvdGFsUGFnZXMgLSAxKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB1cGRhdGVSb3dDb3VudCgpIHtcclxuICAgICAgaWYgKCFpbml0aWFsaXplZCkgeyByZXR1cm47IH1cclxuXHJcbiAgICAgIHZhciBkYXRhTGVuZ3RoID0gZ2V0RGF0YUxlbmd0aCgpO1xyXG4gICAgICB2YXIgZGF0YUxlbmd0aEluY2x1ZGluZ0FkZE5ldyA9IGdldERhdGFMZW5ndGhJbmNsdWRpbmdBZGROZXcoKTtcclxuICAgICAgdmFyIG51bWJlck9mUm93cyA9IGRhdGFMZW5ndGhJbmNsdWRpbmdBZGROZXcgK1xyXG4gICAgICAgICAgKG9wdGlvbnMubGVhdmVTcGFjZUZvck5ld1Jvd3MgPyBudW1WaXNpYmxlUm93cyAtIDEgOiAwKTtcclxuXHJcbiAgICAgIHZhciBvbGRWaWV3cG9ydEhhc1ZTY3JvbGwgPSB2aWV3cG9ydEhhc1ZTY3JvbGw7XHJcbiAgICAgIC8vIHdpdGggYXV0b0hlaWdodCwgd2UgZG8gbm90IG5lZWQgdG8gYWNjb21tb2RhdGUgdGhlIHZlcnRpY2FsIHNjcm9sbCBiYXJcclxuICAgICAgdmlld3BvcnRIYXNWU2Nyb2xsID0gb3B0aW9ucy5hbHdheXNTaG93VmVydGljYWxTY3JvbGwgfHwgIW9wdGlvbnMuYXV0b0hlaWdodCAmJiAobnVtYmVyT2ZSb3dzICogb3B0aW9ucy5yb3dIZWlnaHQgPiB2aWV3cG9ydEgpO1xyXG4gICAgICB2aWV3cG9ydEhhc0hTY3JvbGwgPSAoY2FudmFzV2lkdGggPiB2aWV3cG9ydFcgLSBzY3JvbGxiYXJEaW1lbnNpb25zLndpZHRoKTtcclxuXHJcbiAgICAgIG1ha2VBY3RpdmVDZWxsTm9ybWFsKCk7XHJcblxyXG4gICAgICAvLyByZW1vdmUgdGhlIHJvd3MgdGhhdCBhcmUgbm93IG91dHNpZGUgb2YgdGhlIGRhdGEgcmFuZ2VcclxuICAgICAgLy8gdGhpcyBoZWxwcyBhdm9pZCByZWR1bmRhbnQgY2FsbHMgdG8gLnJlbW92ZVJvdygpIHdoZW4gdGhlIHNpemUgb2YgdGhlIGRhdGEgZGVjcmVhc2VkIGJ5IHRob3VzYW5kcyBvZiByb3dzXHJcbiAgICAgIHZhciByMSA9IGRhdGFMZW5ndGggLSAxO1xyXG4gICAgICBmb3IgKHZhciBpIGluIHJvd3NDYWNoZSkge1xyXG4gICAgICAgIGlmIChpID4gcjEpIHtcclxuICAgICAgICAgIHJlbW92ZVJvd0Zyb21DYWNoZShpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKG9wdGlvbnMuZW5hYmxlQXN5bmNQb3N0UmVuZGVyQ2xlYW51cCkgeyBzdGFydFBvc3RQcm9jZXNzaW5nQ2xlYW51cCgpOyB9XHJcblxyXG4gICAgICBpZiAoYWN0aXZlQ2VsbE5vZGUgJiYgYWN0aXZlUm93ID4gcjEpIHtcclxuICAgICAgICByZXNldEFjdGl2ZUNlbGwoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIG9sZEggPSBoO1xyXG4gICAgICB0aCA9IE1hdGgubWF4KG9wdGlvbnMucm93SGVpZ2h0ICogbnVtYmVyT2ZSb3dzLCB2aWV3cG9ydEggLSBzY3JvbGxiYXJEaW1lbnNpb25zLmhlaWdodCk7XHJcbiAgICAgIGlmICh0aCA8IG1heFN1cHBvcnRlZENzc0hlaWdodCkge1xyXG4gICAgICAgIC8vIGp1c3Qgb25lIHBhZ2VcclxuICAgICAgICBoID0gcGggPSB0aDtcclxuICAgICAgICBuID0gMTtcclxuICAgICAgICBjaiA9IDA7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gYnJlYWsgaW50byBwYWdlc1xyXG4gICAgICAgIGggPSBtYXhTdXBwb3J0ZWRDc3NIZWlnaHQ7XHJcbiAgICAgICAgcGggPSBoIC8gMTAwO1xyXG4gICAgICAgIG4gPSBNYXRoLmZsb29yKHRoIC8gcGgpO1xyXG4gICAgICAgIGNqID0gKHRoIC0gaCkgLyAobiAtIDEpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaCAhPT0gb2xkSCkge1xyXG4gICAgICAgICRjYW52YXMuY3NzKFwiaGVpZ2h0XCIsIGgpO1xyXG4gICAgICAgIHNjcm9sbFRvcCA9ICR2aWV3cG9ydFswXS5zY3JvbGxUb3A7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBvbGRTY3JvbGxUb3BJblJhbmdlID0gKHNjcm9sbFRvcCArIG9mZnNldCA8PSB0aCAtIHZpZXdwb3J0SCk7XHJcblxyXG4gICAgICBpZiAodGggPT0gMCB8fCBzY3JvbGxUb3AgPT0gMCkge1xyXG4gICAgICAgIHBhZ2UgPSBvZmZzZXQgPSAwO1xyXG4gICAgICB9IGVsc2UgaWYgKG9sZFNjcm9sbFRvcEluUmFuZ2UpIHtcclxuICAgICAgICAvLyBtYWludGFpbiB2aXJ0dWFsIHBvc2l0aW9uXHJcbiAgICAgICAgc2Nyb2xsVG8oc2Nyb2xsVG9wICsgb2Zmc2V0KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBzY3JvbGwgdG8gYm90dG9tXHJcbiAgICAgICAgc2Nyb2xsVG8odGggLSB2aWV3cG9ydEgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaCAhPSBvbGRIICYmIG9wdGlvbnMuYXV0b0hlaWdodCkge1xyXG4gICAgICAgIHJlc2l6ZUNhbnZhcygpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAob3B0aW9ucy5mb3JjZUZpdENvbHVtbnMgJiYgb2xkVmlld3BvcnRIYXNWU2Nyb2xsICE9IHZpZXdwb3J0SGFzVlNjcm9sbCkge1xyXG4gICAgICAgIGF1dG9zaXplQ29sdW1ucygpO1xyXG4gICAgICB9XHJcbiAgICAgIHVwZGF0ZUNhbnZhc1dpZHRoKGZhbHNlKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRWaXNpYmxlUmFuZ2Uodmlld3BvcnRUb3AsIHZpZXdwb3J0TGVmdCkge1xyXG4gICAgICBpZiAodmlld3BvcnRUb3AgPT0gbnVsbCkge1xyXG4gICAgICAgIHZpZXdwb3J0VG9wID0gc2Nyb2xsVG9wO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh2aWV3cG9ydExlZnQgPT0gbnVsbCkge1xyXG4gICAgICAgIHZpZXdwb3J0TGVmdCA9IHNjcm9sbExlZnQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdG9wOiBnZXRSb3dGcm9tUG9zaXRpb24odmlld3BvcnRUb3ApLFxyXG4gICAgICAgIGJvdHRvbTogZ2V0Um93RnJvbVBvc2l0aW9uKHZpZXdwb3J0VG9wICsgdmlld3BvcnRIKSArIDEsXHJcbiAgICAgICAgbGVmdFB4OiB2aWV3cG9ydExlZnQsXHJcbiAgICAgICAgcmlnaHRQeDogdmlld3BvcnRMZWZ0ICsgdmlld3BvcnRXXHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0UmVuZGVyZWRSYW5nZSh2aWV3cG9ydFRvcCwgdmlld3BvcnRMZWZ0KSB7XHJcbiAgICAgIHZhciByYW5nZSA9IGdldFZpc2libGVSYW5nZSh2aWV3cG9ydFRvcCwgdmlld3BvcnRMZWZ0KTtcclxuICAgICAgdmFyIGJ1ZmZlciA9IE1hdGgucm91bmQodmlld3BvcnRIIC8gb3B0aW9ucy5yb3dIZWlnaHQpO1xyXG4gICAgICB2YXIgbWluQnVmZmVyID0gb3B0aW9ucy5taW5Sb3dCdWZmZXI7XHJcblxyXG4gICAgICBpZiAodlNjcm9sbERpciA9PSAtMSkge1xyXG4gICAgICAgIHJhbmdlLnRvcCAtPSBidWZmZXI7XHJcbiAgICAgICAgcmFuZ2UuYm90dG9tICs9IG1pbkJ1ZmZlcjtcclxuICAgICAgfSBlbHNlIGlmICh2U2Nyb2xsRGlyID09IDEpIHtcclxuICAgICAgICByYW5nZS50b3AgLT0gbWluQnVmZmVyO1xyXG4gICAgICAgIHJhbmdlLmJvdHRvbSArPSBidWZmZXI7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmFuZ2UudG9wIC09IG1pbkJ1ZmZlcjtcclxuICAgICAgICByYW5nZS5ib3R0b20gKz0gbWluQnVmZmVyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByYW5nZS50b3AgPSBNYXRoLm1heCgwLCByYW5nZS50b3ApO1xyXG4gICAgICByYW5nZS5ib3R0b20gPSBNYXRoLm1pbihnZXREYXRhTGVuZ3RoSW5jbHVkaW5nQWRkTmV3KCkgLSAxLCByYW5nZS5ib3R0b20pO1xyXG5cclxuICAgICAgcmFuZ2UubGVmdFB4IC09IHZpZXdwb3J0VztcclxuICAgICAgcmFuZ2UucmlnaHRQeCArPSB2aWV3cG9ydFc7XHJcblxyXG4gICAgICByYW5nZS5sZWZ0UHggPSBNYXRoLm1heCgwLCByYW5nZS5sZWZ0UHgpO1xyXG4gICAgICByYW5nZS5yaWdodFB4ID0gTWF0aC5taW4oY2FudmFzV2lkdGgsIHJhbmdlLnJpZ2h0UHgpO1xyXG5cclxuICAgICAgcmV0dXJuIHJhbmdlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGVuc3VyZUNlbGxOb2Rlc0luUm93c0NhY2hlKHJvdykge1xyXG4gICAgICB2YXIgY2FjaGVFbnRyeSA9IHJvd3NDYWNoZVtyb3ddO1xyXG4gICAgICBpZiAoY2FjaGVFbnRyeSkge1xyXG4gICAgICAgIGlmIChjYWNoZUVudHJ5LmNlbGxSZW5kZXJRdWV1ZS5sZW5ndGgpIHtcclxuICAgICAgICAgIHZhciBsYXN0Q2hpbGQgPSBjYWNoZUVudHJ5LnJvd05vZGUubGFzdENoaWxkO1xyXG4gICAgICAgICAgd2hpbGUgKGNhY2hlRW50cnkuY2VsbFJlbmRlclF1ZXVlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB2YXIgY29sdW1uSWR4ID0gY2FjaGVFbnRyeS5jZWxsUmVuZGVyUXVldWUucG9wKCk7XHJcbiAgICAgICAgICAgIGNhY2hlRW50cnkuY2VsbE5vZGVzQnlDb2x1bW5JZHhbY29sdW1uSWR4XSA9IGxhc3RDaGlsZDtcclxuICAgICAgICAgICAgbGFzdENoaWxkID0gbGFzdENoaWxkLnByZXZpb3VzU2libGluZztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjbGVhblVwQ2VsbHMocmFuZ2UsIHJvdykge1xyXG4gICAgICB2YXIgdG90YWxDZWxsc1JlbW92ZWQgPSAwO1xyXG4gICAgICB2YXIgY2FjaGVFbnRyeSA9IHJvd3NDYWNoZVtyb3ddO1xyXG5cclxuICAgICAgLy8gUmVtb3ZlIGNlbGxzIG91dHNpZGUgdGhlIHJhbmdlLlxyXG4gICAgICB2YXIgY2VsbHNUb1JlbW92ZSA9IFtdO1xyXG4gICAgICBmb3IgKHZhciBpIGluIGNhY2hlRW50cnkuY2VsbE5vZGVzQnlDb2x1bW5JZHgpIHtcclxuICAgICAgICAvLyBJIHJlYWxseSBoYXRlIGl0IHdoZW4gcGVvcGxlIG1lc3Mgd2l0aCBBcnJheS5wcm90b3R5cGUuXHJcbiAgICAgICAgaWYgKCFjYWNoZUVudHJ5LmNlbGxOb2Rlc0J5Q29sdW1uSWR4Lmhhc093blByb3BlcnR5KGkpKSB7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRoaXMgaXMgYSBzdHJpbmcsIHNvIGl0IG5lZWRzIHRvIGJlIGNhc3QgYmFjayB0byBhIG51bWJlci5cclxuICAgICAgICBpID0gaSB8IDA7XHJcblxyXG4gICAgICAgIHZhciBjb2xzcGFuID0gY2FjaGVFbnRyeS5jZWxsQ29sU3BhbnNbaV07XHJcbiAgICAgICAgaWYgKGNvbHVtblBvc0xlZnRbaV0gPiByYW5nZS5yaWdodFB4IHx8XHJcbiAgICAgICAgICBjb2x1bW5Qb3NSaWdodFtNYXRoLm1pbihjb2x1bW5zLmxlbmd0aCAtIDEsIGkgKyBjb2xzcGFuIC0gMSldIDwgcmFuZ2UubGVmdFB4KSB7XHJcbiAgICAgICAgICBpZiAoIShyb3cgPT0gYWN0aXZlUm93ICYmIGkgPT0gYWN0aXZlQ2VsbCkpIHtcclxuICAgICAgICAgICAgY2VsbHNUb1JlbW92ZS5wdXNoKGkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGNlbGxUb1JlbW92ZSwgbm9kZTtcclxuICAgICAgcG9zdFByb2Nlc3Nncm91cElkKys7XHJcbiAgICAgIHdoaWxlICgoY2VsbFRvUmVtb3ZlID0gY2VsbHNUb1JlbW92ZS5wb3AoKSkgIT0gbnVsbCkge1xyXG4gICAgICAgIG5vZGUgPSBjYWNoZUVudHJ5LmNlbGxOb2Rlc0J5Q29sdW1uSWR4W2NlbGxUb1JlbW92ZV07XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuZW5hYmxlQXN5bmNQb3N0UmVuZGVyQ2xlYW51cCAmJiBwb3N0UHJvY2Vzc2VkUm93c1tyb3ddICYmIHBvc3RQcm9jZXNzZWRSb3dzW3Jvd11bY2VsbFRvUmVtb3ZlXSkge1xyXG4gICAgICAgICAgcXVldWVQb3N0UHJvY2Vzc2VkQ2VsbEZvckNsZWFudXAobm9kZSwgY2VsbFRvUmVtb3ZlLCByb3cpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjYWNoZUVudHJ5LnJvd05vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkZWxldGUgY2FjaGVFbnRyeS5jZWxsQ29sU3BhbnNbY2VsbFRvUmVtb3ZlXTtcclxuICAgICAgICBkZWxldGUgY2FjaGVFbnRyeS5jZWxsTm9kZXNCeUNvbHVtbklkeFtjZWxsVG9SZW1vdmVdO1xyXG4gICAgICAgIGlmIChwb3N0UHJvY2Vzc2VkUm93c1tyb3ddKSB7XHJcbiAgICAgICAgICBkZWxldGUgcG9zdFByb2Nlc3NlZFJvd3Nbcm93XVtjZWxsVG9SZW1vdmVdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0b3RhbENlbGxzUmVtb3ZlZCsrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY2xlYW5VcEFuZFJlbmRlckNlbGxzKHJhbmdlKSB7XHJcbiAgICAgIHZhciBjYWNoZUVudHJ5O1xyXG4gICAgICB2YXIgc3RyaW5nQXJyYXkgPSBbXTtcclxuICAgICAgdmFyIHByb2Nlc3NlZFJvd3MgPSBbXTtcclxuICAgICAgdmFyIGNlbGxzQWRkZWQ7XHJcbiAgICAgIHZhciB0b3RhbENlbGxzQWRkZWQgPSAwO1xyXG4gICAgICB2YXIgY29sc3BhbjtcclxuXHJcbiAgICAgIGZvciAodmFyIHJvdyA9IHJhbmdlLnRvcCwgYnRtID0gcmFuZ2UuYm90dG9tOyByb3cgPD0gYnRtOyByb3crKykge1xyXG4gICAgICAgIGNhY2hlRW50cnkgPSByb3dzQ2FjaGVbcm93XTtcclxuICAgICAgICBpZiAoIWNhY2hlRW50cnkpIHtcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gY2VsbFJlbmRlclF1ZXVlIHBvcHVsYXRlZCBpbiByZW5kZXJSb3dzKCkgbmVlZHMgdG8gYmUgY2xlYXJlZCBmaXJzdFxyXG4gICAgICAgIGVuc3VyZUNlbGxOb2Rlc0luUm93c0NhY2hlKHJvdyk7XHJcblxyXG4gICAgICAgIGNsZWFuVXBDZWxscyhyYW5nZSwgcm93KTtcclxuXHJcbiAgICAgICAgLy8gUmVuZGVyIG1pc3NpbmcgY2VsbHMuXHJcbiAgICAgICAgY2VsbHNBZGRlZCA9IDA7XHJcblxyXG4gICAgICAgIHZhciBtZXRhZGF0YSA9IGRhdGEuZ2V0SXRlbU1ldGFkYXRhICYmIGRhdGEuZ2V0SXRlbU1ldGFkYXRhKHJvdyk7XHJcbiAgICAgICAgbWV0YWRhdGEgPSBtZXRhZGF0YSAmJiBtZXRhZGF0YS5jb2x1bW5zO1xyXG5cclxuICAgICAgICB2YXIgZCA9IGdldERhdGFJdGVtKHJvdyk7XHJcblxyXG4gICAgICAgIC8vIFRPRE86ICBzaG9ydGVuIHRoaXMgbG9vcCAoaW5kZXg/IGhldXJpc3RpY3M/IGJpbmFyeSBzZWFyY2g/KVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGNvbHVtbnMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xyXG4gICAgICAgICAgLy8gQ2VsbHMgdG8gdGhlIHJpZ2h0IGFyZSBvdXRzaWRlIHRoZSByYW5nZS5cclxuICAgICAgICAgIGlmIChjb2x1bW5Qb3NMZWZ0W2ldID4gcmFuZ2UucmlnaHRQeCkge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBBbHJlYWR5IHJlbmRlcmVkLlxyXG4gICAgICAgICAgaWYgKChjb2xzcGFuID0gY2FjaGVFbnRyeS5jZWxsQ29sU3BhbnNbaV0pICE9IG51bGwpIHtcclxuICAgICAgICAgICAgaSArPSAoY29sc3BhbiA+IDEgPyBjb2xzcGFuIC0gMSA6IDApO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBjb2xzcGFuID0gMTtcclxuICAgICAgICAgIGlmIChtZXRhZGF0YSkge1xyXG4gICAgICAgICAgICB2YXIgY29sdW1uRGF0YSA9IG1ldGFkYXRhW2NvbHVtbnNbaV0uaWRdIHx8IG1ldGFkYXRhW2ldO1xyXG4gICAgICAgICAgICBjb2xzcGFuID0gKGNvbHVtbkRhdGEgJiYgY29sdW1uRGF0YS5jb2xzcGFuKSB8fCAxO1xyXG4gICAgICAgICAgICBpZiAoY29sc3BhbiA9PT0gXCIqXCIpIHtcclxuICAgICAgICAgICAgICBjb2xzcGFuID0gaWkgLSBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKGNvbHVtblBvc1JpZ2h0W01hdGgubWluKGlpIC0gMSwgaSArIGNvbHNwYW4gLSAxKV0gPiByYW5nZS5sZWZ0UHgpIHtcclxuICAgICAgICAgICAgYXBwZW5kQ2VsbEh0bWwoc3RyaW5nQXJyYXksIHJvdywgaSwgY29sc3BhbiwgZCk7XHJcbiAgICAgICAgICAgIGNlbGxzQWRkZWQrKztcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpICs9IChjb2xzcGFuID4gMSA/IGNvbHNwYW4gLSAxIDogMCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY2VsbHNBZGRlZCkge1xyXG4gICAgICAgICAgdG90YWxDZWxsc0FkZGVkICs9IGNlbGxzQWRkZWQ7XHJcbiAgICAgICAgICBwcm9jZXNzZWRSb3dzLnB1c2gocm93KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghc3RyaW5nQXJyYXkubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgeCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgIHguaW5uZXJIVE1MID0gc3RyaW5nQXJyYXkuam9pbihcIlwiKTtcclxuXHJcbiAgICAgIHZhciBwcm9jZXNzZWRSb3c7XHJcbiAgICAgIHZhciBub2RlO1xyXG4gICAgICB3aGlsZSAoKHByb2Nlc3NlZFJvdyA9IHByb2Nlc3NlZFJvd3MucG9wKCkpICE9IG51bGwpIHtcclxuICAgICAgICBjYWNoZUVudHJ5ID0gcm93c0NhY2hlW3Byb2Nlc3NlZFJvd107XHJcbiAgICAgICAgdmFyIGNvbHVtbklkeDtcclxuICAgICAgICB3aGlsZSAoKGNvbHVtbklkeCA9IGNhY2hlRW50cnkuY2VsbFJlbmRlclF1ZXVlLnBvcCgpKSAhPSBudWxsKSB7XHJcbiAgICAgICAgICBub2RlID0geC5sYXN0Q2hpbGQ7XHJcbiAgICAgICAgICBjYWNoZUVudHJ5LnJvd05vZGUuYXBwZW5kQ2hpbGQobm9kZSk7XHJcbiAgICAgICAgICBjYWNoZUVudHJ5LmNlbGxOb2Rlc0J5Q29sdW1uSWR4W2NvbHVtbklkeF0gPSBub2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlbmRlclJvd3MocmFuZ2UpIHtcclxuICAgICAgdmFyIHBhcmVudE5vZGUgPSAkY2FudmFzWzBdLFxyXG4gICAgICAgICAgc3RyaW5nQXJyYXkgPSBbXSxcclxuICAgICAgICAgIHJvd3MgPSBbXSxcclxuICAgICAgICAgIG5lZWRUb1Jlc2VsZWN0Q2VsbCA9IGZhbHNlLFxyXG4gICAgICAgICAgZGF0YUxlbmd0aCA9IGdldERhdGFMZW5ndGgoKTtcclxuXHJcbiAgICAgIGZvciAodmFyIGkgPSByYW5nZS50b3AsIGlpID0gcmFuZ2UuYm90dG9tOyBpIDw9IGlpOyBpKyspIHtcclxuICAgICAgICBpZiAocm93c0NhY2hlW2ldKSB7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVuZGVyZWRSb3dzKys7XHJcbiAgICAgICAgcm93cy5wdXNoKGkpO1xyXG5cclxuICAgICAgICAvLyBDcmVhdGUgYW4gZW50cnkgcmlnaHQgYXdheSBzbyB0aGF0IGFwcGVuZFJvd0h0bWwoKSBjYW5cclxuICAgICAgICAvLyBzdGFydCBwb3B1bGF0YXRpbmcgaXQuXHJcbiAgICAgICAgcm93c0NhY2hlW2ldID0ge1xyXG4gICAgICAgICAgXCJyb3dOb2RlXCI6IG51bGwsXHJcblxyXG4gICAgICAgICAgLy8gQ29sU3BhbnMgb2YgcmVuZGVyZWQgY2VsbHMgKGJ5IGNvbHVtbiBpZHgpLlxyXG4gICAgICAgICAgLy8gQ2FuIGFsc28gYmUgdXNlZCBmb3IgY2hlY2tpbmcgd2hldGhlciBhIGNlbGwgaGFzIGJlZW4gcmVuZGVyZWQuXHJcbiAgICAgICAgICBcImNlbGxDb2xTcGFuc1wiOiBbXSxcclxuXHJcbiAgICAgICAgICAvLyBDZWxsIG5vZGVzIChieSBjb2x1bW4gaWR4KS4gIExhenktcG9wdWxhdGVkIGJ5IGVuc3VyZUNlbGxOb2Rlc0luUm93c0NhY2hlKCkuXHJcbiAgICAgICAgICBcImNlbGxOb2Rlc0J5Q29sdW1uSWR4XCI6IFtdLFxyXG5cclxuICAgICAgICAgIC8vIENvbHVtbiBpbmRpY2VzIG9mIGNlbGwgbm9kZXMgdGhhdCBoYXZlIGJlZW4gcmVuZGVyZWQsIGJ1dCBub3QgeWV0IGluZGV4ZWQgaW5cclxuICAgICAgICAgIC8vIGNlbGxOb2Rlc0J5Q29sdW1uSWR4LiAgVGhlc2UgYXJlIGluIHRoZSBzYW1lIG9yZGVyIGFzIGNlbGwgbm9kZXMgYWRkZWQgYXQgdGhlXHJcbiAgICAgICAgICAvLyBlbmQgb2YgdGhlIHJvdy5cclxuICAgICAgICAgIFwiY2VsbFJlbmRlclF1ZXVlXCI6IFtdXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgYXBwZW5kUm93SHRtbChzdHJpbmdBcnJheSwgaSwgcmFuZ2UsIGRhdGFMZW5ndGgpO1xyXG4gICAgICAgIGlmIChhY3RpdmVDZWxsTm9kZSAmJiBhY3RpdmVSb3cgPT09IGkpIHtcclxuICAgICAgICAgIG5lZWRUb1Jlc2VsZWN0Q2VsbCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvdW50ZXJfcm93c19yZW5kZXJlZCsrO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIXJvd3MubGVuZ3RoKSB7IHJldHVybjsgfVxyXG5cclxuICAgICAgdmFyIHggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICB4LmlubmVySFRNTCA9IHN0cmluZ0FycmF5LmpvaW4oXCJcIik7XHJcblxyXG4gICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSByb3dzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcclxuICAgICAgICByb3dzQ2FjaGVbcm93c1tpXV0ucm93Tm9kZSA9IHBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoeC5maXJzdENoaWxkKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG5lZWRUb1Jlc2VsZWN0Q2VsbCkge1xyXG4gICAgICAgIGFjdGl2ZUNlbGxOb2RlID0gZ2V0Q2VsbE5vZGUoYWN0aXZlUm93LCBhY3RpdmVDZWxsKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHN0YXJ0UG9zdFByb2Nlc3NpbmcoKSB7XHJcbiAgICAgIGlmICghb3B0aW9ucy5lbmFibGVBc3luY1Bvc3RSZW5kZXIpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgY2xlYXJUaW1lb3V0KGhfcG9zdHJlbmRlcik7XHJcbiAgICAgIGhfcG9zdHJlbmRlciA9IHNldFRpbWVvdXQoYXN5bmNQb3N0UHJvY2Vzc1Jvd3MsIG9wdGlvbnMuYXN5bmNQb3N0UmVuZGVyRGVsYXkpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHN0YXJ0UG9zdFByb2Nlc3NpbmdDbGVhbnVwKCkge1xyXG4gICAgICBpZiAoIW9wdGlvbnMuZW5hYmxlQXN5bmNQb3N0UmVuZGVyQ2xlYW51cCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBjbGVhclRpbWVvdXQoaF9wb3N0cmVuZGVyQ2xlYW51cCk7XHJcbiAgICAgIGhfcG9zdHJlbmRlckNsZWFudXAgPSBzZXRUaW1lb3V0KGFzeW5jUG9zdFByb2Nlc3NDbGVhbnVwUm93cywgb3B0aW9ucy5hc3luY1Bvc3RSZW5kZXJDbGVhbnVwRGVsYXkpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGludmFsaWRhdGVQb3N0UHJvY2Vzc2luZ1Jlc3VsdHMocm93KSB7XHJcbiAgICAgIC8vIGNoYW5nZSBzdGF0dXMgb2YgY29sdW1ucyB0byBiZSByZS1yZW5kZXJlZFxyXG4gICAgICBmb3IgKHZhciBjb2x1bW5JZHggaW4gcG9zdFByb2Nlc3NlZFJvd3Nbcm93XSkge1xyXG4gICAgICAgIGlmIChwb3N0UHJvY2Vzc2VkUm93c1tyb3ddLmhhc093blByb3BlcnR5KGNvbHVtbklkeCkpIHtcclxuICAgICAgICAgIHBvc3RQcm9jZXNzZWRSb3dzW3Jvd11bY29sdW1uSWR4XSA9ICdDJztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcG9zdFByb2Nlc3NGcm9tUm93ID0gTWF0aC5taW4ocG9zdFByb2Nlc3NGcm9tUm93LCByb3cpO1xyXG4gICAgICBwb3N0UHJvY2Vzc1RvUm93ID0gTWF0aC5tYXgocG9zdFByb2Nlc3NUb1Jvdywgcm93KTtcclxuICAgICAgc3RhcnRQb3N0UHJvY2Vzc2luZygpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZVJvd1Bvc2l0aW9ucygpIHtcclxuICAgICAgZm9yICh2YXIgcm93IGluIHJvd3NDYWNoZSkge1xyXG4gICAgICAgIHJvd3NDYWNoZVtyb3ddLnJvd05vZGUuc3R5bGUudG9wID0gZ2V0Um93VG9wKHJvdykgKyBcInB4XCI7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZW5kZXIoKSB7XHJcbiAgICAgIGlmICghaW5pdGlhbGl6ZWQpIHsgcmV0dXJuOyB9XHJcbiAgICAgIHZhciB2aXNpYmxlID0gZ2V0VmlzaWJsZVJhbmdlKCk7XHJcbiAgICAgIHZhciByZW5kZXJlZCA9IGdldFJlbmRlcmVkUmFuZ2UoKTtcclxuXHJcbiAgICAgIC8vIHJlbW92ZSByb3dzIG5vIGxvbmdlciBpbiB0aGUgdmlld3BvcnRcclxuICAgICAgY2xlYW51cFJvd3MocmVuZGVyZWQpO1xyXG5cclxuICAgICAgLy8gYWRkIG5ldyByb3dzICYgbWlzc2luZyBjZWxscyBpbiBleGlzdGluZyByb3dzXHJcbiAgICAgIGlmIChsYXN0UmVuZGVyZWRTY3JvbGxMZWZ0ICE9IHNjcm9sbExlZnQpIHtcclxuICAgICAgICBjbGVhblVwQW5kUmVuZGVyQ2VsbHMocmVuZGVyZWQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyByZW5kZXIgbWlzc2luZyByb3dzXHJcbiAgICAgIHJlbmRlclJvd3MocmVuZGVyZWQpO1xyXG5cclxuICAgICAgcG9zdFByb2Nlc3NGcm9tUm93ID0gdmlzaWJsZS50b3A7XHJcbiAgICAgIHBvc3RQcm9jZXNzVG9Sb3cgPSBNYXRoLm1pbihnZXREYXRhTGVuZ3RoSW5jbHVkaW5nQWRkTmV3KCkgLSAxLCB2aXNpYmxlLmJvdHRvbSk7XHJcbiAgICAgIHN0YXJ0UG9zdFByb2Nlc3NpbmcoKTtcclxuXHJcbiAgICAgIGxhc3RSZW5kZXJlZFNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcclxuICAgICAgbGFzdFJlbmRlcmVkU2Nyb2xsTGVmdCA9IHNjcm9sbExlZnQ7XHJcbiAgICAgIGhfcmVuZGVyID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVIZWFkZXJTY3JvbGwoKSB7XHJcbiAgICAgIGhhbmRsZUVsZW1lbnRTY3JvbGwoJGhlYWRlclNjcm9sbGVyWzBdKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVIZWFkZXJSb3dTY3JvbGwoKSB7XHJcbiAgICAgIGhhbmRsZUVsZW1lbnRTY3JvbGwoJGhlYWRlclJvd1Njcm9sbGVyWzBdKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVGb290ZXJSb3dTY3JvbGwoKSB7XHJcbiAgICAgIGhhbmRsZUVsZW1lbnRTY3JvbGwoJGZvb3RlclJvd1Njcm9sbGVyWzBdKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVQcmVIZWFkZXJQYW5lbFNjcm9sbCgpIHtcclxuICAgICAgaGFuZGxlRWxlbWVudFNjcm9sbCgkcHJlSGVhZGVyUGFuZWxTY3JvbGxlclswXSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaGFuZGxlRWxlbWVudFNjcm9sbChlbGVtZW50KSB7XHJcbiAgICAgIHZhciBzY3JvbGxMZWZ0ID0gZWxlbWVudC5zY3JvbGxMZWZ0O1xyXG4gICAgICBpZiAoc2Nyb2xsTGVmdCAhPSAkdmlld3BvcnRbMF0uc2Nyb2xsTGVmdCkge1xyXG4gICAgICAgICR2aWV3cG9ydFswXS5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGhhbmRsZVNjcm9sbCgpIHtcclxuICAgICAgc2Nyb2xsVG9wID0gJHZpZXdwb3J0WzBdLnNjcm9sbFRvcDtcclxuICAgICAgc2Nyb2xsTGVmdCA9ICR2aWV3cG9ydFswXS5zY3JvbGxMZWZ0O1xyXG4gICAgICB2YXIgdlNjcm9sbERpc3QgPSBNYXRoLmFicyhzY3JvbGxUb3AgLSBwcmV2U2Nyb2xsVG9wKTtcclxuICAgICAgdmFyIGhTY3JvbGxEaXN0ID0gTWF0aC5hYnMoc2Nyb2xsTGVmdCAtIHByZXZTY3JvbGxMZWZ0KTtcclxuXHJcbiAgICAgIGlmIChoU2Nyb2xsRGlzdCkge1xyXG4gICAgICAgIHByZXZTY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdDtcclxuICAgICAgICAkaGVhZGVyU2Nyb2xsZXJbMF0uc2Nyb2xsTGVmdCA9IHNjcm9sbExlZnQ7XHJcbiAgICAgICAgJHRvcFBhbmVsU2Nyb2xsZXJbMF0uc2Nyb2xsTGVmdCA9IHNjcm9sbExlZnQ7XHJcbiAgICAgICAgJGhlYWRlclJvd1Njcm9sbGVyWzBdLnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0O1xyXG4gICAgICAgIGlmIChvcHRpb25zLmNyZWF0ZUZvb3RlclJvdykge1xyXG4gICAgICAgICAgJGZvb3RlclJvd1Njcm9sbGVyWzBdLnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0aW9ucy5jcmVhdGVQcmVIZWFkZXJQYW5lbCkge1xyXG4gICAgICAgICAgJHByZUhlYWRlclBhbmVsU2Nyb2xsZXJbMF0uc2Nyb2xsTGVmdCA9IHNjcm9sbExlZnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodlNjcm9sbERpc3QpIHtcclxuICAgICAgICB2U2Nyb2xsRGlyID0gcHJldlNjcm9sbFRvcCA8IHNjcm9sbFRvcCA/IDEgOiAtMTtcclxuICAgICAgICBwcmV2U2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xyXG5cclxuICAgICAgICAvLyBzd2l0Y2ggdmlydHVhbCBwYWdlcyBpZiBuZWVkZWRcclxuICAgICAgICBpZiAodlNjcm9sbERpc3QgPCB2aWV3cG9ydEgpIHtcclxuICAgICAgICAgIHNjcm9sbFRvKHNjcm9sbFRvcCArIG9mZnNldCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHZhciBvbGRPZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgICBpZiAoaCA9PSB2aWV3cG9ydEgpIHtcclxuICAgICAgICAgICAgcGFnZSA9IDA7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBwYWdlID0gTWF0aC5taW4obiAtIDEsIE1hdGguZmxvb3Ioc2Nyb2xsVG9wICogKCh0aCAtIHZpZXdwb3J0SCkgLyAoaCAtIHZpZXdwb3J0SCkpICogKDEgLyBwaCkpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIG9mZnNldCA9IE1hdGgucm91bmQocGFnZSAqIGNqKTtcclxuICAgICAgICAgIGlmIChvbGRPZmZzZXQgIT0gb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIGludmFsaWRhdGVBbGxSb3dzKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaFNjcm9sbERpc3QgfHwgdlNjcm9sbERpc3QpIHtcclxuICAgICAgICBpZiAoaF9yZW5kZXIpIHtcclxuICAgICAgICAgIGNsZWFyVGltZW91dChoX3JlbmRlcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoTWF0aC5hYnMobGFzdFJlbmRlcmVkU2Nyb2xsVG9wIC0gc2Nyb2xsVG9wKSA+IDIwIHx8XHJcbiAgICAgICAgICAgIE1hdGguYWJzKGxhc3RSZW5kZXJlZFNjcm9sbExlZnQgLSBzY3JvbGxMZWZ0KSA+IDIwKSB7XHJcbiAgICAgICAgICBpZiAob3B0aW9ucy5mb3JjZVN5bmNTY3JvbGxpbmcgfHwgKFxyXG4gICAgICAgICAgICAgIE1hdGguYWJzKGxhc3RSZW5kZXJlZFNjcm9sbFRvcCAtIHNjcm9sbFRvcCkgPCB2aWV3cG9ydEggJiZcclxuICAgICAgICAgICAgICBNYXRoLmFicyhsYXN0UmVuZGVyZWRTY3JvbGxMZWZ0IC0gc2Nyb2xsTGVmdCkgPCB2aWV3cG9ydFcpKSB7XHJcbiAgICAgICAgICAgIHJlbmRlcigpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaF9yZW5kZXIgPSBzZXRUaW1lb3V0KHJlbmRlciwgNTApO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHRyaWdnZXIoc2VsZi5vblZpZXdwb3J0Q2hhbmdlZCwge2dyaWQ6IHNlbGZ9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRyaWdnZXIoc2VsZi5vblNjcm9sbCwge3Njcm9sbExlZnQ6IHNjcm9sbExlZnQsIHNjcm9sbFRvcDogc2Nyb2xsVG9wLCBncmlkOiBzZWxmfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYXN5bmNQb3N0UHJvY2Vzc1Jvd3MoKSB7XHJcbiAgICAgIHZhciBkYXRhTGVuZ3RoID0gZ2V0RGF0YUxlbmd0aCgpO1xyXG4gICAgICB3aGlsZSAocG9zdFByb2Nlc3NGcm9tUm93IDw9IHBvc3RQcm9jZXNzVG9Sb3cpIHtcclxuICAgICAgICB2YXIgcm93ID0gKHZTY3JvbGxEaXIgPj0gMCkgPyBwb3N0UHJvY2Vzc0Zyb21Sb3crKyA6IHBvc3RQcm9jZXNzVG9Sb3ctLTtcclxuICAgICAgICB2YXIgY2FjaGVFbnRyeSA9IHJvd3NDYWNoZVtyb3ddO1xyXG4gICAgICAgIGlmICghY2FjaGVFbnRyeSB8fCByb3cgPj0gZGF0YUxlbmd0aCkge1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXBvc3RQcm9jZXNzZWRSb3dzW3Jvd10pIHtcclxuICAgICAgICAgIHBvc3RQcm9jZXNzZWRSb3dzW3Jvd10gPSB7fTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGVuc3VyZUNlbGxOb2Rlc0luUm93c0NhY2hlKHJvdyk7XHJcbiAgICAgICAgZm9yICh2YXIgY29sdW1uSWR4IGluIGNhY2hlRW50cnkuY2VsbE5vZGVzQnlDb2x1bW5JZHgpIHtcclxuICAgICAgICAgIGlmICghY2FjaGVFbnRyeS5jZWxsTm9kZXNCeUNvbHVtbklkeC5oYXNPd25Qcm9wZXJ0eShjb2x1bW5JZHgpKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGNvbHVtbklkeCA9IGNvbHVtbklkeCB8IDA7XHJcblxyXG4gICAgICAgICAgdmFyIG0gPSBjb2x1bW5zW2NvbHVtbklkeF07XHJcbiAgICAgICAgICB2YXIgcHJvY2Vzc2VkU3RhdHVzID0gcG9zdFByb2Nlc3NlZFJvd3Nbcm93XVtjb2x1bW5JZHhdOyAvLyBDPWNsZWFudXAgYW5kIHJlLXJlbmRlciwgUj1yZW5kZXJlZFxyXG4gICAgICAgICAgaWYgKG0uYXN5bmNQb3N0UmVuZGVyICYmIHByb2Nlc3NlZFN0YXR1cyAhPT0gJ1InKSB7XHJcbiAgICAgICAgICAgIHZhciBub2RlID0gY2FjaGVFbnRyeS5jZWxsTm9kZXNCeUNvbHVtbklkeFtjb2x1bW5JZHhdO1xyXG4gICAgICAgICAgICBpZiAobm9kZSkge1xyXG4gICAgICAgICAgICAgIG0uYXN5bmNQb3N0UmVuZGVyKG5vZGUsIHJvdywgZ2V0RGF0YUl0ZW0ocm93KSwgbSwgKHByb2Nlc3NlZFN0YXR1cyA9PT0gJ0MnKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcG9zdFByb2Nlc3NlZFJvd3Nbcm93XVtjb2x1bW5JZHhdID0gJ1InO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaF9wb3N0cmVuZGVyID0gc2V0VGltZW91dChhc3luY1Bvc3RQcm9jZXNzUm93cywgb3B0aW9ucy5hc3luY1Bvc3RSZW5kZXJEZWxheSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYXN5bmNQb3N0UHJvY2Vzc0NsZWFudXBSb3dzKCkge1xyXG4gICAgICBpZiAocG9zdFByb2Nlc3NlZENsZWFudXBRdWV1ZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgdmFyIGdyb3VwSWQgPSBwb3N0UHJvY2Vzc2VkQ2xlYW51cFF1ZXVlWzBdLmdyb3VwSWQ7XHJcblxyXG4gICAgICAgIC8vIGxvb3AgdGhyb3VnaCBhbGwgcXVldWUgbWVtYmVycyB3aXRoIHRoaXMgZ3JvdXBJRFxyXG4gICAgICAgIHdoaWxlIChwb3N0UHJvY2Vzc2VkQ2xlYW51cFF1ZXVlLmxlbmd0aCA+IDAgJiYgcG9zdFByb2Nlc3NlZENsZWFudXBRdWV1ZVswXS5ncm91cElkID09IGdyb3VwSWQpIHtcclxuICAgICAgICAgIHZhciBlbnRyeSA9IHBvc3RQcm9jZXNzZWRDbGVhbnVwUXVldWUuc2hpZnQoKTtcclxuICAgICAgICAgIGlmIChlbnRyeS5hY3Rpb25UeXBlID09ICdSJykge1xyXG4gICAgICAgICAgICAkKGVudHJ5Lm5vZGUpLnJlbW92ZSgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGVudHJ5LmFjdGlvblR5cGUgPT0gJ0MnKSB7XHJcbiAgICAgICAgICAgIHZhciBjb2x1bW4gPSBjb2x1bW5zW2VudHJ5LmNvbHVtbklkeF07XHJcbiAgICAgICAgICAgIGlmIChjb2x1bW4uYXN5bmNQb3N0UmVuZGVyQ2xlYW51cCAmJiBlbnRyeS5ub2RlKSB7XHJcbiAgICAgICAgICAgICAgLy8gY2xlYW51cCBtdXN0IGFsc28gcmVtb3ZlIGVsZW1lbnRcclxuICAgICAgICAgICAgICBjb2x1bW4uYXN5bmNQb3N0UmVuZGVyQ2xlYW51cChlbnRyeS5ub2RlLCBlbnRyeS5yb3dJZHgsIGNvbHVtbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGNhbGwgdGhpcyBmdW5jdGlvbiBhZ2FpbiBhZnRlciB0aGUgc3BlY2lmaWVkIGRlbGF5XHJcbiAgICAgICAgaF9wb3N0cmVuZGVyQ2xlYW51cCA9IHNldFRpbWVvdXQoYXN5bmNQb3N0UHJvY2Vzc0NsZWFudXBSb3dzLCBvcHRpb25zLmFzeW5jUG9zdFJlbmRlckNsZWFudXBEZWxheSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB1cGRhdGVDZWxsQ3NzU3R5bGVzT25SZW5kZXJlZFJvd3MoYWRkZWRIYXNoLCByZW1vdmVkSGFzaCkge1xyXG4gICAgICB2YXIgbm9kZSwgY29sdW1uSWQsIGFkZGVkUm93SGFzaCwgcmVtb3ZlZFJvd0hhc2g7XHJcbiAgICAgIGZvciAodmFyIHJvdyBpbiByb3dzQ2FjaGUpIHtcclxuICAgICAgICByZW1vdmVkUm93SGFzaCA9IHJlbW92ZWRIYXNoICYmIHJlbW92ZWRIYXNoW3Jvd107XHJcbiAgICAgICAgYWRkZWRSb3dIYXNoID0gYWRkZWRIYXNoICYmIGFkZGVkSGFzaFtyb3ddO1xyXG5cclxuICAgICAgICBpZiAocmVtb3ZlZFJvd0hhc2gpIHtcclxuICAgICAgICAgIGZvciAoY29sdW1uSWQgaW4gcmVtb3ZlZFJvd0hhc2gpIHtcclxuICAgICAgICAgICAgaWYgKCFhZGRlZFJvd0hhc2ggfHwgcmVtb3ZlZFJvd0hhc2hbY29sdW1uSWRdICE9IGFkZGVkUm93SGFzaFtjb2x1bW5JZF0pIHtcclxuICAgICAgICAgICAgICBub2RlID0gZ2V0Q2VsbE5vZGUocm93LCBnZXRDb2x1bW5JbmRleChjb2x1bW5JZCkpO1xyXG4gICAgICAgICAgICAgIGlmIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAkKG5vZGUpLnJlbW92ZUNsYXNzKHJlbW92ZWRSb3dIYXNoW2NvbHVtbklkXSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYWRkZWRSb3dIYXNoKSB7XHJcbiAgICAgICAgICBmb3IgKGNvbHVtbklkIGluIGFkZGVkUm93SGFzaCkge1xyXG4gICAgICAgICAgICBpZiAoIXJlbW92ZWRSb3dIYXNoIHx8IHJlbW92ZWRSb3dIYXNoW2NvbHVtbklkXSAhPSBhZGRlZFJvd0hhc2hbY29sdW1uSWRdKSB7XHJcbiAgICAgICAgICAgICAgbm9kZSA9IGdldENlbGxOb2RlKHJvdywgZ2V0Q29sdW1uSW5kZXgoY29sdW1uSWQpKTtcclxuICAgICAgICAgICAgICBpZiAobm9kZSkge1xyXG4gICAgICAgICAgICAgICAgJChub2RlKS5hZGRDbGFzcyhhZGRlZFJvd0hhc2hbY29sdW1uSWRdKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhZGRDZWxsQ3NzU3R5bGVzKGtleSwgaGFzaCkge1xyXG4gICAgICBpZiAoY2VsbENzc0NsYXNzZXNba2V5XSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFkZENlbGxDc3NTdHlsZXM6IGNlbGwgQ1NTIGhhc2ggd2l0aCBrZXkgJ1wiICsga2V5ICsgXCInIGFscmVhZHkgZXhpc3RzLlwiKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY2VsbENzc0NsYXNzZXNba2V5XSA9IGhhc2g7XHJcbiAgICAgIHVwZGF0ZUNlbGxDc3NTdHlsZXNPblJlbmRlcmVkUm93cyhoYXNoLCBudWxsKTtcclxuXHJcbiAgICAgIHRyaWdnZXIoc2VsZi5vbkNlbGxDc3NTdHlsZXNDaGFuZ2VkLCB7IFwia2V5XCI6IGtleSwgXCJoYXNoXCI6IGhhc2gsIFwiZ3JpZFwiOiBzZWxmIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlbW92ZUNlbGxDc3NTdHlsZXMoa2V5KSB7XHJcbiAgICAgIGlmICghY2VsbENzc0NsYXNzZXNba2V5XSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdXBkYXRlQ2VsbENzc1N0eWxlc09uUmVuZGVyZWRSb3dzKG51bGwsIGNlbGxDc3NDbGFzc2VzW2tleV0pO1xyXG4gICAgICBkZWxldGUgY2VsbENzc0NsYXNzZXNba2V5XTtcclxuXHJcbiAgICAgIHRyaWdnZXIoc2VsZi5vbkNlbGxDc3NTdHlsZXNDaGFuZ2VkLCB7IFwia2V5XCI6IGtleSwgXCJoYXNoXCI6IG51bGwsIFwiZ3JpZFwiOiBzZWxmIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNldENlbGxDc3NTdHlsZXMoa2V5LCBoYXNoKSB7XHJcbiAgICAgIHZhciBwcmV2SGFzaCA9IGNlbGxDc3NDbGFzc2VzW2tleV07XHJcblxyXG4gICAgICBjZWxsQ3NzQ2xhc3Nlc1trZXldID0gaGFzaDtcclxuICAgICAgdXBkYXRlQ2VsbENzc1N0eWxlc09uUmVuZGVyZWRSb3dzKGhhc2gsIHByZXZIYXNoKTtcclxuXHJcbiAgICAgIHRyaWdnZXIoc2VsZi5vbkNlbGxDc3NTdHlsZXNDaGFuZ2VkLCB7IFwia2V5XCI6IGtleSwgXCJoYXNoXCI6IGhhc2gsIFwiZ3JpZFwiOiBzZWxmIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldENlbGxDc3NTdHlsZXMoa2V5KSB7XHJcbiAgICAgIHJldHVybiBjZWxsQ3NzQ2xhc3Nlc1trZXldO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGZsYXNoQ2VsbChyb3csIGNlbGwsIHNwZWVkKSB7XHJcbiAgICAgIHNwZWVkID0gc3BlZWQgfHwgMTAwO1xyXG4gICAgICBpZiAocm93c0NhY2hlW3Jvd10pIHtcclxuICAgICAgICB2YXIgJGNlbGwgPSAkKGdldENlbGxOb2RlKHJvdywgY2VsbCkpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB0b2dnbGVDZWxsQ2xhc3ModGltZXMpIHtcclxuICAgICAgICAgIGlmICghdGltZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAkY2VsbC5xdWV1ZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICRjZWxsLnRvZ2dsZUNsYXNzKG9wdGlvbnMuY2VsbEZsYXNoaW5nQ3NzQ2xhc3MpLmRlcXVldWUoKTtcclxuICAgICAgICAgICAgICAgICAgdG9nZ2xlQ2VsbENsYXNzKHRpbWVzIC0gMSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHNwZWVkKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRvZ2dsZUNlbGxDbGFzcyg0KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuICAgIC8vIEludGVyYWN0aXZpdHlcclxuXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVNb3VzZVdoZWVsKGUpIHtcclxuICAgICAgdmFyIHJvd05vZGUgPSAkKGUudGFyZ2V0KS5jbG9zZXN0KFwiLnNsaWNrLXJvd1wiKVswXTtcclxuICAgICAgaWYgKHJvd05vZGUgIT0gcm93Tm9kZUZyb21MYXN0TW91c2VXaGVlbEV2ZW50KSB7XHJcbiAgICAgICAgaWYgKHpvbWJpZVJvd05vZGVGcm9tTGFzdE1vdXNlV2hlZWxFdmVudCAmJiB6b21iaWVSb3dOb2RlRnJvbUxhc3RNb3VzZVdoZWVsRXZlbnQgIT0gcm93Tm9kZSkge1xyXG4gICAgICAgICAgaWYgKG9wdGlvbnMuZW5hYmxlQXN5bmNQb3N0UmVuZGVyQ2xlYW51cCAmJiB6b21iaWVSb3dQb3N0UHJvY2Vzc2VkRnJvbUxhc3RNb3VzZVdoZWVsRXZlbnQpIHtcclxuICAgICAgICAgICAgcXVldWVQb3N0UHJvY2Vzc2VkUm93Rm9yQ2xlYW51cCh6b21iaWVSb3dDYWNoZUZyb21MYXN0TW91c2VXaGVlbEV2ZW50LFxyXG4gICAgICAgICAgICAgIHpvbWJpZVJvd1Bvc3RQcm9jZXNzZWRGcm9tTGFzdE1vdXNlV2hlZWxFdmVudCk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAkY2FudmFzWzBdLnJlbW92ZUNoaWxkKHpvbWJpZVJvd05vZGVGcm9tTGFzdE1vdXNlV2hlZWxFdmVudCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB6b21iaWVSb3dOb2RlRnJvbUxhc3RNb3VzZVdoZWVsRXZlbnQgPSBudWxsO1xyXG4gICAgICAgICAgem9tYmllUm93Q2FjaGVGcm9tTGFzdE1vdXNlV2hlZWxFdmVudCA9IG51bGw7XHJcbiAgICAgICAgICB6b21iaWVSb3dQb3N0UHJvY2Vzc2VkRnJvbUxhc3RNb3VzZVdoZWVsRXZlbnQgPSBudWxsO1xyXG5cclxuICAgICAgICAgIGlmIChvcHRpb25zLmVuYWJsZUFzeW5jUG9zdFJlbmRlckNsZWFudXApIHsgc3RhcnRQb3N0UHJvY2Vzc2luZ0NsZWFudXAoKTsgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByb3dOb2RlRnJvbUxhc3RNb3VzZVdoZWVsRXZlbnQgPSByb3dOb2RlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaGFuZGxlRHJhZ0luaXQoZSwgZGQpIHtcclxuICAgICAgdmFyIGNlbGwgPSBnZXRDZWxsRnJvbUV2ZW50KGUpO1xyXG4gICAgICBpZiAoIWNlbGwgfHwgIWNlbGxFeGlzdHMoY2VsbC5yb3csIGNlbGwuY2VsbCkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciByZXR2YWwgPSB0cmlnZ2VyKHNlbGYub25EcmFnSW5pdCwgZGQsIGUpO1xyXG4gICAgICBpZiAoZS5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XHJcbiAgICAgICAgcmV0dXJuIHJldHZhbDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gaWYgbm9ib2R5IGNsYWltcyB0byBiZSBoYW5kbGluZyBkcmFnJ24nZHJvcCBieSBzdG9wcGluZyBpbW1lZGlhdGUgcHJvcGFnYXRpb24sXHJcbiAgICAgIC8vIGNhbmNlbCBvdXQgb2YgaXRcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGhhbmRsZURyYWdTdGFydChlLCBkZCkge1xyXG4gICAgICB2YXIgY2VsbCA9IGdldENlbGxGcm9tRXZlbnQoZSk7XHJcbiAgICAgIGlmICghY2VsbCB8fCAhY2VsbEV4aXN0cyhjZWxsLnJvdywgY2VsbC5jZWxsKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHJldHZhbCA9IHRyaWdnZXIoc2VsZi5vbkRyYWdTdGFydCwgZGQsIGUpO1xyXG4gICAgICBpZiAoZS5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XHJcbiAgICAgICAgcmV0dXJuIHJldHZhbDtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGhhbmRsZURyYWcoZSwgZGQpIHtcclxuICAgICAgcmV0dXJuIHRyaWdnZXIoc2VsZi5vbkRyYWcsIGRkLCBlKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVEcmFnRW5kKGUsIGRkKSB7XHJcbiAgICAgIHRyaWdnZXIoc2VsZi5vbkRyYWdFbmQsIGRkLCBlKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVLZXlEb3duKGUpIHtcclxuICAgICAgdHJpZ2dlcihzZWxmLm9uS2V5RG93biwge3JvdzogYWN0aXZlUm93LCBjZWxsOiBhY3RpdmVDZWxsLCBncmlkOiBzZWxmfSwgZSk7XHJcbiAgICAgIHZhciBoYW5kbGVkID0gZS5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpO1xyXG4gICAgICB2YXIga2V5Q29kZSA9IFNsaWNrLmtleUNvZGU7XHJcblxyXG4gICAgICBpZiAoIWhhbmRsZWQpIHtcclxuICAgICAgICAgaWYgKCFlLnNoaWZ0S2V5ICYmICFlLmFsdEtleSkge1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5lZGl0YWJsZSAmJiBjdXJyZW50RWRpdG9yICYmIGN1cnJlbnRFZGl0b3Iua2V5Q2FwdHVyZUxpc3QpIHtcclxuICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRFZGl0b3Iua2V5Q2FwdHVyZUxpc3QuaW5kZXhPZihlLndoaWNoKSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlLndoaWNoID09IGtleUNvZGUuSE9NRSkge1xyXG4gICAgICAgICAgICAgICBoYW5kbGVkID0gKGUuY3RybEtleSkgPyBuYXZpZ2F0ZVRvcCgpIDogbmF2aWdhdGVSb3dTdGFydCgpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGUud2hpY2ggPT0ga2V5Q29kZS5FTkQpIHtcclxuICAgICAgICAgICAgICAgaGFuZGxlZCA9IChlLmN0cmxLZXkpID8gbmF2aWdhdGVCb3R0b20oKSA6IG5hdmlnYXRlUm93RW5kKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmICghaGFuZGxlZCkge1xyXG4gICAgICAgIGlmICghZS5zaGlmdEtleSAmJiAhZS5hbHRLZXkgJiYgIWUuY3RybEtleSkge1xyXG4gICAgICAgICAgLy8gZWRpdG9yIG1heSBzcGVjaWZ5IGFuIGFycmF5IG9mIGtleXMgdG8gYnViYmxlXHJcbiAgICAgICAgICBpZiAob3B0aW9ucy5lZGl0YWJsZSAmJiBjdXJyZW50RWRpdG9yICYmIGN1cnJlbnRFZGl0b3Iua2V5Q2FwdHVyZUxpc3QpIHtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRFZGl0b3Iua2V5Q2FwdHVyZUxpc3QuaW5kZXhPZiggZS53aGljaCApID4gLTEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGUud2hpY2ggPT0ga2V5Q29kZS5FU0NBUEUpIHtcclxuICAgICAgICAgICAgaWYgKCFnZXRFZGl0b3JMb2NrKCkuaXNBY3RpdmUoKSkge1xyXG4gICAgICAgICAgICAgIHJldHVybjsgLy8gbm8gZWRpdGluZyBtb2RlIHRvIGNhbmNlbCwgYWxsb3cgYnViYmxpbmcgYW5kIGRlZmF1bHQgcHJvY2Vzc2luZyAoZXhpdCB3aXRob3V0IGNhbmNlbGxpbmcgdGhlIGV2ZW50KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhbmNlbEVkaXRBbmRTZXRGb2N1cygpO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChlLndoaWNoID09IGtleUNvZGUuUEFHRV9ET1dOKSB7XHJcbiAgICAgICAgICAgIG5hdmlnYXRlUGFnZURvd24oKTtcclxuICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGUud2hpY2ggPT0ga2V5Q29kZS5QQUdFX1VQKSB7XHJcbiAgICAgICAgICAgIG5hdmlnYXRlUGFnZVVwKCk7XHJcbiAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChlLndoaWNoID09IGtleUNvZGUuTEVGVCkge1xyXG4gICAgICAgICAgICBoYW5kbGVkID0gbmF2aWdhdGVMZWZ0KCk7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGUud2hpY2ggPT0ga2V5Q29kZS5SSUdIVCkge1xyXG4gICAgICAgICAgICBoYW5kbGVkID0gbmF2aWdhdGVSaWdodCgpO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChlLndoaWNoID09IGtleUNvZGUuVVApIHtcclxuICAgICAgICAgICAgaGFuZGxlZCA9IG5hdmlnYXRlVXAoKTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoZS53aGljaCA9PSBrZXlDb2RlLkRPV04pIHtcclxuICAgICAgICAgICAgaGFuZGxlZCA9IG5hdmlnYXRlRG93bigpO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChlLndoaWNoID09IGtleUNvZGUuVEFCKSB7XHJcbiAgICAgICAgICAgIGhhbmRsZWQgPSBuYXZpZ2F0ZU5leHQoKTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoZS53aGljaCA9PSBrZXlDb2RlLkVOVEVSKSB7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmVkaXRhYmxlKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnRFZGl0b3IpIHtcclxuICAgICAgICAgICAgICAgIC8vIGFkZGluZyBuZXcgcm93XHJcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlUm93ID09PSBnZXREYXRhTGVuZ3RoKCkpIHtcclxuICAgICAgICAgICAgICAgICAgbmF2aWdhdGVEb3duKCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICBjb21taXRFZGl0QW5kU2V0Rm9jdXMoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGdldEVkaXRvckxvY2soKS5jb21taXRDdXJyZW50RWRpdCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgIG1ha2VBY3RpdmVDZWxsRWRpdGFibGUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChlLndoaWNoID09IGtleUNvZGUuVEFCICYmIGUuc2hpZnRLZXkgJiYgIWUuY3RybEtleSAmJiAhZS5hbHRLZXkpIHtcclxuICAgICAgICAgIGhhbmRsZWQgPSBuYXZpZ2F0ZVByZXYoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChoYW5kbGVkKSB7XHJcbiAgICAgICAgLy8gdGhlIGV2ZW50IGhhcyBiZWVuIGhhbmRsZWQgc28gZG9uJ3QgbGV0IHBhcmVudCBlbGVtZW50IChidWJibGluZy9wcm9wYWdhdGlvbikgb3IgYnJvd3NlciAoZGVmYXVsdCkgaGFuZGxlIGl0XHJcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGUub3JpZ2luYWxFdmVudC5rZXlDb2RlID0gMDsgLy8gcHJldmVudCBkZWZhdWx0IGJlaGF2aW91ciBmb3Igc3BlY2lhbCBrZXlzIGluIElFIGJyb3dzZXJzIChGMywgRjUsIGV0Yy4pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGlnbm9yZSBleGNlcHRpb25zIC0gc2V0dGluZyB0aGUgb3JpZ2luYWwgZXZlbnQncyBrZXljb2RlIHRocm93cyBhY2Nlc3MgZGVuaWVkIGV4Y2VwdGlvbiBmb3IgXCJDdHJsXCJcclxuICAgICAgICAvLyAoaGl0dGluZyBjb250cm9sIGtleSBvbmx5LCBub3RoaW5nIGVsc2UpLCBcIlNoaWZ0XCIgKG1heWJlIG90aGVycylcclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVDbGljayhlKSB7XHJcbiAgICAgIGlmICghY3VycmVudEVkaXRvcikge1xyXG4gICAgICAgIC8vIGlmIHRoaXMgY2xpY2sgcmVzdWx0ZWQgaW4gc29tZSBjZWxsIGNoaWxkIG5vZGUgZ2V0dGluZyBmb2N1cyxcclxuICAgICAgICAvLyBkb24ndCBzdGVhbCBpdCBiYWNrIC0ga2V5Ym9hcmQgZXZlbnRzIHdpbGwgc3RpbGwgYnViYmxlIHVwXHJcbiAgICAgICAgLy8gSUU5KyBzZWVtcyB0byBkZWZhdWx0IERJVnMgdG8gdGFiSW5kZXg9MCBpbnN0ZWFkIG9mIC0xLCBzbyBjaGVjayBmb3IgY2VsbCBjbGlja3MgZGlyZWN0bHkuXHJcbiAgICAgICAgaWYgKGUudGFyZ2V0ICE9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgfHwgJChlLnRhcmdldCkuaGFzQ2xhc3MoXCJzbGljay1jZWxsXCIpKSB7XHJcbiAgICAgICAgICBzZXRGb2N1cygpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGNlbGwgPSBnZXRDZWxsRnJvbUV2ZW50KGUpO1xyXG4gICAgICBpZiAoIWNlbGwgfHwgKGN1cnJlbnRFZGl0b3IgIT09IG51bGwgJiYgYWN0aXZlUm93ID09IGNlbGwucm93ICYmIGFjdGl2ZUNlbGwgPT0gY2VsbC5jZWxsKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdHJpZ2dlcihzZWxmLm9uQ2xpY2ssIHtyb3c6IGNlbGwucm93LCBjZWxsOiBjZWxsLmNlbGwsIGdyaWQ6IHNlbGZ9LCBlKTtcclxuICAgICAgaWYgKGUuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gdGhpcyBvcHRpbWlzYXRpb24gY2F1c2VzIHRyb3VibGUgLSBNTGVpYm1hbiAjMzI5XHJcbiAgICAgIC8vaWYgKChhY3RpdmVDZWxsICE9IGNlbGwuY2VsbCB8fCBhY3RpdmVSb3cgIT0gY2VsbC5yb3cpICYmIGNhbkNlbGxCZUFjdGl2ZShjZWxsLnJvdywgY2VsbC5jZWxsKSkge1xyXG4gICAgICBpZiAoY2FuQ2VsbEJlQWN0aXZlKGNlbGwucm93LCBjZWxsLmNlbGwpKSB7XHJcbiAgICAgICAgaWYgKCFnZXRFZGl0b3JMb2NrKCkuaXNBY3RpdmUoKSB8fCBnZXRFZGl0b3JMb2NrKCkuY29tbWl0Q3VycmVudEVkaXQoKSkge1xyXG4gICAgICAgICAgc2Nyb2xsUm93SW50b1ZpZXcoY2VsbC5yb3csIGZhbHNlKTtcclxuXHJcbiAgICAgICAgICB2YXIgcHJlQ2xpY2tNb2RlT24gPSAoZS50YXJnZXQgJiYgZS50YXJnZXQuY2xhc3NOYW1lID09PSBTbGljay5wcmVDbGlja0NsYXNzTmFtZSk7XHJcbiAgICAgICAgICB2YXIgY29sdW1uID0gY29sdW1uc1tjZWxsLmNlbGxdO1xyXG4gICAgICAgICAgdmFyIHN1cHByZXNzQWN0aXZlQ2VsbENoYW5nZWRFdmVudCA9IChvcHRpb25zLmVkaXRhYmxlICYmIGNvbHVtbiAmJiBjb2x1bW4uZWRpdG9yICYmIG9wdGlvbnMuc3VwcHJlc3NBY3RpdmVDZWxsQ2hhbmdlT25FZGl0KSA/IHRydWUgOiBmYWxzZTtcclxuICAgICAgICAgIHNldEFjdGl2ZUNlbGxJbnRlcm5hbChnZXRDZWxsTm9kZShjZWxsLnJvdywgY2VsbC5jZWxsKSwgbnVsbCwgcHJlQ2xpY2tNb2RlT24sIHN1cHByZXNzQWN0aXZlQ2VsbENoYW5nZWRFdmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaGFuZGxlQ29udGV4dE1lbnUoZSkge1xyXG4gICAgICB2YXIgJGNlbGwgPSAkKGUudGFyZ2V0KS5jbG9zZXN0KFwiLnNsaWNrLWNlbGxcIiwgJGNhbnZhcyk7XHJcbiAgICAgIGlmICgkY2VsbC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGFyZSB3ZSBlZGl0aW5nIHRoaXMgY2VsbD9cclxuICAgICAgaWYgKGFjdGl2ZUNlbGxOb2RlID09PSAkY2VsbFswXSAmJiBjdXJyZW50RWRpdG9yICE9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0cmlnZ2VyKHNlbGYub25Db250ZXh0TWVudSwge2dyaWQ6IHNlbGZ9LCBlKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVEYmxDbGljayhlKSB7XHJcbiAgICAgIHZhciBjZWxsID0gZ2V0Q2VsbEZyb21FdmVudChlKTtcclxuICAgICAgaWYgKCFjZWxsIHx8IChjdXJyZW50RWRpdG9yICE9PSBudWxsICYmIGFjdGl2ZVJvdyA9PSBjZWxsLnJvdyAmJiBhY3RpdmVDZWxsID09IGNlbGwuY2VsbCkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRyaWdnZXIoc2VsZi5vbkRibENsaWNrLCB7cm93OiBjZWxsLnJvdywgY2VsbDogY2VsbC5jZWxsLCBncmlkOiBzZWxmfSwgZSk7XHJcbiAgICAgIGlmIChlLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChvcHRpb25zLmVkaXRhYmxlKSB7XHJcbiAgICAgICAgZ290b0NlbGwoY2VsbC5yb3csIGNlbGwuY2VsbCwgdHJ1ZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVIZWFkZXJNb3VzZUVudGVyKGUpIHtcclxuICAgICAgdHJpZ2dlcihzZWxmLm9uSGVhZGVyTW91c2VFbnRlciwge1xyXG4gICAgICAgIFwiY29sdW1uXCI6ICQodGhpcykuZGF0YShcImNvbHVtblwiKSxcclxuICAgICAgICBcImdyaWRcIjogc2VsZlxyXG4gICAgICB9LCBlKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVIZWFkZXJNb3VzZUxlYXZlKGUpIHtcclxuICAgICAgdHJpZ2dlcihzZWxmLm9uSGVhZGVyTW91c2VMZWF2ZSwge1xyXG4gICAgICAgIFwiY29sdW1uXCI6ICQodGhpcykuZGF0YShcImNvbHVtblwiKSxcclxuICAgICAgICBcImdyaWRcIjogc2VsZlxyXG4gICAgICB9LCBlKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVIZWFkZXJDb250ZXh0TWVudShlKSB7XHJcbiAgICAgIHZhciAkaGVhZGVyID0gJChlLnRhcmdldCkuY2xvc2VzdChcIi5zbGljay1oZWFkZXItY29sdW1uXCIsIFwiLnNsaWNrLWhlYWRlci1jb2x1bW5zXCIpO1xyXG4gICAgICB2YXIgY29sdW1uID0gJGhlYWRlciAmJiAkaGVhZGVyLmRhdGEoXCJjb2x1bW5cIik7XHJcbiAgICAgIHRyaWdnZXIoc2VsZi5vbkhlYWRlckNvbnRleHRNZW51LCB7Y29sdW1uOiBjb2x1bW4sIGdyaWQ6IHNlbGZ9LCBlKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVIZWFkZXJDbGljayhlKSB7XHJcbiAgICAgIGlmIChjb2x1bW5SZXNpemVEcmFnZ2luZykgcmV0dXJuO1xyXG4gICAgICB2YXIgJGhlYWRlciA9ICQoZS50YXJnZXQpLmNsb3Nlc3QoXCIuc2xpY2staGVhZGVyLWNvbHVtblwiLCBcIi5zbGljay1oZWFkZXItY29sdW1uc1wiKTtcclxuICAgICAgdmFyIGNvbHVtbiA9ICRoZWFkZXIgJiYgJGhlYWRlci5kYXRhKFwiY29sdW1uXCIpO1xyXG4gICAgICBpZiAoY29sdW1uKSB7XHJcbiAgICAgICAgdHJpZ2dlcihzZWxmLm9uSGVhZGVyQ2xpY2ssIHtjb2x1bW46IGNvbHVtbiwgZ3JpZDogc2VsZn0sIGUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaGFuZGxlTW91c2VFbnRlcihlKSB7XHJcbiAgICAgIHRyaWdnZXIoc2VsZi5vbk1vdXNlRW50ZXIsIHtncmlkOiBzZWxmfSwgZSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaGFuZGxlTW91c2VMZWF2ZShlKSB7XHJcbiAgICAgIHRyaWdnZXIoc2VsZi5vbk1vdXNlTGVhdmUsIHtncmlkOiBzZWxmfSwgZSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY2VsbEV4aXN0cyhyb3csIGNlbGwpIHtcclxuICAgICAgcmV0dXJuICEocm93IDwgMCB8fCByb3cgPj0gZ2V0RGF0YUxlbmd0aCgpIHx8IGNlbGwgPCAwIHx8IGNlbGwgPj0gY29sdW1ucy5sZW5ndGgpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldENlbGxGcm9tUG9pbnQoeCwgeSkge1xyXG4gICAgICB2YXIgcm93ID0gZ2V0Um93RnJvbVBvc2l0aW9uKHkpO1xyXG4gICAgICB2YXIgY2VsbCA9IDA7XHJcblxyXG4gICAgICB2YXIgdyA9IDA7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sdW1ucy5sZW5ndGggJiYgdyA8IHg7IGkrKykge1xyXG4gICAgICAgIHcgKz0gY29sdW1uc1tpXS53aWR0aDtcclxuICAgICAgICBjZWxsKys7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChjZWxsIDwgMCkge1xyXG4gICAgICAgIGNlbGwgPSAwO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4ge3Jvdzogcm93LCBjZWxsOiBjZWxsIC0gMX07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0Q2VsbEZyb21Ob2RlKGNlbGxOb2RlKSB7XHJcbiAgICAgIC8vIHJlYWQgY29sdW1uIG51bWJlciBmcm9tIC5sPGNvbHVtbk51bWJlcj4gQ1NTIGNsYXNzXHJcbiAgICAgIHZhciBjbHMgPSAvbFxcZCsvLmV4ZWMoY2VsbE5vZGUuY2xhc3NOYW1lKTtcclxuICAgICAgaWYgKCFjbHMpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnZXRDZWxsRnJvbU5vZGU6IGNhbm5vdCBnZXQgY2VsbCAtIFwiICsgY2VsbE5vZGUuY2xhc3NOYW1lKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcGFyc2VJbnQoY2xzWzBdLnN1YnN0cigxLCBjbHNbMF0ubGVuZ3RoIC0gMSksIDEwKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRSb3dGcm9tTm9kZShyb3dOb2RlKSB7XHJcbiAgICAgIGZvciAodmFyIHJvdyBpbiByb3dzQ2FjaGUpIHtcclxuICAgICAgICBpZiAocm93c0NhY2hlW3Jvd10ucm93Tm9kZSA9PT0gcm93Tm9kZSkge1xyXG4gICAgICAgICAgcmV0dXJuIHJvdyB8IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRDZWxsRnJvbUV2ZW50KGUpIHtcclxuICAgICAgdmFyICRjZWxsID0gJChlLnRhcmdldCkuY2xvc2VzdChcIi5zbGljay1jZWxsXCIsICRjYW52YXMpO1xyXG4gICAgICBpZiAoISRjZWxsLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgcm93ID0gZ2V0Um93RnJvbU5vZGUoJGNlbGxbMF0ucGFyZW50Tm9kZSk7XHJcbiAgICAgIHZhciBjZWxsID0gZ2V0Q2VsbEZyb21Ob2RlKCRjZWxsWzBdKTtcclxuXHJcbiAgICAgIGlmIChyb3cgPT0gbnVsbCB8fCBjZWxsID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgXCJyb3dcIjogcm93LFxyXG4gICAgICAgICAgXCJjZWxsXCI6IGNlbGxcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0Q2VsbE5vZGVCb3gocm93LCBjZWxsKSB7XHJcbiAgICAgIGlmICghY2VsbEV4aXN0cyhyb3csIGNlbGwpKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciB5MSA9IGdldFJvd1RvcChyb3cpO1xyXG4gICAgICB2YXIgeTIgPSB5MSArIG9wdGlvbnMucm93SGVpZ2h0IC0gMTtcclxuICAgICAgdmFyIHgxID0gMDtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjZWxsOyBpKyspIHtcclxuICAgICAgICB4MSArPSBjb2x1bW5zW2ldLndpZHRoO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciB4MiA9IHgxICsgY29sdW1uc1tjZWxsXS53aWR0aDtcclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdG9wOiB5MSxcclxuICAgICAgICBsZWZ0OiB4MSxcclxuICAgICAgICBib3R0b206IHkyLFxyXG4gICAgICAgIHJpZ2h0OiB4MlxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuICAgIC8vIENlbGwgc3dpdGNoaW5nXHJcblxyXG4gICAgZnVuY3Rpb24gcmVzZXRBY3RpdmVDZWxsKCkge1xyXG4gICAgICBzZXRBY3RpdmVDZWxsSW50ZXJuYWwobnVsbCwgZmFsc2UpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNldEZvY3VzKCkge1xyXG4gICAgICBpZiAodGFiYmluZ0RpcmVjdGlvbiA9PSAtMSkge1xyXG4gICAgICAgICRmb2N1c1NpbmtbMF0uZm9jdXMoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAkZm9jdXNTaW5rMlswXS5mb2N1cygpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2Nyb2xsQ2VsbEludG9WaWV3KHJvdywgY2VsbCwgZG9QYWdpbmcpIHtcclxuICAgICAgc2Nyb2xsUm93SW50b1ZpZXcocm93LCBkb1BhZ2luZyk7XHJcblxyXG4gICAgICB2YXIgY29sc3BhbiA9IGdldENvbHNwYW4ocm93LCBjZWxsKTtcclxuICAgICAgaW50ZXJuYWxTY3JvbGxDb2x1bW5JbnRvVmlldyhjb2x1bW5Qb3NMZWZ0W2NlbGxdLCBjb2x1bW5Qb3NSaWdodFtjZWxsICsgKGNvbHNwYW4gPiAxID8gY29sc3BhbiAtIDEgOiAwKV0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGludGVybmFsU2Nyb2xsQ29sdW1uSW50b1ZpZXcobGVmdCwgcmlnaHQpIHtcclxuICAgICAgdmFyIHNjcm9sbFJpZ2h0ID0gc2Nyb2xsTGVmdCArIHZpZXdwb3J0VztcclxuXHJcbiAgICAgIGlmIChsZWZ0IDwgc2Nyb2xsTGVmdCkge1xyXG4gICAgICAgICR2aWV3cG9ydC5zY3JvbGxMZWZ0KGxlZnQpO1xyXG4gICAgICAgIGhhbmRsZVNjcm9sbCgpO1xyXG4gICAgICAgIHJlbmRlcigpO1xyXG4gICAgICB9IGVsc2UgaWYgKHJpZ2h0ID4gc2Nyb2xsUmlnaHQpIHtcclxuICAgICAgICAkdmlld3BvcnQuc2Nyb2xsTGVmdChNYXRoLm1pbihsZWZ0LCByaWdodCAtICR2aWV3cG9ydFswXS5jbGllbnRXaWR0aCkpO1xyXG4gICAgICAgIGhhbmRsZVNjcm9sbCgpO1xyXG4gICAgICAgIHJlbmRlcigpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2Nyb2xsQ29sdW1uSW50b1ZpZXcoY2VsbCkge1xyXG4gICAgICBpbnRlcm5hbFNjcm9sbENvbHVtbkludG9WaWV3KGNvbHVtblBvc0xlZnRbY2VsbF0sIGNvbHVtblBvc1JpZ2h0W2NlbGxdKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzZXRBY3RpdmVDZWxsSW50ZXJuYWwobmV3Q2VsbCwgb3B0X2VkaXRNb2RlLCBwcmVDbGlja01vZGVPbiwgc3VwcHJlc3NBY3RpdmVDZWxsQ2hhbmdlZEV2ZW50KSB7XHJcbiAgICAgIGlmIChhY3RpdmVDZWxsTm9kZSAhPT0gbnVsbCkge1xyXG4gICAgICAgIG1ha2VBY3RpdmVDZWxsTm9ybWFsKCk7XHJcbiAgICAgICAgJChhY3RpdmVDZWxsTm9kZSkucmVtb3ZlQ2xhc3MoXCJhY3RpdmVcIik7XHJcbiAgICAgICAgaWYgKHJvd3NDYWNoZVthY3RpdmVSb3ddKSB7XHJcbiAgICAgICAgICAkKHJvd3NDYWNoZVthY3RpdmVSb3ddLnJvd05vZGUpLnJlbW92ZUNsYXNzKFwiYWN0aXZlXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGFjdGl2ZUNlbGxDaGFuZ2VkID0gKGFjdGl2ZUNlbGxOb2RlICE9PSBuZXdDZWxsKTtcclxuICAgICAgYWN0aXZlQ2VsbE5vZGUgPSBuZXdDZWxsO1xyXG5cclxuICAgICAgaWYgKGFjdGl2ZUNlbGxOb2RlICE9IG51bGwpIHtcclxuICAgICAgICBhY3RpdmVSb3cgPSBnZXRSb3dGcm9tTm9kZShhY3RpdmVDZWxsTm9kZS5wYXJlbnROb2RlKTtcclxuICAgICAgICBhY3RpdmVDZWxsID0gYWN0aXZlUG9zWCA9IGdldENlbGxGcm9tTm9kZShhY3RpdmVDZWxsTm9kZSk7XHJcblxyXG4gICAgICAgIGlmIChvcHRfZWRpdE1vZGUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgb3B0X2VkaXRNb2RlID0gKGFjdGl2ZVJvdyA9PSBnZXREYXRhTGVuZ3RoKCkpIHx8IG9wdGlvbnMuYXV0b0VkaXQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5zaG93Q2VsbFNlbGVjdGlvbikge1xyXG4gICAgICAgICQoYWN0aXZlQ2VsbE5vZGUpLmFkZENsYXNzKFwiYWN0aXZlXCIpO1xyXG4gICAgICAgICQocm93c0NhY2hlW2FjdGl2ZVJvd10ucm93Tm9kZSkuYWRkQ2xhc3MoXCJhY3RpdmVcIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5lZGl0YWJsZSAmJiBvcHRfZWRpdE1vZGUgJiYgaXNDZWxsUG90ZW50aWFsbHlFZGl0YWJsZShhY3RpdmVSb3csIGFjdGl2ZUNlbGwpKSB7XHJcbiAgICAgICAgICBjbGVhclRpbWVvdXQoaF9lZGl0b3JMb2FkZXIpO1xyXG5cclxuICAgICAgICAgIGlmIChvcHRpb25zLmFzeW5jRWRpdG9yTG9hZGluZykge1xyXG4gICAgICAgICAgICBoX2VkaXRvckxvYWRlciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgIG1ha2VBY3RpdmVDZWxsRWRpdGFibGUodW5kZWZpbmVkLCBwcmVDbGlja01vZGVPbik7XHJcbiAgICAgICAgICAgIH0sIG9wdGlvbnMuYXN5bmNFZGl0b3JMb2FkRGVsYXkpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbWFrZUFjdGl2ZUNlbGxFZGl0YWJsZSh1bmRlZmluZWQsIHByZUNsaWNrTW9kZU9uKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYWN0aXZlUm93ID0gYWN0aXZlQ2VsbCA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgIFxyXG4gICAgICAvLyB0aGlzIG9wdGltaXNhdGlvbiBjYXVzZXMgdHJvdWJsZSAtIE1MZWlibWFuICMzMjlcclxuICAgICAgLy9pZiAoYWN0aXZlQ2VsbENoYW5nZWQpIHtcclxuICAgICAgaWYgKCFzdXBwcmVzc0FjdGl2ZUNlbGxDaGFuZ2VkRXZlbnQpIHsgdHJpZ2dlcihzZWxmLm9uQWN0aXZlQ2VsbENoYW5nZWQsIGdldEFjdGl2ZUNlbGwoKSk7IH1cclxuICAgICAgLy99XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY2xlYXJUZXh0U2VsZWN0aW9uKCkge1xyXG4gICAgICBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uICYmIGRvY3VtZW50LnNlbGVjdGlvbi5lbXB0eSkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAvL0lFIGZhaWxzIGhlcmUgaWYgc2VsZWN0ZWQgZWxlbWVudCBpcyBub3QgaW4gZG9tXHJcbiAgICAgICAgICBkb2N1bWVudC5zZWxlY3Rpb24uZW1wdHkoKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IH1cclxuICAgICAgfSBlbHNlIGlmICh3aW5kb3cuZ2V0U2VsZWN0aW9uKSB7XHJcbiAgICAgICAgdmFyIHNlbCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcclxuICAgICAgICBpZiAoc2VsICYmIHNlbC5yZW1vdmVBbGxSYW5nZXMpIHtcclxuICAgICAgICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpc0NlbGxQb3RlbnRpYWxseUVkaXRhYmxlKHJvdywgY2VsbCkge1xyXG4gICAgICB2YXIgZGF0YUxlbmd0aCA9IGdldERhdGFMZW5ndGgoKTtcclxuICAgICAgLy8gaXMgdGhlIGRhdGEgZm9yIHRoaXMgcm93IGxvYWRlZD9cclxuICAgICAgaWYgKHJvdyA8IGRhdGFMZW5ndGggJiYgIWdldERhdGFJdGVtKHJvdykpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGFyZSB3ZSBpbiB0aGUgQWRkIE5ldyByb3c/ICBjYW4gd2UgY3JlYXRlIG5ldyBmcm9tIHRoaXMgY2VsbD9cclxuICAgICAgaWYgKGNvbHVtbnNbY2VsbF0uY2Fubm90VHJpZ2dlckluc2VydCAmJiByb3cgPj0gZGF0YUxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gZG9lcyB0aGlzIGNlbGwgaGF2ZSBhbiBlZGl0b3I/XHJcbiAgICAgIGlmICghZ2V0RWRpdG9yKHJvdywgY2VsbCkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1ha2VBY3RpdmVDZWxsTm9ybWFsKCkge1xyXG4gICAgICBpZiAoIWN1cnJlbnRFZGl0b3IpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdHJpZ2dlcihzZWxmLm9uQmVmb3JlQ2VsbEVkaXRvckRlc3Ryb3ksIHtlZGl0b3I6IGN1cnJlbnRFZGl0b3IsIGdyaWQ6IHNlbGZ9KTtcclxuICAgICAgY3VycmVudEVkaXRvci5kZXN0cm95KCk7XHJcbiAgICAgIGN1cnJlbnRFZGl0b3IgPSBudWxsO1xyXG5cclxuICAgICAgaWYgKGFjdGl2ZUNlbGxOb2RlKSB7XHJcbiAgICAgICAgdmFyIGQgPSBnZXREYXRhSXRlbShhY3RpdmVSb3cpO1xyXG4gICAgICAgICQoYWN0aXZlQ2VsbE5vZGUpLnJlbW92ZUNsYXNzKFwiZWRpdGFibGUgaW52YWxpZFwiKTtcclxuICAgICAgICBpZiAoZCkge1xyXG4gICAgICAgICAgdmFyIGNvbHVtbiA9IGNvbHVtbnNbYWN0aXZlQ2VsbF07XHJcbiAgICAgICAgICB2YXIgZm9ybWF0dGVyID0gZ2V0Rm9ybWF0dGVyKGFjdGl2ZVJvdywgY29sdW1uKTtcclxuICAgICAgICAgIHZhciBmb3JtYXR0ZXJSZXN1bHQgPSAgZm9ybWF0dGVyKGFjdGl2ZVJvdywgYWN0aXZlQ2VsbCwgZ2V0RGF0YUl0ZW1WYWx1ZUZvckNvbHVtbihkLCBjb2x1bW4pLCBjb2x1bW4sIGQsIHNlbGYpO1xyXG4gICAgICAgICAgYXBwbHlGb3JtYXRSZXN1bHRUb0NlbGxOb2RlKGZvcm1hdHRlclJlc3VsdCwgYWN0aXZlQ2VsbE5vZGUpO1xyXG4gICAgICAgICAgaW52YWxpZGF0ZVBvc3RQcm9jZXNzaW5nUmVzdWx0cyhhY3RpdmVSb3cpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gaWYgdGhlcmUgcHJldmlvdXNseSB3YXMgdGV4dCBzZWxlY3RlZCBvbiBhIHBhZ2UgKHN1Y2ggYXMgc2VsZWN0ZWQgdGV4dCBpbiB0aGUgZWRpdCBjZWxsIGp1c3QgcmVtb3ZlZCksXHJcbiAgICAgIC8vIElFIGNhbid0IHNldCBmb2N1cyB0byBhbnl0aGluZyBlbHNlIGNvcnJlY3RseVxyXG4gICAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9tc2llLykpIHtcclxuICAgICAgICBjbGVhclRleHRTZWxlY3Rpb24oKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZ2V0RWRpdG9yTG9jaygpLmRlYWN0aXZhdGUoZWRpdENvbnRyb2xsZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1ha2VBY3RpdmVDZWxsRWRpdGFibGUoZWRpdG9yLCBwcmVDbGlja01vZGVPbikge1xyXG4gICAgICBpZiAoIWFjdGl2ZUNlbGxOb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghb3B0aW9ucy5lZGl0YWJsZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdyaWQgOiBtYWtlQWN0aXZlQ2VsbEVkaXRhYmxlIDogc2hvdWxkIG5ldmVyIGdldCBjYWxsZWQgd2hlbiBvcHRpb25zLmVkaXRhYmxlIGlzIGZhbHNlXCIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBjYW5jZWwgcGVuZGluZyBhc3luYyBjYWxsIGlmIHRoZXJlIGlzIG9uZVxyXG4gICAgICBjbGVhclRpbWVvdXQoaF9lZGl0b3JMb2FkZXIpO1xyXG5cclxuICAgICAgaWYgKCFpc0NlbGxQb3RlbnRpYWxseUVkaXRhYmxlKGFjdGl2ZVJvdywgYWN0aXZlQ2VsbCkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBjb2x1bW5EZWYgPSBjb2x1bW5zW2FjdGl2ZUNlbGxdO1xyXG4gICAgICB2YXIgaXRlbSA9IGdldERhdGFJdGVtKGFjdGl2ZVJvdyk7XHJcblxyXG4gICAgICBpZiAodHJpZ2dlcihzZWxmLm9uQmVmb3JlRWRpdENlbGwsIHtyb3c6IGFjdGl2ZVJvdywgY2VsbDogYWN0aXZlQ2VsbCwgaXRlbTogaXRlbSwgY29sdW1uOiBjb2x1bW5EZWYsIGdyaWQ6IHNlbGZ9KSA9PT0gZmFsc2UpIHtcclxuICAgICAgICBzZXRGb2N1cygpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgZ2V0RWRpdG9yTG9jaygpLmFjdGl2YXRlKGVkaXRDb250cm9sbGVyKTtcclxuICAgICAgJChhY3RpdmVDZWxsTm9kZSkuYWRkQ2xhc3MoXCJlZGl0YWJsZVwiKTtcclxuXHJcbiAgICAgIHZhciB1c2VFZGl0b3IgPSBlZGl0b3IgfHwgZ2V0RWRpdG9yKGFjdGl2ZVJvdywgYWN0aXZlQ2VsbCk7XHJcblxyXG4gICAgICAvLyBkb24ndCBjbGVhciB0aGUgY2VsbCBpZiBhIGN1c3RvbSBlZGl0b3IgaXMgcGFzc2VkIHRocm91Z2hcclxuICAgICAgaWYgKCFlZGl0b3IgJiYgIXVzZUVkaXRvci5zdXBwcmVzc0NsZWFyT25FZGl0KSB7XHJcbiAgICAgICAgYWN0aXZlQ2VsbE5vZGUuaW5uZXJIVE1MID0gXCJcIjtcclxuICAgICAgfVxyXG5cclxuICAgICAgY3VycmVudEVkaXRvciA9IG5ldyB1c2VFZGl0b3Ioe1xyXG4gICAgICAgIGdyaWQ6IHNlbGYsXHJcbiAgICAgICAgZ3JpZFBvc2l0aW9uOiBhYnNCb3goJGNvbnRhaW5lclswXSksXHJcbiAgICAgICAgcG9zaXRpb246IGFic0JveChhY3RpdmVDZWxsTm9kZSksXHJcbiAgICAgICAgY29udGFpbmVyOiBhY3RpdmVDZWxsTm9kZSxcclxuICAgICAgICBjb2x1bW46IGNvbHVtbkRlZixcclxuICAgICAgICBpdGVtOiBpdGVtIHx8IHt9LFxyXG4gICAgICAgIGNvbW1pdENoYW5nZXM6IGNvbW1pdEVkaXRBbmRTZXRGb2N1cyxcclxuICAgICAgICBjYW5jZWxDaGFuZ2VzOiBjYW5jZWxFZGl0QW5kU2V0Rm9jdXNcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAoaXRlbSkge1xyXG4gICAgICAgIGN1cnJlbnRFZGl0b3IubG9hZFZhbHVlKGl0ZW0pO1xyXG4gICAgICAgIGlmIChwcmVDbGlja01vZGVPbiAmJiBjdXJyZW50RWRpdG9yLnByZUNsaWNrKSB7XHJcbiAgICAgICAgICBjdXJyZW50RWRpdG9yLnByZUNsaWNrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBzZXJpYWxpemVkRWRpdG9yVmFsdWUgPSBjdXJyZW50RWRpdG9yLnNlcmlhbGl6ZVZhbHVlKCk7XHJcblxyXG4gICAgICBpZiAoY3VycmVudEVkaXRvci5wb3NpdGlvbikge1xyXG4gICAgICAgIGhhbmRsZUFjdGl2ZUNlbGxQb3NpdGlvbkNoYW5nZSgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY29tbWl0RWRpdEFuZFNldEZvY3VzKCkge1xyXG4gICAgICAvLyBpZiB0aGUgY29tbWl0IGZhaWxzLCBpdCB3b3VsZCBkbyBzbyBkdWUgdG8gYSB2YWxpZGF0aW9uIGVycm9yXHJcbiAgICAgIC8vIGlmIHNvLCBkbyBub3Qgc3RlYWwgdGhlIGZvY3VzIGZyb20gdGhlIGVkaXRvclxyXG4gICAgICBpZiAoZ2V0RWRpdG9yTG9jaygpLmNvbW1pdEN1cnJlbnRFZGl0KCkpIHtcclxuICAgICAgICBzZXRGb2N1cygpO1xyXG4gICAgICAgIGlmIChvcHRpb25zLmF1dG9FZGl0KSB7XHJcbiAgICAgICAgICBuYXZpZ2F0ZURvd24oKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjYW5jZWxFZGl0QW5kU2V0Rm9jdXMoKSB7XHJcbiAgICAgIGlmIChnZXRFZGl0b3JMb2NrKCkuY2FuY2VsQ3VycmVudEVkaXQoKSkge1xyXG4gICAgICAgIHNldEZvY3VzKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhYnNCb3goZWxlbSkge1xyXG4gICAgICB2YXIgYm94ID0ge1xyXG4gICAgICAgIHRvcDogZWxlbS5vZmZzZXRUb3AsXHJcbiAgICAgICAgbGVmdDogZWxlbS5vZmZzZXRMZWZ0LFxyXG4gICAgICAgIGJvdHRvbTogMCxcclxuICAgICAgICByaWdodDogMCxcclxuICAgICAgICB3aWR0aDogJChlbGVtKS5vdXRlcldpZHRoKCksXHJcbiAgICAgICAgaGVpZ2h0OiAkKGVsZW0pLm91dGVySGVpZ2h0KCksXHJcbiAgICAgICAgdmlzaWJsZTogdHJ1ZX07XHJcbiAgICAgIGJveC5ib3R0b20gPSBib3gudG9wICsgYm94LmhlaWdodDtcclxuICAgICAgYm94LnJpZ2h0ID0gYm94LmxlZnQgKyBib3gud2lkdGg7XHJcblxyXG4gICAgICAvLyB3YWxrIHVwIHRoZSB0cmVlXHJcbiAgICAgIHZhciBvZmZzZXRQYXJlbnQgPSBlbGVtLm9mZnNldFBhcmVudDtcclxuICAgICAgd2hpbGUgKChlbGVtID0gZWxlbS5wYXJlbnROb2RlKSAhPSBkb2N1bWVudC5ib2R5KSB7XHJcbiAgICAgICAgaWYgKGVsZW0gPT0gbnVsbCkgYnJlYWs7XHJcblxyXG4gICAgICAgIGlmIChib3gudmlzaWJsZSAmJiBlbGVtLnNjcm9sbEhlaWdodCAhPSBlbGVtLm9mZnNldEhlaWdodCAmJiAkKGVsZW0pLmNzcyhcIm92ZXJmbG93WVwiKSAhPSBcInZpc2libGVcIikge1xyXG4gICAgICAgICAgYm94LnZpc2libGUgPSBib3guYm90dG9tID4gZWxlbS5zY3JvbGxUb3AgJiYgYm94LnRvcCA8IGVsZW0uc2Nyb2xsVG9wICsgZWxlbS5jbGllbnRIZWlnaHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYm94LnZpc2libGUgJiYgZWxlbS5zY3JvbGxXaWR0aCAhPSBlbGVtLm9mZnNldFdpZHRoICYmICQoZWxlbSkuY3NzKFwib3ZlcmZsb3dYXCIpICE9IFwidmlzaWJsZVwiKSB7XHJcbiAgICAgICAgICBib3gudmlzaWJsZSA9IGJveC5yaWdodCA+IGVsZW0uc2Nyb2xsTGVmdCAmJiBib3gubGVmdCA8IGVsZW0uc2Nyb2xsTGVmdCArIGVsZW0uY2xpZW50V2lkdGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBib3gubGVmdCAtPSBlbGVtLnNjcm9sbExlZnQ7XHJcbiAgICAgICAgYm94LnRvcCAtPSBlbGVtLnNjcm9sbFRvcDtcclxuXHJcbiAgICAgICAgaWYgKGVsZW0gPT09IG9mZnNldFBhcmVudCkge1xyXG4gICAgICAgICAgYm94LmxlZnQgKz0gZWxlbS5vZmZzZXRMZWZ0O1xyXG4gICAgICAgICAgYm94LnRvcCArPSBlbGVtLm9mZnNldFRvcDtcclxuICAgICAgICAgIG9mZnNldFBhcmVudCA9IGVsZW0ub2Zmc2V0UGFyZW50O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYm94LmJvdHRvbSA9IGJveC50b3AgKyBib3guaGVpZ2h0O1xyXG4gICAgICAgIGJveC5yaWdodCA9IGJveC5sZWZ0ICsgYm94LndpZHRoO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gYm94O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldEFjdGl2ZUNlbGxQb3NpdGlvbigpIHtcclxuICAgICAgcmV0dXJuIGFic0JveChhY3RpdmVDZWxsTm9kZSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0R3JpZFBvc2l0aW9uKCkge1xyXG4gICAgICByZXR1cm4gYWJzQm94KCRjb250YWluZXJbMF0pXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaGFuZGxlQWN0aXZlQ2VsbFBvc2l0aW9uQ2hhbmdlKCkge1xyXG4gICAgICBpZiAoIWFjdGl2ZUNlbGxOb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0cmlnZ2VyKHNlbGYub25BY3RpdmVDZWxsUG9zaXRpb25DaGFuZ2VkLCB7Z3JpZDogc2VsZn0pO1xyXG5cclxuICAgICAgaWYgKGN1cnJlbnRFZGl0b3IpIHtcclxuICAgICAgICB2YXIgY2VsbEJveCA9IGdldEFjdGl2ZUNlbGxQb3NpdGlvbigpO1xyXG4gICAgICAgIGlmIChjdXJyZW50RWRpdG9yLnNob3cgJiYgY3VycmVudEVkaXRvci5oaWRlKSB7XHJcbiAgICAgICAgICBpZiAoIWNlbGxCb3gudmlzaWJsZSkge1xyXG4gICAgICAgICAgICBjdXJyZW50RWRpdG9yLmhpZGUoKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRFZGl0b3Iuc2hvdygpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGN1cnJlbnRFZGl0b3IucG9zaXRpb24pIHtcclxuICAgICAgICAgIGN1cnJlbnRFZGl0b3IucG9zaXRpb24oY2VsbEJveCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0Q2VsbEVkaXRvcigpIHtcclxuICAgICAgcmV0dXJuIGN1cnJlbnRFZGl0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0QWN0aXZlQ2VsbCgpIHtcclxuICAgICAgaWYgKCFhY3RpdmVDZWxsTm9kZSkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB7cm93OiBhY3RpdmVSb3csIGNlbGw6IGFjdGl2ZUNlbGwsIGdyaWQ6IHNlbGZ9O1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0QWN0aXZlQ2VsbE5vZGUoKSB7XHJcbiAgICAgIHJldHVybiBhY3RpdmVDZWxsTm9kZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzY3JvbGxSb3dJbnRvVmlldyhyb3csIGRvUGFnaW5nKSB7XHJcbiAgICAgIHZhciByb3dBdFRvcCA9IHJvdyAqIG9wdGlvbnMucm93SGVpZ2h0O1xyXG4gICAgICB2YXIgcm93QXRCb3R0b20gPSAocm93ICsgMSkgKiBvcHRpb25zLnJvd0hlaWdodCAtIHZpZXdwb3J0SCArICh2aWV3cG9ydEhhc0hTY3JvbGwgPyBzY3JvbGxiYXJEaW1lbnNpb25zLmhlaWdodCA6IDApO1xyXG5cclxuICAgICAgLy8gbmVlZCB0byBwYWdlIGRvd24/XHJcbiAgICAgIGlmICgocm93ICsgMSkgKiBvcHRpb25zLnJvd0hlaWdodCA+IHNjcm9sbFRvcCArIHZpZXdwb3J0SCArIG9mZnNldCkge1xyXG4gICAgICAgIHNjcm9sbFRvKGRvUGFnaW5nID8gcm93QXRUb3AgOiByb3dBdEJvdHRvbSk7XHJcbiAgICAgICAgcmVuZGVyKCk7XHJcbiAgICAgIH1cclxuICAgICAgLy8gb3IgcGFnZSB1cD9cclxuICAgICAgZWxzZSBpZiAocm93ICogb3B0aW9ucy5yb3dIZWlnaHQgPCBzY3JvbGxUb3AgKyBvZmZzZXQpIHtcclxuICAgICAgICBzY3JvbGxUbyhkb1BhZ2luZyA/IHJvd0F0Qm90dG9tIDogcm93QXRUb3ApO1xyXG4gICAgICAgIHJlbmRlcigpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2Nyb2xsUm93VG9Ub3Aocm93KSB7XHJcbiAgICAgIHNjcm9sbFRvKHJvdyAqIG9wdGlvbnMucm93SGVpZ2h0KTtcclxuICAgICAgcmVuZGVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2Nyb2xsUGFnZShkaXIpIHtcclxuICAgICAgdmFyIGRlbHRhUm93cyA9IGRpciAqIG51bVZpc2libGVSb3dzO1xyXG4gICAgICBzY3JvbGxUbygoZ2V0Um93RnJvbVBvc2l0aW9uKHNjcm9sbFRvcCkgKyBkZWx0YVJvd3MpICogb3B0aW9ucy5yb3dIZWlnaHQpO1xyXG4gICAgICByZW5kZXIoKTtcclxuXHJcbiAgICAgIGlmIChvcHRpb25zLmVuYWJsZUNlbGxOYXZpZ2F0aW9uICYmIGFjdGl2ZVJvdyAhPSBudWxsKSB7XHJcbiAgICAgICAgdmFyIHJvdyA9IGFjdGl2ZVJvdyArIGRlbHRhUm93cztcclxuICAgICAgICB2YXIgZGF0YUxlbmd0aEluY2x1ZGluZ0FkZE5ldyA9IGdldERhdGFMZW5ndGhJbmNsdWRpbmdBZGROZXcoKTtcclxuICAgICAgICBpZiAocm93ID49IGRhdGFMZW5ndGhJbmNsdWRpbmdBZGROZXcpIHtcclxuICAgICAgICAgIHJvdyA9IGRhdGFMZW5ndGhJbmNsdWRpbmdBZGROZXcgLSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocm93IDwgMCkge1xyXG4gICAgICAgICAgcm93ID0gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBjZWxsID0gMCwgcHJldkNlbGwgPSBudWxsO1xyXG4gICAgICAgIHZhciBwcmV2QWN0aXZlUG9zWCA9IGFjdGl2ZVBvc1g7XHJcbiAgICAgICAgd2hpbGUgKGNlbGwgPD0gYWN0aXZlUG9zWCkge1xyXG4gICAgICAgICAgaWYgKGNhbkNlbGxCZUFjdGl2ZShyb3csIGNlbGwpKSB7XHJcbiAgICAgICAgICAgIHByZXZDZWxsID0gY2VsbDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGNlbGwgKz0gZ2V0Q29sc3Bhbihyb3csIGNlbGwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHByZXZDZWxsICE9PSBudWxsKSB7XHJcbiAgICAgICAgICBzZXRBY3RpdmVDZWxsSW50ZXJuYWwoZ2V0Q2VsbE5vZGUocm93LCBwcmV2Q2VsbCkpO1xyXG4gICAgICAgICAgYWN0aXZlUG9zWCA9IHByZXZBY3RpdmVQb3NYO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXNldEFjdGl2ZUNlbGwoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBuYXZpZ2F0ZVBhZ2VEb3duKCkge1xyXG4gICAgICBzY3JvbGxQYWdlKDEpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG5hdmlnYXRlUGFnZVVwKCkge1xyXG4gICAgICAgc2Nyb2xsUGFnZSgtMSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbmF2aWdhdGVUb3AoKSB7XHJcbiAgICAgICBuYXZpZ2F0ZVRvUm93KDApO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG5hdmlnYXRlQm90dG9tKCkge1xyXG4gICAgICAgbmF2aWdhdGVUb1JvdyhnZXREYXRhTGVuZ3RoKCktMSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbmF2aWdhdGVUb1Jvdyhyb3cpIHtcclxuICAgICAgIHZhciBudW1fcm93cyA9IGdldERhdGFMZW5ndGgoKTtcclxuICAgICAgIGlmICghbnVtX3Jvd3MpIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgIGlmIChyb3cgPCAwKSByb3cgPSAwO1xyXG4gICAgICAgZWxzZSBpZiAocm93ID49IG51bV9yb3dzKSByb3cgPSBudW1fcm93cyAtIDE7XHJcblxyXG4gICAgICAgc2Nyb2xsQ2VsbEludG9WaWV3KHJvdywgMCwgdHJ1ZSk7XHJcbiAgICAgICBpZiAob3B0aW9ucy5lbmFibGVDZWxsTmF2aWdhdGlvbiAmJiBhY3RpdmVSb3cgIT0gbnVsbCkge1xyXG4gICAgICAgICAgdmFyIGNlbGwgPSAwLCBwcmV2Q2VsbCA9IG51bGw7XHJcbiAgICAgICAgICB2YXIgcHJldkFjdGl2ZVBvc1ggPSBhY3RpdmVQb3NYO1xyXG4gICAgICAgICAgd2hpbGUgKGNlbGwgPD0gYWN0aXZlUG9zWCkge1xyXG4gICAgICAgICAgICAgaWYgKGNhbkNlbGxCZUFjdGl2ZShyb3csIGNlbGwpKSB7XHJcbiAgICAgICAgICAgICAgICBwcmV2Q2VsbCA9IGNlbGw7XHJcbiAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICBjZWxsICs9IGdldENvbHNwYW4ocm93LCBjZWxsKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAocHJldkNlbGwgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgIHNldEFjdGl2ZUNlbGxJbnRlcm5hbChnZXRDZWxsTm9kZShyb3csIHByZXZDZWxsKSk7XHJcbiAgICAgICAgICAgICBhY3RpdmVQb3NYID0gcHJldkFjdGl2ZVBvc1g7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgcmVzZXRBY3RpdmVDZWxsKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICB9XHJcbiAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRDb2xzcGFuKHJvdywgY2VsbCkge1xyXG4gICAgICB2YXIgbWV0YWRhdGEgPSBkYXRhLmdldEl0ZW1NZXRhZGF0YSAmJiBkYXRhLmdldEl0ZW1NZXRhZGF0YShyb3cpO1xyXG4gICAgICBpZiAoIW1ldGFkYXRhIHx8ICFtZXRhZGF0YS5jb2x1bW5zKSB7XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBjb2x1bW5EYXRhID0gbWV0YWRhdGEuY29sdW1uc1tjb2x1bW5zW2NlbGxdLmlkXSB8fCBtZXRhZGF0YS5jb2x1bW5zW2NlbGxdO1xyXG4gICAgICB2YXIgY29sc3BhbiA9IChjb2x1bW5EYXRhICYmIGNvbHVtbkRhdGEuY29sc3Bhbik7XHJcbiAgICAgIGlmIChjb2xzcGFuID09PSBcIipcIikge1xyXG4gICAgICAgIGNvbHNwYW4gPSBjb2x1bW5zLmxlbmd0aCAtIGNlbGw7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29sc3BhbiA9IGNvbHNwYW4gfHwgMTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGNvbHNwYW47XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZmluZEZpcnN0Rm9jdXNhYmxlQ2VsbChyb3cpIHtcclxuICAgICAgdmFyIGNlbGwgPSAwO1xyXG4gICAgICB3aGlsZSAoY2VsbCA8IGNvbHVtbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgaWYgKGNhbkNlbGxCZUFjdGl2ZShyb3csIGNlbGwpKSB7XHJcbiAgICAgICAgICByZXR1cm4gY2VsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2VsbCArPSBnZXRDb2xzcGFuKHJvdywgY2VsbCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZmluZExhc3RGb2N1c2FibGVDZWxsKHJvdykge1xyXG4gICAgICB2YXIgY2VsbCA9IDA7XHJcbiAgICAgIHZhciBsYXN0Rm9jdXNhYmxlQ2VsbCA9IG51bGw7XHJcbiAgICAgIHdoaWxlIChjZWxsIDwgY29sdW1ucy5sZW5ndGgpIHtcclxuICAgICAgICBpZiAoY2FuQ2VsbEJlQWN0aXZlKHJvdywgY2VsbCkpIHtcclxuICAgICAgICAgIGxhc3RGb2N1c2FibGVDZWxsID0gY2VsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2VsbCArPSBnZXRDb2xzcGFuKHJvdywgY2VsbCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGxhc3RGb2N1c2FibGVDZWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdvdG9SaWdodChyb3csIGNlbGwsIHBvc1gpIHtcclxuICAgICAgaWYgKGNlbGwgPj0gY29sdW1ucy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG5cclxuICAgICAgZG8ge1xyXG4gICAgICAgIGNlbGwgKz0gZ2V0Q29sc3Bhbihyb3csIGNlbGwpO1xyXG4gICAgICB9XHJcbiAgICAgIHdoaWxlIChjZWxsIDwgY29sdW1ucy5sZW5ndGggJiYgIWNhbkNlbGxCZUFjdGl2ZShyb3csIGNlbGwpKTtcclxuXHJcbiAgICAgIGlmIChjZWxsIDwgY29sdW1ucy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgXCJyb3dcIjogcm93LFxyXG4gICAgICAgICAgXCJjZWxsXCI6IGNlbGwsXHJcbiAgICAgICAgICBcInBvc1hcIjogY2VsbFxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ290b0xlZnQocm93LCBjZWxsLCBwb3NYKSB7XHJcbiAgICAgIGlmIChjZWxsIDw9IDApIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGZpcnN0Rm9jdXNhYmxlQ2VsbCA9IGZpbmRGaXJzdEZvY3VzYWJsZUNlbGwocm93KTtcclxuICAgICAgaWYgKGZpcnN0Rm9jdXNhYmxlQ2VsbCA9PT0gbnVsbCB8fCBmaXJzdEZvY3VzYWJsZUNlbGwgPj0gY2VsbCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgcHJldiA9IHtcclxuICAgICAgICBcInJvd1wiOiByb3csXHJcbiAgICAgICAgXCJjZWxsXCI6IGZpcnN0Rm9jdXNhYmxlQ2VsbCxcclxuICAgICAgICBcInBvc1hcIjogZmlyc3RGb2N1c2FibGVDZWxsXHJcbiAgICAgIH07XHJcbiAgICAgIHZhciBwb3M7XHJcbiAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgcG9zID0gZ290b1JpZ2h0KHByZXYucm93LCBwcmV2LmNlbGwsIHByZXYucG9zWCk7XHJcbiAgICAgICAgaWYgKCFwb3MpIHtcclxuICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocG9zLmNlbGwgPj0gY2VsbCkge1xyXG4gICAgICAgICAgcmV0dXJuIHByZXY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByZXYgPSBwb3M7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnb3RvRG93bihyb3csIGNlbGwsIHBvc1gpIHtcclxuICAgICAgdmFyIHByZXZDZWxsO1xyXG4gICAgICB2YXIgZGF0YUxlbmd0aEluY2x1ZGluZ0FkZE5ldyA9IGdldERhdGFMZW5ndGhJbmNsdWRpbmdBZGROZXcoKTtcclxuICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICBpZiAoKytyb3cgPj0gZGF0YUxlbmd0aEluY2x1ZGluZ0FkZE5ldykge1xyXG4gICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcmV2Q2VsbCA9IGNlbGwgPSAwO1xyXG4gICAgICAgIHdoaWxlIChjZWxsIDw9IHBvc1gpIHtcclxuICAgICAgICAgIHByZXZDZWxsID0gY2VsbDtcclxuICAgICAgICAgIGNlbGwgKz0gZ2V0Q29sc3Bhbihyb3csIGNlbGwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNhbkNlbGxCZUFjdGl2ZShyb3csIHByZXZDZWxsKSkge1xyXG4gICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgXCJyb3dcIjogcm93LFxyXG4gICAgICAgICAgICBcImNlbGxcIjogcHJldkNlbGwsXHJcbiAgICAgICAgICAgIFwicG9zWFwiOiBwb3NYXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdvdG9VcChyb3csIGNlbGwsIHBvc1gpIHtcclxuICAgICAgdmFyIHByZXZDZWxsO1xyXG4gICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgIGlmICgtLXJvdyA8IDApIHtcclxuICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJldkNlbGwgPSBjZWxsID0gMDtcclxuICAgICAgICB3aGlsZSAoY2VsbCA8PSBwb3NYKSB7XHJcbiAgICAgICAgICBwcmV2Q2VsbCA9IGNlbGw7XHJcbiAgICAgICAgICBjZWxsICs9IGdldENvbHNwYW4ocm93LCBjZWxsKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChjYW5DZWxsQmVBY3RpdmUocm93LCBwcmV2Q2VsbCkpIHtcclxuICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIFwicm93XCI6IHJvdyxcclxuICAgICAgICAgICAgXCJjZWxsXCI6IHByZXZDZWxsLFxyXG4gICAgICAgICAgICBcInBvc1hcIjogcG9zWFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnb3RvTmV4dChyb3csIGNlbGwsIHBvc1gpIHtcclxuICAgICAgaWYgKHJvdyA9PSBudWxsICYmIGNlbGwgPT0gbnVsbCkge1xyXG4gICAgICAgIHJvdyA9IGNlbGwgPSBwb3NYID0gMDtcclxuICAgICAgICBpZiAoY2FuQ2VsbEJlQWN0aXZlKHJvdywgY2VsbCkpIHtcclxuICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIFwicm93XCI6IHJvdyxcclxuICAgICAgICAgICAgXCJjZWxsXCI6IGNlbGwsXHJcbiAgICAgICAgICAgIFwicG9zWFwiOiBjZWxsXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHBvcyA9IGdvdG9SaWdodChyb3csIGNlbGwsIHBvc1gpO1xyXG4gICAgICBpZiAocG9zKSB7XHJcbiAgICAgICAgcmV0dXJuIHBvcztcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGZpcnN0Rm9jdXNhYmxlQ2VsbCA9IG51bGw7XHJcbiAgICAgIHZhciBkYXRhTGVuZ3RoSW5jbHVkaW5nQWRkTmV3ID0gZ2V0RGF0YUxlbmd0aEluY2x1ZGluZ0FkZE5ldygpO1xyXG5cclxuICAgICAgLy8gaWYgYXQgbGFzdCByb3csIGN5Y2xlIHRocm91Z2ggY29sdW1ucyByYXRoZXIgdGhhbiBnZXQgc3R1Y2sgaW4gdGhlIGxhc3Qgb25lXHJcbiAgICAgIGlmIChyb3cgPT09IGRhdGFMZW5ndGhJbmNsdWRpbmdBZGROZXcgLSAxKSB7IHJvdy0tOyB9XHJcblxyXG4gICAgICB3aGlsZSAoKytyb3cgPCBkYXRhTGVuZ3RoSW5jbHVkaW5nQWRkTmV3KSB7XHJcbiAgICAgICAgZmlyc3RGb2N1c2FibGVDZWxsID0gZmluZEZpcnN0Rm9jdXNhYmxlQ2VsbChyb3cpO1xyXG4gICAgICAgIGlmIChmaXJzdEZvY3VzYWJsZUNlbGwgIT09IG51bGwpIHtcclxuICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIFwicm93XCI6IHJvdyxcclxuICAgICAgICAgICAgXCJjZWxsXCI6IGZpcnN0Rm9jdXNhYmxlQ2VsbCxcclxuICAgICAgICAgICAgXCJwb3NYXCI6IGZpcnN0Rm9jdXNhYmxlQ2VsbFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ290b1ByZXYocm93LCBjZWxsLCBwb3NYKSB7XHJcbiAgICAgIGlmIChyb3cgPT0gbnVsbCAmJiBjZWxsID09IG51bGwpIHtcclxuICAgICAgICByb3cgPSBnZXREYXRhTGVuZ3RoSW5jbHVkaW5nQWRkTmV3KCkgLSAxO1xyXG4gICAgICAgIGNlbGwgPSBwb3NYID0gY29sdW1ucy5sZW5ndGggLSAxO1xyXG4gICAgICAgIGlmIChjYW5DZWxsQmVBY3RpdmUocm93LCBjZWxsKSkge1xyXG4gICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgXCJyb3dcIjogcm93LFxyXG4gICAgICAgICAgICBcImNlbGxcIjogY2VsbCxcclxuICAgICAgICAgICAgXCJwb3NYXCI6IGNlbGxcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgcG9zO1xyXG4gICAgICB2YXIgbGFzdFNlbGVjdGFibGVDZWxsO1xyXG4gICAgICB3aGlsZSAoIXBvcykge1xyXG4gICAgICAgIHBvcyA9IGdvdG9MZWZ0KHJvdywgY2VsbCwgcG9zWCk7XHJcbiAgICAgICAgaWYgKHBvcykge1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgtLXJvdyA8IDApIHtcclxuICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY2VsbCA9IDA7XHJcbiAgICAgICAgbGFzdFNlbGVjdGFibGVDZWxsID0gZmluZExhc3RGb2N1c2FibGVDZWxsKHJvdyk7XHJcbiAgICAgICAgaWYgKGxhc3RTZWxlY3RhYmxlQ2VsbCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgcG9zID0ge1xyXG4gICAgICAgICAgICBcInJvd1wiOiByb3csXHJcbiAgICAgICAgICAgIFwiY2VsbFwiOiBsYXN0U2VsZWN0YWJsZUNlbGwsXHJcbiAgICAgICAgICAgIFwicG9zWFwiOiBsYXN0U2VsZWN0YWJsZUNlbGxcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBwb3M7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ290b1Jvd1N0YXJ0KHJvdywgY2VsbCwgcG9zWCkge1xyXG4gICAgICAgdmFyIG5ld0NlbGwgPSBmaW5kRmlyc3RGb2N1c2FibGVDZWxsKHJvdyk7XHJcbiAgICAgICBpZiAobmV3Q2VsbCA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIFwicm93XCI6IHJvdyxcclxuICAgICAgICAgIFwiY2VsbFwiOiBuZXdDZWxsLFxyXG4gICAgICAgICAgXCJwb3NYXCI6IHBvc1hcclxuICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ290b1Jvd0VuZChyb3csIGNlbGwsIHBvc1gpIHtcclxuICAgICAgIHZhciBuZXdDZWxsID0gZmluZExhc3RGb2N1c2FibGVDZWxsKHJvdyk7XHJcbiAgICAgICBpZiAobmV3Q2VsbCA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIFwicm93XCI6IHJvdyxcclxuICAgICAgICAgIFwiY2VsbFwiOiBuZXdDZWxsLFxyXG4gICAgICAgICAgXCJwb3NYXCI6IHBvc1hcclxuICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbmF2aWdhdGVSaWdodCgpIHtcclxuICAgICAgcmV0dXJuIG5hdmlnYXRlKFwicmlnaHRcIik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbmF2aWdhdGVMZWZ0KCkge1xyXG4gICAgICByZXR1cm4gbmF2aWdhdGUoXCJsZWZ0XCIpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG5hdmlnYXRlRG93bigpIHtcclxuICAgICAgcmV0dXJuIG5hdmlnYXRlKFwiZG93blwiKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBuYXZpZ2F0ZVVwKCkge1xyXG4gICAgICByZXR1cm4gbmF2aWdhdGUoXCJ1cFwiKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBuYXZpZ2F0ZU5leHQoKSB7XHJcbiAgICAgIHJldHVybiBuYXZpZ2F0ZShcIm5leHRcIik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbmF2aWdhdGVQcmV2KCkge1xyXG4gICAgICAgcmV0dXJuIG5hdmlnYXRlKFwicHJldlwiKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBuYXZpZ2F0ZVJvd1N0YXJ0KCkge1xyXG4gICAgICAgcmV0dXJuIG5hdmlnYXRlKFwiaG9tZVwiKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBuYXZpZ2F0ZVJvd0VuZCgpIHtcclxuICAgICAgIHJldHVybiBuYXZpZ2F0ZShcImVuZFwiKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkaXIgTmF2aWdhdGlvbiBkaXJlY3Rpb24uXHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG5hdmlnYXRpb24gcmVzdWx0ZWQgaW4gYSBjaGFuZ2Ugb2YgYWN0aXZlIGNlbGwuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG5hdmlnYXRlKGRpcikge1xyXG4gICAgICBpZiAoIW9wdGlvbnMuZW5hYmxlQ2VsbE5hdmlnYXRpb24pIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghYWN0aXZlQ2VsbE5vZGUgJiYgZGlyICE9IFwicHJldlwiICYmIGRpciAhPSBcIm5leHRcIikge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFnZXRFZGl0b3JMb2NrKCkuY29tbWl0Q3VycmVudEVkaXQoKSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHNldEZvY3VzKCk7XHJcblxyXG4gICAgICB2YXIgdGFiYmluZ0RpcmVjdGlvbnMgPSB7XHJcbiAgICAgICAgXCJ1cFwiOiAtMSxcclxuICAgICAgICBcImRvd25cIjogMSxcclxuICAgICAgICBcImxlZnRcIjogLTEsXHJcbiAgICAgICAgXCJyaWdodFwiOiAxLFxyXG4gICAgICAgIFwicHJldlwiOiAtMSxcclxuICAgICAgICBcIm5leHRcIjogMSxcclxuICAgICAgICBcImhvbWVcIjogLTEsXHJcbiAgICAgICAgXCJlbmRcIjogMVxyXG4gICAgICB9O1xyXG4gICAgICB0YWJiaW5nRGlyZWN0aW9uID0gdGFiYmluZ0RpcmVjdGlvbnNbZGlyXTtcclxuXHJcbiAgICAgIHZhciBzdGVwRnVuY3Rpb25zID0ge1xyXG4gICAgICAgIFwidXBcIjogZ290b1VwLFxyXG4gICAgICAgIFwiZG93blwiOiBnb3RvRG93bixcclxuICAgICAgICBcImxlZnRcIjogZ290b0xlZnQsXHJcbiAgICAgICAgXCJyaWdodFwiOiBnb3RvUmlnaHQsXHJcbiAgICAgICAgXCJwcmV2XCI6IGdvdG9QcmV2LFxyXG4gICAgICAgIFwibmV4dFwiOiBnb3RvTmV4dCxcclxuICAgICAgICBcImhvbWVcIjogZ290b1Jvd1N0YXJ0LFxyXG4gICAgICAgIFwiZW5kXCI6IGdvdG9Sb3dFbmRcclxuICAgICAgfTtcclxuICAgICAgdmFyIHN0ZXBGbiA9IHN0ZXBGdW5jdGlvbnNbZGlyXTtcclxuICAgICAgdmFyIHBvcyA9IHN0ZXBGbihhY3RpdmVSb3csIGFjdGl2ZUNlbGwsIGFjdGl2ZVBvc1gpO1xyXG4gICAgICBpZiAocG9zKSB7XHJcbiAgICAgICAgdmFyIGlzQWRkTmV3Um93ID0gKHBvcy5yb3cgPT0gZ2V0RGF0YUxlbmd0aCgpKTtcclxuICAgICAgICBzY3JvbGxDZWxsSW50b1ZpZXcocG9zLnJvdywgcG9zLmNlbGwsICFpc0FkZE5ld1JvdyAmJiBvcHRpb25zLmVtdWxhdGVQYWdpbmdXaGVuU2Nyb2xsaW5nKTtcclxuICAgICAgICBzZXRBY3RpdmVDZWxsSW50ZXJuYWwoZ2V0Q2VsbE5vZGUocG9zLnJvdywgcG9zLmNlbGwpKTtcclxuICAgICAgICBhY3RpdmVQb3NYID0gcG9zLnBvc1g7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc2V0QWN0aXZlQ2VsbEludGVybmFsKGdldENlbGxOb2RlKGFjdGl2ZVJvdywgYWN0aXZlQ2VsbCkpO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldENlbGxOb2RlKHJvdywgY2VsbCkge1xyXG4gICAgICBpZiAocm93c0NhY2hlW3Jvd10pIHtcclxuICAgICAgICBlbnN1cmVDZWxsTm9kZXNJblJvd3NDYWNoZShyb3cpO1xyXG4gICAgICAgIHJldHVybiByb3dzQ2FjaGVbcm93XS5jZWxsTm9kZXNCeUNvbHVtbklkeFtjZWxsXTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzZXRBY3RpdmVDZWxsKHJvdywgY2VsbCwgb3B0X2VkaXRNb2RlLCBwcmVDbGlja01vZGVPbiwgc3VwcHJlc3NBY3RpdmVDZWxsQ2hhbmdlZEV2ZW50KSB7XHJcbiAgICAgIGlmICghaW5pdGlhbGl6ZWQpIHsgcmV0dXJuOyB9XHJcbiAgICAgIGlmIChyb3cgPiBnZXREYXRhTGVuZ3RoKCkgfHwgcm93IDwgMCB8fCBjZWxsID49IGNvbHVtbnMubGVuZ3RoIHx8IGNlbGwgPCAwKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIW9wdGlvbnMuZW5hYmxlQ2VsbE5hdmlnYXRpb24pIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHNjcm9sbENlbGxJbnRvVmlldyhyb3csIGNlbGwsIGZhbHNlKTtcclxuICAgICAgc2V0QWN0aXZlQ2VsbEludGVybmFsKGdldENlbGxOb2RlKHJvdywgY2VsbCksIG9wdF9lZGl0TW9kZSwgcHJlQ2xpY2tNb2RlT24sIHN1cHByZXNzQWN0aXZlQ2VsbENoYW5nZWRFdmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY2FuQ2VsbEJlQWN0aXZlKHJvdywgY2VsbCkge1xyXG4gICAgICBpZiAoIW9wdGlvbnMuZW5hYmxlQ2VsbE5hdmlnYXRpb24gfHwgcm93ID49IGdldERhdGFMZW5ndGhJbmNsdWRpbmdBZGROZXcoKSB8fFxyXG4gICAgICAgICAgcm93IDwgMCB8fCBjZWxsID49IGNvbHVtbnMubGVuZ3RoIHx8IGNlbGwgPCAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgcm93TWV0YWRhdGEgPSBkYXRhLmdldEl0ZW1NZXRhZGF0YSAmJiBkYXRhLmdldEl0ZW1NZXRhZGF0YShyb3cpO1xyXG4gICAgICBpZiAocm93TWV0YWRhdGEgJiYgdHlwZW9mIHJvd01ldGFkYXRhLmZvY3VzYWJsZSAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgIHJldHVybiAhIXJvd01ldGFkYXRhLmZvY3VzYWJsZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGNvbHVtbk1ldGFkYXRhID0gcm93TWV0YWRhdGEgJiYgcm93TWV0YWRhdGEuY29sdW1ucztcclxuICAgICAgaWYgKGNvbHVtbk1ldGFkYXRhICYmIGNvbHVtbk1ldGFkYXRhW2NvbHVtbnNbY2VsbF0uaWRdICYmIHR5cGVvZiBjb2x1bW5NZXRhZGF0YVtjb2x1bW5zW2NlbGxdLmlkXS5mb2N1c2FibGUgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICByZXR1cm4gISFjb2x1bW5NZXRhZGF0YVtjb2x1bW5zW2NlbGxdLmlkXS5mb2N1c2FibGU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGNvbHVtbk1ldGFkYXRhICYmIGNvbHVtbk1ldGFkYXRhW2NlbGxdICYmIHR5cGVvZiBjb2x1bW5NZXRhZGF0YVtjZWxsXS5mb2N1c2FibGUgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICByZXR1cm4gISFjb2x1bW5NZXRhZGF0YVtjZWxsXS5mb2N1c2FibGU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiAhIWNvbHVtbnNbY2VsbF0uZm9jdXNhYmxlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNhbkNlbGxCZVNlbGVjdGVkKHJvdywgY2VsbCkge1xyXG4gICAgICBpZiAocm93ID49IGdldERhdGFMZW5ndGgoKSB8fCByb3cgPCAwIHx8IGNlbGwgPj0gY29sdW1ucy5sZW5ndGggfHwgY2VsbCA8IDApIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciByb3dNZXRhZGF0YSA9IGRhdGEuZ2V0SXRlbU1ldGFkYXRhICYmIGRhdGEuZ2V0SXRlbU1ldGFkYXRhKHJvdyk7XHJcbiAgICAgIGlmIChyb3dNZXRhZGF0YSAmJiB0eXBlb2Ygcm93TWV0YWRhdGEuc2VsZWN0YWJsZSAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgIHJldHVybiAhIXJvd01ldGFkYXRhLnNlbGVjdGFibGU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBjb2x1bW5NZXRhZGF0YSA9IHJvd01ldGFkYXRhICYmIHJvd01ldGFkYXRhLmNvbHVtbnMgJiYgKHJvd01ldGFkYXRhLmNvbHVtbnNbY29sdW1uc1tjZWxsXS5pZF0gfHwgcm93TWV0YWRhdGEuY29sdW1uc1tjZWxsXSk7XHJcbiAgICAgIGlmIChjb2x1bW5NZXRhZGF0YSAmJiB0eXBlb2YgY29sdW1uTWV0YWRhdGEuc2VsZWN0YWJsZSAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgIHJldHVybiAhIWNvbHVtbk1ldGFkYXRhLnNlbGVjdGFibGU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiAhIWNvbHVtbnNbY2VsbF0uc2VsZWN0YWJsZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnb3RvQ2VsbChyb3csIGNlbGwsIGZvcmNlRWRpdCkge1xyXG4gICAgICBpZiAoIWluaXRpYWxpemVkKSB7IHJldHVybjsgfVxyXG4gICAgICBpZiAoIWNhbkNlbGxCZUFjdGl2ZShyb3csIGNlbGwpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIWdldEVkaXRvckxvY2soKS5jb21taXRDdXJyZW50RWRpdCgpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzY3JvbGxDZWxsSW50b1ZpZXcocm93LCBjZWxsLCBmYWxzZSk7XHJcblxyXG4gICAgICB2YXIgbmV3Q2VsbCA9IGdldENlbGxOb2RlKHJvdywgY2VsbCk7XHJcblxyXG4gICAgICAvLyBpZiBzZWxlY3RpbmcgdGhlICdhZGQgbmV3JyByb3csIHN0YXJ0IGVkaXRpbmcgcmlnaHQgYXdheVxyXG4gICAgICBzZXRBY3RpdmVDZWxsSW50ZXJuYWwobmV3Q2VsbCwgKGZvcmNlRWRpdCB8fCAocm93ID09PSBnZXREYXRhTGVuZ3RoKCkpIHx8IG9wdGlvbnMuYXV0b0VkaXQpLCBudWxsLCBvcHRpb25zLmVkaXRhYmxlKTtcclxuXHJcbiAgICAgIC8vIGlmIG5vIGVkaXRvciB3YXMgY3JlYXRlZCwgc2V0IHRoZSBmb2N1cyBiYWNrIG9uIHRoZSBncmlkXHJcbiAgICAgIGlmICghY3VycmVudEVkaXRvcikge1xyXG4gICAgICAgIHNldEZvY3VzKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gICAgLy8gSUVkaXRvciBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIGVkaXRvciBsb2NrXHJcblxyXG4gICAgZnVuY3Rpb24gY29tbWl0Q3VycmVudEVkaXQoKSB7XHJcbiAgICAgIHZhciBpdGVtID0gZ2V0RGF0YUl0ZW0oYWN0aXZlUm93KTtcclxuICAgICAgdmFyIGNvbHVtbiA9IGNvbHVtbnNbYWN0aXZlQ2VsbF07XHJcblxyXG4gICAgICBpZiAoY3VycmVudEVkaXRvcikge1xyXG4gICAgICAgIGlmIChjdXJyZW50RWRpdG9yLmlzVmFsdWVDaGFuZ2VkKCkpIHtcclxuICAgICAgICAgIHZhciB2YWxpZGF0aW9uUmVzdWx0cyA9IGN1cnJlbnRFZGl0b3IudmFsaWRhdGUoKTtcclxuXHJcbiAgICAgICAgICBpZiAodmFsaWRhdGlvblJlc3VsdHMudmFsaWQpIHtcclxuICAgICAgICAgICAgaWYgKGFjdGl2ZVJvdyA8IGdldERhdGFMZW5ndGgoKSkge1xyXG4gICAgICAgICAgICAgIHZhciBlZGl0Q29tbWFuZCA9IHtcclxuICAgICAgICAgICAgICAgIHJvdzogYWN0aXZlUm93LFxyXG4gICAgICAgICAgICAgICAgY2VsbDogYWN0aXZlQ2VsbCxcclxuICAgICAgICAgICAgICAgIGVkaXRvcjogY3VycmVudEVkaXRvcixcclxuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWRWYWx1ZTogY3VycmVudEVkaXRvci5zZXJpYWxpemVWYWx1ZSgpLFxyXG4gICAgICAgICAgICAgICAgcHJldlNlcmlhbGl6ZWRWYWx1ZTogc2VyaWFsaXplZEVkaXRvclZhbHVlLFxyXG4gICAgICAgICAgICAgICAgZXhlY3V0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci5hcHBseVZhbHVlKGl0ZW0sIHRoaXMuc2VyaWFsaXplZFZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgdXBkYXRlUm93KHRoaXMucm93KTtcclxuICAgICAgICAgICAgICAgICAgdHJpZ2dlcihzZWxmLm9uQ2VsbENoYW5nZSwge1xyXG4gICAgICAgICAgICAgICAgICAgIHJvdzogdGhpcy5yb3csXHJcbiAgICAgICAgICAgICAgICAgICAgY2VsbDogdGhpcy5jZWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW06IGl0ZW0sXHJcbiAgICAgICAgICAgICAgICAgICAgZ3JpZDogc2VsZlxyXG4gICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB1bmRvOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgIHRoaXMuZWRpdG9yLmFwcGx5VmFsdWUoaXRlbSwgdGhpcy5wcmV2U2VyaWFsaXplZFZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgdXBkYXRlUm93KHRoaXMucm93KTtcclxuICAgICAgICAgICAgICAgICAgdHJpZ2dlcihzZWxmLm9uQ2VsbENoYW5nZSwge1xyXG4gICAgICAgICAgICAgICAgICAgIHJvdzogdGhpcy5yb3csXHJcbiAgICAgICAgICAgICAgICAgICAgY2VsbDogdGhpcy5jZWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW06IGl0ZW0sXHJcbiAgICAgICAgICAgICAgICAgICAgZ3JpZDogc2VsZlxyXG4gICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICBpZiAob3B0aW9ucy5lZGl0Q29tbWFuZEhhbmRsZXIpIHtcclxuICAgICAgICAgICAgICAgIG1ha2VBY3RpdmVDZWxsTm9ybWFsKCk7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLmVkaXRDb21tYW5kSGFuZGxlcihpdGVtLCBjb2x1bW4sIGVkaXRDb21tYW5kKTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZWRpdENvbW1hbmQuZXhlY3V0ZSgpO1xyXG4gICAgICAgICAgICAgICAgbWFrZUFjdGl2ZUNlbGxOb3JtYWwoKTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHZhciBuZXdJdGVtID0ge307XHJcbiAgICAgICAgICAgICAgY3VycmVudEVkaXRvci5hcHBseVZhbHVlKG5ld0l0ZW0sIGN1cnJlbnRFZGl0b3Iuc2VyaWFsaXplVmFsdWUoKSk7XHJcbiAgICAgICAgICAgICAgbWFrZUFjdGl2ZUNlbGxOb3JtYWwoKTtcclxuICAgICAgICAgICAgICB0cmlnZ2VyKHNlbGYub25BZGROZXdSb3csIHtpdGVtOiBuZXdJdGVtLCBjb2x1bW46IGNvbHVtbiwgZ3JpZDogc2VsZn0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBjaGVjayB3aGV0aGVyIHRoZSBsb2NrIGhhcyBiZWVuIHJlLWFjcXVpcmVkIGJ5IGV2ZW50IGhhbmRsZXJzXHJcbiAgICAgICAgICAgIHJldHVybiAhZ2V0RWRpdG9yTG9jaygpLmlzQWN0aXZlKCk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBSZS1hZGQgdGhlIENTUyBjbGFzcyB0byB0cmlnZ2VyIHRyYW5zaXRpb25zLCBpZiBhbnkuXHJcbiAgICAgICAgICAgICQoYWN0aXZlQ2VsbE5vZGUpLnJlbW92ZUNsYXNzKFwiaW52YWxpZFwiKTtcclxuICAgICAgICAgICAgJChhY3RpdmVDZWxsTm9kZSkud2lkdGgoKTsgIC8vIGZvcmNlIGxheW91dFxyXG4gICAgICAgICAgICAkKGFjdGl2ZUNlbGxOb2RlKS5hZGRDbGFzcyhcImludmFsaWRcIik7XHJcblxyXG4gICAgICAgICAgICB0cmlnZ2VyKHNlbGYub25WYWxpZGF0aW9uRXJyb3IsIHtcclxuICAgICAgICAgICAgICBlZGl0b3I6IGN1cnJlbnRFZGl0b3IsXHJcbiAgICAgICAgICAgICAgY2VsbE5vZGU6IGFjdGl2ZUNlbGxOb2RlLFxyXG4gICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHRzOiB2YWxpZGF0aW9uUmVzdWx0cyxcclxuICAgICAgICAgICAgICByb3c6IGFjdGl2ZVJvdyxcclxuICAgICAgICAgICAgICBjZWxsOiBhY3RpdmVDZWxsLFxyXG4gICAgICAgICAgICAgIGNvbHVtbjogY29sdW1uLFxyXG4gICAgICAgICAgICAgIGdyaWQ6IHNlbGZcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBjdXJyZW50RWRpdG9yLmZvY3VzKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG1ha2VBY3RpdmVDZWxsTm9ybWFsKCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY2FuY2VsQ3VycmVudEVkaXQoKSB7XHJcbiAgICAgIG1ha2VBY3RpdmVDZWxsTm9ybWFsKCk7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJvd3NUb1Jhbmdlcyhyb3dzKSB7XHJcbiAgICAgIHZhciByYW5nZXMgPSBbXTtcclxuICAgICAgdmFyIGxhc3RDZWxsID0gY29sdW1ucy5sZW5ndGggLSAxO1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICByYW5nZXMucHVzaChuZXcgU2xpY2suUmFuZ2Uocm93c1tpXSwgMCwgcm93c1tpXSwgbGFzdENlbGwpKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcmFuZ2VzO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldFNlbGVjdGVkUm93cygpIHtcclxuICAgICAgaWYgKCFzZWxlY3Rpb25Nb2RlbCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlbGVjdGlvbiBtb2RlbCBpcyBub3Qgc2V0XCIpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBzZWxlY3RlZFJvd3M7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2V0U2VsZWN0ZWRSb3dzKHJvd3MpIHtcclxuICAgICAgaWYgKCFzZWxlY3Rpb25Nb2RlbCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlbGVjdGlvbiBtb2RlbCBpcyBub3Qgc2V0XCIpO1xyXG4gICAgICB9XHJcbiAgICAgIHNlbGVjdGlvbk1vZGVsLnNldFNlbGVjdGVkUmFuZ2VzKHJvd3NUb1Jhbmdlcyhyb3dzKSk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuICAgIC8vIERlYnVnXHJcblxyXG4gICAgdGhpcy5kZWJ1ZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHMgPSBcIlwiO1xyXG5cclxuICAgICAgcyArPSAoXCJcXG5cIiArIFwiY291bnRlcl9yb3dzX3JlbmRlcmVkOiAgXCIgKyBjb3VudGVyX3Jvd3NfcmVuZGVyZWQpO1xyXG4gICAgICBzICs9IChcIlxcblwiICsgXCJjb3VudGVyX3Jvd3NfcmVtb3ZlZDogIFwiICsgY291bnRlcl9yb3dzX3JlbW92ZWQpO1xyXG4gICAgICBzICs9IChcIlxcblwiICsgXCJyZW5kZXJlZFJvd3M6ICBcIiArIHJlbmRlcmVkUm93cyk7XHJcbiAgICAgIHMgKz0gKFwiXFxuXCIgKyBcIm51bVZpc2libGVSb3dzOiAgXCIgKyBudW1WaXNpYmxlUm93cyk7XHJcbiAgICAgIHMgKz0gKFwiXFxuXCIgKyBcIm1heFN1cHBvcnRlZENzc0hlaWdodDogIFwiICsgbWF4U3VwcG9ydGVkQ3NzSGVpZ2h0KTtcclxuICAgICAgcyArPSAoXCJcXG5cIiArIFwibih1bWJlciBvZiBwYWdlcyk6ICBcIiArIG4pO1xyXG4gICAgICBzICs9IChcIlxcblwiICsgXCIoY3VycmVudCkgcGFnZTogIFwiICsgcGFnZSk7XHJcbiAgICAgIHMgKz0gKFwiXFxuXCIgKyBcInBhZ2UgaGVpZ2h0IChwaCk6ICBcIiArIHBoKTtcclxuICAgICAgcyArPSAoXCJcXG5cIiArIFwidlNjcm9sbERpcjogIFwiICsgdlNjcm9sbERpcik7XHJcblxyXG4gICAgICBhbGVydChzKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gYSBkZWJ1ZyBoZWxwZXIgdG8gYmUgYWJsZSB0byBhY2Nlc3MgcHJpdmF0ZSBtZW1iZXJzXHJcbiAgICB0aGlzLmV2YWwgPSBmdW5jdGlvbiAoZXhwcikge1xyXG4gICAgICByZXR1cm4gZXZhbChleHByKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gICAgLy8gUHVibGljIEFQSVxyXG5cclxuICAgICQuZXh0ZW5kKHRoaXMsIHtcclxuICAgICAgXCJzbGlja0dyaWRWZXJzaW9uXCI6IFwiMi4zLjE5XCIsXHJcblxyXG4gICAgICAvLyBFdmVudHNcclxuICAgICAgXCJvblNjcm9sbFwiOiBuZXcgU2xpY2suRXZlbnQoKSxcclxuICAgICAgXCJvblNvcnRcIjogbmV3IFNsaWNrLkV2ZW50KCksXHJcbiAgICAgIFwib25IZWFkZXJNb3VzZUVudGVyXCI6IG5ldyBTbGljay5FdmVudCgpLFxyXG4gICAgICBcIm9uSGVhZGVyTW91c2VMZWF2ZVwiOiBuZXcgU2xpY2suRXZlbnQoKSxcclxuICAgICAgXCJvbkhlYWRlckNvbnRleHRNZW51XCI6IG5ldyBTbGljay5FdmVudCgpLFxyXG4gICAgICBcIm9uSGVhZGVyQ2xpY2tcIjogbmV3IFNsaWNrLkV2ZW50KCksXHJcbiAgICAgIFwib25IZWFkZXJDZWxsUmVuZGVyZWRcIjogbmV3IFNsaWNrLkV2ZW50KCksXHJcbiAgICAgIFwib25CZWZvcmVIZWFkZXJDZWxsRGVzdHJveVwiOiBuZXcgU2xpY2suRXZlbnQoKSxcclxuICAgICAgXCJvbkhlYWRlclJvd0NlbGxSZW5kZXJlZFwiOiBuZXcgU2xpY2suRXZlbnQoKSxcclxuICAgICAgXCJvbkZvb3RlclJvd0NlbGxSZW5kZXJlZFwiOiBuZXcgU2xpY2suRXZlbnQoKSxcclxuICAgICAgXCJvbkJlZm9yZUhlYWRlclJvd0NlbGxEZXN0cm95XCI6IG5ldyBTbGljay5FdmVudCgpLFxyXG4gICAgICBcIm9uQmVmb3JlRm9vdGVyUm93Q2VsbERlc3Ryb3lcIjogbmV3IFNsaWNrLkV2ZW50KCksXHJcbiAgICAgIFwib25Nb3VzZUVudGVyXCI6IG5ldyBTbGljay5FdmVudCgpLFxyXG4gICAgICBcIm9uTW91c2VMZWF2ZVwiOiBuZXcgU2xpY2suRXZlbnQoKSxcclxuICAgICAgXCJvbkNsaWNrXCI6IG5ldyBTbGljay5FdmVudCgpLFxyXG4gICAgICBcIm9uRGJsQ2xpY2tcIjogbmV3IFNsaWNrLkV2ZW50KCksXHJcbiAgICAgIFwib25Db250ZXh0TWVudVwiOiBuZXcgU2xpY2suRXZlbnQoKSxcclxuICAgICAgXCJvbktleURvd25cIjogbmV3IFNsaWNrLkV2ZW50KCksXHJcbiAgICAgIFwib25BZGROZXdSb3dcIjogbmV3IFNsaWNrLkV2ZW50KCksXHJcbiAgICAgIFwib25CZWZvcmVBcHBlbmRDZWxsXCI6IG5ldyBTbGljay5FdmVudCgpLFxyXG4gICAgICBcIm9uVmFsaWRhdGlvbkVycm9yXCI6IG5ldyBTbGljay5FdmVudCgpLFxyXG4gICAgICBcIm9uVmlld3BvcnRDaGFuZ2VkXCI6IG5ldyBTbGljay5FdmVudCgpLFxyXG4gICAgICBcIm9uQ29sdW1uc1Jlb3JkZXJlZFwiOiBuZXcgU2xpY2suRXZlbnQoKSxcclxuICAgICAgXCJvbkNvbHVtbnNSZXNpemVkXCI6IG5ldyBTbGljay5FdmVudCgpLFxyXG4gICAgICBcIm9uQ2VsbENoYW5nZVwiOiBuZXcgU2xpY2suRXZlbnQoKSxcclxuICAgICAgXCJvbkJlZm9yZUVkaXRDZWxsXCI6IG5ldyBTbGljay5FdmVudCgpLFxyXG4gICAgICBcIm9uQmVmb3JlQ2VsbEVkaXRvckRlc3Ryb3lcIjogbmV3IFNsaWNrLkV2ZW50KCksXHJcbiAgICAgIFwib25CZWZvcmVEZXN0cm95XCI6IG5ldyBTbGljay5FdmVudCgpLFxyXG4gICAgICBcIm9uQWN0aXZlQ2VsbENoYW5nZWRcIjogbmV3IFNsaWNrLkV2ZW50KCksXHJcbiAgICAgIFwib25BY3RpdmVDZWxsUG9zaXRpb25DaGFuZ2VkXCI6IG5ldyBTbGljay5FdmVudCgpLFxyXG4gICAgICBcIm9uRHJhZ0luaXRcIjogbmV3IFNsaWNrLkV2ZW50KCksXHJcbiAgICAgIFwib25EcmFnU3RhcnRcIjogbmV3IFNsaWNrLkV2ZW50KCksXHJcbiAgICAgIFwib25EcmFnXCI6IG5ldyBTbGljay5FdmVudCgpLFxyXG4gICAgICBcIm9uRHJhZ0VuZFwiOiBuZXcgU2xpY2suRXZlbnQoKSxcclxuICAgICAgXCJvblNlbGVjdGVkUm93c0NoYW5nZWRcIjogbmV3IFNsaWNrLkV2ZW50KCksXHJcbiAgICAgIFwib25DZWxsQ3NzU3R5bGVzQ2hhbmdlZFwiOiBuZXcgU2xpY2suRXZlbnQoKSxcclxuXHJcbiAgICAgIC8vIE1ldGhvZHNcclxuICAgICAgXCJyZWdpc3RlclBsdWdpblwiOiByZWdpc3RlclBsdWdpbixcclxuICAgICAgXCJ1bnJlZ2lzdGVyUGx1Z2luXCI6IHVucmVnaXN0ZXJQbHVnaW4sXHJcbiAgICAgIFwiZ2V0Q29sdW1uc1wiOiBnZXRDb2x1bW5zLFxyXG4gICAgICBcInNldENvbHVtbnNcIjogc2V0Q29sdW1ucyxcclxuICAgICAgXCJnZXRDb2x1bW5JbmRleFwiOiBnZXRDb2x1bW5JbmRleCxcclxuICAgICAgXCJ1cGRhdGVDb2x1bW5IZWFkZXJcIjogdXBkYXRlQ29sdW1uSGVhZGVyLFxyXG4gICAgICBcInNldFNvcnRDb2x1bW5cIjogc2V0U29ydENvbHVtbixcclxuICAgICAgXCJzZXRTb3J0Q29sdW1uc1wiOiBzZXRTb3J0Q29sdW1ucyxcclxuICAgICAgXCJnZXRTb3J0Q29sdW1uc1wiOiBnZXRTb3J0Q29sdW1ucyxcclxuICAgICAgXCJhdXRvc2l6ZUNvbHVtbnNcIjogYXV0b3NpemVDb2x1bW5zLFxyXG4gICAgICBcImdldE9wdGlvbnNcIjogZ2V0T3B0aW9ucyxcclxuICAgICAgXCJzZXRPcHRpb25zXCI6IHNldE9wdGlvbnMsXHJcbiAgICAgIFwiZ2V0RGF0YVwiOiBnZXREYXRhLFxyXG4gICAgICBcImdldERhdGFMZW5ndGhcIjogZ2V0RGF0YUxlbmd0aCxcclxuICAgICAgXCJnZXREYXRhSXRlbVwiOiBnZXREYXRhSXRlbSxcclxuICAgICAgXCJzZXREYXRhXCI6IHNldERhdGEsXHJcbiAgICAgIFwiZ2V0U2VsZWN0aW9uTW9kZWxcIjogZ2V0U2VsZWN0aW9uTW9kZWwsXHJcbiAgICAgIFwic2V0U2VsZWN0aW9uTW9kZWxcIjogc2V0U2VsZWN0aW9uTW9kZWwsXHJcbiAgICAgIFwiZ2V0U2VsZWN0ZWRSb3dzXCI6IGdldFNlbGVjdGVkUm93cyxcclxuICAgICAgXCJzZXRTZWxlY3RlZFJvd3NcIjogc2V0U2VsZWN0ZWRSb3dzLFxyXG4gICAgICBcImdldENvbnRhaW5lck5vZGVcIjogZ2V0Q29udGFpbmVyTm9kZSxcclxuICAgICAgXCJ1cGRhdGVQYWdpbmdTdGF0dXNGcm9tVmlld1wiOiB1cGRhdGVQYWdpbmdTdGF0dXNGcm9tVmlldyxcclxuXHJcbiAgICAgIFwicmVuZGVyXCI6IHJlbmRlcixcclxuICAgICAgXCJpbnZhbGlkYXRlXCI6IGludmFsaWRhdGUsXHJcbiAgICAgIFwiaW52YWxpZGF0ZVJvd1wiOiBpbnZhbGlkYXRlUm93LFxyXG4gICAgICBcImludmFsaWRhdGVSb3dzXCI6IGludmFsaWRhdGVSb3dzLFxyXG4gICAgICBcImludmFsaWRhdGVBbGxSb3dzXCI6IGludmFsaWRhdGVBbGxSb3dzLFxyXG4gICAgICBcInVwZGF0ZUNlbGxcIjogdXBkYXRlQ2VsbCxcclxuICAgICAgXCJ1cGRhdGVSb3dcIjogdXBkYXRlUm93LFxyXG4gICAgICBcImdldFZpZXdwb3J0XCI6IGdldFZpc2libGVSYW5nZSxcclxuICAgICAgXCJnZXRSZW5kZXJlZFJhbmdlXCI6IGdldFJlbmRlcmVkUmFuZ2UsXHJcbiAgICAgIFwicmVzaXplQ2FudmFzXCI6IHJlc2l6ZUNhbnZhcyxcclxuICAgICAgXCJ1cGRhdGVSb3dDb3VudFwiOiB1cGRhdGVSb3dDb3VudCxcclxuICAgICAgXCJzY3JvbGxSb3dJbnRvVmlld1wiOiBzY3JvbGxSb3dJbnRvVmlldyxcclxuICAgICAgXCJzY3JvbGxSb3dUb1RvcFwiOiBzY3JvbGxSb3dUb1RvcCxcclxuICAgICAgXCJzY3JvbGxDZWxsSW50b1ZpZXdcIjogc2Nyb2xsQ2VsbEludG9WaWV3LFxyXG4gICAgICBcInNjcm9sbENvbHVtbkludG9WaWV3XCI6IHNjcm9sbENvbHVtbkludG9WaWV3LFxyXG4gICAgICBcImdldENhbnZhc05vZGVcIjogZ2V0Q2FudmFzTm9kZSxcclxuICAgICAgXCJnZXRVSURcIjogZ2V0VUlELFxyXG4gICAgICBcImdldEhlYWRlckNvbHVtbldpZHRoRGlmZlwiOiBnZXRIZWFkZXJDb2x1bW5XaWR0aERpZmYsXHJcbiAgICAgIFwiZ2V0U2Nyb2xsYmFyRGltZW5zaW9uc1wiOiBnZXRTY3JvbGxiYXJEaW1lbnNpb25zLFxyXG4gICAgICBcImdldEhlYWRlcnNXaWR0aFwiOiBnZXRIZWFkZXJzV2lkdGgsXHJcbiAgICAgIFwiZ2V0Q2FudmFzV2lkdGhcIjogZ2V0Q2FudmFzV2lkdGgsXHJcbiAgICAgIFwiZm9jdXNcIjogc2V0Rm9jdXMsXHJcbiAgICAgIFwic2Nyb2xsVG9cIjogc2Nyb2xsVG8sXHJcbiAgICAgIFxyXG4gICAgICBcImdldENlbGxGcm9tUG9pbnRcIjogZ2V0Q2VsbEZyb21Qb2ludCxcclxuICAgICAgXCJnZXRDZWxsRnJvbUV2ZW50XCI6IGdldENlbGxGcm9tRXZlbnQsXHJcbiAgICAgIFwiZ2V0QWN0aXZlQ2VsbFwiOiBnZXRBY3RpdmVDZWxsLFxyXG4gICAgICBcInNldEFjdGl2ZUNlbGxcIjogc2V0QWN0aXZlQ2VsbCxcclxuICAgICAgXCJnZXRBY3RpdmVDZWxsTm9kZVwiOiBnZXRBY3RpdmVDZWxsTm9kZSxcclxuICAgICAgXCJnZXRBY3RpdmVDZWxsUG9zaXRpb25cIjogZ2V0QWN0aXZlQ2VsbFBvc2l0aW9uLFxyXG4gICAgICBcInJlc2V0QWN0aXZlQ2VsbFwiOiByZXNldEFjdGl2ZUNlbGwsXHJcbiAgICAgIFwiZWRpdEFjdGl2ZUNlbGxcIjogbWFrZUFjdGl2ZUNlbGxFZGl0YWJsZSxcclxuICAgICAgXCJnZXRDZWxsRWRpdG9yXCI6IGdldENlbGxFZGl0b3IsXHJcbiAgICAgIFwiZ2V0Q2VsbE5vZGVcIjogZ2V0Q2VsbE5vZGUsXHJcbiAgICAgIFwiZ2V0Q2VsbE5vZGVCb3hcIjogZ2V0Q2VsbE5vZGVCb3gsXHJcbiAgICAgIFwiY2FuQ2VsbEJlU2VsZWN0ZWRcIjogY2FuQ2VsbEJlU2VsZWN0ZWQsXHJcbiAgICAgIFwiY2FuQ2VsbEJlQWN0aXZlXCI6IGNhbkNlbGxCZUFjdGl2ZSxcclxuICAgICAgXCJuYXZpZ2F0ZVByZXZcIjogbmF2aWdhdGVQcmV2LFxyXG4gICAgICBcIm5hdmlnYXRlTmV4dFwiOiBuYXZpZ2F0ZU5leHQsXHJcbiAgICAgIFwibmF2aWdhdGVVcFwiOiBuYXZpZ2F0ZVVwLFxyXG4gICAgICBcIm5hdmlnYXRlRG93blwiOiBuYXZpZ2F0ZURvd24sXHJcbiAgICAgIFwibmF2aWdhdGVMZWZ0XCI6IG5hdmlnYXRlTGVmdCxcclxuICAgICAgXCJuYXZpZ2F0ZVJpZ2h0XCI6IG5hdmlnYXRlUmlnaHQsXHJcbiAgICAgIFwibmF2aWdhdGVQYWdlVXBcIjogbmF2aWdhdGVQYWdlVXAsXHJcbiAgICAgIFwibmF2aWdhdGVQYWdlRG93blwiOiBuYXZpZ2F0ZVBhZ2VEb3duLFxyXG4gICAgICBcIm5hdmlnYXRlVG9wXCI6IG5hdmlnYXRlVG9wLFxyXG4gICAgICBcIm5hdmlnYXRlQm90dG9tXCI6IG5hdmlnYXRlQm90dG9tLFxyXG4gICAgICBcIm5hdmlnYXRlUm93U3RhcnRcIjogbmF2aWdhdGVSb3dTdGFydCxcclxuICAgICAgXCJuYXZpZ2F0ZVJvd0VuZFwiOiBuYXZpZ2F0ZVJvd0VuZCxcclxuICAgICAgXCJnb3RvQ2VsbFwiOiBnb3RvQ2VsbCxcclxuICAgICAgXCJnZXRUb3BQYW5lbFwiOiBnZXRUb3BQYW5lbCxcclxuICAgICAgXCJzZXRUb3BQYW5lbFZpc2liaWxpdHlcIjogc2V0VG9wUGFuZWxWaXNpYmlsaXR5LFxyXG4gICAgICBcImdldFByZUhlYWRlclBhbmVsXCI6IGdldFByZUhlYWRlclBhbmVsLFxyXG4gICAgICBcInNldFByZUhlYWRlclBhbmVsVmlzaWJpbGl0eVwiOiBzZXRQcmVIZWFkZXJQYW5lbFZpc2liaWxpdHksXHJcbiAgICAgIFwiZ2V0SGVhZGVyXCI6IGdldEhlYWRlcixcclxuICAgICAgXCJnZXRIZWFkZXJDb2x1bW5cIjogZ2V0SGVhZGVyQ29sdW1uLFxyXG4gICAgICBcInNldEhlYWRlclJvd1Zpc2liaWxpdHlcIjogc2V0SGVhZGVyUm93VmlzaWJpbGl0eSxcclxuICAgICAgXCJnZXRIZWFkZXJSb3dcIjogZ2V0SGVhZGVyUm93LFxyXG4gICAgICBcImdldEhlYWRlclJvd0NvbHVtblwiOiBnZXRIZWFkZXJSb3dDb2x1bW4sXHJcbiAgICAgIFwic2V0Rm9vdGVyUm93VmlzaWJpbGl0eVwiOiBzZXRGb290ZXJSb3dWaXNpYmlsaXR5LFxyXG4gICAgICBcImdldEZvb3RlclJvd1wiOiBnZXRGb290ZXJSb3csXHJcbiAgICAgIFwiZ2V0Rm9vdGVyUm93Q29sdW1uXCI6IGdldEZvb3RlclJvd0NvbHVtbixcclxuICAgICAgXCJnZXRHcmlkUG9zaXRpb25cIjogZ2V0R3JpZFBvc2l0aW9uLFxyXG4gICAgICBcImZsYXNoQ2VsbFwiOiBmbGFzaENlbGwsXHJcbiAgICAgIFwiYWRkQ2VsbENzc1N0eWxlc1wiOiBhZGRDZWxsQ3NzU3R5bGVzLFxyXG4gICAgICBcInNldENlbGxDc3NTdHlsZXNcIjogc2V0Q2VsbENzc1N0eWxlcyxcclxuICAgICAgXCJyZW1vdmVDZWxsQ3NzU3R5bGVzXCI6IHJlbW92ZUNlbGxDc3NTdHlsZXMsXHJcbiAgICAgIFwiZ2V0Q2VsbENzc1N0eWxlc1wiOiBnZXRDZWxsQ3NzU3R5bGVzLFxyXG5cclxuICAgICAgXCJpbml0XCI6IGZpbmlzaEluaXRpYWxpemF0aW9uLFxyXG4gICAgICBcImRlc3Ryb3lcIjogZGVzdHJveSxcclxuXHJcbiAgICAgIC8vIElFZGl0b3IgaW1wbGVtZW50YXRpb25cclxuICAgICAgXCJnZXRFZGl0b3JMb2NrXCI6IGdldEVkaXRvckxvY2ssXHJcbiAgICAgIFwiZ2V0RWRpdENvbnRyb2xsZXJcIjogZ2V0RWRpdENvbnRyb2xsZXJcclxuICAgIH0pO1xyXG5cclxuICAgIGluaXQoKTtcclxuICB9XHJcblxyXG4gIC8vU2xpY2suR3JpZD1TbGlja0dyaWQ7XHJcbiAgZXhwb3J0IHtTbGljayxTbGlja0dyaWR9O1xyXG5cclxuXHJcblxyXG4gIFxyXG5cclxuXHJcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQTdDQTtBQStDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBSkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBaERBO0FBa0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBMVVBO0FBQ0E7QUE0VUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFOQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFmQTtBQWlCQTtBQW5DQTtBQUNBO0FBc0NBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFuREE7QUFDQTtBQXFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBV0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQS9CQTtBQWlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWJBO0FBQ0E7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQWRBO0FBQ0E7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBekJBO0FBQ0E7QUEyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBM0lBO0FBQ0E7QUE2SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/vendor/slick.grid.js\n");

/***/ }),

/***/ "./src/webgl/regl.js":
/*!***************************!*\
  !*** ./src/webgl/regl.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar isTypedArray = function isTypedArray(x) {\n  return x instanceof Uint8Array || x instanceof Uint16Array || x instanceof Uint32Array || x instanceof Int8Array || x instanceof Int16Array || x instanceof Int32Array || x instanceof Float32Array || x instanceof Float64Array || x instanceof Uint8ClampedArray;\n};\n\nvar extend = function extend(base, opts) {\n  var keys = Object.keys(opts);\n  for (var i = 0; i < keys.length; ++i) {\n    base[keys[i]] = opts[keys[i]];\n  }\n  return base;\n};\n\n// Error checking and parameter validation.\n//\n// Statements for the form `check.someProcedure(...)` get removed by\n// a browserify transform for optimized/minified bundles.\n//\n/* globals atob */\nvar endl = '\\n';\n\n// only used for extracting shader names.  if atob not present, then errors\n// will be slightly crappier\nfunction decodeB64(str) {\n  if (typeof atob !== 'undefined') {\n    return atob(str);\n  }\n  return 'base64:' + str;\n}\n\nfunction raise(message) {\n  var error = new Error('(regl) ' + message);\n  console.error(error);\n  throw error;\n}\n\nfunction check(pred, message) {\n  if (!pred) {\n    raise(message);\n  }\n}\n\nfunction encolon(message) {\n  if (message) {\n    return ': ' + message;\n  }\n  return '';\n}\n\nfunction checkParameter(param, possibilities, message) {\n  if (!(param in possibilities)) {\n    raise('unknown parameter (' + param + ')' + encolon(message) + '. possible values: ' + Object.keys(possibilities).join());\n  }\n}\n\nfunction checkIsTypedArray(data, message) {\n  if (!isTypedArray(data)) {\n    raise('invalid parameter type' + encolon(message) + '. must be a typed array');\n  }\n}\n\nfunction checkTypeOf(value, type, message) {\n  if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== type) {\n    raise('invalid parameter type' + encolon(message) + '. expected ' + type + ', got ' + (typeof value === 'undefined' ? 'undefined' : _typeof(value)));\n  }\n}\n\nfunction checkNonNegativeInt(value, message) {\n  if (!(value >= 0 && (value | 0) === value)) {\n    raise('invalid parameter type, (' + value + ')' + encolon(message) + '. must be a nonnegative integer');\n  }\n}\n\nfunction checkOneOf(value, list, message) {\n  if (list.indexOf(value) < 0) {\n    raise('invalid value' + encolon(message) + '. must be one of: ' + list);\n  }\n}\n\nvar constructorKeys = ['gl', 'canvas', 'container', 'attributes', 'pixelRatio', 'extensions', 'optionalExtensions', 'profile', 'onDone'];\n\nfunction checkConstructor(obj) {\n  Object.keys(obj).forEach(function (key) {\n    if (constructorKeys.indexOf(key) < 0) {\n      raise('invalid regl constructor argument \"' + key + '\". must be one of ' + constructorKeys);\n    }\n  });\n}\n\nfunction leftPad(str, n) {\n  str = str + '';\n  while (str.length < n) {\n    str = ' ' + str;\n  }\n  return str;\n}\n\nfunction ShaderFile() {\n  this.name = 'unknown';\n  this.lines = [];\n  this.index = {};\n  this.hasErrors = false;\n}\n\nfunction ShaderLine(number, line) {\n  this.number = number;\n  this.line = line;\n  this.errors = [];\n}\n\nfunction ShaderError(fileNumber, lineNumber, message) {\n  this.file = fileNumber;\n  this.line = lineNumber;\n  this.message = message;\n}\n\nfunction guessCommand() {\n  var error = new Error();\n  var stack = (error.stack || error).toString();\n  var pat = /compileProcedure.*\\n\\s*at.*\\((.*)\\)/.exec(stack);\n  if (pat) {\n    return pat[1];\n  }\n  var pat2 = /compileProcedure.*\\n\\s*at\\s+(.*)(\\n|$)/.exec(stack);\n  if (pat2) {\n    return pat2[1];\n  }\n  return 'unknown';\n}\n\nfunction guessCallSite() {\n  var error = new Error();\n  var stack = (error.stack || error).toString();\n  var pat = /at REGLCommand.*\\n\\s+at.*\\((.*)\\)/.exec(stack);\n  if (pat) {\n    return pat[1];\n  }\n  var pat2 = /at REGLCommand.*\\n\\s+at\\s+(.*)\\n/.exec(stack);\n  if (pat2) {\n    return pat2[1];\n  }\n  return 'unknown';\n}\n\nfunction parseSource(source, command) {\n  var lines = source.split('\\n');\n  var lineNumber = 1;\n  var fileNumber = 0;\n  var files = {\n    unknown: new ShaderFile(),\n    0: new ShaderFile()\n  };\n  files.unknown.name = files[0].name = command || guessCommand();\n  files.unknown.lines.push(new ShaderLine(0, ''));\n  for (var i = 0; i < lines.length; ++i) {\n    var line = lines[i];\n    var parts = /^\\s*\\#\\s*(\\w+)\\s+(.+)\\s*$/.exec(line);\n    if (parts) {\n      switch (parts[1]) {\n        case 'line':\n          var lineNumberInfo = /(\\d+)(\\s+\\d+)?/.exec(parts[2]);\n          if (lineNumberInfo) {\n            lineNumber = lineNumberInfo[1] | 0;\n            if (lineNumberInfo[2]) {\n              fileNumber = lineNumberInfo[2] | 0;\n              if (!(fileNumber in files)) {\n                files[fileNumber] = new ShaderFile();\n              }\n            }\n          }\n          break;\n        case 'define':\n          var nameInfo = /SHADER_NAME(_B64)?\\s+(.*)$/.exec(parts[2]);\n          if (nameInfo) {\n            files[fileNumber].name = nameInfo[1] ? decodeB64(nameInfo[2]) : nameInfo[2];\n          }\n          break;\n      }\n    }\n    files[fileNumber].lines.push(new ShaderLine(lineNumber++, line));\n  }\n  Object.keys(files).forEach(function (fileNumber) {\n    var file = files[fileNumber];\n    file.lines.forEach(function (line) {\n      file.index[line.number] = line;\n    });\n  });\n  return files;\n}\n\nfunction parseErrorLog(errLog) {\n  var result = [];\n  errLog.split('\\n').forEach(function (errMsg) {\n    if (errMsg.length < 5) {\n      return;\n    }\n    var parts = /^ERROR\\:\\s+(\\d+)\\:(\\d+)\\:\\s*(.*)$/.exec(errMsg);\n    if (parts) {\n      result.push(new ShaderError(parts[1] | 0, parts[2] | 0, parts[3].trim()));\n    } else if (errMsg.length > 0) {\n      result.push(new ShaderError('unknown', 0, errMsg));\n    }\n  });\n  return result;\n}\n\nfunction annotateFiles(files, errors) {\n  errors.forEach(function (error) {\n    var file = files[error.file];\n    if (file) {\n      var line = file.index[error.line];\n      if (line) {\n        line.errors.push(error);\n        file.hasErrors = true;\n        return;\n      }\n    }\n    files.unknown.hasErrors = true;\n    files.unknown.lines[0].errors.push(error);\n  });\n}\n\nfunction checkShaderError(gl, shader, source, type, command) {\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    var errLog = gl.getShaderInfoLog(shader);\n    var typeName = type === gl.FRAGMENT_SHADER ? 'fragment' : 'vertex';\n    checkCommandType(source, 'string', typeName + ' shader source must be a string', command);\n    var files = parseSource(source, command);\n    var errors = parseErrorLog(errLog);\n    annotateFiles(files, errors);\n\n    Object.keys(files).forEach(function (fileNumber) {\n      var file = files[fileNumber];\n      if (!file.hasErrors) {\n        return;\n      }\n\n      var strings = [''];\n      var styles = [''];\n\n      function push(str, style) {\n        strings.push(str);\n        styles.push(style || '');\n      }\n\n      push('file number ' + fileNumber + ': ' + file.name + '\\n', 'color:red;text-decoration:underline;font-weight:bold');\n\n      file.lines.forEach(function (line) {\n        if (line.errors.length > 0) {\n          push(leftPad(line.number, 4) + '|  ', 'background-color:yellow; font-weight:bold');\n          push(line.line + endl, 'color:red; background-color:yellow; font-weight:bold');\n\n          // try to guess token\n          var offset = 0;\n          line.errors.forEach(function (error) {\n            var message = error.message;\n            var token = /^\\s*\\'(.*)\\'\\s*\\:\\s*(.*)$/.exec(message);\n            if (token) {\n              var tokenPat = token[1];\n              message = token[2];\n              switch (tokenPat) {\n                case 'assign':\n                  tokenPat = '=';\n                  break;\n              }\n              offset = Math.max(line.line.indexOf(tokenPat, offset), 0);\n            } else {\n              offset = 0;\n            }\n\n            push(leftPad('| ', 6));\n            push(leftPad('^^^', offset + 3) + endl, 'font-weight:bold');\n            push(leftPad('| ', 6));\n            push(message + endl, 'font-weight:bold');\n          });\n          push(leftPad('| ', 6) + endl);\n        } else {\n          push(leftPad(line.number, 4) + '|  ');\n          push(line.line + endl, 'color:red');\n        }\n      });\n      if (typeof document !== 'undefined' && !window.chrome) {\n        styles[0] = strings.join('%c');\n        console.log.apply(console, styles);\n      } else {\n        console.log(strings.join(''));\n      }\n    });\n\n    check.raise('Error compiling ' + typeName + ' shader, ' + files[0].name);\n  }\n}\n\nfunction checkLinkError(gl, program, fragShader, vertShader, command) {\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    var errLog = gl.getProgramInfoLog(program);\n    var fragParse = parseSource(fragShader, command);\n    var vertParse = parseSource(vertShader, command);\n\n    var header = 'Error linking program with vertex shader, \"' + vertParse[0].name + '\", and fragment shader \"' + fragParse[0].name + '\"';\n\n    if (typeof document !== 'undefined') {\n      console.log('%c' + header + endl + '%c' + errLog, 'color:red;text-decoration:underline;font-weight:bold', 'color:red');\n    } else {\n      console.log(header + endl + errLog);\n    }\n    check.raise(header);\n  }\n}\n\nfunction saveCommandRef(object) {\n  object._commandRef = guessCommand();\n}\n\nfunction saveDrawCommandInfo(opts, uniforms, attributes, stringStore) {\n  saveCommandRef(opts);\n\n  function id(str) {\n    if (str) {\n      return stringStore.id(str);\n    }\n    return 0;\n  }\n  opts._fragId = id(opts.static.frag);\n  opts._vertId = id(opts.static.vert);\n\n  function addProps(dict, set) {\n    Object.keys(set).forEach(function (u) {\n      dict[stringStore.id(u)] = true;\n    });\n  }\n\n  var uniformSet = opts._uniformSet = {};\n  addProps(uniformSet, uniforms.static);\n  addProps(uniformSet, uniforms.dynamic);\n\n  var attributeSet = opts._attributeSet = {};\n  addProps(attributeSet, attributes.static);\n  addProps(attributeSet, attributes.dynamic);\n\n  opts._hasCount = 'count' in opts.static || 'count' in opts.dynamic || 'elements' in opts.static || 'elements' in opts.dynamic;\n}\n\nfunction commandRaise(message, command) {\n  var callSite = guessCallSite();\n  raise(message + ' in command ' + (command || guessCommand()) + (callSite === 'unknown' ? '' : ' called from ' + callSite));\n}\n\nfunction checkCommand(pred, message, command) {\n  if (!pred) {\n    commandRaise(message, command || guessCommand());\n  }\n}\n\nfunction checkParameterCommand(param, possibilities, message, command) {\n  if (!(param in possibilities)) {\n    commandRaise('unknown parameter (' + param + ')' + encolon(message) + '. possible values: ' + Object.keys(possibilities).join(), command || guessCommand());\n  }\n}\n\nfunction checkCommandType(value, type, message, command) {\n  if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== type) {\n    commandRaise('invalid parameter type' + encolon(message) + '. expected ' + type + ', got ' + (typeof value === 'undefined' ? 'undefined' : _typeof(value)), command || guessCommand());\n  }\n}\n\nfunction checkOptional(block) {\n  block();\n}\n\nfunction checkFramebufferFormat(attachment, texFormats, rbFormats) {\n  if (attachment.texture) {\n    checkOneOf(attachment.texture._texture.internalformat, texFormats, 'unsupported texture format for attachment');\n  } else {\n    checkOneOf(attachment.renderbuffer._renderbuffer.format, rbFormats, 'unsupported renderbuffer format for attachment');\n  }\n}\n\nvar GL_CLAMP_TO_EDGE = 0x812F;\n\nvar GL_NEAREST = 0x2600;\nvar GL_NEAREST_MIPMAP_NEAREST = 0x2700;\nvar GL_LINEAR_MIPMAP_NEAREST = 0x2701;\nvar GL_NEAREST_MIPMAP_LINEAR = 0x2702;\nvar GL_LINEAR_MIPMAP_LINEAR = 0x2703;\n\nvar GL_BYTE = 5120;\nvar GL_UNSIGNED_BYTE = 5121;\nvar GL_SHORT = 5122;\nvar GL_UNSIGNED_SHORT = 5123;\nvar GL_INT = 5124;\nvar GL_UNSIGNED_INT = 5125;\nvar GL_FLOAT = 5126;\n\nvar GL_UNSIGNED_SHORT_4_4_4_4 = 0x8033;\nvar GL_UNSIGNED_SHORT_5_5_5_1 = 0x8034;\nvar GL_UNSIGNED_SHORT_5_6_5 = 0x8363;\nvar GL_UNSIGNED_INT_24_8_WEBGL = 0x84FA;\n\nvar GL_HALF_FLOAT_OES = 0x8D61;\n\nvar TYPE_SIZE = {};\n\nTYPE_SIZE[GL_BYTE] = TYPE_SIZE[GL_UNSIGNED_BYTE] = 1;\n\nTYPE_SIZE[GL_SHORT] = TYPE_SIZE[GL_UNSIGNED_SHORT] = TYPE_SIZE[GL_HALF_FLOAT_OES] = TYPE_SIZE[GL_UNSIGNED_SHORT_5_6_5] = TYPE_SIZE[GL_UNSIGNED_SHORT_4_4_4_4] = TYPE_SIZE[GL_UNSIGNED_SHORT_5_5_5_1] = 2;\n\nTYPE_SIZE[GL_INT] = TYPE_SIZE[GL_UNSIGNED_INT] = TYPE_SIZE[GL_FLOAT] = TYPE_SIZE[GL_UNSIGNED_INT_24_8_WEBGL] = 4;\n\nfunction pixelSize(type, channels) {\n  if (type === GL_UNSIGNED_SHORT_5_5_5_1 || type === GL_UNSIGNED_SHORT_4_4_4_4 || type === GL_UNSIGNED_SHORT_5_6_5) {\n    return 2;\n  } else if (type === GL_UNSIGNED_INT_24_8_WEBGL) {\n    return 4;\n  } else {\n    return TYPE_SIZE[type] * channels;\n  }\n}\n\nfunction isPow2(v) {\n  return !(v & v - 1) && !!v;\n}\n\nfunction checkTexture2D(info, mipData, limits) {\n  var i;\n  var w = mipData.width;\n  var h = mipData.height;\n  var c = mipData.channels;\n\n  // Check texture shape\n  check(w > 0 && w <= limits.maxTextureSize && h > 0 && h <= limits.maxTextureSize, 'invalid texture shape');\n\n  // check wrap mode\n  if (info.wrapS !== GL_CLAMP_TO_EDGE || info.wrapT !== GL_CLAMP_TO_EDGE) {\n    check(isPow2(w) && isPow2(h), 'incompatible wrap mode for texture, both width and height must be power of 2');\n  }\n\n  if (mipData.mipmask === 1) {\n    if (w !== 1 && h !== 1) {\n      check(info.minFilter !== GL_NEAREST_MIPMAP_NEAREST && info.minFilter !== GL_NEAREST_MIPMAP_LINEAR && info.minFilter !== GL_LINEAR_MIPMAP_NEAREST && info.minFilter !== GL_LINEAR_MIPMAP_LINEAR, 'min filter requires mipmap');\n    }\n  } else {\n    // texture must be power of 2\n    check(isPow2(w) && isPow2(h), 'texture must be a square power of 2 to support mipmapping');\n    check(mipData.mipmask === (w << 1) - 1, 'missing or incomplete mipmap data');\n  }\n\n  if (mipData.type === GL_FLOAT) {\n    if (limits.extensions.indexOf('oes_texture_float_linear') < 0) {\n      check(info.minFilter === GL_NEAREST && info.magFilter === GL_NEAREST, 'filter not supported, must enable oes_texture_float_linear');\n    }\n    check(!info.genMipmaps, 'mipmap generation not supported with float textures');\n  }\n\n  // check image complete\n  var mipimages = mipData.images;\n  for (i = 0; i < 16; ++i) {\n    if (mipimages[i]) {\n      var mw = w >> i;\n      var mh = h >> i;\n      check(mipData.mipmask & 1 << i, 'missing mipmap data');\n\n      var img = mipimages[i];\n\n      check(img.width === mw && img.height === mh, 'invalid shape for mip images');\n\n      check(img.format === mipData.format && img.internalformat === mipData.internalformat && img.type === mipData.type, 'incompatible type for mip image');\n\n      if (img.compressed) {\n        // TODO: check size for compressed images\n      } else if (img.data) {\n        // check(img.data.byteLength === mw * mh *\n        // Math.max(pixelSize(img.type, c), img.unpackAlignment),\n        var rowSize = Math.ceil(pixelSize(img.type, c) * mw / img.unpackAlignment) * img.unpackAlignment;\n        check(img.data.byteLength === rowSize * mh, 'invalid data for image, buffer size is inconsistent with image format');\n      } else if (img.element) {\n        // TODO: check element can be loaded\n      } else if (img.copy) {\n        // TODO: check compatible format and type\n      }\n    } else if (!info.genMipmaps) {\n      check((mipData.mipmask & 1 << i) === 0, 'extra mipmap data');\n    }\n  }\n\n  if (mipData.compressed) {\n    check(!info.genMipmaps, 'mipmap generation for compressed images not supported');\n  }\n}\n\nfunction checkTextureCube(texture, info, faces, limits) {\n  var w = texture.width;\n  var h = texture.height;\n  var c = texture.channels;\n\n  // Check texture shape\n  check(w > 0 && w <= limits.maxTextureSize && h > 0 && h <= limits.maxTextureSize, 'invalid texture shape');\n  check(w === h, 'cube map must be square');\n  check(info.wrapS === GL_CLAMP_TO_EDGE && info.wrapT === GL_CLAMP_TO_EDGE, 'wrap mode not supported by cube map');\n\n  for (var i = 0; i < faces.length; ++i) {\n    var face = faces[i];\n    check(face.width === w && face.height === h, 'inconsistent cube map face shape');\n\n    if (info.genMipmaps) {\n      check(!face.compressed, 'can not generate mipmap for compressed textures');\n      check(face.mipmask === 1, 'can not specify mipmaps and generate mipmaps');\n    } else {\n      // TODO: check mip and filter mode\n    }\n\n    var mipmaps = face.images;\n    for (var j = 0; j < 16; ++j) {\n      var img = mipmaps[j];\n      if (img) {\n        var mw = w >> j;\n        var mh = h >> j;\n        check(face.mipmask & 1 << j, 'missing mipmap data');\n        check(img.width === mw && img.height === mh, 'invalid shape for mip images');\n        check(img.format === texture.format && img.internalformat === texture.internalformat && img.type === texture.type, 'incompatible type for mip image');\n\n        if (img.compressed) {\n          // TODO: check size for compressed images\n        } else if (img.data) {\n          check(img.data.byteLength === mw * mh * Math.max(pixelSize(img.type, c), img.unpackAlignment), 'invalid data for image, buffer size is inconsistent with image format');\n        } else if (img.element) {\n          // TODO: check element can be loaded\n        } else if (img.copy) {\n          // TODO: check compatible format and type\n        }\n      }\n    }\n  }\n}\n\nvar check$1 = extend(check, {\n  optional: checkOptional,\n  raise: raise,\n  commandRaise: commandRaise,\n  command: checkCommand,\n  parameter: checkParameter,\n  commandParameter: checkParameterCommand,\n  constructor: checkConstructor,\n  type: checkTypeOf,\n  commandType: checkCommandType,\n  isTypedArray: checkIsTypedArray,\n  nni: checkNonNegativeInt,\n  oneOf: checkOneOf,\n  shaderError: checkShaderError,\n  linkError: checkLinkError,\n  callSite: guessCallSite,\n  saveCommandRef: saveCommandRef,\n  saveDrawInfo: saveDrawCommandInfo,\n  framebufferFormat: checkFramebufferFormat,\n  guessCommand: guessCommand,\n  texture2D: checkTexture2D,\n  textureCube: checkTextureCube\n});\n\nvar VARIABLE_COUNTER = 0;\n\nvar DYN_FUNC = 0;\n\nfunction DynamicVariable(type, data) {\n  this.id = VARIABLE_COUNTER++;\n  this.type = type;\n  this.data = data;\n}\n\nfunction escapeStr(str) {\n  return str.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"');\n}\n\nfunction splitParts(str) {\n  if (str.length === 0) {\n    return [];\n  }\n\n  var firstChar = str.charAt(0);\n  var lastChar = str.charAt(str.length - 1);\n\n  if (str.length > 1 && firstChar === lastChar && (firstChar === '\"' || firstChar === \"'\")) {\n    return ['\"' + escapeStr(str.substr(1, str.length - 2)) + '\"'];\n  }\n\n  var parts = /\\[(false|true|null|\\d+|'[^']*'|\"[^\"]*\")\\]/.exec(str);\n  if (parts) {\n    return splitParts(str.substr(0, parts.index)).concat(splitParts(parts[1])).concat(splitParts(str.substr(parts.index + parts[0].length)));\n  }\n\n  var subparts = str.split('.');\n  if (subparts.length === 1) {\n    return ['\"' + escapeStr(str) + '\"'];\n  }\n\n  var result = [];\n  for (var i = 0; i < subparts.length; ++i) {\n    result = result.concat(splitParts(subparts[i]));\n  }\n  return result;\n}\n\nfunction toAccessorString(str) {\n  return '[' + splitParts(str).join('][') + ']';\n}\n\nfunction defineDynamic(type, data) {\n  return new DynamicVariable(type, toAccessorString(data + ''));\n}\n\nfunction isDynamic(x) {\n  return typeof x === 'function' && !x._reglType || x instanceof DynamicVariable;\n}\n\nfunction unbox(x, path) {\n  if (typeof x === 'function') {\n    return new DynamicVariable(DYN_FUNC, x);\n  }\n  return x;\n}\n\nvar dynamic = {\n  DynamicVariable: DynamicVariable,\n  define: defineDynamic,\n  isDynamic: isDynamic,\n  unbox: unbox,\n  accessor: toAccessorString\n};\n\n/* globals requestAnimationFrame, cancelAnimationFrame */\nvar raf = {\n  next: typeof requestAnimationFrame === 'function' ? function (cb) {\n    return requestAnimationFrame(cb);\n  } : function (cb) {\n    return setTimeout(cb, 16);\n  },\n  cancel: typeof cancelAnimationFrame === 'function' ? function (raf) {\n    return cancelAnimationFrame(raf);\n  } : clearTimeout\n};\n\n/* globals performance */\nvar clock = typeof performance !== 'undefined' && performance.now ? function () {\n  return performance.now();\n} : function () {\n  return +new Date();\n};\n\nfunction createStringStore() {\n  var stringIds = { '': 0 };\n  var stringValues = [''];\n  return {\n    id: function id(str) {\n      var result = stringIds[str];\n      if (result) {\n        return result;\n      }\n      result = stringIds[str] = stringValues.length;\n      stringValues.push(str);\n      return result;\n    },\n\n    str: function str(id) {\n      return stringValues[id];\n    }\n  };\n}\n\n// Context and canvas creation helper functions\nfunction createCanvas(element, onDone, pixelRatio) {\n  var canvas = document.createElement('canvas');\n  extend(canvas.style, {\n    border: 0,\n    margin: 0,\n    padding: 0,\n    top: 0,\n    left: 0\n  });\n  element.appendChild(canvas);\n\n  if (element === document.body) {\n    canvas.style.position = 'absolute';\n    extend(element.style, {\n      margin: 0,\n      padding: 0\n    });\n  }\n\n  function resize() {\n    var w = window.innerWidth;\n    var h = window.innerHeight;\n    if (element !== document.body) {\n      var bounds = element.getBoundingClientRect();\n      w = bounds.right - bounds.left;\n      h = bounds.bottom - bounds.top;\n    }\n    canvas.width = pixelRatio * w;\n    canvas.height = pixelRatio * h;\n    extend(canvas.style, {\n      width: w + 'px',\n      height: h + 'px'\n    });\n  }\n\n  window.addEventListener('resize', resize, false);\n\n  function onDestroy() {\n    window.removeEventListener('resize', resize);\n    element.removeChild(canvas);\n  }\n\n  resize();\n\n  return {\n    canvas: canvas,\n    onDestroy: onDestroy\n  };\n}\n\nfunction createContext(canvas, contextAttributes) {\n  function get(name) {\n    try {\n      return canvas.getContext(name, contextAttributes);\n    } catch (e) {\n      return null;\n    }\n  }\n  return get('webgl') || get('experimental-webgl') || get('webgl-experimental');\n}\n\nfunction isHTMLElement(obj) {\n  return typeof obj.nodeName === 'string' && typeof obj.appendChild === 'function' && typeof obj.getBoundingClientRect === 'function';\n}\n\nfunction isWebGLContext(obj) {\n  return typeof obj.drawArrays === 'function' || typeof obj.drawElements === 'function';\n}\n\nfunction parseExtensions(input) {\n  if (typeof input === 'string') {\n    return input.split();\n  }\n  check$1(Array.isArray(input), 'invalid extension array');\n  return input;\n}\n\nfunction getElement(desc) {\n  if (typeof desc === 'string') {\n    check$1(typeof document !== 'undefined', 'not supported outside of DOM');\n    return document.querySelector(desc);\n  }\n  return desc;\n}\n\nfunction parseArgs(args_) {\n  var args = args_ || {};\n  var element, container, canvas, gl;\n  var contextAttributes = {};\n  var extensions = [];\n  var optionalExtensions = [];\n  var pixelRatio = typeof window === 'undefined' ? 1 : window.devicePixelRatio;\n  var profile = false;\n  var onDone = function onDone(err) {\n    if (err) {\n      check$1.raise(err);\n    }\n  };\n  var onDestroy = function onDestroy() {};\n  if (typeof args === 'string') {\n    check$1(typeof document !== 'undefined', 'selector queries only supported in DOM enviroments');\n    element = document.querySelector(args);\n    check$1(element, 'invalid query string for element');\n  } else if ((typeof args === 'undefined' ? 'undefined' : _typeof(args)) === 'object') {\n    if (isHTMLElement(args)) {\n      element = args;\n    } else if (isWebGLContext(args)) {\n      gl = args;\n      canvas = gl.canvas;\n    } else {\n      check$1.constructor(args);\n      if ('gl' in args) {\n        gl = args.gl;\n      } else if ('canvas' in args) {\n        canvas = getElement(args.canvas);\n      } else if ('container' in args) {\n        container = getElement(args.container);\n      }\n      if ('attributes' in args) {\n        contextAttributes = args.attributes;\n        check$1.type(contextAttributes, 'object', 'invalid context attributes');\n      }\n      if ('extensions' in args) {\n        extensions = parseExtensions(args.extensions);\n      }\n      if ('optionalExtensions' in args) {\n        optionalExtensions = parseExtensions(args.optionalExtensions);\n      }\n      if ('onDone' in args) {\n        check$1.type(args.onDone, 'function', 'invalid or missing onDone callback');\n        onDone = args.onDone;\n      }\n      if ('profile' in args) {\n        profile = !!args.profile;\n      }\n      if ('pixelRatio' in args) {\n        pixelRatio = +args.pixelRatio;\n        check$1(pixelRatio > 0, 'invalid pixel ratio');\n      }\n    }\n  } else {\n    check$1.raise('invalid arguments to regl');\n  }\n\n  if (element) {\n    if (element.nodeName.toLowerCase() === 'canvas') {\n      canvas = element;\n    } else {\n      container = element;\n    }\n  }\n\n  if (!gl) {\n    if (!canvas) {\n      check$1(typeof document !== 'undefined', 'must manually specify webgl context outside of DOM environments');\n      var result = createCanvas(container || document.body, onDone, pixelRatio);\n      if (!result) {\n        return null;\n      }\n      canvas = result.canvas;\n      onDestroy = result.onDestroy;\n    }\n    gl = createContext(canvas, contextAttributes);\n  }\n\n  if (!gl) {\n    onDestroy();\n    onDone('webgl not supported, try upgrading your browser or graphics drivers http://get.webgl.org');\n    return null;\n  }\n\n  return {\n    gl: gl,\n    canvas: canvas,\n    container: container,\n    extensions: extensions,\n    optionalExtensions: optionalExtensions,\n    pixelRatio: pixelRatio,\n    profile: profile,\n    onDone: onDone,\n    onDestroy: onDestroy\n  };\n}\n\nfunction createExtensionCache(gl, config) {\n  var extensions = {};\n\n  function tryLoadExtension(name_) {\n    check$1.type(name_, 'string', 'extension name must be string');\n    var name = name_.toLowerCase();\n    var ext;\n    try {\n      ext = extensions[name] = gl.getExtension(name);\n    } catch (e) {}\n    return !!ext;\n  }\n\n  for (var i = 0; i < config.extensions.length; ++i) {\n    var name = config.extensions[i];\n    if (!tryLoadExtension(name)) {\n      config.onDestroy();\n      config.onDone('\"' + name + '\" extension is not supported by the current WebGL context, try upgrading your system or a different browser');\n      return null;\n    }\n  }\n\n  config.optionalExtensions.forEach(tryLoadExtension);\n\n  return {\n    extensions: extensions,\n    restore: function restore() {\n      Object.keys(extensions).forEach(function (name) {\n        if (!tryLoadExtension(name)) {\n          throw new Error('(regl): error restoring extension ' + name);\n        }\n      });\n    }\n  };\n}\n\nfunction loop(n, f) {\n  var result = Array(n);\n  for (var i = 0; i < n; ++i) {\n    result[i] = f(i);\n  }\n  return result;\n}\n\nvar GL_BYTE$1 = 5120;\nvar GL_UNSIGNED_BYTE$2 = 5121;\nvar GL_SHORT$1 = 5122;\nvar GL_UNSIGNED_SHORT$1 = 5123;\nvar GL_INT$1 = 5124;\nvar GL_UNSIGNED_INT$1 = 5125;\nvar GL_FLOAT$2 = 5126;\n\nfunction nextPow16(v) {\n  for (var i = 16; i <= 1 << 28; i *= 16) {\n    if (v <= i) {\n      return i;\n    }\n  }\n  return 0;\n}\n\nfunction log2(v) {\n  var r, shift;\n  r = (v > 0xFFFF) << 4;\n  v >>>= r;\n  shift = (v > 0xFF) << 3;\n  v >>>= shift;r |= shift;\n  shift = (v > 0xF) << 2;\n  v >>>= shift;r |= shift;\n  shift = (v > 0x3) << 1;\n  v >>>= shift;r |= shift;\n  return r | v >> 1;\n}\n\nfunction createPool() {\n  var bufferPool = loop(8, function () {\n    return [];\n  });\n\n  function alloc(n) {\n    var sz = nextPow16(n);\n    var bin = bufferPool[log2(sz) >> 2];\n    if (bin.length > 0) {\n      return bin.pop();\n    }\n    return new ArrayBuffer(sz);\n  }\n\n  function free(buf) {\n    bufferPool[log2(buf.byteLength) >> 2].push(buf);\n  }\n\n  function allocType(type, n) {\n    var result = null;\n    switch (type) {\n      case GL_BYTE$1:\n        result = new Int8Array(alloc(n), 0, n);\n        break;\n      case GL_UNSIGNED_BYTE$2:\n        result = new Uint8Array(alloc(n), 0, n);\n        break;\n      case GL_SHORT$1:\n        result = new Int16Array(alloc(2 * n), 0, n);\n        break;\n      case GL_UNSIGNED_SHORT$1:\n        result = new Uint16Array(alloc(2 * n), 0, n);\n        break;\n      case GL_INT$1:\n        result = new Int32Array(alloc(4 * n), 0, n);\n        break;\n      case GL_UNSIGNED_INT$1:\n        result = new Uint32Array(alloc(4 * n), 0, n);\n        break;\n      case GL_FLOAT$2:\n        result = new Float32Array(alloc(4 * n), 0, n);\n        break;\n      default:\n        return null;\n    }\n    if (result.length !== n) {\n      return result.subarray(0, n);\n    }\n    return result;\n  }\n\n  function freeType(array) {\n    free(array.buffer);\n  }\n\n  return {\n    alloc: alloc,\n    free: free,\n    allocType: allocType,\n    freeType: freeType\n  };\n}\n\nvar pool = createPool();\n\n// zero pool for initial zero data\npool.zero = createPool();\n\nvar GL_SUBPIXEL_BITS = 0x0D50;\nvar GL_RED_BITS = 0x0D52;\nvar GL_GREEN_BITS = 0x0D53;\nvar GL_BLUE_BITS = 0x0D54;\nvar GL_ALPHA_BITS = 0x0D55;\nvar GL_DEPTH_BITS = 0x0D56;\nvar GL_STENCIL_BITS = 0x0D57;\n\nvar GL_ALIASED_POINT_SIZE_RANGE = 0x846D;\nvar GL_ALIASED_LINE_WIDTH_RANGE = 0x846E;\n\nvar GL_MAX_TEXTURE_SIZE = 0x0D33;\nvar GL_MAX_VIEWPORT_DIMS = 0x0D3A;\nvar GL_MAX_VERTEX_ATTRIBS = 0x8869;\nvar GL_MAX_VERTEX_UNIFORM_VECTORS = 0x8DFB;\nvar GL_MAX_VARYING_VECTORS = 0x8DFC;\nvar GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D;\nvar GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS = 0x8B4C;\nvar GL_MAX_TEXTURE_IMAGE_UNITS = 0x8872;\nvar GL_MAX_FRAGMENT_UNIFORM_VECTORS = 0x8DFD;\nvar GL_MAX_CUBE_MAP_TEXTURE_SIZE = 0x851C;\nvar GL_MAX_RENDERBUFFER_SIZE = 0x84E8;\n\nvar GL_VENDOR = 0x1F00;\nvar GL_RENDERER = 0x1F01;\nvar GL_VERSION = 0x1F02;\nvar GL_SHADING_LANGUAGE_VERSION = 0x8B8C;\n\nvar GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = 0x84FF;\n\nvar GL_MAX_COLOR_ATTACHMENTS_WEBGL = 0x8CDF;\nvar GL_MAX_DRAW_BUFFERS_WEBGL = 0x8824;\n\nvar GL_TEXTURE_2D = 0x0DE1;\nvar GL_TEXTURE_CUBE_MAP = 0x8513;\nvar GL_TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;\nvar GL_TEXTURE0 = 0x84C0;\nvar GL_RGBA = 0x1908;\nvar GL_FLOAT$1 = 0x1406;\nvar GL_UNSIGNED_BYTE$1 = 0x1401;\nvar GL_FRAMEBUFFER = 0x8D40;\nvar GL_FRAMEBUFFER_COMPLETE = 0x8CD5;\nvar GL_COLOR_ATTACHMENT0 = 0x8CE0;\nvar GL_COLOR_BUFFER_BIT$1 = 0x4000;\n\nvar wrapLimits = function wrapLimits(gl, extensions) {\n  var maxAnisotropic = 1;\n  if (extensions.ext_texture_filter_anisotropic) {\n    maxAnisotropic = gl.getParameter(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT);\n  }\n\n  var maxDrawbuffers = 1;\n  var maxColorAttachments = 1;\n  if (extensions.webgl_draw_buffers) {\n    maxDrawbuffers = gl.getParameter(GL_MAX_DRAW_BUFFERS_WEBGL);\n    maxColorAttachments = gl.getParameter(GL_MAX_COLOR_ATTACHMENTS_WEBGL);\n  }\n\n  // detect if reading float textures is available (Safari doesn't support)\n  var readFloat = !!extensions.oes_texture_float;\n  if (readFloat) {\n    var readFloatTexture = gl.createTexture();\n    gl.bindTexture(GL_TEXTURE_2D, readFloatTexture);\n    gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 1, 1, 0, GL_RGBA, GL_FLOAT$1, null);\n\n    var fbo = gl.createFramebuffer();\n    gl.bindFramebuffer(GL_FRAMEBUFFER, fbo);\n    gl.framebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, readFloatTexture, 0);\n    gl.bindTexture(GL_TEXTURE_2D, null);\n\n    if (gl.checkFramebufferStatus(GL_FRAMEBUFFER) !== GL_FRAMEBUFFER_COMPLETE) readFloat = false;else {\n      gl.viewport(0, 0, 1, 1);\n      gl.clearColor(1.0, 0.0, 0.0, 1.0);\n      gl.clear(GL_COLOR_BUFFER_BIT$1);\n      var pixels = pool.allocType(GL_FLOAT$1, 4);\n      gl.readPixels(0, 0, 1, 1, GL_RGBA, GL_FLOAT$1, pixels);\n\n      if (gl.getError()) readFloat = false;else {\n        gl.deleteFramebuffer(fbo);\n        gl.deleteTexture(readFloatTexture);\n\n        readFloat = pixels[0] === 1.0;\n      }\n\n      pool.freeType(pixels);\n    }\n  }\n\n  // detect non power of two cube textures support (IE doesn't support)\n  var npotTextureCube = true;\n  var cubeTexture = gl.createTexture();\n  var data = pool.allocType(GL_UNSIGNED_BYTE$1, 36);\n  gl.activeTexture(GL_TEXTURE0);\n  gl.bindTexture(GL_TEXTURE_CUBE_MAP, cubeTexture);\n  gl.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X, 0, GL_RGBA, 3, 3, 0, GL_RGBA, GL_UNSIGNED_BYTE$1, data);\n  pool.freeType(data);\n  gl.bindTexture(GL_TEXTURE_CUBE_MAP, null);\n  gl.deleteTexture(cubeTexture);\n  npotTextureCube = !gl.getError();\n\n  return {\n    // drawing buffer bit depth\n    colorBits: [gl.getParameter(GL_RED_BITS), gl.getParameter(GL_GREEN_BITS), gl.getParameter(GL_BLUE_BITS), gl.getParameter(GL_ALPHA_BITS)],\n    depthBits: gl.getParameter(GL_DEPTH_BITS),\n    stencilBits: gl.getParameter(GL_STENCIL_BITS),\n    subpixelBits: gl.getParameter(GL_SUBPIXEL_BITS),\n\n    // supported extensions\n    extensions: Object.keys(extensions).filter(function (ext) {\n      return !!extensions[ext];\n    }),\n\n    // max aniso samples\n    maxAnisotropic: maxAnisotropic,\n\n    // max draw buffers\n    maxDrawbuffers: maxDrawbuffers,\n    maxColorAttachments: maxColorAttachments,\n\n    // point and line size ranges\n    pointSizeDims: gl.getParameter(GL_ALIASED_POINT_SIZE_RANGE),\n    lineWidthDims: gl.getParameter(GL_ALIASED_LINE_WIDTH_RANGE),\n    maxViewportDims: gl.getParameter(GL_MAX_VIEWPORT_DIMS),\n    maxCombinedTextureUnits: gl.getParameter(GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS),\n    maxCubeMapSize: gl.getParameter(GL_MAX_CUBE_MAP_TEXTURE_SIZE),\n    maxRenderbufferSize: gl.getParameter(GL_MAX_RENDERBUFFER_SIZE),\n    maxTextureUnits: gl.getParameter(GL_MAX_TEXTURE_IMAGE_UNITS),\n    maxTextureSize: gl.getParameter(GL_MAX_TEXTURE_SIZE),\n    maxAttributes: gl.getParameter(GL_MAX_VERTEX_ATTRIBS),\n    maxVertexUniforms: gl.getParameter(GL_MAX_VERTEX_UNIFORM_VECTORS),\n    maxVertexTextureUnits: gl.getParameter(GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS),\n    maxVaryingVectors: gl.getParameter(GL_MAX_VARYING_VECTORS),\n    maxFragmentUniforms: gl.getParameter(GL_MAX_FRAGMENT_UNIFORM_VECTORS),\n\n    // vendor info\n    glsl: gl.getParameter(GL_SHADING_LANGUAGE_VERSION),\n    renderer: gl.getParameter(GL_RENDERER),\n    vendor: gl.getParameter(GL_VENDOR),\n    version: gl.getParameter(GL_VERSION),\n\n    // quirks\n    readFloat: readFloat,\n    npotTextureCube: npotTextureCube\n  };\n};\n\nfunction isNDArrayLike(obj) {\n  return !!obj && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && Array.isArray(obj.shape) && Array.isArray(obj.stride) && typeof obj.offset === 'number' && obj.shape.length === obj.stride.length && (Array.isArray(obj.data) || isTypedArray(obj.data));\n}\n\nvar values = function values(obj) {\n  return Object.keys(obj).map(function (key) {\n    return obj[key];\n  });\n};\n\nvar flattenUtils = {\n  shape: arrayShape$1,\n  flatten: flattenArray\n};\n\nfunction flatten1D(array, nx, out) {\n  for (var i = 0; i < nx; ++i) {\n    out[i] = array[i];\n  }\n}\n\nfunction flatten2D(array, nx, ny, out) {\n  var ptr = 0;\n  for (var i = 0; i < nx; ++i) {\n    var row = array[i];\n    for (var j = 0; j < ny; ++j) {\n      out[ptr++] = row[j];\n    }\n  }\n}\n\nfunction flatten3D(array, nx, ny, nz, out, ptr_) {\n  var ptr = ptr_;\n  for (var i = 0; i < nx; ++i) {\n    var row = array[i];\n    for (var j = 0; j < ny; ++j) {\n      var col = row[j];\n      for (var k = 0; k < nz; ++k) {\n        out[ptr++] = col[k];\n      }\n    }\n  }\n}\n\nfunction flattenRec(array, shape, level, out, ptr) {\n  var stride = 1;\n  for (var i = level + 1; i < shape.length; ++i) {\n    stride *= shape[i];\n  }\n  var n = shape[level];\n  if (shape.length - level === 4) {\n    var nx = shape[level + 1];\n    var ny = shape[level + 2];\n    var nz = shape[level + 3];\n    for (i = 0; i < n; ++i) {\n      flatten3D(array[i], nx, ny, nz, out, ptr);\n      ptr += stride;\n    }\n  } else {\n    for (i = 0; i < n; ++i) {\n      flattenRec(array[i], shape, level + 1, out, ptr);\n      ptr += stride;\n    }\n  }\n}\n\nfunction flattenArray(array, shape, type, out_) {\n  var sz = 1;\n  if (shape.length) {\n    for (var i = 0; i < shape.length; ++i) {\n      sz *= shape[i];\n    }\n  } else {\n    sz = 0;\n  }\n  var out = out_ || pool.allocType(type, sz);\n  switch (shape.length) {\n    case 0:\n      break;\n    case 1:\n      flatten1D(array, shape[0], out);\n      break;\n    case 2:\n      flatten2D(array, shape[0], shape[1], out);\n      break;\n    case 3:\n      flatten3D(array, shape[0], shape[1], shape[2], out, 0);\n      break;\n    default:\n      flattenRec(array, shape, 0, out, 0);\n  }\n  return out;\n}\n\nfunction arrayShape$1(array_) {\n  var shape = [];\n  for (var array = array_; array.length; array = array[0]) {\n    shape.push(array.length);\n  }\n  return shape;\n}\n\nvar arrayTypes = {\n  \"[object Int8Array]\": 5120,\n  \"[object Int16Array]\": 5122,\n  \"[object Int32Array]\": 5124,\n  \"[object Uint8Array]\": 5121,\n  \"[object Uint8ClampedArray]\": 5121,\n  \"[object Uint16Array]\": 5123,\n  \"[object Uint32Array]\": 5125,\n  \"[object Float32Array]\": 5126,\n  \"[object Float64Array]\": 5121,\n  \"[object ArrayBuffer]\": 5121\n};\n\nvar int8 = 5120;\nvar int16 = 5122;\nvar int32 = 5124;\nvar uint8 = 5121;\nvar uint16 = 5123;\nvar uint32 = 5125;\nvar float = 5126;\nvar float32 = 5126;\nvar glTypes = {\n  int8: int8,\n  int16: int16,\n  int32: int32,\n  uint8: uint8,\n  uint16: uint16,\n  uint32: uint32,\n  float: float,\n  float32: float32\n};\n\nvar dynamic$1 = 35048;\nvar stream = 35040;\nvar usageTypes = {\n  dynamic: dynamic$1,\n  stream: stream,\n  \"static\": 35044\n};\n\nvar arrayFlatten = flattenUtils.flatten;\nvar arrayShape = flattenUtils.shape;\n\nvar GL_STATIC_DRAW = 0x88E4;\nvar GL_STREAM_DRAW = 0x88E0;\n\nvar GL_UNSIGNED_BYTE$3 = 5121;\nvar GL_FLOAT$3 = 5126;\n\nvar DTYPES_SIZES = [];\nDTYPES_SIZES[5120] = 1; // int8\nDTYPES_SIZES[5122] = 2; // int16\nDTYPES_SIZES[5124] = 4; // int32\nDTYPES_SIZES[5121] = 1; // uint8\nDTYPES_SIZES[5123] = 2; // uint16\nDTYPES_SIZES[5125] = 4; // uint32\nDTYPES_SIZES[5126] = 4; // float32\n\nfunction typedArrayCode(data) {\n  return arrayTypes[Object.prototype.toString.call(data)] | 0;\n}\n\nfunction copyArray(out, inp) {\n  for (var i = 0; i < inp.length; ++i) {\n    out[i] = inp[i];\n  }\n}\n\nfunction transpose(result, data, shapeX, shapeY, strideX, strideY, offset) {\n  var ptr = 0;\n  for (var i = 0; i < shapeX; ++i) {\n    for (var j = 0; j < shapeY; ++j) {\n      result[ptr++] = data[strideX * i + strideY * j + offset];\n    }\n  }\n}\n\nfunction wrapBufferState(gl, stats, config, attributeState) {\n  var bufferCount = 0;\n  var bufferSet = {};\n\n  function REGLBuffer(type) {\n    this.id = bufferCount++;\n    this.buffer = gl.createBuffer();\n    this.type = type;\n    this.usage = GL_STATIC_DRAW;\n    this.byteLength = 0;\n    this.dimension = 1;\n    this.dtype = GL_UNSIGNED_BYTE$3;\n\n    this.persistentData = null;\n\n    if (config.profile) {\n      this.stats = { size: 0 };\n    }\n  }\n\n  REGLBuffer.prototype.bind = function () {\n    gl.bindBuffer(this.type, this.buffer);\n  };\n\n  REGLBuffer.prototype.destroy = function () {\n    destroy(this);\n  };\n\n  var streamPool = [];\n\n  function createStream(type, data) {\n    var buffer = streamPool.pop();\n    if (!buffer) {\n      buffer = new REGLBuffer(type);\n    }\n    buffer.bind();\n    initBufferFromData(buffer, data, GL_STREAM_DRAW, 0, 1, false);\n    return buffer;\n  }\n\n  function destroyStream(stream$$1) {\n    streamPool.push(stream$$1);\n  }\n\n  function initBufferFromTypedArray(buffer, data, usage) {\n    buffer.byteLength = data.byteLength;\n    gl.bufferData(buffer.type, data, usage);\n  }\n\n  function initBufferFromData(buffer, data, usage, dtype, dimension, persist) {\n    var shape;\n    buffer.usage = usage;\n    if (Array.isArray(data)) {\n      buffer.dtype = dtype || GL_FLOAT$3;\n      if (data.length > 0) {\n        var flatData;\n        if (Array.isArray(data[0])) {\n          shape = arrayShape(data);\n          var dim = 1;\n          for (var i = 1; i < shape.length; ++i) {\n            dim *= shape[i];\n          }\n          buffer.dimension = dim;\n          flatData = arrayFlatten(data, shape, buffer.dtype);\n          initBufferFromTypedArray(buffer, flatData, usage);\n          if (persist) {\n            buffer.persistentData = flatData;\n          } else {\n            pool.freeType(flatData);\n          }\n        } else if (typeof data[0] === 'number') {\n          buffer.dimension = dimension;\n          var typedData = pool.allocType(buffer.dtype, data.length);\n          copyArray(typedData, data);\n          initBufferFromTypedArray(buffer, typedData, usage);\n          if (persist) {\n            buffer.persistentData = typedData;\n          } else {\n            pool.freeType(typedData);\n          }\n        } else if (isTypedArray(data[0])) {\n          buffer.dimension = data[0].length;\n          buffer.dtype = dtype || typedArrayCode(data[0]) || GL_FLOAT$3;\n          flatData = arrayFlatten(data, [data.length, data[0].length], buffer.dtype);\n          initBufferFromTypedArray(buffer, flatData, usage);\n          if (persist) {\n            buffer.persistentData = flatData;\n          } else {\n            pool.freeType(flatData);\n          }\n        } else {\n          check$1.raise('invalid buffer data');\n        }\n      }\n    } else if (isTypedArray(data)) {\n      buffer.dtype = dtype || typedArrayCode(data);\n      buffer.dimension = dimension;\n      initBufferFromTypedArray(buffer, data, usage);\n      if (persist) {\n        buffer.persistentData = new Uint8Array(new Uint8Array(data.buffer));\n      }\n    } else if (isNDArrayLike(data)) {\n      shape = data.shape;\n      var stride = data.stride;\n      var offset = data.offset;\n\n      var shapeX = 0;\n      var shapeY = 0;\n      var strideX = 0;\n      var strideY = 0;\n      if (shape.length === 1) {\n        shapeX = shape[0];\n        shapeY = 1;\n        strideX = stride[0];\n        strideY = 0;\n      } else if (shape.length === 2) {\n        shapeX = shape[0];\n        shapeY = shape[1];\n        strideX = stride[0];\n        strideY = stride[1];\n      } else {\n        check$1.raise('invalid shape');\n      }\n\n      buffer.dtype = dtype || typedArrayCode(data.data) || GL_FLOAT$3;\n      buffer.dimension = shapeY;\n\n      var transposeData = pool.allocType(buffer.dtype, shapeX * shapeY);\n      transpose(transposeData, data.data, shapeX, shapeY, strideX, strideY, offset);\n      initBufferFromTypedArray(buffer, transposeData, usage);\n      if (persist) {\n        buffer.persistentData = transposeData;\n      } else {\n        pool.freeType(transposeData);\n      }\n    } else {\n      check$1.raise('invalid buffer data');\n    }\n  }\n\n  function destroy(buffer) {\n    stats.bufferCount--;\n\n    for (var i = 0; i < attributeState.state.length; ++i) {\n      var record = attributeState.state[i];\n      if (record.buffer === buffer) {\n        gl.disableVertexAttribArray(i);\n        record.buffer = null;\n      }\n    }\n\n    var handle = buffer.buffer;\n    check$1(handle, 'buffer must not be deleted already');\n    gl.deleteBuffer(handle);\n    buffer.buffer = null;\n    delete bufferSet[buffer.id];\n  }\n\n  function createBuffer(options, type, deferInit, persistent) {\n    stats.bufferCount++;\n\n    var buffer = new REGLBuffer(type);\n    bufferSet[buffer.id] = buffer;\n\n    function reglBuffer(options) {\n      var usage = GL_STATIC_DRAW;\n      var data = null;\n      var byteLength = 0;\n      var dtype = 0;\n      var dimension = 1;\n      if (Array.isArray(options) || isTypedArray(options) || isNDArrayLike(options)) {\n        data = options;\n      } else if (typeof options === 'number') {\n        byteLength = options | 0;\n      } else if (options) {\n        check$1.type(options, 'object', 'buffer arguments must be an object, a number or an array');\n\n        if ('data' in options) {\n          check$1(data === null || Array.isArray(data) || isTypedArray(data) || isNDArrayLike(data), 'invalid data for buffer');\n          data = options.data;\n        }\n\n        if ('usage' in options) {\n          check$1.parameter(options.usage, usageTypes, 'invalid buffer usage');\n          usage = usageTypes[options.usage];\n        }\n\n        if ('type' in options) {\n          check$1.parameter(options.type, glTypes, 'invalid buffer type');\n          dtype = glTypes[options.type];\n        }\n\n        if ('dimension' in options) {\n          check$1.type(options.dimension, 'number', 'invalid dimension');\n          dimension = options.dimension | 0;\n        }\n\n        if ('length' in options) {\n          check$1.nni(byteLength, 'buffer length must be a nonnegative integer');\n          byteLength = options.length | 0;\n        }\n      }\n\n      buffer.bind();\n      if (!data) {\n        // #475\n        if (byteLength) gl.bufferData(buffer.type, byteLength, usage);\n        buffer.dtype = dtype || GL_UNSIGNED_BYTE$3;\n        buffer.usage = usage;\n        buffer.dimension = dimension;\n        buffer.byteLength = byteLength;\n      } else {\n        initBufferFromData(buffer, data, usage, dtype, dimension, persistent);\n      }\n\n      if (config.profile) {\n        buffer.stats.size = buffer.byteLength * DTYPES_SIZES[buffer.dtype];\n      }\n\n      return reglBuffer;\n    }\n\n    function setSubData(data, offset) {\n      check$1(offset + data.byteLength <= buffer.byteLength, 'invalid buffer subdata call, buffer is too small. ' + ' Can\\'t write data of size ' + data.byteLength + ' starting from offset ' + offset + ' to a buffer of size ' + buffer.byteLength);\n\n      gl.bufferSubData(buffer.type, offset, data);\n    }\n\n    function subdata(data, offset_) {\n      var offset = (offset_ || 0) | 0;\n      var shape;\n      buffer.bind();\n      if (isTypedArray(data)) {\n        setSubData(data, offset);\n      } else if (Array.isArray(data)) {\n        if (data.length > 0) {\n          if (typeof data[0] === 'number') {\n            var converted = pool.allocType(buffer.dtype, data.length);\n            copyArray(converted, data);\n            setSubData(converted, offset);\n            pool.freeType(converted);\n          } else if (Array.isArray(data[0]) || isTypedArray(data[0])) {\n            shape = arrayShape(data);\n            var flatData = arrayFlatten(data, shape, buffer.dtype);\n            setSubData(flatData, offset);\n            pool.freeType(flatData);\n          } else {\n            check$1.raise('invalid buffer data');\n          }\n        }\n      } else if (isNDArrayLike(data)) {\n        shape = data.shape;\n        var stride = data.stride;\n\n        var shapeX = 0;\n        var shapeY = 0;\n        var strideX = 0;\n        var strideY = 0;\n        if (shape.length === 1) {\n          shapeX = shape[0];\n          shapeY = 1;\n          strideX = stride[0];\n          strideY = 0;\n        } else if (shape.length === 2) {\n          shapeX = shape[0];\n          shapeY = shape[1];\n          strideX = stride[0];\n          strideY = stride[1];\n        } else {\n          check$1.raise('invalid shape');\n        }\n        var dtype = Array.isArray(data.data) ? buffer.dtype : typedArrayCode(data.data);\n\n        var transposeData = pool.allocType(dtype, shapeX * shapeY);\n        transpose(transposeData, data.data, shapeX, shapeY, strideX, strideY, data.offset);\n        setSubData(transposeData, offset);\n        pool.freeType(transposeData);\n      } else {\n        check$1.raise('invalid data for buffer subdata');\n      }\n      return reglBuffer;\n    }\n\n    if (!deferInit) {\n      reglBuffer(options);\n    }\n\n    reglBuffer._reglType = 'buffer';\n    reglBuffer._buffer = buffer;\n    reglBuffer.subdata = subdata;\n    if (config.profile) {\n      reglBuffer.stats = buffer.stats;\n    }\n    reglBuffer.destroy = function () {\n      destroy(buffer);\n    };\n\n    return reglBuffer;\n  }\n\n  function restoreBuffers() {\n    values(bufferSet).forEach(function (buffer) {\n      buffer.buffer = gl.createBuffer();\n      gl.bindBuffer(buffer.type, buffer.buffer);\n      gl.bufferData(buffer.type, buffer.persistentData || buffer.byteLength, buffer.usage);\n    });\n  }\n\n  if (config.profile) {\n    stats.getTotalBufferSize = function () {\n      var total = 0;\n      // TODO: Right now, the streams are not part of the total count.\n      Object.keys(bufferSet).forEach(function (key) {\n        total += bufferSet[key].stats.size;\n      });\n      return total;\n    };\n  }\n\n  return {\n    create: createBuffer,\n\n    createStream: createStream,\n    destroyStream: destroyStream,\n\n    clear: function clear() {\n      values(bufferSet).forEach(destroy);\n      streamPool.forEach(destroy);\n    },\n\n    getBuffer: function getBuffer(wrapper) {\n      if (wrapper && wrapper._buffer instanceof REGLBuffer) {\n        return wrapper._buffer;\n      }\n      return null;\n    },\n\n    restore: restoreBuffers,\n\n    _initBuffer: initBufferFromData\n  };\n}\n\nvar points = 0;\nvar point = 0;\nvar lines = 1;\nvar line = 1;\nvar triangles = 4;\nvar triangle = 4;\nvar primTypes = {\n  points: points,\n  point: point,\n  lines: lines,\n  line: line,\n  triangles: triangles,\n  triangle: triangle,\n  \"line loop\": 2,\n  \"line strip\": 3,\n  \"triangle strip\": 5,\n  \"triangle fan\": 6\n};\n\nvar GL_POINTS = 0;\nvar GL_LINES = 1;\nvar GL_TRIANGLES = 4;\n\nvar GL_BYTE$2 = 5120;\nvar GL_UNSIGNED_BYTE$4 = 5121;\nvar GL_SHORT$2 = 5122;\nvar GL_UNSIGNED_SHORT$2 = 5123;\nvar GL_INT$2 = 5124;\nvar GL_UNSIGNED_INT$2 = 5125;\n\nvar GL_ELEMENT_ARRAY_BUFFER = 34963;\n\nvar GL_STREAM_DRAW$1 = 0x88E0;\nvar GL_STATIC_DRAW$1 = 0x88E4;\n\nfunction wrapElementsState(gl, extensions, bufferState, stats) {\n  var elementSet = {};\n  var elementCount = 0;\n\n  var elementTypes = {\n    'uint8': GL_UNSIGNED_BYTE$4,\n    'uint16': GL_UNSIGNED_SHORT$2\n  };\n\n  if (extensions.oes_element_index_uint) {\n    elementTypes.uint32 = GL_UNSIGNED_INT$2;\n  }\n\n  function REGLElementBuffer(buffer) {\n    this.id = elementCount++;\n    elementSet[this.id] = this;\n    this.buffer = buffer;\n    this.primType = GL_TRIANGLES;\n    this.vertCount = 0;\n    this.type = 0;\n  }\n\n  REGLElementBuffer.prototype.bind = function () {\n    this.buffer.bind();\n  };\n\n  var bufferPool = [];\n\n  function createElementStream(data) {\n    var result = bufferPool.pop();\n    if (!result) {\n      result = new REGLElementBuffer(bufferState.create(null, GL_ELEMENT_ARRAY_BUFFER, true, false)._buffer);\n    }\n    initElements(result, data, GL_STREAM_DRAW$1, -1, -1, 0, 0);\n    return result;\n  }\n\n  function destroyElementStream(elements) {\n    bufferPool.push(elements);\n  }\n\n  function initElements(elements, data, usage, prim, count, byteLength, type) {\n    elements.buffer.bind();\n    if (data) {\n      var predictedType = type;\n      if (!type && (!isTypedArray(data) || isNDArrayLike(data) && !isTypedArray(data.data))) {\n        predictedType = extensions.oes_element_index_uint ? GL_UNSIGNED_INT$2 : GL_UNSIGNED_SHORT$2;\n      }\n      bufferState._initBuffer(elements.buffer, data, usage, predictedType, 3);\n    } else {\n      gl.bufferData(GL_ELEMENT_ARRAY_BUFFER, byteLength, usage);\n      elements.buffer.dtype = dtype || GL_UNSIGNED_BYTE$4;\n      elements.buffer.usage = usage;\n      elements.buffer.dimension = 3;\n      elements.buffer.byteLength = byteLength;\n    }\n\n    var dtype = type;\n    if (!type) {\n      switch (elements.buffer.dtype) {\n        case GL_UNSIGNED_BYTE$4:\n        case GL_BYTE$2:\n          dtype = GL_UNSIGNED_BYTE$4;\n          break;\n\n        case GL_UNSIGNED_SHORT$2:\n        case GL_SHORT$2:\n          dtype = GL_UNSIGNED_SHORT$2;\n          break;\n\n        case GL_UNSIGNED_INT$2:\n        case GL_INT$2:\n          dtype = GL_UNSIGNED_INT$2;\n          break;\n\n        default:\n          check$1.raise('unsupported type for element array');\n      }\n      elements.buffer.dtype = dtype;\n    }\n    elements.type = dtype;\n\n    // Check oes_element_index_uint extension\n    check$1(dtype !== GL_UNSIGNED_INT$2 || !!extensions.oes_element_index_uint, '32 bit element buffers not supported, enable oes_element_index_uint first');\n\n    // try to guess default primitive type and arguments\n    var vertCount = count;\n    if (vertCount < 0) {\n      vertCount = elements.buffer.byteLength;\n      if (dtype === GL_UNSIGNED_SHORT$2) {\n        vertCount >>= 1;\n      } else if (dtype === GL_UNSIGNED_INT$2) {\n        vertCount >>= 2;\n      }\n    }\n    elements.vertCount = vertCount;\n\n    // try to guess primitive type from cell dimension\n    var primType = prim;\n    if (prim < 0) {\n      primType = GL_TRIANGLES;\n      var dimension = elements.buffer.dimension;\n      if (dimension === 1) primType = GL_POINTS;\n      if (dimension === 2) primType = GL_LINES;\n      if (dimension === 3) primType = GL_TRIANGLES;\n    }\n    elements.primType = primType;\n  }\n\n  function destroyElements(elements) {\n    stats.elementsCount--;\n\n    check$1(elements.buffer !== null, 'must not double destroy elements');\n    delete elementSet[elements.id];\n    elements.buffer.destroy();\n    elements.buffer = null;\n  }\n\n  function createElements(options, persistent) {\n    var buffer = bufferState.create(null, GL_ELEMENT_ARRAY_BUFFER, true);\n    var elements = new REGLElementBuffer(buffer._buffer);\n    stats.elementsCount++;\n\n    function reglElements(options) {\n      if (!options) {\n        buffer();\n        elements.primType = GL_TRIANGLES;\n        elements.vertCount = 0;\n        elements.type = GL_UNSIGNED_BYTE$4;\n      } else if (typeof options === 'number') {\n        buffer(options);\n        elements.primType = GL_TRIANGLES;\n        elements.vertCount = options | 0;\n        elements.type = GL_UNSIGNED_BYTE$4;\n      } else {\n        var data = null;\n        var usage = GL_STATIC_DRAW$1;\n        var primType = -1;\n        var vertCount = -1;\n        var byteLength = 0;\n        var dtype = 0;\n        if (Array.isArray(options) || isTypedArray(options) || isNDArrayLike(options)) {\n          data = options;\n        } else {\n          check$1.type(options, 'object', 'invalid arguments for elements');\n          if ('data' in options) {\n            data = options.data;\n            check$1(Array.isArray(data) || isTypedArray(data) || isNDArrayLike(data), 'invalid data for element buffer');\n          }\n          if ('usage' in options) {\n            check$1.parameter(options.usage, usageTypes, 'invalid element buffer usage');\n            usage = usageTypes[options.usage];\n          }\n          if ('primitive' in options) {\n            check$1.parameter(options.primitive, primTypes, 'invalid element buffer primitive');\n            primType = primTypes[options.primitive];\n          }\n          if ('count' in options) {\n            check$1(typeof options.count === 'number' && options.count >= 0, 'invalid vertex count for elements');\n            vertCount = options.count | 0;\n          }\n          if ('type' in options) {\n            check$1.parameter(options.type, elementTypes, 'invalid buffer type');\n            dtype = elementTypes[options.type];\n          }\n          if ('length' in options) {\n            byteLength = options.length | 0;\n          } else {\n            byteLength = vertCount;\n            if (dtype === GL_UNSIGNED_SHORT$2 || dtype === GL_SHORT$2) {\n              byteLength *= 2;\n            } else if (dtype === GL_UNSIGNED_INT$2 || dtype === GL_INT$2) {\n              byteLength *= 4;\n            }\n          }\n        }\n        initElements(elements, data, usage, primType, vertCount, byteLength, dtype);\n      }\n\n      return reglElements;\n    }\n\n    reglElements(options);\n\n    reglElements._reglType = 'elements';\n    reglElements._elements = elements;\n    reglElements.subdata = function (data, offset) {\n      buffer.subdata(data, offset);\n      return reglElements;\n    };\n    reglElements.destroy = function () {\n      destroyElements(elements);\n    };\n\n    return reglElements;\n  }\n\n  return {\n    create: createElements,\n    createStream: createElementStream,\n    destroyStream: destroyElementStream,\n    getElements: function getElements(elements) {\n      if (typeof elements === 'function' && elements._elements instanceof REGLElementBuffer) {\n        return elements._elements;\n      }\n      return null;\n    },\n    clear: function clear() {\n      values(elementSet).forEach(destroyElements);\n    }\n  };\n}\n\nvar FLOAT = new Float32Array(1);\nvar INT = new Uint32Array(FLOAT.buffer);\n\nvar GL_UNSIGNED_SHORT$4 = 5123;\n\nfunction convertToHalfFloat(array) {\n  var ushorts = pool.allocType(GL_UNSIGNED_SHORT$4, array.length);\n\n  for (var i = 0; i < array.length; ++i) {\n    if (isNaN(array[i])) {\n      ushorts[i] = 0xffff;\n    } else if (array[i] === Infinity) {\n      ushorts[i] = 0x7c00;\n    } else if (array[i] === -Infinity) {\n      ushorts[i] = 0xfc00;\n    } else {\n      FLOAT[0] = array[i];\n      var x = INT[0];\n\n      var sgn = x >>> 31 << 15;\n      var exp = (x << 1 >>> 24) - 127;\n      var frac = x >> 13 & (1 << 10) - 1;\n\n      if (exp < -24) {\n        // round non-representable denormals to 0\n        ushorts[i] = sgn;\n      } else if (exp < -14) {\n        // handle denormals\n        var s = -14 - exp;\n        ushorts[i] = sgn + (frac + (1 << 10) >> s);\n      } else if (exp > 15) {\n        // round overflow to +/- Infinity\n        ushorts[i] = sgn + 0x7c00;\n      } else {\n        // otherwise convert directly\n        ushorts[i] = sgn + (exp + 15 << 10) + frac;\n      }\n    }\n  }\n\n  return ushorts;\n}\n\nfunction isArrayLike(s) {\n  return Array.isArray(s) || isTypedArray(s);\n}\n\nvar isPow2$1 = function isPow2$1(v) {\n  return !(v & v - 1) && !!v;\n};\n\nvar GL_COMPRESSED_TEXTURE_FORMATS = 0x86A3;\n\nvar GL_TEXTURE_2D$1 = 0x0DE1;\nvar GL_TEXTURE_CUBE_MAP$1 = 0x8513;\nvar GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 = 0x8515;\n\nvar GL_RGBA$1 = 0x1908;\nvar GL_ALPHA = 0x1906;\nvar GL_RGB = 0x1907;\nvar GL_LUMINANCE = 0x1909;\nvar GL_LUMINANCE_ALPHA = 0x190A;\n\nvar GL_RGBA4 = 0x8056;\nvar GL_RGB5_A1 = 0x8057;\nvar GL_RGB565 = 0x8D62;\n\nvar GL_UNSIGNED_SHORT_4_4_4_4$1 = 0x8033;\nvar GL_UNSIGNED_SHORT_5_5_5_1$1 = 0x8034;\nvar GL_UNSIGNED_SHORT_5_6_5$1 = 0x8363;\nvar GL_UNSIGNED_INT_24_8_WEBGL$1 = 0x84FA;\n\nvar GL_DEPTH_COMPONENT = 0x1902;\nvar GL_DEPTH_STENCIL = 0x84F9;\n\nvar GL_SRGB_EXT = 0x8C40;\nvar GL_SRGB_ALPHA_EXT = 0x8C42;\n\nvar GL_HALF_FLOAT_OES$1 = 0x8D61;\n\nvar GL_COMPRESSED_RGB_S3TC_DXT1_EXT = 0x83F0;\nvar GL_COMPRESSED_RGBA_S3TC_DXT1_EXT = 0x83F1;\nvar GL_COMPRESSED_RGBA_S3TC_DXT3_EXT = 0x83F2;\nvar GL_COMPRESSED_RGBA_S3TC_DXT5_EXT = 0x83F3;\n\nvar GL_COMPRESSED_RGB_ATC_WEBGL = 0x8C92;\nvar GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 0x8C93;\nvar GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 0x87EE;\n\nvar GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 0x8C00;\nvar GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 0x8C01;\nvar GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 0x8C02;\nvar GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 0x8C03;\n\nvar GL_COMPRESSED_RGB_ETC1_WEBGL = 0x8D64;\n\nvar GL_UNSIGNED_BYTE$5 = 0x1401;\nvar GL_UNSIGNED_SHORT$3 = 0x1403;\nvar GL_UNSIGNED_INT$3 = 0x1405;\nvar GL_FLOAT$4 = 0x1406;\n\nvar GL_TEXTURE_WRAP_S = 0x2802;\nvar GL_TEXTURE_WRAP_T = 0x2803;\n\nvar GL_REPEAT = 0x2901;\nvar GL_CLAMP_TO_EDGE$1 = 0x812F;\nvar GL_MIRRORED_REPEAT = 0x8370;\n\nvar GL_TEXTURE_MAG_FILTER = 0x2800;\nvar GL_TEXTURE_MIN_FILTER = 0x2801;\n\nvar GL_NEAREST$1 = 0x2600;\nvar GL_LINEAR = 0x2601;\nvar GL_NEAREST_MIPMAP_NEAREST$1 = 0x2700;\nvar GL_LINEAR_MIPMAP_NEAREST$1 = 0x2701;\nvar GL_NEAREST_MIPMAP_LINEAR$1 = 0x2702;\nvar GL_LINEAR_MIPMAP_LINEAR$1 = 0x2703;\n\nvar GL_GENERATE_MIPMAP_HINT = 0x8192;\nvar GL_DONT_CARE = 0x1100;\nvar GL_FASTEST = 0x1101;\nvar GL_NICEST = 0x1102;\n\nvar GL_TEXTURE_MAX_ANISOTROPY_EXT = 0x84FE;\n\nvar GL_UNPACK_ALIGNMENT = 0x0CF5;\nvar GL_UNPACK_FLIP_Y_WEBGL = 0x9240;\nvar GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241;\nvar GL_UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243;\n\nvar GL_BROWSER_DEFAULT_WEBGL = 0x9244;\n\nvar GL_TEXTURE0$1 = 0x84C0;\n\nvar MIPMAP_FILTERS = [GL_NEAREST_MIPMAP_NEAREST$1, GL_NEAREST_MIPMAP_LINEAR$1, GL_LINEAR_MIPMAP_NEAREST$1, GL_LINEAR_MIPMAP_LINEAR$1];\n\nvar CHANNELS_FORMAT = [0, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_RGBA$1];\n\nvar FORMAT_CHANNELS = {};\nFORMAT_CHANNELS[GL_LUMINANCE] = FORMAT_CHANNELS[GL_ALPHA] = FORMAT_CHANNELS[GL_DEPTH_COMPONENT] = 1;\nFORMAT_CHANNELS[GL_DEPTH_STENCIL] = FORMAT_CHANNELS[GL_LUMINANCE_ALPHA] = 2;\nFORMAT_CHANNELS[GL_RGB] = FORMAT_CHANNELS[GL_SRGB_EXT] = 3;\nFORMAT_CHANNELS[GL_RGBA$1] = FORMAT_CHANNELS[GL_SRGB_ALPHA_EXT] = 4;\n\nfunction objectName(str) {\n  return '[object ' + str + ']';\n}\n\nvar CANVAS_CLASS = objectName('HTMLCanvasElement');\nvar CONTEXT2D_CLASS = objectName('CanvasRenderingContext2D');\nvar BITMAP_CLASS = objectName('ImageBitmap');\nvar IMAGE_CLASS = objectName('HTMLImageElement');\nvar VIDEO_CLASS = objectName('HTMLVideoElement');\n\nvar PIXEL_CLASSES = Object.keys(arrayTypes).concat([CANVAS_CLASS, CONTEXT2D_CLASS, BITMAP_CLASS, IMAGE_CLASS, VIDEO_CLASS]);\n\n// for every texture type, store\n// the size in bytes.\nvar TYPE_SIZES = [];\nTYPE_SIZES[GL_UNSIGNED_BYTE$5] = 1;\nTYPE_SIZES[GL_FLOAT$4] = 4;\nTYPE_SIZES[GL_HALF_FLOAT_OES$1] = 2;\n\nTYPE_SIZES[GL_UNSIGNED_SHORT$3] = 2;\nTYPE_SIZES[GL_UNSIGNED_INT$3] = 4;\n\nvar FORMAT_SIZES_SPECIAL = [];\nFORMAT_SIZES_SPECIAL[GL_RGBA4] = 2;\nFORMAT_SIZES_SPECIAL[GL_RGB5_A1] = 2;\nFORMAT_SIZES_SPECIAL[GL_RGB565] = 2;\nFORMAT_SIZES_SPECIAL[GL_DEPTH_STENCIL] = 4;\n\nFORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_S3TC_DXT1_EXT] = 0.5;\nFORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT1_EXT] = 0.5;\nFORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT3_EXT] = 1;\nFORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT5_EXT] = 1;\n\nFORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_ATC_WEBGL] = 0.5;\nFORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL] = 1;\nFORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL] = 1;\n\nFORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG] = 0.5;\nFORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG] = 0.25;\nFORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG] = 0.5;\nFORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG] = 0.25;\n\nFORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_ETC1_WEBGL] = 0.5;\n\nfunction isNumericArray(arr) {\n  return Array.isArray(arr) && (arr.length === 0 || typeof arr[0] === 'number');\n}\n\nfunction isRectArray(arr) {\n  if (!Array.isArray(arr)) {\n    return false;\n  }\n  var width = arr.length;\n  if (width === 0 || !isArrayLike(arr[0])) {\n    return false;\n  }\n  return true;\n}\n\nfunction classString(x) {\n  return Object.prototype.toString.call(x);\n}\n\nfunction isCanvasElement(object) {\n  return classString(object) === CANVAS_CLASS;\n}\n\nfunction isContext2D(object) {\n  return classString(object) === CONTEXT2D_CLASS;\n}\n\nfunction isBitmap(object) {\n  return classString(object) === BITMAP_CLASS;\n}\n\nfunction isImageElement(object) {\n  return classString(object) === IMAGE_CLASS;\n}\n\nfunction isVideoElement(object) {\n  return classString(object) === VIDEO_CLASS;\n}\n\nfunction isPixelData(object) {\n  if (!object) {\n    return false;\n  }\n  var className = classString(object);\n  if (PIXEL_CLASSES.indexOf(className) >= 0) {\n    return true;\n  }\n  return isNumericArray(object) || isRectArray(object) || isNDArrayLike(object);\n}\n\nfunction typedArrayCode$1(data) {\n  return arrayTypes[Object.prototype.toString.call(data)] | 0;\n}\n\nfunction convertData(result, data) {\n  var n = data.length;\n  switch (result.type) {\n    case GL_UNSIGNED_BYTE$5:\n    case GL_UNSIGNED_SHORT$3:\n    case GL_UNSIGNED_INT$3:\n    case GL_FLOAT$4:\n      var converted = pool.allocType(result.type, n);\n      converted.set(data);\n      result.data = converted;\n      break;\n\n    case GL_HALF_FLOAT_OES$1:\n      result.data = convertToHalfFloat(data);\n      break;\n\n    default:\n      check$1.raise('unsupported texture type, must specify a typed array');\n  }\n}\n\nfunction preConvert(image, n) {\n  return pool.allocType(image.type === GL_HALF_FLOAT_OES$1 ? GL_FLOAT$4 : image.type, n);\n}\n\nfunction postConvert(image, data) {\n  if (image.type === GL_HALF_FLOAT_OES$1) {\n    image.data = convertToHalfFloat(data);\n    pool.freeType(data);\n  } else {\n    image.data = data;\n  }\n}\n\nfunction transposeData(image, array, strideX, strideY, strideC, offset) {\n  var w = image.width;\n  var h = image.height;\n  var c = image.channels;\n  var n = w * h * c;\n  var data = preConvert(image, n);\n\n  var p = 0;\n  for (var i = 0; i < h; ++i) {\n    for (var j = 0; j < w; ++j) {\n      for (var k = 0; k < c; ++k) {\n        data[p++] = array[strideX * j + strideY * i + strideC * k + offset];\n      }\n    }\n  }\n\n  postConvert(image, data);\n}\n\nfunction getTextureSize(format, type, width, height, isMipmap, isCube) {\n  var s;\n  if (typeof FORMAT_SIZES_SPECIAL[format] !== 'undefined') {\n    // we have a special array for dealing with weird color formats such as RGB5A1\n    s = FORMAT_SIZES_SPECIAL[format];\n  } else {\n    s = FORMAT_CHANNELS[format] * TYPE_SIZES[type];\n  }\n\n  if (isCube) {\n    s *= 6;\n  }\n\n  if (isMipmap) {\n    // compute the total size of all the mipmaps.\n    var total = 0;\n\n    var w = width;\n    while (w >= 1) {\n      // we can only use mipmaps on a square image,\n      // so we can simply use the width and ignore the height:\n      total += s * w * w;\n      w /= 2;\n    }\n    return total;\n  } else {\n    return s * width * height;\n  }\n}\n\nfunction createTextureSet(gl, extensions, limits, reglPoll, contextState, stats, config) {\n  // -------------------------------------------------------\n  // Initialize constants and parameter tables here\n  // -------------------------------------------------------\n  var mipmapHint = {\n    \"don't care\": GL_DONT_CARE,\n    'dont care': GL_DONT_CARE,\n    'nice': GL_NICEST,\n    'fast': GL_FASTEST\n  };\n\n  var wrapModes = {\n    'repeat': GL_REPEAT,\n    'clamp': GL_CLAMP_TO_EDGE$1,\n    'mirror': GL_MIRRORED_REPEAT\n  };\n\n  var magFilters = {\n    'nearest': GL_NEAREST$1,\n    'linear': GL_LINEAR\n  };\n\n  var minFilters = extend({\n    'mipmap': GL_LINEAR_MIPMAP_LINEAR$1,\n    'nearest mipmap nearest': GL_NEAREST_MIPMAP_NEAREST$1,\n    'linear mipmap nearest': GL_LINEAR_MIPMAP_NEAREST$1,\n    'nearest mipmap linear': GL_NEAREST_MIPMAP_LINEAR$1,\n    'linear mipmap linear': GL_LINEAR_MIPMAP_LINEAR$1\n  }, magFilters);\n\n  var colorSpace = {\n    'none': 0,\n    'browser': GL_BROWSER_DEFAULT_WEBGL\n  };\n\n  var textureTypes = {\n    'uint8': GL_UNSIGNED_BYTE$5,\n    'rgba4': GL_UNSIGNED_SHORT_4_4_4_4$1,\n    'rgb565': GL_UNSIGNED_SHORT_5_6_5$1,\n    'rgb5 a1': GL_UNSIGNED_SHORT_5_5_5_1$1\n  };\n\n  var textureFormats = {\n    'alpha': GL_ALPHA,\n    'luminance': GL_LUMINANCE,\n    'luminance alpha': GL_LUMINANCE_ALPHA,\n    'rgb': GL_RGB,\n    'rgba': GL_RGBA$1,\n    'rgba4': GL_RGBA4,\n    'rgb5 a1': GL_RGB5_A1,\n    'rgb565': GL_RGB565\n  };\n\n  var compressedTextureFormats = {};\n\n  if (extensions.ext_srgb) {\n    textureFormats.srgb = GL_SRGB_EXT;\n    textureFormats.srgba = GL_SRGB_ALPHA_EXT;\n  }\n\n  if (extensions.oes_texture_float) {\n    textureTypes.float32 = textureTypes.float = GL_FLOAT$4;\n  }\n\n  if (extensions.oes_texture_half_float) {\n    textureTypes['float16'] = textureTypes['half float'] = GL_HALF_FLOAT_OES$1;\n  }\n\n  if (extensions.webgl_depth_texture) {\n    extend(textureFormats, {\n      'depth': GL_DEPTH_COMPONENT,\n      'depth stencil': GL_DEPTH_STENCIL\n    });\n\n    extend(textureTypes, {\n      'uint16': GL_UNSIGNED_SHORT$3,\n      'uint32': GL_UNSIGNED_INT$3,\n      'depth stencil': GL_UNSIGNED_INT_24_8_WEBGL$1\n    });\n  }\n\n  if (extensions.webgl_compressed_texture_s3tc) {\n    extend(compressedTextureFormats, {\n      'rgb s3tc dxt1': GL_COMPRESSED_RGB_S3TC_DXT1_EXT,\n      'rgba s3tc dxt1': GL_COMPRESSED_RGBA_S3TC_DXT1_EXT,\n      'rgba s3tc dxt3': GL_COMPRESSED_RGBA_S3TC_DXT3_EXT,\n      'rgba s3tc dxt5': GL_COMPRESSED_RGBA_S3TC_DXT5_EXT\n    });\n  }\n\n  if (extensions.webgl_compressed_texture_atc) {\n    extend(compressedTextureFormats, {\n      'rgb atc': GL_COMPRESSED_RGB_ATC_WEBGL,\n      'rgba atc explicit alpha': GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL,\n      'rgba atc interpolated alpha': GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL\n    });\n  }\n\n  if (extensions.webgl_compressed_texture_pvrtc) {\n    extend(compressedTextureFormats, {\n      'rgb pvrtc 4bppv1': GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG,\n      'rgb pvrtc 2bppv1': GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG,\n      'rgba pvrtc 4bppv1': GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,\n      'rgba pvrtc 2bppv1': GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG\n    });\n  }\n\n  if (extensions.webgl_compressed_texture_etc1) {\n    compressedTextureFormats['rgb etc1'] = GL_COMPRESSED_RGB_ETC1_WEBGL;\n  }\n\n  // Copy over all texture formats\n  var supportedCompressedFormats = Array.prototype.slice.call(gl.getParameter(GL_COMPRESSED_TEXTURE_FORMATS));\n  Object.keys(compressedTextureFormats).forEach(function (name) {\n    var format = compressedTextureFormats[name];\n    if (supportedCompressedFormats.indexOf(format) >= 0) {\n      textureFormats[name] = format;\n    }\n  });\n\n  var supportedFormats = Object.keys(textureFormats);\n  limits.textureFormats = supportedFormats;\n\n  // associate with every format string its\n  // corresponding GL-value.\n  var textureFormatsInvert = [];\n  Object.keys(textureFormats).forEach(function (key) {\n    var val = textureFormats[key];\n    textureFormatsInvert[val] = key;\n  });\n\n  // associate with every type string its\n  // corresponding GL-value.\n  var textureTypesInvert = [];\n  Object.keys(textureTypes).forEach(function (key) {\n    var val = textureTypes[key];\n    textureTypesInvert[val] = key;\n  });\n\n  var magFiltersInvert = [];\n  Object.keys(magFilters).forEach(function (key) {\n    var val = magFilters[key];\n    magFiltersInvert[val] = key;\n  });\n\n  var minFiltersInvert = [];\n  Object.keys(minFilters).forEach(function (key) {\n    var val = minFilters[key];\n    minFiltersInvert[val] = key;\n  });\n\n  var wrapModesInvert = [];\n  Object.keys(wrapModes).forEach(function (key) {\n    var val = wrapModes[key];\n    wrapModesInvert[val] = key;\n  });\n\n  // colorFormats[] gives the format (channels) associated to an\n  // internalformat\n  var colorFormats = supportedFormats.reduce(function (color, key) {\n    var glenum = textureFormats[key];\n    if (glenum === GL_LUMINANCE || glenum === GL_ALPHA || glenum === GL_LUMINANCE || glenum === GL_LUMINANCE_ALPHA || glenum === GL_DEPTH_COMPONENT || glenum === GL_DEPTH_STENCIL) {\n      color[glenum] = glenum;\n    } else if (glenum === GL_RGB5_A1 || key.indexOf('rgba') >= 0) {\n      color[glenum] = GL_RGBA$1;\n    } else {\n      color[glenum] = GL_RGB;\n    }\n    return color;\n  }, {});\n\n  function TexFlags() {\n    // format info\n    this.internalformat = GL_RGBA$1;\n    this.format = GL_RGBA$1;\n    this.type = GL_UNSIGNED_BYTE$5;\n    this.compressed = false;\n\n    // pixel storage\n    this.premultiplyAlpha = false;\n    this.flipY = false;\n    this.unpackAlignment = 1;\n    this.colorSpace = GL_BROWSER_DEFAULT_WEBGL;\n\n    // shape info\n    this.width = 0;\n    this.height = 0;\n    this.channels = 0;\n  }\n\n  function copyFlags(result, other) {\n    result.internalformat = other.internalformat;\n    result.format = other.format;\n    result.type = other.type;\n    result.compressed = other.compressed;\n\n    result.premultiplyAlpha = other.premultiplyAlpha;\n    result.flipY = other.flipY;\n    result.unpackAlignment = other.unpackAlignment;\n    result.colorSpace = other.colorSpace;\n\n    result.width = other.width;\n    result.height = other.height;\n    result.channels = other.channels;\n  }\n\n  function parseFlags(flags, options) {\n    if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) !== 'object' || !options) {\n      return;\n    }\n\n    if ('premultiplyAlpha' in options) {\n      check$1.type(options.premultiplyAlpha, 'boolean', 'invalid premultiplyAlpha');\n      flags.premultiplyAlpha = options.premultiplyAlpha;\n    }\n\n    if ('flipY' in options) {\n      check$1.type(options.flipY, 'boolean', 'invalid texture flip');\n      flags.flipY = options.flipY;\n    }\n\n    if ('alignment' in options) {\n      check$1.oneOf(options.alignment, [1, 2, 4, 8], 'invalid texture unpack alignment');\n      flags.unpackAlignment = options.alignment;\n    }\n\n    if ('colorSpace' in options) {\n      check$1.parameter(options.colorSpace, colorSpace, 'invalid colorSpace');\n      flags.colorSpace = colorSpace[options.colorSpace];\n    }\n\n    if ('type' in options) {\n      var type = options.type;\n      check$1(extensions.oes_texture_float || !(type === 'float' || type === 'float32'), 'you must enable the OES_texture_float extension in order to use floating point textures.');\n      check$1(extensions.oes_texture_half_float || !(type === 'half float' || type === 'float16'), 'you must enable the OES_texture_half_float extension in order to use 16-bit floating point textures.');\n      check$1(extensions.webgl_depth_texture || !(type === 'uint16' || type === 'uint32' || type === 'depth stencil'), 'you must enable the WEBGL_depth_texture extension in order to use depth/stencil textures.');\n      check$1.parameter(type, textureTypes, 'invalid texture type');\n      flags.type = textureTypes[type];\n    }\n\n    var w = flags.width;\n    var h = flags.height;\n    var c = flags.channels;\n    var hasChannels = false;\n    if ('shape' in options) {\n      check$1(Array.isArray(options.shape) && options.shape.length >= 2, 'shape must be an array');\n      w = options.shape[0];\n      h = options.shape[1];\n      if (options.shape.length === 3) {\n        c = options.shape[2];\n        check$1(c > 0 && c <= 4, 'invalid number of channels');\n        hasChannels = true;\n      }\n      check$1(w >= 0 && w <= limits.maxTextureSize, 'invalid width');\n      check$1(h >= 0 && h <= limits.maxTextureSize, 'invalid height');\n    } else {\n      if ('radius' in options) {\n        w = h = options.radius;\n        check$1(w >= 0 && w <= limits.maxTextureSize, 'invalid radius');\n      }\n      if ('width' in options) {\n        w = options.width;\n        check$1(w >= 0 && w <= limits.maxTextureSize, 'invalid width');\n      }\n      if ('height' in options) {\n        h = options.height;\n        check$1(h >= 0 && h <= limits.maxTextureSize, 'invalid height');\n      }\n      if ('channels' in options) {\n        c = options.channels;\n        check$1(c > 0 && c <= 4, 'invalid number of channels');\n        hasChannels = true;\n      }\n    }\n    flags.width = w | 0;\n    flags.height = h | 0;\n    flags.channels = c | 0;\n\n    var hasFormat = false;\n    if ('format' in options) {\n      var formatStr = options.format;\n      check$1(extensions.webgl_depth_texture || !(formatStr === 'depth' || formatStr === 'depth stencil'), 'you must enable the WEBGL_depth_texture extension in order to use depth/stencil textures.');\n      check$1.parameter(formatStr, textureFormats, 'invalid texture format');\n      var internalformat = flags.internalformat = textureFormats[formatStr];\n      flags.format = colorFormats[internalformat];\n      if (formatStr in textureTypes) {\n        if (!('type' in options)) {\n          flags.type = textureTypes[formatStr];\n        }\n      }\n      if (formatStr in compressedTextureFormats) {\n        flags.compressed = true;\n      }\n      hasFormat = true;\n    }\n\n    // Reconcile channels and format\n    if (!hasChannels && hasFormat) {\n      flags.channels = FORMAT_CHANNELS[flags.format];\n    } else if (hasChannels && !hasFormat) {\n      if (flags.channels !== CHANNELS_FORMAT[flags.format]) {\n        flags.format = flags.internalformat = CHANNELS_FORMAT[flags.channels];\n      }\n    } else if (hasFormat && hasChannels) {\n      check$1(flags.channels === FORMAT_CHANNELS[flags.format], 'number of channels inconsistent with specified format');\n    }\n  }\n\n  function setFlags(flags) {\n    gl.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, flags.flipY);\n    gl.pixelStorei(GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL, flags.premultiplyAlpha);\n    gl.pixelStorei(GL_UNPACK_COLORSPACE_CONVERSION_WEBGL, flags.colorSpace);\n    gl.pixelStorei(GL_UNPACK_ALIGNMENT, flags.unpackAlignment);\n  }\n\n  // -------------------------------------------------------\n  // Tex image data\n  // -------------------------------------------------------\n  function TexImage() {\n    TexFlags.call(this);\n\n    this.xOffset = 0;\n    this.yOffset = 0;\n\n    // data\n    this.data = null;\n    this.needsFree = false;\n\n    // html element\n    this.element = null;\n\n    // copyTexImage info\n    this.needsCopy = false;\n  }\n\n  function parseImage(image, options) {\n    var data = null;\n    if (isPixelData(options)) {\n      data = options;\n    } else if (options) {\n      check$1.type(options, 'object', 'invalid pixel data type');\n      parseFlags(image, options);\n      if ('x' in options) {\n        image.xOffset = options.x | 0;\n      }\n      if ('y' in options) {\n        image.yOffset = options.y | 0;\n      }\n      if (isPixelData(options.data)) {\n        data = options.data;\n      }\n    }\n\n    check$1(!image.compressed || data instanceof Uint8Array, 'compressed texture data must be stored in a uint8array');\n\n    if (options.copy) {\n      check$1(!data, 'can not specify copy and data field for the same texture');\n      var viewW = contextState.viewportWidth;\n      var viewH = contextState.viewportHeight;\n      image.width = image.width || viewW - image.xOffset;\n      image.height = image.height || viewH - image.yOffset;\n      image.needsCopy = true;\n      check$1(image.xOffset >= 0 && image.xOffset < viewW && image.yOffset >= 0 && image.yOffset < viewH && image.width > 0 && image.width <= viewW && image.height > 0 && image.height <= viewH, 'copy texture read out of bounds');\n    } else if (!data) {\n      image.width = image.width || 1;\n      image.height = image.height || 1;\n      image.channels = image.channels || 4;\n    } else if (isTypedArray(data)) {\n      image.channels = image.channels || 4;\n      image.data = data;\n      if (!('type' in options) && image.type === GL_UNSIGNED_BYTE$5) {\n        image.type = typedArrayCode$1(data);\n      }\n    } else if (isNumericArray(data)) {\n      image.channels = image.channels || 4;\n      convertData(image, data);\n      image.alignment = 1;\n      image.needsFree = true;\n    } else if (isNDArrayLike(data)) {\n      var array = data.data;\n      if (!Array.isArray(array) && image.type === GL_UNSIGNED_BYTE$5) {\n        image.type = typedArrayCode$1(array);\n      }\n      var shape = data.shape;\n      var stride = data.stride;\n      var shapeX, shapeY, shapeC, strideX, strideY, strideC;\n      if (shape.length === 3) {\n        shapeC = shape[2];\n        strideC = stride[2];\n      } else {\n        check$1(shape.length === 2, 'invalid ndarray pixel data, must be 2 or 3D');\n        shapeC = 1;\n        strideC = 1;\n      }\n      shapeX = shape[0];\n      shapeY = shape[1];\n      strideX = stride[0];\n      strideY = stride[1];\n      image.alignment = 1;\n      image.width = shapeX;\n      image.height = shapeY;\n      image.channels = shapeC;\n      image.format = image.internalformat = CHANNELS_FORMAT[shapeC];\n      image.needsFree = true;\n      transposeData(image, array, strideX, strideY, strideC, data.offset);\n    } else if (isCanvasElement(data) || isContext2D(data)) {\n      if (isCanvasElement(data)) {\n        image.element = data;\n      } else {\n        image.element = data.canvas;\n      }\n      image.width = image.element.width;\n      image.height = image.element.height;\n      image.channels = 4;\n    } else if (isBitmap(data)) {\n      image.element = data;\n      image.width = data.width;\n      image.height = data.height;\n      image.channels = 4;\n    } else if (isImageElement(data)) {\n      image.element = data;\n      image.width = data.naturalWidth;\n      image.height = data.naturalHeight;\n      image.channels = 4;\n    } else if (isVideoElement(data)) {\n      image.element = data;\n      image.width = data.videoWidth;\n      image.height = data.videoHeight;\n      image.channels = 4;\n    } else if (isRectArray(data)) {\n      var w = image.width || data[0].length;\n      var h = image.height || data.length;\n      var c = image.channels;\n      if (isArrayLike(data[0][0])) {\n        c = c || data[0][0].length;\n      } else {\n        c = c || 1;\n      }\n      var arrayShape = flattenUtils.shape(data);\n      var n = 1;\n      for (var dd = 0; dd < arrayShape.length; ++dd) {\n        n *= arrayShape[dd];\n      }\n      var allocData = preConvert(image, n);\n      flattenUtils.flatten(data, arrayShape, '', allocData);\n      postConvert(image, allocData);\n      image.alignment = 1;\n      image.width = w;\n      image.height = h;\n      image.channels = c;\n      image.format = image.internalformat = CHANNELS_FORMAT[c];\n      image.needsFree = true;\n    }\n\n    if (image.type === GL_FLOAT$4) {\n      check$1(limits.extensions.indexOf('oes_texture_float') >= 0, 'oes_texture_float extension not enabled');\n    } else if (image.type === GL_HALF_FLOAT_OES$1) {\n      check$1(limits.extensions.indexOf('oes_texture_half_float') >= 0, 'oes_texture_half_float extension not enabled');\n    }\n\n    // do compressed texture  validation here.\n  }\n\n  function setImage(info, target, miplevel) {\n    var element = info.element;\n    var data = info.data;\n    var internalformat = info.internalformat;\n    var format = info.format;\n    var type = info.type;\n    var width = info.width;\n    var height = info.height;\n    var channels = info.channels;\n\n    setFlags(info);\n\n    if (element) {\n      gl.texImage2D(target, miplevel, format, format, type, element);\n    } else if (info.compressed) {\n      gl.compressedTexImage2D(target, miplevel, internalformat, width, height, 0, data);\n    } else if (info.needsCopy) {\n      reglPoll();\n      gl.copyTexImage2D(target, miplevel, format, info.xOffset, info.yOffset, width, height, 0);\n    } else {\n      var nullData = !data;\n      if (nullData) {\n        data = pool.zero.allocType(type, width * height * channels);\n      }\n\n      gl.texImage2D(target, miplevel, format, width, height, 0, format, type, data);\n\n      if (nullData && data) {\n        pool.zero.freeType(data);\n      }\n    }\n  }\n\n  function setSubImage(info, target, x, y, miplevel) {\n    var element = info.element;\n    var data = info.data;\n    var internalformat = info.internalformat;\n    var format = info.format;\n    var type = info.type;\n    var width = info.width;\n    var height = info.height;\n\n    setFlags(info);\n\n    if (element) {\n      gl.texSubImage2D(target, miplevel, x, y, format, type, element);\n    } else if (info.compressed) {\n      gl.compressedTexSubImage2D(target, miplevel, x, y, internalformat, width, height, data);\n    } else if (info.needsCopy) {\n      reglPoll();\n      gl.copyTexSubImage2D(target, miplevel, x, y, info.xOffset, info.yOffset, width, height);\n    } else {\n      gl.texSubImage2D(target, miplevel, x, y, width, height, format, type, data);\n    }\n  }\n\n  // texImage pool\n  var imagePool = [];\n\n  function allocImage() {\n    return imagePool.pop() || new TexImage();\n  }\n\n  function freeImage(image) {\n    if (image.needsFree) {\n      pool.freeType(image.data);\n    }\n    TexImage.call(image);\n    imagePool.push(image);\n  }\n\n  // -------------------------------------------------------\n  // Mip map\n  // -------------------------------------------------------\n  function MipMap() {\n    TexFlags.call(this);\n\n    this.genMipmaps = false;\n    this.mipmapHint = GL_DONT_CARE;\n    this.mipmask = 0;\n    this.images = Array(16);\n  }\n\n  function parseMipMapFromShape(mipmap, width, height) {\n    var img = mipmap.images[0] = allocImage();\n    mipmap.mipmask = 1;\n    img.width = mipmap.width = width;\n    img.height = mipmap.height = height;\n    img.channels = mipmap.channels = 4;\n  }\n\n  function parseMipMapFromObject(mipmap, options) {\n    var imgData = null;\n    if (isPixelData(options)) {\n      imgData = mipmap.images[0] = allocImage();\n      copyFlags(imgData, mipmap);\n      parseImage(imgData, options);\n      mipmap.mipmask = 1;\n    } else {\n      parseFlags(mipmap, options);\n      if (Array.isArray(options.mipmap)) {\n        var mipData = options.mipmap;\n        for (var i = 0; i < mipData.length; ++i) {\n          imgData = mipmap.images[i] = allocImage();\n          copyFlags(imgData, mipmap);\n          imgData.width >>= i;\n          imgData.height >>= i;\n          parseImage(imgData, mipData[i]);\n          mipmap.mipmask |= 1 << i;\n        }\n      } else {\n        imgData = mipmap.images[0] = allocImage();\n        copyFlags(imgData, mipmap);\n        parseImage(imgData, options);\n        mipmap.mipmask = 1;\n      }\n    }\n    copyFlags(mipmap, mipmap.images[0]);\n\n    // For textures of the compressed format WEBGL_compressed_texture_s3tc\n    // we must have that\n    //\n    // \"When level equals zero width and height must be a multiple of 4.\n    // When level is greater than 0 width and height must be 0, 1, 2 or a multiple of 4. \"\n    //\n    // but we do not yet support having multiple mipmap levels for compressed textures,\n    // so we only test for level zero.\n\n    if (mipmap.compressed && mipmap.internalformat === GL_COMPRESSED_RGB_S3TC_DXT1_EXT || mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT1_EXT || mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT3_EXT || mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT5_EXT) {\n      check$1(mipmap.width % 4 === 0 && mipmap.height % 4 === 0, 'for compressed texture formats, mipmap level 0 must have width and height that are a multiple of 4');\n    }\n  }\n\n  function setMipMap(mipmap, target) {\n    var images = mipmap.images;\n    for (var i = 0; i < images.length; ++i) {\n      if (!images[i]) {\n        return;\n      }\n      setImage(images[i], target, i);\n    }\n  }\n\n  var mipPool = [];\n\n  function allocMipMap() {\n    var result = mipPool.pop() || new MipMap();\n    TexFlags.call(result);\n    result.mipmask = 0;\n    for (var i = 0; i < 16; ++i) {\n      result.images[i] = null;\n    }\n    return result;\n  }\n\n  function freeMipMap(mipmap) {\n    var images = mipmap.images;\n    for (var i = 0; i < images.length; ++i) {\n      if (images[i]) {\n        freeImage(images[i]);\n      }\n      images[i] = null;\n    }\n    mipPool.push(mipmap);\n  }\n\n  // -------------------------------------------------------\n  // Tex info\n  // -------------------------------------------------------\n  function TexInfo() {\n    this.minFilter = GL_NEAREST$1;\n    this.magFilter = GL_NEAREST$1;\n\n    this.wrapS = GL_CLAMP_TO_EDGE$1;\n    this.wrapT = GL_CLAMP_TO_EDGE$1;\n\n    this.anisotropic = 1;\n\n    this.genMipmaps = false;\n    this.mipmapHint = GL_DONT_CARE;\n  }\n\n  function parseTexInfo(info, options) {\n    if ('min' in options) {\n      var minFilter = options.min;\n      check$1.parameter(minFilter, minFilters);\n      info.minFilter = minFilters[minFilter];\n      if (MIPMAP_FILTERS.indexOf(info.minFilter) >= 0 && !('faces' in options)) {\n        info.genMipmaps = true;\n      }\n    }\n\n    if ('mag' in options) {\n      var magFilter = options.mag;\n      check$1.parameter(magFilter, magFilters);\n      info.magFilter = magFilters[magFilter];\n    }\n\n    var wrapS = info.wrapS;\n    var wrapT = info.wrapT;\n    if ('wrap' in options) {\n      var wrap = options.wrap;\n      if (typeof wrap === 'string') {\n        check$1.parameter(wrap, wrapModes);\n        wrapS = wrapT = wrapModes[wrap];\n      } else if (Array.isArray(wrap)) {\n        check$1.parameter(wrap[0], wrapModes);\n        check$1.parameter(wrap[1], wrapModes);\n        wrapS = wrapModes[wrap[0]];\n        wrapT = wrapModes[wrap[1]];\n      }\n    } else {\n      if ('wrapS' in options) {\n        var optWrapS = options.wrapS;\n        check$1.parameter(optWrapS, wrapModes);\n        wrapS = wrapModes[optWrapS];\n      }\n      if ('wrapT' in options) {\n        var optWrapT = options.wrapT;\n        check$1.parameter(optWrapT, wrapModes);\n        wrapT = wrapModes[optWrapT];\n      }\n    }\n    info.wrapS = wrapS;\n    info.wrapT = wrapT;\n\n    if ('anisotropic' in options) {\n      var anisotropic = options.anisotropic;\n      check$1(typeof anisotropic === 'number' && anisotropic >= 1 && anisotropic <= limits.maxAnisotropic, 'aniso samples must be between 1 and ');\n      info.anisotropic = options.anisotropic;\n    }\n\n    if ('mipmap' in options) {\n      var hasMipMap = false;\n      switch (_typeof(options.mipmap)) {\n        case 'string':\n          check$1.parameter(options.mipmap, mipmapHint, 'invalid mipmap hint');\n          info.mipmapHint = mipmapHint[options.mipmap];\n          info.genMipmaps = true;\n          hasMipMap = true;\n          break;\n\n        case 'boolean':\n          hasMipMap = info.genMipmaps = options.mipmap;\n          break;\n\n        case 'object':\n          check$1(Array.isArray(options.mipmap), 'invalid mipmap type');\n          info.genMipmaps = false;\n          hasMipMap = true;\n          break;\n\n        default:\n          check$1.raise('invalid mipmap type');\n      }\n      if (hasMipMap && !('min' in options)) {\n        info.minFilter = GL_NEAREST_MIPMAP_NEAREST$1;\n      }\n    }\n  }\n\n  function setTexInfo(info, target) {\n    gl.texParameteri(target, GL_TEXTURE_MIN_FILTER, info.minFilter);\n    gl.texParameteri(target, GL_TEXTURE_MAG_FILTER, info.magFilter);\n    gl.texParameteri(target, GL_TEXTURE_WRAP_S, info.wrapS);\n    gl.texParameteri(target, GL_TEXTURE_WRAP_T, info.wrapT);\n    if (extensions.ext_texture_filter_anisotropic) {\n      gl.texParameteri(target, GL_TEXTURE_MAX_ANISOTROPY_EXT, info.anisotropic);\n    }\n    if (info.genMipmaps) {\n      gl.hint(GL_GENERATE_MIPMAP_HINT, info.mipmapHint);\n      gl.generateMipmap(target);\n    }\n  }\n\n  // -------------------------------------------------------\n  // Full texture object\n  // -------------------------------------------------------\n  var textureCount = 0;\n  var textureSet = {};\n  var numTexUnits = limits.maxTextureUnits;\n  var textureUnits = Array(numTexUnits).map(function () {\n    return null;\n  });\n\n  function REGLTexture(target) {\n    TexFlags.call(this);\n    this.mipmask = 0;\n    this.internalformat = GL_RGBA$1;\n\n    this.id = textureCount++;\n\n    this.refCount = 1;\n\n    this.target = target;\n    this.texture = gl.createTexture();\n\n    this.unit = -1;\n    this.bindCount = 0;\n\n    this.texInfo = new TexInfo();\n\n    if (config.profile) {\n      this.stats = { size: 0 };\n    }\n  }\n\n  function tempBind(texture) {\n    gl.activeTexture(GL_TEXTURE0$1);\n    gl.bindTexture(texture.target, texture.texture);\n  }\n\n  function tempRestore() {\n    var prev = textureUnits[0];\n    if (prev) {\n      gl.bindTexture(prev.target, prev.texture);\n    } else {\n      gl.bindTexture(GL_TEXTURE_2D$1, null);\n    }\n  }\n\n  function destroy(texture) {\n    var handle = texture.texture;\n    check$1(handle, 'must not double destroy texture');\n    var unit = texture.unit;\n    var target = texture.target;\n    if (unit >= 0) {\n      gl.activeTexture(GL_TEXTURE0$1 + unit);\n      gl.bindTexture(target, null);\n      textureUnits[unit] = null;\n    }\n    gl.deleteTexture(handle);\n    texture.texture = null;\n    texture.params = null;\n    texture.pixels = null;\n    texture.refCount = 0;\n    delete textureSet[texture.id];\n    stats.textureCount--;\n  }\n\n  extend(REGLTexture.prototype, {\n    bind: function bind() {\n      var texture = this;\n      texture.bindCount += 1;\n      var unit = texture.unit;\n      if (unit < 0) {\n        for (var i = 0; i < numTexUnits; ++i) {\n          var other = textureUnits[i];\n          if (other) {\n            if (other.bindCount > 0) {\n              continue;\n            }\n            other.unit = -1;\n          }\n          textureUnits[i] = texture;\n          unit = i;\n          break;\n        }\n        if (unit >= numTexUnits) {\n          check$1.raise('insufficient number of texture units');\n        }\n        if (config.profile && stats.maxTextureUnits < unit + 1) {\n          stats.maxTextureUnits = unit + 1; // +1, since the units are zero-based\n        }\n        texture.unit = unit;\n        gl.activeTexture(GL_TEXTURE0$1 + unit);\n        gl.bindTexture(texture.target, texture.texture);\n      }\n      return unit;\n    },\n\n    unbind: function unbind() {\n      this.bindCount -= 1;\n    },\n\n    decRef: function decRef() {\n      if (--this.refCount <= 0) {\n        destroy(this);\n      }\n    }\n  });\n\n  function createTexture2D(a, b) {\n    var texture = new REGLTexture(GL_TEXTURE_2D$1);\n    textureSet[texture.id] = texture;\n    stats.textureCount++;\n\n    function reglTexture2D(a, b) {\n      var texInfo = texture.texInfo;\n      TexInfo.call(texInfo);\n      var mipData = allocMipMap();\n\n      if (typeof a === 'number') {\n        if (typeof b === 'number') {\n          parseMipMapFromShape(mipData, a | 0, b | 0);\n        } else {\n          parseMipMapFromShape(mipData, a | 0, a | 0);\n        }\n      } else if (a) {\n        check$1.type(a, 'object', 'invalid arguments to regl.texture');\n        parseTexInfo(texInfo, a);\n        parseMipMapFromObject(mipData, a);\n      } else {\n        // empty textures get assigned a default shape of 1x1\n        parseMipMapFromShape(mipData, 1, 1);\n      }\n\n      if (texInfo.genMipmaps) {\n        mipData.mipmask = (mipData.width << 1) - 1;\n      }\n      texture.mipmask = mipData.mipmask;\n\n      copyFlags(texture, mipData);\n\n      check$1.texture2D(texInfo, mipData, limits);\n      texture.internalformat = mipData.internalformat;\n\n      reglTexture2D.width = mipData.width;\n      reglTexture2D.height = mipData.height;\n\n      tempBind(texture);\n      setMipMap(mipData, GL_TEXTURE_2D$1);\n      setTexInfo(texInfo, GL_TEXTURE_2D$1);\n      tempRestore();\n\n      freeMipMap(mipData);\n\n      if (config.profile) {\n        texture.stats.size = getTextureSize(texture.internalformat, texture.type, mipData.width, mipData.height, texInfo.genMipmaps, false);\n      }\n      reglTexture2D.format = textureFormatsInvert[texture.internalformat];\n      reglTexture2D.type = textureTypesInvert[texture.type];\n\n      reglTexture2D.mag = magFiltersInvert[texInfo.magFilter];\n      reglTexture2D.min = minFiltersInvert[texInfo.minFilter];\n\n      reglTexture2D.wrapS = wrapModesInvert[texInfo.wrapS];\n      reglTexture2D.wrapT = wrapModesInvert[texInfo.wrapT];\n\n      return reglTexture2D;\n    }\n\n    function subimage(image, x_, y_, level_) {\n      check$1(!!image, 'must specify image data');\n\n      var x = x_ | 0;\n      var y = y_ | 0;\n      var level = level_ | 0;\n\n      var imageData = allocImage();\n      copyFlags(imageData, texture);\n      imageData.width = 0;\n      imageData.height = 0;\n      parseImage(imageData, image);\n      imageData.width = imageData.width || (texture.width >> level) - x;\n      imageData.height = imageData.height || (texture.height >> level) - y;\n\n      check$1(texture.type === imageData.type && texture.format === imageData.format && texture.internalformat === imageData.internalformat, 'incompatible format for texture.subimage');\n      check$1(x >= 0 && y >= 0 && x + imageData.width <= texture.width && y + imageData.height <= texture.height, 'texture.subimage write out of bounds');\n      check$1(texture.mipmask & 1 << level, 'missing mipmap data');\n      check$1(imageData.data || imageData.element || imageData.needsCopy, 'missing image data');\n\n      tempBind(texture);\n      setSubImage(imageData, GL_TEXTURE_2D$1, x, y, level);\n      tempRestore();\n\n      freeImage(imageData);\n\n      return reglTexture2D;\n    }\n\n    function resize(w_, h_) {\n      var w = w_ | 0;\n      var h = h_ | 0 || w;\n      if (w === texture.width && h === texture.height) {\n        return reglTexture2D;\n      }\n\n      reglTexture2D.width = texture.width = w;\n      reglTexture2D.height = texture.height = h;\n\n      tempBind(texture);\n\n      var data;\n      var channels = texture.channels;\n      var type = texture.type;\n\n      for (var i = 0; texture.mipmask >> i; ++i) {\n        var _w = w >> i;\n        var _h = h >> i;\n        if (!_w || !_h) break;\n        data = pool.zero.allocType(type, _w * _h * channels);\n        gl.texImage2D(GL_TEXTURE_2D$1, i, texture.format, _w, _h, 0, texture.format, texture.type, data);\n        if (data) pool.zero.freeType(data);\n      }\n      tempRestore();\n\n      // also, recompute the texture size.\n      if (config.profile) {\n        texture.stats.size = getTextureSize(texture.internalformat, texture.type, w, h, false, false);\n      }\n\n      return reglTexture2D;\n    }\n\n    reglTexture2D(a, b);\n\n    reglTexture2D.subimage = subimage;\n    reglTexture2D.resize = resize;\n    reglTexture2D._reglType = 'texture2d';\n    reglTexture2D._texture = texture;\n    if (config.profile) {\n      reglTexture2D.stats = texture.stats;\n    }\n    reglTexture2D.destroy = function () {\n      texture.decRef();\n    };\n\n    return reglTexture2D;\n  }\n\n  function createTextureCube(a0, a1, a2, a3, a4, a5) {\n    var texture = new REGLTexture(GL_TEXTURE_CUBE_MAP$1);\n    textureSet[texture.id] = texture;\n    stats.cubeCount++;\n\n    var faces = new Array(6);\n\n    function reglTextureCube(a0, a1, a2, a3, a4, a5) {\n      var i;\n      var texInfo = texture.texInfo;\n      TexInfo.call(texInfo);\n      for (i = 0; i < 6; ++i) {\n        faces[i] = allocMipMap();\n      }\n\n      if (typeof a0 === 'number' || !a0) {\n        var s = a0 | 0 || 1;\n        for (i = 0; i < 6; ++i) {\n          parseMipMapFromShape(faces[i], s, s);\n        }\n      } else if ((typeof a0 === 'undefined' ? 'undefined' : _typeof(a0)) === 'object') {\n        if (a1) {\n          parseMipMapFromObject(faces[0], a0);\n          parseMipMapFromObject(faces[1], a1);\n          parseMipMapFromObject(faces[2], a2);\n          parseMipMapFromObject(faces[3], a3);\n          parseMipMapFromObject(faces[4], a4);\n          parseMipMapFromObject(faces[5], a5);\n        } else {\n          parseTexInfo(texInfo, a0);\n          parseFlags(texture, a0);\n          if ('faces' in a0) {\n            var face_input = a0.faces;\n            check$1(Array.isArray(face_input) && face_input.length === 6, 'cube faces must be a length 6 array');\n            for (i = 0; i < 6; ++i) {\n              check$1(_typeof(face_input[i]) === 'object' && !!face_input[i], 'invalid input for cube map face');\n              copyFlags(faces[i], texture);\n              parseMipMapFromObject(faces[i], face_input[i]);\n            }\n          } else {\n            for (i = 0; i < 6; ++i) {\n              parseMipMapFromObject(faces[i], a0);\n            }\n          }\n        }\n      } else {\n        check$1.raise('invalid arguments to cube map');\n      }\n\n      copyFlags(texture, faces[0]);\n\n      if (!limits.npotTextureCube) {\n        check$1(isPow2$1(texture.width) && isPow2$1(texture.height), 'your browser does not support non power or two texture dimensions');\n      }\n\n      if (texInfo.genMipmaps) {\n        texture.mipmask = (faces[0].width << 1) - 1;\n      } else {\n        texture.mipmask = faces[0].mipmask;\n      }\n\n      check$1.textureCube(texture, texInfo, faces, limits);\n      texture.internalformat = faces[0].internalformat;\n\n      reglTextureCube.width = faces[0].width;\n      reglTextureCube.height = faces[0].height;\n\n      tempBind(texture);\n      for (i = 0; i < 6; ++i) {\n        setMipMap(faces[i], GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + i);\n      }\n      setTexInfo(texInfo, GL_TEXTURE_CUBE_MAP$1);\n      tempRestore();\n\n      if (config.profile) {\n        texture.stats.size = getTextureSize(texture.internalformat, texture.type, reglTextureCube.width, reglTextureCube.height, texInfo.genMipmaps, true);\n      }\n\n      reglTextureCube.format = textureFormatsInvert[texture.internalformat];\n      reglTextureCube.type = textureTypesInvert[texture.type];\n\n      reglTextureCube.mag = magFiltersInvert[texInfo.magFilter];\n      reglTextureCube.min = minFiltersInvert[texInfo.minFilter];\n\n      reglTextureCube.wrapS = wrapModesInvert[texInfo.wrapS];\n      reglTextureCube.wrapT = wrapModesInvert[texInfo.wrapT];\n\n      for (i = 0; i < 6; ++i) {\n        freeMipMap(faces[i]);\n      }\n\n      return reglTextureCube;\n    }\n\n    function subimage(face, image, x_, y_, level_) {\n      check$1(!!image, 'must specify image data');\n      check$1(typeof face === 'number' && face === (face | 0) && face >= 0 && face < 6, 'invalid face');\n\n      var x = x_ | 0;\n      var y = y_ | 0;\n      var level = level_ | 0;\n\n      var imageData = allocImage();\n      copyFlags(imageData, texture);\n      imageData.width = 0;\n      imageData.height = 0;\n      parseImage(imageData, image);\n      imageData.width = imageData.width || (texture.width >> level) - x;\n      imageData.height = imageData.height || (texture.height >> level) - y;\n\n      check$1(texture.type === imageData.type && texture.format === imageData.format && texture.internalformat === imageData.internalformat, 'incompatible format for texture.subimage');\n      check$1(x >= 0 && y >= 0 && x + imageData.width <= texture.width && y + imageData.height <= texture.height, 'texture.subimage write out of bounds');\n      check$1(texture.mipmask & 1 << level, 'missing mipmap data');\n      check$1(imageData.data || imageData.element || imageData.needsCopy, 'missing image data');\n\n      tempBind(texture);\n      setSubImage(imageData, GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + face, x, y, level);\n      tempRestore();\n\n      freeImage(imageData);\n\n      return reglTextureCube;\n    }\n\n    function resize(radius_) {\n      var radius = radius_ | 0;\n      if (radius === texture.width) {\n        return;\n      }\n\n      reglTextureCube.width = texture.width = radius;\n      reglTextureCube.height = texture.height = radius;\n\n      tempBind(texture);\n      for (var i = 0; i < 6; ++i) {\n        for (var j = 0; texture.mipmask >> j; ++j) {\n          gl.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + i, j, texture.format, radius >> j, radius >> j, 0, texture.format, texture.type, null);\n        }\n      }\n      tempRestore();\n\n      if (config.profile) {\n        texture.stats.size = getTextureSize(texture.internalformat, texture.type, reglTextureCube.width, reglTextureCube.height, false, true);\n      }\n\n      return reglTextureCube;\n    }\n\n    reglTextureCube(a0, a1, a2, a3, a4, a5);\n\n    reglTextureCube.subimage = subimage;\n    reglTextureCube.resize = resize;\n    reglTextureCube._reglType = 'textureCube';\n    reglTextureCube._texture = texture;\n    if (config.profile) {\n      reglTextureCube.stats = texture.stats;\n    }\n    reglTextureCube.destroy = function () {\n      texture.decRef();\n    };\n\n    return reglTextureCube;\n  }\n\n  // Called when regl is destroyed\n  function destroyTextures() {\n    for (var i = 0; i < numTexUnits; ++i) {\n      gl.activeTexture(GL_TEXTURE0$1 + i);\n      gl.bindTexture(GL_TEXTURE_2D$1, null);\n      textureUnits[i] = null;\n    }\n    values(textureSet).forEach(destroy);\n\n    stats.cubeCount = 0;\n    stats.textureCount = 0;\n  }\n\n  if (config.profile) {\n    stats.getTotalTextureSize = function () {\n      var total = 0;\n      Object.keys(textureSet).forEach(function (key) {\n        total += textureSet[key].stats.size;\n      });\n      return total;\n    };\n  }\n\n  function restoreTextures() {\n    values(textureSet).forEach(function (texture) {\n      texture.texture = gl.createTexture();\n      gl.bindTexture(texture.target, texture.texture);\n      for (var i = 0; i < 32; ++i) {\n        if ((texture.mipmask & 1 << i) === 0) {\n          continue;\n        }\n        if (texture.target === GL_TEXTURE_2D$1) {\n          gl.texImage2D(GL_TEXTURE_2D$1, i, texture.internalformat, texture.width >> i, texture.height >> i, 0, texture.internalformat, texture.type, null);\n        } else {\n          for (var j = 0; j < 6; ++j) {\n            gl.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + j, i, texture.internalformat, texture.width >> i, texture.height >> i, 0, texture.internalformat, texture.type, null);\n          }\n        }\n      }\n      setTexInfo(texture.texInfo, texture.target);\n    });\n  }\n\n  return {\n    create2D: createTexture2D,\n    createCube: createTextureCube,\n    clear: destroyTextures,\n    getTexture: function getTexture(wrapper) {\n      return null;\n    },\n    restore: restoreTextures\n  };\n}\n\nvar GL_RENDERBUFFER = 0x8D41;\n\nvar GL_RGBA4$1 = 0x8056;\nvar GL_RGB5_A1$1 = 0x8057;\nvar GL_RGB565$1 = 0x8D62;\nvar GL_DEPTH_COMPONENT16 = 0x81A5;\nvar GL_STENCIL_INDEX8 = 0x8D48;\nvar GL_DEPTH_STENCIL$1 = 0x84F9;\n\nvar GL_SRGB8_ALPHA8_EXT = 0x8C43;\n\nvar GL_RGBA32F_EXT = 0x8814;\n\nvar GL_RGBA16F_EXT = 0x881A;\nvar GL_RGB16F_EXT = 0x881B;\n\nvar FORMAT_SIZES = [];\n\nFORMAT_SIZES[GL_RGBA4$1] = 2;\nFORMAT_SIZES[GL_RGB5_A1$1] = 2;\nFORMAT_SIZES[GL_RGB565$1] = 2;\n\nFORMAT_SIZES[GL_DEPTH_COMPONENT16] = 2;\nFORMAT_SIZES[GL_STENCIL_INDEX8] = 1;\nFORMAT_SIZES[GL_DEPTH_STENCIL$1] = 4;\n\nFORMAT_SIZES[GL_SRGB8_ALPHA8_EXT] = 4;\nFORMAT_SIZES[GL_RGBA32F_EXT] = 16;\nFORMAT_SIZES[GL_RGBA16F_EXT] = 8;\nFORMAT_SIZES[GL_RGB16F_EXT] = 6;\n\nfunction getRenderbufferSize(format, width, height) {\n  return FORMAT_SIZES[format] * width * height;\n}\n\nvar wrapRenderbuffers = function wrapRenderbuffers(gl, extensions, limits, stats, config) {\n  var formatTypes = {\n    'rgba4': GL_RGBA4$1,\n    'rgb565': GL_RGB565$1,\n    'rgb5 a1': GL_RGB5_A1$1,\n    'depth': GL_DEPTH_COMPONENT16,\n    'stencil': GL_STENCIL_INDEX8,\n    'depth stencil': GL_DEPTH_STENCIL$1\n  };\n\n  if (extensions.ext_srgb) {\n    formatTypes['srgba'] = GL_SRGB8_ALPHA8_EXT;\n  }\n\n  if (extensions.ext_color_buffer_half_float) {\n    formatTypes['rgba16f'] = GL_RGBA16F_EXT;\n    formatTypes['rgb16f'] = GL_RGB16F_EXT;\n  }\n\n  if (extensions.webgl_color_buffer_float) {\n    formatTypes['rgba32f'] = GL_RGBA32F_EXT;\n  }\n\n  var formatTypesInvert = [];\n  Object.keys(formatTypes).forEach(function (key) {\n    var val = formatTypes[key];\n    formatTypesInvert[val] = key;\n  });\n\n  var renderbufferCount = 0;\n  var renderbufferSet = {};\n\n  function REGLRenderbuffer(renderbuffer) {\n    this.id = renderbufferCount++;\n    this.refCount = 1;\n\n    this.renderbuffer = renderbuffer;\n\n    this.format = GL_RGBA4$1;\n    this.width = 0;\n    this.height = 0;\n\n    if (config.profile) {\n      this.stats = { size: 0 };\n    }\n  }\n\n  REGLRenderbuffer.prototype.decRef = function () {\n    if (--this.refCount <= 0) {\n      destroy(this);\n    }\n  };\n\n  function destroy(rb) {\n    var handle = rb.renderbuffer;\n    check$1(handle, 'must not double destroy renderbuffer');\n    gl.bindRenderbuffer(GL_RENDERBUFFER, null);\n    gl.deleteRenderbuffer(handle);\n    rb.renderbuffer = null;\n    rb.refCount = 0;\n    delete renderbufferSet[rb.id];\n    stats.renderbufferCount--;\n  }\n\n  function createRenderbuffer(a, b) {\n    var renderbuffer = new REGLRenderbuffer(gl.createRenderbuffer());\n    renderbufferSet[renderbuffer.id] = renderbuffer;\n    stats.renderbufferCount++;\n\n    function reglRenderbuffer(a, b) {\n      var w = 0;\n      var h = 0;\n      var format = GL_RGBA4$1;\n\n      if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) === 'object' && a) {\n        var options = a;\n        if ('shape' in options) {\n          var shape = options.shape;\n          check$1(Array.isArray(shape) && shape.length >= 2, 'invalid renderbuffer shape');\n          w = shape[0] | 0;\n          h = shape[1] | 0;\n        } else {\n          if ('radius' in options) {\n            w = h = options.radius | 0;\n          }\n          if ('width' in options) {\n            w = options.width | 0;\n          }\n          if ('height' in options) {\n            h = options.height | 0;\n          }\n        }\n        if ('format' in options) {\n          check$1.parameter(options.format, formatTypes, 'invalid renderbuffer format');\n          format = formatTypes[options.format];\n        }\n      } else if (typeof a === 'number') {\n        w = a | 0;\n        if (typeof b === 'number') {\n          h = b | 0;\n        } else {\n          h = w;\n        }\n      } else if (!a) {\n        w = h = 1;\n      } else {\n        check$1.raise('invalid arguments to renderbuffer constructor');\n      }\n\n      // check shape\n      check$1(w > 0 && h > 0 && w <= limits.maxRenderbufferSize && h <= limits.maxRenderbufferSize, 'invalid renderbuffer size');\n\n      if (w === renderbuffer.width && h === renderbuffer.height && format === renderbuffer.format) {\n        return;\n      }\n\n      reglRenderbuffer.width = renderbuffer.width = w;\n      reglRenderbuffer.height = renderbuffer.height = h;\n      renderbuffer.format = format;\n\n      gl.bindRenderbuffer(GL_RENDERBUFFER, renderbuffer.renderbuffer);\n      gl.renderbufferStorage(GL_RENDERBUFFER, format, w, h);\n\n      check$1(gl.getError() === 0, 'invalid render buffer format');\n\n      if (config.profile) {\n        renderbuffer.stats.size = getRenderbufferSize(renderbuffer.format, renderbuffer.width, renderbuffer.height);\n      }\n      reglRenderbuffer.format = formatTypesInvert[renderbuffer.format];\n\n      return reglRenderbuffer;\n    }\n\n    function resize(w_, h_) {\n      var w = w_ | 0;\n      var h = h_ | 0 || w;\n\n      if (w === renderbuffer.width && h === renderbuffer.height) {\n        return reglRenderbuffer;\n      }\n\n      // check shape\n      check$1(w > 0 && h > 0 && w <= limits.maxRenderbufferSize && h <= limits.maxRenderbufferSize, 'invalid renderbuffer size');\n\n      reglRenderbuffer.width = renderbuffer.width = w;\n      reglRenderbuffer.height = renderbuffer.height = h;\n\n      gl.bindRenderbuffer(GL_RENDERBUFFER, renderbuffer.renderbuffer);\n      gl.renderbufferStorage(GL_RENDERBUFFER, renderbuffer.format, w, h);\n\n      check$1(gl.getError() === 0, 'invalid render buffer format');\n\n      // also, recompute size.\n      if (config.profile) {\n        renderbuffer.stats.size = getRenderbufferSize(renderbuffer.format, renderbuffer.width, renderbuffer.height);\n      }\n\n      return reglRenderbuffer;\n    }\n\n    reglRenderbuffer(a, b);\n\n    reglRenderbuffer.resize = resize;\n    reglRenderbuffer._reglType = 'renderbuffer';\n    reglRenderbuffer._renderbuffer = renderbuffer;\n    if (config.profile) {\n      reglRenderbuffer.stats = renderbuffer.stats;\n    }\n    reglRenderbuffer.destroy = function () {\n      renderbuffer.decRef();\n    };\n\n    return reglRenderbuffer;\n  }\n\n  if (config.profile) {\n    stats.getTotalRenderbufferSize = function () {\n      var total = 0;\n      Object.keys(renderbufferSet).forEach(function (key) {\n        total += renderbufferSet[key].stats.size;\n      });\n      return total;\n    };\n  }\n\n  function restoreRenderbuffers() {\n    values(renderbufferSet).forEach(function (rb) {\n      rb.renderbuffer = gl.createRenderbuffer();\n      gl.bindRenderbuffer(GL_RENDERBUFFER, rb.renderbuffer);\n      gl.renderbufferStorage(GL_RENDERBUFFER, rb.format, rb.width, rb.height);\n    });\n    gl.bindRenderbuffer(GL_RENDERBUFFER, null);\n  }\n\n  return {\n    create: createRenderbuffer,\n    clear: function clear() {\n      values(renderbufferSet).forEach(destroy);\n    },\n    restore: restoreRenderbuffers\n  };\n};\n\n// We store these constants so that the minifier can inline them\nvar GL_FRAMEBUFFER$1 = 0x8D40;\nvar GL_RENDERBUFFER$1 = 0x8D41;\n\nvar GL_TEXTURE_2D$2 = 0x0DE1;\nvar GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 = 0x8515;\n\nvar GL_COLOR_ATTACHMENT0$1 = 0x8CE0;\nvar GL_DEPTH_ATTACHMENT = 0x8D00;\nvar GL_STENCIL_ATTACHMENT = 0x8D20;\nvar GL_DEPTH_STENCIL_ATTACHMENT = 0x821A;\n\nvar GL_FRAMEBUFFER_COMPLETE$1 = 0x8CD5;\nvar GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 0x8CD6;\nvar GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7;\nvar GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 0x8CD9;\nvar GL_FRAMEBUFFER_UNSUPPORTED = 0x8CDD;\n\nvar GL_HALF_FLOAT_OES$2 = 0x8D61;\nvar GL_UNSIGNED_BYTE$6 = 0x1401;\nvar GL_FLOAT$5 = 0x1406;\n\nvar GL_RGB$1 = 0x1907;\nvar GL_RGBA$2 = 0x1908;\n\nvar GL_DEPTH_COMPONENT$1 = 0x1902;\n\nvar colorTextureFormatEnums = [GL_RGB$1, GL_RGBA$2];\n\n// for every texture format, store\n// the number of channels\nvar textureFormatChannels = [];\ntextureFormatChannels[GL_RGBA$2] = 4;\ntextureFormatChannels[GL_RGB$1] = 3;\n\n// for every texture type, store\n// the size in bytes.\nvar textureTypeSizes = [];\ntextureTypeSizes[GL_UNSIGNED_BYTE$6] = 1;\ntextureTypeSizes[GL_FLOAT$5] = 4;\ntextureTypeSizes[GL_HALF_FLOAT_OES$2] = 2;\n\nvar GL_RGBA4$2 = 0x8056;\nvar GL_RGB5_A1$2 = 0x8057;\nvar GL_RGB565$2 = 0x8D62;\nvar GL_DEPTH_COMPONENT16$1 = 0x81A5;\nvar GL_STENCIL_INDEX8$1 = 0x8D48;\nvar GL_DEPTH_STENCIL$2 = 0x84F9;\n\nvar GL_SRGB8_ALPHA8_EXT$1 = 0x8C43;\n\nvar GL_RGBA32F_EXT$1 = 0x8814;\n\nvar GL_RGBA16F_EXT$1 = 0x881A;\nvar GL_RGB16F_EXT$1 = 0x881B;\n\nvar colorRenderbufferFormatEnums = [GL_RGBA4$2, GL_RGB5_A1$2, GL_RGB565$2, GL_SRGB8_ALPHA8_EXT$1, GL_RGBA16F_EXT$1, GL_RGB16F_EXT$1, GL_RGBA32F_EXT$1];\n\nvar statusCode = {};\nstatusCode[GL_FRAMEBUFFER_COMPLETE$1] = 'complete';\nstatusCode[GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT] = 'incomplete attachment';\nstatusCode[GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS] = 'incomplete dimensions';\nstatusCode[GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT] = 'incomplete, missing attachment';\nstatusCode[GL_FRAMEBUFFER_UNSUPPORTED] = 'unsupported';\n\nfunction wrapFBOState(gl, extensions, limits, textureState, renderbufferState, stats) {\n  var framebufferState = {\n    cur: null,\n    next: null,\n    dirty: false,\n    setFBO: null\n  };\n\n  var colorTextureFormats = ['rgba'];\n  var colorRenderbufferFormats = ['rgba4', 'rgb565', 'rgb5 a1'];\n\n  if (extensions.ext_srgb) {\n    colorRenderbufferFormats.push('srgba');\n  }\n\n  if (extensions.ext_color_buffer_half_float) {\n    colorRenderbufferFormats.push('rgba16f', 'rgb16f');\n  }\n\n  if (extensions.webgl_color_buffer_float) {\n    colorRenderbufferFormats.push('rgba32f');\n  }\n\n  var colorTypes = ['uint8'];\n  if (extensions.oes_texture_half_float) {\n    colorTypes.push('half float', 'float16');\n  }\n  if (extensions.oes_texture_float) {\n    colorTypes.push('float', 'float32');\n  }\n\n  function FramebufferAttachment(target, texture, renderbuffer) {\n    this.target = target;\n    this.texture = texture;\n    this.renderbuffer = renderbuffer;\n\n    var w = 0;\n    var h = 0;\n    if (texture) {\n      w = texture.width;\n      h = texture.height;\n    } else if (renderbuffer) {\n      w = renderbuffer.width;\n      h = renderbuffer.height;\n    }\n    this.width = w;\n    this.height = h;\n  }\n\n  function decRef(attachment) {\n    if (attachment) {\n      if (attachment.texture) {\n        attachment.texture._texture.decRef();\n      }\n      if (attachment.renderbuffer) {\n        attachment.renderbuffer._renderbuffer.decRef();\n      }\n    }\n  }\n\n  function incRefAndCheckShape(attachment, width, height) {\n    if (!attachment) {\n      return;\n    }\n    if (attachment.texture) {\n      var texture = attachment.texture._texture;\n      var tw = Math.max(1, texture.width);\n      var th = Math.max(1, texture.height);\n      check$1(tw === width && th === height, 'inconsistent width/height for supplied texture');\n      texture.refCount += 1;\n    } else {\n      var renderbuffer = attachment.renderbuffer._renderbuffer;\n      check$1(renderbuffer.width === width && renderbuffer.height === height, 'inconsistent width/height for renderbuffer');\n      renderbuffer.refCount += 1;\n    }\n  }\n\n  function attach(location, attachment) {\n    if (attachment) {\n      if (attachment.texture) {\n        gl.framebufferTexture2D(GL_FRAMEBUFFER$1, location, attachment.target, attachment.texture._texture.texture, 0);\n      } else {\n        gl.framebufferRenderbuffer(GL_FRAMEBUFFER$1, location, GL_RENDERBUFFER$1, attachment.renderbuffer._renderbuffer.renderbuffer);\n      }\n    }\n  }\n\n  function parseAttachment(attachment) {\n    var target = GL_TEXTURE_2D$2;\n    var texture = null;\n    var renderbuffer = null;\n\n    var data = attachment;\n    if ((typeof attachment === 'undefined' ? 'undefined' : _typeof(attachment)) === 'object') {\n      data = attachment.data;\n      if ('target' in attachment) {\n        target = attachment.target | 0;\n      }\n    }\n\n    check$1.type(data, 'function', 'invalid attachment data');\n\n    var type = data._reglType;\n    if (type === 'texture2d') {\n      texture = data;\n      check$1(target === GL_TEXTURE_2D$2);\n    } else if (type === 'textureCube') {\n      texture = data;\n      check$1(target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 && target < GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 + 6, 'invalid cube map target');\n    } else if (type === 'renderbuffer') {\n      renderbuffer = data;\n      target = GL_RENDERBUFFER$1;\n    } else {\n      check$1.raise('invalid regl object for attachment');\n    }\n\n    return new FramebufferAttachment(target, texture, renderbuffer);\n  }\n\n  function allocAttachment(width, height, isTexture, format, type) {\n    if (isTexture) {\n      var texture = textureState.create2D({\n        width: width,\n        height: height,\n        format: format,\n        type: type\n      });\n      texture._texture.refCount = 0;\n      return new FramebufferAttachment(GL_TEXTURE_2D$2, texture, null);\n    } else {\n      var rb = renderbufferState.create({\n        width: width,\n        height: height,\n        format: format\n      });\n      rb._renderbuffer.refCount = 0;\n      return new FramebufferAttachment(GL_RENDERBUFFER$1, null, rb);\n    }\n  }\n\n  function unwrapAttachment(attachment) {\n    return attachment && (attachment.texture || attachment.renderbuffer);\n  }\n\n  function resizeAttachment(attachment, w, h) {\n    if (attachment) {\n      if (attachment.texture) {\n        attachment.texture.resize(w, h);\n      } else if (attachment.renderbuffer) {\n        attachment.renderbuffer.resize(w, h);\n      }\n    }\n  }\n\n  var framebufferCount = 0;\n  var framebufferSet = {};\n\n  function REGLFramebuffer() {\n    this.id = framebufferCount++;\n    framebufferSet[this.id] = this;\n\n    this.framebuffer = gl.createFramebuffer();\n    this.width = 0;\n    this.height = 0;\n\n    this.colorAttachments = [];\n    this.depthAttachment = null;\n    this.stencilAttachment = null;\n    this.depthStencilAttachment = null;\n  }\n\n  function decFBORefs(framebuffer) {\n    framebuffer.colorAttachments.forEach(decRef);\n    decRef(framebuffer.depthAttachment);\n    decRef(framebuffer.stencilAttachment);\n    decRef(framebuffer.depthStencilAttachment);\n  }\n\n  function _destroy(framebuffer) {\n    var handle = framebuffer.framebuffer;\n    check$1(handle, 'must not double destroy framebuffer');\n    gl.deleteFramebuffer(handle);\n    framebuffer.framebuffer = null;\n    stats.framebufferCount--;\n    delete framebufferSet[framebuffer.id];\n  }\n\n  function updateFramebuffer(framebuffer) {\n    var i;\n\n    gl.bindFramebuffer(GL_FRAMEBUFFER$1, framebuffer.framebuffer);\n    var colorAttachments = framebuffer.colorAttachments;\n    for (i = 0; i < colorAttachments.length; ++i) {\n      attach(GL_COLOR_ATTACHMENT0$1 + i, colorAttachments[i]);\n    }\n    for (i = colorAttachments.length; i < limits.maxColorAttachments; ++i) {\n      gl.framebufferTexture2D(GL_FRAMEBUFFER$1, GL_COLOR_ATTACHMENT0$1 + i, GL_TEXTURE_2D$2, null, 0);\n    }\n\n    gl.framebufferTexture2D(GL_FRAMEBUFFER$1, GL_DEPTH_STENCIL_ATTACHMENT, GL_TEXTURE_2D$2, null, 0);\n    gl.framebufferTexture2D(GL_FRAMEBUFFER$1, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D$2, null, 0);\n    gl.framebufferTexture2D(GL_FRAMEBUFFER$1, GL_STENCIL_ATTACHMENT, GL_TEXTURE_2D$2, null, 0);\n\n    attach(GL_DEPTH_ATTACHMENT, framebuffer.depthAttachment);\n    attach(GL_STENCIL_ATTACHMENT, framebuffer.stencilAttachment);\n    attach(GL_DEPTH_STENCIL_ATTACHMENT, framebuffer.depthStencilAttachment);\n\n    // Check status code\n    var status = gl.checkFramebufferStatus(GL_FRAMEBUFFER$1);\n    if (status !== GL_FRAMEBUFFER_COMPLETE$1) {\n      check$1.raise('framebuffer configuration not supported, status = ' + statusCode[status]);\n    }\n\n    gl.bindFramebuffer(GL_FRAMEBUFFER$1, framebufferState.next ? framebufferState.next.framebuffer : null);\n    framebufferState.cur = framebufferState.next;\n\n    // FIXME: Clear error code here.  This is a work around for a bug in\n    // headless-gl\n    gl.getError();\n  }\n\n  function createFBO(a0, a1) {\n    var framebuffer = new REGLFramebuffer();\n    stats.framebufferCount++;\n\n    function reglFramebuffer(a, b) {\n      var i;\n\n      check$1(framebufferState.next !== framebuffer, 'can not update framebuffer which is currently in use');\n\n      var extDrawBuffers = extensions.webgl_draw_buffers;\n\n      var width = 0;\n      var height = 0;\n\n      var needsDepth = true;\n      var needsStencil = true;\n\n      var colorBuffer = null;\n      var colorTexture = true;\n      var colorFormat = 'rgba';\n      var colorType = 'uint8';\n      var colorCount = 1;\n\n      var depthBuffer = null;\n      var stencilBuffer = null;\n      var depthStencilBuffer = null;\n      var depthStencilTexture = false;\n\n      if (typeof a === 'number') {\n        width = a | 0;\n        height = b | 0 || width;\n      } else if (!a) {\n        width = height = 1;\n      } else {\n        check$1.type(a, 'object', 'invalid arguments for framebuffer');\n        var options = a;\n\n        if ('shape' in options) {\n          var shape = options.shape;\n          check$1(Array.isArray(shape) && shape.length >= 2, 'invalid shape for framebuffer');\n          width = shape[0];\n          height = shape[1];\n        } else {\n          if ('radius' in options) {\n            width = height = options.radius;\n          }\n          if ('width' in options) {\n            width = options.width;\n          }\n          if ('height' in options) {\n            height = options.height;\n          }\n        }\n\n        if ('color' in options || 'colors' in options) {\n          colorBuffer = options.color || options.colors;\n          if (Array.isArray(colorBuffer)) {\n            check$1(colorBuffer.length === 1 || extDrawBuffers, 'multiple render targets not supported');\n          }\n        }\n\n        if (!colorBuffer) {\n          if ('colorCount' in options) {\n            colorCount = options.colorCount | 0;\n            check$1(colorCount > 0, 'invalid color buffer count');\n          }\n\n          if ('colorTexture' in options) {\n            colorTexture = !!options.colorTexture;\n            colorFormat = 'rgba4';\n          }\n\n          if ('colorType' in options) {\n            colorType = options.colorType;\n            if (!colorTexture) {\n              if (colorType === 'half float' || colorType === 'float16') {\n                check$1(extensions.ext_color_buffer_half_float, 'you must enable EXT_color_buffer_half_float to use 16-bit render buffers');\n                colorFormat = 'rgba16f';\n              } else if (colorType === 'float' || colorType === 'float32') {\n                check$1(extensions.webgl_color_buffer_float, 'you must enable WEBGL_color_buffer_float in order to use 32-bit floating point renderbuffers');\n                colorFormat = 'rgba32f';\n              }\n            } else {\n              check$1(extensions.oes_texture_float || !(colorType === 'float' || colorType === 'float32'), 'you must enable OES_texture_float in order to use floating point framebuffer objects');\n              check$1(extensions.oes_texture_half_float || !(colorType === 'half float' || colorType === 'float16'), 'you must enable OES_texture_half_float in order to use 16-bit floating point framebuffer objects');\n            }\n            check$1.oneOf(colorType, colorTypes, 'invalid color type');\n          }\n\n          if ('colorFormat' in options) {\n            colorFormat = options.colorFormat;\n            if (colorTextureFormats.indexOf(colorFormat) >= 0) {\n              colorTexture = true;\n            } else if (colorRenderbufferFormats.indexOf(colorFormat) >= 0) {\n              colorTexture = false;\n            } else {\n              if (colorTexture) {\n                check$1.oneOf(options.colorFormat, colorTextureFormats, 'invalid color format for texture');\n              } else {\n                check$1.oneOf(options.colorFormat, colorRenderbufferFormats, 'invalid color format for renderbuffer');\n              }\n            }\n          }\n        }\n\n        if ('depthTexture' in options || 'depthStencilTexture' in options) {\n          depthStencilTexture = !!(options.depthTexture || options.depthStencilTexture);\n          check$1(!depthStencilTexture || extensions.webgl_depth_texture, 'webgl_depth_texture extension not supported');\n        }\n\n        if ('depth' in options) {\n          if (typeof options.depth === 'boolean') {\n            needsDepth = options.depth;\n          } else {\n            depthBuffer = options.depth;\n            needsStencil = false;\n          }\n        }\n\n        if ('stencil' in options) {\n          if (typeof options.stencil === 'boolean') {\n            needsStencil = options.stencil;\n          } else {\n            stencilBuffer = options.stencil;\n            needsDepth = false;\n          }\n        }\n\n        if ('depthStencil' in options) {\n          if (typeof options.depthStencil === 'boolean') {\n            needsDepth = needsStencil = options.depthStencil;\n          } else {\n            depthStencilBuffer = options.depthStencil;\n            needsDepth = false;\n            needsStencil = false;\n          }\n        }\n      }\n\n      // parse attachments\n      var colorAttachments = null;\n      var depthAttachment = null;\n      var stencilAttachment = null;\n      var depthStencilAttachment = null;\n\n      // Set up color attachments\n      if (Array.isArray(colorBuffer)) {\n        colorAttachments = colorBuffer.map(parseAttachment);\n      } else if (colorBuffer) {\n        colorAttachments = [parseAttachment(colorBuffer)];\n      } else {\n        colorAttachments = new Array(colorCount);\n        for (i = 0; i < colorCount; ++i) {\n          colorAttachments[i] = allocAttachment(width, height, colorTexture, colorFormat, colorType);\n        }\n      }\n\n      check$1(extensions.webgl_draw_buffers || colorAttachments.length <= 1, 'you must enable the WEBGL_draw_buffers extension in order to use multiple color buffers.');\n      check$1(colorAttachments.length <= limits.maxColorAttachments, 'too many color attachments, not supported');\n\n      width = width || colorAttachments[0].width;\n      height = height || colorAttachments[0].height;\n\n      if (depthBuffer) {\n        depthAttachment = parseAttachment(depthBuffer);\n      } else if (needsDepth && !needsStencil) {\n        depthAttachment = allocAttachment(width, height, depthStencilTexture, 'depth', 'uint32');\n      }\n\n      if (stencilBuffer) {\n        stencilAttachment = parseAttachment(stencilBuffer);\n      } else if (needsStencil && !needsDepth) {\n        stencilAttachment = allocAttachment(width, height, false, 'stencil', 'uint8');\n      }\n\n      if (depthStencilBuffer) {\n        depthStencilAttachment = parseAttachment(depthStencilBuffer);\n      } else if (!depthBuffer && !stencilBuffer && needsStencil && needsDepth) {\n        depthStencilAttachment = allocAttachment(width, height, depthStencilTexture, 'depth stencil', 'depth stencil');\n      }\n\n      check$1(!!depthBuffer + !!stencilBuffer + !!depthStencilBuffer <= 1, 'invalid framebuffer configuration, can specify exactly one depth/stencil attachment');\n\n      var commonColorAttachmentSize = null;\n\n      for (i = 0; i < colorAttachments.length; ++i) {\n        incRefAndCheckShape(colorAttachments[i], width, height);\n        check$1(!colorAttachments[i] || colorAttachments[i].texture && colorTextureFormatEnums.indexOf(colorAttachments[i].texture._texture.format) >= 0 || colorAttachments[i].renderbuffer && colorRenderbufferFormatEnums.indexOf(colorAttachments[i].renderbuffer._renderbuffer.format) >= 0, 'framebuffer color attachment ' + i + ' is invalid');\n\n        if (colorAttachments[i] && colorAttachments[i].texture) {\n          var colorAttachmentSize = textureFormatChannels[colorAttachments[i].texture._texture.format] * textureTypeSizes[colorAttachments[i].texture._texture.type];\n\n          if (commonColorAttachmentSize === null) {\n            commonColorAttachmentSize = colorAttachmentSize;\n          } else {\n            // We need to make sure that all color attachments have the same number of bitplanes\n            // (that is, the same numer of bits per pixel)\n            // This is required by the GLES2.0 standard. See the beginning of Chapter 4 in that document.\n            check$1(commonColorAttachmentSize === colorAttachmentSize, 'all color attachments much have the same number of bits per pixel.');\n          }\n        }\n      }\n      incRefAndCheckShape(depthAttachment, width, height);\n      check$1(!depthAttachment || depthAttachment.texture && depthAttachment.texture._texture.format === GL_DEPTH_COMPONENT$1 || depthAttachment.renderbuffer && depthAttachment.renderbuffer._renderbuffer.format === GL_DEPTH_COMPONENT16$1, 'invalid depth attachment for framebuffer object');\n      incRefAndCheckShape(stencilAttachment, width, height);\n      check$1(!stencilAttachment || stencilAttachment.renderbuffer && stencilAttachment.renderbuffer._renderbuffer.format === GL_STENCIL_INDEX8$1, 'invalid stencil attachment for framebuffer object');\n      incRefAndCheckShape(depthStencilAttachment, width, height);\n      check$1(!depthStencilAttachment || depthStencilAttachment.texture && depthStencilAttachment.texture._texture.format === GL_DEPTH_STENCIL$2 || depthStencilAttachment.renderbuffer && depthStencilAttachment.renderbuffer._renderbuffer.format === GL_DEPTH_STENCIL$2, 'invalid depth-stencil attachment for framebuffer object');\n\n      // decrement references\n      decFBORefs(framebuffer);\n\n      framebuffer.width = width;\n      framebuffer.height = height;\n\n      framebuffer.colorAttachments = colorAttachments;\n      framebuffer.depthAttachment = depthAttachment;\n      framebuffer.stencilAttachment = stencilAttachment;\n      framebuffer.depthStencilAttachment = depthStencilAttachment;\n\n      reglFramebuffer.color = colorAttachments.map(unwrapAttachment);\n      reglFramebuffer.depth = unwrapAttachment(depthAttachment);\n      reglFramebuffer.stencil = unwrapAttachment(stencilAttachment);\n      reglFramebuffer.depthStencil = unwrapAttachment(depthStencilAttachment);\n\n      reglFramebuffer.width = framebuffer.width;\n      reglFramebuffer.height = framebuffer.height;\n\n      updateFramebuffer(framebuffer);\n\n      return reglFramebuffer;\n    }\n\n    function resize(w_, h_) {\n      check$1(framebufferState.next !== framebuffer, 'can not resize a framebuffer which is currently in use');\n\n      var w = w_ | 0;\n      var h = h_ | 0 || w;\n      if (w === framebuffer.width && h === framebuffer.height) {\n        return reglFramebuffer;\n      }\n\n      // resize all buffers\n      var colorAttachments = framebuffer.colorAttachments;\n      for (var i = 0; i < colorAttachments.length; ++i) {\n        resizeAttachment(colorAttachments[i], w, h);\n      }\n      resizeAttachment(framebuffer.depthAttachment, w, h);\n      resizeAttachment(framebuffer.stencilAttachment, w, h);\n      resizeAttachment(framebuffer.depthStencilAttachment, w, h);\n\n      framebuffer.width = reglFramebuffer.width = w;\n      framebuffer.height = reglFramebuffer.height = h;\n\n      updateFramebuffer(framebuffer);\n\n      return reglFramebuffer;\n    }\n\n    reglFramebuffer(a0, a1);\n\n    return extend(reglFramebuffer, {\n      resize: resize,\n      _reglType: 'framebuffer',\n      _framebuffer: framebuffer,\n      destroy: function destroy() {\n        _destroy(framebuffer);\n        decFBORefs(framebuffer);\n      },\n      use: function use(block) {\n        framebufferState.setFBO({\n          framebuffer: reglFramebuffer\n        }, block);\n      }\n    });\n  }\n\n  function createCubeFBO(options) {\n    var faces = Array(6);\n\n    function reglFramebufferCube(a) {\n      var i;\n\n      check$1(faces.indexOf(framebufferState.next) < 0, 'can not update framebuffer which is currently in use');\n\n      var extDrawBuffers = extensions.webgl_draw_buffers;\n\n      var params = {\n        color: null\n      };\n\n      var radius = 0;\n\n      var colorBuffer = null;\n      var colorFormat = 'rgba';\n      var colorType = 'uint8';\n      var colorCount = 1;\n\n      if (typeof a === 'number') {\n        radius = a | 0;\n      } else if (!a) {\n        radius = 1;\n      } else {\n        check$1.type(a, 'object', 'invalid arguments for framebuffer');\n        var options = a;\n\n        if ('shape' in options) {\n          var shape = options.shape;\n          check$1(Array.isArray(shape) && shape.length >= 2, 'invalid shape for framebuffer');\n          check$1(shape[0] === shape[1], 'cube framebuffer must be square');\n          radius = shape[0];\n        } else {\n          if ('radius' in options) {\n            radius = options.radius | 0;\n          }\n          if ('width' in options) {\n            radius = options.width | 0;\n            if ('height' in options) {\n              check$1(options.height === radius, 'must be square');\n            }\n          } else if ('height' in options) {\n            radius = options.height | 0;\n          }\n        }\n\n        if ('color' in options || 'colors' in options) {\n          colorBuffer = options.color || options.colors;\n          if (Array.isArray(colorBuffer)) {\n            check$1(colorBuffer.length === 1 || extDrawBuffers, 'multiple render targets not supported');\n          }\n        }\n\n        if (!colorBuffer) {\n          if ('colorCount' in options) {\n            colorCount = options.colorCount | 0;\n            check$1(colorCount > 0, 'invalid color buffer count');\n          }\n\n          if ('colorType' in options) {\n            check$1.oneOf(options.colorType, colorTypes, 'invalid color type');\n            colorType = options.colorType;\n          }\n\n          if ('colorFormat' in options) {\n            colorFormat = options.colorFormat;\n            check$1.oneOf(options.colorFormat, colorTextureFormats, 'invalid color format for texture');\n          }\n        }\n\n        if ('depth' in options) {\n          params.depth = options.depth;\n        }\n\n        if ('stencil' in options) {\n          params.stencil = options.stencil;\n        }\n\n        if ('depthStencil' in options) {\n          params.depthStencil = options.depthStencil;\n        }\n      }\n\n      var colorCubes;\n      if (colorBuffer) {\n        if (Array.isArray(colorBuffer)) {\n          colorCubes = [];\n          for (i = 0; i < colorBuffer.length; ++i) {\n            colorCubes[i] = colorBuffer[i];\n          }\n        } else {\n          colorCubes = [colorBuffer];\n        }\n      } else {\n        colorCubes = Array(colorCount);\n        var cubeMapParams = {\n          radius: radius,\n          format: colorFormat,\n          type: colorType\n        };\n        for (i = 0; i < colorCount; ++i) {\n          colorCubes[i] = textureState.createCube(cubeMapParams);\n        }\n      }\n\n      // Check color cubes\n      params.color = Array(colorCubes.length);\n      for (i = 0; i < colorCubes.length; ++i) {\n        var cube = colorCubes[i];\n        check$1(typeof cube === 'function' && cube._reglType === 'textureCube', 'invalid cube map');\n        radius = radius || cube.width;\n        check$1(cube.width === radius && cube.height === radius, 'invalid cube map shape');\n        params.color[i] = {\n          target: GL_TEXTURE_CUBE_MAP_POSITIVE_X$2,\n          data: colorCubes[i]\n        };\n      }\n\n      for (i = 0; i < 6; ++i) {\n        for (var j = 0; j < colorCubes.length; ++j) {\n          params.color[j].target = GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 + i;\n        }\n        // reuse depth-stencil attachments across all cube maps\n        if (i > 0) {\n          params.depth = faces[0].depth;\n          params.stencil = faces[0].stencil;\n          params.depthStencil = faces[0].depthStencil;\n        }\n        if (faces[i]) {\n          faces[i](params);\n        } else {\n          faces[i] = createFBO(params);\n        }\n      }\n\n      return extend(reglFramebufferCube, {\n        width: radius,\n        height: radius,\n        color: colorCubes\n      });\n    }\n\n    function resize(radius_) {\n      var i;\n      var radius = radius_ | 0;\n      check$1(radius > 0 && radius <= limits.maxCubeMapSize, 'invalid radius for cube fbo');\n\n      if (radius === reglFramebufferCube.width) {\n        return reglFramebufferCube;\n      }\n\n      var colors = reglFramebufferCube.color;\n      for (i = 0; i < colors.length; ++i) {\n        colors[i].resize(radius);\n      }\n\n      for (i = 0; i < 6; ++i) {\n        faces[i].resize(radius);\n      }\n\n      reglFramebufferCube.width = reglFramebufferCube.height = radius;\n\n      return reglFramebufferCube;\n    }\n\n    reglFramebufferCube(options);\n\n    return extend(reglFramebufferCube, {\n      faces: faces,\n      resize: resize,\n      _reglType: 'framebufferCube',\n      destroy: function destroy() {\n        faces.forEach(function (f) {\n          f.destroy();\n        });\n      }\n    });\n  }\n\n  function restoreFramebuffers() {\n    values(framebufferSet).forEach(function (fb) {\n      fb.framebuffer = gl.createFramebuffer();\n      updateFramebuffer(fb);\n    });\n  }\n\n  return extend(framebufferState, {\n    getFramebuffer: function getFramebuffer(object) {\n      if (typeof object === 'function' && object._reglType === 'framebuffer') {\n        var fbo = object._framebuffer;\n        if (fbo instanceof REGLFramebuffer) {\n          return fbo;\n        }\n      }\n      return null;\n    },\n    create: createFBO,\n    createCube: createCubeFBO,\n    clear: function clear() {\n      values(framebufferSet).forEach(_destroy);\n    },\n    restore: restoreFramebuffers\n  });\n}\n\nvar GL_FLOAT$6 = 5126;\n\nfunction AttributeRecord() {\n  this.state = 0;\n\n  this.x = 0.0;\n  this.y = 0.0;\n  this.z = 0.0;\n  this.w = 0.0;\n\n  this.buffer = null;\n  this.size = 0;\n  this.normalized = false;\n  this.type = GL_FLOAT$6;\n  this.offset = 0;\n  this.stride = 0;\n  this.divisor = 0;\n}\n\nfunction wrapAttributeState(gl, extensions, limits, stringStore) {\n  var NUM_ATTRIBUTES = limits.maxAttributes;\n  var attributeBindings = new Array(NUM_ATTRIBUTES);\n  for (var i = 0; i < NUM_ATTRIBUTES; ++i) {\n    attributeBindings[i] = new AttributeRecord();\n  }\n\n  return {\n    Record: AttributeRecord,\n    scope: {},\n    state: attributeBindings\n  };\n}\n\nvar GL_FRAGMENT_SHADER = 35632;\nvar GL_VERTEX_SHADER = 35633;\n\nvar GL_ACTIVE_UNIFORMS = 0x8B86;\nvar GL_ACTIVE_ATTRIBUTES = 0x8B89;\n\nfunction wrapShaderState(gl, stringStore, stats, config) {\n  // ===================================================\n  // glsl compilation and linking\n  // ===================================================\n  var fragShaders = {};\n  var vertShaders = {};\n\n  function ActiveInfo(name, id, location, info) {\n    this.name = name;\n    this.id = id;\n    this.location = location;\n    this.info = info;\n  }\n\n  function insertActiveInfo(list, info) {\n    for (var i = 0; i < list.length; ++i) {\n      if (list[i].id === info.id) {\n        list[i].location = info.location;\n        return;\n      }\n    }\n    list.push(info);\n  }\n\n  function getShader(type, id, command) {\n    var cache = type === GL_FRAGMENT_SHADER ? fragShaders : vertShaders;\n    var shader = cache[id];\n\n    if (!shader) {\n      var source = stringStore.str(id);\n      shader = gl.createShader(type);\n      gl.shaderSource(shader, source);\n      gl.compileShader(shader);\n      check$1.shaderError(gl, shader, source, type, command);\n      cache[id] = shader;\n    }\n\n    return shader;\n  }\n\n  // ===================================================\n  // program linking\n  // ===================================================\n  var programCache = {};\n  var programList = [];\n\n  var PROGRAM_COUNTER = 0;\n\n  function REGLProgram(fragId, vertId) {\n    this.id = PROGRAM_COUNTER++;\n    this.fragId = fragId;\n    this.vertId = vertId;\n    this.program = null;\n    this.uniforms = [];\n    this.attributes = [];\n\n    if (config.profile) {\n      this.stats = {\n        uniformsCount: 0,\n        attributesCount: 0\n      };\n    }\n  }\n\n  function linkProgram(desc, command) {\n    var i, info;\n\n    // -------------------------------\n    // compile & link\n    // -------------------------------\n    var fragShader = getShader(GL_FRAGMENT_SHADER, desc.fragId);\n    var vertShader = getShader(GL_VERTEX_SHADER, desc.vertId);\n\n    var program = desc.program = gl.createProgram();\n    gl.attachShader(program, fragShader);\n    gl.attachShader(program, vertShader);\n    gl.linkProgram(program);\n    check$1.linkError(gl, program, stringStore.str(desc.fragId), stringStore.str(desc.vertId), command);\n\n    // -------------------------------\n    // grab uniforms\n    // -------------------------------\n    var numUniforms = gl.getProgramParameter(program, GL_ACTIVE_UNIFORMS);\n    if (config.profile) {\n      desc.stats.uniformsCount = numUniforms;\n    }\n    var uniforms = desc.uniforms;\n    for (i = 0; i < numUniforms; ++i) {\n      info = gl.getActiveUniform(program, i);\n      if (info) {\n        if (info.size > 1) {\n          for (var j = 0; j < info.size; ++j) {\n            var name = info.name.replace('[0]', '[' + j + ']');\n            insertActiveInfo(uniforms, new ActiveInfo(name, stringStore.id(name), gl.getUniformLocation(program, name), info));\n          }\n        } else {\n          insertActiveInfo(uniforms, new ActiveInfo(info.name, stringStore.id(info.name), gl.getUniformLocation(program, info.name), info));\n        }\n      }\n    }\n\n    // -------------------------------\n    // grab attributes\n    // -------------------------------\n    var numAttributes = gl.getProgramParameter(program, GL_ACTIVE_ATTRIBUTES);\n    if (config.profile) {\n      desc.stats.attributesCount = numAttributes;\n    }\n\n    var attributes = desc.attributes;\n    for (i = 0; i < numAttributes; ++i) {\n      info = gl.getActiveAttrib(program, i);\n      if (info) {\n        insertActiveInfo(attributes, new ActiveInfo(info.name, stringStore.id(info.name), gl.getAttribLocation(program, info.name), info));\n      }\n    }\n  }\n\n  if (config.profile) {\n    stats.getMaxUniformsCount = function () {\n      var m = 0;\n      programList.forEach(function (desc) {\n        if (desc.stats.uniformsCount > m) {\n          m = desc.stats.uniformsCount;\n        }\n      });\n      return m;\n    };\n\n    stats.getMaxAttributesCount = function () {\n      var m = 0;\n      programList.forEach(function (desc) {\n        if (desc.stats.attributesCount > m) {\n          m = desc.stats.attributesCount;\n        }\n      });\n      return m;\n    };\n  }\n\n  function restoreShaders() {\n    fragShaders = {};\n    vertShaders = {};\n    for (var i = 0; i < programList.length; ++i) {\n      linkProgram(programList[i]);\n    }\n  }\n\n  return {\n    clear: function clear() {\n      var deleteShader = gl.deleteShader.bind(gl);\n      values(fragShaders).forEach(deleteShader);\n      fragShaders = {};\n      values(vertShaders).forEach(deleteShader);\n      vertShaders = {};\n\n      programList.forEach(function (desc) {\n        gl.deleteProgram(desc.program);\n      });\n      programList.length = 0;\n      programCache = {};\n\n      stats.shaderCount = 0;\n    },\n\n    program: function program(vertId, fragId, command) {\n      check$1.command(vertId >= 0, 'missing vertex shader', command);\n      check$1.command(fragId >= 0, 'missing fragment shader', command);\n\n      var cache = programCache[fragId];\n      if (!cache) {\n        cache = programCache[fragId] = {};\n      }\n      var program = cache[vertId];\n      if (!program) {\n        program = new REGLProgram(fragId, vertId);\n        stats.shaderCount++;\n\n        linkProgram(program, command);\n        cache[vertId] = program;\n        programList.push(program);\n      }\n      return program;\n    },\n\n    restore: restoreShaders,\n\n    shader: getShader,\n\n    frag: -1,\n    vert: -1\n  };\n}\n\nvar GL_RGBA$3 = 6408;\nvar GL_UNSIGNED_BYTE$7 = 5121;\nvar GL_PACK_ALIGNMENT = 0x0D05;\nvar GL_FLOAT$7 = 0x1406; // 5126\n\nfunction wrapReadPixels(gl, framebufferState, reglPoll, context, glAttributes, extensions, limits) {\n  function readPixelsImpl(input) {\n    var type;\n    if (framebufferState.next === null) {\n      check$1(glAttributes.preserveDrawingBuffer, 'you must create a webgl context with \"preserveDrawingBuffer\":true in order to read pixels from the drawing buffer');\n      type = GL_UNSIGNED_BYTE$7;\n    } else {\n      check$1(framebufferState.next.colorAttachments[0].texture !== null, 'You cannot read from a renderbuffer');\n      type = framebufferState.next.colorAttachments[0].texture._texture.type;\n\n      if (extensions.oes_texture_float) {\n        check$1(type === GL_UNSIGNED_BYTE$7 || type === GL_FLOAT$7, 'Reading from a framebuffer is only allowed for the types \\'uint8\\' and \\'float\\'');\n\n        if (type === GL_FLOAT$7) {\n          check$1(limits.readFloat, 'Reading \\'float\\' values is not permitted in your browser. For a fallback, please see: https://www.npmjs.com/package/glsl-read-float');\n        }\n      } else {\n        check$1(type === GL_UNSIGNED_BYTE$7, 'Reading from a framebuffer is only allowed for the type \\'uint8\\'');\n      }\n    }\n\n    var x = 0;\n    var y = 0;\n    var width = context.framebufferWidth;\n    var height = context.framebufferHeight;\n    var data = null;\n\n    if (isTypedArray(input)) {\n      data = input;\n    } else if (input) {\n      check$1.type(input, 'object', 'invalid arguments to regl.read()');\n      x = input.x | 0;\n      y = input.y | 0;\n      check$1(x >= 0 && x < context.framebufferWidth, 'invalid x offset for regl.read');\n      check$1(y >= 0 && y < context.framebufferHeight, 'invalid y offset for regl.read');\n      width = (input.width || context.framebufferWidth - x) | 0;\n      height = (input.height || context.framebufferHeight - y) | 0;\n      data = input.data || null;\n    }\n\n    // sanity check input.data\n    if (data) {\n      if (type === GL_UNSIGNED_BYTE$7) {\n        check$1(data instanceof Uint8Array, 'buffer must be \\'Uint8Array\\' when reading from a framebuffer of type \\'uint8\\'');\n      } else if (type === GL_FLOAT$7) {\n        check$1(data instanceof Float32Array, 'buffer must be \\'Float32Array\\' when reading from a framebuffer of type \\'float\\'');\n      }\n    }\n\n    check$1(width > 0 && width + x <= context.framebufferWidth, 'invalid width for read pixels');\n    check$1(height > 0 && height + y <= context.framebufferHeight, 'invalid height for read pixels');\n\n    // Update WebGL state\n    reglPoll();\n\n    // Compute size\n    var size = width * height * 4;\n\n    // Allocate data\n    if (!data) {\n      if (type === GL_UNSIGNED_BYTE$7) {\n        data = new Uint8Array(size);\n      } else if (type === GL_FLOAT$7) {\n        data = data || new Float32Array(size);\n      }\n    }\n\n    // Type check\n    check$1.isTypedArray(data, 'data buffer for regl.read() must be a typedarray');\n    check$1(data.byteLength >= size, 'data buffer for regl.read() too small');\n\n    // Run read pixels\n    gl.pixelStorei(GL_PACK_ALIGNMENT, 4);\n    gl.readPixels(x, y, width, height, GL_RGBA$3, type, data);\n\n    return data;\n  }\n\n  function readPixelsFBO(options) {\n    var result;\n    framebufferState.setFBO({\n      framebuffer: options.framebuffer\n    }, function () {\n      result = readPixelsImpl(options);\n    });\n    return result;\n  }\n\n  function readPixels(options) {\n    if (!options || !('framebuffer' in options)) {\n      return readPixelsImpl(options);\n    } else {\n      return readPixelsFBO(options);\n    }\n  }\n\n  return readPixels;\n}\n\nfunction slice(x) {\n  return Array.prototype.slice.call(x);\n}\n\nfunction join(x) {\n  return slice(x).join('');\n}\n\nfunction createEnvironment() {\n  // Unique variable id counter\n  var varCounter = 0;\n\n  // Linked values are passed from this scope into the generated code block\n  // Calling link() passes a value into the generated scope and returns\n  // the variable name which it is bound to\n  var linkedNames = [];\n  var linkedValues = [];\n  function link(value) {\n    for (var i = 0; i < linkedValues.length; ++i) {\n      if (linkedValues[i] === value) {\n        return linkedNames[i];\n      }\n    }\n\n    var name = 'g' + varCounter++;\n    linkedNames.push(name);\n    linkedValues.push(value);\n    return name;\n  }\n\n  // create a code block\n  function block() {\n    var code = [];\n    function push() {\n      code.push.apply(code, slice(arguments));\n    }\n\n    var vars = [];\n    function def() {\n      var name = 'v' + varCounter++;\n      vars.push(name);\n\n      if (arguments.length > 0) {\n        code.push(name, '=');\n        code.push.apply(code, slice(arguments));\n        code.push(';');\n      }\n\n      return name;\n    }\n\n    return extend(push, {\n      def: def,\n      toString: function toString() {\n        return join([vars.length > 0 ? 'var ' + vars + ';' : '', join(code)]);\n      }\n    });\n  }\n\n  function scope() {\n    var entry = block();\n    var exit = block();\n\n    var entryToString = entry.toString;\n    var exitToString = exit.toString;\n\n    function save(object, prop) {\n      exit(object, prop, '=', entry.def(object, prop), ';');\n    }\n\n    return extend(function () {\n      entry.apply(entry, slice(arguments));\n    }, {\n      def: entry.def,\n      entry: entry,\n      exit: exit,\n      save: save,\n      set: function set(object, prop, value) {\n        save(object, prop);\n        entry(object, prop, '=', value, ';');\n      },\n      toString: function toString() {\n        return entryToString() + exitToString();\n      }\n    });\n  }\n\n  function conditional() {\n    var pred = join(arguments);\n    var thenBlock = scope();\n    var elseBlock = scope();\n\n    var thenToString = thenBlock.toString;\n    var elseToString = elseBlock.toString;\n\n    return extend(thenBlock, {\n      then: function then() {\n        thenBlock.apply(thenBlock, slice(arguments));\n        return this;\n      },\n      else: function _else() {\n        elseBlock.apply(elseBlock, slice(arguments));\n        return this;\n      },\n      toString: function toString() {\n        var elseClause = elseToString();\n        if (elseClause) {\n          elseClause = 'else{' + elseClause + '}';\n        }\n        return join(['if(', pred, '){', thenToString(), '}', elseClause]);\n      }\n    });\n  }\n\n  // procedure list\n  var globalBlock = block();\n  var procedures = {};\n  function proc(name, count) {\n    var args = [];\n    function arg() {\n      var name = 'a' + args.length;\n      args.push(name);\n      return name;\n    }\n\n    count = count || 0;\n    for (var i = 0; i < count; ++i) {\n      arg();\n    }\n\n    var body = scope();\n    var bodyToString = body.toString;\n\n    var result = procedures[name] = extend(body, {\n      arg: arg,\n      toString: function toString() {\n        return join(['function(', args.join(), '){', bodyToString(), '}']);\n      }\n    });\n\n    return result;\n  }\n\n  function compile() {\n    var code = ['\"use strict\";', globalBlock, 'return {'];\n    Object.keys(procedures).forEach(function (name) {\n      code.push('\"', name, '\":', procedures[name].toString(), ',');\n    });\n    code.push('}');\n    var src = join(code).replace(/;/g, ';\\n').replace(/}/g, '}\\n').replace(/{/g, '{\\n');\n    var proc = Function.apply(null, linkedNames.concat(src));\n    return proc.apply(null, linkedValues);\n  }\n\n  return {\n    global: globalBlock,\n    link: link,\n    block: block,\n    proc: proc,\n    scope: scope,\n    cond: conditional,\n    compile: compile\n  };\n}\n\n// \"cute\" names for vector components\nvar CUTE_COMPONENTS = 'xyzw'.split('');\n\nvar GL_UNSIGNED_BYTE$8 = 5121;\n\nvar ATTRIB_STATE_POINTER = 1;\nvar ATTRIB_STATE_CONSTANT = 2;\n\nvar DYN_FUNC$1 = 0;\nvar DYN_PROP$1 = 1;\nvar DYN_CONTEXT$1 = 2;\nvar DYN_STATE$1 = 3;\nvar DYN_THUNK = 4;\n\nvar S_DITHER = 'dither';\nvar S_BLEND_ENABLE = 'blend.enable';\nvar S_BLEND_COLOR = 'blend.color';\nvar S_BLEND_EQUATION = 'blend.equation';\nvar S_BLEND_FUNC = 'blend.func';\nvar S_DEPTH_ENABLE = 'depth.enable';\nvar S_DEPTH_FUNC = 'depth.func';\nvar S_DEPTH_RANGE = 'depth.range';\nvar S_DEPTH_MASK = 'depth.mask';\nvar S_COLOR_MASK = 'colorMask';\nvar S_CULL_ENABLE = 'cull.enable';\nvar S_CULL_FACE = 'cull.face';\nvar S_FRONT_FACE = 'frontFace';\nvar S_LINE_WIDTH = 'lineWidth';\nvar S_POLYGON_OFFSET_ENABLE = 'polygonOffset.enable';\nvar S_POLYGON_OFFSET_OFFSET = 'polygonOffset.offset';\nvar S_SAMPLE_ALPHA = 'sample.alpha';\nvar S_SAMPLE_ENABLE = 'sample.enable';\nvar S_SAMPLE_COVERAGE = 'sample.coverage';\nvar S_STENCIL_ENABLE = 'stencil.enable';\nvar S_STENCIL_MASK = 'stencil.mask';\nvar S_STENCIL_FUNC = 'stencil.func';\nvar S_STENCIL_OPFRONT = 'stencil.opFront';\nvar S_STENCIL_OPBACK = 'stencil.opBack';\nvar S_SCISSOR_ENABLE = 'scissor.enable';\nvar S_SCISSOR_BOX = 'scissor.box';\nvar S_VIEWPORT = 'viewport';\n\nvar S_PROFILE = 'profile';\n\nvar S_FRAMEBUFFER = 'framebuffer';\nvar S_VERT = 'vert';\nvar S_FRAG = 'frag';\nvar S_ELEMENTS = 'elements';\nvar S_PRIMITIVE = 'primitive';\nvar S_COUNT = 'count';\nvar S_OFFSET = 'offset';\nvar S_INSTANCES = 'instances';\n\nvar SUFFIX_WIDTH = 'Width';\nvar SUFFIX_HEIGHT = 'Height';\n\nvar S_FRAMEBUFFER_WIDTH = S_FRAMEBUFFER + SUFFIX_WIDTH;\nvar S_FRAMEBUFFER_HEIGHT = S_FRAMEBUFFER + SUFFIX_HEIGHT;\nvar S_VIEWPORT_WIDTH = S_VIEWPORT + SUFFIX_WIDTH;\nvar S_VIEWPORT_HEIGHT = S_VIEWPORT + SUFFIX_HEIGHT;\nvar S_DRAWINGBUFFER = 'drawingBuffer';\nvar S_DRAWINGBUFFER_WIDTH = S_DRAWINGBUFFER + SUFFIX_WIDTH;\nvar S_DRAWINGBUFFER_HEIGHT = S_DRAWINGBUFFER + SUFFIX_HEIGHT;\n\nvar NESTED_OPTIONS = [S_BLEND_FUNC, S_BLEND_EQUATION, S_STENCIL_FUNC, S_STENCIL_OPFRONT, S_STENCIL_OPBACK, S_SAMPLE_COVERAGE, S_VIEWPORT, S_SCISSOR_BOX, S_POLYGON_OFFSET_OFFSET];\n\nvar GL_ARRAY_BUFFER$1 = 34962;\nvar GL_ELEMENT_ARRAY_BUFFER$1 = 34963;\n\nvar GL_FRAGMENT_SHADER$1 = 35632;\nvar GL_VERTEX_SHADER$1 = 35633;\n\nvar GL_TEXTURE_2D$3 = 0x0DE1;\nvar GL_TEXTURE_CUBE_MAP$2 = 0x8513;\n\nvar GL_CULL_FACE = 0x0B44;\nvar GL_BLEND = 0x0BE2;\nvar GL_DITHER = 0x0BD0;\nvar GL_STENCIL_TEST = 0x0B90;\nvar GL_DEPTH_TEST = 0x0B71;\nvar GL_SCISSOR_TEST = 0x0C11;\nvar GL_POLYGON_OFFSET_FILL = 0x8037;\nvar GL_SAMPLE_ALPHA_TO_COVERAGE = 0x809E;\nvar GL_SAMPLE_COVERAGE = 0x80A0;\n\nvar GL_FLOAT$8 = 5126;\nvar GL_FLOAT_VEC2 = 35664;\nvar GL_FLOAT_VEC3 = 35665;\nvar GL_FLOAT_VEC4 = 35666;\nvar GL_INT$3 = 5124;\nvar GL_INT_VEC2 = 35667;\nvar GL_INT_VEC3 = 35668;\nvar GL_INT_VEC4 = 35669;\nvar GL_BOOL = 35670;\nvar GL_BOOL_VEC2 = 35671;\nvar GL_BOOL_VEC3 = 35672;\nvar GL_BOOL_VEC4 = 35673;\nvar GL_FLOAT_MAT2 = 35674;\nvar GL_FLOAT_MAT3 = 35675;\nvar GL_FLOAT_MAT4 = 35676;\nvar GL_SAMPLER_2D = 35678;\nvar GL_SAMPLER_CUBE = 35680;\n\nvar GL_TRIANGLES$1 = 4;\n\nvar GL_FRONT = 1028;\nvar GL_BACK = 1029;\nvar GL_CW = 0x0900;\nvar GL_CCW = 0x0901;\nvar GL_MIN_EXT = 0x8007;\nvar GL_MAX_EXT = 0x8008;\nvar GL_ALWAYS = 519;\nvar GL_KEEP = 7680;\nvar GL_ZERO = 0;\nvar GL_ONE = 1;\nvar GL_FUNC_ADD = 0x8006;\nvar GL_LESS = 513;\n\nvar GL_FRAMEBUFFER$2 = 0x8D40;\nvar GL_COLOR_ATTACHMENT0$2 = 0x8CE0;\n\nvar blendFuncs = {\n  '0': 0,\n  '1': 1,\n  'zero': 0,\n  'one': 1,\n  'src color': 768,\n  'one minus src color': 769,\n  'src alpha': 770,\n  'one minus src alpha': 771,\n  'dst color': 774,\n  'one minus dst color': 775,\n  'dst alpha': 772,\n  'one minus dst alpha': 773,\n  'constant color': 32769,\n  'one minus constant color': 32770,\n  'constant alpha': 32771,\n  'one minus constant alpha': 32772,\n  'src alpha saturate': 776\n};\n\n// There are invalid values for srcRGB and dstRGB. See:\n// https://www.khronos.org/registry/webgl/specs/1.0/#6.13\n// https://github.com/KhronosGroup/WebGL/blob/0d3201f5f7ec3c0060bc1f04077461541f1987b9/conformance-suites/1.0.3/conformance/misc/webgl-specific.html#L56\nvar invalidBlendCombinations = ['constant color, constant alpha', 'one minus constant color, constant alpha', 'constant color, one minus constant alpha', 'one minus constant color, one minus constant alpha', 'constant alpha, constant color', 'constant alpha, one minus constant color', 'one minus constant alpha, constant color', 'one minus constant alpha, one minus constant color'];\n\nvar compareFuncs = {\n  'never': 512,\n  'less': 513,\n  '<': 513,\n  'equal': 514,\n  '=': 514,\n  '==': 514,\n  '===': 514,\n  'lequal': 515,\n  '<=': 515,\n  'greater': 516,\n  '>': 516,\n  'notequal': 517,\n  '!=': 517,\n  '!==': 517,\n  'gequal': 518,\n  '>=': 518,\n  'always': 519\n};\n\nvar stencilOps = {\n  '0': 0,\n  'zero': 0,\n  'keep': 7680,\n  'replace': 7681,\n  'increment': 7682,\n  'decrement': 7683,\n  'increment wrap': 34055,\n  'decrement wrap': 34056,\n  'invert': 5386\n};\n\nvar shaderType = {\n  'frag': GL_FRAGMENT_SHADER$1,\n  'vert': GL_VERTEX_SHADER$1\n};\n\nvar orientationType = {\n  'cw': GL_CW,\n  'ccw': GL_CCW\n};\n\nfunction isBufferArgs(x) {\n  return Array.isArray(x) || isTypedArray(x) || isNDArrayLike(x);\n}\n\n// Make sure viewport is processed first\nfunction sortState(state) {\n  return state.sort(function (a, b) {\n    if (a === S_VIEWPORT) {\n      return -1;\n    } else if (b === S_VIEWPORT) {\n      return 1;\n    }\n    return a < b ? -1 : 1;\n  });\n}\n\nfunction Declaration(thisDep, contextDep, propDep, append) {\n  this.thisDep = thisDep;\n  this.contextDep = contextDep;\n  this.propDep = propDep;\n  this.append = append;\n}\n\nfunction isStatic(decl) {\n  return decl && !(decl.thisDep || decl.contextDep || decl.propDep);\n}\n\nfunction createStaticDecl(append) {\n  return new Declaration(false, false, false, append);\n}\n\nfunction createDynamicDecl(dyn, append) {\n  var type = dyn.type;\n  if (type === DYN_FUNC$1) {\n    var numArgs = dyn.data.length;\n    return new Declaration(true, numArgs >= 1, numArgs >= 2, append);\n  } else if (type === DYN_THUNK) {\n    var data = dyn.data;\n    return new Declaration(data.thisDep, data.contextDep, data.propDep, append);\n  } else {\n    return new Declaration(type === DYN_STATE$1, type === DYN_CONTEXT$1, type === DYN_PROP$1, append);\n  }\n}\n\nvar SCOPE_DECL = new Declaration(false, false, false, function () {});\n\nfunction reglCore(gl, stringStore, extensions, limits, bufferState, elementState, textureState, framebufferState, uniformState, attributeState, shaderState, drawState, contextState, timer, config) {\n  var AttributeRecord = attributeState.Record;\n\n  var blendEquations = {\n    'add': 32774,\n    'subtract': 32778,\n    'reverse subtract': 32779\n  };\n  if (extensions.ext_blend_minmax) {\n    blendEquations.min = GL_MIN_EXT;\n    blendEquations.max = GL_MAX_EXT;\n  }\n\n  var extInstancing = extensions.angle_instanced_arrays;\n  var extDrawBuffers = extensions.webgl_draw_buffers;\n\n  // ===================================================\n  // ===================================================\n  // WEBGL STATE\n  // ===================================================\n  // ===================================================\n  var currentState = {\n    dirty: true,\n    profile: config.profile\n  };\n  var nextState = {};\n  var GL_STATE_NAMES = [];\n  var GL_FLAGS = {};\n  var GL_VARIABLES = {};\n\n  function propName(name) {\n    return name.replace('.', '_');\n  }\n\n  function stateFlag(sname, cap, init) {\n    var name = propName(sname);\n    GL_STATE_NAMES.push(sname);\n    nextState[name] = currentState[name] = !!init;\n    GL_FLAGS[name] = cap;\n  }\n\n  function stateVariable(sname, func, init) {\n    var name = propName(sname);\n    GL_STATE_NAMES.push(sname);\n    if (Array.isArray(init)) {\n      currentState[name] = init.slice();\n      nextState[name] = init.slice();\n    } else {\n      currentState[name] = nextState[name] = init;\n    }\n    GL_VARIABLES[name] = func;\n  }\n\n  // Dithering\n  stateFlag(S_DITHER, GL_DITHER);\n\n  // Blending\n  stateFlag(S_BLEND_ENABLE, GL_BLEND);\n  stateVariable(S_BLEND_COLOR, 'blendColor', [0, 0, 0, 0]);\n  stateVariable(S_BLEND_EQUATION, 'blendEquationSeparate', [GL_FUNC_ADD, GL_FUNC_ADD]);\n  stateVariable(S_BLEND_FUNC, 'blendFuncSeparate', [GL_ONE, GL_ZERO, GL_ONE, GL_ZERO]);\n\n  // Depth\n  stateFlag(S_DEPTH_ENABLE, GL_DEPTH_TEST, true);\n  stateVariable(S_DEPTH_FUNC, 'depthFunc', GL_LESS);\n  stateVariable(S_DEPTH_RANGE, 'depthRange', [0, 1]);\n  stateVariable(S_DEPTH_MASK, 'depthMask', true);\n\n  // Color mask\n  stateVariable(S_COLOR_MASK, S_COLOR_MASK, [true, true, true, true]);\n\n  // Face culling\n  stateFlag(S_CULL_ENABLE, GL_CULL_FACE);\n  stateVariable(S_CULL_FACE, 'cullFace', GL_BACK);\n\n  // Front face orientation\n  stateVariable(S_FRONT_FACE, S_FRONT_FACE, GL_CCW);\n\n  // Line width\n  stateVariable(S_LINE_WIDTH, S_LINE_WIDTH, 1);\n\n  // Polygon offset\n  stateFlag(S_POLYGON_OFFSET_ENABLE, GL_POLYGON_OFFSET_FILL);\n  stateVariable(S_POLYGON_OFFSET_OFFSET, 'polygonOffset', [0, 0]);\n\n  // Sample coverage\n  stateFlag(S_SAMPLE_ALPHA, GL_SAMPLE_ALPHA_TO_COVERAGE);\n  stateFlag(S_SAMPLE_ENABLE, GL_SAMPLE_COVERAGE);\n  stateVariable(S_SAMPLE_COVERAGE, 'sampleCoverage', [1, false]);\n\n  // Stencil\n  stateFlag(S_STENCIL_ENABLE, GL_STENCIL_TEST);\n  stateVariable(S_STENCIL_MASK, 'stencilMask', -1);\n  stateVariable(S_STENCIL_FUNC, 'stencilFunc', [GL_ALWAYS, 0, -1]);\n  stateVariable(S_STENCIL_OPFRONT, 'stencilOpSeparate', [GL_FRONT, GL_KEEP, GL_KEEP, GL_KEEP]);\n  stateVariable(S_STENCIL_OPBACK, 'stencilOpSeparate', [GL_BACK, GL_KEEP, GL_KEEP, GL_KEEP]);\n\n  // Scissor\n  stateFlag(S_SCISSOR_ENABLE, GL_SCISSOR_TEST);\n  stateVariable(S_SCISSOR_BOX, 'scissor', [0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight]);\n\n  // Viewport\n  stateVariable(S_VIEWPORT, S_VIEWPORT, [0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight]);\n\n  // ===================================================\n  // ===================================================\n  // ENVIRONMENT\n  // ===================================================\n  // ===================================================\n  var sharedState = {\n    gl: gl,\n    context: contextState,\n    strings: stringStore,\n    next: nextState,\n    current: currentState,\n    draw: drawState,\n    elements: elementState,\n    buffer: bufferState,\n    shader: shaderState,\n    attributes: attributeState.state,\n    uniforms: uniformState,\n    framebuffer: framebufferState,\n    extensions: extensions,\n\n    timer: timer,\n    isBufferArgs: isBufferArgs\n  };\n\n  var sharedConstants = {\n    primTypes: primTypes,\n    compareFuncs: compareFuncs,\n    blendFuncs: blendFuncs,\n    blendEquations: blendEquations,\n    stencilOps: stencilOps,\n    glTypes: glTypes,\n    orientationType: orientationType\n  };\n\n  check$1.optional(function () {\n    sharedState.isArrayLike = isArrayLike;\n  });\n\n  if (extDrawBuffers) {\n    sharedConstants.backBuffer = [GL_BACK];\n    sharedConstants.drawBuffer = loop(limits.maxDrawbuffers, function (i) {\n      if (i === 0) {\n        return [0];\n      }\n      return loop(i, function (j) {\n        return GL_COLOR_ATTACHMENT0$2 + j;\n      });\n    });\n  }\n\n  var drawCallCounter = 0;\n  function createREGLEnvironment() {\n    var env = createEnvironment();\n    var link = env.link;\n    var global = env.global;\n    env.id = drawCallCounter++;\n\n    env.batchId = '0';\n\n    // link shared state\n    var SHARED = link(sharedState);\n    var shared = env.shared = {\n      props: 'a0'\n    };\n    Object.keys(sharedState).forEach(function (prop) {\n      shared[prop] = global.def(SHARED, '.', prop);\n    });\n\n    // Inject runtime assertion stuff for debug builds\n    check$1.optional(function () {\n      env.CHECK = link(check$1);\n      env.commandStr = check$1.guessCommand();\n      env.command = link(env.commandStr);\n      env.assert = function (block, pred, message) {\n        block('if(!(', pred, '))', this.CHECK, '.commandRaise(', link(message), ',', this.command, ');');\n      };\n\n      sharedConstants.invalidBlendCombinations = invalidBlendCombinations;\n    });\n\n    // Copy GL state variables over\n    var nextVars = env.next = {};\n    var currentVars = env.current = {};\n    Object.keys(GL_VARIABLES).forEach(function (variable) {\n      if (Array.isArray(currentState[variable])) {\n        nextVars[variable] = global.def(shared.next, '.', variable);\n        currentVars[variable] = global.def(shared.current, '.', variable);\n      }\n    });\n\n    // Initialize shared constants\n    var constants = env.constants = {};\n    Object.keys(sharedConstants).forEach(function (name) {\n      constants[name] = global.def(JSON.stringify(sharedConstants[name]));\n    });\n\n    // Helper function for calling a block\n    env.invoke = function (block, x) {\n      switch (x.type) {\n        case DYN_FUNC$1:\n          var argList = ['this', shared.context, shared.props, env.batchId];\n          return block.def(link(x.data), '.call(', argList.slice(0, Math.max(x.data.length + 1, 4)), ')');\n        case DYN_PROP$1:\n          return block.def(shared.props, x.data);\n        case DYN_CONTEXT$1:\n          return block.def(shared.context, x.data);\n        case DYN_STATE$1:\n          return block.def('this', x.data);\n        case DYN_THUNK:\n          x.data.append(env, block);\n          return x.data.ref;\n      }\n    };\n\n    env.attribCache = {};\n\n    var scopeAttribs = {};\n    env.scopeAttrib = function (name) {\n      var id = stringStore.id(name);\n      if (id in scopeAttribs) {\n        return scopeAttribs[id];\n      }\n      var binding = attributeState.scope[id];\n      if (!binding) {\n        binding = attributeState.scope[id] = new AttributeRecord();\n      }\n      var result = scopeAttribs[id] = link(binding);\n      return result;\n    };\n\n    return env;\n  }\n\n  // ===================================================\n  // ===================================================\n  // PARSING\n  // ===================================================\n  // ===================================================\n  function parseProfile(options) {\n    var staticOptions = options.static;\n    var dynamicOptions = options.dynamic;\n\n    var profileEnable;\n    if (S_PROFILE in staticOptions) {\n      var value = !!staticOptions[S_PROFILE];\n      profileEnable = createStaticDecl(function (env, scope) {\n        return value;\n      });\n      profileEnable.enable = value;\n    } else if (S_PROFILE in dynamicOptions) {\n      var dyn = dynamicOptions[S_PROFILE];\n      profileEnable = createDynamicDecl(dyn, function (env, scope) {\n        return env.invoke(scope, dyn);\n      });\n    }\n\n    return profileEnable;\n  }\n\n  function parseFramebuffer(options, env) {\n    var staticOptions = options.static;\n    var dynamicOptions = options.dynamic;\n\n    if (S_FRAMEBUFFER in staticOptions) {\n      var framebuffer = staticOptions[S_FRAMEBUFFER];\n      if (framebuffer) {\n        framebuffer = framebufferState.getFramebuffer(framebuffer);\n        check$1.command(framebuffer, 'invalid framebuffer object');\n        return createStaticDecl(function (env, block) {\n          var FRAMEBUFFER = env.link(framebuffer);\n          var shared = env.shared;\n          block.set(shared.framebuffer, '.next', FRAMEBUFFER);\n          var CONTEXT = shared.context;\n          block.set(CONTEXT, '.' + S_FRAMEBUFFER_WIDTH, FRAMEBUFFER + '.width');\n          block.set(CONTEXT, '.' + S_FRAMEBUFFER_HEIGHT, FRAMEBUFFER + '.height');\n          return FRAMEBUFFER;\n        });\n      } else {\n        return createStaticDecl(function (env, scope) {\n          var shared = env.shared;\n          scope.set(shared.framebuffer, '.next', 'null');\n          var CONTEXT = shared.context;\n          scope.set(CONTEXT, '.' + S_FRAMEBUFFER_WIDTH, CONTEXT + '.' + S_DRAWINGBUFFER_WIDTH);\n          scope.set(CONTEXT, '.' + S_FRAMEBUFFER_HEIGHT, CONTEXT + '.' + S_DRAWINGBUFFER_HEIGHT);\n          return 'null';\n        });\n      }\n    } else if (S_FRAMEBUFFER in dynamicOptions) {\n      var dyn = dynamicOptions[S_FRAMEBUFFER];\n      return createDynamicDecl(dyn, function (env, scope) {\n        var FRAMEBUFFER_FUNC = env.invoke(scope, dyn);\n        var shared = env.shared;\n        var FRAMEBUFFER_STATE = shared.framebuffer;\n        var FRAMEBUFFER = scope.def(FRAMEBUFFER_STATE, '.getFramebuffer(', FRAMEBUFFER_FUNC, ')');\n\n        check$1.optional(function () {\n          env.assert(scope, '!' + FRAMEBUFFER_FUNC + '||' + FRAMEBUFFER, 'invalid framebuffer object');\n        });\n\n        scope.set(FRAMEBUFFER_STATE, '.next', FRAMEBUFFER);\n        var CONTEXT = shared.context;\n        scope.set(CONTEXT, '.' + S_FRAMEBUFFER_WIDTH, FRAMEBUFFER + '?' + FRAMEBUFFER + '.width:' + CONTEXT + '.' + S_DRAWINGBUFFER_WIDTH);\n        scope.set(CONTEXT, '.' + S_FRAMEBUFFER_HEIGHT, FRAMEBUFFER + '?' + FRAMEBUFFER + '.height:' + CONTEXT + '.' + S_DRAWINGBUFFER_HEIGHT);\n        return FRAMEBUFFER;\n      });\n    } else {\n      return null;\n    }\n  }\n\n  function parseViewportScissor(options, framebuffer, env) {\n    var staticOptions = options.static;\n    var dynamicOptions = options.dynamic;\n\n    function parseBox(param) {\n      if (param in staticOptions) {\n        var box = staticOptions[param];\n        check$1.commandType(box, 'object', 'invalid ' + param, env.commandStr);\n\n        var isStatic = true;\n        var x = box.x | 0;\n        var y = box.y | 0;\n        var w, h;\n        if ('width' in box) {\n          w = box.width | 0;\n          check$1.command(w >= 0, 'invalid ' + param, env.commandStr);\n        } else {\n          isStatic = false;\n        }\n        if ('height' in box) {\n          h = box.height | 0;\n          check$1.command(h >= 0, 'invalid ' + param, env.commandStr);\n        } else {\n          isStatic = false;\n        }\n\n        return new Declaration(!isStatic && framebuffer && framebuffer.thisDep, !isStatic && framebuffer && framebuffer.contextDep, !isStatic && framebuffer && framebuffer.propDep, function (env, scope) {\n          var CONTEXT = env.shared.context;\n          var BOX_W = w;\n          if (!('width' in box)) {\n            BOX_W = scope.def(CONTEXT, '.', S_FRAMEBUFFER_WIDTH, '-', x);\n          }\n          var BOX_H = h;\n          if (!('height' in box)) {\n            BOX_H = scope.def(CONTEXT, '.', S_FRAMEBUFFER_HEIGHT, '-', y);\n          }\n          return [x, y, BOX_W, BOX_H];\n        });\n      } else if (param in dynamicOptions) {\n        var dynBox = dynamicOptions[param];\n        var result = createDynamicDecl(dynBox, function (env, scope) {\n          var BOX = env.invoke(scope, dynBox);\n\n          check$1.optional(function () {\n            env.assert(scope, BOX + '&&typeof ' + BOX + '===\"object\"', 'invalid ' + param);\n          });\n\n          var CONTEXT = env.shared.context;\n          var BOX_X = scope.def(BOX, '.x|0');\n          var BOX_Y = scope.def(BOX, '.y|0');\n          var BOX_W = scope.def('\"width\" in ', BOX, '?', BOX, '.width|0:', '(', CONTEXT, '.', S_FRAMEBUFFER_WIDTH, '-', BOX_X, ')');\n          var BOX_H = scope.def('\"height\" in ', BOX, '?', BOX, '.height|0:', '(', CONTEXT, '.', S_FRAMEBUFFER_HEIGHT, '-', BOX_Y, ')');\n\n          check$1.optional(function () {\n            env.assert(scope, BOX_W + '>=0&&' + BOX_H + '>=0', 'invalid ' + param);\n          });\n\n          return [BOX_X, BOX_Y, BOX_W, BOX_H];\n        });\n        if (framebuffer) {\n          result.thisDep = result.thisDep || framebuffer.thisDep;\n          result.contextDep = result.contextDep || framebuffer.contextDep;\n          result.propDep = result.propDep || framebuffer.propDep;\n        }\n        return result;\n      } else if (framebuffer) {\n        return new Declaration(framebuffer.thisDep, framebuffer.contextDep, framebuffer.propDep, function (env, scope) {\n          var CONTEXT = env.shared.context;\n          return [0, 0, scope.def(CONTEXT, '.', S_FRAMEBUFFER_WIDTH), scope.def(CONTEXT, '.', S_FRAMEBUFFER_HEIGHT)];\n        });\n      } else {\n        return null;\n      }\n    }\n\n    var viewport = parseBox(S_VIEWPORT);\n\n    if (viewport) {\n      var prevViewport = viewport;\n      viewport = new Declaration(viewport.thisDep, viewport.contextDep, viewport.propDep, function (env, scope) {\n        var VIEWPORT = prevViewport.append(env, scope);\n        var CONTEXT = env.shared.context;\n        scope.set(CONTEXT, '.' + S_VIEWPORT_WIDTH, VIEWPORT[2]);\n        scope.set(CONTEXT, '.' + S_VIEWPORT_HEIGHT, VIEWPORT[3]);\n        return VIEWPORT;\n      });\n    }\n\n    return {\n      viewport: viewport,\n      scissor_box: parseBox(S_SCISSOR_BOX)\n    };\n  }\n\n  function parseProgram(options) {\n    var staticOptions = options.static;\n    var dynamicOptions = options.dynamic;\n\n    function parseShader(name) {\n      if (name in staticOptions) {\n        var id = stringStore.id(staticOptions[name]);\n        check$1.optional(function () {\n          shaderState.shader(shaderType[name], id, check$1.guessCommand());\n        });\n        var result = createStaticDecl(function () {\n          return id;\n        });\n        result.id = id;\n        return result;\n      } else if (name in dynamicOptions) {\n        var dyn = dynamicOptions[name];\n        return createDynamicDecl(dyn, function (env, scope) {\n          var str = env.invoke(scope, dyn);\n          var id = scope.def(env.shared.strings, '.id(', str, ')');\n          check$1.optional(function () {\n            scope(env.shared.shader, '.shader(', shaderType[name], ',', id, ',', env.command, ');');\n          });\n          return id;\n        });\n      }\n      return null;\n    }\n\n    var frag = parseShader(S_FRAG);\n    var vert = parseShader(S_VERT);\n\n    var program = null;\n    var progVar;\n    if (isStatic(frag) && isStatic(vert)) {\n      program = shaderState.program(vert.id, frag.id);\n      progVar = createStaticDecl(function (env, scope) {\n        return env.link(program);\n      });\n    } else {\n      progVar = new Declaration(frag && frag.thisDep || vert && vert.thisDep, frag && frag.contextDep || vert && vert.contextDep, frag && frag.propDep || vert && vert.propDep, function (env, scope) {\n        var SHADER_STATE = env.shared.shader;\n        var fragId;\n        if (frag) {\n          fragId = frag.append(env, scope);\n        } else {\n          fragId = scope.def(SHADER_STATE, '.', S_FRAG);\n        }\n        var vertId;\n        if (vert) {\n          vertId = vert.append(env, scope);\n        } else {\n          vertId = scope.def(SHADER_STATE, '.', S_VERT);\n        }\n        var progDef = SHADER_STATE + '.program(' + vertId + ',' + fragId;\n        check$1.optional(function () {\n          progDef += ',' + env.command;\n        });\n        return scope.def(progDef + ')');\n      });\n    }\n\n    return {\n      frag: frag,\n      vert: vert,\n      progVar: progVar,\n      program: program\n    };\n  }\n\n  function parseDraw(options, env) {\n    var staticOptions = options.static;\n    var dynamicOptions = options.dynamic;\n\n    function parseElements() {\n      if (S_ELEMENTS in staticOptions) {\n        var elements = staticOptions[S_ELEMENTS];\n        if (isBufferArgs(elements)) {\n          elements = elementState.getElements(elementState.create(elements, true));\n        } else if (elements) {\n          elements = elementState.getElements(elements);\n          check$1.command(elements, 'invalid elements', env.commandStr);\n        }\n        var result = createStaticDecl(function (env, scope) {\n          if (elements) {\n            var result = env.link(elements);\n            env.ELEMENTS = result;\n            return result;\n          }\n          env.ELEMENTS = null;\n          return null;\n        });\n        result.value = elements;\n        return result;\n      } else if (S_ELEMENTS in dynamicOptions) {\n        var dyn = dynamicOptions[S_ELEMENTS];\n        return createDynamicDecl(dyn, function (env, scope) {\n          var shared = env.shared;\n\n          var IS_BUFFER_ARGS = shared.isBufferArgs;\n          var ELEMENT_STATE = shared.elements;\n\n          var elementDefn = env.invoke(scope, dyn);\n          var elements = scope.def('null');\n          var elementStream = scope.def(IS_BUFFER_ARGS, '(', elementDefn, ')');\n\n          var ifte = env.cond(elementStream).then(elements, '=', ELEMENT_STATE, '.createStream(', elementDefn, ');').else(elements, '=', ELEMENT_STATE, '.getElements(', elementDefn, ');');\n\n          check$1.optional(function () {\n            env.assert(ifte.else, '!' + elementDefn + '||' + elements, 'invalid elements');\n          });\n\n          scope.entry(ifte);\n          scope.exit(env.cond(elementStream).then(ELEMENT_STATE, '.destroyStream(', elements, ');'));\n\n          env.ELEMENTS = elements;\n\n          return elements;\n        });\n      }\n\n      return null;\n    }\n\n    var elements = parseElements();\n\n    function parsePrimitive() {\n      if (S_PRIMITIVE in staticOptions) {\n        var primitive = staticOptions[S_PRIMITIVE];\n        check$1.commandParameter(primitive, primTypes, 'invalid primitve', env.commandStr);\n        return createStaticDecl(function (env, scope) {\n          return primTypes[primitive];\n        });\n      } else if (S_PRIMITIVE in dynamicOptions) {\n        var dynPrimitive = dynamicOptions[S_PRIMITIVE];\n        return createDynamicDecl(dynPrimitive, function (env, scope) {\n          var PRIM_TYPES = env.constants.primTypes;\n          var prim = env.invoke(scope, dynPrimitive);\n          check$1.optional(function () {\n            env.assert(scope, prim + ' in ' + PRIM_TYPES, 'invalid primitive, must be one of ' + Object.keys(primTypes));\n          });\n          return scope.def(PRIM_TYPES, '[', prim, ']');\n        });\n      } else if (elements) {\n        if (isStatic(elements)) {\n          if (elements.value) {\n            return createStaticDecl(function (env, scope) {\n              return scope.def(env.ELEMENTS, '.primType');\n            });\n          } else {\n            return createStaticDecl(function () {\n              return GL_TRIANGLES$1;\n            });\n          }\n        } else {\n          return new Declaration(elements.thisDep, elements.contextDep, elements.propDep, function (env, scope) {\n            var elements = env.ELEMENTS;\n            return scope.def(elements, '?', elements, '.primType:', GL_TRIANGLES$1);\n          });\n        }\n      }\n      return null;\n    }\n\n    function parseParam(param, isOffset) {\n      if (param in staticOptions) {\n        var value = staticOptions[param] | 0;\n        check$1.command(!isOffset || value >= 0, 'invalid ' + param, env.commandStr);\n        return createStaticDecl(function (env, scope) {\n          if (isOffset) {\n            env.OFFSET = value;\n          }\n          return value;\n        });\n      } else if (param in dynamicOptions) {\n        var dynValue = dynamicOptions[param];\n        return createDynamicDecl(dynValue, function (env, scope) {\n          var result = env.invoke(scope, dynValue);\n          if (isOffset) {\n            env.OFFSET = result;\n            check$1.optional(function () {\n              env.assert(scope, result + '>=0', 'invalid ' + param);\n            });\n          }\n          return result;\n        });\n      } else if (isOffset && elements) {\n        return createStaticDecl(function (env, scope) {\n          env.OFFSET = '0';\n          return 0;\n        });\n      }\n      return null;\n    }\n\n    var OFFSET = parseParam(S_OFFSET, true);\n\n    function parseVertCount() {\n      if (S_COUNT in staticOptions) {\n        var count = staticOptions[S_COUNT] | 0;\n        check$1.command(typeof count === 'number' && count >= 0, 'invalid vertex count', env.commandStr);\n        return createStaticDecl(function () {\n          return count;\n        });\n      } else if (S_COUNT in dynamicOptions) {\n        var dynCount = dynamicOptions[S_COUNT];\n        return createDynamicDecl(dynCount, function (env, scope) {\n          var result = env.invoke(scope, dynCount);\n          check$1.optional(function () {\n            env.assert(scope, 'typeof ' + result + '===\"number\"&&' + result + '>=0&&' + result + '===(' + result + '|0)', 'invalid vertex count');\n          });\n          return result;\n        });\n      } else if (elements) {\n        if (isStatic(elements)) {\n          if (elements) {\n            if (OFFSET) {\n              return new Declaration(OFFSET.thisDep, OFFSET.contextDep, OFFSET.propDep, function (env, scope) {\n                var result = scope.def(env.ELEMENTS, '.vertCount-', env.OFFSET);\n\n                check$1.optional(function () {\n                  env.assert(scope, result + '>=0', 'invalid vertex offset/element buffer too small');\n                });\n\n                return result;\n              });\n            } else {\n              return createStaticDecl(function (env, scope) {\n                return scope.def(env.ELEMENTS, '.vertCount');\n              });\n            }\n          } else {\n            var result = createStaticDecl(function () {\n              return -1;\n            });\n            check$1.optional(function () {\n              result.MISSING = true;\n            });\n            return result;\n          }\n        } else {\n          var variable = new Declaration(elements.thisDep || OFFSET.thisDep, elements.contextDep || OFFSET.contextDep, elements.propDep || OFFSET.propDep, function (env, scope) {\n            var elements = env.ELEMENTS;\n            if (env.OFFSET) {\n              return scope.def(elements, '?', elements, '.vertCount-', env.OFFSET, ':-1');\n            }\n            return scope.def(elements, '?', elements, '.vertCount:-1');\n          });\n          check$1.optional(function () {\n            variable.DYNAMIC = true;\n          });\n          return variable;\n        }\n      }\n      return null;\n    }\n\n    return {\n      elements: elements,\n      primitive: parsePrimitive(),\n      count: parseVertCount(),\n      instances: parseParam(S_INSTANCES, false),\n      offset: OFFSET\n    };\n  }\n\n  function parseGLState(options, env) {\n    var staticOptions = options.static;\n    var dynamicOptions = options.dynamic;\n\n    var STATE = {};\n\n    GL_STATE_NAMES.forEach(function (prop) {\n      var param = propName(prop);\n\n      function parseParam(parseStatic, parseDynamic) {\n        if (prop in staticOptions) {\n          var value = parseStatic(staticOptions[prop]);\n          STATE[param] = createStaticDecl(function () {\n            return value;\n          });\n        } else if (prop in dynamicOptions) {\n          var dyn = dynamicOptions[prop];\n          STATE[param] = createDynamicDecl(dyn, function (env, scope) {\n            return parseDynamic(env, scope, env.invoke(scope, dyn));\n          });\n        }\n      }\n\n      switch (prop) {\n        case S_CULL_ENABLE:\n        case S_BLEND_ENABLE:\n        case S_DITHER:\n        case S_STENCIL_ENABLE:\n        case S_DEPTH_ENABLE:\n        case S_SCISSOR_ENABLE:\n        case S_POLYGON_OFFSET_ENABLE:\n        case S_SAMPLE_ALPHA:\n        case S_SAMPLE_ENABLE:\n        case S_DEPTH_MASK:\n          return parseParam(function (value) {\n            check$1.commandType(value, 'boolean', prop, env.commandStr);\n            return value;\n          }, function (env, scope, value) {\n            check$1.optional(function () {\n              env.assert(scope, 'typeof ' + value + '===\"boolean\"', 'invalid flag ' + prop, env.commandStr);\n            });\n            return value;\n          });\n\n        case S_DEPTH_FUNC:\n          return parseParam(function (value) {\n            check$1.commandParameter(value, compareFuncs, 'invalid ' + prop, env.commandStr);\n            return compareFuncs[value];\n          }, function (env, scope, value) {\n            var COMPARE_FUNCS = env.constants.compareFuncs;\n            check$1.optional(function () {\n              env.assert(scope, value + ' in ' + COMPARE_FUNCS, 'invalid ' + prop + ', must be one of ' + Object.keys(compareFuncs));\n            });\n            return scope.def(COMPARE_FUNCS, '[', value, ']');\n          });\n\n        case S_DEPTH_RANGE:\n          return parseParam(function (value) {\n            check$1.command(isArrayLike(value) && value.length === 2 && typeof value[0] === 'number' && typeof value[1] === 'number' && value[0] <= value[1], 'depth range is 2d array', env.commandStr);\n            return value;\n          }, function (env, scope, value) {\n            check$1.optional(function () {\n              env.assert(scope, env.shared.isArrayLike + '(' + value + ')&&' + value + '.length===2&&' + 'typeof ' + value + '[0]===\"number\"&&' + 'typeof ' + value + '[1]===\"number\"&&' + value + '[0]<=' + value + '[1]', 'depth range must be a 2d array');\n            });\n\n            var Z_NEAR = scope.def('+', value, '[0]');\n            var Z_FAR = scope.def('+', value, '[1]');\n            return [Z_NEAR, Z_FAR];\n          });\n\n        case S_BLEND_FUNC:\n          return parseParam(function (value) {\n            check$1.commandType(value, 'object', 'blend.func', env.commandStr);\n            var srcRGB = 'srcRGB' in value ? value.srcRGB : value.src;\n            var srcAlpha = 'srcAlpha' in value ? value.srcAlpha : value.src;\n            var dstRGB = 'dstRGB' in value ? value.dstRGB : value.dst;\n            var dstAlpha = 'dstAlpha' in value ? value.dstAlpha : value.dst;\n            check$1.commandParameter(srcRGB, blendFuncs, param + '.srcRGB', env.commandStr);\n            check$1.commandParameter(srcAlpha, blendFuncs, param + '.srcAlpha', env.commandStr);\n            check$1.commandParameter(dstRGB, blendFuncs, param + '.dstRGB', env.commandStr);\n            check$1.commandParameter(dstAlpha, blendFuncs, param + '.dstAlpha', env.commandStr);\n\n            check$1.command(invalidBlendCombinations.indexOf(srcRGB + ', ' + dstRGB) === -1, 'unallowed blending combination (srcRGB, dstRGB) = (' + srcRGB + ', ' + dstRGB + ')', env.commandStr);\n\n            return [blendFuncs[srcRGB], blendFuncs[dstRGB], blendFuncs[srcAlpha], blendFuncs[dstAlpha]];\n          }, function (env, scope, value) {\n            var BLEND_FUNCS = env.constants.blendFuncs;\n\n            check$1.optional(function () {\n              env.assert(scope, value + '&&typeof ' + value + '===\"object\"', 'invalid blend func, must be an object');\n            });\n\n            function read(prefix, suffix) {\n              var func = scope.def('\"', prefix, suffix, '\" in ', value, '?', value, '.', prefix, suffix, ':', value, '.', prefix);\n\n              check$1.optional(function () {\n                env.assert(scope, func + ' in ' + BLEND_FUNCS, 'invalid ' + prop + '.' + prefix + suffix + ', must be one of ' + Object.keys(blendFuncs));\n              });\n\n              return func;\n            }\n\n            var srcRGB = read('src', 'RGB');\n            var dstRGB = read('dst', 'RGB');\n\n            check$1.optional(function () {\n              var INVALID_BLEND_COMBINATIONS = env.constants.invalidBlendCombinations;\n\n              env.assert(scope, INVALID_BLEND_COMBINATIONS + '.indexOf(' + srcRGB + '+\", \"+' + dstRGB + ') === -1 ', 'unallowed blending combination for (srcRGB, dstRGB)');\n            });\n\n            var SRC_RGB = scope.def(BLEND_FUNCS, '[', srcRGB, ']');\n            var SRC_ALPHA = scope.def(BLEND_FUNCS, '[', read('src', 'Alpha'), ']');\n            var DST_RGB = scope.def(BLEND_FUNCS, '[', dstRGB, ']');\n            var DST_ALPHA = scope.def(BLEND_FUNCS, '[', read('dst', 'Alpha'), ']');\n\n            return [SRC_RGB, DST_RGB, SRC_ALPHA, DST_ALPHA];\n          });\n\n        case S_BLEND_EQUATION:\n          return parseParam(function (value) {\n            if (typeof value === 'string') {\n              check$1.commandParameter(value, blendEquations, 'invalid ' + prop, env.commandStr);\n              return [blendEquations[value], blendEquations[value]];\n            } else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {\n              check$1.commandParameter(value.rgb, blendEquations, prop + '.rgb', env.commandStr);\n              check$1.commandParameter(value.alpha, blendEquations, prop + '.alpha', env.commandStr);\n              return [blendEquations[value.rgb], blendEquations[value.alpha]];\n            } else {\n              check$1.commandRaise('invalid blend.equation', env.commandStr);\n            }\n          }, function (env, scope, value) {\n            var BLEND_EQUATIONS = env.constants.blendEquations;\n\n            var RGB = scope.def();\n            var ALPHA = scope.def();\n\n            var ifte = env.cond('typeof ', value, '===\"string\"');\n\n            check$1.optional(function () {\n              function checkProp(block, name, value) {\n                env.assert(block, value + ' in ' + BLEND_EQUATIONS, 'invalid ' + name + ', must be one of ' + Object.keys(blendEquations));\n              }\n              checkProp(ifte.then, prop, value);\n\n              env.assert(ifte.else, value + '&&typeof ' + value + '===\"object\"', 'invalid ' + prop);\n              checkProp(ifte.else, prop + '.rgb', value + '.rgb');\n              checkProp(ifte.else, prop + '.alpha', value + '.alpha');\n            });\n\n            ifte.then(RGB, '=', ALPHA, '=', BLEND_EQUATIONS, '[', value, '];');\n            ifte.else(RGB, '=', BLEND_EQUATIONS, '[', value, '.rgb];', ALPHA, '=', BLEND_EQUATIONS, '[', value, '.alpha];');\n\n            scope(ifte);\n\n            return [RGB, ALPHA];\n          });\n\n        case S_BLEND_COLOR:\n          return parseParam(function (value) {\n            check$1.command(isArrayLike(value) && value.length === 4, 'blend.color must be a 4d array', env.commandStr);\n            return loop(4, function (i) {\n              return +value[i];\n            });\n          }, function (env, scope, value) {\n            check$1.optional(function () {\n              env.assert(scope, env.shared.isArrayLike + '(' + value + ')&&' + value + '.length===4', 'blend.color must be a 4d array');\n            });\n            return loop(4, function (i) {\n              return scope.def('+', value, '[', i, ']');\n            });\n          });\n\n        case S_STENCIL_MASK:\n          return parseParam(function (value) {\n            check$1.commandType(value, 'number', param, env.commandStr);\n            return value | 0;\n          }, function (env, scope, value) {\n            check$1.optional(function () {\n              env.assert(scope, 'typeof ' + value + '===\"number\"', 'invalid stencil.mask');\n            });\n            return scope.def(value, '|0');\n          });\n\n        case S_STENCIL_FUNC:\n          return parseParam(function (value) {\n            check$1.commandType(value, 'object', param, env.commandStr);\n            var cmp = value.cmp || 'keep';\n            var ref = value.ref || 0;\n            var mask = 'mask' in value ? value.mask : -1;\n            check$1.commandParameter(cmp, compareFuncs, prop + '.cmp', env.commandStr);\n            check$1.commandType(ref, 'number', prop + '.ref', env.commandStr);\n            check$1.commandType(mask, 'number', prop + '.mask', env.commandStr);\n            return [compareFuncs[cmp], ref, mask];\n          }, function (env, scope, value) {\n            var COMPARE_FUNCS = env.constants.compareFuncs;\n            check$1.optional(function () {\n              function assert() {\n                env.assert(scope, Array.prototype.join.call(arguments, ''), 'invalid stencil.func');\n              }\n              assert(value + '&&typeof ', value, '===\"object\"');\n              assert('!(\"cmp\" in ', value, ')||(', value, '.cmp in ', COMPARE_FUNCS, ')');\n            });\n            var cmp = scope.def('\"cmp\" in ', value, '?', COMPARE_FUNCS, '[', value, '.cmp]', ':', GL_KEEP);\n            var ref = scope.def(value, '.ref|0');\n            var mask = scope.def('\"mask\" in ', value, '?', value, '.mask|0:-1');\n            return [cmp, ref, mask];\n          });\n\n        case S_STENCIL_OPFRONT:\n        case S_STENCIL_OPBACK:\n          return parseParam(function (value) {\n            check$1.commandType(value, 'object', param, env.commandStr);\n            var fail = value.fail || 'keep';\n            var zfail = value.zfail || 'keep';\n            var zpass = value.zpass || 'keep';\n            check$1.commandParameter(fail, stencilOps, prop + '.fail', env.commandStr);\n            check$1.commandParameter(zfail, stencilOps, prop + '.zfail', env.commandStr);\n            check$1.commandParameter(zpass, stencilOps, prop + '.zpass', env.commandStr);\n            return [prop === S_STENCIL_OPBACK ? GL_BACK : GL_FRONT, stencilOps[fail], stencilOps[zfail], stencilOps[zpass]];\n          }, function (env, scope, value) {\n            var STENCIL_OPS = env.constants.stencilOps;\n\n            check$1.optional(function () {\n              env.assert(scope, value + '&&typeof ' + value + '===\"object\"', 'invalid ' + prop);\n            });\n\n            function read(name) {\n              check$1.optional(function () {\n                env.assert(scope, '!(\"' + name + '\" in ' + value + ')||' + '(' + value + '.' + name + ' in ' + STENCIL_OPS + ')', 'invalid ' + prop + '.' + name + ', must be one of ' + Object.keys(stencilOps));\n              });\n\n              return scope.def('\"', name, '\" in ', value, '?', STENCIL_OPS, '[', value, '.', name, ']:', GL_KEEP);\n            }\n\n            return [prop === S_STENCIL_OPBACK ? GL_BACK : GL_FRONT, read('fail'), read('zfail'), read('zpass')];\n          });\n\n        case S_POLYGON_OFFSET_OFFSET:\n          return parseParam(function (value) {\n            check$1.commandType(value, 'object', param, env.commandStr);\n            var factor = value.factor | 0;\n            var units = value.units | 0;\n            check$1.commandType(factor, 'number', param + '.factor', env.commandStr);\n            check$1.commandType(units, 'number', param + '.units', env.commandStr);\n            return [factor, units];\n          }, function (env, scope, value) {\n            check$1.optional(function () {\n              env.assert(scope, value + '&&typeof ' + value + '===\"object\"', 'invalid ' + prop);\n            });\n\n            var FACTOR = scope.def(value, '.factor|0');\n            var UNITS = scope.def(value, '.units|0');\n\n            return [FACTOR, UNITS];\n          });\n\n        case S_CULL_FACE:\n          return parseParam(function (value) {\n            var face = 0;\n            if (value === 'front') {\n              face = GL_FRONT;\n            } else if (value === 'back') {\n              face = GL_BACK;\n            }\n            check$1.command(!!face, param, env.commandStr);\n            return face;\n          }, function (env, scope, value) {\n            check$1.optional(function () {\n              env.assert(scope, value + '===\"front\"||' + value + '===\"back\"', 'invalid cull.face');\n            });\n            return scope.def(value, '===\"front\"?', GL_FRONT, ':', GL_BACK);\n          });\n\n        case S_LINE_WIDTH:\n          return parseParam(function (value) {\n            check$1.command(typeof value === 'number' && value >= limits.lineWidthDims[0] && value <= limits.lineWidthDims[1], 'invalid line width, must be a positive number between ' + limits.lineWidthDims[0] + ' and ' + limits.lineWidthDims[1], env.commandStr);\n            return value;\n          }, function (env, scope, value) {\n            check$1.optional(function () {\n              env.assert(scope, 'typeof ' + value + '===\"number\"&&' + value + '>=' + limits.lineWidthDims[0] + '&&' + value + '<=' + limits.lineWidthDims[1], 'invalid line width');\n            });\n\n            return value;\n          });\n\n        case S_FRONT_FACE:\n          return parseParam(function (value) {\n            check$1.commandParameter(value, orientationType, param, env.commandStr);\n            return orientationType[value];\n          }, function (env, scope, value) {\n            check$1.optional(function () {\n              env.assert(scope, value + '===\"cw\"||' + value + '===\"ccw\"', 'invalid frontFace, must be one of cw,ccw');\n            });\n            return scope.def(value + '===\"cw\"?' + GL_CW + ':' + GL_CCW);\n          });\n\n        case S_COLOR_MASK:\n          return parseParam(function (value) {\n            check$1.command(isArrayLike(value) && value.length === 4, 'color.mask must be length 4 array', env.commandStr);\n            return value.map(function (v) {\n              return !!v;\n            });\n          }, function (env, scope, value) {\n            check$1.optional(function () {\n              env.assert(scope, env.shared.isArrayLike + '(' + value + ')&&' + value + '.length===4', 'invalid color.mask');\n            });\n            return loop(4, function (i) {\n              return '!!' + value + '[' + i + ']';\n            });\n          });\n\n        case S_SAMPLE_COVERAGE:\n          return parseParam(function (value) {\n            check$1.command((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value, param, env.commandStr);\n            var sampleValue = 'value' in value ? value.value : 1;\n            var sampleInvert = !!value.invert;\n            check$1.command(typeof sampleValue === 'number' && sampleValue >= 0 && sampleValue <= 1, 'sample.coverage.value must be a number between 0 and 1', env.commandStr);\n            return [sampleValue, sampleInvert];\n          }, function (env, scope, value) {\n            check$1.optional(function () {\n              env.assert(scope, value + '&&typeof ' + value + '===\"object\"', 'invalid sample.coverage');\n            });\n            var VALUE = scope.def('\"value\" in ', value, '?+', value, '.value:1');\n            var INVERT = scope.def('!!', value, '.invert');\n            return [VALUE, INVERT];\n          });\n      }\n    });\n\n    return STATE;\n  }\n\n  function parseUniforms(uniforms, env) {\n    var staticUniforms = uniforms.static;\n    var dynamicUniforms = uniforms.dynamic;\n\n    var UNIFORMS = {};\n\n    Object.keys(staticUniforms).forEach(function (name) {\n      var value = staticUniforms[name];\n      var result;\n      if (typeof value === 'number' || typeof value === 'boolean') {\n        result = createStaticDecl(function () {\n          return value;\n        });\n      } else if (typeof value === 'function') {\n        var reglType = value._reglType;\n        if (reglType === 'texture2d' || reglType === 'textureCube') {\n          result = createStaticDecl(function (env) {\n            return env.link(value);\n          });\n        } else if (reglType === 'framebuffer' || reglType === 'framebufferCube') {\n          check$1.command(value.color.length > 0, 'missing color attachment for framebuffer sent to uniform \"' + name + '\"', env.commandStr);\n          result = createStaticDecl(function (env) {\n            return env.link(value.color[0]);\n          });\n        } else {\n          check$1.commandRaise('invalid data for uniform \"' + name + '\"', env.commandStr);\n        }\n      } else if (isArrayLike(value)) {\n        result = createStaticDecl(function (env) {\n          var ITEM = env.global.def('[', loop(value.length, function (i) {\n            check$1.command(typeof value[i] === 'number' || typeof value[i] === 'boolean', 'invalid uniform ' + name, env.commandStr);\n            return value[i];\n          }), ']');\n          return ITEM;\n        });\n      } else {\n        check$1.commandRaise('invalid or missing data for uniform \"' + name + '\"', env.commandStr);\n      }\n      result.value = value;\n      UNIFORMS[name] = result;\n    });\n\n    Object.keys(dynamicUniforms).forEach(function (key) {\n      var dyn = dynamicUniforms[key];\n      UNIFORMS[key] = createDynamicDecl(dyn, function (env, scope) {\n        return env.invoke(scope, dyn);\n      });\n    });\n\n    return UNIFORMS;\n  }\n\n  function parseAttributes(attributes, env) {\n    var staticAttributes = attributes.static;\n    var dynamicAttributes = attributes.dynamic;\n\n    var attributeDefs = {};\n\n    Object.keys(staticAttributes).forEach(function (attribute) {\n      var value = staticAttributes[attribute];\n      var id = stringStore.id(attribute);\n\n      var record = new AttributeRecord();\n      if (isBufferArgs(value)) {\n        record.state = ATTRIB_STATE_POINTER;\n        record.buffer = bufferState.getBuffer(bufferState.create(value, GL_ARRAY_BUFFER$1, false, true));\n        record.type = 0;\n      } else {\n        var buffer = bufferState.getBuffer(value);\n        if (buffer) {\n          record.state = ATTRIB_STATE_POINTER;\n          record.buffer = buffer;\n          record.type = 0;\n        } else {\n          check$1.command((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value, 'invalid data for attribute ' + attribute, env.commandStr);\n          if ('constant' in value) {\n            var constant = value.constant;\n            record.buffer = 'null';\n            record.state = ATTRIB_STATE_CONSTANT;\n            if (typeof constant === 'number') {\n              record.x = constant;\n            } else {\n              check$1.command(isArrayLike(constant) && constant.length > 0 && constant.length <= 4, 'invalid constant for attribute ' + attribute, env.commandStr);\n              CUTE_COMPONENTS.forEach(function (c, i) {\n                if (i < constant.length) {\n                  record[c] = constant[i];\n                }\n              });\n            }\n          } else {\n            if (isBufferArgs(value.buffer)) {\n              buffer = bufferState.getBuffer(bufferState.create(value.buffer, GL_ARRAY_BUFFER$1, false, true));\n            } else {\n              buffer = bufferState.getBuffer(value.buffer);\n            }\n            check$1.command(!!buffer, 'missing buffer for attribute \"' + attribute + '\"', env.commandStr);\n\n            var offset = value.offset | 0;\n            check$1.command(offset >= 0, 'invalid offset for attribute \"' + attribute + '\"', env.commandStr);\n\n            var stride = value.stride | 0;\n            check$1.command(stride >= 0 && stride < 256, 'invalid stride for attribute \"' + attribute + '\", must be integer betweeen [0, 255]', env.commandStr);\n\n            var size = value.size | 0;\n            check$1.command(!('size' in value) || size > 0 && size <= 4, 'invalid size for attribute \"' + attribute + '\", must be 1,2,3,4', env.commandStr);\n\n            var normalized = !!value.normalized;\n\n            var type = 0;\n            if ('type' in value) {\n              check$1.commandParameter(value.type, glTypes, 'invalid type for attribute ' + attribute, env.commandStr);\n              type = glTypes[value.type];\n            }\n\n            var divisor = value.divisor | 0;\n            if ('divisor' in value) {\n              check$1.command(divisor === 0 || extInstancing, 'cannot specify divisor for attribute \"' + attribute + '\", instancing not supported', env.commandStr);\n              check$1.command(divisor >= 0, 'invalid divisor for attribute \"' + attribute + '\"', env.commandStr);\n            }\n\n            check$1.optional(function () {\n              var command = env.commandStr;\n\n              var VALID_KEYS = ['buffer', 'offset', 'divisor', 'normalized', 'type', 'size', 'stride'];\n\n              Object.keys(value).forEach(function (prop) {\n                check$1.command(VALID_KEYS.indexOf(prop) >= 0, 'unknown parameter \"' + prop + '\" for attribute pointer \"' + attribute + '\" (valid parameters are ' + VALID_KEYS + ')', command);\n              });\n            });\n\n            record.buffer = buffer;\n            record.state = ATTRIB_STATE_POINTER;\n            record.size = size;\n            record.normalized = normalized;\n            record.type = type || buffer.dtype;\n            record.offset = offset;\n            record.stride = stride;\n            record.divisor = divisor;\n          }\n        }\n      }\n\n      attributeDefs[attribute] = createStaticDecl(function (env, scope) {\n        var cache = env.attribCache;\n        if (id in cache) {\n          return cache[id];\n        }\n        var result = {\n          isStream: false\n        };\n        Object.keys(record).forEach(function (key) {\n          result[key] = record[key];\n        });\n        if (record.buffer) {\n          result.buffer = env.link(record.buffer);\n          result.type = result.type || result.buffer + '.dtype';\n        }\n        cache[id] = result;\n        return result;\n      });\n    });\n\n    Object.keys(dynamicAttributes).forEach(function (attribute) {\n      var dyn = dynamicAttributes[attribute];\n\n      function appendAttributeCode(env, block) {\n        var VALUE = env.invoke(block, dyn);\n\n        var shared = env.shared;\n\n        var IS_BUFFER_ARGS = shared.isBufferArgs;\n        var BUFFER_STATE = shared.buffer;\n\n        // Perform validation on attribute\n        check$1.optional(function () {\n          env.assert(block, VALUE + '&&(typeof ' + VALUE + '===\"object\"||typeof ' + VALUE + '===\"function\")&&(' + IS_BUFFER_ARGS + '(' + VALUE + ')||' + BUFFER_STATE + '.getBuffer(' + VALUE + ')||' + BUFFER_STATE + '.getBuffer(' + VALUE + '.buffer)||' + IS_BUFFER_ARGS + '(' + VALUE + '.buffer)||' + '(\"constant\" in ' + VALUE + '&&(typeof ' + VALUE + '.constant===\"number\"||' + shared.isArrayLike + '(' + VALUE + '.constant))))', 'invalid dynamic attribute \"' + attribute + '\"');\n        });\n\n        // allocate names for result\n        var result = {\n          isStream: block.def(false)\n        };\n        var defaultRecord = new AttributeRecord();\n        defaultRecord.state = ATTRIB_STATE_POINTER;\n        Object.keys(defaultRecord).forEach(function (key) {\n          result[key] = block.def('' + defaultRecord[key]);\n        });\n\n        var BUFFER = result.buffer;\n        var TYPE = result.type;\n        block('if(', IS_BUFFER_ARGS, '(', VALUE, ')){', result.isStream, '=true;', BUFFER, '=', BUFFER_STATE, '.createStream(', GL_ARRAY_BUFFER$1, ',', VALUE, ');', TYPE, '=', BUFFER, '.dtype;', '}else{', BUFFER, '=', BUFFER_STATE, '.getBuffer(', VALUE, ');', 'if(', BUFFER, '){', TYPE, '=', BUFFER, '.dtype;', '}else if(\"constant\" in ', VALUE, '){', result.state, '=', ATTRIB_STATE_CONSTANT, ';', 'if(typeof ' + VALUE + '.constant === \"number\"){', result[CUTE_COMPONENTS[0]], '=', VALUE, '.constant;', CUTE_COMPONENTS.slice(1).map(function (n) {\n          return result[n];\n        }).join('='), '=0;', '}else{', CUTE_COMPONENTS.map(function (name, i) {\n          return result[name] + '=' + VALUE + '.constant.length>' + i + '?' + VALUE + '.constant[' + i + ']:0;';\n        }).join(''), '}}else{', 'if(', IS_BUFFER_ARGS, '(', VALUE, '.buffer)){', BUFFER, '=', BUFFER_STATE, '.createStream(', GL_ARRAY_BUFFER$1, ',', VALUE, '.buffer);', '}else{', BUFFER, '=', BUFFER_STATE, '.getBuffer(', VALUE, '.buffer);', '}', TYPE, '=\"type\" in ', VALUE, '?', shared.glTypes, '[', VALUE, '.type]:', BUFFER, '.dtype;', result.normalized, '=!!', VALUE, '.normalized;');\n        function emitReadRecord(name) {\n          block(result[name], '=', VALUE, '.', name, '|0;');\n        }\n        emitReadRecord('size');\n        emitReadRecord('offset');\n        emitReadRecord('stride');\n        emitReadRecord('divisor');\n\n        block('}}');\n\n        block.exit('if(', result.isStream, '){', BUFFER_STATE, '.destroyStream(', BUFFER, ');', '}');\n\n        return result;\n      }\n\n      attributeDefs[attribute] = createDynamicDecl(dyn, appendAttributeCode);\n    });\n\n    return attributeDefs;\n  }\n\n  function parseContext(context) {\n    var staticContext = context.static;\n    var dynamicContext = context.dynamic;\n    var result = {};\n\n    Object.keys(staticContext).forEach(function (name) {\n      var value = staticContext[name];\n      result[name] = createStaticDecl(function (env, scope) {\n        if (typeof value === 'number' || typeof value === 'boolean') {\n          return '' + value;\n        } else {\n          return env.link(value);\n        }\n      });\n    });\n\n    Object.keys(dynamicContext).forEach(function (name) {\n      var dyn = dynamicContext[name];\n      result[name] = createDynamicDecl(dyn, function (env, scope) {\n        return env.invoke(scope, dyn);\n      });\n    });\n\n    return result;\n  }\n\n  function parseArguments(options, attributes, uniforms, context, env) {\n    var staticOptions = options.static;\n    var dynamicOptions = options.dynamic;\n\n    check$1.optional(function () {\n      var KEY_NAMES = [S_FRAMEBUFFER, S_VERT, S_FRAG, S_ELEMENTS, S_PRIMITIVE, S_OFFSET, S_COUNT, S_INSTANCES, S_PROFILE].concat(GL_STATE_NAMES);\n\n      function checkKeys(dict) {\n        Object.keys(dict).forEach(function (key) {\n          check$1.command(KEY_NAMES.indexOf(key) >= 0, 'unknown parameter \"' + key + '\"', env.commandStr);\n        });\n      }\n\n      checkKeys(staticOptions);\n      checkKeys(dynamicOptions);\n    });\n\n    var framebuffer = parseFramebuffer(options, env);\n    var viewportAndScissor = parseViewportScissor(options, framebuffer, env);\n    var draw = parseDraw(options, env);\n    var state = parseGLState(options, env);\n    var shader = parseProgram(options, env);\n\n    function copyBox(name) {\n      var defn = viewportAndScissor[name];\n      if (defn) {\n        state[name] = defn;\n      }\n    }\n    copyBox(S_VIEWPORT);\n    copyBox(propName(S_SCISSOR_BOX));\n\n    var dirty = Object.keys(state).length > 0;\n\n    var result = {\n      framebuffer: framebuffer,\n      draw: draw,\n      shader: shader,\n      state: state,\n      dirty: dirty\n    };\n\n    result.profile = parseProfile(options, env);\n    result.uniforms = parseUniforms(uniforms, env);\n    result.attributes = parseAttributes(attributes, env);\n    result.context = parseContext(context, env);\n    return result;\n  }\n\n  // ===================================================\n  // ===================================================\n  // COMMON UPDATE FUNCTIONS\n  // ===================================================\n  // ===================================================\n  function emitContext(env, scope, context) {\n    var shared = env.shared;\n    var CONTEXT = shared.context;\n\n    var contextEnter = env.scope();\n\n    Object.keys(context).forEach(function (name) {\n      scope.save(CONTEXT, '.' + name);\n      var defn = context[name];\n      contextEnter(CONTEXT, '.', name, '=', defn.append(env, scope), ';');\n    });\n\n    scope(contextEnter);\n  }\n\n  // ===================================================\n  // ===================================================\n  // COMMON DRAWING FUNCTIONS\n  // ===================================================\n  // ===================================================\n  function emitPollFramebuffer(env, scope, framebuffer, skipCheck) {\n    var shared = env.shared;\n\n    var GL = shared.gl;\n    var FRAMEBUFFER_STATE = shared.framebuffer;\n    var EXT_DRAW_BUFFERS;\n    if (extDrawBuffers) {\n      EXT_DRAW_BUFFERS = scope.def(shared.extensions, '.webgl_draw_buffers');\n    }\n\n    var constants = env.constants;\n\n    var DRAW_BUFFERS = constants.drawBuffer;\n    var BACK_BUFFER = constants.backBuffer;\n\n    var NEXT;\n    if (framebuffer) {\n      NEXT = framebuffer.append(env, scope);\n    } else {\n      NEXT = scope.def(FRAMEBUFFER_STATE, '.next');\n    }\n\n    if (!skipCheck) {\n      scope('if(', NEXT, '!==', FRAMEBUFFER_STATE, '.cur){');\n    }\n    scope('if(', NEXT, '){', GL, '.bindFramebuffer(', GL_FRAMEBUFFER$2, ',', NEXT, '.framebuffer);');\n    if (extDrawBuffers) {\n      scope(EXT_DRAW_BUFFERS, '.drawBuffersWEBGL(', DRAW_BUFFERS, '[', NEXT, '.colorAttachments.length]);');\n    }\n    scope('}else{', GL, '.bindFramebuffer(', GL_FRAMEBUFFER$2, ',null);');\n    if (extDrawBuffers) {\n      scope(EXT_DRAW_BUFFERS, '.drawBuffersWEBGL(', BACK_BUFFER, ');');\n    }\n    scope('}', FRAMEBUFFER_STATE, '.cur=', NEXT, ';');\n    if (!skipCheck) {\n      scope('}');\n    }\n  }\n\n  function emitPollState(env, scope, args) {\n    var shared = env.shared;\n\n    var GL = shared.gl;\n\n    var CURRENT_VARS = env.current;\n    var NEXT_VARS = env.next;\n    var CURRENT_STATE = shared.current;\n    var NEXT_STATE = shared.next;\n\n    var block = env.cond(CURRENT_STATE, '.dirty');\n\n    GL_STATE_NAMES.forEach(function (prop) {\n      var param = propName(prop);\n      if (param in args.state) {\n        return;\n      }\n\n      var NEXT, CURRENT;\n      if (param in NEXT_VARS) {\n        NEXT = NEXT_VARS[param];\n        CURRENT = CURRENT_VARS[param];\n        var parts = loop(currentState[param].length, function (i) {\n          return block.def(NEXT, '[', i, ']');\n        });\n        block(env.cond(parts.map(function (p, i) {\n          return p + '!==' + CURRENT + '[' + i + ']';\n        }).join('||')).then(GL, '.', GL_VARIABLES[param], '(', parts, ');', parts.map(function (p, i) {\n          return CURRENT + '[' + i + ']=' + p;\n        }).join(';'), ';'));\n      } else {\n        NEXT = block.def(NEXT_STATE, '.', param);\n        var ifte = env.cond(NEXT, '!==', CURRENT_STATE, '.', param);\n        block(ifte);\n        if (param in GL_FLAGS) {\n          ifte(env.cond(NEXT).then(GL, '.enable(', GL_FLAGS[param], ');').else(GL, '.disable(', GL_FLAGS[param], ');'), CURRENT_STATE, '.', param, '=', NEXT, ';');\n        } else {\n          ifte(GL, '.', GL_VARIABLES[param], '(', NEXT, ');', CURRENT_STATE, '.', param, '=', NEXT, ';');\n        }\n      }\n    });\n    if (Object.keys(args.state).length === 0) {\n      block(CURRENT_STATE, '.dirty=false;');\n    }\n    scope(block);\n  }\n\n  function emitSetOptions(env, scope, options, filter) {\n    var shared = env.shared;\n    var CURRENT_VARS = env.current;\n    var CURRENT_STATE = shared.current;\n    var GL = shared.gl;\n    sortState(Object.keys(options)).forEach(function (param) {\n      var defn = options[param];\n      if (filter && !filter(defn)) {\n        return;\n      }\n      var variable = defn.append(env, scope);\n      if (GL_FLAGS[param]) {\n        var flag = GL_FLAGS[param];\n        if (isStatic(defn)) {\n          if (variable) {\n            scope(GL, '.enable(', flag, ');');\n          } else {\n            scope(GL, '.disable(', flag, ');');\n          }\n        } else {\n          scope(env.cond(variable).then(GL, '.enable(', flag, ');').else(GL, '.disable(', flag, ');'));\n        }\n        scope(CURRENT_STATE, '.', param, '=', variable, ';');\n      } else if (isArrayLike(variable)) {\n        var CURRENT = CURRENT_VARS[param];\n        scope(GL, '.', GL_VARIABLES[param], '(', variable, ');', variable.map(function (v, i) {\n          return CURRENT + '[' + i + ']=' + v;\n        }).join(';'), ';');\n      } else {\n        scope(GL, '.', GL_VARIABLES[param], '(', variable, ');', CURRENT_STATE, '.', param, '=', variable, ';');\n      }\n    });\n  }\n\n  function injectExtensions(env, scope) {\n    if (extInstancing) {\n      env.instancing = scope.def(env.shared.extensions, '.angle_instanced_arrays');\n    }\n  }\n\n  function emitProfile(env, scope, args, useScope, incrementCounter) {\n    var shared = env.shared;\n    var STATS = env.stats;\n    var CURRENT_STATE = shared.current;\n    var TIMER = shared.timer;\n    var profileArg = args.profile;\n\n    function perfCounter() {\n      if (typeof performance === 'undefined') {\n        return 'Date.now()';\n      } else {\n        return 'performance.now()';\n      }\n    }\n\n    var CPU_START, QUERY_COUNTER;\n    function emitProfileStart(block) {\n      CPU_START = scope.def();\n      block(CPU_START, '=', perfCounter(), ';');\n      if (typeof incrementCounter === 'string') {\n        block(STATS, '.count+=', incrementCounter, ';');\n      } else {\n        block(STATS, '.count++;');\n      }\n      if (timer) {\n        if (useScope) {\n          QUERY_COUNTER = scope.def();\n          block(QUERY_COUNTER, '=', TIMER, '.getNumPendingQueries();');\n        } else {\n          block(TIMER, '.beginQuery(', STATS, ');');\n        }\n      }\n    }\n\n    function emitProfileEnd(block) {\n      block(STATS, '.cpuTime+=', perfCounter(), '-', CPU_START, ';');\n      if (timer) {\n        if (useScope) {\n          block(TIMER, '.pushScopeStats(', QUERY_COUNTER, ',', TIMER, '.getNumPendingQueries(),', STATS, ');');\n        } else {\n          block(TIMER, '.endQuery();');\n        }\n      }\n    }\n\n    function scopeProfile(value) {\n      var prev = scope.def(CURRENT_STATE, '.profile');\n      scope(CURRENT_STATE, '.profile=', value, ';');\n      scope.exit(CURRENT_STATE, '.profile=', prev, ';');\n    }\n\n    var USE_PROFILE;\n    if (profileArg) {\n      if (isStatic(profileArg)) {\n        if (profileArg.enable) {\n          emitProfileStart(scope);\n          emitProfileEnd(scope.exit);\n          scopeProfile('true');\n        } else {\n          scopeProfile('false');\n        }\n        return;\n      }\n      USE_PROFILE = profileArg.append(env, scope);\n      scopeProfile(USE_PROFILE);\n    } else {\n      USE_PROFILE = scope.def(CURRENT_STATE, '.profile');\n    }\n\n    var start = env.block();\n    emitProfileStart(start);\n    scope('if(', USE_PROFILE, '){', start, '}');\n    var end = env.block();\n    emitProfileEnd(end);\n    scope.exit('if(', USE_PROFILE, '){', end, '}');\n  }\n\n  function emitAttributes(env, scope, args, attributes, filter) {\n    var shared = env.shared;\n\n    function typeLength(x) {\n      switch (x) {\n        case GL_FLOAT_VEC2:\n        case GL_INT_VEC2:\n        case GL_BOOL_VEC2:\n          return 2;\n        case GL_FLOAT_VEC3:\n        case GL_INT_VEC3:\n        case GL_BOOL_VEC3:\n          return 3;\n        case GL_FLOAT_VEC4:\n        case GL_INT_VEC4:\n        case GL_BOOL_VEC4:\n          return 4;\n        default:\n          return 1;\n      }\n    }\n\n    function emitBindAttribute(ATTRIBUTE, size, record) {\n      var GL = shared.gl;\n\n      var LOCATION = scope.def(ATTRIBUTE, '.location');\n      var BINDING = scope.def(shared.attributes, '[', LOCATION, ']');\n\n      var STATE = record.state;\n      var BUFFER = record.buffer;\n      var CONST_COMPONENTS = [record.x, record.y, record.z, record.w];\n\n      var COMMON_KEYS = ['buffer', 'normalized', 'offset', 'stride'];\n\n      function emitBuffer() {\n        scope('if(!', BINDING, '.buffer){', GL, '.enableVertexAttribArray(', LOCATION, ');}');\n\n        var TYPE = record.type;\n        var SIZE;\n        if (!record.size) {\n          SIZE = size;\n        } else {\n          SIZE = scope.def(record.size, '||', size);\n        }\n\n        scope('if(', BINDING, '.type!==', TYPE, '||', BINDING, '.size!==', SIZE, '||', COMMON_KEYS.map(function (key) {\n          return BINDING + '.' + key + '!==' + record[key];\n        }).join('||'), '){', GL, '.bindBuffer(', GL_ARRAY_BUFFER$1, ',', BUFFER, '.buffer);', GL, '.vertexAttribPointer(', [LOCATION, SIZE, TYPE, record.normalized, record.stride, record.offset], ');', BINDING, '.type=', TYPE, ';', BINDING, '.size=', SIZE, ';', COMMON_KEYS.map(function (key) {\n          return BINDING + '.' + key + '=' + record[key] + ';';\n        }).join(''), '}');\n\n        if (extInstancing) {\n          var DIVISOR = record.divisor;\n          scope('if(', BINDING, '.divisor!==', DIVISOR, '){', env.instancing, '.vertexAttribDivisorANGLE(', [LOCATION, DIVISOR], ');', BINDING, '.divisor=', DIVISOR, ';}');\n        }\n      }\n\n      function emitConstant() {\n        scope('if(', BINDING, '.buffer){', GL, '.disableVertexAttribArray(', LOCATION, ');', '}if(', CUTE_COMPONENTS.map(function (c, i) {\n          return BINDING + '.' + c + '!==' + CONST_COMPONENTS[i];\n        }).join('||'), '){', GL, '.vertexAttrib4f(', LOCATION, ',', CONST_COMPONENTS, ');', CUTE_COMPONENTS.map(function (c, i) {\n          return BINDING + '.' + c + '=' + CONST_COMPONENTS[i] + ';';\n        }).join(''), '}');\n      }\n\n      if (STATE === ATTRIB_STATE_POINTER) {\n        emitBuffer();\n      } else if (STATE === ATTRIB_STATE_CONSTANT) {\n        emitConstant();\n      } else {\n        scope('if(', STATE, '===', ATTRIB_STATE_POINTER, '){');\n        emitBuffer();\n        scope('}else{');\n        emitConstant();\n        scope('}');\n      }\n    }\n\n    attributes.forEach(function (attribute) {\n      var name = attribute.name;\n      var arg = args.attributes[name];\n      var record;\n      if (arg) {\n        if (!filter(arg)) {\n          return;\n        }\n        record = arg.append(env, scope);\n      } else {\n        if (!filter(SCOPE_DECL)) {\n          return;\n        }\n        var scopeAttrib = env.scopeAttrib(name);\n        check$1.optional(function () {\n          env.assert(scope, scopeAttrib + '.state', 'missing attribute ' + name);\n        });\n        record = {};\n        Object.keys(new AttributeRecord()).forEach(function (key) {\n          record[key] = scope.def(scopeAttrib, '.', key);\n        });\n      }\n      emitBindAttribute(env.link(attribute), typeLength(attribute.info.type), record);\n    });\n  }\n\n  function emitUniforms(env, scope, args, uniforms, filter) {\n    var shared = env.shared;\n    var GL = shared.gl;\n\n    var infix;\n    for (var i = 0; i < uniforms.length; ++i) {\n      var uniform = uniforms[i];\n      var name = uniform.name;\n      var type = uniform.info.type;\n      var arg = args.uniforms[name];\n      var UNIFORM = env.link(uniform);\n      var LOCATION = UNIFORM + '.location';\n\n      var VALUE;\n      if (arg) {\n        if (!filter(arg)) {\n          continue;\n        }\n        if (isStatic(arg)) {\n          var value = arg.value;\n          check$1.command(value !== null && typeof value !== 'undefined', 'missing uniform \"' + name + '\"', env.commandStr);\n          if (type === GL_SAMPLER_2D || type === GL_SAMPLER_CUBE) {\n            check$1.command(typeof value === 'function' && (type === GL_SAMPLER_2D && (value._reglType === 'texture2d' || value._reglType === 'framebuffer') || type === GL_SAMPLER_CUBE && (value._reglType === 'textureCube' || value._reglType === 'framebufferCube')), 'invalid texture for uniform ' + name, env.commandStr);\n            var TEX_VALUE = env.link(value._texture || value.color[0]._texture);\n            scope(GL, '.uniform1i(', LOCATION, ',', TEX_VALUE + '.bind());');\n            scope.exit(TEX_VALUE, '.unbind();');\n          } else if (type === GL_FLOAT_MAT2 || type === GL_FLOAT_MAT3 || type === GL_FLOAT_MAT4) {\n            check$1.optional(function () {\n              check$1.command(isArrayLike(value), 'invalid matrix for uniform ' + name, env.commandStr);\n              check$1.command(type === GL_FLOAT_MAT2 && value.length === 4 || type === GL_FLOAT_MAT3 && value.length === 9 || type === GL_FLOAT_MAT4 && value.length === 16, 'invalid length for matrix uniform ' + name, env.commandStr);\n            });\n            var MAT_VALUE = env.global.def('new Float32Array([' + Array.prototype.slice.call(value) + '])');\n            var dim = 2;\n            if (type === GL_FLOAT_MAT3) {\n              dim = 3;\n            } else if (type === GL_FLOAT_MAT4) {\n              dim = 4;\n            }\n            scope(GL, '.uniformMatrix', dim, 'fv(', LOCATION, ',false,', MAT_VALUE, ');');\n          } else {\n            switch (type) {\n              case GL_FLOAT$8:\n                check$1.commandType(value, 'number', 'uniform ' + name, env.commandStr);\n                infix = '1f';\n                break;\n              case GL_FLOAT_VEC2:\n                check$1.command(isArrayLike(value) && value.length === 2, 'uniform ' + name, env.commandStr);\n                infix = '2f';\n                break;\n              case GL_FLOAT_VEC3:\n                check$1.command(isArrayLike(value) && value.length === 3, 'uniform ' + name, env.commandStr);\n                infix = '3f';\n                break;\n              case GL_FLOAT_VEC4:\n                check$1.command(isArrayLike(value) && value.length === 4, 'uniform ' + name, env.commandStr);\n                infix = '4f';\n                break;\n              case GL_BOOL:\n                check$1.commandType(value, 'boolean', 'uniform ' + name, env.commandStr);\n                infix = '1i';\n                break;\n              case GL_INT$3:\n                check$1.commandType(value, 'number', 'uniform ' + name, env.commandStr);\n                infix = '1i';\n                break;\n              case GL_BOOL_VEC2:\n                check$1.command(isArrayLike(value) && value.length === 2, 'uniform ' + name, env.commandStr);\n                infix = '2i';\n                break;\n              case GL_INT_VEC2:\n                check$1.command(isArrayLike(value) && value.length === 2, 'uniform ' + name, env.commandStr);\n                infix = '2i';\n                break;\n              case GL_BOOL_VEC3:\n                check$1.command(isArrayLike(value) && value.length === 3, 'uniform ' + name, env.commandStr);\n                infix = '3i';\n                break;\n              case GL_INT_VEC3:\n                check$1.command(isArrayLike(value) && value.length === 3, 'uniform ' + name, env.commandStr);\n                infix = '3i';\n                break;\n              case GL_BOOL_VEC4:\n                check$1.command(isArrayLike(value) && value.length === 4, 'uniform ' + name, env.commandStr);\n                infix = '4i';\n                break;\n              case GL_INT_VEC4:\n                check$1.command(isArrayLike(value) && value.length === 4, 'uniform ' + name, env.commandStr);\n                infix = '4i';\n                break;\n            }\n            scope(GL, '.uniform', infix, '(', LOCATION, ',', isArrayLike(value) ? Array.prototype.slice.call(value) : value, ');');\n          }\n          continue;\n        } else {\n          VALUE = arg.append(env, scope);\n        }\n      } else {\n        if (!filter(SCOPE_DECL)) {\n          continue;\n        }\n        VALUE = scope.def(shared.uniforms, '[', stringStore.id(name), ']');\n      }\n\n      if (type === GL_SAMPLER_2D) {\n        scope('if(', VALUE, '&&', VALUE, '._reglType===\"framebuffer\"){', VALUE, '=', VALUE, '.color[0];', '}');\n      } else if (type === GL_SAMPLER_CUBE) {\n        scope('if(', VALUE, '&&', VALUE, '._reglType===\"framebufferCube\"){', VALUE, '=', VALUE, '.color[0];', '}');\n      }\n\n      // perform type validation\n      check$1.optional(function () {\n        function check(pred, message) {\n          env.assert(scope, pred, 'bad data or missing for uniform \"' + name + '\".  ' + message);\n        }\n\n        function checkType(type) {\n          check('typeof ' + VALUE + '===\"' + type + '\"', 'invalid type, expected ' + type);\n        }\n\n        function checkVector(n, type) {\n          check(shared.isArrayLike + '(' + VALUE + ')&&' + VALUE + '.length===' + n, 'invalid vector, should have length ' + n, env.commandStr);\n        }\n\n        function checkTexture(target) {\n          check('typeof ' + VALUE + '===\"function\"&&' + VALUE + '._reglType===\"texture' + (target === GL_TEXTURE_2D$3 ? '2d' : 'Cube') + '\"', 'invalid texture type', env.commandStr);\n        }\n\n        switch (type) {\n          case GL_INT$3:\n            checkType('number');\n            break;\n          case GL_INT_VEC2:\n            checkVector(2, 'number');\n            break;\n          case GL_INT_VEC3:\n            checkVector(3, 'number');\n            break;\n          case GL_INT_VEC4:\n            checkVector(4, 'number');\n            break;\n          case GL_FLOAT$8:\n            checkType('number');\n            break;\n          case GL_FLOAT_VEC2:\n            checkVector(2, 'number');\n            break;\n          case GL_FLOAT_VEC3:\n            checkVector(3, 'number');\n            break;\n          case GL_FLOAT_VEC4:\n            checkVector(4, 'number');\n            break;\n          case GL_BOOL:\n            checkType('boolean');\n            break;\n          case GL_BOOL_VEC2:\n            checkVector(2, 'boolean');\n            break;\n          case GL_BOOL_VEC3:\n            checkVector(3, 'boolean');\n            break;\n          case GL_BOOL_VEC4:\n            checkVector(4, 'boolean');\n            break;\n          case GL_FLOAT_MAT2:\n            checkVector(4, 'number');\n            break;\n          case GL_FLOAT_MAT3:\n            checkVector(9, 'number');\n            break;\n          case GL_FLOAT_MAT4:\n            checkVector(16, 'number');\n            break;\n          case GL_SAMPLER_2D:\n            checkTexture(GL_TEXTURE_2D$3);\n            break;\n          case GL_SAMPLER_CUBE:\n            checkTexture(GL_TEXTURE_CUBE_MAP$2);\n            break;\n        }\n      });\n\n      var unroll = 1;\n      switch (type) {\n        case GL_SAMPLER_2D:\n        case GL_SAMPLER_CUBE:\n          var TEX = scope.def(VALUE, '._texture');\n          scope(GL, '.uniform1i(', LOCATION, ',', TEX, '.bind());');\n          scope.exit(TEX, '.unbind();');\n          continue;\n\n        case GL_INT$3:\n        case GL_BOOL:\n          infix = '1i';\n          break;\n\n        case GL_INT_VEC2:\n        case GL_BOOL_VEC2:\n          infix = '2i';\n          unroll = 2;\n          break;\n\n        case GL_INT_VEC3:\n        case GL_BOOL_VEC3:\n          infix = '3i';\n          unroll = 3;\n          break;\n\n        case GL_INT_VEC4:\n        case GL_BOOL_VEC4:\n          infix = '4i';\n          unroll = 4;\n          break;\n\n        case GL_FLOAT$8:\n          infix = '1f';\n          break;\n\n        case GL_FLOAT_VEC2:\n          infix = '2f';\n          unroll = 2;\n          break;\n\n        case GL_FLOAT_VEC3:\n          infix = '3f';\n          unroll = 3;\n          break;\n\n        case GL_FLOAT_VEC4:\n          infix = '4f';\n          unroll = 4;\n          break;\n\n        case GL_FLOAT_MAT2:\n          infix = 'Matrix2fv';\n          break;\n\n        case GL_FLOAT_MAT3:\n          infix = 'Matrix3fv';\n          break;\n\n        case GL_FLOAT_MAT4:\n          infix = 'Matrix4fv';\n          break;\n      }\n\n      scope(GL, '.uniform', infix, '(', LOCATION, ',');\n      if (infix.charAt(0) === 'M') {\n        var matSize = Math.pow(type - GL_FLOAT_MAT2 + 2, 2);\n        var STORAGE = env.global.def('new Float32Array(', matSize, ')');\n        scope('false,(Array.isArray(', VALUE, ')||', VALUE, ' instanceof Float32Array)?', VALUE, ':(', loop(matSize, function (i) {\n          return STORAGE + '[' + i + ']=' + VALUE + '[' + i + ']';\n        }), ',', STORAGE, ')');\n      } else if (unroll > 1) {\n        scope(loop(unroll, function (i) {\n          return VALUE + '[' + i + ']';\n        }));\n      } else {\n        scope(VALUE);\n      }\n      scope(');');\n    }\n  }\n\n  function emitDraw(env, outer, inner, args) {\n    var shared = env.shared;\n    var GL = shared.gl;\n    var DRAW_STATE = shared.draw;\n\n    var drawOptions = args.draw;\n\n    function emitElements() {\n      var defn = drawOptions.elements;\n      var ELEMENTS;\n      var scope = outer;\n      if (defn) {\n        if (defn.contextDep && args.contextDynamic || defn.propDep) {\n          scope = inner;\n        }\n        ELEMENTS = defn.append(env, scope);\n      } else {\n        ELEMENTS = scope.def(DRAW_STATE, '.', S_ELEMENTS);\n      }\n      if (ELEMENTS) {\n        scope('if(' + ELEMENTS + ')' + GL + '.bindBuffer(' + GL_ELEMENT_ARRAY_BUFFER$1 + ',' + ELEMENTS + '.buffer.buffer);');\n      }\n      return ELEMENTS;\n    }\n\n    function emitCount() {\n      var defn = drawOptions.count;\n      var COUNT;\n      var scope = outer;\n      if (defn) {\n        if (defn.contextDep && args.contextDynamic || defn.propDep) {\n          scope = inner;\n        }\n        COUNT = defn.append(env, scope);\n        check$1.optional(function () {\n          if (defn.MISSING) {\n            env.assert(outer, 'false', 'missing vertex count');\n          }\n          if (defn.DYNAMIC) {\n            env.assert(scope, COUNT + '>=0', 'missing vertex count');\n          }\n        });\n      } else {\n        COUNT = scope.def(DRAW_STATE, '.', S_COUNT);\n        check$1.optional(function () {\n          env.assert(scope, COUNT + '>=0', 'missing vertex count');\n        });\n      }\n      return COUNT;\n    }\n\n    var ELEMENTS = emitElements();\n    function emitValue(name) {\n      var defn = drawOptions[name];\n      if (defn) {\n        if (defn.contextDep && args.contextDynamic || defn.propDep) {\n          return defn.append(env, inner);\n        } else {\n          return defn.append(env, outer);\n        }\n      } else {\n        return outer.def(DRAW_STATE, '.', name);\n      }\n    }\n\n    var PRIMITIVE = emitValue(S_PRIMITIVE);\n    var OFFSET = emitValue(S_OFFSET);\n\n    var COUNT = emitCount();\n    if (typeof COUNT === 'number') {\n      if (COUNT === 0) {\n        return;\n      }\n    } else {\n      inner('if(', COUNT, '){');\n      inner.exit('}');\n    }\n\n    var INSTANCES, EXT_INSTANCING;\n    if (extInstancing) {\n      INSTANCES = emitValue(S_INSTANCES);\n      EXT_INSTANCING = env.instancing;\n    }\n\n    var ELEMENT_TYPE = ELEMENTS + '.type';\n\n    var elementsStatic = drawOptions.elements && isStatic(drawOptions.elements);\n\n    function emitInstancing() {\n      function drawElements() {\n        inner(EXT_INSTANCING, '.drawElementsInstancedANGLE(', [PRIMITIVE, COUNT, ELEMENT_TYPE, OFFSET + '<<((' + ELEMENT_TYPE + '-' + GL_UNSIGNED_BYTE$8 + ')>>1)', INSTANCES], ');');\n      }\n\n      function drawArrays() {\n        inner(EXT_INSTANCING, '.drawArraysInstancedANGLE(', [PRIMITIVE, OFFSET, COUNT, INSTANCES], ');');\n      }\n\n      if (ELEMENTS) {\n        if (!elementsStatic) {\n          inner('if(', ELEMENTS, '){');\n          drawElements();\n          inner('}else{');\n          drawArrays();\n          inner('}');\n        } else {\n          drawElements();\n        }\n      } else {\n        drawArrays();\n      }\n    }\n\n    function emitRegular() {\n      function drawElements() {\n        inner(GL + '.drawElements(' + [PRIMITIVE, COUNT, ELEMENT_TYPE, OFFSET + '<<((' + ELEMENT_TYPE + '-' + GL_UNSIGNED_BYTE$8 + ')>>1)'] + ');');\n      }\n\n      function drawArrays() {\n        inner(GL + '.drawArrays(' + [PRIMITIVE, OFFSET, COUNT] + ');');\n      }\n\n      if (ELEMENTS) {\n        if (!elementsStatic) {\n          inner('if(', ELEMENTS, '){');\n          drawElements();\n          inner('}else{');\n          drawArrays();\n          inner('}');\n        } else {\n          drawElements();\n        }\n      } else {\n        drawArrays();\n      }\n    }\n\n    if (extInstancing && (typeof INSTANCES !== 'number' || INSTANCES >= 0)) {\n      if (typeof INSTANCES === 'string') {\n        inner('if(', INSTANCES, '>0){');\n        emitInstancing();\n        inner('}else if(', INSTANCES, '<0){');\n        emitRegular();\n        inner('}');\n      } else {\n        emitInstancing();\n      }\n    } else {\n      emitRegular();\n    }\n  }\n\n  function createBody(emitBody, parentEnv, args, program, count) {\n    var env = createREGLEnvironment();\n    var scope = env.proc('body', count);\n    check$1.optional(function () {\n      env.commandStr = parentEnv.commandStr;\n      env.command = env.link(parentEnv.commandStr);\n    });\n    if (extInstancing) {\n      env.instancing = scope.def(env.shared.extensions, '.angle_instanced_arrays');\n    }\n    emitBody(env, scope, args, program);\n    return env.compile().body;\n  }\n\n  // ===================================================\n  // ===================================================\n  // DRAW PROC\n  // ===================================================\n  // ===================================================\n  function emitDrawBody(env, draw, args, program) {\n    injectExtensions(env, draw);\n    emitAttributes(env, draw, args, program.attributes, function () {\n      return true;\n    });\n    emitUniforms(env, draw, args, program.uniforms, function () {\n      return true;\n    });\n    emitDraw(env, draw, draw, args);\n  }\n\n  function emitDrawProc(env, args) {\n    var draw = env.proc('draw', 1);\n\n    injectExtensions(env, draw);\n\n    emitContext(env, draw, args.context);\n    emitPollFramebuffer(env, draw, args.framebuffer);\n\n    emitPollState(env, draw, args);\n    emitSetOptions(env, draw, args.state);\n\n    emitProfile(env, draw, args, false, true);\n\n    var program = args.shader.progVar.append(env, draw);\n    draw(env.shared.gl, '.useProgram(', program, '.program);');\n\n    if (args.shader.program) {\n      emitDrawBody(env, draw, args, args.shader.program);\n    } else {\n      var drawCache = env.global.def('{}');\n      var PROG_ID = draw.def(program, '.id');\n      var CACHED_PROC = draw.def(drawCache, '[', PROG_ID, ']');\n      draw(env.cond(CACHED_PROC).then(CACHED_PROC, '.call(this,a0);').else(CACHED_PROC, '=', drawCache, '[', PROG_ID, ']=', env.link(function (program) {\n        return createBody(emitDrawBody, env, args, program, 1);\n      }), '(', program, ');', CACHED_PROC, '.call(this,a0);'));\n    }\n\n    if (Object.keys(args.state).length > 0) {\n      draw(env.shared.current, '.dirty=true;');\n    }\n  }\n\n  // ===================================================\n  // ===================================================\n  // BATCH PROC\n  // ===================================================\n  // ===================================================\n\n  function emitBatchDynamicShaderBody(env, scope, args, program) {\n    env.batchId = 'a1';\n\n    injectExtensions(env, scope);\n\n    function all() {\n      return true;\n    }\n\n    emitAttributes(env, scope, args, program.attributes, all);\n    emitUniforms(env, scope, args, program.uniforms, all);\n    emitDraw(env, scope, scope, args);\n  }\n\n  function emitBatchBody(env, scope, args, program) {\n    injectExtensions(env, scope);\n\n    var contextDynamic = args.contextDep;\n\n    var BATCH_ID = scope.def();\n    var PROP_LIST = 'a0';\n    var NUM_PROPS = 'a1';\n    var PROPS = scope.def();\n    env.shared.props = PROPS;\n    env.batchId = BATCH_ID;\n\n    var outer = env.scope();\n    var inner = env.scope();\n\n    scope(outer.entry, 'for(', BATCH_ID, '=0;', BATCH_ID, '<', NUM_PROPS, ';++', BATCH_ID, '){', PROPS, '=', PROP_LIST, '[', BATCH_ID, '];', inner, '}', outer.exit);\n\n    function isInnerDefn(defn) {\n      return defn.contextDep && contextDynamic || defn.propDep;\n    }\n\n    function isOuterDefn(defn) {\n      return !isInnerDefn(defn);\n    }\n\n    if (args.needsContext) {\n      emitContext(env, inner, args.context);\n    }\n    if (args.needsFramebuffer) {\n      emitPollFramebuffer(env, inner, args.framebuffer);\n    }\n    emitSetOptions(env, inner, args.state, isInnerDefn);\n\n    if (args.profile && isInnerDefn(args.profile)) {\n      emitProfile(env, inner, args, false, true);\n    }\n\n    if (!program) {\n      var progCache = env.global.def('{}');\n      var PROGRAM = args.shader.progVar.append(env, inner);\n      var PROG_ID = inner.def(PROGRAM, '.id');\n      var CACHED_PROC = inner.def(progCache, '[', PROG_ID, ']');\n      inner(env.shared.gl, '.useProgram(', PROGRAM, '.program);', 'if(!', CACHED_PROC, '){', CACHED_PROC, '=', progCache, '[', PROG_ID, ']=', env.link(function (program) {\n        return createBody(emitBatchDynamicShaderBody, env, args, program, 2);\n      }), '(', PROGRAM, ');}', CACHED_PROC, '.call(this,a0[', BATCH_ID, '],', BATCH_ID, ');');\n    } else {\n      emitAttributes(env, outer, args, program.attributes, isOuterDefn);\n      emitAttributes(env, inner, args, program.attributes, isInnerDefn);\n      emitUniforms(env, outer, args, program.uniforms, isOuterDefn);\n      emitUniforms(env, inner, args, program.uniforms, isInnerDefn);\n      emitDraw(env, outer, inner, args);\n    }\n  }\n\n  function emitBatchProc(env, args) {\n    var batch = env.proc('batch', 2);\n    env.batchId = '0';\n\n    injectExtensions(env, batch);\n\n    // Check if any context variables depend on props\n    var contextDynamic = false;\n    var needsContext = true;\n    Object.keys(args.context).forEach(function (name) {\n      contextDynamic = contextDynamic || args.context[name].propDep;\n    });\n    if (!contextDynamic) {\n      emitContext(env, batch, args.context);\n      needsContext = false;\n    }\n\n    // framebuffer state affects framebufferWidth/height context vars\n    var framebuffer = args.framebuffer;\n    var needsFramebuffer = false;\n    if (framebuffer) {\n      if (framebuffer.propDep) {\n        contextDynamic = needsFramebuffer = true;\n      } else if (framebuffer.contextDep && contextDynamic) {\n        needsFramebuffer = true;\n      }\n      if (!needsFramebuffer) {\n        emitPollFramebuffer(env, batch, framebuffer);\n      }\n    } else {\n      emitPollFramebuffer(env, batch, null);\n    }\n\n    // viewport is weird because it can affect context vars\n    if (args.state.viewport && args.state.viewport.propDep) {\n      contextDynamic = true;\n    }\n\n    function isInnerDefn(defn) {\n      return defn.contextDep && contextDynamic || defn.propDep;\n    }\n\n    // set webgl options\n    emitPollState(env, batch, args);\n    emitSetOptions(env, batch, args.state, function (defn) {\n      return !isInnerDefn(defn);\n    });\n\n    if (!args.profile || !isInnerDefn(args.profile)) {\n      emitProfile(env, batch, args, false, 'a1');\n    }\n\n    // Save these values to args so that the batch body routine can use them\n    args.contextDep = contextDynamic;\n    args.needsContext = needsContext;\n    args.needsFramebuffer = needsFramebuffer;\n\n    // determine if shader is dynamic\n    var progDefn = args.shader.progVar;\n    if (progDefn.contextDep && contextDynamic || progDefn.propDep) {\n      emitBatchBody(env, batch, args, null);\n    } else {\n      var PROGRAM = progDefn.append(env, batch);\n      batch(env.shared.gl, '.useProgram(', PROGRAM, '.program);');\n      if (args.shader.program) {\n        emitBatchBody(env, batch, args, args.shader.program);\n      } else {\n        var batchCache = env.global.def('{}');\n        var PROG_ID = batch.def(PROGRAM, '.id');\n        var CACHED_PROC = batch.def(batchCache, '[', PROG_ID, ']');\n        batch(env.cond(CACHED_PROC).then(CACHED_PROC, '.call(this,a0,a1);').else(CACHED_PROC, '=', batchCache, '[', PROG_ID, ']=', env.link(function (program) {\n          return createBody(emitBatchBody, env, args, program, 2);\n        }), '(', PROGRAM, ');', CACHED_PROC, '.call(this,a0,a1);'));\n      }\n    }\n\n    if (Object.keys(args.state).length > 0) {\n      batch(env.shared.current, '.dirty=true;');\n    }\n  }\n\n  // ===================================================\n  // ===================================================\n  // SCOPE COMMAND\n  // ===================================================\n  // ===================================================\n  function emitScopeProc(env, args) {\n    var scope = env.proc('scope', 3);\n    env.batchId = 'a2';\n\n    var shared = env.shared;\n    var CURRENT_STATE = shared.current;\n\n    emitContext(env, scope, args.context);\n\n    if (args.framebuffer) {\n      args.framebuffer.append(env, scope);\n    }\n\n    sortState(Object.keys(args.state)).forEach(function (name) {\n      var defn = args.state[name];\n      var value = defn.append(env, scope);\n      if (isArrayLike(value)) {\n        value.forEach(function (v, i) {\n          scope.set(env.next[name], '[' + i + ']', v);\n        });\n      } else {\n        scope.set(shared.next, '.' + name, value);\n      }\n    });\n\n    emitProfile(env, scope, args, true, true);[S_ELEMENTS, S_OFFSET, S_COUNT, S_INSTANCES, S_PRIMITIVE].forEach(function (opt) {\n      var variable = args.draw[opt];\n      if (!variable) {\n        return;\n      }\n      scope.set(shared.draw, '.' + opt, '' + variable.append(env, scope));\n    });\n\n    Object.keys(args.uniforms).forEach(function (opt) {\n      scope.set(shared.uniforms, '[' + stringStore.id(opt) + ']', args.uniforms[opt].append(env, scope));\n    });\n\n    Object.keys(args.attributes).forEach(function (name) {\n      var record = args.attributes[name].append(env, scope);\n      var scopeAttrib = env.scopeAttrib(name);\n      Object.keys(new AttributeRecord()).forEach(function (prop) {\n        scope.set(scopeAttrib, '.' + prop, record[prop]);\n      });\n    });\n\n    function saveShader(name) {\n      var shader = args.shader[name];\n      if (shader) {\n        scope.set(shared.shader, '.' + name, shader.append(env, scope));\n      }\n    }\n    saveShader(S_VERT);\n    saveShader(S_FRAG);\n\n    if (Object.keys(args.state).length > 0) {\n      scope(CURRENT_STATE, '.dirty=true;');\n      scope.exit(CURRENT_STATE, '.dirty=true;');\n    }\n\n    scope('a1(', env.shared.context, ',a0,', env.batchId, ');');\n  }\n\n  function isDynamicObject(object) {\n    if ((typeof object === 'undefined' ? 'undefined' : _typeof(object)) !== 'object' || isArrayLike(object)) {\n      return;\n    }\n    var props = Object.keys(object);\n    for (var i = 0; i < props.length; ++i) {\n      if (dynamic.isDynamic(object[props[i]])) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function splatObject(env, options, name) {\n    var object = options.static[name];\n    if (!object || !isDynamicObject(object)) {\n      return;\n    }\n\n    var globals = env.global;\n    var keys = Object.keys(object);\n    var thisDep = false;\n    var contextDep = false;\n    var propDep = false;\n    var objectRef = env.global.def('{}');\n    keys.forEach(function (key) {\n      var value = object[key];\n      if (dynamic.isDynamic(value)) {\n        if (typeof value === 'function') {\n          value = object[key] = dynamic.unbox(value);\n        }\n        var deps = createDynamicDecl(value, null);\n        thisDep = thisDep || deps.thisDep;\n        propDep = propDep || deps.propDep;\n        contextDep = contextDep || deps.contextDep;\n      } else {\n        globals(objectRef, '.', key, '=');\n        switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {\n          case 'number':\n            globals(value);\n            break;\n          case 'string':\n            globals('\"', value, '\"');\n            break;\n          case 'object':\n            if (Array.isArray(value)) {\n              globals('[', value.join(), ']');\n            }\n            break;\n          default:\n            globals(env.link(value));\n            break;\n        }\n        globals(';');\n      }\n    });\n\n    function appendBlock(env, block) {\n      keys.forEach(function (key) {\n        var value = object[key];\n        if (!dynamic.isDynamic(value)) {\n          return;\n        }\n        var ref = env.invoke(block, value);\n        block(objectRef, '.', key, '=', ref, ';');\n      });\n    }\n\n    options.dynamic[name] = new dynamic.DynamicVariable(DYN_THUNK, {\n      thisDep: thisDep,\n      contextDep: contextDep,\n      propDep: propDep,\n      ref: objectRef,\n      append: appendBlock\n    });\n    delete options.static[name];\n  }\n\n  // ===========================================================================\n  // ===========================================================================\n  // MAIN DRAW COMMAND\n  // ===========================================================================\n  // ===========================================================================\n  function compileCommand(options, attributes, uniforms, context, stats) {\n    var env = createREGLEnvironment();\n\n    // link stats, so that we can easily access it in the program.\n    env.stats = env.link(stats);\n\n    // splat options and attributes to allow for dynamic nested properties\n    Object.keys(attributes.static).forEach(function (key) {\n      splatObject(env, attributes, key);\n    });\n    NESTED_OPTIONS.forEach(function (name) {\n      splatObject(env, options, name);\n    });\n\n    var args = parseArguments(options, attributes, uniforms, context, env);\n\n    emitDrawProc(env, args);\n    emitScopeProc(env, args);\n    emitBatchProc(env, args);\n\n    return env.compile();\n  }\n\n  // ===========================================================================\n  // ===========================================================================\n  // POLL / REFRESH\n  // ===========================================================================\n  // ===========================================================================\n  return {\n    next: nextState,\n    current: currentState,\n    procs: function () {\n      var env = createREGLEnvironment();\n      var poll = env.proc('poll');\n      var refresh = env.proc('refresh');\n      var common = env.block();\n      poll(common);\n      refresh(common);\n\n      var shared = env.shared;\n      var GL = shared.gl;\n      var NEXT_STATE = shared.next;\n      var CURRENT_STATE = shared.current;\n\n      common(CURRENT_STATE, '.dirty=false;');\n\n      emitPollFramebuffer(env, poll);\n      emitPollFramebuffer(env, refresh, null, true);\n\n      // Refresh updates all attribute state changes\n      var INSTANCING;\n      if (extInstancing) {\n        INSTANCING = env.link(extInstancing);\n      }\n      for (var i = 0; i < limits.maxAttributes; ++i) {\n        var BINDING = refresh.def(shared.attributes, '[', i, ']');\n        var ifte = env.cond(BINDING, '.buffer');\n        ifte.then(GL, '.enableVertexAttribArray(', i, ');', GL, '.bindBuffer(', GL_ARRAY_BUFFER$1, ',', BINDING, '.buffer.buffer);', GL, '.vertexAttribPointer(', i, ',', BINDING, '.size,', BINDING, '.type,', BINDING, '.normalized,', BINDING, '.stride,', BINDING, '.offset);').else(GL, '.disableVertexAttribArray(', i, ');', GL, '.vertexAttrib4f(', i, ',', BINDING, '.x,', BINDING, '.y,', BINDING, '.z,', BINDING, '.w);', BINDING, '.buffer=null;');\n        refresh(ifte);\n        if (extInstancing) {\n          refresh(INSTANCING, '.vertexAttribDivisorANGLE(', i, ',', BINDING, '.divisor);');\n        }\n      }\n\n      Object.keys(GL_FLAGS).forEach(function (flag) {\n        var cap = GL_FLAGS[flag];\n        var NEXT = common.def(NEXT_STATE, '.', flag);\n        var block = env.block();\n        block('if(', NEXT, '){', GL, '.enable(', cap, ')}else{', GL, '.disable(', cap, ')}', CURRENT_STATE, '.', flag, '=', NEXT, ';');\n        refresh(block);\n        poll('if(', NEXT, '!==', CURRENT_STATE, '.', flag, '){', block, '}');\n      });\n\n      Object.keys(GL_VARIABLES).forEach(function (name) {\n        var func = GL_VARIABLES[name];\n        var init = currentState[name];\n        var NEXT, CURRENT;\n        var block = env.block();\n        block(GL, '.', func, '(');\n        if (isArrayLike(init)) {\n          var n = init.length;\n          NEXT = env.global.def(NEXT_STATE, '.', name);\n          CURRENT = env.global.def(CURRENT_STATE, '.', name);\n          block(loop(n, function (i) {\n            return NEXT + '[' + i + ']';\n          }), ');', loop(n, function (i) {\n            return CURRENT + '[' + i + ']=' + NEXT + '[' + i + '];';\n          }).join(''));\n          poll('if(', loop(n, function (i) {\n            return NEXT + '[' + i + ']!==' + CURRENT + '[' + i + ']';\n          }).join('||'), '){', block, '}');\n        } else {\n          NEXT = common.def(NEXT_STATE, '.', name);\n          CURRENT = common.def(CURRENT_STATE, '.', name);\n          block(NEXT, ');', CURRENT_STATE, '.', name, '=', NEXT, ';');\n          poll('if(', NEXT, '!==', CURRENT, '){', block, '}');\n        }\n        refresh(block);\n      });\n\n      return env.compile();\n    }(),\n    compile: compileCommand\n  };\n}\n\nfunction stats() {\n  return {\n    bufferCount: 0,\n    elementsCount: 0,\n    framebufferCount: 0,\n    shaderCount: 0,\n    textureCount: 0,\n    cubeCount: 0,\n    renderbufferCount: 0,\n    maxTextureUnits: 0\n  };\n}\n\nvar GL_QUERY_RESULT_EXT = 0x8866;\nvar GL_QUERY_RESULT_AVAILABLE_EXT = 0x8867;\nvar GL_TIME_ELAPSED_EXT = 0x88BF;\n\nvar createTimer = function createTimer(gl, extensions) {\n  var extTimer = extensions.ext_disjoint_timer_query;\n\n  if (!extTimer) {\n    return null;\n  }\n\n  // QUERY POOL BEGIN\n  var queryPool = [];\n  function allocQuery() {\n    return queryPool.pop() || extTimer.createQueryEXT();\n  }\n  function freeQuery(query) {\n    queryPool.push(query);\n  }\n  // QUERY POOL END\n\n  var pendingQueries = [];\n  function beginQuery(stats) {\n    var query = allocQuery();\n    extTimer.beginQueryEXT(GL_TIME_ELAPSED_EXT, query);\n    pendingQueries.push(query);\n    pushScopeStats(pendingQueries.length - 1, pendingQueries.length, stats);\n  }\n\n  function endQuery() {\n    extTimer.endQueryEXT(GL_TIME_ELAPSED_EXT);\n  }\n\n  //\n  // Pending stats pool.\n  //\n  function PendingStats() {\n    this.startQueryIndex = -1;\n    this.endQueryIndex = -1;\n    this.sum = 0;\n    this.stats = null;\n  }\n  var pendingStatsPool = [];\n  function allocPendingStats() {\n    return pendingStatsPool.pop() || new PendingStats();\n  }\n  function freePendingStats(pendingStats) {\n    pendingStatsPool.push(pendingStats);\n  }\n  // Pending stats pool end\n\n  var pendingStats = [];\n  function pushScopeStats(start, end, stats) {\n    var ps = allocPendingStats();\n    ps.startQueryIndex = start;\n    ps.endQueryIndex = end;\n    ps.sum = 0;\n    ps.stats = stats;\n    pendingStats.push(ps);\n  }\n\n  // we should call this at the beginning of the frame,\n  // in order to update gpuTime\n  var timeSum = [];\n  var queryPtr = [];\n  function update() {\n    var ptr, i;\n\n    var n = pendingQueries.length;\n    if (n === 0) {\n      return;\n    }\n\n    // Reserve space\n    queryPtr.length = Math.max(queryPtr.length, n + 1);\n    timeSum.length = Math.max(timeSum.length, n + 1);\n    timeSum[0] = 0;\n    queryPtr[0] = 0;\n\n    // Update all pending timer queries\n    var queryTime = 0;\n    ptr = 0;\n    for (i = 0; i < pendingQueries.length; ++i) {\n      var query = pendingQueries[i];\n      if (extTimer.getQueryObjectEXT(query, GL_QUERY_RESULT_AVAILABLE_EXT)) {\n        queryTime += extTimer.getQueryObjectEXT(query, GL_QUERY_RESULT_EXT);\n        freeQuery(query);\n      } else {\n        pendingQueries[ptr++] = query;\n      }\n      timeSum[i + 1] = queryTime;\n      queryPtr[i + 1] = ptr;\n    }\n    pendingQueries.length = ptr;\n\n    // Update all pending stat queries\n    ptr = 0;\n    for (i = 0; i < pendingStats.length; ++i) {\n      var stats = pendingStats[i];\n      var start = stats.startQueryIndex;\n      var end = stats.endQueryIndex;\n      stats.sum += timeSum[end] - timeSum[start];\n      var startPtr = queryPtr[start];\n      var endPtr = queryPtr[end];\n      if (endPtr === startPtr) {\n        stats.stats.gpuTime += stats.sum / 1e6;\n        freePendingStats(stats);\n      } else {\n        stats.startQueryIndex = startPtr;\n        stats.endQueryIndex = endPtr;\n        pendingStats[ptr++] = stats;\n      }\n    }\n    pendingStats.length = ptr;\n  }\n\n  return {\n    beginQuery: beginQuery,\n    endQuery: endQuery,\n    pushScopeStats: pushScopeStats,\n    update: update,\n    getNumPendingQueries: function getNumPendingQueries() {\n      return pendingQueries.length;\n    },\n    clear: function clear() {\n      queryPool.push.apply(queryPool, pendingQueries);\n      for (var i = 0; i < queryPool.length; i++) {\n        extTimer.deleteQueryEXT(queryPool[i]);\n      }\n      pendingQueries.length = 0;\n      queryPool.length = 0;\n    },\n    restore: function restore() {\n      pendingQueries.length = 0;\n      queryPool.length = 0;\n    }\n  };\n};\n\nvar GL_COLOR_BUFFER_BIT = 16384;\nvar GL_DEPTH_BUFFER_BIT = 256;\nvar GL_STENCIL_BUFFER_BIT = 1024;\n\nvar GL_ARRAY_BUFFER = 34962;\n\nvar CONTEXT_LOST_EVENT = 'webglcontextlost';\nvar CONTEXT_RESTORED_EVENT = 'webglcontextrestored';\n\nvar DYN_PROP = 1;\nvar DYN_CONTEXT = 2;\nvar DYN_STATE = 3;\n\nfunction find(haystack, needle) {\n  for (var i = 0; i < haystack.length; ++i) {\n    if (haystack[i] === needle) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nfunction wrapREGL(args) {\n  var config = parseArgs(args);\n  if (!config) {\n    return null;\n  }\n\n  var gl = config.gl;\n  var glAttributes = gl.getContextAttributes();\n  var contextLost = gl.isContextLost();\n\n  var extensionState = createExtensionCache(gl, config);\n  if (!extensionState) {\n    return null;\n  }\n\n  var stringStore = createStringStore();\n  var stats$$1 = stats();\n  var extensions = extensionState.extensions;\n  var timer = createTimer(gl, extensions);\n\n  var START_TIME = clock();\n  var WIDTH = gl.drawingBufferWidth;\n  var HEIGHT = gl.drawingBufferHeight;\n\n  var contextState = {\n    tick: 0,\n    time: 0,\n    viewportWidth: WIDTH,\n    viewportHeight: HEIGHT,\n    framebufferWidth: WIDTH,\n    framebufferHeight: HEIGHT,\n    drawingBufferWidth: WIDTH,\n    drawingBufferHeight: HEIGHT,\n    pixelRatio: config.pixelRatio\n  };\n  var uniformState = {};\n  var drawState = {\n    elements: null,\n    primitive: 4, // GL_TRIANGLES\n    count: -1,\n    offset: 0,\n    instances: -1\n  };\n\n  var limits = wrapLimits(gl, extensions);\n  var attributeState = wrapAttributeState(gl, extensions, limits, stringStore);\n  var bufferState = wrapBufferState(gl, stats$$1, config, attributeState);\n  var elementState = wrapElementsState(gl, extensions, bufferState, stats$$1);\n  var shaderState = wrapShaderState(gl, stringStore, stats$$1, config);\n  var textureState = createTextureSet(gl, extensions, limits, function () {\n    core.procs.poll();\n  }, contextState, stats$$1, config);\n  var renderbufferState = wrapRenderbuffers(gl, extensions, limits, stats$$1, config);\n  var framebufferState = wrapFBOState(gl, extensions, limits, textureState, renderbufferState, stats$$1);\n  var core = reglCore(gl, stringStore, extensions, limits, bufferState, elementState, textureState, framebufferState, uniformState, attributeState, shaderState, drawState, contextState, timer, config);\n  var readPixels = wrapReadPixels(gl, framebufferState, core.procs.poll, contextState, glAttributes, extensions, limits);\n\n  var nextState = core.next;\n  var canvas = gl.canvas;\n\n  var rafCallbacks = [];\n  var lossCallbacks = [];\n  var restoreCallbacks = [];\n  var destroyCallbacks = [config.onDestroy];\n\n  var activeRAF = null;\n  function handleRAF() {\n    if (rafCallbacks.length === 0) {\n      if (timer) {\n        timer.update();\n      }\n      activeRAF = null;\n      return;\n    }\n\n    // schedule next animation frame\n    activeRAF = raf.next(handleRAF);\n\n    // poll for changes\n    _poll();\n\n    // fire a callback for all pending rafs\n    for (var i = rafCallbacks.length - 1; i >= 0; --i) {\n      var cb = rafCallbacks[i];\n      if (cb) {\n        cb(contextState, null, 0);\n      }\n    }\n\n    // flush all pending webgl calls\n    gl.flush();\n\n    // poll GPU timers *after* gl.flush so we don't delay command dispatch\n    if (timer) {\n      timer.update();\n    }\n  }\n\n  function startRAF() {\n    if (!activeRAF && rafCallbacks.length > 0) {\n      activeRAF = raf.next(handleRAF);\n    }\n  }\n\n  function stopRAF() {\n    if (activeRAF) {\n      raf.cancel(handleRAF);\n      activeRAF = null;\n    }\n  }\n\n  function handleContextLoss(event) {\n    event.preventDefault();\n\n    // set context lost flag\n    contextLost = true;\n\n    // pause request animation frame\n    stopRAF();\n\n    // lose context\n    lossCallbacks.forEach(function (cb) {\n      cb();\n    });\n  }\n\n  function handleContextRestored(event) {\n    // clear error code\n    gl.getError();\n\n    // clear context lost flag\n    contextLost = false;\n\n    // refresh state\n    extensionState.restore();\n    shaderState.restore();\n    bufferState.restore();\n    textureState.restore();\n    renderbufferState.restore();\n    framebufferState.restore();\n    if (timer) {\n      timer.restore();\n    }\n\n    // refresh state\n    core.procs.refresh();\n\n    // restart RAF\n    startRAF();\n\n    // restore context\n    restoreCallbacks.forEach(function (cb) {\n      cb();\n    });\n  }\n\n  if (canvas) {\n    canvas.addEventListener(CONTEXT_LOST_EVENT, handleContextLoss, false);\n    canvas.addEventListener(CONTEXT_RESTORED_EVENT, handleContextRestored, false);\n  }\n\n  function destroy() {\n    rafCallbacks.length = 0;\n    stopRAF();\n\n    if (canvas) {\n      canvas.removeEventListener(CONTEXT_LOST_EVENT, handleContextLoss);\n      canvas.removeEventListener(CONTEXT_RESTORED_EVENT, handleContextRestored);\n    }\n\n    shaderState.clear();\n    framebufferState.clear();\n    renderbufferState.clear();\n    textureState.clear();\n    elementState.clear();\n    bufferState.clear();\n\n    if (timer) {\n      timer.clear();\n    }\n\n    destroyCallbacks.forEach(function (cb) {\n      cb();\n    });\n  }\n\n  function compileProcedure(options) {\n    check$1(!!options, 'invalid args to regl({...})');\n    check$1.type(options, 'object', 'invalid args to regl({...})');\n\n    function flattenNestedOptions(options) {\n      var result = extend({}, options);\n      delete result.uniforms;\n      delete result.attributes;\n      delete result.context;\n\n      if ('stencil' in result && result.stencil.op) {\n        result.stencil.opBack = result.stencil.opFront = result.stencil.op;\n        delete result.stencil.op;\n      }\n\n      function merge(name) {\n        if (name in result) {\n          var child = result[name];\n          delete result[name];\n          Object.keys(child).forEach(function (prop) {\n            result[name + '.' + prop] = child[prop];\n          });\n        }\n      }\n      merge('blend');\n      merge('depth');\n      merge('cull');\n      merge('stencil');\n      merge('polygonOffset');\n      merge('scissor');\n      merge('sample');\n\n      return result;\n    }\n\n    function separateDynamic(object) {\n      var staticItems = {};\n      var dynamicItems = {};\n      Object.keys(object).forEach(function (option) {\n        var value = object[option];\n        if (dynamic.isDynamic(value)) {\n          dynamicItems[option] = dynamic.unbox(value, option);\n        } else {\n          staticItems[option] = value;\n        }\n      });\n      return {\n        dynamic: dynamicItems,\n        static: staticItems\n      };\n    }\n\n    // Treat context variables separate from other dynamic variables\n    var context = separateDynamic(options.context || {});\n    var uniforms = separateDynamic(options.uniforms || {});\n    var attributes = separateDynamic(options.attributes || {});\n    var opts = separateDynamic(flattenNestedOptions(options));\n\n    var stats$$1 = {\n      gpuTime: 0.0,\n      cpuTime: 0.0,\n      count: 0\n    };\n\n    var compiled = core.compile(opts, attributes, uniforms, context, stats$$1);\n\n    var draw = compiled.draw;\n    var batch = compiled.batch;\n    var scope = compiled.scope;\n\n    // FIXME: we should modify code generation for batch commands so this\n    // isn't necessary\n    var EMPTY_ARRAY = [];\n    function reserve(count) {\n      while (EMPTY_ARRAY.length < count) {\n        EMPTY_ARRAY.push(null);\n      }\n      return EMPTY_ARRAY;\n    }\n\n    function REGLCommand(args, body) {\n      var i;\n      if (contextLost) {\n        check$1.raise('context lost');\n      }\n      if (typeof args === 'function') {\n        return scope.call(this, null, args, 0);\n      } else if (typeof body === 'function') {\n        if (typeof args === 'number') {\n          for (i = 0; i < args; ++i) {\n            scope.call(this, null, body, i);\n          }\n          return;\n        } else if (Array.isArray(args)) {\n          for (i = 0; i < args.length; ++i) {\n            scope.call(this, args[i], body, i);\n          }\n          return;\n        } else {\n          return scope.call(this, args, body, 0);\n        }\n      } else if (typeof args === 'number') {\n        if (args > 0) {\n          return batch.call(this, reserve(args | 0), args | 0);\n        }\n      } else if (Array.isArray(args)) {\n        if (args.length) {\n          return batch.call(this, args, args.length);\n        }\n      } else {\n        return draw.call(this, args);\n      }\n    }\n\n    return extend(REGLCommand, {\n      stats: stats$$1\n    });\n  }\n\n  var setFBO = framebufferState.setFBO = compileProcedure({\n    framebuffer: dynamic.define.call(null, DYN_PROP, 'framebuffer')\n  });\n\n  function clearImpl(_, options) {\n    var clearFlags = 0;\n    core.procs.poll();\n\n    var c = options.color;\n    if (c) {\n      gl.clearColor(+c[0] || 0, +c[1] || 0, +c[2] || 0, +c[3] || 0);\n      clearFlags |= GL_COLOR_BUFFER_BIT;\n    }\n    if ('depth' in options) {\n      gl.clearDepth(+options.depth);\n      clearFlags |= GL_DEPTH_BUFFER_BIT;\n    }\n    if ('stencil' in options) {\n      gl.clearStencil(options.stencil | 0);\n      clearFlags |= GL_STENCIL_BUFFER_BIT;\n    }\n\n    check$1(!!clearFlags, 'called regl.clear with no buffer specified');\n    gl.clear(clearFlags);\n  }\n\n  function clear(options) {\n    check$1((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object' && options, 'regl.clear() takes an object as input');\n    if ('framebuffer' in options) {\n      if (options.framebuffer && options.framebuffer_reglType === 'framebufferCube') {\n        for (var i = 0; i < 6; ++i) {\n          setFBO(extend({\n            framebuffer: options.framebuffer.faces[i]\n          }, options), clearImpl);\n        }\n      } else {\n        setFBO(options, clearImpl);\n      }\n    } else {\n      clearImpl(null, options);\n    }\n  }\n\n  function frame(cb) {\n    check$1.type(cb, 'function', 'regl.frame() callback must be a function');\n    rafCallbacks.push(cb);\n\n    function cancel() {\n      // FIXME:  should we check something other than equals cb here?\n      // what if a user calls frame twice with the same callback...\n      //\n      var i = find(rafCallbacks, cb);\n      check$1(i >= 0, 'cannot cancel a frame twice');\n      function pendingCancel() {\n        var index = find(rafCallbacks, pendingCancel);\n        rafCallbacks[index] = rafCallbacks[rafCallbacks.length - 1];\n        rafCallbacks.length -= 1;\n        if (rafCallbacks.length <= 0) {\n          stopRAF();\n        }\n      }\n      rafCallbacks[i] = pendingCancel;\n    }\n\n    startRAF();\n\n    return {\n      cancel: cancel\n    };\n  }\n\n  // poll viewport\n  function pollViewport() {\n    var viewport = nextState.viewport;\n    var scissorBox = nextState.scissor_box;\n    viewport[0] = viewport[1] = scissorBox[0] = scissorBox[1] = 0;\n    contextState.viewportWidth = contextState.framebufferWidth = contextState.drawingBufferWidth = viewport[2] = scissorBox[2] = gl.drawingBufferWidth;\n    contextState.viewportHeight = contextState.framebufferHeight = contextState.drawingBufferHeight = viewport[3] = scissorBox[3] = gl.drawingBufferHeight;\n  }\n\n  function _poll() {\n    contextState.tick += 1;\n    contextState.time = now();\n    pollViewport();\n    core.procs.poll();\n  }\n\n  function refresh() {\n    pollViewport();\n    core.procs.refresh();\n    if (timer) {\n      timer.update();\n    }\n  }\n\n  function now() {\n    return (clock() - START_TIME) / 1000.0;\n  }\n\n  refresh();\n\n  function addListener(event, callback) {\n    check$1.type(callback, 'function', 'listener callback must be a function');\n\n    var callbacks;\n    switch (event) {\n      case 'frame':\n        return frame(callback);\n      case 'lost':\n        callbacks = lossCallbacks;\n        break;\n      case 'restore':\n        callbacks = restoreCallbacks;\n        break;\n      case 'destroy':\n        callbacks = destroyCallbacks;\n        break;\n      default:\n        check$1.raise('invalid event, must be one of frame,lost,restore,destroy');\n    }\n\n    callbacks.push(callback);\n    return {\n      cancel: function cancel() {\n        for (var i = 0; i < callbacks.length; ++i) {\n          if (callbacks[i] === callback) {\n            callbacks[i] = callbacks[callbacks.length - 1];\n            callbacks.pop();\n            return;\n          }\n        }\n      }\n    };\n  }\n\n  var regl = extend(compileProcedure, {\n    // Clear current FBO\n    clear: clear,\n\n    // Short cuts for dynamic variables\n    prop: dynamic.define.bind(null, DYN_PROP),\n    context: dynamic.define.bind(null, DYN_CONTEXT),\n    this: dynamic.define.bind(null, DYN_STATE),\n\n    // executes an empty draw command\n    draw: compileProcedure({}),\n\n    // Resources\n    buffer: function buffer(options) {\n      return bufferState.create(options, GL_ARRAY_BUFFER, false, false);\n    },\n    elements: function elements(options) {\n      return elementState.create(options, false);\n    },\n    texture: textureState.create2D,\n    cube: textureState.createCube,\n    renderbuffer: renderbufferState.create,\n    framebuffer: framebufferState.create,\n    framebufferCube: framebufferState.createCube,\n\n    // Expose context attributes\n    attributes: glAttributes,\n\n    // Frame rendering\n    frame: frame,\n    on: addListener,\n\n    // System limits\n    limits: limits,\n    hasExtension: function hasExtension(name) {\n      return limits.extensions.indexOf(name.toLowerCase()) >= 0;\n    },\n\n    // Read pixels\n    read: readPixels,\n\n    // Destroy regl and all associated resources\n    destroy: destroy,\n\n    // Direct GL state manipulation\n    _gl: gl,\n    _refresh: refresh,\n\n    poll: function poll() {\n      _poll();\n      if (timer) {\n        timer.update();\n      }\n    },\n\n    // Current time\n    now: now,\n\n    // regl Statistics Information\n    stats: stats$$1\n  });\n\n  config.onDone(null, regl);\n\n  return regl;\n}\n\nexports.regl = wrapREGL;\n//# sourceMappingURL=regl.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvd2ViZ2wvcmVnbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvd2ViZ2wvcmVnbC5qcz8wMjIxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBpc1R5cGVkQXJyYXkgPSBmdW5jdGlvbiAoeCkge1xyXG4gIHJldHVybiAoXHJcbiAgICB4IGluc3RhbmNlb2YgVWludDhBcnJheSB8fFxyXG4gICAgeCBpbnN0YW5jZW9mIFVpbnQxNkFycmF5IHx8XHJcbiAgICB4IGluc3RhbmNlb2YgVWludDMyQXJyYXkgfHxcclxuICAgIHggaW5zdGFuY2VvZiBJbnQ4QXJyYXkgfHxcclxuICAgIHggaW5zdGFuY2VvZiBJbnQxNkFycmF5IHx8XHJcbiAgICB4IGluc3RhbmNlb2YgSW50MzJBcnJheSB8fFxyXG4gICAgeCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSB8fFxyXG4gICAgeCBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSB8fFxyXG4gICAgeCBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5XHJcbiAgKVxyXG59O1xyXG5cclxudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChiYXNlLCBvcHRzKSB7XHJcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvcHRzKTtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcclxuICAgIGJhc2Vba2V5c1tpXV0gPSBvcHRzW2tleXNbaV1dO1xyXG4gIH1cclxuICByZXR1cm4gYmFzZVxyXG59O1xyXG5cclxuLy8gRXJyb3IgY2hlY2tpbmcgYW5kIHBhcmFtZXRlciB2YWxpZGF0aW9uLlxyXG4vL1xyXG4vLyBTdGF0ZW1lbnRzIGZvciB0aGUgZm9ybSBgY2hlY2suc29tZVByb2NlZHVyZSguLi4pYCBnZXQgcmVtb3ZlZCBieVxyXG4vLyBhIGJyb3dzZXJpZnkgdHJhbnNmb3JtIGZvciBvcHRpbWl6ZWQvbWluaWZpZWQgYnVuZGxlcy5cclxuLy9cclxuLyogZ2xvYmFscyBhdG9iICovXHJcbnZhciBlbmRsID0gJ1xcbic7XHJcblxyXG4vLyBvbmx5IHVzZWQgZm9yIGV4dHJhY3Rpbmcgc2hhZGVyIG5hbWVzLiAgaWYgYXRvYiBub3QgcHJlc2VudCwgdGhlbiBlcnJvcnNcclxuLy8gd2lsbCBiZSBzbGlnaHRseSBjcmFwcGllclxyXG5mdW5jdGlvbiBkZWNvZGVCNjQgKHN0cikge1xyXG4gIGlmICh0eXBlb2YgYXRvYiAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIHJldHVybiBhdG9iKHN0cilcclxuICB9XHJcbiAgcmV0dXJuICdiYXNlNjQ6JyArIHN0clxyXG59XHJcblxyXG5mdW5jdGlvbiByYWlzZSAobWVzc2FnZSkge1xyXG4gIHZhciBlcnJvciA9IG5ldyBFcnJvcignKHJlZ2wpICcgKyBtZXNzYWdlKTtcclxuICBjb25zb2xlLmVycm9yKGVycm9yKTtcclxuICB0aHJvdyBlcnJvclxyXG59XHJcblxyXG5mdW5jdGlvbiBjaGVjayAocHJlZCwgbWVzc2FnZSkge1xyXG4gIGlmICghcHJlZCkge1xyXG4gICAgcmFpc2UobWVzc2FnZSk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBlbmNvbG9uIChtZXNzYWdlKSB7XHJcbiAgaWYgKG1lc3NhZ2UpIHtcclxuICAgIHJldHVybiAnOiAnICsgbWVzc2FnZVxyXG4gIH1cclxuICByZXR1cm4gJydcclxufVxyXG5cclxuZnVuY3Rpb24gY2hlY2tQYXJhbWV0ZXIgKHBhcmFtLCBwb3NzaWJpbGl0aWVzLCBtZXNzYWdlKSB7XHJcbiAgaWYgKCEocGFyYW0gaW4gcG9zc2liaWxpdGllcykpIHtcclxuICAgIHJhaXNlKCd1bmtub3duIHBhcmFtZXRlciAoJyArIHBhcmFtICsgJyknICsgZW5jb2xvbihtZXNzYWdlKSArXHJcbiAgICAgICAgICAnLiBwb3NzaWJsZSB2YWx1ZXM6ICcgKyBPYmplY3Qua2V5cyhwb3NzaWJpbGl0aWVzKS5qb2luKCkpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gY2hlY2tJc1R5cGVkQXJyYXkgKGRhdGEsIG1lc3NhZ2UpIHtcclxuICBpZiAoIWlzVHlwZWRBcnJheShkYXRhKSkge1xyXG4gICAgcmFpc2UoXHJcbiAgICAgICdpbnZhbGlkIHBhcmFtZXRlciB0eXBlJyArIGVuY29sb24obWVzc2FnZSkgK1xyXG4gICAgICAnLiBtdXN0IGJlIGEgdHlwZWQgYXJyYXknKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoZWNrVHlwZU9mICh2YWx1ZSwgdHlwZSwgbWVzc2FnZSkge1xyXG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IHR5cGUpIHtcclxuICAgIHJhaXNlKFxyXG4gICAgICAnaW52YWxpZCBwYXJhbWV0ZXIgdHlwZScgKyBlbmNvbG9uKG1lc3NhZ2UpICtcclxuICAgICAgJy4gZXhwZWN0ZWQgJyArIHR5cGUgKyAnLCBnb3QgJyArICh0eXBlb2YgdmFsdWUpKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoZWNrTm9uTmVnYXRpdmVJbnQgKHZhbHVlLCBtZXNzYWdlKSB7XHJcbiAgaWYgKCEoKHZhbHVlID49IDApICYmXHJcbiAgICAgICAgKCh2YWx1ZSB8IDApID09PSB2YWx1ZSkpKSB7XHJcbiAgICByYWlzZSgnaW52YWxpZCBwYXJhbWV0ZXIgdHlwZSwgKCcgKyB2YWx1ZSArICcpJyArIGVuY29sb24obWVzc2FnZSkgK1xyXG4gICAgICAgICAgJy4gbXVzdCBiZSBhIG5vbm5lZ2F0aXZlIGludGVnZXInKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoZWNrT25lT2YgKHZhbHVlLCBsaXN0LCBtZXNzYWdlKSB7XHJcbiAgaWYgKGxpc3QuaW5kZXhPZih2YWx1ZSkgPCAwKSB7XHJcbiAgICByYWlzZSgnaW52YWxpZCB2YWx1ZScgKyBlbmNvbG9uKG1lc3NhZ2UpICsgJy4gbXVzdCBiZSBvbmUgb2Y6ICcgKyBsaXN0KTtcclxuICB9XHJcbn1cclxuXHJcbnZhciBjb25zdHJ1Y3RvcktleXMgPSBbXHJcbiAgJ2dsJyxcclxuICAnY2FudmFzJyxcclxuICAnY29udGFpbmVyJyxcclxuICAnYXR0cmlidXRlcycsXHJcbiAgJ3BpeGVsUmF0aW8nLFxyXG4gICdleHRlbnNpb25zJyxcclxuICAnb3B0aW9uYWxFeHRlbnNpb25zJyxcclxuICAncHJvZmlsZScsXHJcbiAgJ29uRG9uZSdcclxuXTtcclxuXHJcbmZ1bmN0aW9uIGNoZWNrQ29uc3RydWN0b3IgKG9iaikge1xyXG4gIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICBpZiAoY29uc3RydWN0b3JLZXlzLmluZGV4T2Yoa2V5KSA8IDApIHtcclxuICAgICAgcmFpc2UoJ2ludmFsaWQgcmVnbCBjb25zdHJ1Y3RvciBhcmd1bWVudCBcIicgKyBrZXkgKyAnXCIuIG11c3QgYmUgb25lIG9mICcgKyBjb25zdHJ1Y3RvcktleXMpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBsZWZ0UGFkIChzdHIsIG4pIHtcclxuICBzdHIgPSBzdHIgKyAnJztcclxuICB3aGlsZSAoc3RyLmxlbmd0aCA8IG4pIHtcclxuICAgIHN0ciA9ICcgJyArIHN0cjtcclxuICB9XHJcbiAgcmV0dXJuIHN0clxyXG59XHJcblxyXG5mdW5jdGlvbiBTaGFkZXJGaWxlICgpIHtcclxuICB0aGlzLm5hbWUgPSAndW5rbm93bic7XHJcbiAgdGhpcy5saW5lcyA9IFtdO1xyXG4gIHRoaXMuaW5kZXggPSB7fTtcclxuICB0aGlzLmhhc0Vycm9ycyA9IGZhbHNlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBTaGFkZXJMaW5lIChudW1iZXIsIGxpbmUpIHtcclxuICB0aGlzLm51bWJlciA9IG51bWJlcjtcclxuICB0aGlzLmxpbmUgPSBsaW5lO1xyXG4gIHRoaXMuZXJyb3JzID0gW107XHJcbn1cclxuXHJcbmZ1bmN0aW9uIFNoYWRlckVycm9yIChmaWxlTnVtYmVyLCBsaW5lTnVtYmVyLCBtZXNzYWdlKSB7XHJcbiAgdGhpcy5maWxlID0gZmlsZU51bWJlcjtcclxuICB0aGlzLmxpbmUgPSBsaW5lTnVtYmVyO1xyXG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGd1ZXNzQ29tbWFuZCAoKSB7XHJcbiAgdmFyIGVycm9yID0gbmV3IEVycm9yKCk7XHJcbiAgdmFyIHN0YWNrID0gKGVycm9yLnN0YWNrIHx8IGVycm9yKS50b1N0cmluZygpO1xyXG4gIHZhciBwYXQgPSAvY29tcGlsZVByb2NlZHVyZS4qXFxuXFxzKmF0LipcXCgoLiopXFwpLy5leGVjKHN0YWNrKTtcclxuICBpZiAocGF0KSB7XHJcbiAgICByZXR1cm4gcGF0WzFdXHJcbiAgfVxyXG4gIHZhciBwYXQyID0gL2NvbXBpbGVQcm9jZWR1cmUuKlxcblxccyphdFxccysoLiopKFxcbnwkKS8uZXhlYyhzdGFjayk7XHJcbiAgaWYgKHBhdDIpIHtcclxuICAgIHJldHVybiBwYXQyWzFdXHJcbiAgfVxyXG4gIHJldHVybiAndW5rbm93bidcclxufVxyXG5cclxuZnVuY3Rpb24gZ3Vlc3NDYWxsU2l0ZSAoKSB7XHJcbiAgdmFyIGVycm9yID0gbmV3IEVycm9yKCk7XHJcbiAgdmFyIHN0YWNrID0gKGVycm9yLnN0YWNrIHx8IGVycm9yKS50b1N0cmluZygpO1xyXG4gIHZhciBwYXQgPSAvYXQgUkVHTENvbW1hbmQuKlxcblxccythdC4qXFwoKC4qKVxcKS8uZXhlYyhzdGFjayk7XHJcbiAgaWYgKHBhdCkge1xyXG4gICAgcmV0dXJuIHBhdFsxXVxyXG4gIH1cclxuICB2YXIgcGF0MiA9IC9hdCBSRUdMQ29tbWFuZC4qXFxuXFxzK2F0XFxzKyguKilcXG4vLmV4ZWMoc3RhY2spO1xyXG4gIGlmIChwYXQyKSB7XHJcbiAgICByZXR1cm4gcGF0MlsxXVxyXG4gIH1cclxuICByZXR1cm4gJ3Vua25vd24nXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnNlU291cmNlIChzb3VyY2UsIGNvbW1hbmQpIHtcclxuICB2YXIgbGluZXMgPSBzb3VyY2Uuc3BsaXQoJ1xcbicpO1xyXG4gIHZhciBsaW5lTnVtYmVyID0gMTtcclxuICB2YXIgZmlsZU51bWJlciA9IDA7XHJcbiAgdmFyIGZpbGVzID0ge1xyXG4gICAgdW5rbm93bjogbmV3IFNoYWRlckZpbGUoKSxcclxuICAgIDA6IG5ldyBTaGFkZXJGaWxlKClcclxuICB9O1xyXG4gIGZpbGVzLnVua25vd24ubmFtZSA9IGZpbGVzWzBdLm5hbWUgPSBjb21tYW5kIHx8IGd1ZXNzQ29tbWFuZCgpO1xyXG4gIGZpbGVzLnVua25vd24ubGluZXMucHVzaChuZXcgU2hhZGVyTGluZSgwLCAnJykpO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIHtcclxuICAgIHZhciBsaW5lID0gbGluZXNbaV07XHJcbiAgICB2YXIgcGFydHMgPSAvXlxccypcXCNcXHMqKFxcdyspXFxzKyguKylcXHMqJC8uZXhlYyhsaW5lKTtcclxuICAgIGlmIChwYXJ0cykge1xyXG4gICAgICBzd2l0Y2ggKHBhcnRzWzFdKSB7XHJcbiAgICAgICAgY2FzZSAnbGluZSc6XHJcbiAgICAgICAgICB2YXIgbGluZU51bWJlckluZm8gPSAvKFxcZCspKFxccytcXGQrKT8vLmV4ZWMocGFydHNbMl0pO1xyXG4gICAgICAgICAgaWYgKGxpbmVOdW1iZXJJbmZvKSB7XHJcbiAgICAgICAgICAgIGxpbmVOdW1iZXIgPSBsaW5lTnVtYmVySW5mb1sxXSB8IDA7XHJcbiAgICAgICAgICAgIGlmIChsaW5lTnVtYmVySW5mb1syXSkge1xyXG4gICAgICAgICAgICAgIGZpbGVOdW1iZXIgPSBsaW5lTnVtYmVySW5mb1syXSB8IDA7XHJcbiAgICAgICAgICAgICAgaWYgKCEoZmlsZU51bWJlciBpbiBmaWxlcykpIHtcclxuICAgICAgICAgICAgICAgIGZpbGVzW2ZpbGVOdW1iZXJdID0gbmV3IFNoYWRlckZpbGUoKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgY2FzZSAnZGVmaW5lJzpcclxuICAgICAgICAgIHZhciBuYW1lSW5mbyA9IC9TSEFERVJfTkFNRShfQjY0KT9cXHMrKC4qKSQvLmV4ZWMocGFydHNbMl0pO1xyXG4gICAgICAgICAgaWYgKG5hbWVJbmZvKSB7XHJcbiAgICAgICAgICAgIGZpbGVzW2ZpbGVOdW1iZXJdLm5hbWUgPSAobmFtZUluZm9bMV1cclxuICAgICAgICAgICAgICAgID8gZGVjb2RlQjY0KG5hbWVJbmZvWzJdKVxyXG4gICAgICAgICAgICAgICAgOiBuYW1lSW5mb1syXSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVha1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBmaWxlc1tmaWxlTnVtYmVyXS5saW5lcy5wdXNoKG5ldyBTaGFkZXJMaW5lKGxpbmVOdW1iZXIrKywgbGluZSkpO1xyXG4gIH1cclxuICBPYmplY3Qua2V5cyhmaWxlcykuZm9yRWFjaChmdW5jdGlvbiAoZmlsZU51bWJlcikge1xyXG4gICAgdmFyIGZpbGUgPSBmaWxlc1tmaWxlTnVtYmVyXTtcclxuICAgIGZpbGUubGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xyXG4gICAgICBmaWxlLmluZGV4W2xpbmUubnVtYmVyXSA9IGxpbmU7XHJcbiAgICB9KTtcclxuICB9KTtcclxuICByZXR1cm4gZmlsZXNcclxufVxyXG5cclxuZnVuY3Rpb24gcGFyc2VFcnJvckxvZyAoZXJyTG9nKSB7XHJcbiAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gIGVyckxvZy5zcGxpdCgnXFxuJykuZm9yRWFjaChmdW5jdGlvbiAoZXJyTXNnKSB7XHJcbiAgICBpZiAoZXJyTXNnLmxlbmd0aCA8IDUpIHtcclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcbiAgICB2YXIgcGFydHMgPSAvXkVSUk9SXFw6XFxzKyhcXGQrKVxcOihcXGQrKVxcOlxccyooLiopJC8uZXhlYyhlcnJNc2cpO1xyXG4gICAgaWYgKHBhcnRzKSB7XHJcbiAgICAgIHJlc3VsdC5wdXNoKG5ldyBTaGFkZXJFcnJvcihcclxuICAgICAgICBwYXJ0c1sxXSB8IDAsXHJcbiAgICAgICAgcGFydHNbMl0gfCAwLFxyXG4gICAgICAgIHBhcnRzWzNdLnRyaW0oKSkpO1xyXG4gICAgfSBlbHNlIGlmIChlcnJNc2cubGVuZ3RoID4gMCkge1xyXG4gICAgICByZXN1bHQucHVzaChuZXcgU2hhZGVyRXJyb3IoJ3Vua25vd24nLCAwLCBlcnJNc2cpKTtcclxuICAgIH1cclxuICB9KTtcclxuICByZXR1cm4gcmVzdWx0XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFubm90YXRlRmlsZXMgKGZpbGVzLCBlcnJvcnMpIHtcclxuICBlcnJvcnMuZm9yRWFjaChmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgIHZhciBmaWxlID0gZmlsZXNbZXJyb3IuZmlsZV07XHJcbiAgICBpZiAoZmlsZSkge1xyXG4gICAgICB2YXIgbGluZSA9IGZpbGUuaW5kZXhbZXJyb3IubGluZV07XHJcbiAgICAgIGlmIChsaW5lKSB7XHJcbiAgICAgICAgbGluZS5lcnJvcnMucHVzaChlcnJvcik7XHJcbiAgICAgICAgZmlsZS5oYXNFcnJvcnMgPSB0cnVlO1xyXG4gICAgICAgIHJldHVyblxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBmaWxlcy51bmtub3duLmhhc0Vycm9ycyA9IHRydWU7XHJcbiAgICBmaWxlcy51bmtub3duLmxpbmVzWzBdLmVycm9ycy5wdXNoKGVycm9yKTtcclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2hlY2tTaGFkZXJFcnJvciAoZ2wsIHNoYWRlciwgc291cmNlLCB0eXBlLCBjb21tYW5kKSB7XHJcbiAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcclxuICAgIHZhciBlcnJMb2cgPSBnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcik7XHJcbiAgICB2YXIgdHlwZU5hbWUgPSB0eXBlID09PSBnbC5GUkFHTUVOVF9TSEFERVIgPyAnZnJhZ21lbnQnIDogJ3ZlcnRleCc7XHJcbiAgICBjaGVja0NvbW1hbmRUeXBlKHNvdXJjZSwgJ3N0cmluZycsIHR5cGVOYW1lICsgJyBzaGFkZXIgc291cmNlIG11c3QgYmUgYSBzdHJpbmcnLCBjb21tYW5kKTtcclxuICAgIHZhciBmaWxlcyA9IHBhcnNlU291cmNlKHNvdXJjZSwgY29tbWFuZCk7XHJcbiAgICB2YXIgZXJyb3JzID0gcGFyc2VFcnJvckxvZyhlcnJMb2cpO1xyXG4gICAgYW5ub3RhdGVGaWxlcyhmaWxlcywgZXJyb3JzKTtcclxuXHJcbiAgICBPYmplY3Qua2V5cyhmaWxlcykuZm9yRWFjaChmdW5jdGlvbiAoZmlsZU51bWJlcikge1xyXG4gICAgICB2YXIgZmlsZSA9IGZpbGVzW2ZpbGVOdW1iZXJdO1xyXG4gICAgICBpZiAoIWZpbGUuaGFzRXJyb3JzKSB7XHJcbiAgICAgICAgcmV0dXJuXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBzdHJpbmdzID0gWycnXTtcclxuICAgICAgdmFyIHN0eWxlcyA9IFsnJ107XHJcblxyXG4gICAgICBmdW5jdGlvbiBwdXNoIChzdHIsIHN0eWxlKSB7XHJcbiAgICAgICAgc3RyaW5ncy5wdXNoKHN0cik7XHJcbiAgICAgICAgc3R5bGVzLnB1c2goc3R5bGUgfHwgJycpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwdXNoKCdmaWxlIG51bWJlciAnICsgZmlsZU51bWJlciArICc6ICcgKyBmaWxlLm5hbWUgKyAnXFxuJywgJ2NvbG9yOnJlZDt0ZXh0LWRlY29yYXRpb246dW5kZXJsaW5lO2ZvbnQtd2VpZ2h0OmJvbGQnKTtcclxuXHJcbiAgICAgIGZpbGUubGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xyXG4gICAgICAgIGlmIChsaW5lLmVycm9ycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICBwdXNoKGxlZnRQYWQobGluZS5udW1iZXIsIDQpICsgJ3wgICcsICdiYWNrZ3JvdW5kLWNvbG9yOnllbGxvdzsgZm9udC13ZWlnaHQ6Ym9sZCcpO1xyXG4gICAgICAgICAgcHVzaChsaW5lLmxpbmUgKyBlbmRsLCAnY29sb3I6cmVkOyBiYWNrZ3JvdW5kLWNvbG9yOnllbGxvdzsgZm9udC13ZWlnaHQ6Ym9sZCcpO1xyXG5cclxuICAgICAgICAgIC8vIHRyeSB0byBndWVzcyB0b2tlblxyXG4gICAgICAgICAgdmFyIG9mZnNldCA9IDA7XHJcbiAgICAgICAgICBsaW5lLmVycm9ycy5mb3JFYWNoKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XHJcbiAgICAgICAgICAgIHZhciB0b2tlbiA9IC9eXFxzKlxcJyguKilcXCdcXHMqXFw6XFxzKiguKikkLy5leGVjKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICBpZiAodG9rZW4pIHtcclxuICAgICAgICAgICAgICB2YXIgdG9rZW5QYXQgPSB0b2tlblsxXTtcclxuICAgICAgICAgICAgICBtZXNzYWdlID0gdG9rZW5bMl07XHJcbiAgICAgICAgICAgICAgc3dpdGNoICh0b2tlblBhdCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnYXNzaWduJzpcclxuICAgICAgICAgICAgICAgICAgdG9rZW5QYXQgPSAnPSc7XHJcbiAgICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIG9mZnNldCA9IE1hdGgubWF4KGxpbmUubGluZS5pbmRleE9mKHRva2VuUGF0LCBvZmZzZXQpLCAwKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBvZmZzZXQgPSAwO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwdXNoKGxlZnRQYWQoJ3wgJywgNikpO1xyXG4gICAgICAgICAgICBwdXNoKGxlZnRQYWQoJ15eXicsIG9mZnNldCArIDMpICsgZW5kbCwgJ2ZvbnQtd2VpZ2h0OmJvbGQnKTtcclxuICAgICAgICAgICAgcHVzaChsZWZ0UGFkKCd8ICcsIDYpKTtcclxuICAgICAgICAgICAgcHVzaChtZXNzYWdlICsgZW5kbCwgJ2ZvbnQtd2VpZ2h0OmJvbGQnKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgcHVzaChsZWZ0UGFkKCd8ICcsIDYpICsgZW5kbCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHB1c2gobGVmdFBhZChsaW5lLm51bWJlciwgNCkgKyAnfCAgJyk7XHJcbiAgICAgICAgICBwdXNoKGxpbmUubGluZSArIGVuZGwsICdjb2xvcjpyZWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiAhd2luZG93LmNocm9tZSkge1xyXG4gICAgICAgIHN0eWxlc1swXSA9IHN0cmluZ3Muam9pbignJWMnKTtcclxuICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBzdHlsZXMpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKHN0cmluZ3Muam9pbignJykpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBjaGVjay5yYWlzZSgnRXJyb3IgY29tcGlsaW5nICcgKyB0eXBlTmFtZSArICcgc2hhZGVyLCAnICsgZmlsZXNbMF0ubmFtZSk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBjaGVja0xpbmtFcnJvciAoZ2wsIHByb2dyYW0sIGZyYWdTaGFkZXIsIHZlcnRTaGFkZXIsIGNvbW1hbmQpIHtcclxuICBpZiAoIWdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpKSB7XHJcbiAgICB2YXIgZXJyTG9nID0gZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSk7XHJcbiAgICB2YXIgZnJhZ1BhcnNlID0gcGFyc2VTb3VyY2UoZnJhZ1NoYWRlciwgY29tbWFuZCk7XHJcbiAgICB2YXIgdmVydFBhcnNlID0gcGFyc2VTb3VyY2UodmVydFNoYWRlciwgY29tbWFuZCk7XHJcblxyXG4gICAgdmFyIGhlYWRlciA9ICdFcnJvciBsaW5raW5nIHByb2dyYW0gd2l0aCB2ZXJ0ZXggc2hhZGVyLCBcIicgK1xyXG4gICAgICB2ZXJ0UGFyc2VbMF0ubmFtZSArICdcIiwgYW5kIGZyYWdtZW50IHNoYWRlciBcIicgKyBmcmFnUGFyc2VbMF0ubmFtZSArICdcIic7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgY29uc29sZS5sb2coJyVjJyArIGhlYWRlciArIGVuZGwgKyAnJWMnICsgZXJyTG9nLFxyXG4gICAgICAgICdjb2xvcjpyZWQ7dGV4dC1kZWNvcmF0aW9uOnVuZGVybGluZTtmb250LXdlaWdodDpib2xkJyxcclxuICAgICAgICAnY29sb3I6cmVkJyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zb2xlLmxvZyhoZWFkZXIgKyBlbmRsICsgZXJyTG9nKTtcclxuICAgIH1cclxuICAgIGNoZWNrLnJhaXNlKGhlYWRlcik7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBzYXZlQ29tbWFuZFJlZiAob2JqZWN0KSB7XHJcbiAgb2JqZWN0Ll9jb21tYW5kUmVmID0gZ3Vlc3NDb21tYW5kKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNhdmVEcmF3Q29tbWFuZEluZm8gKG9wdHMsIHVuaWZvcm1zLCBhdHRyaWJ1dGVzLCBzdHJpbmdTdG9yZSkge1xyXG4gIHNhdmVDb21tYW5kUmVmKG9wdHMpO1xyXG5cclxuICBmdW5jdGlvbiBpZCAoc3RyKSB7XHJcbiAgICBpZiAoc3RyKSB7XHJcbiAgICAgIHJldHVybiBzdHJpbmdTdG9yZS5pZChzdHIpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gMFxyXG4gIH1cclxuICBvcHRzLl9mcmFnSWQgPSBpZChvcHRzLnN0YXRpYy5mcmFnKTtcclxuICBvcHRzLl92ZXJ0SWQgPSBpZChvcHRzLnN0YXRpYy52ZXJ0KTtcclxuXHJcbiAgZnVuY3Rpb24gYWRkUHJvcHMgKGRpY3QsIHNldCkge1xyXG4gICAgT2JqZWN0LmtleXMoc2V0KS5mb3JFYWNoKGZ1bmN0aW9uICh1KSB7XHJcbiAgICAgIGRpY3Rbc3RyaW5nU3RvcmUuaWQodSldID0gdHJ1ZTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgdmFyIHVuaWZvcm1TZXQgPSBvcHRzLl91bmlmb3JtU2V0ID0ge307XHJcbiAgYWRkUHJvcHModW5pZm9ybVNldCwgdW5pZm9ybXMuc3RhdGljKTtcclxuICBhZGRQcm9wcyh1bmlmb3JtU2V0LCB1bmlmb3Jtcy5keW5hbWljKTtcclxuXHJcbiAgdmFyIGF0dHJpYnV0ZVNldCA9IG9wdHMuX2F0dHJpYnV0ZVNldCA9IHt9O1xyXG4gIGFkZFByb3BzKGF0dHJpYnV0ZVNldCwgYXR0cmlidXRlcy5zdGF0aWMpO1xyXG4gIGFkZFByb3BzKGF0dHJpYnV0ZVNldCwgYXR0cmlidXRlcy5keW5hbWljKTtcclxuXHJcbiAgb3B0cy5faGFzQ291bnQgPSAoXHJcbiAgICAnY291bnQnIGluIG9wdHMuc3RhdGljIHx8XHJcbiAgICAnY291bnQnIGluIG9wdHMuZHluYW1pYyB8fFxyXG4gICAgJ2VsZW1lbnRzJyBpbiBvcHRzLnN0YXRpYyB8fFxyXG4gICAgJ2VsZW1lbnRzJyBpbiBvcHRzLmR5bmFtaWMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb21tYW5kUmFpc2UgKG1lc3NhZ2UsIGNvbW1hbmQpIHtcclxuICB2YXIgY2FsbFNpdGUgPSBndWVzc0NhbGxTaXRlKCk7XHJcbiAgcmFpc2UobWVzc2FnZSArXHJcbiAgICAnIGluIGNvbW1hbmQgJyArIChjb21tYW5kIHx8IGd1ZXNzQ29tbWFuZCgpKSArXHJcbiAgICAoY2FsbFNpdGUgPT09ICd1bmtub3duJyA/ICcnIDogJyBjYWxsZWQgZnJvbSAnICsgY2FsbFNpdGUpKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2hlY2tDb21tYW5kIChwcmVkLCBtZXNzYWdlLCBjb21tYW5kKSB7XHJcbiAgaWYgKCFwcmVkKSB7XHJcbiAgICBjb21tYW5kUmFpc2UobWVzc2FnZSwgY29tbWFuZCB8fCBndWVzc0NvbW1hbmQoKSk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBjaGVja1BhcmFtZXRlckNvbW1hbmQgKHBhcmFtLCBwb3NzaWJpbGl0aWVzLCBtZXNzYWdlLCBjb21tYW5kKSB7XHJcbiAgaWYgKCEocGFyYW0gaW4gcG9zc2liaWxpdGllcykpIHtcclxuICAgIGNvbW1hbmRSYWlzZShcclxuICAgICAgJ3Vua25vd24gcGFyYW1ldGVyICgnICsgcGFyYW0gKyAnKScgKyBlbmNvbG9uKG1lc3NhZ2UpICtcclxuICAgICAgJy4gcG9zc2libGUgdmFsdWVzOiAnICsgT2JqZWN0LmtleXMocG9zc2liaWxpdGllcykuam9pbigpLFxyXG4gICAgICBjb21tYW5kIHx8IGd1ZXNzQ29tbWFuZCgpKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoZWNrQ29tbWFuZFR5cGUgKHZhbHVlLCB0eXBlLCBtZXNzYWdlLCBjb21tYW5kKSB7XHJcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gdHlwZSkge1xyXG4gICAgY29tbWFuZFJhaXNlKFxyXG4gICAgICAnaW52YWxpZCBwYXJhbWV0ZXIgdHlwZScgKyBlbmNvbG9uKG1lc3NhZ2UpICtcclxuICAgICAgJy4gZXhwZWN0ZWQgJyArIHR5cGUgKyAnLCBnb3QgJyArICh0eXBlb2YgdmFsdWUpLFxyXG4gICAgICBjb21tYW5kIHx8IGd1ZXNzQ29tbWFuZCgpKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoZWNrT3B0aW9uYWwgKGJsb2NrKSB7XHJcbiAgYmxvY2soKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2hlY2tGcmFtZWJ1ZmZlckZvcm1hdCAoYXR0YWNobWVudCwgdGV4Rm9ybWF0cywgcmJGb3JtYXRzKSB7XHJcbiAgaWYgKGF0dGFjaG1lbnQudGV4dHVyZSkge1xyXG4gICAgY2hlY2tPbmVPZihcclxuICAgICAgYXR0YWNobWVudC50ZXh0dXJlLl90ZXh0dXJlLmludGVybmFsZm9ybWF0LFxyXG4gICAgICB0ZXhGb3JtYXRzLFxyXG4gICAgICAndW5zdXBwb3J0ZWQgdGV4dHVyZSBmb3JtYXQgZm9yIGF0dGFjaG1lbnQnKTtcclxuICB9IGVsc2Uge1xyXG4gICAgY2hlY2tPbmVPZihcclxuICAgICAgYXR0YWNobWVudC5yZW5kZXJidWZmZXIuX3JlbmRlcmJ1ZmZlci5mb3JtYXQsXHJcbiAgICAgIHJiRm9ybWF0cyxcclxuICAgICAgJ3Vuc3VwcG9ydGVkIHJlbmRlcmJ1ZmZlciBmb3JtYXQgZm9yIGF0dGFjaG1lbnQnKTtcclxuICB9XHJcbn1cclxuXHJcbnZhciBHTF9DTEFNUF9UT19FREdFID0gMHg4MTJGO1xyXG5cclxudmFyIEdMX05FQVJFU1QgPSAweDI2MDA7XHJcbnZhciBHTF9ORUFSRVNUX01JUE1BUF9ORUFSRVNUID0gMHgyNzAwO1xyXG52YXIgR0xfTElORUFSX01JUE1BUF9ORUFSRVNUID0gMHgyNzAxO1xyXG52YXIgR0xfTkVBUkVTVF9NSVBNQVBfTElORUFSID0gMHgyNzAyO1xyXG52YXIgR0xfTElORUFSX01JUE1BUF9MSU5FQVIgPSAweDI3MDM7XHJcblxyXG52YXIgR0xfQllURSA9IDUxMjA7XHJcbnZhciBHTF9VTlNJR05FRF9CWVRFID0gNTEyMTtcclxudmFyIEdMX1NIT1JUID0gNTEyMjtcclxudmFyIEdMX1VOU0lHTkVEX1NIT1JUID0gNTEyMztcclxudmFyIEdMX0lOVCA9IDUxMjQ7XHJcbnZhciBHTF9VTlNJR05FRF9JTlQgPSA1MTI1O1xyXG52YXIgR0xfRkxPQVQgPSA1MTI2O1xyXG5cclxudmFyIEdMX1VOU0lHTkVEX1NIT1JUXzRfNF80XzQgPSAweDgwMzM7XHJcbnZhciBHTF9VTlNJR05FRF9TSE9SVF81XzVfNV8xID0gMHg4MDM0O1xyXG52YXIgR0xfVU5TSUdORURfU0hPUlRfNV82XzUgPSAweDgzNjM7XHJcbnZhciBHTF9VTlNJR05FRF9JTlRfMjRfOF9XRUJHTCA9IDB4ODRGQTtcclxuXHJcbnZhciBHTF9IQUxGX0ZMT0FUX09FUyA9IDB4OEQ2MTtcclxuXHJcbnZhciBUWVBFX1NJWkUgPSB7fTtcclxuXHJcblRZUEVfU0laRVtHTF9CWVRFXSA9XHJcblRZUEVfU0laRVtHTF9VTlNJR05FRF9CWVRFXSA9IDE7XHJcblxyXG5UWVBFX1NJWkVbR0xfU0hPUlRdID1cclxuVFlQRV9TSVpFW0dMX1VOU0lHTkVEX1NIT1JUXSA9XHJcblRZUEVfU0laRVtHTF9IQUxGX0ZMT0FUX09FU10gPVxyXG5UWVBFX1NJWkVbR0xfVU5TSUdORURfU0hPUlRfNV82XzVdID1cclxuVFlQRV9TSVpFW0dMX1VOU0lHTkVEX1NIT1JUXzRfNF80XzRdID1cclxuVFlQRV9TSVpFW0dMX1VOU0lHTkVEX1NIT1JUXzVfNV81XzFdID0gMjtcclxuXHJcblRZUEVfU0laRVtHTF9JTlRdID1cclxuVFlQRV9TSVpFW0dMX1VOU0lHTkVEX0lOVF0gPVxyXG5UWVBFX1NJWkVbR0xfRkxPQVRdID1cclxuVFlQRV9TSVpFW0dMX1VOU0lHTkVEX0lOVF8yNF84X1dFQkdMXSA9IDQ7XHJcblxyXG5mdW5jdGlvbiBwaXhlbFNpemUgKHR5cGUsIGNoYW5uZWxzKSB7XHJcbiAgaWYgKHR5cGUgPT09IEdMX1VOU0lHTkVEX1NIT1JUXzVfNV81XzEgfHxcclxuICAgICAgdHlwZSA9PT0gR0xfVU5TSUdORURfU0hPUlRfNF80XzRfNCB8fFxyXG4gICAgICB0eXBlID09PSBHTF9VTlNJR05FRF9TSE9SVF81XzZfNSkge1xyXG4gICAgcmV0dXJuIDJcclxuICB9IGVsc2UgaWYgKHR5cGUgPT09IEdMX1VOU0lHTkVEX0lOVF8yNF84X1dFQkdMKSB7XHJcbiAgICByZXR1cm4gNFxyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gVFlQRV9TSVpFW3R5cGVdICogY2hhbm5lbHNcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzUG93MiAodikge1xyXG4gIHJldHVybiAhKHYgJiAodiAtIDEpKSAmJiAoISF2KVxyXG59XHJcblxyXG5mdW5jdGlvbiBjaGVja1RleHR1cmUyRCAoaW5mbywgbWlwRGF0YSwgbGltaXRzKSB7XHJcbiAgdmFyIGk7XHJcbiAgdmFyIHcgPSBtaXBEYXRhLndpZHRoO1xyXG4gIHZhciBoID0gbWlwRGF0YS5oZWlnaHQ7XHJcbiAgdmFyIGMgPSBtaXBEYXRhLmNoYW5uZWxzO1xyXG5cclxuICAvLyBDaGVjayB0ZXh0dXJlIHNoYXBlXHJcbiAgY2hlY2sodyA+IDAgJiYgdyA8PSBsaW1pdHMubWF4VGV4dHVyZVNpemUgJiZcclxuICAgICAgICBoID4gMCAmJiBoIDw9IGxpbWl0cy5tYXhUZXh0dXJlU2l6ZSxcclxuICAgICAgICAnaW52YWxpZCB0ZXh0dXJlIHNoYXBlJyk7XHJcblxyXG4gIC8vIGNoZWNrIHdyYXAgbW9kZVxyXG4gIGlmIChpbmZvLndyYXBTICE9PSBHTF9DTEFNUF9UT19FREdFIHx8IGluZm8ud3JhcFQgIT09IEdMX0NMQU1QX1RPX0VER0UpIHtcclxuICAgIGNoZWNrKGlzUG93Mih3KSAmJiBpc1BvdzIoaCksXHJcbiAgICAgICdpbmNvbXBhdGlibGUgd3JhcCBtb2RlIGZvciB0ZXh0dXJlLCBib3RoIHdpZHRoIGFuZCBoZWlnaHQgbXVzdCBiZSBwb3dlciBvZiAyJyk7XHJcbiAgfVxyXG5cclxuICBpZiAobWlwRGF0YS5taXBtYXNrID09PSAxKSB7XHJcbiAgICBpZiAodyAhPT0gMSAmJiBoICE9PSAxKSB7XHJcbiAgICAgIGNoZWNrKFxyXG4gICAgICAgIGluZm8ubWluRmlsdGVyICE9PSBHTF9ORUFSRVNUX01JUE1BUF9ORUFSRVNUICYmXHJcbiAgICAgICAgaW5mby5taW5GaWx0ZXIgIT09IEdMX05FQVJFU1RfTUlQTUFQX0xJTkVBUiAmJlxyXG4gICAgICAgIGluZm8ubWluRmlsdGVyICE9PSBHTF9MSU5FQVJfTUlQTUFQX05FQVJFU1QgJiZcclxuICAgICAgICBpbmZvLm1pbkZpbHRlciAhPT0gR0xfTElORUFSX01JUE1BUF9MSU5FQVIsXHJcbiAgICAgICAgJ21pbiBmaWx0ZXIgcmVxdWlyZXMgbWlwbWFwJyk7XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIHRleHR1cmUgbXVzdCBiZSBwb3dlciBvZiAyXHJcbiAgICBjaGVjayhpc1BvdzIodykgJiYgaXNQb3cyKGgpLFxyXG4gICAgICAndGV4dHVyZSBtdXN0IGJlIGEgc3F1YXJlIHBvd2VyIG9mIDIgdG8gc3VwcG9ydCBtaXBtYXBwaW5nJyk7XHJcbiAgICBjaGVjayhtaXBEYXRhLm1pcG1hc2sgPT09ICh3IDw8IDEpIC0gMSxcclxuICAgICAgJ21pc3Npbmcgb3IgaW5jb21wbGV0ZSBtaXBtYXAgZGF0YScpO1xyXG4gIH1cclxuXHJcbiAgaWYgKG1pcERhdGEudHlwZSA9PT0gR0xfRkxPQVQpIHtcclxuICAgIGlmIChsaW1pdHMuZXh0ZW5zaW9ucy5pbmRleE9mKCdvZXNfdGV4dHVyZV9mbG9hdF9saW5lYXInKSA8IDApIHtcclxuICAgICAgY2hlY2soaW5mby5taW5GaWx0ZXIgPT09IEdMX05FQVJFU1QgJiYgaW5mby5tYWdGaWx0ZXIgPT09IEdMX05FQVJFU1QsXHJcbiAgICAgICAgJ2ZpbHRlciBub3Qgc3VwcG9ydGVkLCBtdXN0IGVuYWJsZSBvZXNfdGV4dHVyZV9mbG9hdF9saW5lYXInKTtcclxuICAgIH1cclxuICAgIGNoZWNrKCFpbmZvLmdlbk1pcG1hcHMsXHJcbiAgICAgICdtaXBtYXAgZ2VuZXJhdGlvbiBub3Qgc3VwcG9ydGVkIHdpdGggZmxvYXQgdGV4dHVyZXMnKTtcclxuICB9XHJcblxyXG4gIC8vIGNoZWNrIGltYWdlIGNvbXBsZXRlXHJcbiAgdmFyIG1pcGltYWdlcyA9IG1pcERhdGEuaW1hZ2VzO1xyXG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgKytpKSB7XHJcbiAgICBpZiAobWlwaW1hZ2VzW2ldKSB7XHJcbiAgICAgIHZhciBtdyA9IHcgPj4gaTtcclxuICAgICAgdmFyIG1oID0gaCA+PiBpO1xyXG4gICAgICBjaGVjayhtaXBEYXRhLm1pcG1hc2sgJiAoMSA8PCBpKSwgJ21pc3NpbmcgbWlwbWFwIGRhdGEnKTtcclxuXHJcbiAgICAgIHZhciBpbWcgPSBtaXBpbWFnZXNbaV07XHJcblxyXG4gICAgICBjaGVjayhcclxuICAgICAgICBpbWcud2lkdGggPT09IG13ICYmXHJcbiAgICAgICAgaW1nLmhlaWdodCA9PT0gbWgsXHJcbiAgICAgICAgJ2ludmFsaWQgc2hhcGUgZm9yIG1pcCBpbWFnZXMnKTtcclxuXHJcbiAgICAgIGNoZWNrKFxyXG4gICAgICAgIGltZy5mb3JtYXQgPT09IG1pcERhdGEuZm9ybWF0ICYmXHJcbiAgICAgICAgaW1nLmludGVybmFsZm9ybWF0ID09PSBtaXBEYXRhLmludGVybmFsZm9ybWF0ICYmXHJcbiAgICAgICAgaW1nLnR5cGUgPT09IG1pcERhdGEudHlwZSxcclxuICAgICAgICAnaW5jb21wYXRpYmxlIHR5cGUgZm9yIG1pcCBpbWFnZScpO1xyXG5cclxuICAgICAgaWYgKGltZy5jb21wcmVzc2VkKSB7XHJcbiAgICAgICAgLy8gVE9ETzogY2hlY2sgc2l6ZSBmb3IgY29tcHJlc3NlZCBpbWFnZXNcclxuICAgICAgfSBlbHNlIGlmIChpbWcuZGF0YSkge1xyXG4gICAgICAgIC8vIGNoZWNrKGltZy5kYXRhLmJ5dGVMZW5ndGggPT09IG13ICogbWggKlxyXG4gICAgICAgIC8vIE1hdGgubWF4KHBpeGVsU2l6ZShpbWcudHlwZSwgYyksIGltZy51bnBhY2tBbGlnbm1lbnQpLFxyXG4gICAgICAgIHZhciByb3dTaXplID0gTWF0aC5jZWlsKHBpeGVsU2l6ZShpbWcudHlwZSwgYykgKiBtdyAvIGltZy51bnBhY2tBbGlnbm1lbnQpICogaW1nLnVucGFja0FsaWdubWVudDtcclxuICAgICAgICBjaGVjayhpbWcuZGF0YS5ieXRlTGVuZ3RoID09PSByb3dTaXplICogbWgsXHJcbiAgICAgICAgICAnaW52YWxpZCBkYXRhIGZvciBpbWFnZSwgYnVmZmVyIHNpemUgaXMgaW5jb25zaXN0ZW50IHdpdGggaW1hZ2UgZm9ybWF0Jyk7XHJcbiAgICAgIH0gZWxzZSBpZiAoaW1nLmVsZW1lbnQpIHtcclxuICAgICAgICAvLyBUT0RPOiBjaGVjayBlbGVtZW50IGNhbiBiZSBsb2FkZWRcclxuICAgICAgfSBlbHNlIGlmIChpbWcuY29weSkge1xyXG4gICAgICAgIC8vIFRPRE86IGNoZWNrIGNvbXBhdGlibGUgZm9ybWF0IGFuZCB0eXBlXHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoIWluZm8uZ2VuTWlwbWFwcykge1xyXG4gICAgICBjaGVjaygobWlwRGF0YS5taXBtYXNrICYgKDEgPDwgaSkpID09PSAwLCAnZXh0cmEgbWlwbWFwIGRhdGEnKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChtaXBEYXRhLmNvbXByZXNzZWQpIHtcclxuICAgIGNoZWNrKCFpbmZvLmdlbk1pcG1hcHMsXHJcbiAgICAgICdtaXBtYXAgZ2VuZXJhdGlvbiBmb3IgY29tcHJlc3NlZCBpbWFnZXMgbm90IHN1cHBvcnRlZCcpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gY2hlY2tUZXh0dXJlQ3ViZSAodGV4dHVyZSwgaW5mbywgZmFjZXMsIGxpbWl0cykge1xyXG4gIHZhciB3ID0gdGV4dHVyZS53aWR0aDtcclxuICB2YXIgaCA9IHRleHR1cmUuaGVpZ2h0O1xyXG4gIHZhciBjID0gdGV4dHVyZS5jaGFubmVscztcclxuXHJcbiAgLy8gQ2hlY2sgdGV4dHVyZSBzaGFwZVxyXG4gIGNoZWNrKFxyXG4gICAgdyA+IDAgJiYgdyA8PSBsaW1pdHMubWF4VGV4dHVyZVNpemUgJiYgaCA+IDAgJiYgaCA8PSBsaW1pdHMubWF4VGV4dHVyZVNpemUsXHJcbiAgICAnaW52YWxpZCB0ZXh0dXJlIHNoYXBlJyk7XHJcbiAgY2hlY2soXHJcbiAgICB3ID09PSBoLFxyXG4gICAgJ2N1YmUgbWFwIG11c3QgYmUgc3F1YXJlJyk7XHJcbiAgY2hlY2soXHJcbiAgICBpbmZvLndyYXBTID09PSBHTF9DTEFNUF9UT19FREdFICYmIGluZm8ud3JhcFQgPT09IEdMX0NMQU1QX1RPX0VER0UsXHJcbiAgICAnd3JhcCBtb2RlIG5vdCBzdXBwb3J0ZWQgYnkgY3ViZSBtYXAnKTtcclxuXHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmYWNlcy5sZW5ndGg7ICsraSkge1xyXG4gICAgdmFyIGZhY2UgPSBmYWNlc1tpXTtcclxuICAgIGNoZWNrKFxyXG4gICAgICBmYWNlLndpZHRoID09PSB3ICYmIGZhY2UuaGVpZ2h0ID09PSBoLFxyXG4gICAgICAnaW5jb25zaXN0ZW50IGN1YmUgbWFwIGZhY2Ugc2hhcGUnKTtcclxuXHJcbiAgICBpZiAoaW5mby5nZW5NaXBtYXBzKSB7XHJcbiAgICAgIGNoZWNrKCFmYWNlLmNvbXByZXNzZWQsXHJcbiAgICAgICAgJ2NhbiBub3QgZ2VuZXJhdGUgbWlwbWFwIGZvciBjb21wcmVzc2VkIHRleHR1cmVzJyk7XHJcbiAgICAgIGNoZWNrKGZhY2UubWlwbWFzayA9PT0gMSxcclxuICAgICAgICAnY2FuIG5vdCBzcGVjaWZ5IG1pcG1hcHMgYW5kIGdlbmVyYXRlIG1pcG1hcHMnKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIFRPRE86IGNoZWNrIG1pcCBhbmQgZmlsdGVyIG1vZGVcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbWlwbWFwcyA9IGZhY2UuaW1hZ2VzO1xyXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCAxNjsgKytqKSB7XHJcbiAgICAgIHZhciBpbWcgPSBtaXBtYXBzW2pdO1xyXG4gICAgICBpZiAoaW1nKSB7XHJcbiAgICAgICAgdmFyIG13ID0gdyA+PiBqO1xyXG4gICAgICAgIHZhciBtaCA9IGggPj4gajtcclxuICAgICAgICBjaGVjayhmYWNlLm1pcG1hc2sgJiAoMSA8PCBqKSwgJ21pc3NpbmcgbWlwbWFwIGRhdGEnKTtcclxuICAgICAgICBjaGVjayhcclxuICAgICAgICAgIGltZy53aWR0aCA9PT0gbXcgJiZcclxuICAgICAgICAgIGltZy5oZWlnaHQgPT09IG1oLFxyXG4gICAgICAgICAgJ2ludmFsaWQgc2hhcGUgZm9yIG1pcCBpbWFnZXMnKTtcclxuICAgICAgICBjaGVjayhcclxuICAgICAgICAgIGltZy5mb3JtYXQgPT09IHRleHR1cmUuZm9ybWF0ICYmXHJcbiAgICAgICAgICBpbWcuaW50ZXJuYWxmb3JtYXQgPT09IHRleHR1cmUuaW50ZXJuYWxmb3JtYXQgJiZcclxuICAgICAgICAgIGltZy50eXBlID09PSB0ZXh0dXJlLnR5cGUsXHJcbiAgICAgICAgICAnaW5jb21wYXRpYmxlIHR5cGUgZm9yIG1pcCBpbWFnZScpO1xyXG5cclxuICAgICAgICBpZiAoaW1nLmNvbXByZXNzZWQpIHtcclxuICAgICAgICAgIC8vIFRPRE86IGNoZWNrIHNpemUgZm9yIGNvbXByZXNzZWQgaW1hZ2VzXHJcbiAgICAgICAgfSBlbHNlIGlmIChpbWcuZGF0YSkge1xyXG4gICAgICAgICAgY2hlY2soaW1nLmRhdGEuYnl0ZUxlbmd0aCA9PT0gbXcgKiBtaCAqXHJcbiAgICAgICAgICAgIE1hdGgubWF4KHBpeGVsU2l6ZShpbWcudHlwZSwgYyksIGltZy51bnBhY2tBbGlnbm1lbnQpLFxyXG4gICAgICAgICAgICAnaW52YWxpZCBkYXRhIGZvciBpbWFnZSwgYnVmZmVyIHNpemUgaXMgaW5jb25zaXN0ZW50IHdpdGggaW1hZ2UgZm9ybWF0Jyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpbWcuZWxlbWVudCkge1xyXG4gICAgICAgICAgLy8gVE9ETzogY2hlY2sgZWxlbWVudCBjYW4gYmUgbG9hZGVkXHJcbiAgICAgICAgfSBlbHNlIGlmIChpbWcuY29weSkge1xyXG4gICAgICAgICAgLy8gVE9ETzogY2hlY2sgY29tcGF0aWJsZSBmb3JtYXQgYW5kIHR5cGVcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbnZhciBjaGVjayQxID0gZXh0ZW5kKGNoZWNrLCB7XHJcbiAgb3B0aW9uYWw6IGNoZWNrT3B0aW9uYWwsXHJcbiAgcmFpc2U6IHJhaXNlLFxyXG4gIGNvbW1hbmRSYWlzZTogY29tbWFuZFJhaXNlLFxyXG4gIGNvbW1hbmQ6IGNoZWNrQ29tbWFuZCxcclxuICBwYXJhbWV0ZXI6IGNoZWNrUGFyYW1ldGVyLFxyXG4gIGNvbW1hbmRQYXJhbWV0ZXI6IGNoZWNrUGFyYW1ldGVyQ29tbWFuZCxcclxuICBjb25zdHJ1Y3RvcjogY2hlY2tDb25zdHJ1Y3RvcixcclxuICB0eXBlOiBjaGVja1R5cGVPZixcclxuICBjb21tYW5kVHlwZTogY2hlY2tDb21tYW5kVHlwZSxcclxuICBpc1R5cGVkQXJyYXk6IGNoZWNrSXNUeXBlZEFycmF5LFxyXG4gIG5uaTogY2hlY2tOb25OZWdhdGl2ZUludCxcclxuICBvbmVPZjogY2hlY2tPbmVPZixcclxuICBzaGFkZXJFcnJvcjogY2hlY2tTaGFkZXJFcnJvcixcclxuICBsaW5rRXJyb3I6IGNoZWNrTGlua0Vycm9yLFxyXG4gIGNhbGxTaXRlOiBndWVzc0NhbGxTaXRlLFxyXG4gIHNhdmVDb21tYW5kUmVmOiBzYXZlQ29tbWFuZFJlZixcclxuICBzYXZlRHJhd0luZm86IHNhdmVEcmF3Q29tbWFuZEluZm8sXHJcbiAgZnJhbWVidWZmZXJGb3JtYXQ6IGNoZWNrRnJhbWVidWZmZXJGb3JtYXQsXHJcbiAgZ3Vlc3NDb21tYW5kOiBndWVzc0NvbW1hbmQsXHJcbiAgdGV4dHVyZTJEOiBjaGVja1RleHR1cmUyRCxcclxuICB0ZXh0dXJlQ3ViZTogY2hlY2tUZXh0dXJlQ3ViZVxyXG59KTtcclxuXHJcbnZhciBWQVJJQUJMRV9DT1VOVEVSID0gMDtcclxuXHJcbnZhciBEWU5fRlVOQyA9IDA7XHJcblxyXG5mdW5jdGlvbiBEeW5hbWljVmFyaWFibGUgKHR5cGUsIGRhdGEpIHtcclxuICB0aGlzLmlkID0gKFZBUklBQkxFX0NPVU5URVIrKyk7XHJcbiAgdGhpcy50eXBlID0gdHlwZTtcclxuICB0aGlzLmRhdGEgPSBkYXRhO1xyXG59XHJcblxyXG5mdW5jdGlvbiBlc2NhcGVTdHIgKHN0cikge1xyXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKS5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJylcclxufVxyXG5cclxuZnVuY3Rpb24gc3BsaXRQYXJ0cyAoc3RyKSB7XHJcbiAgaWYgKHN0ci5sZW5ndGggPT09IDApIHtcclxuICAgIHJldHVybiBbXVxyXG4gIH1cclxuXHJcbiAgdmFyIGZpcnN0Q2hhciA9IHN0ci5jaGFyQXQoMCk7XHJcbiAgdmFyIGxhc3RDaGFyID0gc3RyLmNoYXJBdChzdHIubGVuZ3RoIC0gMSk7XHJcblxyXG4gIGlmIChzdHIubGVuZ3RoID4gMSAmJlxyXG4gICAgICBmaXJzdENoYXIgPT09IGxhc3RDaGFyICYmXHJcbiAgICAgIChmaXJzdENoYXIgPT09ICdcIicgfHwgZmlyc3RDaGFyID09PSBcIidcIikpIHtcclxuICAgIHJldHVybiBbJ1wiJyArIGVzY2FwZVN0cihzdHIuc3Vic3RyKDEsIHN0ci5sZW5ndGggLSAyKSkgKyAnXCInXVxyXG4gIH1cclxuXHJcbiAgdmFyIHBhcnRzID0gL1xcWyhmYWxzZXx0cnVlfG51bGx8XFxkK3wnW14nXSonfFwiW15cIl0qXCIpXFxdLy5leGVjKHN0cik7XHJcbiAgaWYgKHBhcnRzKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICBzcGxpdFBhcnRzKHN0ci5zdWJzdHIoMCwgcGFydHMuaW5kZXgpKVxyXG4gICAgICAuY29uY2F0KHNwbGl0UGFydHMocGFydHNbMV0pKVxyXG4gICAgICAuY29uY2F0KHNwbGl0UGFydHMoc3RyLnN1YnN0cihwYXJ0cy5pbmRleCArIHBhcnRzWzBdLmxlbmd0aCkpKVxyXG4gICAgKVxyXG4gIH1cclxuXHJcbiAgdmFyIHN1YnBhcnRzID0gc3RyLnNwbGl0KCcuJyk7XHJcbiAgaWYgKHN1YnBhcnRzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgcmV0dXJuIFsnXCInICsgZXNjYXBlU3RyKHN0cikgKyAnXCInXVxyXG4gIH1cclxuXHJcbiAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3VicGFydHMubGVuZ3RoOyArK2kpIHtcclxuICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoc3BsaXRQYXJ0cyhzdWJwYXJ0c1tpXSkpO1xyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRvQWNjZXNzb3JTdHJpbmcgKHN0cikge1xyXG4gIHJldHVybiAnWycgKyBzcGxpdFBhcnRzKHN0cikuam9pbignXVsnKSArICddJ1xyXG59XHJcblxyXG5mdW5jdGlvbiBkZWZpbmVEeW5hbWljICh0eXBlLCBkYXRhKSB7XHJcbiAgcmV0dXJuIG5ldyBEeW5hbWljVmFyaWFibGUodHlwZSwgdG9BY2Nlc3NvclN0cmluZyhkYXRhICsgJycpKVxyXG59XHJcblxyXG5mdW5jdGlvbiBpc0R5bmFtaWMgKHgpIHtcclxuICByZXR1cm4gKHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nICYmICF4Ll9yZWdsVHlwZSkgfHxcclxuICAgICAgICAgeCBpbnN0YW5jZW9mIER5bmFtaWNWYXJpYWJsZVxyXG59XHJcblxyXG5mdW5jdGlvbiB1bmJveCAoeCwgcGF0aCkge1xyXG4gIGlmICh0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgcmV0dXJuIG5ldyBEeW5hbWljVmFyaWFibGUoRFlOX0ZVTkMsIHgpXHJcbiAgfVxyXG4gIHJldHVybiB4XHJcbn1cclxuXHJcbnZhciBkeW5hbWljID0ge1xyXG4gIER5bmFtaWNWYXJpYWJsZTogRHluYW1pY1ZhcmlhYmxlLFxyXG4gIGRlZmluZTogZGVmaW5lRHluYW1pYyxcclxuICBpc0R5bmFtaWM6IGlzRHluYW1pYyxcclxuICB1bmJveDogdW5ib3gsXHJcbiAgYWNjZXNzb3I6IHRvQWNjZXNzb3JTdHJpbmdcclxufTtcclxuXHJcbi8qIGdsb2JhbHMgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLCBjYW5jZWxBbmltYXRpb25GcmFtZSAqL1xyXG52YXIgcmFmID0ge1xyXG4gIG5leHQ6IHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09ICdmdW5jdGlvbidcclxuICAgID8gZnVuY3Rpb24gKGNiKSB7IHJldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2IpIH1cclxuICAgIDogZnVuY3Rpb24gKGNiKSB7IHJldHVybiBzZXRUaW1lb3V0KGNiLCAxNikgfSxcclxuICBjYW5jZWw6IHR5cGVvZiBjYW5jZWxBbmltYXRpb25GcmFtZSA9PT0gJ2Z1bmN0aW9uJ1xyXG4gICAgPyBmdW5jdGlvbiAocmFmKSB7IHJldHVybiBjYW5jZWxBbmltYXRpb25GcmFtZShyYWYpIH1cclxuICAgIDogY2xlYXJUaW1lb3V0XHJcbn07XHJcblxyXG4vKiBnbG9iYWxzIHBlcmZvcm1hbmNlICovXHJcbnZhciBjbG9jayA9ICh0eXBlb2YgcGVyZm9ybWFuY2UgIT09ICd1bmRlZmluZWQnICYmIHBlcmZvcm1hbmNlLm5vdylcclxuICA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpIH1cclxuICA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICsobmV3IERhdGUoKSkgfTtcclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVN0cmluZ1N0b3JlICgpIHtcclxuICB2YXIgc3RyaW5nSWRzID0geycnOiAwfTtcclxuICB2YXIgc3RyaW5nVmFsdWVzID0gWycnXTtcclxuICByZXR1cm4ge1xyXG4gICAgaWQ6IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgICAgdmFyIHJlc3VsdCA9IHN0cmluZ0lkc1tzdHJdO1xyXG4gICAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxyXG4gICAgICB9XHJcbiAgICAgIHJlc3VsdCA9IHN0cmluZ0lkc1tzdHJdID0gc3RyaW5nVmFsdWVzLmxlbmd0aDtcclxuICAgICAgc3RyaW5nVmFsdWVzLnB1c2goc3RyKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdFxyXG4gICAgfSxcclxuXHJcbiAgICBzdHI6IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICByZXR1cm4gc3RyaW5nVmFsdWVzW2lkXVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8gQ29udGV4dCBhbmQgY2FudmFzIGNyZWF0aW9uIGhlbHBlciBmdW5jdGlvbnNcclxuZnVuY3Rpb24gY3JlYXRlQ2FudmFzIChlbGVtZW50LCBvbkRvbmUsIHBpeGVsUmF0aW8pIHtcclxuICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgZXh0ZW5kKGNhbnZhcy5zdHlsZSwge1xyXG4gICAgYm9yZGVyOiAwLFxyXG4gICAgbWFyZ2luOiAwLFxyXG4gICAgcGFkZGluZzogMCxcclxuICAgIHRvcDogMCxcclxuICAgIGxlZnQ6IDBcclxuICB9KTtcclxuICBlbGVtZW50LmFwcGVuZENoaWxkKGNhbnZhcyk7XHJcblxyXG4gIGlmIChlbGVtZW50ID09PSBkb2N1bWVudC5ib2R5KSB7XHJcbiAgICBjYW52YXMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gICAgZXh0ZW5kKGVsZW1lbnQuc3R5bGUsIHtcclxuICAgICAgbWFyZ2luOiAwLFxyXG4gICAgICBwYWRkaW5nOiAwXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlc2l6ZSAoKSB7XHJcbiAgICB2YXIgdyA9IHdpbmRvdy5pbm5lcldpZHRoO1xyXG4gICAgdmFyIGggPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XHJcbiAgICBpZiAoZWxlbWVudCAhPT0gZG9jdW1lbnQuYm9keSkge1xyXG4gICAgICB2YXIgYm91bmRzID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgdyA9IGJvdW5kcy5yaWdodCAtIGJvdW5kcy5sZWZ0O1xyXG4gICAgICBoID0gYm91bmRzLmJvdHRvbSAtIGJvdW5kcy50b3A7XHJcbiAgICB9XHJcbiAgICBjYW52YXMud2lkdGggPSBwaXhlbFJhdGlvICogdztcclxuICAgIGNhbnZhcy5oZWlnaHQgPSBwaXhlbFJhdGlvICogaDtcclxuICAgIGV4dGVuZChjYW52YXMuc3R5bGUsIHtcclxuICAgICAgd2lkdGg6IHcgKyAncHgnLFxyXG4gICAgICBoZWlnaHQ6IGggKyAncHgnXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCByZXNpemUsIGZhbHNlKTtcclxuXHJcbiAgZnVuY3Rpb24gb25EZXN0cm95ICgpIHtcclxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCByZXNpemUpO1xyXG4gICAgZWxlbWVudC5yZW1vdmVDaGlsZChjYW52YXMpO1xyXG4gIH1cclxuXHJcbiAgcmVzaXplKCk7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBjYW52YXM6IGNhbnZhcyxcclxuICAgIG9uRGVzdHJveTogb25EZXN0cm95XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVDb250ZXh0IChjYW52YXMsIGNvbnRleHRBdHRyaWJ1dGVzKSB7XHJcbiAgZnVuY3Rpb24gZ2V0IChuYW1lKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICByZXR1cm4gY2FudmFzLmdldENvbnRleHQobmFtZSwgY29udGV4dEF0dHJpYnV0ZXMpXHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIHJldHVybiBudWxsXHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiAoXHJcbiAgICBnZXQoJ3dlYmdsJykgfHxcclxuICAgIGdldCgnZXhwZXJpbWVudGFsLXdlYmdsJykgfHxcclxuICAgIGdldCgnd2ViZ2wtZXhwZXJpbWVudGFsJylcclxuICApXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzSFRNTEVsZW1lbnQgKG9iaikge1xyXG4gIHJldHVybiAoXHJcbiAgICB0eXBlb2Ygb2JqLm5vZGVOYW1lID09PSAnc3RyaW5nJyAmJlxyXG4gICAgdHlwZW9mIG9iai5hcHBlbmRDaGlsZCA9PT0gJ2Z1bmN0aW9uJyAmJlxyXG4gICAgdHlwZW9mIG9iai5nZXRCb3VuZGluZ0NsaWVudFJlY3QgPT09ICdmdW5jdGlvbidcclxuICApXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzV2ViR0xDb250ZXh0IChvYmopIHtcclxuICByZXR1cm4gKFxyXG4gICAgdHlwZW9mIG9iai5kcmF3QXJyYXlzID09PSAnZnVuY3Rpb24nIHx8XHJcbiAgICB0eXBlb2Ygb2JqLmRyYXdFbGVtZW50cyA9PT0gJ2Z1bmN0aW9uJ1xyXG4gIClcclxufVxyXG5cclxuZnVuY3Rpb24gcGFyc2VFeHRlbnNpb25zIChpbnB1dCkge1xyXG4gIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICByZXR1cm4gaW5wdXQuc3BsaXQoKVxyXG4gIH1cclxuICBjaGVjayQxKEFycmF5LmlzQXJyYXkoaW5wdXQpLCAnaW52YWxpZCBleHRlbnNpb24gYXJyYXknKTtcclxuICByZXR1cm4gaW5wdXRcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0RWxlbWVudCAoZGVzYykge1xyXG4gIGlmICh0eXBlb2YgZGVzYyA9PT0gJ3N0cmluZycpIHtcclxuICAgIGNoZWNrJDEodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJywgJ25vdCBzdXBwb3J0ZWQgb3V0c2lkZSBvZiBET00nKTtcclxuICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGRlc2MpXHJcbiAgfVxyXG4gIHJldHVybiBkZXNjXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnNlQXJncyAoYXJnc18pIHtcclxuICB2YXIgYXJncyA9IGFyZ3NfIHx8IHt9O1xyXG4gIHZhciBlbGVtZW50LCBjb250YWluZXIsIGNhbnZhcywgZ2w7XHJcbiAgdmFyIGNvbnRleHRBdHRyaWJ1dGVzID0ge307XHJcbiAgdmFyIGV4dGVuc2lvbnMgPSBbXTtcclxuICB2YXIgb3B0aW9uYWxFeHRlbnNpb25zID0gW107XHJcbiAgdmFyIHBpeGVsUmF0aW8gPSAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyAxIDogd2luZG93LmRldmljZVBpeGVsUmF0aW8pO1xyXG4gIHZhciBwcm9maWxlID0gZmFsc2U7XHJcbiAgdmFyIG9uRG9uZSA9IGZ1bmN0aW9uIChlcnIpIHtcclxuICAgIGlmIChlcnIpIHtcclxuICAgICAgY2hlY2skMS5yYWlzZShlcnIpO1xyXG4gICAgfVxyXG4gIH07XHJcbiAgdmFyIG9uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHt9O1xyXG4gIGlmICh0eXBlb2YgYXJncyA9PT0gJ3N0cmluZycpIHtcclxuICAgIGNoZWNrJDEoXHJcbiAgICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcsXHJcbiAgICAgICdzZWxlY3RvciBxdWVyaWVzIG9ubHkgc3VwcG9ydGVkIGluIERPTSBlbnZpcm9tZW50cycpO1xyXG4gICAgZWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYXJncyk7XHJcbiAgICBjaGVjayQxKGVsZW1lbnQsICdpbnZhbGlkIHF1ZXJ5IHN0cmluZyBmb3IgZWxlbWVudCcpO1xyXG4gIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3MgPT09ICdvYmplY3QnKSB7XHJcbiAgICBpZiAoaXNIVE1MRWxlbWVudChhcmdzKSkge1xyXG4gICAgICBlbGVtZW50ID0gYXJncztcclxuICAgIH0gZWxzZSBpZiAoaXNXZWJHTENvbnRleHQoYXJncykpIHtcclxuICAgICAgZ2wgPSBhcmdzO1xyXG4gICAgICBjYW52YXMgPSBnbC5jYW52YXM7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjaGVjayQxLmNvbnN0cnVjdG9yKGFyZ3MpO1xyXG4gICAgICBpZiAoJ2dsJyBpbiBhcmdzKSB7XHJcbiAgICAgICAgZ2wgPSBhcmdzLmdsO1xyXG4gICAgICB9IGVsc2UgaWYgKCdjYW52YXMnIGluIGFyZ3MpIHtcclxuICAgICAgICBjYW52YXMgPSBnZXRFbGVtZW50KGFyZ3MuY2FudmFzKTtcclxuICAgICAgfSBlbHNlIGlmICgnY29udGFpbmVyJyBpbiBhcmdzKSB7XHJcbiAgICAgICAgY29udGFpbmVyID0gZ2V0RWxlbWVudChhcmdzLmNvbnRhaW5lcik7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCdhdHRyaWJ1dGVzJyBpbiBhcmdzKSB7XHJcbiAgICAgICAgY29udGV4dEF0dHJpYnV0ZXMgPSBhcmdzLmF0dHJpYnV0ZXM7XHJcbiAgICAgICAgY2hlY2skMS50eXBlKGNvbnRleHRBdHRyaWJ1dGVzLCAnb2JqZWN0JywgJ2ludmFsaWQgY29udGV4dCBhdHRyaWJ1dGVzJyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCdleHRlbnNpb25zJyBpbiBhcmdzKSB7XHJcbiAgICAgICAgZXh0ZW5zaW9ucyA9IHBhcnNlRXh0ZW5zaW9ucyhhcmdzLmV4dGVuc2lvbnMpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICgnb3B0aW9uYWxFeHRlbnNpb25zJyBpbiBhcmdzKSB7XHJcbiAgICAgICAgb3B0aW9uYWxFeHRlbnNpb25zID0gcGFyc2VFeHRlbnNpb25zKGFyZ3Mub3B0aW9uYWxFeHRlbnNpb25zKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoJ29uRG9uZScgaW4gYXJncykge1xyXG4gICAgICAgIGNoZWNrJDEudHlwZShcclxuICAgICAgICAgIGFyZ3Mub25Eb25lLCAnZnVuY3Rpb24nLFxyXG4gICAgICAgICAgJ2ludmFsaWQgb3IgbWlzc2luZyBvbkRvbmUgY2FsbGJhY2snKTtcclxuICAgICAgICBvbkRvbmUgPSBhcmdzLm9uRG9uZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoJ3Byb2ZpbGUnIGluIGFyZ3MpIHtcclxuICAgICAgICBwcm9maWxlID0gISFhcmdzLnByb2ZpbGU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCdwaXhlbFJhdGlvJyBpbiBhcmdzKSB7XHJcbiAgICAgICAgcGl4ZWxSYXRpbyA9ICthcmdzLnBpeGVsUmF0aW87XHJcbiAgICAgICAgY2hlY2skMShwaXhlbFJhdGlvID4gMCwgJ2ludmFsaWQgcGl4ZWwgcmF0aW8nKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICBjaGVjayQxLnJhaXNlKCdpbnZhbGlkIGFyZ3VtZW50cyB0byByZWdsJyk7XHJcbiAgfVxyXG5cclxuICBpZiAoZWxlbWVudCkge1xyXG4gICAgaWYgKGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2NhbnZhcycpIHtcclxuICAgICAgY2FudmFzID0gZWxlbWVudDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnRhaW5lciA9IGVsZW1lbnQ7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAoIWdsKSB7XHJcbiAgICBpZiAoIWNhbnZhcykge1xyXG4gICAgICBjaGVjayQxKFxyXG4gICAgICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcsXHJcbiAgICAgICAgJ211c3QgbWFudWFsbHkgc3BlY2lmeSB3ZWJnbCBjb250ZXh0IG91dHNpZGUgb2YgRE9NIGVudmlyb25tZW50cycpO1xyXG4gICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlQ2FudmFzKGNvbnRhaW5lciB8fCBkb2N1bWVudC5ib2R5LCBvbkRvbmUsIHBpeGVsUmF0aW8pO1xyXG4gICAgICBpZiAoIXJlc3VsdCkge1xyXG4gICAgICAgIHJldHVybiBudWxsXHJcbiAgICAgIH1cclxuICAgICAgY2FudmFzID0gcmVzdWx0LmNhbnZhcztcclxuICAgICAgb25EZXN0cm95ID0gcmVzdWx0Lm9uRGVzdHJveTtcclxuICAgIH1cclxuICAgIGdsID0gY3JlYXRlQ29udGV4dChjYW52YXMsIGNvbnRleHRBdHRyaWJ1dGVzKTtcclxuICB9XHJcblxyXG4gIGlmICghZ2wpIHtcclxuICAgIG9uRGVzdHJveSgpO1xyXG4gICAgb25Eb25lKCd3ZWJnbCBub3Qgc3VwcG9ydGVkLCB0cnkgdXBncmFkaW5nIHlvdXIgYnJvd3NlciBvciBncmFwaGljcyBkcml2ZXJzIGh0dHA6Ly9nZXQud2ViZ2wub3JnJyk7XHJcbiAgICByZXR1cm4gbnVsbFxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGdsOiBnbCxcclxuICAgIGNhbnZhczogY2FudmFzLFxyXG4gICAgY29udGFpbmVyOiBjb250YWluZXIsXHJcbiAgICBleHRlbnNpb25zOiBleHRlbnNpb25zLFxyXG4gICAgb3B0aW9uYWxFeHRlbnNpb25zOiBvcHRpb25hbEV4dGVuc2lvbnMsXHJcbiAgICBwaXhlbFJhdGlvOiBwaXhlbFJhdGlvLFxyXG4gICAgcHJvZmlsZTogcHJvZmlsZSxcclxuICAgIG9uRG9uZTogb25Eb25lLFxyXG4gICAgb25EZXN0cm95OiBvbkRlc3Ryb3lcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUV4dGVuc2lvbkNhY2hlIChnbCwgY29uZmlnKSB7XHJcbiAgdmFyIGV4dGVuc2lvbnMgPSB7fTtcclxuXHJcbiAgZnVuY3Rpb24gdHJ5TG9hZEV4dGVuc2lvbiAobmFtZV8pIHtcclxuICAgIGNoZWNrJDEudHlwZShuYW1lXywgJ3N0cmluZycsICdleHRlbnNpb24gbmFtZSBtdXN0IGJlIHN0cmluZycpO1xyXG4gICAgdmFyIG5hbWUgPSBuYW1lXy50b0xvd2VyQ2FzZSgpO1xyXG4gICAgdmFyIGV4dDtcclxuICAgIHRyeSB7XHJcbiAgICAgIGV4dCA9IGV4dGVuc2lvbnNbbmFtZV0gPSBnbC5nZXRFeHRlbnNpb24obmFtZSk7XHJcbiAgICB9IGNhdGNoIChlKSB7fVxyXG4gICAgcmV0dXJuICEhZXh0XHJcbiAgfVxyXG5cclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbmZpZy5leHRlbnNpb25zLmxlbmd0aDsgKytpKSB7XHJcbiAgICB2YXIgbmFtZSA9IGNvbmZpZy5leHRlbnNpb25zW2ldO1xyXG4gICAgaWYgKCF0cnlMb2FkRXh0ZW5zaW9uKG5hbWUpKSB7XHJcbiAgICAgIGNvbmZpZy5vbkRlc3Ryb3koKTtcclxuICAgICAgY29uZmlnLm9uRG9uZSgnXCInICsgbmFtZSArICdcIiBleHRlbnNpb24gaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgY3VycmVudCBXZWJHTCBjb250ZXh0LCB0cnkgdXBncmFkaW5nIHlvdXIgc3lzdGVtIG9yIGEgZGlmZmVyZW50IGJyb3dzZXInKTtcclxuICAgICAgcmV0dXJuIG51bGxcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNvbmZpZy5vcHRpb25hbEV4dGVuc2lvbnMuZm9yRWFjaCh0cnlMb2FkRXh0ZW5zaW9uKTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGV4dGVuc2lvbnM6IGV4dGVuc2lvbnMsXHJcbiAgICByZXN0b3JlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIE9iamVjdC5rZXlzKGV4dGVuc2lvbnMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICBpZiAoIXRyeUxvYWRFeHRlbnNpb24obmFtZSkpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignKHJlZ2wpOiBlcnJvciByZXN0b3JpbmcgZXh0ZW5zaW9uICcgKyBuYW1lKVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBsb29wIChuLCBmKSB7XHJcbiAgdmFyIHJlc3VsdCA9IEFycmF5KG4pO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcbiAgICByZXN1bHRbaV0gPSBmKGkpO1xyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0XHJcbn1cclxuXHJcbnZhciBHTF9CWVRFJDEgPSA1MTIwO1xyXG52YXIgR0xfVU5TSUdORURfQllURSQyID0gNTEyMTtcclxudmFyIEdMX1NIT1JUJDEgPSA1MTIyO1xyXG52YXIgR0xfVU5TSUdORURfU0hPUlQkMSA9IDUxMjM7XHJcbnZhciBHTF9JTlQkMSA9IDUxMjQ7XHJcbnZhciBHTF9VTlNJR05FRF9JTlQkMSA9IDUxMjU7XHJcbnZhciBHTF9GTE9BVCQyID0gNTEyNjtcclxuXHJcbmZ1bmN0aW9uIG5leHRQb3cxNiAodikge1xyXG4gIGZvciAodmFyIGkgPSAxNjsgaSA8PSAoMSA8PCAyOCk7IGkgKj0gMTYpIHtcclxuICAgIGlmICh2IDw9IGkpIHtcclxuICAgICAgcmV0dXJuIGlcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIDBcclxufVxyXG5cclxuZnVuY3Rpb24gbG9nMiAodikge1xyXG4gIHZhciByLCBzaGlmdDtcclxuICByID0gKHYgPiAweEZGRkYpIDw8IDQ7XHJcbiAgdiA+Pj49IHI7XHJcbiAgc2hpZnQgPSAodiA+IDB4RkYpIDw8IDM7XHJcbiAgdiA+Pj49IHNoaWZ0OyByIHw9IHNoaWZ0O1xyXG4gIHNoaWZ0ID0gKHYgPiAweEYpIDw8IDI7XHJcbiAgdiA+Pj49IHNoaWZ0OyByIHw9IHNoaWZ0O1xyXG4gIHNoaWZ0ID0gKHYgPiAweDMpIDw8IDE7XHJcbiAgdiA+Pj49IHNoaWZ0OyByIHw9IHNoaWZ0O1xyXG4gIHJldHVybiByIHwgKHYgPj4gMSlcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlUG9vbCAoKSB7XHJcbiAgdmFyIGJ1ZmZlclBvb2wgPSBsb29wKDgsIGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBbXVxyXG4gIH0pO1xyXG5cclxuICBmdW5jdGlvbiBhbGxvYyAobikge1xyXG4gICAgdmFyIHN6ID0gbmV4dFBvdzE2KG4pO1xyXG4gICAgdmFyIGJpbiA9IGJ1ZmZlclBvb2xbbG9nMihzeikgPj4gMl07XHJcbiAgICBpZiAoYmluLmxlbmd0aCA+IDApIHtcclxuICAgICAgcmV0dXJuIGJpbi5wb3AoKVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBBcnJheUJ1ZmZlcihzeilcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGZyZWUgKGJ1Zikge1xyXG4gICAgYnVmZmVyUG9vbFtsb2cyKGJ1Zi5ieXRlTGVuZ3RoKSA+PiAyXS5wdXNoKGJ1Zik7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBhbGxvY1R5cGUgKHR5cGUsIG4pIHtcclxuICAgIHZhciByZXN1bHQgPSBudWxsO1xyXG4gICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgIGNhc2UgR0xfQllURSQxOlxyXG4gICAgICAgIHJlc3VsdCA9IG5ldyBJbnQ4QXJyYXkoYWxsb2MobiksIDAsIG4pO1xyXG4gICAgICAgIGJyZWFrXHJcbiAgICAgIGNhc2UgR0xfVU5TSUdORURfQllURSQyOlxyXG4gICAgICAgIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGFsbG9jKG4pLCAwLCBuKTtcclxuICAgICAgICBicmVha1xyXG4gICAgICBjYXNlIEdMX1NIT1JUJDE6XHJcbiAgICAgICAgcmVzdWx0ID0gbmV3IEludDE2QXJyYXkoYWxsb2MoMiAqIG4pLCAwLCBuKTtcclxuICAgICAgICBicmVha1xyXG4gICAgICBjYXNlIEdMX1VOU0lHTkVEX1NIT1JUJDE6XHJcbiAgICAgICAgcmVzdWx0ID0gbmV3IFVpbnQxNkFycmF5KGFsbG9jKDIgKiBuKSwgMCwgbik7XHJcbiAgICAgICAgYnJlYWtcclxuICAgICAgY2FzZSBHTF9JTlQkMTpcclxuICAgICAgICByZXN1bHQgPSBuZXcgSW50MzJBcnJheShhbGxvYyg0ICogbiksIDAsIG4pO1xyXG4gICAgICAgIGJyZWFrXHJcbiAgICAgIGNhc2UgR0xfVU5TSUdORURfSU5UJDE6XHJcbiAgICAgICAgcmVzdWx0ID0gbmV3IFVpbnQzMkFycmF5KGFsbG9jKDQgKiBuKSwgMCwgbik7XHJcbiAgICAgICAgYnJlYWtcclxuICAgICAgY2FzZSBHTF9GTE9BVCQyOlxyXG4gICAgICAgIHJlc3VsdCA9IG5ldyBGbG9hdDMyQXJyYXkoYWxsb2MoNCAqIG4pLCAwLCBuKTtcclxuICAgICAgICBicmVha1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHJldHVybiBudWxsXHJcbiAgICB9XHJcbiAgICBpZiAocmVzdWx0Lmxlbmd0aCAhPT0gbikge1xyXG4gICAgICByZXR1cm4gcmVzdWx0LnN1YmFycmF5KDAsIG4pXHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBmcmVlVHlwZSAoYXJyYXkpIHtcclxuICAgIGZyZWUoYXJyYXkuYnVmZmVyKTtcclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBhbGxvYzogYWxsb2MsXHJcbiAgICBmcmVlOiBmcmVlLFxyXG4gICAgYWxsb2NUeXBlOiBhbGxvY1R5cGUsXHJcbiAgICBmcmVlVHlwZTogZnJlZVR5cGVcclxuICB9XHJcbn1cclxuXHJcbnZhciBwb29sID0gY3JlYXRlUG9vbCgpO1xyXG5cclxuLy8gemVybyBwb29sIGZvciBpbml0aWFsIHplcm8gZGF0YVxyXG5wb29sLnplcm8gPSBjcmVhdGVQb29sKCk7XHJcblxyXG52YXIgR0xfU1VCUElYRUxfQklUUyA9IDB4MEQ1MDtcclxudmFyIEdMX1JFRF9CSVRTID0gMHgwRDUyO1xyXG52YXIgR0xfR1JFRU5fQklUUyA9IDB4MEQ1MztcclxudmFyIEdMX0JMVUVfQklUUyA9IDB4MEQ1NDtcclxudmFyIEdMX0FMUEhBX0JJVFMgPSAweDBENTU7XHJcbnZhciBHTF9ERVBUSF9CSVRTID0gMHgwRDU2O1xyXG52YXIgR0xfU1RFTkNJTF9CSVRTID0gMHgwRDU3O1xyXG5cclxudmFyIEdMX0FMSUFTRURfUE9JTlRfU0laRV9SQU5HRSA9IDB4ODQ2RDtcclxudmFyIEdMX0FMSUFTRURfTElORV9XSURUSF9SQU5HRSA9IDB4ODQ2RTtcclxuXHJcbnZhciBHTF9NQVhfVEVYVFVSRV9TSVpFID0gMHgwRDMzO1xyXG52YXIgR0xfTUFYX1ZJRVdQT1JUX0RJTVMgPSAweDBEM0E7XHJcbnZhciBHTF9NQVhfVkVSVEVYX0FUVFJJQlMgPSAweDg4Njk7XHJcbnZhciBHTF9NQVhfVkVSVEVYX1VOSUZPUk1fVkVDVE9SUyA9IDB4OERGQjtcclxudmFyIEdMX01BWF9WQVJZSU5HX1ZFQ1RPUlMgPSAweDhERkM7XHJcbnZhciBHTF9NQVhfQ09NQklORURfVEVYVFVSRV9JTUFHRV9VTklUUyA9IDB4OEI0RDtcclxudmFyIEdMX01BWF9WRVJURVhfVEVYVFVSRV9JTUFHRV9VTklUUyA9IDB4OEI0QztcclxudmFyIEdMX01BWF9URVhUVVJFX0lNQUdFX1VOSVRTID0gMHg4ODcyO1xyXG52YXIgR0xfTUFYX0ZSQUdNRU5UX1VOSUZPUk1fVkVDVE9SUyA9IDB4OERGRDtcclxudmFyIEdMX01BWF9DVUJFX01BUF9URVhUVVJFX1NJWkUgPSAweDg1MUM7XHJcbnZhciBHTF9NQVhfUkVOREVSQlVGRkVSX1NJWkUgPSAweDg0RTg7XHJcblxyXG52YXIgR0xfVkVORE9SID0gMHgxRjAwO1xyXG52YXIgR0xfUkVOREVSRVIgPSAweDFGMDE7XHJcbnZhciBHTF9WRVJTSU9OID0gMHgxRjAyO1xyXG52YXIgR0xfU0hBRElOR19MQU5HVUFHRV9WRVJTSU9OID0gMHg4QjhDO1xyXG5cclxudmFyIEdMX01BWF9URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCA9IDB4ODRGRjtcclxuXHJcbnZhciBHTF9NQVhfQ09MT1JfQVRUQUNITUVOVFNfV0VCR0wgPSAweDhDREY7XHJcbnZhciBHTF9NQVhfRFJBV19CVUZGRVJTX1dFQkdMID0gMHg4ODI0O1xyXG5cclxudmFyIEdMX1RFWFRVUkVfMkQgPSAweDBERTE7XHJcbnZhciBHTF9URVhUVVJFX0NVQkVfTUFQID0gMHg4NTEzO1xyXG52YXIgR0xfVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YID0gMHg4NTE1O1xyXG52YXIgR0xfVEVYVFVSRTAgPSAweDg0QzA7XHJcbnZhciBHTF9SR0JBID0gMHgxOTA4O1xyXG52YXIgR0xfRkxPQVQkMSA9IDB4MTQwNjtcclxudmFyIEdMX1VOU0lHTkVEX0JZVEUkMSA9IDB4MTQwMTtcclxudmFyIEdMX0ZSQU1FQlVGRkVSID0gMHg4RDQwO1xyXG52YXIgR0xfRlJBTUVCVUZGRVJfQ09NUExFVEUgPSAweDhDRDU7XHJcbnZhciBHTF9DT0xPUl9BVFRBQ0hNRU5UMCA9IDB4OENFMDtcclxudmFyIEdMX0NPTE9SX0JVRkZFUl9CSVQkMSA9IDB4NDAwMDtcclxuXHJcbnZhciB3cmFwTGltaXRzID0gZnVuY3Rpb24gKGdsLCBleHRlbnNpb25zKSB7XHJcbiAgdmFyIG1heEFuaXNvdHJvcGljID0gMTtcclxuICBpZiAoZXh0ZW5zaW9ucy5leHRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMpIHtcclxuICAgIG1heEFuaXNvdHJvcGljID0gZ2wuZ2V0UGFyYW1ldGVyKEdMX01BWF9URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCk7XHJcbiAgfVxyXG5cclxuICB2YXIgbWF4RHJhd2J1ZmZlcnMgPSAxO1xyXG4gIHZhciBtYXhDb2xvckF0dGFjaG1lbnRzID0gMTtcclxuICBpZiAoZXh0ZW5zaW9ucy53ZWJnbF9kcmF3X2J1ZmZlcnMpIHtcclxuICAgIG1heERyYXdidWZmZXJzID0gZ2wuZ2V0UGFyYW1ldGVyKEdMX01BWF9EUkFXX0JVRkZFUlNfV0VCR0wpO1xyXG4gICAgbWF4Q29sb3JBdHRhY2htZW50cyA9IGdsLmdldFBhcmFtZXRlcihHTF9NQVhfQ09MT1JfQVRUQUNITUVOVFNfV0VCR0wpO1xyXG4gIH1cclxuXHJcbiAgLy8gZGV0ZWN0IGlmIHJlYWRpbmcgZmxvYXQgdGV4dHVyZXMgaXMgYXZhaWxhYmxlIChTYWZhcmkgZG9lc24ndCBzdXBwb3J0KVxyXG4gIHZhciByZWFkRmxvYXQgPSAhIWV4dGVuc2lvbnMub2VzX3RleHR1cmVfZmxvYXQ7XHJcbiAgaWYgKHJlYWRGbG9hdCkge1xyXG4gICAgdmFyIHJlYWRGbG9hdFRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XHJcbiAgICBnbC5iaW5kVGV4dHVyZShHTF9URVhUVVJFXzJELCByZWFkRmxvYXRUZXh0dXJlKTtcclxuICAgIGdsLnRleEltYWdlMkQoR0xfVEVYVFVSRV8yRCwgMCwgR0xfUkdCQSwgMSwgMSwgMCwgR0xfUkdCQSwgR0xfRkxPQVQkMSwgbnVsbCk7XHJcblxyXG4gICAgdmFyIGZibyA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XHJcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoR0xfRlJBTUVCVUZGRVIsIGZibyk7XHJcbiAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChHTF9GUkFNRUJVRkZFUiwgR0xfQ09MT1JfQVRUQUNITUVOVDAsIEdMX1RFWFRVUkVfMkQsIHJlYWRGbG9hdFRleHR1cmUsIDApO1xyXG4gICAgZ2wuYmluZFRleHR1cmUoR0xfVEVYVFVSRV8yRCwgbnVsbCk7XHJcblxyXG4gICAgaWYgKGdsLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoR0xfRlJBTUVCVUZGRVIpICE9PSBHTF9GUkFNRUJVRkZFUl9DT01QTEVURSkgcmVhZEZsb2F0ID0gZmFsc2U7XHJcblxyXG4gICAgZWxzZSB7XHJcbiAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIDEsIDEpO1xyXG4gICAgICBnbC5jbGVhckNvbG9yKDEuMCwgMC4wLCAwLjAsIDEuMCk7XHJcbiAgICAgIGdsLmNsZWFyKEdMX0NPTE9SX0JVRkZFUl9CSVQkMSk7XHJcbiAgICAgIHZhciBwaXhlbHMgPSBwb29sLmFsbG9jVHlwZShHTF9GTE9BVCQxLCA0KTtcclxuICAgICAgZ2wucmVhZFBpeGVscygwLCAwLCAxLCAxLCBHTF9SR0JBLCBHTF9GTE9BVCQxLCBwaXhlbHMpO1xyXG5cclxuICAgICAgaWYgKGdsLmdldEVycm9yKCkpIHJlYWRGbG9hdCA9IGZhbHNlO1xyXG4gICAgICBlbHNlIHtcclxuICAgICAgICBnbC5kZWxldGVGcmFtZWJ1ZmZlcihmYm8pO1xyXG4gICAgICAgIGdsLmRlbGV0ZVRleHR1cmUocmVhZEZsb2F0VGV4dHVyZSk7XHJcblxyXG4gICAgICAgIHJlYWRGbG9hdCA9IHBpeGVsc1swXSA9PT0gMS4wO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwb29sLmZyZWVUeXBlKHBpeGVscyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBkZXRlY3Qgbm9uIHBvd2VyIG9mIHR3byBjdWJlIHRleHR1cmVzIHN1cHBvcnQgKElFIGRvZXNuJ3Qgc3VwcG9ydClcclxuICB2YXIgbnBvdFRleHR1cmVDdWJlID0gdHJ1ZTtcclxuICB2YXIgY3ViZVRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XHJcbiAgdmFyIGRhdGEgPSBwb29sLmFsbG9jVHlwZShHTF9VTlNJR05FRF9CWVRFJDEsIDM2KTtcclxuICBnbC5hY3RpdmVUZXh0dXJlKEdMX1RFWFRVUkUwKTtcclxuICBnbC5iaW5kVGV4dHVyZShHTF9URVhUVVJFX0NVQkVfTUFQLCBjdWJlVGV4dHVyZSk7XHJcbiAgZ2wudGV4SW1hZ2UyRChHTF9URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1gsIDAsIEdMX1JHQkEsIDMsIDMsIDAsIEdMX1JHQkEsIEdMX1VOU0lHTkVEX0JZVEUkMSwgZGF0YSk7XHJcbiAgcG9vbC5mcmVlVHlwZShkYXRhKTtcclxuICBnbC5iaW5kVGV4dHVyZShHTF9URVhUVVJFX0NVQkVfTUFQLCBudWxsKTtcclxuICBnbC5kZWxldGVUZXh0dXJlKGN1YmVUZXh0dXJlKTtcclxuICBucG90VGV4dHVyZUN1YmUgPSAhZ2wuZ2V0RXJyb3IoKTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIC8vIGRyYXdpbmcgYnVmZmVyIGJpdCBkZXB0aFxyXG4gICAgY29sb3JCaXRzOiBbXHJcbiAgICAgIGdsLmdldFBhcmFtZXRlcihHTF9SRURfQklUUyksXHJcbiAgICAgIGdsLmdldFBhcmFtZXRlcihHTF9HUkVFTl9CSVRTKSxcclxuICAgICAgZ2wuZ2V0UGFyYW1ldGVyKEdMX0JMVUVfQklUUyksXHJcbiAgICAgIGdsLmdldFBhcmFtZXRlcihHTF9BTFBIQV9CSVRTKVxyXG4gICAgXSxcclxuICAgIGRlcHRoQml0czogZ2wuZ2V0UGFyYW1ldGVyKEdMX0RFUFRIX0JJVFMpLFxyXG4gICAgc3RlbmNpbEJpdHM6IGdsLmdldFBhcmFtZXRlcihHTF9TVEVOQ0lMX0JJVFMpLFxyXG4gICAgc3VicGl4ZWxCaXRzOiBnbC5nZXRQYXJhbWV0ZXIoR0xfU1VCUElYRUxfQklUUyksXHJcblxyXG4gICAgLy8gc3VwcG9ydGVkIGV4dGVuc2lvbnNcclxuICAgIGV4dGVuc2lvbnM6IE9iamVjdC5rZXlzKGV4dGVuc2lvbnMpLmZpbHRlcihmdW5jdGlvbiAoZXh0KSB7XHJcbiAgICAgIHJldHVybiAhIWV4dGVuc2lvbnNbZXh0XVxyXG4gICAgfSksXHJcblxyXG4gICAgLy8gbWF4IGFuaXNvIHNhbXBsZXNcclxuICAgIG1heEFuaXNvdHJvcGljOiBtYXhBbmlzb3Ryb3BpYyxcclxuXHJcbiAgICAvLyBtYXggZHJhdyBidWZmZXJzXHJcbiAgICBtYXhEcmF3YnVmZmVyczogbWF4RHJhd2J1ZmZlcnMsXHJcbiAgICBtYXhDb2xvckF0dGFjaG1lbnRzOiBtYXhDb2xvckF0dGFjaG1lbnRzLFxyXG5cclxuICAgIC8vIHBvaW50IGFuZCBsaW5lIHNpemUgcmFuZ2VzXHJcbiAgICBwb2ludFNpemVEaW1zOiBnbC5nZXRQYXJhbWV0ZXIoR0xfQUxJQVNFRF9QT0lOVF9TSVpFX1JBTkdFKSxcclxuICAgIGxpbmVXaWR0aERpbXM6IGdsLmdldFBhcmFtZXRlcihHTF9BTElBU0VEX0xJTkVfV0lEVEhfUkFOR0UpLFxyXG4gICAgbWF4Vmlld3BvcnREaW1zOiBnbC5nZXRQYXJhbWV0ZXIoR0xfTUFYX1ZJRVdQT1JUX0RJTVMpLFxyXG4gICAgbWF4Q29tYmluZWRUZXh0dXJlVW5pdHM6IGdsLmdldFBhcmFtZXRlcihHTF9NQVhfQ09NQklORURfVEVYVFVSRV9JTUFHRV9VTklUUyksXHJcbiAgICBtYXhDdWJlTWFwU2l6ZTogZ2wuZ2V0UGFyYW1ldGVyKEdMX01BWF9DVUJFX01BUF9URVhUVVJFX1NJWkUpLFxyXG4gICAgbWF4UmVuZGVyYnVmZmVyU2l6ZTogZ2wuZ2V0UGFyYW1ldGVyKEdMX01BWF9SRU5ERVJCVUZGRVJfU0laRSksXHJcbiAgICBtYXhUZXh0dXJlVW5pdHM6IGdsLmdldFBhcmFtZXRlcihHTF9NQVhfVEVYVFVSRV9JTUFHRV9VTklUUyksXHJcbiAgICBtYXhUZXh0dXJlU2l6ZTogZ2wuZ2V0UGFyYW1ldGVyKEdMX01BWF9URVhUVVJFX1NJWkUpLFxyXG4gICAgbWF4QXR0cmlidXRlczogZ2wuZ2V0UGFyYW1ldGVyKEdMX01BWF9WRVJURVhfQVRUUklCUyksXHJcbiAgICBtYXhWZXJ0ZXhVbmlmb3JtczogZ2wuZ2V0UGFyYW1ldGVyKEdMX01BWF9WRVJURVhfVU5JRk9STV9WRUNUT1JTKSxcclxuICAgIG1heFZlcnRleFRleHR1cmVVbml0czogZ2wuZ2V0UGFyYW1ldGVyKEdMX01BWF9WRVJURVhfVEVYVFVSRV9JTUFHRV9VTklUUyksXHJcbiAgICBtYXhWYXJ5aW5nVmVjdG9yczogZ2wuZ2V0UGFyYW1ldGVyKEdMX01BWF9WQVJZSU5HX1ZFQ1RPUlMpLFxyXG4gICAgbWF4RnJhZ21lbnRVbmlmb3JtczogZ2wuZ2V0UGFyYW1ldGVyKEdMX01BWF9GUkFHTUVOVF9VTklGT1JNX1ZFQ1RPUlMpLFxyXG5cclxuICAgIC8vIHZlbmRvciBpbmZvXHJcbiAgICBnbHNsOiBnbC5nZXRQYXJhbWV0ZXIoR0xfU0hBRElOR19MQU5HVUFHRV9WRVJTSU9OKSxcclxuICAgIHJlbmRlcmVyOiBnbC5nZXRQYXJhbWV0ZXIoR0xfUkVOREVSRVIpLFxyXG4gICAgdmVuZG9yOiBnbC5nZXRQYXJhbWV0ZXIoR0xfVkVORE9SKSxcclxuICAgIHZlcnNpb246IGdsLmdldFBhcmFtZXRlcihHTF9WRVJTSU9OKSxcclxuXHJcbiAgICAvLyBxdWlya3NcclxuICAgIHJlYWRGbG9hdDogcmVhZEZsb2F0LFxyXG4gICAgbnBvdFRleHR1cmVDdWJlOiBucG90VGV4dHVyZUN1YmVcclxuICB9XHJcbn07XHJcblxyXG5mdW5jdGlvbiBpc05EQXJyYXlMaWtlIChvYmopIHtcclxuICByZXR1cm4gKFxyXG4gICAgISFvYmogJiZcclxuICAgIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmXHJcbiAgICBBcnJheS5pc0FycmF5KG9iai5zaGFwZSkgJiZcclxuICAgIEFycmF5LmlzQXJyYXkob2JqLnN0cmlkZSkgJiZcclxuICAgIHR5cGVvZiBvYmoub2Zmc2V0ID09PSAnbnVtYmVyJyAmJlxyXG4gICAgb2JqLnNoYXBlLmxlbmd0aCA9PT0gb2JqLnN0cmlkZS5sZW5ndGggJiZcclxuICAgIChBcnJheS5pc0FycmF5KG9iai5kYXRhKSB8fFxyXG4gICAgICBpc1R5cGVkQXJyYXkob2JqLmRhdGEpKSlcclxufVxyXG5cclxudmFyIHZhbHVlcyA9IGZ1bmN0aW9uIChvYmopIHtcclxuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gb2JqW2tleV0gfSlcclxufTtcclxuXHJcbnZhciBmbGF0dGVuVXRpbHMgPSB7XHJcbiAgc2hhcGU6IGFycmF5U2hhcGUkMSxcclxuICBmbGF0dGVuOiBmbGF0dGVuQXJyYXlcclxufTtcclxuXHJcbmZ1bmN0aW9uIGZsYXR0ZW4xRCAoYXJyYXksIG54LCBvdXQpIHtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IG54OyArK2kpIHtcclxuICAgIG91dFtpXSA9IGFycmF5W2ldO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZmxhdHRlbjJEIChhcnJheSwgbngsIG55LCBvdXQpIHtcclxuICB2YXIgcHRyID0gMDtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IG54OyArK2kpIHtcclxuICAgIHZhciByb3cgPSBhcnJheVtpXTtcclxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnk7ICsraikge1xyXG4gICAgICBvdXRbcHRyKytdID0gcm93W2pdO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZmxhdHRlbjNEIChhcnJheSwgbngsIG55LCBueiwgb3V0LCBwdHJfKSB7XHJcbiAgdmFyIHB0ciA9IHB0cl87XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBueDsgKytpKSB7XHJcbiAgICB2YXIgcm93ID0gYXJyYXlbaV07XHJcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG55OyArK2opIHtcclxuICAgICAgdmFyIGNvbCA9IHJvd1tqXTtcclxuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBuejsgKytrKSB7XHJcbiAgICAgICAgb3V0W3B0cisrXSA9IGNvbFtrXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZmxhdHRlblJlYyAoYXJyYXksIHNoYXBlLCBsZXZlbCwgb3V0LCBwdHIpIHtcclxuICB2YXIgc3RyaWRlID0gMTtcclxuICBmb3IgKHZhciBpID0gbGV2ZWwgKyAxOyBpIDwgc2hhcGUubGVuZ3RoOyArK2kpIHtcclxuICAgIHN0cmlkZSAqPSBzaGFwZVtpXTtcclxuICB9XHJcbiAgdmFyIG4gPSBzaGFwZVtsZXZlbF07XHJcbiAgaWYgKHNoYXBlLmxlbmd0aCAtIGxldmVsID09PSA0KSB7XHJcbiAgICB2YXIgbnggPSBzaGFwZVtsZXZlbCArIDFdO1xyXG4gICAgdmFyIG55ID0gc2hhcGVbbGV2ZWwgKyAyXTtcclxuICAgIHZhciBueiA9IHNoYXBlW2xldmVsICsgM107XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgIGZsYXR0ZW4zRChhcnJheVtpXSwgbngsIG55LCBueiwgb3V0LCBwdHIpO1xyXG4gICAgICBwdHIgKz0gc3RyaWRlO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgIGZsYXR0ZW5SZWMoYXJyYXlbaV0sIHNoYXBlLCBsZXZlbCArIDEsIG91dCwgcHRyKTtcclxuICAgICAgcHRyICs9IHN0cmlkZTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZsYXR0ZW5BcnJheSAoYXJyYXksIHNoYXBlLCB0eXBlLCBvdXRfKSB7XHJcbiAgdmFyIHN6ID0gMTtcclxuICBpZiAoc2hhcGUubGVuZ3RoKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNoYXBlLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgIHN6ICo9IHNoYXBlW2ldO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICBzeiA9IDA7XHJcbiAgfVxyXG4gIHZhciBvdXQgPSBvdXRfIHx8IHBvb2wuYWxsb2NUeXBlKHR5cGUsIHN6KTtcclxuICBzd2l0Y2ggKHNoYXBlLmxlbmd0aCkge1xyXG4gICAgY2FzZSAwOlxyXG4gICAgICBicmVha1xyXG4gICAgY2FzZSAxOlxyXG4gICAgICBmbGF0dGVuMUQoYXJyYXksIHNoYXBlWzBdLCBvdXQpO1xyXG4gICAgICBicmVha1xyXG4gICAgY2FzZSAyOlxyXG4gICAgICBmbGF0dGVuMkQoYXJyYXksIHNoYXBlWzBdLCBzaGFwZVsxXSwgb3V0KTtcclxuICAgICAgYnJlYWtcclxuICAgIGNhc2UgMzpcclxuICAgICAgZmxhdHRlbjNEKGFycmF5LCBzaGFwZVswXSwgc2hhcGVbMV0sIHNoYXBlWzJdLCBvdXQsIDApO1xyXG4gICAgICBicmVha1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgZmxhdHRlblJlYyhhcnJheSwgc2hhcGUsIDAsIG91dCwgMCk7XHJcbiAgfVxyXG4gIHJldHVybiBvdXRcclxufVxyXG5cclxuZnVuY3Rpb24gYXJyYXlTaGFwZSQxIChhcnJheV8pIHtcclxuICB2YXIgc2hhcGUgPSBbXTtcclxuICBmb3IgKHZhciBhcnJheSA9IGFycmF5XzsgYXJyYXkubGVuZ3RoOyBhcnJheSA9IGFycmF5WzBdKSB7XHJcbiAgICBzaGFwZS5wdXNoKGFycmF5Lmxlbmd0aCk7XHJcbiAgfVxyXG4gIHJldHVybiBzaGFwZVxyXG59XHJcblxyXG52YXIgYXJyYXlUeXBlcyA9IHtcclxuXHRcIltvYmplY3QgSW50OEFycmF5XVwiOiA1MTIwLFxyXG5cdFwiW29iamVjdCBJbnQxNkFycmF5XVwiOiA1MTIyLFxyXG5cdFwiW29iamVjdCBJbnQzMkFycmF5XVwiOiA1MTI0LFxyXG5cdFwiW29iamVjdCBVaW50OEFycmF5XVwiOiA1MTIxLFxyXG5cdFwiW29iamVjdCBVaW50OENsYW1wZWRBcnJheV1cIjogNTEyMSxcclxuXHRcIltvYmplY3QgVWludDE2QXJyYXldXCI6IDUxMjMsXHJcblx0XCJbb2JqZWN0IFVpbnQzMkFycmF5XVwiOiA1MTI1LFxyXG5cdFwiW29iamVjdCBGbG9hdDMyQXJyYXldXCI6IDUxMjYsXHJcblx0XCJbb2JqZWN0IEZsb2F0NjRBcnJheV1cIjogNTEyMSxcclxuXHRcIltvYmplY3QgQXJyYXlCdWZmZXJdXCI6IDUxMjFcclxufTtcclxuXHJcbnZhciBpbnQ4ID0gNTEyMDtcclxudmFyIGludDE2ID0gNTEyMjtcclxudmFyIGludDMyID0gNTEyNDtcclxudmFyIHVpbnQ4ID0gNTEyMTtcclxudmFyIHVpbnQxNiA9IDUxMjM7XHJcbnZhciB1aW50MzIgPSA1MTI1O1xyXG52YXIgZmxvYXQgPSA1MTI2O1xyXG52YXIgZmxvYXQzMiA9IDUxMjY7XHJcbnZhciBnbFR5cGVzID0ge1xyXG5cdGludDg6IGludDgsXHJcblx0aW50MTY6IGludDE2LFxyXG5cdGludDMyOiBpbnQzMixcclxuXHR1aW50ODogdWludDgsXHJcblx0dWludDE2OiB1aW50MTYsXHJcblx0dWludDMyOiB1aW50MzIsXHJcblx0ZmxvYXQ6IGZsb2F0LFxyXG5cdGZsb2F0MzI6IGZsb2F0MzJcclxufTtcclxuXHJcbnZhciBkeW5hbWljJDEgPSAzNTA0ODtcclxudmFyIHN0cmVhbSA9IDM1MDQwO1xyXG52YXIgdXNhZ2VUeXBlcyA9IHtcclxuXHRkeW5hbWljOiBkeW5hbWljJDEsXHJcblx0c3RyZWFtOiBzdHJlYW0sXHJcblx0XCJzdGF0aWNcIjogMzUwNDRcclxufTtcclxuXHJcbnZhciBhcnJheUZsYXR0ZW4gPSBmbGF0dGVuVXRpbHMuZmxhdHRlbjtcclxudmFyIGFycmF5U2hhcGUgPSBmbGF0dGVuVXRpbHMuc2hhcGU7XHJcblxyXG52YXIgR0xfU1RBVElDX0RSQVcgPSAweDg4RTQ7XHJcbnZhciBHTF9TVFJFQU1fRFJBVyA9IDB4ODhFMDtcclxuXHJcbnZhciBHTF9VTlNJR05FRF9CWVRFJDMgPSA1MTIxO1xyXG52YXIgR0xfRkxPQVQkMyA9IDUxMjY7XHJcblxyXG52YXIgRFRZUEVTX1NJWkVTID0gW107XHJcbkRUWVBFU19TSVpFU1s1MTIwXSA9IDE7IC8vIGludDhcclxuRFRZUEVTX1NJWkVTWzUxMjJdID0gMjsgLy8gaW50MTZcclxuRFRZUEVTX1NJWkVTWzUxMjRdID0gNDsgLy8gaW50MzJcclxuRFRZUEVTX1NJWkVTWzUxMjFdID0gMTsgLy8gdWludDhcclxuRFRZUEVTX1NJWkVTWzUxMjNdID0gMjsgLy8gdWludDE2XHJcbkRUWVBFU19TSVpFU1s1MTI1XSA9IDQ7IC8vIHVpbnQzMlxyXG5EVFlQRVNfU0laRVNbNTEyNl0gPSA0OyAvLyBmbG9hdDMyXHJcblxyXG5mdW5jdGlvbiB0eXBlZEFycmF5Q29kZSAoZGF0YSkge1xyXG4gIHJldHVybiBhcnJheVR5cGVzW09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkYXRhKV0gfCAwXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvcHlBcnJheSAob3V0LCBpbnApIHtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGlucC5sZW5ndGg7ICsraSkge1xyXG4gICAgb3V0W2ldID0gaW5wW2ldO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gdHJhbnNwb3NlIChcclxuICByZXN1bHQsIGRhdGEsIHNoYXBlWCwgc2hhcGVZLCBzdHJpZGVYLCBzdHJpZGVZLCBvZmZzZXQpIHtcclxuICB2YXIgcHRyID0gMDtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNoYXBlWDsgKytpKSB7XHJcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNoYXBlWTsgKytqKSB7XHJcbiAgICAgIHJlc3VsdFtwdHIrK10gPSBkYXRhW3N0cmlkZVggKiBpICsgc3RyaWRlWSAqIGogKyBvZmZzZXRdO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gd3JhcEJ1ZmZlclN0YXRlIChnbCwgc3RhdHMsIGNvbmZpZywgYXR0cmlidXRlU3RhdGUpIHtcclxuICB2YXIgYnVmZmVyQ291bnQgPSAwO1xyXG4gIHZhciBidWZmZXJTZXQgPSB7fTtcclxuXHJcbiAgZnVuY3Rpb24gUkVHTEJ1ZmZlciAodHlwZSkge1xyXG4gICAgdGhpcy5pZCA9IGJ1ZmZlckNvdW50Kys7XHJcbiAgICB0aGlzLmJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG4gICAgdGhpcy50eXBlID0gdHlwZTtcclxuICAgIHRoaXMudXNhZ2UgPSBHTF9TVEFUSUNfRFJBVztcclxuICAgIHRoaXMuYnl0ZUxlbmd0aCA9IDA7XHJcbiAgICB0aGlzLmRpbWVuc2lvbiA9IDE7XHJcbiAgICB0aGlzLmR0eXBlID0gR0xfVU5TSUdORURfQllURSQzO1xyXG5cclxuICAgIHRoaXMucGVyc2lzdGVudERhdGEgPSBudWxsO1xyXG5cclxuICAgIGlmIChjb25maWcucHJvZmlsZSkge1xyXG4gICAgICB0aGlzLnN0YXRzID0ge3NpemU6IDB9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgUkVHTEJ1ZmZlci5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGdsLmJpbmRCdWZmZXIodGhpcy50eXBlLCB0aGlzLmJ1ZmZlcik7XHJcbiAgfTtcclxuXHJcbiAgUkVHTEJ1ZmZlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGRlc3Ryb3kodGhpcyk7XHJcbiAgfTtcclxuXHJcbiAgdmFyIHN0cmVhbVBvb2wgPSBbXTtcclxuXHJcbiAgZnVuY3Rpb24gY3JlYXRlU3RyZWFtICh0eXBlLCBkYXRhKSB7XHJcbiAgICB2YXIgYnVmZmVyID0gc3RyZWFtUG9vbC5wb3AoKTtcclxuICAgIGlmICghYnVmZmVyKSB7XHJcbiAgICAgIGJ1ZmZlciA9IG5ldyBSRUdMQnVmZmVyKHR5cGUpO1xyXG4gICAgfVxyXG4gICAgYnVmZmVyLmJpbmQoKTtcclxuICAgIGluaXRCdWZmZXJGcm9tRGF0YShidWZmZXIsIGRhdGEsIEdMX1NUUkVBTV9EUkFXLCAwLCAxLCBmYWxzZSk7XHJcbiAgICByZXR1cm4gYnVmZmVyXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBkZXN0cm95U3RyZWFtIChzdHJlYW0kJDEpIHtcclxuICAgIHN0cmVhbVBvb2wucHVzaChzdHJlYW0kJDEpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaW5pdEJ1ZmZlckZyb21UeXBlZEFycmF5IChidWZmZXIsIGRhdGEsIHVzYWdlKSB7XHJcbiAgICBidWZmZXIuYnl0ZUxlbmd0aCA9IGRhdGEuYnl0ZUxlbmd0aDtcclxuICAgIGdsLmJ1ZmZlckRhdGEoYnVmZmVyLnR5cGUsIGRhdGEsIHVzYWdlKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGluaXRCdWZmZXJGcm9tRGF0YSAoYnVmZmVyLCBkYXRhLCB1c2FnZSwgZHR5cGUsIGRpbWVuc2lvbiwgcGVyc2lzdCkge1xyXG4gICAgdmFyIHNoYXBlO1xyXG4gICAgYnVmZmVyLnVzYWdlID0gdXNhZ2U7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xyXG4gICAgICBidWZmZXIuZHR5cGUgPSBkdHlwZSB8fCBHTF9GTE9BVCQzO1xyXG4gICAgICBpZiAoZGF0YS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgdmFyIGZsYXREYXRhO1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGFbMF0pKSB7XHJcbiAgICAgICAgICBzaGFwZSA9IGFycmF5U2hhcGUoZGF0YSk7XHJcbiAgICAgICAgICB2YXIgZGltID0gMTtcclxuICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgc2hhcGUubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgZGltICo9IHNoYXBlW2ldO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnVmZmVyLmRpbWVuc2lvbiA9IGRpbTtcclxuICAgICAgICAgIGZsYXREYXRhID0gYXJyYXlGbGF0dGVuKGRhdGEsIHNoYXBlLCBidWZmZXIuZHR5cGUpO1xyXG4gICAgICAgICAgaW5pdEJ1ZmZlckZyb21UeXBlZEFycmF5KGJ1ZmZlciwgZmxhdERhdGEsIHVzYWdlKTtcclxuICAgICAgICAgIGlmIChwZXJzaXN0KSB7XHJcbiAgICAgICAgICAgIGJ1ZmZlci5wZXJzaXN0ZW50RGF0YSA9IGZsYXREYXRhO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcG9vbC5mcmVlVHlwZShmbGF0RGF0YSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YVswXSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgIGJ1ZmZlci5kaW1lbnNpb24gPSBkaW1lbnNpb247XHJcbiAgICAgICAgICB2YXIgdHlwZWREYXRhID0gcG9vbC5hbGxvY1R5cGUoYnVmZmVyLmR0eXBlLCBkYXRhLmxlbmd0aCk7XHJcbiAgICAgICAgICBjb3B5QXJyYXkodHlwZWREYXRhLCBkYXRhKTtcclxuICAgICAgICAgIGluaXRCdWZmZXJGcm9tVHlwZWRBcnJheShidWZmZXIsIHR5cGVkRGF0YSwgdXNhZ2UpO1xyXG4gICAgICAgICAgaWYgKHBlcnNpc3QpIHtcclxuICAgICAgICAgICAgYnVmZmVyLnBlcnNpc3RlbnREYXRhID0gdHlwZWREYXRhO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcG9vbC5mcmVlVHlwZSh0eXBlZERhdGEpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNUeXBlZEFycmF5KGRhdGFbMF0pKSB7XHJcbiAgICAgICAgICBidWZmZXIuZGltZW5zaW9uID0gZGF0YVswXS5sZW5ndGg7XHJcbiAgICAgICAgICBidWZmZXIuZHR5cGUgPSBkdHlwZSB8fCB0eXBlZEFycmF5Q29kZShkYXRhWzBdKSB8fCBHTF9GTE9BVCQzO1xyXG4gICAgICAgICAgZmxhdERhdGEgPSBhcnJheUZsYXR0ZW4oXHJcbiAgICAgICAgICAgIGRhdGEsXHJcbiAgICAgICAgICAgIFtkYXRhLmxlbmd0aCwgZGF0YVswXS5sZW5ndGhdLFxyXG4gICAgICAgICAgICBidWZmZXIuZHR5cGUpO1xyXG4gICAgICAgICAgaW5pdEJ1ZmZlckZyb21UeXBlZEFycmF5KGJ1ZmZlciwgZmxhdERhdGEsIHVzYWdlKTtcclxuICAgICAgICAgIGlmIChwZXJzaXN0KSB7XHJcbiAgICAgICAgICAgIGJ1ZmZlci5wZXJzaXN0ZW50RGF0YSA9IGZsYXREYXRhO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcG9vbC5mcmVlVHlwZShmbGF0RGF0YSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNoZWNrJDEucmFpc2UoJ2ludmFsaWQgYnVmZmVyIGRhdGEnKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoaXNUeXBlZEFycmF5KGRhdGEpKSB7XHJcbiAgICAgIGJ1ZmZlci5kdHlwZSA9IGR0eXBlIHx8IHR5cGVkQXJyYXlDb2RlKGRhdGEpO1xyXG4gICAgICBidWZmZXIuZGltZW5zaW9uID0gZGltZW5zaW9uO1xyXG4gICAgICBpbml0QnVmZmVyRnJvbVR5cGVkQXJyYXkoYnVmZmVyLCBkYXRhLCB1c2FnZSk7XHJcbiAgICAgIGlmIChwZXJzaXN0KSB7XHJcbiAgICAgICAgYnVmZmVyLnBlcnNpc3RlbnREYXRhID0gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQ4QXJyYXkoZGF0YS5idWZmZXIpKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChpc05EQXJyYXlMaWtlKGRhdGEpKSB7XHJcbiAgICAgIHNoYXBlID0gZGF0YS5zaGFwZTtcclxuICAgICAgdmFyIHN0cmlkZSA9IGRhdGEuc3RyaWRlO1xyXG4gICAgICB2YXIgb2Zmc2V0ID0gZGF0YS5vZmZzZXQ7XHJcblxyXG4gICAgICB2YXIgc2hhcGVYID0gMDtcclxuICAgICAgdmFyIHNoYXBlWSA9IDA7XHJcbiAgICAgIHZhciBzdHJpZGVYID0gMDtcclxuICAgICAgdmFyIHN0cmlkZVkgPSAwO1xyXG4gICAgICBpZiAoc2hhcGUubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgc2hhcGVYID0gc2hhcGVbMF07XHJcbiAgICAgICAgc2hhcGVZID0gMTtcclxuICAgICAgICBzdHJpZGVYID0gc3RyaWRlWzBdO1xyXG4gICAgICAgIHN0cmlkZVkgPSAwO1xyXG4gICAgICB9IGVsc2UgaWYgKHNoYXBlLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgIHNoYXBlWCA9IHNoYXBlWzBdO1xyXG4gICAgICAgIHNoYXBlWSA9IHNoYXBlWzFdO1xyXG4gICAgICAgIHN0cmlkZVggPSBzdHJpZGVbMF07XHJcbiAgICAgICAgc3RyaWRlWSA9IHN0cmlkZVsxXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjaGVjayQxLnJhaXNlKCdpbnZhbGlkIHNoYXBlJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGJ1ZmZlci5kdHlwZSA9IGR0eXBlIHx8IHR5cGVkQXJyYXlDb2RlKGRhdGEuZGF0YSkgfHwgR0xfRkxPQVQkMztcclxuICAgICAgYnVmZmVyLmRpbWVuc2lvbiA9IHNoYXBlWTtcclxuXHJcbiAgICAgIHZhciB0cmFuc3Bvc2VEYXRhID0gcG9vbC5hbGxvY1R5cGUoYnVmZmVyLmR0eXBlLCBzaGFwZVggKiBzaGFwZVkpO1xyXG4gICAgICB0cmFuc3Bvc2UodHJhbnNwb3NlRGF0YSxcclxuICAgICAgICBkYXRhLmRhdGEsXHJcbiAgICAgICAgc2hhcGVYLCBzaGFwZVksXHJcbiAgICAgICAgc3RyaWRlWCwgc3RyaWRlWSxcclxuICAgICAgICBvZmZzZXQpO1xyXG4gICAgICBpbml0QnVmZmVyRnJvbVR5cGVkQXJyYXkoYnVmZmVyLCB0cmFuc3Bvc2VEYXRhLCB1c2FnZSk7XHJcbiAgICAgIGlmIChwZXJzaXN0KSB7XHJcbiAgICAgICAgYnVmZmVyLnBlcnNpc3RlbnREYXRhID0gdHJhbnNwb3NlRGF0YTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBwb29sLmZyZWVUeXBlKHRyYW5zcG9zZURhdGEpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjaGVjayQxLnJhaXNlKCdpbnZhbGlkIGJ1ZmZlciBkYXRhJyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBkZXN0cm95IChidWZmZXIpIHtcclxuICAgIHN0YXRzLmJ1ZmZlckNvdW50LS07XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRyaWJ1dGVTdGF0ZS5zdGF0ZS5sZW5ndGg7ICsraSkge1xyXG4gICAgICB2YXIgcmVjb3JkID0gYXR0cmlidXRlU3RhdGUuc3RhdGVbaV07XHJcbiAgICAgIGlmIChyZWNvcmQuYnVmZmVyID09PSBidWZmZXIpIHtcclxuICAgICAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoaSk7XHJcbiAgICAgICAgcmVjb3JkLmJ1ZmZlciA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgaGFuZGxlID0gYnVmZmVyLmJ1ZmZlcjtcclxuICAgIGNoZWNrJDEoaGFuZGxlLCAnYnVmZmVyIG11c3Qgbm90IGJlIGRlbGV0ZWQgYWxyZWFkeScpO1xyXG4gICAgZ2wuZGVsZXRlQnVmZmVyKGhhbmRsZSk7XHJcbiAgICBidWZmZXIuYnVmZmVyID0gbnVsbDtcclxuICAgIGRlbGV0ZSBidWZmZXJTZXRbYnVmZmVyLmlkXTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAob3B0aW9ucywgdHlwZSwgZGVmZXJJbml0LCBwZXJzaXN0ZW50KSB7XHJcbiAgICBzdGF0cy5idWZmZXJDb3VudCsrO1xyXG5cclxuICAgIHZhciBidWZmZXIgPSBuZXcgUkVHTEJ1ZmZlcih0eXBlKTtcclxuICAgIGJ1ZmZlclNldFtidWZmZXIuaWRdID0gYnVmZmVyO1xyXG5cclxuICAgIGZ1bmN0aW9uIHJlZ2xCdWZmZXIgKG9wdGlvbnMpIHtcclxuICAgICAgdmFyIHVzYWdlID0gR0xfU1RBVElDX0RSQVc7XHJcbiAgICAgIHZhciBkYXRhID0gbnVsbDtcclxuICAgICAgdmFyIGJ5dGVMZW5ndGggPSAwO1xyXG4gICAgICB2YXIgZHR5cGUgPSAwO1xyXG4gICAgICB2YXIgZGltZW5zaW9uID0gMTtcclxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykgfHxcclxuICAgICAgICAgIGlzVHlwZWRBcnJheShvcHRpb25zKSB8fFxyXG4gICAgICAgICAgaXNOREFycmF5TGlrZShvcHRpb25zKSkge1xyXG4gICAgICAgIGRhdGEgPSBvcHRpb25zO1xyXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIGJ5dGVMZW5ndGggPSBvcHRpb25zIHwgMDtcclxuICAgICAgfSBlbHNlIGlmIChvcHRpb25zKSB7XHJcbiAgICAgICAgY2hlY2skMS50eXBlKFxyXG4gICAgICAgICAgb3B0aW9ucywgJ29iamVjdCcsXHJcbiAgICAgICAgICAnYnVmZmVyIGFyZ3VtZW50cyBtdXN0IGJlIGFuIG9iamVjdCwgYSBudW1iZXIgb3IgYW4gYXJyYXknKTtcclxuXHJcbiAgICAgICAgaWYgKCdkYXRhJyBpbiBvcHRpb25zKSB7XHJcbiAgICAgICAgICBjaGVjayQxKFxyXG4gICAgICAgICAgICBkYXRhID09PSBudWxsIHx8XHJcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoZGF0YSkgfHxcclxuICAgICAgICAgICAgaXNUeXBlZEFycmF5KGRhdGEpIHx8XHJcbiAgICAgICAgICAgIGlzTkRBcnJheUxpa2UoZGF0YSksXHJcbiAgICAgICAgICAgICdpbnZhbGlkIGRhdGEgZm9yIGJ1ZmZlcicpO1xyXG4gICAgICAgICAgZGF0YSA9IG9wdGlvbnMuZGF0YTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICgndXNhZ2UnIGluIG9wdGlvbnMpIHtcclxuICAgICAgICAgIGNoZWNrJDEucGFyYW1ldGVyKG9wdGlvbnMudXNhZ2UsIHVzYWdlVHlwZXMsICdpbnZhbGlkIGJ1ZmZlciB1c2FnZScpO1xyXG4gICAgICAgICAgdXNhZ2UgPSB1c2FnZVR5cGVzW29wdGlvbnMudXNhZ2VdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCd0eXBlJyBpbiBvcHRpb25zKSB7XHJcbiAgICAgICAgICBjaGVjayQxLnBhcmFtZXRlcihvcHRpb25zLnR5cGUsIGdsVHlwZXMsICdpbnZhbGlkIGJ1ZmZlciB0eXBlJyk7XHJcbiAgICAgICAgICBkdHlwZSA9IGdsVHlwZXNbb3B0aW9ucy50eXBlXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICgnZGltZW5zaW9uJyBpbiBvcHRpb25zKSB7XHJcbiAgICAgICAgICBjaGVjayQxLnR5cGUob3B0aW9ucy5kaW1lbnNpb24sICdudW1iZXInLCAnaW52YWxpZCBkaW1lbnNpb24nKTtcclxuICAgICAgICAgIGRpbWVuc2lvbiA9IG9wdGlvbnMuZGltZW5zaW9uIHwgMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICgnbGVuZ3RoJyBpbiBvcHRpb25zKSB7XHJcbiAgICAgICAgICBjaGVjayQxLm5uaShieXRlTGVuZ3RoLCAnYnVmZmVyIGxlbmd0aCBtdXN0IGJlIGEgbm9ubmVnYXRpdmUgaW50ZWdlcicpO1xyXG4gICAgICAgICAgYnl0ZUxlbmd0aCA9IG9wdGlvbnMubGVuZ3RoIHwgMDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGJ1ZmZlci5iaW5kKCk7XHJcbiAgICAgIGlmICghZGF0YSkge1xyXG4gICAgICAgIC8vICM0NzVcclxuICAgICAgICBpZiAoYnl0ZUxlbmd0aCkgZ2wuYnVmZmVyRGF0YShidWZmZXIudHlwZSwgYnl0ZUxlbmd0aCwgdXNhZ2UpO1xyXG4gICAgICAgIGJ1ZmZlci5kdHlwZSA9IGR0eXBlIHx8IEdMX1VOU0lHTkVEX0JZVEUkMztcclxuICAgICAgICBidWZmZXIudXNhZ2UgPSB1c2FnZTtcclxuICAgICAgICBidWZmZXIuZGltZW5zaW9uID0gZGltZW5zaW9uO1xyXG4gICAgICAgIGJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpbml0QnVmZmVyRnJvbURhdGEoYnVmZmVyLCBkYXRhLCB1c2FnZSwgZHR5cGUsIGRpbWVuc2lvbiwgcGVyc2lzdGVudCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChjb25maWcucHJvZmlsZSkge1xyXG4gICAgICAgIGJ1ZmZlci5zdGF0cy5zaXplID0gYnVmZmVyLmJ5dGVMZW5ndGggKiBEVFlQRVNfU0laRVNbYnVmZmVyLmR0eXBlXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJlZ2xCdWZmZXJcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzZXRTdWJEYXRhIChkYXRhLCBvZmZzZXQpIHtcclxuICAgICAgY2hlY2skMShvZmZzZXQgKyBkYXRhLmJ5dGVMZW5ndGggPD0gYnVmZmVyLmJ5dGVMZW5ndGgsXHJcbiAgICAgICAgJ2ludmFsaWQgYnVmZmVyIHN1YmRhdGEgY2FsbCwgYnVmZmVyIGlzIHRvbyBzbWFsbC4gJyArICcgQ2FuXFwndCB3cml0ZSBkYXRhIG9mIHNpemUgJyArIGRhdGEuYnl0ZUxlbmd0aCArICcgc3RhcnRpbmcgZnJvbSBvZmZzZXQgJyArIG9mZnNldCArICcgdG8gYSBidWZmZXIgb2Ygc2l6ZSAnICsgYnVmZmVyLmJ5dGVMZW5ndGgpO1xyXG5cclxuICAgICAgZ2wuYnVmZmVyU3ViRGF0YShidWZmZXIudHlwZSwgb2Zmc2V0LCBkYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzdWJkYXRhIChkYXRhLCBvZmZzZXRfKSB7XHJcbiAgICAgIHZhciBvZmZzZXQgPSAob2Zmc2V0XyB8fCAwKSB8IDA7XHJcbiAgICAgIHZhciBzaGFwZTtcclxuICAgICAgYnVmZmVyLmJpbmQoKTtcclxuICAgICAgaWYgKGlzVHlwZWRBcnJheShkYXRhKSkge1xyXG4gICAgICAgIHNldFN1YkRhdGEoZGF0YSwgb2Zmc2V0KTtcclxuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XHJcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgaWYgKHR5cGVvZiBkYXRhWzBdID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICB2YXIgY29udmVydGVkID0gcG9vbC5hbGxvY1R5cGUoYnVmZmVyLmR0eXBlLCBkYXRhLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIGNvcHlBcnJheShjb252ZXJ0ZWQsIGRhdGEpO1xyXG4gICAgICAgICAgICBzZXRTdWJEYXRhKGNvbnZlcnRlZCwgb2Zmc2V0KTtcclxuICAgICAgICAgICAgcG9vbC5mcmVlVHlwZShjb252ZXJ0ZWQpO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGRhdGFbMF0pIHx8IGlzVHlwZWRBcnJheShkYXRhWzBdKSkge1xyXG4gICAgICAgICAgICBzaGFwZSA9IGFycmF5U2hhcGUoZGF0YSk7XHJcbiAgICAgICAgICAgIHZhciBmbGF0RGF0YSA9IGFycmF5RmxhdHRlbihkYXRhLCBzaGFwZSwgYnVmZmVyLmR0eXBlKTtcclxuICAgICAgICAgICAgc2V0U3ViRGF0YShmbGF0RGF0YSwgb2Zmc2V0KTtcclxuICAgICAgICAgICAgcG9vbC5mcmVlVHlwZShmbGF0RGF0YSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjaGVjayQxLnJhaXNlKCdpbnZhbGlkIGJ1ZmZlciBkYXRhJyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKGlzTkRBcnJheUxpa2UoZGF0YSkpIHtcclxuICAgICAgICBzaGFwZSA9IGRhdGEuc2hhcGU7XHJcbiAgICAgICAgdmFyIHN0cmlkZSA9IGRhdGEuc3RyaWRlO1xyXG5cclxuICAgICAgICB2YXIgc2hhcGVYID0gMDtcclxuICAgICAgICB2YXIgc2hhcGVZID0gMDtcclxuICAgICAgICB2YXIgc3RyaWRlWCA9IDA7XHJcbiAgICAgICAgdmFyIHN0cmlkZVkgPSAwO1xyXG4gICAgICAgIGlmIChzaGFwZS5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgIHNoYXBlWCA9IHNoYXBlWzBdO1xyXG4gICAgICAgICAgc2hhcGVZID0gMTtcclxuICAgICAgICAgIHN0cmlkZVggPSBzdHJpZGVbMF07XHJcbiAgICAgICAgICBzdHJpZGVZID0gMDtcclxuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgICAgc2hhcGVYID0gc2hhcGVbMF07XHJcbiAgICAgICAgICBzaGFwZVkgPSBzaGFwZVsxXTtcclxuICAgICAgICAgIHN0cmlkZVggPSBzdHJpZGVbMF07XHJcbiAgICAgICAgICBzdHJpZGVZID0gc3RyaWRlWzFdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjaGVjayQxLnJhaXNlKCdpbnZhbGlkIHNoYXBlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBkdHlwZSA9IEFycmF5LmlzQXJyYXkoZGF0YS5kYXRhKVxyXG4gICAgICAgICAgPyBidWZmZXIuZHR5cGVcclxuICAgICAgICAgIDogdHlwZWRBcnJheUNvZGUoZGF0YS5kYXRhKTtcclxuXHJcbiAgICAgICAgdmFyIHRyYW5zcG9zZURhdGEgPSBwb29sLmFsbG9jVHlwZShkdHlwZSwgc2hhcGVYICogc2hhcGVZKTtcclxuICAgICAgICB0cmFuc3Bvc2UodHJhbnNwb3NlRGF0YSxcclxuICAgICAgICAgIGRhdGEuZGF0YSxcclxuICAgICAgICAgIHNoYXBlWCwgc2hhcGVZLFxyXG4gICAgICAgICAgc3RyaWRlWCwgc3RyaWRlWSxcclxuICAgICAgICAgIGRhdGEub2Zmc2V0KTtcclxuICAgICAgICBzZXRTdWJEYXRhKHRyYW5zcG9zZURhdGEsIG9mZnNldCk7XHJcbiAgICAgICAgcG9vbC5mcmVlVHlwZSh0cmFuc3Bvc2VEYXRhKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjaGVjayQxLnJhaXNlKCdpbnZhbGlkIGRhdGEgZm9yIGJ1ZmZlciBzdWJkYXRhJyk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJlZ2xCdWZmZXJcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWRlZmVySW5pdCkge1xyXG4gICAgICByZWdsQnVmZmVyKG9wdGlvbnMpO1xyXG4gICAgfVxyXG5cclxuICAgIHJlZ2xCdWZmZXIuX3JlZ2xUeXBlID0gJ2J1ZmZlcic7XHJcbiAgICByZWdsQnVmZmVyLl9idWZmZXIgPSBidWZmZXI7XHJcbiAgICByZWdsQnVmZmVyLnN1YmRhdGEgPSBzdWJkYXRhO1xyXG4gICAgaWYgKGNvbmZpZy5wcm9maWxlKSB7XHJcbiAgICAgIHJlZ2xCdWZmZXIuc3RhdHMgPSBidWZmZXIuc3RhdHM7XHJcbiAgICB9XHJcbiAgICByZWdsQnVmZmVyLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7IGRlc3Ryb3koYnVmZmVyKTsgfTtcclxuXHJcbiAgICByZXR1cm4gcmVnbEJ1ZmZlclxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmVzdG9yZUJ1ZmZlcnMgKCkge1xyXG4gICAgdmFsdWVzKGJ1ZmZlclNldCkuZm9yRWFjaChmdW5jdGlvbiAoYnVmZmVyKSB7XHJcbiAgICAgIGJ1ZmZlci5idWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcclxuICAgICAgZ2wuYmluZEJ1ZmZlcihidWZmZXIudHlwZSwgYnVmZmVyLmJ1ZmZlcik7XHJcbiAgICAgIGdsLmJ1ZmZlckRhdGEoXHJcbiAgICAgICAgYnVmZmVyLnR5cGUsIGJ1ZmZlci5wZXJzaXN0ZW50RGF0YSB8fCBidWZmZXIuYnl0ZUxlbmd0aCwgYnVmZmVyLnVzYWdlKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgaWYgKGNvbmZpZy5wcm9maWxlKSB7XHJcbiAgICBzdGF0cy5nZXRUb3RhbEJ1ZmZlclNpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciB0b3RhbCA9IDA7XHJcbiAgICAgIC8vIFRPRE86IFJpZ2h0IG5vdywgdGhlIHN0cmVhbXMgYXJlIG5vdCBwYXJ0IG9mIHRoZSB0b3RhbCBjb3VudC5cclxuICAgICAgT2JqZWN0LmtleXMoYnVmZmVyU2V0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICB0b3RhbCArPSBidWZmZXJTZXRba2V5XS5zdGF0cy5zaXplO1xyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIHRvdGFsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGNyZWF0ZTogY3JlYXRlQnVmZmVyLFxyXG5cclxuICAgIGNyZWF0ZVN0cmVhbTogY3JlYXRlU3RyZWFtLFxyXG4gICAgZGVzdHJveVN0cmVhbTogZGVzdHJveVN0cmVhbSxcclxuXHJcbiAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YWx1ZXMoYnVmZmVyU2V0KS5mb3JFYWNoKGRlc3Ryb3kpO1xyXG4gICAgICBzdHJlYW1Qb29sLmZvckVhY2goZGVzdHJveSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldEJ1ZmZlcjogZnVuY3Rpb24gKHdyYXBwZXIpIHtcclxuICAgICAgaWYgKHdyYXBwZXIgJiYgd3JhcHBlci5fYnVmZmVyIGluc3RhbmNlb2YgUkVHTEJ1ZmZlcikge1xyXG4gICAgICAgIHJldHVybiB3cmFwcGVyLl9idWZmZXJcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbnVsbFxyXG4gICAgfSxcclxuXHJcbiAgICByZXN0b3JlOiByZXN0b3JlQnVmZmVycyxcclxuXHJcbiAgICBfaW5pdEJ1ZmZlcjogaW5pdEJ1ZmZlckZyb21EYXRhXHJcbiAgfVxyXG59XHJcblxyXG52YXIgcG9pbnRzID0gMDtcclxudmFyIHBvaW50ID0gMDtcclxudmFyIGxpbmVzID0gMTtcclxudmFyIGxpbmUgPSAxO1xyXG52YXIgdHJpYW5nbGVzID0gNDtcclxudmFyIHRyaWFuZ2xlID0gNDtcclxudmFyIHByaW1UeXBlcyA9IHtcclxuXHRwb2ludHM6IHBvaW50cyxcclxuXHRwb2ludDogcG9pbnQsXHJcblx0bGluZXM6IGxpbmVzLFxyXG5cdGxpbmU6IGxpbmUsXHJcblx0dHJpYW5nbGVzOiB0cmlhbmdsZXMsXHJcblx0dHJpYW5nbGU6IHRyaWFuZ2xlLFxyXG5cdFwibGluZSBsb29wXCI6IDIsXHJcblx0XCJsaW5lIHN0cmlwXCI6IDMsXHJcblx0XCJ0cmlhbmdsZSBzdHJpcFwiOiA1LFxyXG5cdFwidHJpYW5nbGUgZmFuXCI6IDZcclxufTtcclxuXHJcbnZhciBHTF9QT0lOVFMgPSAwO1xyXG52YXIgR0xfTElORVMgPSAxO1xyXG52YXIgR0xfVFJJQU5HTEVTID0gNDtcclxuXHJcbnZhciBHTF9CWVRFJDIgPSA1MTIwO1xyXG52YXIgR0xfVU5TSUdORURfQllURSQ0ID0gNTEyMTtcclxudmFyIEdMX1NIT1JUJDIgPSA1MTIyO1xyXG52YXIgR0xfVU5TSUdORURfU0hPUlQkMiA9IDUxMjM7XHJcbnZhciBHTF9JTlQkMiA9IDUxMjQ7XHJcbnZhciBHTF9VTlNJR05FRF9JTlQkMiA9IDUxMjU7XHJcblxyXG52YXIgR0xfRUxFTUVOVF9BUlJBWV9CVUZGRVIgPSAzNDk2MztcclxuXHJcbnZhciBHTF9TVFJFQU1fRFJBVyQxID0gMHg4OEUwO1xyXG52YXIgR0xfU1RBVElDX0RSQVckMSA9IDB4ODhFNDtcclxuXHJcbmZ1bmN0aW9uIHdyYXBFbGVtZW50c1N0YXRlIChnbCwgZXh0ZW5zaW9ucywgYnVmZmVyU3RhdGUsIHN0YXRzKSB7XHJcbiAgdmFyIGVsZW1lbnRTZXQgPSB7fTtcclxuICB2YXIgZWxlbWVudENvdW50ID0gMDtcclxuXHJcbiAgdmFyIGVsZW1lbnRUeXBlcyA9IHtcclxuICAgICd1aW50OCc6IEdMX1VOU0lHTkVEX0JZVEUkNCxcclxuICAgICd1aW50MTYnOiBHTF9VTlNJR05FRF9TSE9SVCQyXHJcbiAgfTtcclxuXHJcbiAgaWYgKGV4dGVuc2lvbnMub2VzX2VsZW1lbnRfaW5kZXhfdWludCkge1xyXG4gICAgZWxlbWVudFR5cGVzLnVpbnQzMiA9IEdMX1VOU0lHTkVEX0lOVCQyO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gUkVHTEVsZW1lbnRCdWZmZXIgKGJ1ZmZlcikge1xyXG4gICAgdGhpcy5pZCA9IGVsZW1lbnRDb3VudCsrO1xyXG4gICAgZWxlbWVudFNldFt0aGlzLmlkXSA9IHRoaXM7XHJcbiAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcclxuICAgIHRoaXMucHJpbVR5cGUgPSBHTF9UUklBTkdMRVM7XHJcbiAgICB0aGlzLnZlcnRDb3VudCA9IDA7XHJcbiAgICB0aGlzLnR5cGUgPSAwO1xyXG4gIH1cclxuXHJcbiAgUkVHTEVsZW1lbnRCdWZmZXIucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLmJ1ZmZlci5iaW5kKCk7XHJcbiAgfTtcclxuXHJcbiAgdmFyIGJ1ZmZlclBvb2wgPSBbXTtcclxuXHJcbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFN0cmVhbSAoZGF0YSkge1xyXG4gICAgdmFyIHJlc3VsdCA9IGJ1ZmZlclBvb2wucG9wKCk7XHJcbiAgICBpZiAoIXJlc3VsdCkge1xyXG4gICAgICByZXN1bHQgPSBuZXcgUkVHTEVsZW1lbnRCdWZmZXIoYnVmZmVyU3RhdGUuY3JlYXRlKFxyXG4gICAgICAgIG51bGwsXHJcbiAgICAgICAgR0xfRUxFTUVOVF9BUlJBWV9CVUZGRVIsXHJcbiAgICAgICAgdHJ1ZSxcclxuICAgICAgICBmYWxzZSkuX2J1ZmZlcik7XHJcbiAgICB9XHJcbiAgICBpbml0RWxlbWVudHMocmVzdWx0LCBkYXRhLCBHTF9TVFJFQU1fRFJBVyQxLCAtMSwgLTEsIDAsIDApO1xyXG4gICAgcmV0dXJuIHJlc3VsdFxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZGVzdHJveUVsZW1lbnRTdHJlYW0gKGVsZW1lbnRzKSB7XHJcbiAgICBidWZmZXJQb29sLnB1c2goZWxlbWVudHMpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaW5pdEVsZW1lbnRzIChcclxuICAgIGVsZW1lbnRzLFxyXG4gICAgZGF0YSxcclxuICAgIHVzYWdlLFxyXG4gICAgcHJpbSxcclxuICAgIGNvdW50LFxyXG4gICAgYnl0ZUxlbmd0aCxcclxuICAgIHR5cGUpIHtcclxuICAgIGVsZW1lbnRzLmJ1ZmZlci5iaW5kKCk7XHJcbiAgICBpZiAoZGF0YSkge1xyXG4gICAgICB2YXIgcHJlZGljdGVkVHlwZSA9IHR5cGU7XHJcbiAgICAgIGlmICghdHlwZSAmJiAoXHJcbiAgICAgICAgICAhaXNUeXBlZEFycmF5KGRhdGEpIHx8XHJcbiAgICAgICAgIChpc05EQXJyYXlMaWtlKGRhdGEpICYmICFpc1R5cGVkQXJyYXkoZGF0YS5kYXRhKSkpKSB7XHJcbiAgICAgICAgcHJlZGljdGVkVHlwZSA9IGV4dGVuc2lvbnMub2VzX2VsZW1lbnRfaW5kZXhfdWludFxyXG4gICAgICAgICAgPyBHTF9VTlNJR05FRF9JTlQkMlxyXG4gICAgICAgICAgOiBHTF9VTlNJR05FRF9TSE9SVCQyO1xyXG4gICAgICB9XHJcbiAgICAgIGJ1ZmZlclN0YXRlLl9pbml0QnVmZmVyKFxyXG4gICAgICAgIGVsZW1lbnRzLmJ1ZmZlcixcclxuICAgICAgICBkYXRhLFxyXG4gICAgICAgIHVzYWdlLFxyXG4gICAgICAgIHByZWRpY3RlZFR5cGUsXHJcbiAgICAgICAgMyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBnbC5idWZmZXJEYXRhKEdMX0VMRU1FTlRfQVJSQVlfQlVGRkVSLCBieXRlTGVuZ3RoLCB1c2FnZSk7XHJcbiAgICAgIGVsZW1lbnRzLmJ1ZmZlci5kdHlwZSA9IGR0eXBlIHx8IEdMX1VOU0lHTkVEX0JZVEUkNDtcclxuICAgICAgZWxlbWVudHMuYnVmZmVyLnVzYWdlID0gdXNhZ2U7XHJcbiAgICAgIGVsZW1lbnRzLmJ1ZmZlci5kaW1lbnNpb24gPSAzO1xyXG4gICAgICBlbGVtZW50cy5idWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGR0eXBlID0gdHlwZTtcclxuICAgIGlmICghdHlwZSkge1xyXG4gICAgICBzd2l0Y2ggKGVsZW1lbnRzLmJ1ZmZlci5kdHlwZSkge1xyXG4gICAgICAgIGNhc2UgR0xfVU5TSUdORURfQllURSQ0OlxyXG4gICAgICAgIGNhc2UgR0xfQllURSQyOlxyXG4gICAgICAgICAgZHR5cGUgPSBHTF9VTlNJR05FRF9CWVRFJDQ7XHJcbiAgICAgICAgICBicmVha1xyXG5cclxuICAgICAgICBjYXNlIEdMX1VOU0lHTkVEX1NIT1JUJDI6XHJcbiAgICAgICAgY2FzZSBHTF9TSE9SVCQyOlxyXG4gICAgICAgICAgZHR5cGUgPSBHTF9VTlNJR05FRF9TSE9SVCQyO1xyXG4gICAgICAgICAgYnJlYWtcclxuXHJcbiAgICAgICAgY2FzZSBHTF9VTlNJR05FRF9JTlQkMjpcclxuICAgICAgICBjYXNlIEdMX0lOVCQyOlxyXG4gICAgICAgICAgZHR5cGUgPSBHTF9VTlNJR05FRF9JTlQkMjtcclxuICAgICAgICAgIGJyZWFrXHJcblxyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBjaGVjayQxLnJhaXNlKCd1bnN1cHBvcnRlZCB0eXBlIGZvciBlbGVtZW50IGFycmF5Jyk7XHJcbiAgICAgIH1cclxuICAgICAgZWxlbWVudHMuYnVmZmVyLmR0eXBlID0gZHR5cGU7XHJcbiAgICB9XHJcbiAgICBlbGVtZW50cy50eXBlID0gZHR5cGU7XHJcblxyXG4gICAgLy8gQ2hlY2sgb2VzX2VsZW1lbnRfaW5kZXhfdWludCBleHRlbnNpb25cclxuICAgIGNoZWNrJDEoXHJcbiAgICAgIGR0eXBlICE9PSBHTF9VTlNJR05FRF9JTlQkMiB8fFxyXG4gICAgICAhIWV4dGVuc2lvbnMub2VzX2VsZW1lbnRfaW5kZXhfdWludCxcclxuICAgICAgJzMyIGJpdCBlbGVtZW50IGJ1ZmZlcnMgbm90IHN1cHBvcnRlZCwgZW5hYmxlIG9lc19lbGVtZW50X2luZGV4X3VpbnQgZmlyc3QnKTtcclxuXHJcbiAgICAvLyB0cnkgdG8gZ3Vlc3MgZGVmYXVsdCBwcmltaXRpdmUgdHlwZSBhbmQgYXJndW1lbnRzXHJcbiAgICB2YXIgdmVydENvdW50ID0gY291bnQ7XHJcbiAgICBpZiAodmVydENvdW50IDwgMCkge1xyXG4gICAgICB2ZXJ0Q291bnQgPSBlbGVtZW50cy5idWZmZXIuYnl0ZUxlbmd0aDtcclxuICAgICAgaWYgKGR0eXBlID09PSBHTF9VTlNJR05FRF9TSE9SVCQyKSB7XHJcbiAgICAgICAgdmVydENvdW50ID4+PSAxO1xyXG4gICAgICB9IGVsc2UgaWYgKGR0eXBlID09PSBHTF9VTlNJR05FRF9JTlQkMikge1xyXG4gICAgICAgIHZlcnRDb3VudCA+Pj0gMjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxlbWVudHMudmVydENvdW50ID0gdmVydENvdW50O1xyXG5cclxuICAgIC8vIHRyeSB0byBndWVzcyBwcmltaXRpdmUgdHlwZSBmcm9tIGNlbGwgZGltZW5zaW9uXHJcbiAgICB2YXIgcHJpbVR5cGUgPSBwcmltO1xyXG4gICAgaWYgKHByaW0gPCAwKSB7XHJcbiAgICAgIHByaW1UeXBlID0gR0xfVFJJQU5HTEVTO1xyXG4gICAgICB2YXIgZGltZW5zaW9uID0gZWxlbWVudHMuYnVmZmVyLmRpbWVuc2lvbjtcclxuICAgICAgaWYgKGRpbWVuc2lvbiA9PT0gMSkgcHJpbVR5cGUgPSBHTF9QT0lOVFM7XHJcbiAgICAgIGlmIChkaW1lbnNpb24gPT09IDIpIHByaW1UeXBlID0gR0xfTElORVM7XHJcbiAgICAgIGlmIChkaW1lbnNpb24gPT09IDMpIHByaW1UeXBlID0gR0xfVFJJQU5HTEVTO1xyXG4gICAgfVxyXG4gICAgZWxlbWVudHMucHJpbVR5cGUgPSBwcmltVHlwZTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGRlc3Ryb3lFbGVtZW50cyAoZWxlbWVudHMpIHtcclxuICAgIHN0YXRzLmVsZW1lbnRzQ291bnQtLTtcclxuXHJcbiAgICBjaGVjayQxKGVsZW1lbnRzLmJ1ZmZlciAhPT0gbnVsbCwgJ211c3Qgbm90IGRvdWJsZSBkZXN0cm95IGVsZW1lbnRzJyk7XHJcbiAgICBkZWxldGUgZWxlbWVudFNldFtlbGVtZW50cy5pZF07XHJcbiAgICBlbGVtZW50cy5idWZmZXIuZGVzdHJveSgpO1xyXG4gICAgZWxlbWVudHMuYnVmZmVyID0gbnVsbDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRzIChvcHRpb25zLCBwZXJzaXN0ZW50KSB7XHJcbiAgICB2YXIgYnVmZmVyID0gYnVmZmVyU3RhdGUuY3JlYXRlKG51bGwsIEdMX0VMRU1FTlRfQVJSQVlfQlVGRkVSLCB0cnVlKTtcclxuICAgIHZhciBlbGVtZW50cyA9IG5ldyBSRUdMRWxlbWVudEJ1ZmZlcihidWZmZXIuX2J1ZmZlcik7XHJcbiAgICBzdGF0cy5lbGVtZW50c0NvdW50Kys7XHJcblxyXG4gICAgZnVuY3Rpb24gcmVnbEVsZW1lbnRzIChvcHRpb25zKSB7XHJcbiAgICAgIGlmICghb3B0aW9ucykge1xyXG4gICAgICAgIGJ1ZmZlcigpO1xyXG4gICAgICAgIGVsZW1lbnRzLnByaW1UeXBlID0gR0xfVFJJQU5HTEVTO1xyXG4gICAgICAgIGVsZW1lbnRzLnZlcnRDb3VudCA9IDA7XHJcbiAgICAgICAgZWxlbWVudHMudHlwZSA9IEdMX1VOU0lHTkVEX0JZVEUkNDtcclxuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICBidWZmZXIob3B0aW9ucyk7XHJcbiAgICAgICAgZWxlbWVudHMucHJpbVR5cGUgPSBHTF9UUklBTkdMRVM7XHJcbiAgICAgICAgZWxlbWVudHMudmVydENvdW50ID0gb3B0aW9ucyB8IDA7XHJcbiAgICAgICAgZWxlbWVudHMudHlwZSA9IEdMX1VOU0lHTkVEX0JZVEUkNDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB2YXIgZGF0YSA9IG51bGw7XHJcbiAgICAgICAgdmFyIHVzYWdlID0gR0xfU1RBVElDX0RSQVckMTtcclxuICAgICAgICB2YXIgcHJpbVR5cGUgPSAtMTtcclxuICAgICAgICB2YXIgdmVydENvdW50ID0gLTE7XHJcbiAgICAgICAgdmFyIGJ5dGVMZW5ndGggPSAwO1xyXG4gICAgICAgIHZhciBkdHlwZSA9IDA7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykgfHxcclxuICAgICAgICAgICAgaXNUeXBlZEFycmF5KG9wdGlvbnMpIHx8XHJcbiAgICAgICAgICAgIGlzTkRBcnJheUxpa2Uob3B0aW9ucykpIHtcclxuICAgICAgICAgIGRhdGEgPSBvcHRpb25zO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjaGVjayQxLnR5cGUob3B0aW9ucywgJ29iamVjdCcsICdpbnZhbGlkIGFyZ3VtZW50cyBmb3IgZWxlbWVudHMnKTtcclxuICAgICAgICAgIGlmICgnZGF0YScgaW4gb3B0aW9ucykge1xyXG4gICAgICAgICAgICBkYXRhID0gb3B0aW9ucy5kYXRhO1xyXG4gICAgICAgICAgICBjaGVjayQxKFxyXG4gICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShkYXRhKSB8fFxyXG4gICAgICAgICAgICAgICAgaXNUeXBlZEFycmF5KGRhdGEpIHx8XHJcbiAgICAgICAgICAgICAgICBpc05EQXJyYXlMaWtlKGRhdGEpLFxyXG4gICAgICAgICAgICAgICAgJ2ludmFsaWQgZGF0YSBmb3IgZWxlbWVudCBidWZmZXInKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICgndXNhZ2UnIGluIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgY2hlY2skMS5wYXJhbWV0ZXIoXHJcbiAgICAgICAgICAgICAgb3B0aW9ucy51c2FnZSxcclxuICAgICAgICAgICAgICB1c2FnZVR5cGVzLFxyXG4gICAgICAgICAgICAgICdpbnZhbGlkIGVsZW1lbnQgYnVmZmVyIHVzYWdlJyk7XHJcbiAgICAgICAgICAgIHVzYWdlID0gdXNhZ2VUeXBlc1tvcHRpb25zLnVzYWdlXTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICgncHJpbWl0aXZlJyBpbiBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIGNoZWNrJDEucGFyYW1ldGVyKFxyXG4gICAgICAgICAgICAgIG9wdGlvbnMucHJpbWl0aXZlLFxyXG4gICAgICAgICAgICAgIHByaW1UeXBlcyxcclxuICAgICAgICAgICAgICAnaW52YWxpZCBlbGVtZW50IGJ1ZmZlciBwcmltaXRpdmUnKTtcclxuICAgICAgICAgICAgcHJpbVR5cGUgPSBwcmltVHlwZXNbb3B0aW9ucy5wcmltaXRpdmVdO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKCdjb3VudCcgaW4gb3B0aW9ucykge1xyXG4gICAgICAgICAgICBjaGVjayQxKFxyXG4gICAgICAgICAgICAgIHR5cGVvZiBvcHRpb25zLmNvdW50ID09PSAnbnVtYmVyJyAmJiBvcHRpb25zLmNvdW50ID49IDAsXHJcbiAgICAgICAgICAgICAgJ2ludmFsaWQgdmVydGV4IGNvdW50IGZvciBlbGVtZW50cycpO1xyXG4gICAgICAgICAgICB2ZXJ0Q291bnQgPSBvcHRpb25zLmNvdW50IHwgMDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICgndHlwZScgaW4gb3B0aW9ucykge1xyXG4gICAgICAgICAgICBjaGVjayQxLnBhcmFtZXRlcihcclxuICAgICAgICAgICAgICBvcHRpb25zLnR5cGUsXHJcbiAgICAgICAgICAgICAgZWxlbWVudFR5cGVzLFxyXG4gICAgICAgICAgICAgICdpbnZhbGlkIGJ1ZmZlciB0eXBlJyk7XHJcbiAgICAgICAgICAgIGR0eXBlID0gZWxlbWVudFR5cGVzW29wdGlvbnMudHlwZV07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoJ2xlbmd0aCcgaW4gb3B0aW9ucykge1xyXG4gICAgICAgICAgICBieXRlTGVuZ3RoID0gb3B0aW9ucy5sZW5ndGggfCAwO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYnl0ZUxlbmd0aCA9IHZlcnRDb3VudDtcclxuICAgICAgICAgICAgaWYgKGR0eXBlID09PSBHTF9VTlNJR05FRF9TSE9SVCQyIHx8IGR0eXBlID09PSBHTF9TSE9SVCQyKSB7XHJcbiAgICAgICAgICAgICAgYnl0ZUxlbmd0aCAqPSAyO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGR0eXBlID09PSBHTF9VTlNJR05FRF9JTlQkMiB8fCBkdHlwZSA9PT0gR0xfSU5UJDIpIHtcclxuICAgICAgICAgICAgICBieXRlTGVuZ3RoICo9IDQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaW5pdEVsZW1lbnRzKFxyXG4gICAgICAgICAgZWxlbWVudHMsXHJcbiAgICAgICAgICBkYXRhLFxyXG4gICAgICAgICAgdXNhZ2UsXHJcbiAgICAgICAgICBwcmltVHlwZSxcclxuICAgICAgICAgIHZlcnRDb3VudCxcclxuICAgICAgICAgIGJ5dGVMZW5ndGgsXHJcbiAgICAgICAgICBkdHlwZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiByZWdsRWxlbWVudHNcclxuICAgIH1cclxuXHJcbiAgICByZWdsRWxlbWVudHMob3B0aW9ucyk7XHJcblxyXG4gICAgcmVnbEVsZW1lbnRzLl9yZWdsVHlwZSA9ICdlbGVtZW50cyc7XHJcbiAgICByZWdsRWxlbWVudHMuX2VsZW1lbnRzID0gZWxlbWVudHM7XHJcbiAgICByZWdsRWxlbWVudHMuc3ViZGF0YSA9IGZ1bmN0aW9uIChkYXRhLCBvZmZzZXQpIHtcclxuICAgICAgYnVmZmVyLnN1YmRhdGEoZGF0YSwgb2Zmc2V0KTtcclxuICAgICAgcmV0dXJuIHJlZ2xFbGVtZW50c1xyXG4gICAgfTtcclxuICAgIHJlZ2xFbGVtZW50cy5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICBkZXN0cm95RWxlbWVudHMoZWxlbWVudHMpO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gcmVnbEVsZW1lbnRzXHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgY3JlYXRlOiBjcmVhdGVFbGVtZW50cyxcclxuICAgIGNyZWF0ZVN0cmVhbTogY3JlYXRlRWxlbWVudFN0cmVhbSxcclxuICAgIGRlc3Ryb3lTdHJlYW06IGRlc3Ryb3lFbGVtZW50U3RyZWFtLFxyXG4gICAgZ2V0RWxlbWVudHM6IGZ1bmN0aW9uIChlbGVtZW50cykge1xyXG4gICAgICBpZiAodHlwZW9mIGVsZW1lbnRzID09PSAnZnVuY3Rpb24nICYmXHJcbiAgICAgICAgICBlbGVtZW50cy5fZWxlbWVudHMgaW5zdGFuY2VvZiBSRUdMRWxlbWVudEJ1ZmZlcikge1xyXG4gICAgICAgIHJldHVybiBlbGVtZW50cy5fZWxlbWVudHNcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbnVsbFxyXG4gICAgfSxcclxuICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhbHVlcyhlbGVtZW50U2V0KS5mb3JFYWNoKGRlc3Ryb3lFbGVtZW50cyk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG52YXIgRkxPQVQgPSBuZXcgRmxvYXQzMkFycmF5KDEpO1xyXG52YXIgSU5UID0gbmV3IFVpbnQzMkFycmF5KEZMT0FULmJ1ZmZlcik7XHJcblxyXG52YXIgR0xfVU5TSUdORURfU0hPUlQkNCA9IDUxMjM7XHJcblxyXG5mdW5jdGlvbiBjb252ZXJ0VG9IYWxmRmxvYXQgKGFycmF5KSB7XHJcbiAgdmFyIHVzaG9ydHMgPSBwb29sLmFsbG9jVHlwZShHTF9VTlNJR05FRF9TSE9SVCQ0LCBhcnJheS5sZW5ndGgpO1xyXG5cclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgKytpKSB7XHJcbiAgICBpZiAoaXNOYU4oYXJyYXlbaV0pKSB7XHJcbiAgICAgIHVzaG9ydHNbaV0gPSAweGZmZmY7XHJcbiAgICB9IGVsc2UgaWYgKGFycmF5W2ldID09PSBJbmZpbml0eSkge1xyXG4gICAgICB1c2hvcnRzW2ldID0gMHg3YzAwO1xyXG4gICAgfSBlbHNlIGlmIChhcnJheVtpXSA9PT0gLUluZmluaXR5KSB7XHJcbiAgICAgIHVzaG9ydHNbaV0gPSAweGZjMDA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBGTE9BVFswXSA9IGFycmF5W2ldO1xyXG4gICAgICB2YXIgeCA9IElOVFswXTtcclxuXHJcbiAgICAgIHZhciBzZ24gPSAoeCA+Pj4gMzEpIDw8IDE1O1xyXG4gICAgICB2YXIgZXhwID0gKCh4IDw8IDEpID4+PiAyNCkgLSAxMjc7XHJcbiAgICAgIHZhciBmcmFjID0gKHggPj4gMTMpICYgKCgxIDw8IDEwKSAtIDEpO1xyXG5cclxuICAgICAgaWYgKGV4cCA8IC0yNCkge1xyXG4gICAgICAgIC8vIHJvdW5kIG5vbi1yZXByZXNlbnRhYmxlIGRlbm9ybWFscyB0byAwXHJcbiAgICAgICAgdXNob3J0c1tpXSA9IHNnbjtcclxuICAgICAgfSBlbHNlIGlmIChleHAgPCAtMTQpIHtcclxuICAgICAgICAvLyBoYW5kbGUgZGVub3JtYWxzXHJcbiAgICAgICAgdmFyIHMgPSAtMTQgLSBleHA7XHJcbiAgICAgICAgdXNob3J0c1tpXSA9IHNnbiArICgoZnJhYyArICgxIDw8IDEwKSkgPj4gcyk7XHJcbiAgICAgIH0gZWxzZSBpZiAoZXhwID4gMTUpIHtcclxuICAgICAgICAvLyByb3VuZCBvdmVyZmxvdyB0byArLy0gSW5maW5pdHlcclxuICAgICAgICB1c2hvcnRzW2ldID0gc2duICsgMHg3YzAwO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIG90aGVyd2lzZSBjb252ZXJ0IGRpcmVjdGx5XHJcbiAgICAgICAgdXNob3J0c1tpXSA9IHNnbiArICgoZXhwICsgMTUpIDw8IDEwKSArIGZyYWM7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB1c2hvcnRzXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzQXJyYXlMaWtlIChzKSB7XHJcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkocykgfHwgaXNUeXBlZEFycmF5KHMpXHJcbn1cclxuXHJcbnZhciBpc1BvdzIkMSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgcmV0dXJuICEodiAmICh2IC0gMSkpICYmICghIXYpXHJcbn07XHJcblxyXG52YXIgR0xfQ09NUFJFU1NFRF9URVhUVVJFX0ZPUk1BVFMgPSAweDg2QTM7XHJcblxyXG52YXIgR0xfVEVYVFVSRV8yRCQxID0gMHgwREUxO1xyXG52YXIgR0xfVEVYVFVSRV9DVUJFX01BUCQxID0gMHg4NTEzO1xyXG52YXIgR0xfVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YJDEgPSAweDg1MTU7XHJcblxyXG52YXIgR0xfUkdCQSQxID0gMHgxOTA4O1xyXG52YXIgR0xfQUxQSEEgPSAweDE5MDY7XHJcbnZhciBHTF9SR0IgPSAweDE5MDc7XHJcbnZhciBHTF9MVU1JTkFOQ0UgPSAweDE5MDk7XHJcbnZhciBHTF9MVU1JTkFOQ0VfQUxQSEEgPSAweDE5MEE7XHJcblxyXG52YXIgR0xfUkdCQTQgPSAweDgwNTY7XHJcbnZhciBHTF9SR0I1X0ExID0gMHg4MDU3O1xyXG52YXIgR0xfUkdCNTY1ID0gMHg4RDYyO1xyXG5cclxudmFyIEdMX1VOU0lHTkVEX1NIT1JUXzRfNF80XzQkMSA9IDB4ODAzMztcclxudmFyIEdMX1VOU0lHTkVEX1NIT1JUXzVfNV81XzEkMSA9IDB4ODAzNDtcclxudmFyIEdMX1VOU0lHTkVEX1NIT1JUXzVfNl81JDEgPSAweDgzNjM7XHJcbnZhciBHTF9VTlNJR05FRF9JTlRfMjRfOF9XRUJHTCQxID0gMHg4NEZBO1xyXG5cclxudmFyIEdMX0RFUFRIX0NPTVBPTkVOVCA9IDB4MTkwMjtcclxudmFyIEdMX0RFUFRIX1NURU5DSUwgPSAweDg0Rjk7XHJcblxyXG52YXIgR0xfU1JHQl9FWFQgPSAweDhDNDA7XHJcbnZhciBHTF9TUkdCX0FMUEhBX0VYVCA9IDB4OEM0MjtcclxuXHJcbnZhciBHTF9IQUxGX0ZMT0FUX09FUyQxID0gMHg4RDYxO1xyXG5cclxudmFyIEdMX0NPTVBSRVNTRURfUkdCX1MzVENfRFhUMV9FWFQgPSAweDgzRjA7XHJcbnZhciBHTF9DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQxX0VYVCA9IDB4ODNGMTtcclxudmFyIEdMX0NPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDNfRVhUID0gMHg4M0YyO1xyXG52YXIgR0xfQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUNV9FWFQgPSAweDgzRjM7XHJcblxyXG52YXIgR0xfQ09NUFJFU1NFRF9SR0JfQVRDX1dFQkdMID0gMHg4QzkyO1xyXG52YXIgR0xfQ09NUFJFU1NFRF9SR0JBX0FUQ19FWFBMSUNJVF9BTFBIQV9XRUJHTCA9IDB4OEM5MztcclxudmFyIEdMX0NPTVBSRVNTRURfUkdCQV9BVENfSU5URVJQT0xBVEVEX0FMUEhBX1dFQkdMID0gMHg4N0VFO1xyXG5cclxudmFyIEdMX0NPTVBSRVNTRURfUkdCX1BWUlRDXzRCUFBWMV9JTUcgPSAweDhDMDA7XHJcbnZhciBHTF9DT01QUkVTU0VEX1JHQl9QVlJUQ18yQlBQVjFfSU1HID0gMHg4QzAxO1xyXG52YXIgR0xfQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzRCUFBWMV9JTUcgPSAweDhDMDI7XHJcbnZhciBHTF9DT01QUkVTU0VEX1JHQkFfUFZSVENfMkJQUFYxX0lNRyA9IDB4OEMwMztcclxuXHJcbnZhciBHTF9DT01QUkVTU0VEX1JHQl9FVEMxX1dFQkdMID0gMHg4RDY0O1xyXG5cclxudmFyIEdMX1VOU0lHTkVEX0JZVEUkNSA9IDB4MTQwMTtcclxudmFyIEdMX1VOU0lHTkVEX1NIT1JUJDMgPSAweDE0MDM7XHJcbnZhciBHTF9VTlNJR05FRF9JTlQkMyA9IDB4MTQwNTtcclxudmFyIEdMX0ZMT0FUJDQgPSAweDE0MDY7XHJcblxyXG52YXIgR0xfVEVYVFVSRV9XUkFQX1MgPSAweDI4MDI7XHJcbnZhciBHTF9URVhUVVJFX1dSQVBfVCA9IDB4MjgwMztcclxuXHJcbnZhciBHTF9SRVBFQVQgPSAweDI5MDE7XHJcbnZhciBHTF9DTEFNUF9UT19FREdFJDEgPSAweDgxMkY7XHJcbnZhciBHTF9NSVJST1JFRF9SRVBFQVQgPSAweDgzNzA7XHJcblxyXG52YXIgR0xfVEVYVFVSRV9NQUdfRklMVEVSID0gMHgyODAwO1xyXG52YXIgR0xfVEVYVFVSRV9NSU5fRklMVEVSID0gMHgyODAxO1xyXG5cclxudmFyIEdMX05FQVJFU1QkMSA9IDB4MjYwMDtcclxudmFyIEdMX0xJTkVBUiA9IDB4MjYwMTtcclxudmFyIEdMX05FQVJFU1RfTUlQTUFQX05FQVJFU1QkMSA9IDB4MjcwMDtcclxudmFyIEdMX0xJTkVBUl9NSVBNQVBfTkVBUkVTVCQxID0gMHgyNzAxO1xyXG52YXIgR0xfTkVBUkVTVF9NSVBNQVBfTElORUFSJDEgPSAweDI3MDI7XHJcbnZhciBHTF9MSU5FQVJfTUlQTUFQX0xJTkVBUiQxID0gMHgyNzAzO1xyXG5cclxudmFyIEdMX0dFTkVSQVRFX01JUE1BUF9ISU5UID0gMHg4MTkyO1xyXG52YXIgR0xfRE9OVF9DQVJFID0gMHgxMTAwO1xyXG52YXIgR0xfRkFTVEVTVCA9IDB4MTEwMTtcclxudmFyIEdMX05JQ0VTVCA9IDB4MTEwMjtcclxuXHJcbnZhciBHTF9URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCA9IDB4ODRGRTtcclxuXHJcbnZhciBHTF9VTlBBQ0tfQUxJR05NRU5UID0gMHgwQ0Y1O1xyXG52YXIgR0xfVU5QQUNLX0ZMSVBfWV9XRUJHTCA9IDB4OTI0MDtcclxudmFyIEdMX1VOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCA9IDB4OTI0MTtcclxudmFyIEdMX1VOUEFDS19DT0xPUlNQQUNFX0NPTlZFUlNJT05fV0VCR0wgPSAweDkyNDM7XHJcblxyXG52YXIgR0xfQlJPV1NFUl9ERUZBVUxUX1dFQkdMID0gMHg5MjQ0O1xyXG5cclxudmFyIEdMX1RFWFRVUkUwJDEgPSAweDg0QzA7XHJcblxyXG52YXIgTUlQTUFQX0ZJTFRFUlMgPSBbXHJcbiAgR0xfTkVBUkVTVF9NSVBNQVBfTkVBUkVTVCQxLFxyXG4gIEdMX05FQVJFU1RfTUlQTUFQX0xJTkVBUiQxLFxyXG4gIEdMX0xJTkVBUl9NSVBNQVBfTkVBUkVTVCQxLFxyXG4gIEdMX0xJTkVBUl9NSVBNQVBfTElORUFSJDFcclxuXTtcclxuXHJcbnZhciBDSEFOTkVMU19GT1JNQVQgPSBbXHJcbiAgMCxcclxuICBHTF9MVU1JTkFOQ0UsXHJcbiAgR0xfTFVNSU5BTkNFX0FMUEhBLFxyXG4gIEdMX1JHQixcclxuICBHTF9SR0JBJDFcclxuXTtcclxuXHJcbnZhciBGT1JNQVRfQ0hBTk5FTFMgPSB7fTtcclxuRk9STUFUX0NIQU5ORUxTW0dMX0xVTUlOQU5DRV0gPVxyXG5GT1JNQVRfQ0hBTk5FTFNbR0xfQUxQSEFdID1cclxuRk9STUFUX0NIQU5ORUxTW0dMX0RFUFRIX0NPTVBPTkVOVF0gPSAxO1xyXG5GT1JNQVRfQ0hBTk5FTFNbR0xfREVQVEhfU1RFTkNJTF0gPVxyXG5GT1JNQVRfQ0hBTk5FTFNbR0xfTFVNSU5BTkNFX0FMUEhBXSA9IDI7XHJcbkZPUk1BVF9DSEFOTkVMU1tHTF9SR0JdID1cclxuRk9STUFUX0NIQU5ORUxTW0dMX1NSR0JfRVhUXSA9IDM7XHJcbkZPUk1BVF9DSEFOTkVMU1tHTF9SR0JBJDFdID1cclxuRk9STUFUX0NIQU5ORUxTW0dMX1NSR0JfQUxQSEFfRVhUXSA9IDQ7XHJcblxyXG5mdW5jdGlvbiBvYmplY3ROYW1lIChzdHIpIHtcclxuICByZXR1cm4gJ1tvYmplY3QgJyArIHN0ciArICddJ1xyXG59XHJcblxyXG52YXIgQ0FOVkFTX0NMQVNTID0gb2JqZWN0TmFtZSgnSFRNTENhbnZhc0VsZW1lbnQnKTtcclxudmFyIENPTlRFWFQyRF9DTEFTUyA9IG9iamVjdE5hbWUoJ0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCcpO1xyXG52YXIgQklUTUFQX0NMQVNTID0gb2JqZWN0TmFtZSgnSW1hZ2VCaXRtYXAnKTtcclxudmFyIElNQUdFX0NMQVNTID0gb2JqZWN0TmFtZSgnSFRNTEltYWdlRWxlbWVudCcpO1xyXG52YXIgVklERU9fQ0xBU1MgPSBvYmplY3ROYW1lKCdIVE1MVmlkZW9FbGVtZW50Jyk7XHJcblxyXG52YXIgUElYRUxfQ0xBU1NFUyA9IE9iamVjdC5rZXlzKGFycmF5VHlwZXMpLmNvbmNhdChbXHJcbiAgQ0FOVkFTX0NMQVNTLFxyXG4gIENPTlRFWFQyRF9DTEFTUyxcclxuICBCSVRNQVBfQ0xBU1MsXHJcbiAgSU1BR0VfQ0xBU1MsXHJcbiAgVklERU9fQ0xBU1NcclxuXSk7XHJcblxyXG4vLyBmb3IgZXZlcnkgdGV4dHVyZSB0eXBlLCBzdG9yZVxyXG4vLyB0aGUgc2l6ZSBpbiBieXRlcy5cclxudmFyIFRZUEVfU0laRVMgPSBbXTtcclxuVFlQRV9TSVpFU1tHTF9VTlNJR05FRF9CWVRFJDVdID0gMTtcclxuVFlQRV9TSVpFU1tHTF9GTE9BVCQ0XSA9IDQ7XHJcblRZUEVfU0laRVNbR0xfSEFMRl9GTE9BVF9PRVMkMV0gPSAyO1xyXG5cclxuVFlQRV9TSVpFU1tHTF9VTlNJR05FRF9TSE9SVCQzXSA9IDI7XHJcblRZUEVfU0laRVNbR0xfVU5TSUdORURfSU5UJDNdID0gNDtcclxuXHJcbnZhciBGT1JNQVRfU0laRVNfU1BFQ0lBTCA9IFtdO1xyXG5GT1JNQVRfU0laRVNfU1BFQ0lBTFtHTF9SR0JBNF0gPSAyO1xyXG5GT1JNQVRfU0laRVNfU1BFQ0lBTFtHTF9SR0I1X0ExXSA9IDI7XHJcbkZPUk1BVF9TSVpFU19TUEVDSUFMW0dMX1JHQjU2NV0gPSAyO1xyXG5GT1JNQVRfU0laRVNfU1BFQ0lBTFtHTF9ERVBUSF9TVEVOQ0lMXSA9IDQ7XHJcblxyXG5GT1JNQVRfU0laRVNfU1BFQ0lBTFtHTF9DT01QUkVTU0VEX1JHQl9TM1RDX0RYVDFfRVhUXSA9IDAuNTtcclxuRk9STUFUX1NJWkVTX1NQRUNJQUxbR0xfQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUMV9FWFRdID0gMC41O1xyXG5GT1JNQVRfU0laRVNfU1BFQ0lBTFtHTF9DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQzX0VYVF0gPSAxO1xyXG5GT1JNQVRfU0laRVNfU1BFQ0lBTFtHTF9DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQ1X0VYVF0gPSAxO1xyXG5cclxuRk9STUFUX1NJWkVTX1NQRUNJQUxbR0xfQ09NUFJFU1NFRF9SR0JfQVRDX1dFQkdMXSA9IDAuNTtcclxuRk9STUFUX1NJWkVTX1NQRUNJQUxbR0xfQ09NUFJFU1NFRF9SR0JBX0FUQ19FWFBMSUNJVF9BTFBIQV9XRUJHTF0gPSAxO1xyXG5GT1JNQVRfU0laRVNfU1BFQ0lBTFtHTF9DT01QUkVTU0VEX1JHQkFfQVRDX0lOVEVSUE9MQVRFRF9BTFBIQV9XRUJHTF0gPSAxO1xyXG5cclxuRk9STUFUX1NJWkVTX1NQRUNJQUxbR0xfQ09NUFJFU1NFRF9SR0JfUFZSVENfNEJQUFYxX0lNR10gPSAwLjU7XHJcbkZPUk1BVF9TSVpFU19TUEVDSUFMW0dMX0NPTVBSRVNTRURfUkdCX1BWUlRDXzJCUFBWMV9JTUddID0gMC4yNTtcclxuRk9STUFUX1NJWkVTX1NQRUNJQUxbR0xfQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzRCUFBWMV9JTUddID0gMC41O1xyXG5GT1JNQVRfU0laRVNfU1BFQ0lBTFtHTF9DT01QUkVTU0VEX1JHQkFfUFZSVENfMkJQUFYxX0lNR10gPSAwLjI1O1xyXG5cclxuRk9STUFUX1NJWkVTX1NQRUNJQUxbR0xfQ09NUFJFU1NFRF9SR0JfRVRDMV9XRUJHTF0gPSAwLjU7XHJcblxyXG5mdW5jdGlvbiBpc051bWVyaWNBcnJheSAoYXJyKSB7XHJcbiAgcmV0dXJuIChcclxuICAgIEFycmF5LmlzQXJyYXkoYXJyKSAmJlxyXG4gICAgKGFyci5sZW5ndGggPT09IDAgfHxcclxuICAgIHR5cGVvZiBhcnJbMF0gPT09ICdudW1iZXInKSlcclxufVxyXG5cclxuZnVuY3Rpb24gaXNSZWN0QXJyYXkgKGFycikge1xyXG4gIGlmICghQXJyYXkuaXNBcnJheShhcnIpKSB7XHJcbiAgICByZXR1cm4gZmFsc2VcclxuICB9XHJcbiAgdmFyIHdpZHRoID0gYXJyLmxlbmd0aDtcclxuICBpZiAod2lkdGggPT09IDAgfHwgIWlzQXJyYXlMaWtlKGFyclswXSkpIHtcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH1cclxuICByZXR1cm4gdHJ1ZVxyXG59XHJcblxyXG5mdW5jdGlvbiBjbGFzc1N0cmluZyAoeCkge1xyXG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeClcclxufVxyXG5cclxuZnVuY3Rpb24gaXNDYW52YXNFbGVtZW50IChvYmplY3QpIHtcclxuICByZXR1cm4gY2xhc3NTdHJpbmcob2JqZWN0KSA9PT0gQ0FOVkFTX0NMQVNTXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzQ29udGV4dDJEIChvYmplY3QpIHtcclxuICByZXR1cm4gY2xhc3NTdHJpbmcob2JqZWN0KSA9PT0gQ09OVEVYVDJEX0NMQVNTXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzQml0bWFwIChvYmplY3QpIHtcclxuICByZXR1cm4gY2xhc3NTdHJpbmcob2JqZWN0KSA9PT0gQklUTUFQX0NMQVNTXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzSW1hZ2VFbGVtZW50IChvYmplY3QpIHtcclxuICByZXR1cm4gY2xhc3NTdHJpbmcob2JqZWN0KSA9PT0gSU1BR0VfQ0xBU1NcclxufVxyXG5cclxuZnVuY3Rpb24gaXNWaWRlb0VsZW1lbnQgKG9iamVjdCkge1xyXG4gIHJldHVybiBjbGFzc1N0cmluZyhvYmplY3QpID09PSBWSURFT19DTEFTU1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc1BpeGVsRGF0YSAob2JqZWN0KSB7XHJcbiAgaWYgKCFvYmplY3QpIHtcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH1cclxuICB2YXIgY2xhc3NOYW1lID0gY2xhc3NTdHJpbmcob2JqZWN0KTtcclxuICBpZiAoUElYRUxfQ0xBU1NFUy5pbmRleE9mKGNsYXNzTmFtZSkgPj0gMCkge1xyXG4gICAgcmV0dXJuIHRydWVcclxuICB9XHJcbiAgcmV0dXJuIChcclxuICAgIGlzTnVtZXJpY0FycmF5KG9iamVjdCkgfHxcclxuICAgIGlzUmVjdEFycmF5KG9iamVjdCkgfHxcclxuICAgIGlzTkRBcnJheUxpa2Uob2JqZWN0KSlcclxufVxyXG5cclxuZnVuY3Rpb24gdHlwZWRBcnJheUNvZGUkMSAoZGF0YSkge1xyXG4gIHJldHVybiBhcnJheVR5cGVzW09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkYXRhKV0gfCAwXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbnZlcnREYXRhIChyZXN1bHQsIGRhdGEpIHtcclxuICB2YXIgbiA9IGRhdGEubGVuZ3RoO1xyXG4gIHN3aXRjaCAocmVzdWx0LnR5cGUpIHtcclxuICAgIGNhc2UgR0xfVU5TSUdORURfQllURSQ1OlxyXG4gICAgY2FzZSBHTF9VTlNJR05FRF9TSE9SVCQzOlxyXG4gICAgY2FzZSBHTF9VTlNJR05FRF9JTlQkMzpcclxuICAgIGNhc2UgR0xfRkxPQVQkNDpcclxuICAgICAgdmFyIGNvbnZlcnRlZCA9IHBvb2wuYWxsb2NUeXBlKHJlc3VsdC50eXBlLCBuKTtcclxuICAgICAgY29udmVydGVkLnNldChkYXRhKTtcclxuICAgICAgcmVzdWx0LmRhdGEgPSBjb252ZXJ0ZWQ7XHJcbiAgICAgIGJyZWFrXHJcblxyXG4gICAgY2FzZSBHTF9IQUxGX0ZMT0FUX09FUyQxOlxyXG4gICAgICByZXN1bHQuZGF0YSA9IGNvbnZlcnRUb0hhbGZGbG9hdChkYXRhKTtcclxuICAgICAgYnJlYWtcclxuXHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICBjaGVjayQxLnJhaXNlKCd1bnN1cHBvcnRlZCB0ZXh0dXJlIHR5cGUsIG11c3Qgc3BlY2lmeSBhIHR5cGVkIGFycmF5Jyk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBwcmVDb252ZXJ0IChpbWFnZSwgbikge1xyXG4gIHJldHVybiBwb29sLmFsbG9jVHlwZShcclxuICAgIGltYWdlLnR5cGUgPT09IEdMX0hBTEZfRkxPQVRfT0VTJDFcclxuICAgICAgPyBHTF9GTE9BVCQ0XHJcbiAgICAgIDogaW1hZ2UudHlwZSwgbilcclxufVxyXG5cclxuZnVuY3Rpb24gcG9zdENvbnZlcnQgKGltYWdlLCBkYXRhKSB7XHJcbiAgaWYgKGltYWdlLnR5cGUgPT09IEdMX0hBTEZfRkxPQVRfT0VTJDEpIHtcclxuICAgIGltYWdlLmRhdGEgPSBjb252ZXJ0VG9IYWxmRmxvYXQoZGF0YSk7XHJcbiAgICBwb29sLmZyZWVUeXBlKGRhdGEpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBpbWFnZS5kYXRhID0gZGF0YTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRyYW5zcG9zZURhdGEgKGltYWdlLCBhcnJheSwgc3RyaWRlWCwgc3RyaWRlWSwgc3RyaWRlQywgb2Zmc2V0KSB7XHJcbiAgdmFyIHcgPSBpbWFnZS53aWR0aDtcclxuICB2YXIgaCA9IGltYWdlLmhlaWdodDtcclxuICB2YXIgYyA9IGltYWdlLmNoYW5uZWxzO1xyXG4gIHZhciBuID0gdyAqIGggKiBjO1xyXG4gIHZhciBkYXRhID0gcHJlQ29udmVydChpbWFnZSwgbik7XHJcblxyXG4gIHZhciBwID0gMDtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGg7ICsraSkge1xyXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCB3OyArK2opIHtcclxuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBjOyArK2spIHtcclxuICAgICAgICBkYXRhW3ArK10gPSBhcnJheVtzdHJpZGVYICogaiArIHN0cmlkZVkgKiBpICsgc3RyaWRlQyAqIGsgKyBvZmZzZXRdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwb3N0Q29udmVydChpbWFnZSwgZGF0YSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFRleHR1cmVTaXplIChmb3JtYXQsIHR5cGUsIHdpZHRoLCBoZWlnaHQsIGlzTWlwbWFwLCBpc0N1YmUpIHtcclxuICB2YXIgcztcclxuICBpZiAodHlwZW9mIEZPUk1BVF9TSVpFU19TUEVDSUFMW2Zvcm1hdF0gIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAvLyB3ZSBoYXZlIGEgc3BlY2lhbCBhcnJheSBmb3IgZGVhbGluZyB3aXRoIHdlaXJkIGNvbG9yIGZvcm1hdHMgc3VjaCBhcyBSR0I1QTFcclxuICAgIHMgPSBGT1JNQVRfU0laRVNfU1BFQ0lBTFtmb3JtYXRdO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBzID0gRk9STUFUX0NIQU5ORUxTW2Zvcm1hdF0gKiBUWVBFX1NJWkVTW3R5cGVdO1xyXG4gIH1cclxuXHJcbiAgaWYgKGlzQ3ViZSkge1xyXG4gICAgcyAqPSA2O1xyXG4gIH1cclxuXHJcbiAgaWYgKGlzTWlwbWFwKSB7XHJcbiAgICAvLyBjb21wdXRlIHRoZSB0b3RhbCBzaXplIG9mIGFsbCB0aGUgbWlwbWFwcy5cclxuICAgIHZhciB0b3RhbCA9IDA7XHJcblxyXG4gICAgdmFyIHcgPSB3aWR0aDtcclxuICAgIHdoaWxlICh3ID49IDEpIHtcclxuICAgICAgLy8gd2UgY2FuIG9ubHkgdXNlIG1pcG1hcHMgb24gYSBzcXVhcmUgaW1hZ2UsXHJcbiAgICAgIC8vIHNvIHdlIGNhbiBzaW1wbHkgdXNlIHRoZSB3aWR0aCBhbmQgaWdub3JlIHRoZSBoZWlnaHQ6XHJcbiAgICAgIHRvdGFsICs9IHMgKiB3ICogdztcclxuICAgICAgdyAvPSAyO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRvdGFsXHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBzICogd2lkdGggKiBoZWlnaHRcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVRleHR1cmVTZXQgKFxyXG4gIGdsLCBleHRlbnNpb25zLCBsaW1pdHMsIHJlZ2xQb2xsLCBjb250ZXh0U3RhdGUsIHN0YXRzLCBjb25maWcpIHtcclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgLy8gSW5pdGlhbGl6ZSBjb25zdGFudHMgYW5kIHBhcmFtZXRlciB0YWJsZXMgaGVyZVxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICB2YXIgbWlwbWFwSGludCA9IHtcclxuICAgIFwiZG9uJ3QgY2FyZVwiOiBHTF9ET05UX0NBUkUsXHJcbiAgICAnZG9udCBjYXJlJzogR0xfRE9OVF9DQVJFLFxyXG4gICAgJ25pY2UnOiBHTF9OSUNFU1QsXHJcbiAgICAnZmFzdCc6IEdMX0ZBU1RFU1RcclxuICB9O1xyXG5cclxuICB2YXIgd3JhcE1vZGVzID0ge1xyXG4gICAgJ3JlcGVhdCc6IEdMX1JFUEVBVCxcclxuICAgICdjbGFtcCc6IEdMX0NMQU1QX1RPX0VER0UkMSxcclxuICAgICdtaXJyb3InOiBHTF9NSVJST1JFRF9SRVBFQVRcclxuICB9O1xyXG5cclxuICB2YXIgbWFnRmlsdGVycyA9IHtcclxuICAgICduZWFyZXN0JzogR0xfTkVBUkVTVCQxLFxyXG4gICAgJ2xpbmVhcic6IEdMX0xJTkVBUlxyXG4gIH07XHJcblxyXG4gIHZhciBtaW5GaWx0ZXJzID0gZXh0ZW5kKHtcclxuICAgICdtaXBtYXAnOiBHTF9MSU5FQVJfTUlQTUFQX0xJTkVBUiQxLFxyXG4gICAgJ25lYXJlc3QgbWlwbWFwIG5lYXJlc3QnOiBHTF9ORUFSRVNUX01JUE1BUF9ORUFSRVNUJDEsXHJcbiAgICAnbGluZWFyIG1pcG1hcCBuZWFyZXN0JzogR0xfTElORUFSX01JUE1BUF9ORUFSRVNUJDEsXHJcbiAgICAnbmVhcmVzdCBtaXBtYXAgbGluZWFyJzogR0xfTkVBUkVTVF9NSVBNQVBfTElORUFSJDEsXHJcbiAgICAnbGluZWFyIG1pcG1hcCBsaW5lYXInOiBHTF9MSU5FQVJfTUlQTUFQX0xJTkVBUiQxXHJcbiAgfSwgbWFnRmlsdGVycyk7XHJcblxyXG4gIHZhciBjb2xvclNwYWNlID0ge1xyXG4gICAgJ25vbmUnOiAwLFxyXG4gICAgJ2Jyb3dzZXInOiBHTF9CUk9XU0VSX0RFRkFVTFRfV0VCR0xcclxuICB9O1xyXG5cclxuICB2YXIgdGV4dHVyZVR5cGVzID0ge1xyXG4gICAgJ3VpbnQ4JzogR0xfVU5TSUdORURfQllURSQ1LFxyXG4gICAgJ3JnYmE0JzogR0xfVU5TSUdORURfU0hPUlRfNF80XzRfNCQxLFxyXG4gICAgJ3JnYjU2NSc6IEdMX1VOU0lHTkVEX1NIT1JUXzVfNl81JDEsXHJcbiAgICAncmdiNSBhMSc6IEdMX1VOU0lHTkVEX1NIT1JUXzVfNV81XzEkMVxyXG4gIH07XHJcblxyXG4gIHZhciB0ZXh0dXJlRm9ybWF0cyA9IHtcclxuICAgICdhbHBoYSc6IEdMX0FMUEhBLFxyXG4gICAgJ2x1bWluYW5jZSc6IEdMX0xVTUlOQU5DRSxcclxuICAgICdsdW1pbmFuY2UgYWxwaGEnOiBHTF9MVU1JTkFOQ0VfQUxQSEEsXHJcbiAgICAncmdiJzogR0xfUkdCLFxyXG4gICAgJ3JnYmEnOiBHTF9SR0JBJDEsXHJcbiAgICAncmdiYTQnOiBHTF9SR0JBNCxcclxuICAgICdyZ2I1IGExJzogR0xfUkdCNV9BMSxcclxuICAgICdyZ2I1NjUnOiBHTF9SR0I1NjVcclxuICB9O1xyXG5cclxuICB2YXIgY29tcHJlc3NlZFRleHR1cmVGb3JtYXRzID0ge307XHJcblxyXG4gIGlmIChleHRlbnNpb25zLmV4dF9zcmdiKSB7XHJcbiAgICB0ZXh0dXJlRm9ybWF0cy5zcmdiID0gR0xfU1JHQl9FWFQ7XHJcbiAgICB0ZXh0dXJlRm9ybWF0cy5zcmdiYSA9IEdMX1NSR0JfQUxQSEFfRVhUO1xyXG4gIH1cclxuXHJcbiAgaWYgKGV4dGVuc2lvbnMub2VzX3RleHR1cmVfZmxvYXQpIHtcclxuICAgIHRleHR1cmVUeXBlcy5mbG9hdDMyID0gdGV4dHVyZVR5cGVzLmZsb2F0ID0gR0xfRkxPQVQkNDtcclxuICB9XHJcblxyXG4gIGlmIChleHRlbnNpb25zLm9lc190ZXh0dXJlX2hhbGZfZmxvYXQpIHtcclxuICAgIHRleHR1cmVUeXBlc1snZmxvYXQxNiddID0gdGV4dHVyZVR5cGVzWydoYWxmIGZsb2F0J10gPSBHTF9IQUxGX0ZMT0FUX09FUyQxO1xyXG4gIH1cclxuXHJcbiAgaWYgKGV4dGVuc2lvbnMud2ViZ2xfZGVwdGhfdGV4dHVyZSkge1xyXG4gICAgZXh0ZW5kKHRleHR1cmVGb3JtYXRzLCB7XHJcbiAgICAgICdkZXB0aCc6IEdMX0RFUFRIX0NPTVBPTkVOVCxcclxuICAgICAgJ2RlcHRoIHN0ZW5jaWwnOiBHTF9ERVBUSF9TVEVOQ0lMXHJcbiAgICB9KTtcclxuXHJcbiAgICBleHRlbmQodGV4dHVyZVR5cGVzLCB7XHJcbiAgICAgICd1aW50MTYnOiBHTF9VTlNJR05FRF9TSE9SVCQzLFxyXG4gICAgICAndWludDMyJzogR0xfVU5TSUdORURfSU5UJDMsXHJcbiAgICAgICdkZXB0aCBzdGVuY2lsJzogR0xfVU5TSUdORURfSU5UXzI0XzhfV0VCR0wkMVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBpZiAoZXh0ZW5zaW9ucy53ZWJnbF9jb21wcmVzc2VkX3RleHR1cmVfczN0Yykge1xyXG4gICAgZXh0ZW5kKGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cywge1xyXG4gICAgICAncmdiIHMzdGMgZHh0MSc6IEdMX0NPTVBSRVNTRURfUkdCX1MzVENfRFhUMV9FWFQsXHJcbiAgICAgICdyZ2JhIHMzdGMgZHh0MSc6IEdMX0NPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDFfRVhULFxyXG4gICAgICAncmdiYSBzM3RjIGR4dDMnOiBHTF9DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQzX0VYVCxcclxuICAgICAgJ3JnYmEgczN0YyBkeHQ1JzogR0xfQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUNV9FWFRcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgaWYgKGV4dGVuc2lvbnMud2ViZ2xfY29tcHJlc3NlZF90ZXh0dXJlX2F0Yykge1xyXG4gICAgZXh0ZW5kKGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cywge1xyXG4gICAgICAncmdiIGF0Yyc6IEdMX0NPTVBSRVNTRURfUkdCX0FUQ19XRUJHTCxcclxuICAgICAgJ3JnYmEgYXRjIGV4cGxpY2l0IGFscGhhJzogR0xfQ09NUFJFU1NFRF9SR0JBX0FUQ19FWFBMSUNJVF9BTFBIQV9XRUJHTCxcclxuICAgICAgJ3JnYmEgYXRjIGludGVycG9sYXRlZCBhbHBoYSc6IEdMX0NPTVBSRVNTRURfUkdCQV9BVENfSU5URVJQT0xBVEVEX0FMUEhBX1dFQkdMXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGlmIChleHRlbnNpb25zLndlYmdsX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0Yykge1xyXG4gICAgZXh0ZW5kKGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cywge1xyXG4gICAgICAncmdiIHB2cnRjIDRicHB2MSc6IEdMX0NPTVBSRVNTRURfUkdCX1BWUlRDXzRCUFBWMV9JTUcsXHJcbiAgICAgICdyZ2IgcHZydGMgMmJwcHYxJzogR0xfQ09NUFJFU1NFRF9SR0JfUFZSVENfMkJQUFYxX0lNRyxcclxuICAgICAgJ3JnYmEgcHZydGMgNGJwcHYxJzogR0xfQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzRCUFBWMV9JTUcsXHJcbiAgICAgICdyZ2JhIHB2cnRjIDJicHB2MSc6IEdMX0NPTVBSRVNTRURfUkdCQV9QVlJUQ18yQlBQVjFfSU1HXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGlmIChleHRlbnNpb25zLndlYmdsX2NvbXByZXNzZWRfdGV4dHVyZV9ldGMxKSB7XHJcbiAgICBjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHNbJ3JnYiBldGMxJ10gPSBHTF9DT01QUkVTU0VEX1JHQl9FVEMxX1dFQkdMO1xyXG4gIH1cclxuXHJcbiAgLy8gQ29weSBvdmVyIGFsbCB0ZXh0dXJlIGZvcm1hdHNcclxuICB2YXIgc3VwcG9ydGVkQ29tcHJlc3NlZEZvcm1hdHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChcclxuICAgIGdsLmdldFBhcmFtZXRlcihHTF9DT01QUkVTU0VEX1RFWFRVUkVfRk9STUFUUykpO1xyXG4gIE9iamVjdC5rZXlzKGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgdmFyIGZvcm1hdCA9IGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0c1tuYW1lXTtcclxuICAgIGlmIChzdXBwb3J0ZWRDb21wcmVzc2VkRm9ybWF0cy5pbmRleE9mKGZvcm1hdCkgPj0gMCkge1xyXG4gICAgICB0ZXh0dXJlRm9ybWF0c1tuYW1lXSA9IGZvcm1hdDtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgdmFyIHN1cHBvcnRlZEZvcm1hdHMgPSBPYmplY3Qua2V5cyh0ZXh0dXJlRm9ybWF0cyk7XHJcbiAgbGltaXRzLnRleHR1cmVGb3JtYXRzID0gc3VwcG9ydGVkRm9ybWF0cztcclxuXHJcbiAgLy8gYXNzb2NpYXRlIHdpdGggZXZlcnkgZm9ybWF0IHN0cmluZyBpdHNcclxuICAvLyBjb3JyZXNwb25kaW5nIEdMLXZhbHVlLlxyXG4gIHZhciB0ZXh0dXJlRm9ybWF0c0ludmVydCA9IFtdO1xyXG4gIE9iamVjdC5rZXlzKHRleHR1cmVGb3JtYXRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgIHZhciB2YWwgPSB0ZXh0dXJlRm9ybWF0c1trZXldO1xyXG4gICAgdGV4dHVyZUZvcm1hdHNJbnZlcnRbdmFsXSA9IGtleTtcclxuICB9KTtcclxuXHJcbiAgLy8gYXNzb2NpYXRlIHdpdGggZXZlcnkgdHlwZSBzdHJpbmcgaXRzXHJcbiAgLy8gY29ycmVzcG9uZGluZyBHTC12YWx1ZS5cclxuICB2YXIgdGV4dHVyZVR5cGVzSW52ZXJ0ID0gW107XHJcbiAgT2JqZWN0LmtleXModGV4dHVyZVR5cGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgIHZhciB2YWwgPSB0ZXh0dXJlVHlwZXNba2V5XTtcclxuICAgIHRleHR1cmVUeXBlc0ludmVydFt2YWxdID0ga2V5O1xyXG4gIH0pO1xyXG5cclxuICB2YXIgbWFnRmlsdGVyc0ludmVydCA9IFtdO1xyXG4gIE9iamVjdC5rZXlzKG1hZ0ZpbHRlcnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gICAgdmFyIHZhbCA9IG1hZ0ZpbHRlcnNba2V5XTtcclxuICAgIG1hZ0ZpbHRlcnNJbnZlcnRbdmFsXSA9IGtleTtcclxuICB9KTtcclxuXHJcbiAgdmFyIG1pbkZpbHRlcnNJbnZlcnQgPSBbXTtcclxuICBPYmplY3Qua2V5cyhtaW5GaWx0ZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgIHZhciB2YWwgPSBtaW5GaWx0ZXJzW2tleV07XHJcbiAgICBtaW5GaWx0ZXJzSW52ZXJ0W3ZhbF0gPSBrZXk7XHJcbiAgfSk7XHJcblxyXG4gIHZhciB3cmFwTW9kZXNJbnZlcnQgPSBbXTtcclxuICBPYmplY3Qua2V5cyh3cmFwTW9kZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gICAgdmFyIHZhbCA9IHdyYXBNb2Rlc1trZXldO1xyXG4gICAgd3JhcE1vZGVzSW52ZXJ0W3ZhbF0gPSBrZXk7XHJcbiAgfSk7XHJcblxyXG4gIC8vIGNvbG9yRm9ybWF0c1tdIGdpdmVzIHRoZSBmb3JtYXQgKGNoYW5uZWxzKSBhc3NvY2lhdGVkIHRvIGFuXHJcbiAgLy8gaW50ZXJuYWxmb3JtYXRcclxuICB2YXIgY29sb3JGb3JtYXRzID0gc3VwcG9ydGVkRm9ybWF0cy5yZWR1Y2UoZnVuY3Rpb24gKGNvbG9yLCBrZXkpIHtcclxuICAgIHZhciBnbGVudW0gPSB0ZXh0dXJlRm9ybWF0c1trZXldO1xyXG4gICAgaWYgKGdsZW51bSA9PT0gR0xfTFVNSU5BTkNFIHx8XHJcbiAgICAgICAgZ2xlbnVtID09PSBHTF9BTFBIQSB8fFxyXG4gICAgICAgIGdsZW51bSA9PT0gR0xfTFVNSU5BTkNFIHx8XHJcbiAgICAgICAgZ2xlbnVtID09PSBHTF9MVU1JTkFOQ0VfQUxQSEEgfHxcclxuICAgICAgICBnbGVudW0gPT09IEdMX0RFUFRIX0NPTVBPTkVOVCB8fFxyXG4gICAgICAgIGdsZW51bSA9PT0gR0xfREVQVEhfU1RFTkNJTCkge1xyXG4gICAgICBjb2xvcltnbGVudW1dID0gZ2xlbnVtO1xyXG4gICAgfSBlbHNlIGlmIChnbGVudW0gPT09IEdMX1JHQjVfQTEgfHwga2V5LmluZGV4T2YoJ3JnYmEnKSA+PSAwKSB7XHJcbiAgICAgIGNvbG9yW2dsZW51bV0gPSBHTF9SR0JBJDE7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb2xvcltnbGVudW1dID0gR0xfUkdCO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbG9yXHJcbiAgfSwge30pO1xyXG5cclxuICBmdW5jdGlvbiBUZXhGbGFncyAoKSB7XHJcbiAgICAvLyBmb3JtYXQgaW5mb1xyXG4gICAgdGhpcy5pbnRlcm5hbGZvcm1hdCA9IEdMX1JHQkEkMTtcclxuICAgIHRoaXMuZm9ybWF0ID0gR0xfUkdCQSQxO1xyXG4gICAgdGhpcy50eXBlID0gR0xfVU5TSUdORURfQllURSQ1O1xyXG4gICAgdGhpcy5jb21wcmVzc2VkID0gZmFsc2U7XHJcblxyXG4gICAgLy8gcGl4ZWwgc3RvcmFnZVxyXG4gICAgdGhpcy5wcmVtdWx0aXBseUFscGhhID0gZmFsc2U7XHJcbiAgICB0aGlzLmZsaXBZID0gZmFsc2U7XHJcbiAgICB0aGlzLnVucGFja0FsaWdubWVudCA9IDE7XHJcbiAgICB0aGlzLmNvbG9yU3BhY2UgPSBHTF9CUk9XU0VSX0RFRkFVTFRfV0VCR0w7XHJcblxyXG4gICAgLy8gc2hhcGUgaW5mb1xyXG4gICAgdGhpcy53aWR0aCA9IDA7XHJcbiAgICB0aGlzLmhlaWdodCA9IDA7XHJcbiAgICB0aGlzLmNoYW5uZWxzID0gMDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNvcHlGbGFncyAocmVzdWx0LCBvdGhlcikge1xyXG4gICAgcmVzdWx0LmludGVybmFsZm9ybWF0ID0gb3RoZXIuaW50ZXJuYWxmb3JtYXQ7XHJcbiAgICByZXN1bHQuZm9ybWF0ID0gb3RoZXIuZm9ybWF0O1xyXG4gICAgcmVzdWx0LnR5cGUgPSBvdGhlci50eXBlO1xyXG4gICAgcmVzdWx0LmNvbXByZXNzZWQgPSBvdGhlci5jb21wcmVzc2VkO1xyXG5cclxuICAgIHJlc3VsdC5wcmVtdWx0aXBseUFscGhhID0gb3RoZXIucHJlbXVsdGlwbHlBbHBoYTtcclxuICAgIHJlc3VsdC5mbGlwWSA9IG90aGVyLmZsaXBZO1xyXG4gICAgcmVzdWx0LnVucGFja0FsaWdubWVudCA9IG90aGVyLnVucGFja0FsaWdubWVudDtcclxuICAgIHJlc3VsdC5jb2xvclNwYWNlID0gb3RoZXIuY29sb3JTcGFjZTtcclxuXHJcbiAgICByZXN1bHQud2lkdGggPSBvdGhlci53aWR0aDtcclxuICAgIHJlc3VsdC5oZWlnaHQgPSBvdGhlci5oZWlnaHQ7XHJcbiAgICByZXN1bHQuY2hhbm5lbHMgPSBvdGhlci5jaGFubmVscztcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHBhcnNlRmxhZ3MgKGZsYWdzLCBvcHRpb25zKSB7XHJcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnIHx8ICFvcHRpb25zKSB7XHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG5cclxuICAgIGlmICgncHJlbXVsdGlwbHlBbHBoYScgaW4gb3B0aW9ucykge1xyXG4gICAgICBjaGVjayQxLnR5cGUob3B0aW9ucy5wcmVtdWx0aXBseUFscGhhLCAnYm9vbGVhbicsXHJcbiAgICAgICAgJ2ludmFsaWQgcHJlbXVsdGlwbHlBbHBoYScpO1xyXG4gICAgICBmbGFncy5wcmVtdWx0aXBseUFscGhhID0gb3B0aW9ucy5wcmVtdWx0aXBseUFscGhhO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICgnZmxpcFknIGluIG9wdGlvbnMpIHtcclxuICAgICAgY2hlY2skMS50eXBlKG9wdGlvbnMuZmxpcFksICdib29sZWFuJyxcclxuICAgICAgICAnaW52YWxpZCB0ZXh0dXJlIGZsaXAnKTtcclxuICAgICAgZmxhZ3MuZmxpcFkgPSBvcHRpb25zLmZsaXBZO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICgnYWxpZ25tZW50JyBpbiBvcHRpb25zKSB7XHJcbiAgICAgIGNoZWNrJDEub25lT2Yob3B0aW9ucy5hbGlnbm1lbnQsIFsxLCAyLCA0LCA4XSxcclxuICAgICAgICAnaW52YWxpZCB0ZXh0dXJlIHVucGFjayBhbGlnbm1lbnQnKTtcclxuICAgICAgZmxhZ3MudW5wYWNrQWxpZ25tZW50ID0gb3B0aW9ucy5hbGlnbm1lbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCdjb2xvclNwYWNlJyBpbiBvcHRpb25zKSB7XHJcbiAgICAgIGNoZWNrJDEucGFyYW1ldGVyKG9wdGlvbnMuY29sb3JTcGFjZSwgY29sb3JTcGFjZSxcclxuICAgICAgICAnaW52YWxpZCBjb2xvclNwYWNlJyk7XHJcbiAgICAgIGZsYWdzLmNvbG9yU3BhY2UgPSBjb2xvclNwYWNlW29wdGlvbnMuY29sb3JTcGFjZV07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCd0eXBlJyBpbiBvcHRpb25zKSB7XHJcbiAgICAgIHZhciB0eXBlID0gb3B0aW9ucy50eXBlO1xyXG4gICAgICBjaGVjayQxKGV4dGVuc2lvbnMub2VzX3RleHR1cmVfZmxvYXQgfHxcclxuICAgICAgICAhKHR5cGUgPT09ICdmbG9hdCcgfHwgdHlwZSA9PT0gJ2Zsb2F0MzInKSxcclxuICAgICAgICAneW91IG11c3QgZW5hYmxlIHRoZSBPRVNfdGV4dHVyZV9mbG9hdCBleHRlbnNpb24gaW4gb3JkZXIgdG8gdXNlIGZsb2F0aW5nIHBvaW50IHRleHR1cmVzLicpO1xyXG4gICAgICBjaGVjayQxKGV4dGVuc2lvbnMub2VzX3RleHR1cmVfaGFsZl9mbG9hdCB8fFxyXG4gICAgICAgICEodHlwZSA9PT0gJ2hhbGYgZmxvYXQnIHx8IHR5cGUgPT09ICdmbG9hdDE2JyksXHJcbiAgICAgICAgJ3lvdSBtdXN0IGVuYWJsZSB0aGUgT0VTX3RleHR1cmVfaGFsZl9mbG9hdCBleHRlbnNpb24gaW4gb3JkZXIgdG8gdXNlIDE2LWJpdCBmbG9hdGluZyBwb2ludCB0ZXh0dXJlcy4nKTtcclxuICAgICAgY2hlY2skMShleHRlbnNpb25zLndlYmdsX2RlcHRoX3RleHR1cmUgfHxcclxuICAgICAgICAhKHR5cGUgPT09ICd1aW50MTYnIHx8IHR5cGUgPT09ICd1aW50MzInIHx8IHR5cGUgPT09ICdkZXB0aCBzdGVuY2lsJyksXHJcbiAgICAgICAgJ3lvdSBtdXN0IGVuYWJsZSB0aGUgV0VCR0xfZGVwdGhfdGV4dHVyZSBleHRlbnNpb24gaW4gb3JkZXIgdG8gdXNlIGRlcHRoL3N0ZW5jaWwgdGV4dHVyZXMuJyk7XHJcbiAgICAgIGNoZWNrJDEucGFyYW1ldGVyKHR5cGUsIHRleHR1cmVUeXBlcyxcclxuICAgICAgICAnaW52YWxpZCB0ZXh0dXJlIHR5cGUnKTtcclxuICAgICAgZmxhZ3MudHlwZSA9IHRleHR1cmVUeXBlc1t0eXBlXTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgdyA9IGZsYWdzLndpZHRoO1xyXG4gICAgdmFyIGggPSBmbGFncy5oZWlnaHQ7XHJcbiAgICB2YXIgYyA9IGZsYWdzLmNoYW5uZWxzO1xyXG4gICAgdmFyIGhhc0NoYW5uZWxzID0gZmFsc2U7XHJcbiAgICBpZiAoJ3NoYXBlJyBpbiBvcHRpb25zKSB7XHJcbiAgICAgIGNoZWNrJDEoQXJyYXkuaXNBcnJheShvcHRpb25zLnNoYXBlKSAmJiBvcHRpb25zLnNoYXBlLmxlbmd0aCA+PSAyLFxyXG4gICAgICAgICdzaGFwZSBtdXN0IGJlIGFuIGFycmF5Jyk7XHJcbiAgICAgIHcgPSBvcHRpb25zLnNoYXBlWzBdO1xyXG4gICAgICBoID0gb3B0aW9ucy5zaGFwZVsxXTtcclxuICAgICAgaWYgKG9wdGlvbnMuc2hhcGUubGVuZ3RoID09PSAzKSB7XHJcbiAgICAgICAgYyA9IG9wdGlvbnMuc2hhcGVbMl07XHJcbiAgICAgICAgY2hlY2skMShjID4gMCAmJiBjIDw9IDQsICdpbnZhbGlkIG51bWJlciBvZiBjaGFubmVscycpO1xyXG4gICAgICAgIGhhc0NoYW5uZWxzID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICBjaGVjayQxKHcgPj0gMCAmJiB3IDw9IGxpbWl0cy5tYXhUZXh0dXJlU2l6ZSwgJ2ludmFsaWQgd2lkdGgnKTtcclxuICAgICAgY2hlY2skMShoID49IDAgJiYgaCA8PSBsaW1pdHMubWF4VGV4dHVyZVNpemUsICdpbnZhbGlkIGhlaWdodCcpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKCdyYWRpdXMnIGluIG9wdGlvbnMpIHtcclxuICAgICAgICB3ID0gaCA9IG9wdGlvbnMucmFkaXVzO1xyXG4gICAgICAgIGNoZWNrJDEodyA+PSAwICYmIHcgPD0gbGltaXRzLm1heFRleHR1cmVTaXplLCAnaW52YWxpZCByYWRpdXMnKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoJ3dpZHRoJyBpbiBvcHRpb25zKSB7XHJcbiAgICAgICAgdyA9IG9wdGlvbnMud2lkdGg7XHJcbiAgICAgICAgY2hlY2skMSh3ID49IDAgJiYgdyA8PSBsaW1pdHMubWF4VGV4dHVyZVNpemUsICdpbnZhbGlkIHdpZHRoJyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCdoZWlnaHQnIGluIG9wdGlvbnMpIHtcclxuICAgICAgICBoID0gb3B0aW9ucy5oZWlnaHQ7XHJcbiAgICAgICAgY2hlY2skMShoID49IDAgJiYgaCA8PSBsaW1pdHMubWF4VGV4dHVyZVNpemUsICdpbnZhbGlkIGhlaWdodCcpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICgnY2hhbm5lbHMnIGluIG9wdGlvbnMpIHtcclxuICAgICAgICBjID0gb3B0aW9ucy5jaGFubmVscztcclxuICAgICAgICBjaGVjayQxKGMgPiAwICYmIGMgPD0gNCwgJ2ludmFsaWQgbnVtYmVyIG9mIGNoYW5uZWxzJyk7XHJcbiAgICAgICAgaGFzQ2hhbm5lbHMgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBmbGFncy53aWR0aCA9IHcgfCAwO1xyXG4gICAgZmxhZ3MuaGVpZ2h0ID0gaCB8IDA7XHJcbiAgICBmbGFncy5jaGFubmVscyA9IGMgfCAwO1xyXG5cclxuICAgIHZhciBoYXNGb3JtYXQgPSBmYWxzZTtcclxuICAgIGlmICgnZm9ybWF0JyBpbiBvcHRpb25zKSB7XHJcbiAgICAgIHZhciBmb3JtYXRTdHIgPSBvcHRpb25zLmZvcm1hdDtcclxuICAgICAgY2hlY2skMShleHRlbnNpb25zLndlYmdsX2RlcHRoX3RleHR1cmUgfHxcclxuICAgICAgICAhKGZvcm1hdFN0ciA9PT0gJ2RlcHRoJyB8fCBmb3JtYXRTdHIgPT09ICdkZXB0aCBzdGVuY2lsJyksXHJcbiAgICAgICAgJ3lvdSBtdXN0IGVuYWJsZSB0aGUgV0VCR0xfZGVwdGhfdGV4dHVyZSBleHRlbnNpb24gaW4gb3JkZXIgdG8gdXNlIGRlcHRoL3N0ZW5jaWwgdGV4dHVyZXMuJyk7XHJcbiAgICAgIGNoZWNrJDEucGFyYW1ldGVyKGZvcm1hdFN0ciwgdGV4dHVyZUZvcm1hdHMsXHJcbiAgICAgICAgJ2ludmFsaWQgdGV4dHVyZSBmb3JtYXQnKTtcclxuICAgICAgdmFyIGludGVybmFsZm9ybWF0ID0gZmxhZ3MuaW50ZXJuYWxmb3JtYXQgPSB0ZXh0dXJlRm9ybWF0c1tmb3JtYXRTdHJdO1xyXG4gICAgICBmbGFncy5mb3JtYXQgPSBjb2xvckZvcm1hdHNbaW50ZXJuYWxmb3JtYXRdO1xyXG4gICAgICBpZiAoZm9ybWF0U3RyIGluIHRleHR1cmVUeXBlcykge1xyXG4gICAgICAgIGlmICghKCd0eXBlJyBpbiBvcHRpb25zKSkge1xyXG4gICAgICAgICAgZmxhZ3MudHlwZSA9IHRleHR1cmVUeXBlc1tmb3JtYXRTdHJdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoZm9ybWF0U3RyIGluIGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cykge1xyXG4gICAgICAgIGZsYWdzLmNvbXByZXNzZWQgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGhhc0Zvcm1hdCA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVjb25jaWxlIGNoYW5uZWxzIGFuZCBmb3JtYXRcclxuICAgIGlmICghaGFzQ2hhbm5lbHMgJiYgaGFzRm9ybWF0KSB7XHJcbiAgICAgIGZsYWdzLmNoYW5uZWxzID0gRk9STUFUX0NIQU5ORUxTW2ZsYWdzLmZvcm1hdF07XHJcbiAgICB9IGVsc2UgaWYgKGhhc0NoYW5uZWxzICYmICFoYXNGb3JtYXQpIHtcclxuICAgICAgaWYgKGZsYWdzLmNoYW5uZWxzICE9PSBDSEFOTkVMU19GT1JNQVRbZmxhZ3MuZm9ybWF0XSkge1xyXG4gICAgICAgIGZsYWdzLmZvcm1hdCA9IGZsYWdzLmludGVybmFsZm9ybWF0ID0gQ0hBTk5FTFNfRk9STUFUW2ZsYWdzLmNoYW5uZWxzXTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChoYXNGb3JtYXQgJiYgaGFzQ2hhbm5lbHMpIHtcclxuICAgICAgY2hlY2skMShcclxuICAgICAgICBmbGFncy5jaGFubmVscyA9PT0gRk9STUFUX0NIQU5ORUxTW2ZsYWdzLmZvcm1hdF0sXHJcbiAgICAgICAgJ251bWJlciBvZiBjaGFubmVscyBpbmNvbnNpc3RlbnQgd2l0aCBzcGVjaWZpZWQgZm9ybWF0Jyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzZXRGbGFncyAoZmxhZ3MpIHtcclxuICAgIGdsLnBpeGVsU3RvcmVpKEdMX1VOUEFDS19GTElQX1lfV0VCR0wsIGZsYWdzLmZsaXBZKTtcclxuICAgIGdsLnBpeGVsU3RvcmVpKEdMX1VOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgZmxhZ3MucHJlbXVsdGlwbHlBbHBoYSk7XHJcbiAgICBnbC5waXhlbFN0b3JlaShHTF9VTlBBQ0tfQ09MT1JTUEFDRV9DT05WRVJTSU9OX1dFQkdMLCBmbGFncy5jb2xvclNwYWNlKTtcclxuICAgIGdsLnBpeGVsU3RvcmVpKEdMX1VOUEFDS19BTElHTk1FTlQsIGZsYWdzLnVucGFja0FsaWdubWVudCk7XHJcbiAgfVxyXG5cclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgLy8gVGV4IGltYWdlIGRhdGFcclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgZnVuY3Rpb24gVGV4SW1hZ2UgKCkge1xyXG4gICAgVGV4RmxhZ3MuY2FsbCh0aGlzKTtcclxuXHJcbiAgICB0aGlzLnhPZmZzZXQgPSAwO1xyXG4gICAgdGhpcy55T2Zmc2V0ID0gMDtcclxuXHJcbiAgICAvLyBkYXRhXHJcbiAgICB0aGlzLmRhdGEgPSBudWxsO1xyXG4gICAgdGhpcy5uZWVkc0ZyZWUgPSBmYWxzZTtcclxuXHJcbiAgICAvLyBodG1sIGVsZW1lbnRcclxuICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XHJcblxyXG4gICAgLy8gY29weVRleEltYWdlIGluZm9cclxuICAgIHRoaXMubmVlZHNDb3B5ID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBwYXJzZUltYWdlIChpbWFnZSwgb3B0aW9ucykge1xyXG4gICAgdmFyIGRhdGEgPSBudWxsO1xyXG4gICAgaWYgKGlzUGl4ZWxEYXRhKG9wdGlvbnMpKSB7XHJcbiAgICAgIGRhdGEgPSBvcHRpb25zO1xyXG4gICAgfSBlbHNlIGlmIChvcHRpb25zKSB7XHJcbiAgICAgIGNoZWNrJDEudHlwZShvcHRpb25zLCAnb2JqZWN0JywgJ2ludmFsaWQgcGl4ZWwgZGF0YSB0eXBlJyk7XHJcbiAgICAgIHBhcnNlRmxhZ3MoaW1hZ2UsIG9wdGlvbnMpO1xyXG4gICAgICBpZiAoJ3gnIGluIG9wdGlvbnMpIHtcclxuICAgICAgICBpbWFnZS54T2Zmc2V0ID0gb3B0aW9ucy54IHwgMDtcclxuICAgICAgfVxyXG4gICAgICBpZiAoJ3knIGluIG9wdGlvbnMpIHtcclxuICAgICAgICBpbWFnZS55T2Zmc2V0ID0gb3B0aW9ucy55IHwgMDtcclxuICAgICAgfVxyXG4gICAgICBpZiAoaXNQaXhlbERhdGEob3B0aW9ucy5kYXRhKSkge1xyXG4gICAgICAgIGRhdGEgPSBvcHRpb25zLmRhdGE7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjaGVjayQxKFxyXG4gICAgICAhaW1hZ2UuY29tcHJlc3NlZCB8fFxyXG4gICAgICBkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSxcclxuICAgICAgJ2NvbXByZXNzZWQgdGV4dHVyZSBkYXRhIG11c3QgYmUgc3RvcmVkIGluIGEgdWludDhhcnJheScpO1xyXG5cclxuICAgIGlmIChvcHRpb25zLmNvcHkpIHtcclxuICAgICAgY2hlY2skMSghZGF0YSwgJ2NhbiBub3Qgc3BlY2lmeSBjb3B5IGFuZCBkYXRhIGZpZWxkIGZvciB0aGUgc2FtZSB0ZXh0dXJlJyk7XHJcbiAgICAgIHZhciB2aWV3VyA9IGNvbnRleHRTdGF0ZS52aWV3cG9ydFdpZHRoO1xyXG4gICAgICB2YXIgdmlld0ggPSBjb250ZXh0U3RhdGUudmlld3BvcnRIZWlnaHQ7XHJcbiAgICAgIGltYWdlLndpZHRoID0gaW1hZ2Uud2lkdGggfHwgKHZpZXdXIC0gaW1hZ2UueE9mZnNldCk7XHJcbiAgICAgIGltYWdlLmhlaWdodCA9IGltYWdlLmhlaWdodCB8fCAodmlld0ggLSBpbWFnZS55T2Zmc2V0KTtcclxuICAgICAgaW1hZ2UubmVlZHNDb3B5ID0gdHJ1ZTtcclxuICAgICAgY2hlY2skMShpbWFnZS54T2Zmc2V0ID49IDAgJiYgaW1hZ2UueE9mZnNldCA8IHZpZXdXICYmXHJcbiAgICAgICAgICAgIGltYWdlLnlPZmZzZXQgPj0gMCAmJiBpbWFnZS55T2Zmc2V0IDwgdmlld0ggJiZcclxuICAgICAgICAgICAgaW1hZ2Uud2lkdGggPiAwICYmIGltYWdlLndpZHRoIDw9IHZpZXdXICYmXHJcbiAgICAgICAgICAgIGltYWdlLmhlaWdodCA+IDAgJiYgaW1hZ2UuaGVpZ2h0IDw9IHZpZXdILFxyXG4gICAgICAgICAgICAnY29weSB0ZXh0dXJlIHJlYWQgb3V0IG9mIGJvdW5kcycpO1xyXG4gICAgfSBlbHNlIGlmICghZGF0YSkge1xyXG4gICAgICBpbWFnZS53aWR0aCA9IGltYWdlLndpZHRoIHx8IDE7XHJcbiAgICAgIGltYWdlLmhlaWdodCA9IGltYWdlLmhlaWdodCB8fCAxO1xyXG4gICAgICBpbWFnZS5jaGFubmVscyA9IGltYWdlLmNoYW5uZWxzIHx8IDQ7XHJcbiAgICB9IGVsc2UgaWYgKGlzVHlwZWRBcnJheShkYXRhKSkge1xyXG4gICAgICBpbWFnZS5jaGFubmVscyA9IGltYWdlLmNoYW5uZWxzIHx8IDQ7XHJcbiAgICAgIGltYWdlLmRhdGEgPSBkYXRhO1xyXG4gICAgICBpZiAoISgndHlwZScgaW4gb3B0aW9ucykgJiYgaW1hZ2UudHlwZSA9PT0gR0xfVU5TSUdORURfQllURSQ1KSB7XHJcbiAgICAgICAgaW1hZ2UudHlwZSA9IHR5cGVkQXJyYXlDb2RlJDEoZGF0YSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoaXNOdW1lcmljQXJyYXkoZGF0YSkpIHtcclxuICAgICAgaW1hZ2UuY2hhbm5lbHMgPSBpbWFnZS5jaGFubmVscyB8fCA0O1xyXG4gICAgICBjb252ZXJ0RGF0YShpbWFnZSwgZGF0YSk7XHJcbiAgICAgIGltYWdlLmFsaWdubWVudCA9IDE7XHJcbiAgICAgIGltYWdlLm5lZWRzRnJlZSA9IHRydWU7XHJcbiAgICB9IGVsc2UgaWYgKGlzTkRBcnJheUxpa2UoZGF0YSkpIHtcclxuICAgICAgdmFyIGFycmF5ID0gZGF0YS5kYXRhO1xyXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpICYmIGltYWdlLnR5cGUgPT09IEdMX1VOU0lHTkVEX0JZVEUkNSkge1xyXG4gICAgICAgIGltYWdlLnR5cGUgPSB0eXBlZEFycmF5Q29kZSQxKGFycmF5KTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgc2hhcGUgPSBkYXRhLnNoYXBlO1xyXG4gICAgICB2YXIgc3RyaWRlID0gZGF0YS5zdHJpZGU7XHJcbiAgICAgIHZhciBzaGFwZVgsIHNoYXBlWSwgc2hhcGVDLCBzdHJpZGVYLCBzdHJpZGVZLCBzdHJpZGVDO1xyXG4gICAgICBpZiAoc2hhcGUubGVuZ3RoID09PSAzKSB7XHJcbiAgICAgICAgc2hhcGVDID0gc2hhcGVbMl07XHJcbiAgICAgICAgc3RyaWRlQyA9IHN0cmlkZVsyXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjaGVjayQxKHNoYXBlLmxlbmd0aCA9PT0gMiwgJ2ludmFsaWQgbmRhcnJheSBwaXhlbCBkYXRhLCBtdXN0IGJlIDIgb3IgM0QnKTtcclxuICAgICAgICBzaGFwZUMgPSAxO1xyXG4gICAgICAgIHN0cmlkZUMgPSAxO1xyXG4gICAgICB9XHJcbiAgICAgIHNoYXBlWCA9IHNoYXBlWzBdO1xyXG4gICAgICBzaGFwZVkgPSBzaGFwZVsxXTtcclxuICAgICAgc3RyaWRlWCA9IHN0cmlkZVswXTtcclxuICAgICAgc3RyaWRlWSA9IHN0cmlkZVsxXTtcclxuICAgICAgaW1hZ2UuYWxpZ25tZW50ID0gMTtcclxuICAgICAgaW1hZ2Uud2lkdGggPSBzaGFwZVg7XHJcbiAgICAgIGltYWdlLmhlaWdodCA9IHNoYXBlWTtcclxuICAgICAgaW1hZ2UuY2hhbm5lbHMgPSBzaGFwZUM7XHJcbiAgICAgIGltYWdlLmZvcm1hdCA9IGltYWdlLmludGVybmFsZm9ybWF0ID0gQ0hBTk5FTFNfRk9STUFUW3NoYXBlQ107XHJcbiAgICAgIGltYWdlLm5lZWRzRnJlZSA9IHRydWU7XHJcbiAgICAgIHRyYW5zcG9zZURhdGEoaW1hZ2UsIGFycmF5LCBzdHJpZGVYLCBzdHJpZGVZLCBzdHJpZGVDLCBkYXRhLm9mZnNldCk7XHJcbiAgICB9IGVsc2UgaWYgKGlzQ2FudmFzRWxlbWVudChkYXRhKSB8fCBpc0NvbnRleHQyRChkYXRhKSkge1xyXG4gICAgICBpZiAoaXNDYW52YXNFbGVtZW50KGRhdGEpKSB7XHJcbiAgICAgICAgaW1hZ2UuZWxlbWVudCA9IGRhdGE7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaW1hZ2UuZWxlbWVudCA9IGRhdGEuY2FudmFzO1xyXG4gICAgICB9XHJcbiAgICAgIGltYWdlLndpZHRoID0gaW1hZ2UuZWxlbWVudC53aWR0aDtcclxuICAgICAgaW1hZ2UuaGVpZ2h0ID0gaW1hZ2UuZWxlbWVudC5oZWlnaHQ7XHJcbiAgICAgIGltYWdlLmNoYW5uZWxzID0gNDtcclxuICAgIH0gZWxzZSBpZiAoaXNCaXRtYXAoZGF0YSkpIHtcclxuICAgICAgaW1hZ2UuZWxlbWVudCA9IGRhdGE7XHJcbiAgICAgIGltYWdlLndpZHRoID0gZGF0YS53aWR0aDtcclxuICAgICAgaW1hZ2UuaGVpZ2h0ID0gZGF0YS5oZWlnaHQ7XHJcbiAgICAgIGltYWdlLmNoYW5uZWxzID0gNDtcclxuICAgIH0gZWxzZSBpZiAoaXNJbWFnZUVsZW1lbnQoZGF0YSkpIHtcclxuICAgICAgaW1hZ2UuZWxlbWVudCA9IGRhdGE7XHJcbiAgICAgIGltYWdlLndpZHRoID0gZGF0YS5uYXR1cmFsV2lkdGg7XHJcbiAgICAgIGltYWdlLmhlaWdodCA9IGRhdGEubmF0dXJhbEhlaWdodDtcclxuICAgICAgaW1hZ2UuY2hhbm5lbHMgPSA0O1xyXG4gICAgfSBlbHNlIGlmIChpc1ZpZGVvRWxlbWVudChkYXRhKSkge1xyXG4gICAgICBpbWFnZS5lbGVtZW50ID0gZGF0YTtcclxuICAgICAgaW1hZ2Uud2lkdGggPSBkYXRhLnZpZGVvV2lkdGg7XHJcbiAgICAgIGltYWdlLmhlaWdodCA9IGRhdGEudmlkZW9IZWlnaHQ7XHJcbiAgICAgIGltYWdlLmNoYW5uZWxzID0gNDtcclxuICAgIH0gZWxzZSBpZiAoaXNSZWN0QXJyYXkoZGF0YSkpIHtcclxuICAgICAgdmFyIHcgPSBpbWFnZS53aWR0aCB8fCBkYXRhWzBdLmxlbmd0aDtcclxuICAgICAgdmFyIGggPSBpbWFnZS5oZWlnaHQgfHwgZGF0YS5sZW5ndGg7XHJcbiAgICAgIHZhciBjID0gaW1hZ2UuY2hhbm5lbHM7XHJcbiAgICAgIGlmIChpc0FycmF5TGlrZShkYXRhWzBdWzBdKSkge1xyXG4gICAgICAgIGMgPSBjIHx8IGRhdGFbMF1bMF0ubGVuZ3RoO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGMgPSBjIHx8IDE7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGFycmF5U2hhcGUgPSBmbGF0dGVuVXRpbHMuc2hhcGUoZGF0YSk7XHJcbiAgICAgIHZhciBuID0gMTtcclxuICAgICAgZm9yICh2YXIgZGQgPSAwOyBkZCA8IGFycmF5U2hhcGUubGVuZ3RoOyArK2RkKSB7XHJcbiAgICAgICAgbiAqPSBhcnJheVNoYXBlW2RkXTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgYWxsb2NEYXRhID0gcHJlQ29udmVydChpbWFnZSwgbik7XHJcbiAgICAgIGZsYXR0ZW5VdGlscy5mbGF0dGVuKGRhdGEsIGFycmF5U2hhcGUsICcnLCBhbGxvY0RhdGEpO1xyXG4gICAgICBwb3N0Q29udmVydChpbWFnZSwgYWxsb2NEYXRhKTtcclxuICAgICAgaW1hZ2UuYWxpZ25tZW50ID0gMTtcclxuICAgICAgaW1hZ2Uud2lkdGggPSB3O1xyXG4gICAgICBpbWFnZS5oZWlnaHQgPSBoO1xyXG4gICAgICBpbWFnZS5jaGFubmVscyA9IGM7XHJcbiAgICAgIGltYWdlLmZvcm1hdCA9IGltYWdlLmludGVybmFsZm9ybWF0ID0gQ0hBTk5FTFNfRk9STUFUW2NdO1xyXG4gICAgICBpbWFnZS5uZWVkc0ZyZWUgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpbWFnZS50eXBlID09PSBHTF9GTE9BVCQ0KSB7XHJcbiAgICAgIGNoZWNrJDEobGltaXRzLmV4dGVuc2lvbnMuaW5kZXhPZignb2VzX3RleHR1cmVfZmxvYXQnKSA+PSAwLFxyXG4gICAgICAgICdvZXNfdGV4dHVyZV9mbG9hdCBleHRlbnNpb24gbm90IGVuYWJsZWQnKTtcclxuICAgIH0gZWxzZSBpZiAoaW1hZ2UudHlwZSA9PT0gR0xfSEFMRl9GTE9BVF9PRVMkMSkge1xyXG4gICAgICBjaGVjayQxKGxpbWl0cy5leHRlbnNpb25zLmluZGV4T2YoJ29lc190ZXh0dXJlX2hhbGZfZmxvYXQnKSA+PSAwLFxyXG4gICAgICAgICdvZXNfdGV4dHVyZV9oYWxmX2Zsb2F0IGV4dGVuc2lvbiBub3QgZW5hYmxlZCcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGRvIGNvbXByZXNzZWQgdGV4dHVyZSAgdmFsaWRhdGlvbiBoZXJlLlxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2V0SW1hZ2UgKGluZm8sIHRhcmdldCwgbWlwbGV2ZWwpIHtcclxuICAgIHZhciBlbGVtZW50ID0gaW5mby5lbGVtZW50O1xyXG4gICAgdmFyIGRhdGEgPSBpbmZvLmRhdGE7XHJcbiAgICB2YXIgaW50ZXJuYWxmb3JtYXQgPSBpbmZvLmludGVybmFsZm9ybWF0O1xyXG4gICAgdmFyIGZvcm1hdCA9IGluZm8uZm9ybWF0O1xyXG4gICAgdmFyIHR5cGUgPSBpbmZvLnR5cGU7XHJcbiAgICB2YXIgd2lkdGggPSBpbmZvLndpZHRoO1xyXG4gICAgdmFyIGhlaWdodCA9IGluZm8uaGVpZ2h0O1xyXG4gICAgdmFyIGNoYW5uZWxzID0gaW5mby5jaGFubmVscztcclxuXHJcbiAgICBzZXRGbGFncyhpbmZvKTtcclxuXHJcbiAgICBpZiAoZWxlbWVudCkge1xyXG4gICAgICBnbC50ZXhJbWFnZTJEKHRhcmdldCwgbWlwbGV2ZWwsIGZvcm1hdCwgZm9ybWF0LCB0eXBlLCBlbGVtZW50KTtcclxuICAgIH0gZWxzZSBpZiAoaW5mby5jb21wcmVzc2VkKSB7XHJcbiAgICAgIGdsLmNvbXByZXNzZWRUZXhJbWFnZTJEKHRhcmdldCwgbWlwbGV2ZWwsIGludGVybmFsZm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCAwLCBkYXRhKTtcclxuICAgIH0gZWxzZSBpZiAoaW5mby5uZWVkc0NvcHkpIHtcclxuICAgICAgcmVnbFBvbGwoKTtcclxuICAgICAgZ2wuY29weVRleEltYWdlMkQoXHJcbiAgICAgICAgdGFyZ2V0LCBtaXBsZXZlbCwgZm9ybWF0LCBpbmZvLnhPZmZzZXQsIGluZm8ueU9mZnNldCwgd2lkdGgsIGhlaWdodCwgMCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YXIgbnVsbERhdGEgPSAhZGF0YTtcclxuICAgICAgaWYgKG51bGxEYXRhKSB7XHJcbiAgICAgICAgZGF0YSA9IHBvb2wuemVyby5hbGxvY1R5cGUodHlwZSwgd2lkdGggKiBoZWlnaHQgKiBjaGFubmVscyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGdsLnRleEltYWdlMkQodGFyZ2V0LCBtaXBsZXZlbCwgZm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCAwLCBmb3JtYXQsIHR5cGUsIGRhdGEpO1xyXG5cclxuICAgICAgaWYgKG51bGxEYXRhICYmIGRhdGEpIHtcclxuICAgICAgICBwb29sLnplcm8uZnJlZVR5cGUoZGF0YSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHNldFN1YkltYWdlIChpbmZvLCB0YXJnZXQsIHgsIHksIG1pcGxldmVsKSB7XHJcbiAgICB2YXIgZWxlbWVudCA9IGluZm8uZWxlbWVudDtcclxuICAgIHZhciBkYXRhID0gaW5mby5kYXRhO1xyXG4gICAgdmFyIGludGVybmFsZm9ybWF0ID0gaW5mby5pbnRlcm5hbGZvcm1hdDtcclxuICAgIHZhciBmb3JtYXQgPSBpbmZvLmZvcm1hdDtcclxuICAgIHZhciB0eXBlID0gaW5mby50eXBlO1xyXG4gICAgdmFyIHdpZHRoID0gaW5mby53aWR0aDtcclxuICAgIHZhciBoZWlnaHQgPSBpbmZvLmhlaWdodDtcclxuXHJcbiAgICBzZXRGbGFncyhpbmZvKTtcclxuXHJcbiAgICBpZiAoZWxlbWVudCkge1xyXG4gICAgICBnbC50ZXhTdWJJbWFnZTJEKFxyXG4gICAgICAgIHRhcmdldCwgbWlwbGV2ZWwsIHgsIHksIGZvcm1hdCwgdHlwZSwgZWxlbWVudCk7XHJcbiAgICB9IGVsc2UgaWYgKGluZm8uY29tcHJlc3NlZCkge1xyXG4gICAgICBnbC5jb21wcmVzc2VkVGV4U3ViSW1hZ2UyRChcclxuICAgICAgICB0YXJnZXQsIG1pcGxldmVsLCB4LCB5LCBpbnRlcm5hbGZvcm1hdCwgd2lkdGgsIGhlaWdodCwgZGF0YSk7XHJcbiAgICB9IGVsc2UgaWYgKGluZm8ubmVlZHNDb3B5KSB7XHJcbiAgICAgIHJlZ2xQb2xsKCk7XHJcbiAgICAgIGdsLmNvcHlUZXhTdWJJbWFnZTJEKFxyXG4gICAgICAgIHRhcmdldCwgbWlwbGV2ZWwsIHgsIHksIGluZm8ueE9mZnNldCwgaW5mby55T2Zmc2V0LCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGdsLnRleFN1YkltYWdlMkQoXHJcbiAgICAgICAgdGFyZ2V0LCBtaXBsZXZlbCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlLCBkYXRhKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIHRleEltYWdlIHBvb2xcclxuICB2YXIgaW1hZ2VQb29sID0gW107XHJcblxyXG4gIGZ1bmN0aW9uIGFsbG9jSW1hZ2UgKCkge1xyXG4gICAgcmV0dXJuIGltYWdlUG9vbC5wb3AoKSB8fCBuZXcgVGV4SW1hZ2UoKVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZnJlZUltYWdlIChpbWFnZSkge1xyXG4gICAgaWYgKGltYWdlLm5lZWRzRnJlZSkge1xyXG4gICAgICBwb29sLmZyZWVUeXBlKGltYWdlLmRhdGEpO1xyXG4gICAgfVxyXG4gICAgVGV4SW1hZ2UuY2FsbChpbWFnZSk7XHJcbiAgICBpbWFnZVBvb2wucHVzaChpbWFnZSk7XHJcbiAgfVxyXG5cclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgLy8gTWlwIG1hcFxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICBmdW5jdGlvbiBNaXBNYXAgKCkge1xyXG4gICAgVGV4RmxhZ3MuY2FsbCh0aGlzKTtcclxuXHJcbiAgICB0aGlzLmdlbk1pcG1hcHMgPSBmYWxzZTtcclxuICAgIHRoaXMubWlwbWFwSGludCA9IEdMX0RPTlRfQ0FSRTtcclxuICAgIHRoaXMubWlwbWFzayA9IDA7XHJcbiAgICB0aGlzLmltYWdlcyA9IEFycmF5KDE2KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHBhcnNlTWlwTWFwRnJvbVNoYXBlIChtaXBtYXAsIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgIHZhciBpbWcgPSBtaXBtYXAuaW1hZ2VzWzBdID0gYWxsb2NJbWFnZSgpO1xyXG4gICAgbWlwbWFwLm1pcG1hc2sgPSAxO1xyXG4gICAgaW1nLndpZHRoID0gbWlwbWFwLndpZHRoID0gd2lkdGg7XHJcbiAgICBpbWcuaGVpZ2h0ID0gbWlwbWFwLmhlaWdodCA9IGhlaWdodDtcclxuICAgIGltZy5jaGFubmVscyA9IG1pcG1hcC5jaGFubmVscyA9IDQ7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBwYXJzZU1pcE1hcEZyb21PYmplY3QgKG1pcG1hcCwgb3B0aW9ucykge1xyXG4gICAgdmFyIGltZ0RhdGEgPSBudWxsO1xyXG4gICAgaWYgKGlzUGl4ZWxEYXRhKG9wdGlvbnMpKSB7XHJcbiAgICAgIGltZ0RhdGEgPSBtaXBtYXAuaW1hZ2VzWzBdID0gYWxsb2NJbWFnZSgpO1xyXG4gICAgICBjb3B5RmxhZ3MoaW1nRGF0YSwgbWlwbWFwKTtcclxuICAgICAgcGFyc2VJbWFnZShpbWdEYXRhLCBvcHRpb25zKTtcclxuICAgICAgbWlwbWFwLm1pcG1hc2sgPSAxO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcGFyc2VGbGFncyhtaXBtYXAsIG9wdGlvbnMpO1xyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLm1pcG1hcCkpIHtcclxuICAgICAgICB2YXIgbWlwRGF0YSA9IG9wdGlvbnMubWlwbWFwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWlwRGF0YS5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgaW1nRGF0YSA9IG1pcG1hcC5pbWFnZXNbaV0gPSBhbGxvY0ltYWdlKCk7XHJcbiAgICAgICAgICBjb3B5RmxhZ3MoaW1nRGF0YSwgbWlwbWFwKTtcclxuICAgICAgICAgIGltZ0RhdGEud2lkdGggPj49IGk7XHJcbiAgICAgICAgICBpbWdEYXRhLmhlaWdodCA+Pj0gaTtcclxuICAgICAgICAgIHBhcnNlSW1hZ2UoaW1nRGF0YSwgbWlwRGF0YVtpXSk7XHJcbiAgICAgICAgICBtaXBtYXAubWlwbWFzayB8PSAoMSA8PCBpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaW1nRGF0YSA9IG1pcG1hcC5pbWFnZXNbMF0gPSBhbGxvY0ltYWdlKCk7XHJcbiAgICAgICAgY29weUZsYWdzKGltZ0RhdGEsIG1pcG1hcCk7XHJcbiAgICAgICAgcGFyc2VJbWFnZShpbWdEYXRhLCBvcHRpb25zKTtcclxuICAgICAgICBtaXBtYXAubWlwbWFzayA9IDE7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGNvcHlGbGFncyhtaXBtYXAsIG1pcG1hcC5pbWFnZXNbMF0pO1xyXG5cclxuICAgIC8vIEZvciB0ZXh0dXJlcyBvZiB0aGUgY29tcHJlc3NlZCBmb3JtYXQgV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGNcclxuICAgIC8vIHdlIG11c3QgaGF2ZSB0aGF0XHJcbiAgICAvL1xyXG4gICAgLy8gXCJXaGVuIGxldmVsIGVxdWFscyB6ZXJvIHdpZHRoIGFuZCBoZWlnaHQgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQuXHJcbiAgICAvLyBXaGVuIGxldmVsIGlzIGdyZWF0ZXIgdGhhbiAwIHdpZHRoIGFuZCBoZWlnaHQgbXVzdCBiZSAwLCAxLCAyIG9yIGEgbXVsdGlwbGUgb2YgNC4gXCJcclxuICAgIC8vXHJcbiAgICAvLyBidXQgd2UgZG8gbm90IHlldCBzdXBwb3J0IGhhdmluZyBtdWx0aXBsZSBtaXBtYXAgbGV2ZWxzIGZvciBjb21wcmVzc2VkIHRleHR1cmVzLFxyXG4gICAgLy8gc28gd2Ugb25seSB0ZXN0IGZvciBsZXZlbCB6ZXJvLlxyXG5cclxuICAgIGlmIChtaXBtYXAuY29tcHJlc3NlZCAmJlxyXG4gICAgICAgIChtaXBtYXAuaW50ZXJuYWxmb3JtYXQgPT09IEdMX0NPTVBSRVNTRURfUkdCX1MzVENfRFhUMV9FWFQpIHx8XHJcbiAgICAgICAgKG1pcG1hcC5pbnRlcm5hbGZvcm1hdCA9PT0gR0xfQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUMV9FWFQpIHx8XHJcbiAgICAgICAgKG1pcG1hcC5pbnRlcm5hbGZvcm1hdCA9PT0gR0xfQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUM19FWFQpIHx8XHJcbiAgICAgICAgKG1pcG1hcC5pbnRlcm5hbGZvcm1hdCA9PT0gR0xfQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUNV9FWFQpKSB7XHJcbiAgICAgIGNoZWNrJDEobWlwbWFwLndpZHRoICUgNCA9PT0gMCAmJlxyXG4gICAgICAgICAgICBtaXBtYXAuaGVpZ2h0ICUgNCA9PT0gMCxcclxuICAgICAgICAgICAgJ2ZvciBjb21wcmVzc2VkIHRleHR1cmUgZm9ybWF0cywgbWlwbWFwIGxldmVsIDAgbXVzdCBoYXZlIHdpZHRoIGFuZCBoZWlnaHQgdGhhdCBhcmUgYSBtdWx0aXBsZSBvZiA0Jyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzZXRNaXBNYXAgKG1pcG1hcCwgdGFyZ2V0KSB7XHJcbiAgICB2YXIgaW1hZ2VzID0gbWlwbWFwLmltYWdlcztcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW1hZ2VzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgIGlmICghaW1hZ2VzW2ldKSB7XHJcbiAgICAgICAgcmV0dXJuXHJcbiAgICAgIH1cclxuICAgICAgc2V0SW1hZ2UoaW1hZ2VzW2ldLCB0YXJnZXQsIGkpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdmFyIG1pcFBvb2wgPSBbXTtcclxuXHJcbiAgZnVuY3Rpb24gYWxsb2NNaXBNYXAgKCkge1xyXG4gICAgdmFyIHJlc3VsdCA9IG1pcFBvb2wucG9wKCkgfHwgbmV3IE1pcE1hcCgpO1xyXG4gICAgVGV4RmxhZ3MuY2FsbChyZXN1bHQpO1xyXG4gICAgcmVzdWx0Lm1pcG1hc2sgPSAwO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSB7XHJcbiAgICAgIHJlc3VsdC5pbWFnZXNbaV0gPSBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdFxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZnJlZU1pcE1hcCAobWlwbWFwKSB7XHJcbiAgICB2YXIgaW1hZ2VzID0gbWlwbWFwLmltYWdlcztcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW1hZ2VzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgIGlmIChpbWFnZXNbaV0pIHtcclxuICAgICAgICBmcmVlSW1hZ2UoaW1hZ2VzW2ldKTtcclxuICAgICAgfVxyXG4gICAgICBpbWFnZXNbaV0gPSBudWxsO1xyXG4gICAgfVxyXG4gICAgbWlwUG9vbC5wdXNoKG1pcG1hcCk7XHJcbiAgfVxyXG5cclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgLy8gVGV4IGluZm9cclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgZnVuY3Rpb24gVGV4SW5mbyAoKSB7XHJcbiAgICB0aGlzLm1pbkZpbHRlciA9IEdMX05FQVJFU1QkMTtcclxuICAgIHRoaXMubWFnRmlsdGVyID0gR0xfTkVBUkVTVCQxO1xyXG5cclxuICAgIHRoaXMud3JhcFMgPSBHTF9DTEFNUF9UT19FREdFJDE7XHJcbiAgICB0aGlzLndyYXBUID0gR0xfQ0xBTVBfVE9fRURHRSQxO1xyXG5cclxuICAgIHRoaXMuYW5pc290cm9waWMgPSAxO1xyXG5cclxuICAgIHRoaXMuZ2VuTWlwbWFwcyA9IGZhbHNlO1xyXG4gICAgdGhpcy5taXBtYXBIaW50ID0gR0xfRE9OVF9DQVJFO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcGFyc2VUZXhJbmZvIChpbmZvLCBvcHRpb25zKSB7XHJcbiAgICBpZiAoJ21pbicgaW4gb3B0aW9ucykge1xyXG4gICAgICB2YXIgbWluRmlsdGVyID0gb3B0aW9ucy5taW47XHJcbiAgICAgIGNoZWNrJDEucGFyYW1ldGVyKG1pbkZpbHRlciwgbWluRmlsdGVycyk7XHJcbiAgICAgIGluZm8ubWluRmlsdGVyID0gbWluRmlsdGVyc1ttaW5GaWx0ZXJdO1xyXG4gICAgICBpZiAoTUlQTUFQX0ZJTFRFUlMuaW5kZXhPZihpbmZvLm1pbkZpbHRlcikgPj0gMCAmJiAhKCdmYWNlcycgaW4gb3B0aW9ucykpIHtcclxuICAgICAgICBpbmZvLmdlbk1pcG1hcHMgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCdtYWcnIGluIG9wdGlvbnMpIHtcclxuICAgICAgdmFyIG1hZ0ZpbHRlciA9IG9wdGlvbnMubWFnO1xyXG4gICAgICBjaGVjayQxLnBhcmFtZXRlcihtYWdGaWx0ZXIsIG1hZ0ZpbHRlcnMpO1xyXG4gICAgICBpbmZvLm1hZ0ZpbHRlciA9IG1hZ0ZpbHRlcnNbbWFnRmlsdGVyXTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgd3JhcFMgPSBpbmZvLndyYXBTO1xyXG4gICAgdmFyIHdyYXBUID0gaW5mby53cmFwVDtcclxuICAgIGlmICgnd3JhcCcgaW4gb3B0aW9ucykge1xyXG4gICAgICB2YXIgd3JhcCA9IG9wdGlvbnMud3JhcDtcclxuICAgICAgaWYgKHR5cGVvZiB3cmFwID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGNoZWNrJDEucGFyYW1ldGVyKHdyYXAsIHdyYXBNb2Rlcyk7XHJcbiAgICAgICAgd3JhcFMgPSB3cmFwVCA9IHdyYXBNb2Rlc1t3cmFwXTtcclxuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHdyYXApKSB7XHJcbiAgICAgICAgY2hlY2skMS5wYXJhbWV0ZXIod3JhcFswXSwgd3JhcE1vZGVzKTtcclxuICAgICAgICBjaGVjayQxLnBhcmFtZXRlcih3cmFwWzFdLCB3cmFwTW9kZXMpO1xyXG4gICAgICAgIHdyYXBTID0gd3JhcE1vZGVzW3dyYXBbMF1dO1xyXG4gICAgICAgIHdyYXBUID0gd3JhcE1vZGVzW3dyYXBbMV1dO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAoJ3dyYXBTJyBpbiBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIG9wdFdyYXBTID0gb3B0aW9ucy53cmFwUztcclxuICAgICAgICBjaGVjayQxLnBhcmFtZXRlcihvcHRXcmFwUywgd3JhcE1vZGVzKTtcclxuICAgICAgICB3cmFwUyA9IHdyYXBNb2Rlc1tvcHRXcmFwU107XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCd3cmFwVCcgaW4gb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBvcHRXcmFwVCA9IG9wdGlvbnMud3JhcFQ7XHJcbiAgICAgICAgY2hlY2skMS5wYXJhbWV0ZXIob3B0V3JhcFQsIHdyYXBNb2Rlcyk7XHJcbiAgICAgICAgd3JhcFQgPSB3cmFwTW9kZXNbb3B0V3JhcFRdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpbmZvLndyYXBTID0gd3JhcFM7XHJcbiAgICBpbmZvLndyYXBUID0gd3JhcFQ7XHJcblxyXG4gICAgaWYgKCdhbmlzb3Ryb3BpYycgaW4gb3B0aW9ucykge1xyXG4gICAgICB2YXIgYW5pc290cm9waWMgPSBvcHRpb25zLmFuaXNvdHJvcGljO1xyXG4gICAgICBjaGVjayQxKHR5cGVvZiBhbmlzb3Ryb3BpYyA9PT0gJ251bWJlcicgJiZcclxuICAgICAgICAgYW5pc290cm9waWMgPj0gMSAmJiBhbmlzb3Ryb3BpYyA8PSBsaW1pdHMubWF4QW5pc290cm9waWMsXHJcbiAgICAgICAgJ2FuaXNvIHNhbXBsZXMgbXVzdCBiZSBiZXR3ZWVuIDEgYW5kICcpO1xyXG4gICAgICBpbmZvLmFuaXNvdHJvcGljID0gb3B0aW9ucy5hbmlzb3Ryb3BpYztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoJ21pcG1hcCcgaW4gb3B0aW9ucykge1xyXG4gICAgICB2YXIgaGFzTWlwTWFwID0gZmFsc2U7XHJcbiAgICAgIHN3aXRjaCAodHlwZW9mIG9wdGlvbnMubWlwbWFwKSB7XHJcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcclxuICAgICAgICAgIGNoZWNrJDEucGFyYW1ldGVyKG9wdGlvbnMubWlwbWFwLCBtaXBtYXBIaW50LFxyXG4gICAgICAgICAgICAnaW52YWxpZCBtaXBtYXAgaGludCcpO1xyXG4gICAgICAgICAgaW5mby5taXBtYXBIaW50ID0gbWlwbWFwSGludFtvcHRpb25zLm1pcG1hcF07XHJcbiAgICAgICAgICBpbmZvLmdlbk1pcG1hcHMgPSB0cnVlO1xyXG4gICAgICAgICAgaGFzTWlwTWFwID0gdHJ1ZTtcclxuICAgICAgICAgIGJyZWFrXHJcblxyXG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxyXG4gICAgICAgICAgaGFzTWlwTWFwID0gaW5mby5nZW5NaXBtYXBzID0gb3B0aW9ucy5taXBtYXA7XHJcbiAgICAgICAgICBicmVha1xyXG5cclxuICAgICAgICBjYXNlICdvYmplY3QnOlxyXG4gICAgICAgICAgY2hlY2skMShBcnJheS5pc0FycmF5KG9wdGlvbnMubWlwbWFwKSwgJ2ludmFsaWQgbWlwbWFwIHR5cGUnKTtcclxuICAgICAgICAgIGluZm8uZ2VuTWlwbWFwcyA9IGZhbHNlO1xyXG4gICAgICAgICAgaGFzTWlwTWFwID0gdHJ1ZTtcclxuICAgICAgICAgIGJyZWFrXHJcblxyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBjaGVjayQxLnJhaXNlKCdpbnZhbGlkIG1pcG1hcCB0eXBlJyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGhhc01pcE1hcCAmJiAhKCdtaW4nIGluIG9wdGlvbnMpKSB7XHJcbiAgICAgICAgaW5mby5taW5GaWx0ZXIgPSBHTF9ORUFSRVNUX01JUE1BUF9ORUFSRVNUJDE7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHNldFRleEluZm8gKGluZm8sIHRhcmdldCkge1xyXG4gICAgZ2wudGV4UGFyYW1ldGVyaSh0YXJnZXQsIEdMX1RFWFRVUkVfTUlOX0ZJTFRFUiwgaW5mby5taW5GaWx0ZXIpO1xyXG4gICAgZ2wudGV4UGFyYW1ldGVyaSh0YXJnZXQsIEdMX1RFWFRVUkVfTUFHX0ZJTFRFUiwgaW5mby5tYWdGaWx0ZXIpO1xyXG4gICAgZ2wudGV4UGFyYW1ldGVyaSh0YXJnZXQsIEdMX1RFWFRVUkVfV1JBUF9TLCBpbmZvLndyYXBTKTtcclxuICAgIGdsLnRleFBhcmFtZXRlcmkodGFyZ2V0LCBHTF9URVhUVVJFX1dSQVBfVCwgaW5mby53cmFwVCk7XHJcbiAgICBpZiAoZXh0ZW5zaW9ucy5leHRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMpIHtcclxuICAgICAgZ2wudGV4UGFyYW1ldGVyaSh0YXJnZXQsIEdMX1RFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhULCBpbmZvLmFuaXNvdHJvcGljKTtcclxuICAgIH1cclxuICAgIGlmIChpbmZvLmdlbk1pcG1hcHMpIHtcclxuICAgICAgZ2wuaGludChHTF9HRU5FUkFURV9NSVBNQVBfSElOVCwgaW5mby5taXBtYXBIaW50KTtcclxuICAgICAgZ2wuZ2VuZXJhdGVNaXBtYXAodGFyZ2V0KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAvLyBGdWxsIHRleHR1cmUgb2JqZWN0XHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIHZhciB0ZXh0dXJlQ291bnQgPSAwO1xyXG4gIHZhciB0ZXh0dXJlU2V0ID0ge307XHJcbiAgdmFyIG51bVRleFVuaXRzID0gbGltaXRzLm1heFRleHR1cmVVbml0cztcclxuICB2YXIgdGV4dHVyZVVuaXRzID0gQXJyYXkobnVtVGV4VW5pdHMpLm1hcChmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gbnVsbFxyXG4gIH0pO1xyXG5cclxuICBmdW5jdGlvbiBSRUdMVGV4dHVyZSAodGFyZ2V0KSB7XHJcbiAgICBUZXhGbGFncy5jYWxsKHRoaXMpO1xyXG4gICAgdGhpcy5taXBtYXNrID0gMDtcclxuICAgIHRoaXMuaW50ZXJuYWxmb3JtYXQgPSBHTF9SR0JBJDE7XHJcblxyXG4gICAgdGhpcy5pZCA9IHRleHR1cmVDb3VudCsrO1xyXG5cclxuICAgIHRoaXMucmVmQ291bnQgPSAxO1xyXG5cclxuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgdGhpcy50ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG5cclxuICAgIHRoaXMudW5pdCA9IC0xO1xyXG4gICAgdGhpcy5iaW5kQ291bnQgPSAwO1xyXG5cclxuICAgIHRoaXMudGV4SW5mbyA9IG5ldyBUZXhJbmZvKCk7XHJcblxyXG4gICAgaWYgKGNvbmZpZy5wcm9maWxlKSB7XHJcbiAgICAgIHRoaXMuc3RhdHMgPSB7c2l6ZTogMH07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB0ZW1wQmluZCAodGV4dHVyZSkge1xyXG4gICAgZ2wuYWN0aXZlVGV4dHVyZShHTF9URVhUVVJFMCQxKTtcclxuICAgIGdsLmJpbmRUZXh0dXJlKHRleHR1cmUudGFyZ2V0LCB0ZXh0dXJlLnRleHR1cmUpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdGVtcFJlc3RvcmUgKCkge1xyXG4gICAgdmFyIHByZXYgPSB0ZXh0dXJlVW5pdHNbMF07XHJcbiAgICBpZiAocHJldikge1xyXG4gICAgICBnbC5iaW5kVGV4dHVyZShwcmV2LnRhcmdldCwgcHJldi50ZXh0dXJlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGdsLmJpbmRUZXh0dXJlKEdMX1RFWFRVUkVfMkQkMSwgbnVsbCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBkZXN0cm95ICh0ZXh0dXJlKSB7XHJcbiAgICB2YXIgaGFuZGxlID0gdGV4dHVyZS50ZXh0dXJlO1xyXG4gICAgY2hlY2skMShoYW5kbGUsICdtdXN0IG5vdCBkb3VibGUgZGVzdHJveSB0ZXh0dXJlJyk7XHJcbiAgICB2YXIgdW5pdCA9IHRleHR1cmUudW5pdDtcclxuICAgIHZhciB0YXJnZXQgPSB0ZXh0dXJlLnRhcmdldDtcclxuICAgIGlmICh1bml0ID49IDApIHtcclxuICAgICAgZ2wuYWN0aXZlVGV4dHVyZShHTF9URVhUVVJFMCQxICsgdW5pdCk7XHJcbiAgICAgIGdsLmJpbmRUZXh0dXJlKHRhcmdldCwgbnVsbCk7XHJcbiAgICAgIHRleHR1cmVVbml0c1t1bml0XSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBnbC5kZWxldGVUZXh0dXJlKGhhbmRsZSk7XHJcbiAgICB0ZXh0dXJlLnRleHR1cmUgPSBudWxsO1xyXG4gICAgdGV4dHVyZS5wYXJhbXMgPSBudWxsO1xyXG4gICAgdGV4dHVyZS5waXhlbHMgPSBudWxsO1xyXG4gICAgdGV4dHVyZS5yZWZDb3VudCA9IDA7XHJcbiAgICBkZWxldGUgdGV4dHVyZVNldFt0ZXh0dXJlLmlkXTtcclxuICAgIHN0YXRzLnRleHR1cmVDb3VudC0tO1xyXG4gIH1cclxuXHJcbiAgZXh0ZW5kKFJFR0xUZXh0dXJlLnByb3RvdHlwZSwge1xyXG4gICAgYmluZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgdGV4dHVyZSA9IHRoaXM7XHJcbiAgICAgIHRleHR1cmUuYmluZENvdW50ICs9IDE7XHJcbiAgICAgIHZhciB1bml0ID0gdGV4dHVyZS51bml0O1xyXG4gICAgICBpZiAodW5pdCA8IDApIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVRleFVuaXRzOyArK2kpIHtcclxuICAgICAgICAgIHZhciBvdGhlciA9IHRleHR1cmVVbml0c1tpXTtcclxuICAgICAgICAgIGlmIChvdGhlcikge1xyXG4gICAgICAgICAgICBpZiAob3RoZXIuYmluZENvdW50ID4gMCkge1xyXG4gICAgICAgICAgICAgIGNvbnRpbnVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3RoZXIudW5pdCA9IC0xO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdGV4dHVyZVVuaXRzW2ldID0gdGV4dHVyZTtcclxuICAgICAgICAgIHVuaXQgPSBpO1xyXG4gICAgICAgICAgYnJlYWtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHVuaXQgPj0gbnVtVGV4VW5pdHMpIHtcclxuICAgICAgICAgIGNoZWNrJDEucmFpc2UoJ2luc3VmZmljaWVudCBudW1iZXIgb2YgdGV4dHVyZSB1bml0cycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29uZmlnLnByb2ZpbGUgJiYgc3RhdHMubWF4VGV4dHVyZVVuaXRzIDwgKHVuaXQgKyAxKSkge1xyXG4gICAgICAgICAgc3RhdHMubWF4VGV4dHVyZVVuaXRzID0gdW5pdCArIDE7IC8vICsxLCBzaW5jZSB0aGUgdW5pdHMgYXJlIHplcm8tYmFzZWRcclxuICAgICAgICB9XHJcbiAgICAgICAgdGV4dHVyZS51bml0ID0gdW5pdDtcclxuICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKEdMX1RFWFRVUkUwJDEgKyB1bml0KTtcclxuICAgICAgICBnbC5iaW5kVGV4dHVyZSh0ZXh0dXJlLnRhcmdldCwgdGV4dHVyZS50ZXh0dXJlKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdW5pdFxyXG4gICAgfSxcclxuXHJcbiAgICB1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5iaW5kQ291bnQgLT0gMTtcclxuICAgIH0sXHJcblxyXG4gICAgZGVjUmVmOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGlmICgtLXRoaXMucmVmQ291bnQgPD0gMCkge1xyXG4gICAgICAgIGRlc3Ryb3kodGhpcyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgZnVuY3Rpb24gY3JlYXRlVGV4dHVyZTJEIChhLCBiKSB7XHJcbiAgICB2YXIgdGV4dHVyZSA9IG5ldyBSRUdMVGV4dHVyZShHTF9URVhUVVJFXzJEJDEpO1xyXG4gICAgdGV4dHVyZVNldFt0ZXh0dXJlLmlkXSA9IHRleHR1cmU7XHJcbiAgICBzdGF0cy50ZXh0dXJlQ291bnQrKztcclxuXHJcbiAgICBmdW5jdGlvbiByZWdsVGV4dHVyZTJEIChhLCBiKSB7XHJcbiAgICAgIHZhciB0ZXhJbmZvID0gdGV4dHVyZS50ZXhJbmZvO1xyXG4gICAgICBUZXhJbmZvLmNhbGwodGV4SW5mbyk7XHJcbiAgICAgIHZhciBtaXBEYXRhID0gYWxsb2NNaXBNYXAoKTtcclxuXHJcbiAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGIgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICBwYXJzZU1pcE1hcEZyb21TaGFwZShtaXBEYXRhLCBhIHwgMCwgYiB8IDApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBwYXJzZU1pcE1hcEZyb21TaGFwZShtaXBEYXRhLCBhIHwgMCwgYSB8IDApO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmIChhKSB7XHJcbiAgICAgICAgY2hlY2skMS50eXBlKGEsICdvYmplY3QnLCAnaW52YWxpZCBhcmd1bWVudHMgdG8gcmVnbC50ZXh0dXJlJyk7XHJcbiAgICAgICAgcGFyc2VUZXhJbmZvKHRleEluZm8sIGEpO1xyXG4gICAgICAgIHBhcnNlTWlwTWFwRnJvbU9iamVjdChtaXBEYXRhLCBhKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBlbXB0eSB0ZXh0dXJlcyBnZXQgYXNzaWduZWQgYSBkZWZhdWx0IHNoYXBlIG9mIDF4MVxyXG4gICAgICAgIHBhcnNlTWlwTWFwRnJvbVNoYXBlKG1pcERhdGEsIDEsIDEpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGV4SW5mby5nZW5NaXBtYXBzKSB7XHJcbiAgICAgICAgbWlwRGF0YS5taXBtYXNrID0gKG1pcERhdGEud2lkdGggPDwgMSkgLSAxO1xyXG4gICAgICB9XHJcbiAgICAgIHRleHR1cmUubWlwbWFzayA9IG1pcERhdGEubWlwbWFzaztcclxuXHJcbiAgICAgIGNvcHlGbGFncyh0ZXh0dXJlLCBtaXBEYXRhKTtcclxuXHJcbiAgICAgIGNoZWNrJDEudGV4dHVyZTJEKHRleEluZm8sIG1pcERhdGEsIGxpbWl0cyk7XHJcbiAgICAgIHRleHR1cmUuaW50ZXJuYWxmb3JtYXQgPSBtaXBEYXRhLmludGVybmFsZm9ybWF0O1xyXG5cclxuICAgICAgcmVnbFRleHR1cmUyRC53aWR0aCA9IG1pcERhdGEud2lkdGg7XHJcbiAgICAgIHJlZ2xUZXh0dXJlMkQuaGVpZ2h0ID0gbWlwRGF0YS5oZWlnaHQ7XHJcblxyXG4gICAgICB0ZW1wQmluZCh0ZXh0dXJlKTtcclxuICAgICAgc2V0TWlwTWFwKG1pcERhdGEsIEdMX1RFWFRVUkVfMkQkMSk7XHJcbiAgICAgIHNldFRleEluZm8odGV4SW5mbywgR0xfVEVYVFVSRV8yRCQxKTtcclxuICAgICAgdGVtcFJlc3RvcmUoKTtcclxuXHJcbiAgICAgIGZyZWVNaXBNYXAobWlwRGF0YSk7XHJcblxyXG4gICAgICBpZiAoY29uZmlnLnByb2ZpbGUpIHtcclxuICAgICAgICB0ZXh0dXJlLnN0YXRzLnNpemUgPSBnZXRUZXh0dXJlU2l6ZShcclxuICAgICAgICAgIHRleHR1cmUuaW50ZXJuYWxmb3JtYXQsXHJcbiAgICAgICAgICB0ZXh0dXJlLnR5cGUsXHJcbiAgICAgICAgICBtaXBEYXRhLndpZHRoLFxyXG4gICAgICAgICAgbWlwRGF0YS5oZWlnaHQsXHJcbiAgICAgICAgICB0ZXhJbmZvLmdlbk1pcG1hcHMsXHJcbiAgICAgICAgICBmYWxzZSk7XHJcbiAgICAgIH1cclxuICAgICAgcmVnbFRleHR1cmUyRC5mb3JtYXQgPSB0ZXh0dXJlRm9ybWF0c0ludmVydFt0ZXh0dXJlLmludGVybmFsZm9ybWF0XTtcclxuICAgICAgcmVnbFRleHR1cmUyRC50eXBlID0gdGV4dHVyZVR5cGVzSW52ZXJ0W3RleHR1cmUudHlwZV07XHJcblxyXG4gICAgICByZWdsVGV4dHVyZTJELm1hZyA9IG1hZ0ZpbHRlcnNJbnZlcnRbdGV4SW5mby5tYWdGaWx0ZXJdO1xyXG4gICAgICByZWdsVGV4dHVyZTJELm1pbiA9IG1pbkZpbHRlcnNJbnZlcnRbdGV4SW5mby5taW5GaWx0ZXJdO1xyXG5cclxuICAgICAgcmVnbFRleHR1cmUyRC53cmFwUyA9IHdyYXBNb2Rlc0ludmVydFt0ZXhJbmZvLndyYXBTXTtcclxuICAgICAgcmVnbFRleHR1cmUyRC53cmFwVCA9IHdyYXBNb2Rlc0ludmVydFt0ZXhJbmZvLndyYXBUXTtcclxuXHJcbiAgICAgIHJldHVybiByZWdsVGV4dHVyZTJEXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc3ViaW1hZ2UgKGltYWdlLCB4XywgeV8sIGxldmVsXykge1xyXG4gICAgICBjaGVjayQxKCEhaW1hZ2UsICdtdXN0IHNwZWNpZnkgaW1hZ2UgZGF0YScpO1xyXG5cclxuICAgICAgdmFyIHggPSB4XyB8IDA7XHJcbiAgICAgIHZhciB5ID0geV8gfCAwO1xyXG4gICAgICB2YXIgbGV2ZWwgPSBsZXZlbF8gfCAwO1xyXG5cclxuICAgICAgdmFyIGltYWdlRGF0YSA9IGFsbG9jSW1hZ2UoKTtcclxuICAgICAgY29weUZsYWdzKGltYWdlRGF0YSwgdGV4dHVyZSk7XHJcbiAgICAgIGltYWdlRGF0YS53aWR0aCA9IDA7XHJcbiAgICAgIGltYWdlRGF0YS5oZWlnaHQgPSAwO1xyXG4gICAgICBwYXJzZUltYWdlKGltYWdlRGF0YSwgaW1hZ2UpO1xyXG4gICAgICBpbWFnZURhdGEud2lkdGggPSBpbWFnZURhdGEud2lkdGggfHwgKCh0ZXh0dXJlLndpZHRoID4+IGxldmVsKSAtIHgpO1xyXG4gICAgICBpbWFnZURhdGEuaGVpZ2h0ID0gaW1hZ2VEYXRhLmhlaWdodCB8fCAoKHRleHR1cmUuaGVpZ2h0ID4+IGxldmVsKSAtIHkpO1xyXG5cclxuICAgICAgY2hlY2skMShcclxuICAgICAgICB0ZXh0dXJlLnR5cGUgPT09IGltYWdlRGF0YS50eXBlICYmXHJcbiAgICAgICAgdGV4dHVyZS5mb3JtYXQgPT09IGltYWdlRGF0YS5mb3JtYXQgJiZcclxuICAgICAgICB0ZXh0dXJlLmludGVybmFsZm9ybWF0ID09PSBpbWFnZURhdGEuaW50ZXJuYWxmb3JtYXQsXHJcbiAgICAgICAgJ2luY29tcGF0aWJsZSBmb3JtYXQgZm9yIHRleHR1cmUuc3ViaW1hZ2UnKTtcclxuICAgICAgY2hlY2skMShcclxuICAgICAgICB4ID49IDAgJiYgeSA+PSAwICYmXHJcbiAgICAgICAgeCArIGltYWdlRGF0YS53aWR0aCA8PSB0ZXh0dXJlLndpZHRoICYmXHJcbiAgICAgICAgeSArIGltYWdlRGF0YS5oZWlnaHQgPD0gdGV4dHVyZS5oZWlnaHQsXHJcbiAgICAgICAgJ3RleHR1cmUuc3ViaW1hZ2Ugd3JpdGUgb3V0IG9mIGJvdW5kcycpO1xyXG4gICAgICBjaGVjayQxKFxyXG4gICAgICAgIHRleHR1cmUubWlwbWFzayAmICgxIDw8IGxldmVsKSxcclxuICAgICAgICAnbWlzc2luZyBtaXBtYXAgZGF0YScpO1xyXG4gICAgICBjaGVjayQxKFxyXG4gICAgICAgIGltYWdlRGF0YS5kYXRhIHx8IGltYWdlRGF0YS5lbGVtZW50IHx8IGltYWdlRGF0YS5uZWVkc0NvcHksXHJcbiAgICAgICAgJ21pc3NpbmcgaW1hZ2UgZGF0YScpO1xyXG5cclxuICAgICAgdGVtcEJpbmQodGV4dHVyZSk7XHJcbiAgICAgIHNldFN1YkltYWdlKGltYWdlRGF0YSwgR0xfVEVYVFVSRV8yRCQxLCB4LCB5LCBsZXZlbCk7XHJcbiAgICAgIHRlbXBSZXN0b3JlKCk7XHJcblxyXG4gICAgICBmcmVlSW1hZ2UoaW1hZ2VEYXRhKTtcclxuXHJcbiAgICAgIHJldHVybiByZWdsVGV4dHVyZTJEXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVzaXplICh3XywgaF8pIHtcclxuICAgICAgdmFyIHcgPSB3XyB8IDA7XHJcbiAgICAgIHZhciBoID0gKGhfIHwgMCkgfHwgdztcclxuICAgICAgaWYgKHcgPT09IHRleHR1cmUud2lkdGggJiYgaCA9PT0gdGV4dHVyZS5oZWlnaHQpIHtcclxuICAgICAgICByZXR1cm4gcmVnbFRleHR1cmUyRFxyXG4gICAgICB9XHJcblxyXG4gICAgICByZWdsVGV4dHVyZTJELndpZHRoID0gdGV4dHVyZS53aWR0aCA9IHc7XHJcbiAgICAgIHJlZ2xUZXh0dXJlMkQuaGVpZ2h0ID0gdGV4dHVyZS5oZWlnaHQgPSBoO1xyXG5cclxuICAgICAgdGVtcEJpbmQodGV4dHVyZSk7XHJcblxyXG4gICAgICB2YXIgZGF0YTtcclxuICAgICAgdmFyIGNoYW5uZWxzID0gdGV4dHVyZS5jaGFubmVscztcclxuICAgICAgdmFyIHR5cGUgPSB0ZXh0dXJlLnR5cGU7XHJcblxyXG4gICAgICBmb3IgKHZhciBpID0gMDsgdGV4dHVyZS5taXBtYXNrID4+IGk7ICsraSkge1xyXG4gICAgICAgIHZhciBfdyA9IHcgPj4gaTtcclxuICAgICAgICB2YXIgX2ggPSBoID4+IGk7XHJcbiAgICAgICAgaWYgKCFfdyB8fCAhX2gpIGJyZWFrXHJcbiAgICAgICAgZGF0YSA9IHBvb2wuemVyby5hbGxvY1R5cGUodHlwZSwgX3cgKiBfaCAqIGNoYW5uZWxzKTtcclxuICAgICAgICBnbC50ZXhJbWFnZTJEKFxyXG4gICAgICAgICAgR0xfVEVYVFVSRV8yRCQxLFxyXG4gICAgICAgICAgaSxcclxuICAgICAgICAgIHRleHR1cmUuZm9ybWF0LFxyXG4gICAgICAgICAgX3csXHJcbiAgICAgICAgICBfaCxcclxuICAgICAgICAgIDAsXHJcbiAgICAgICAgICB0ZXh0dXJlLmZvcm1hdCxcclxuICAgICAgICAgIHRleHR1cmUudHlwZSxcclxuICAgICAgICAgIGRhdGEpO1xyXG4gICAgICAgIGlmIChkYXRhKSBwb29sLnplcm8uZnJlZVR5cGUoZGF0YSk7XHJcbiAgICAgIH1cclxuICAgICAgdGVtcFJlc3RvcmUoKTtcclxuXHJcbiAgICAgIC8vIGFsc28sIHJlY29tcHV0ZSB0aGUgdGV4dHVyZSBzaXplLlxyXG4gICAgICBpZiAoY29uZmlnLnByb2ZpbGUpIHtcclxuICAgICAgICB0ZXh0dXJlLnN0YXRzLnNpemUgPSBnZXRUZXh0dXJlU2l6ZShcclxuICAgICAgICAgIHRleHR1cmUuaW50ZXJuYWxmb3JtYXQsXHJcbiAgICAgICAgICB0ZXh0dXJlLnR5cGUsXHJcbiAgICAgICAgICB3LFxyXG4gICAgICAgICAgaCxcclxuICAgICAgICAgIGZhbHNlLFxyXG4gICAgICAgICAgZmFsc2UpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcmVnbFRleHR1cmUyRFxyXG4gICAgfVxyXG5cclxuICAgIHJlZ2xUZXh0dXJlMkQoYSwgYik7XHJcblxyXG4gICAgcmVnbFRleHR1cmUyRC5zdWJpbWFnZSA9IHN1YmltYWdlO1xyXG4gICAgcmVnbFRleHR1cmUyRC5yZXNpemUgPSByZXNpemU7XHJcbiAgICByZWdsVGV4dHVyZTJELl9yZWdsVHlwZSA9ICd0ZXh0dXJlMmQnO1xyXG4gICAgcmVnbFRleHR1cmUyRC5fdGV4dHVyZSA9IHRleHR1cmU7XHJcbiAgICBpZiAoY29uZmlnLnByb2ZpbGUpIHtcclxuICAgICAgcmVnbFRleHR1cmUyRC5zdGF0cyA9IHRleHR1cmUuc3RhdHM7XHJcbiAgICB9XHJcbiAgICByZWdsVGV4dHVyZTJELmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRleHR1cmUuZGVjUmVmKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiByZWdsVGV4dHVyZTJEXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjcmVhdGVUZXh0dXJlQ3ViZSAoYTAsIGExLCBhMiwgYTMsIGE0LCBhNSkge1xyXG4gICAgdmFyIHRleHR1cmUgPSBuZXcgUkVHTFRleHR1cmUoR0xfVEVYVFVSRV9DVUJFX01BUCQxKTtcclxuICAgIHRleHR1cmVTZXRbdGV4dHVyZS5pZF0gPSB0ZXh0dXJlO1xyXG4gICAgc3RhdHMuY3ViZUNvdW50Kys7XHJcblxyXG4gICAgdmFyIGZhY2VzID0gbmV3IEFycmF5KDYpO1xyXG5cclxuICAgIGZ1bmN0aW9uIHJlZ2xUZXh0dXJlQ3ViZSAoYTAsIGExLCBhMiwgYTMsIGE0LCBhNSkge1xyXG4gICAgICB2YXIgaTtcclxuICAgICAgdmFyIHRleEluZm8gPSB0ZXh0dXJlLnRleEluZm87XHJcbiAgICAgIFRleEluZm8uY2FsbCh0ZXhJbmZvKTtcclxuICAgICAgZm9yIChpID0gMDsgaSA8IDY7ICsraSkge1xyXG4gICAgICAgIGZhY2VzW2ldID0gYWxsb2NNaXBNYXAoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHR5cGVvZiBhMCA9PT0gJ251bWJlcicgfHwgIWEwKSB7XHJcbiAgICAgICAgdmFyIHMgPSAoYTAgfCAwKSB8fCAxO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA2OyArK2kpIHtcclxuICAgICAgICAgIHBhcnNlTWlwTWFwRnJvbVNoYXBlKGZhY2VzW2ldLCBzLCBzKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGEwID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIGlmIChhMSkge1xyXG4gICAgICAgICAgcGFyc2VNaXBNYXBGcm9tT2JqZWN0KGZhY2VzWzBdLCBhMCk7XHJcbiAgICAgICAgICBwYXJzZU1pcE1hcEZyb21PYmplY3QoZmFjZXNbMV0sIGExKTtcclxuICAgICAgICAgIHBhcnNlTWlwTWFwRnJvbU9iamVjdChmYWNlc1syXSwgYTIpO1xyXG4gICAgICAgICAgcGFyc2VNaXBNYXBGcm9tT2JqZWN0KGZhY2VzWzNdLCBhMyk7XHJcbiAgICAgICAgICBwYXJzZU1pcE1hcEZyb21PYmplY3QoZmFjZXNbNF0sIGE0KTtcclxuICAgICAgICAgIHBhcnNlTWlwTWFwRnJvbU9iamVjdChmYWNlc1s1XSwgYTUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBwYXJzZVRleEluZm8odGV4SW5mbywgYTApO1xyXG4gICAgICAgICAgcGFyc2VGbGFncyh0ZXh0dXJlLCBhMCk7XHJcbiAgICAgICAgICBpZiAoJ2ZhY2VzJyBpbiBhMCkge1xyXG4gICAgICAgICAgICB2YXIgZmFjZV9pbnB1dCA9IGEwLmZhY2VzO1xyXG4gICAgICAgICAgICBjaGVjayQxKEFycmF5LmlzQXJyYXkoZmFjZV9pbnB1dCkgJiYgZmFjZV9pbnB1dC5sZW5ndGggPT09IDYsXHJcbiAgICAgICAgICAgICAgJ2N1YmUgZmFjZXMgbXVzdCBiZSBhIGxlbmd0aCA2IGFycmF5Jyk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA2OyArK2kpIHtcclxuICAgICAgICAgICAgICBjaGVjayQxKHR5cGVvZiBmYWNlX2lucHV0W2ldID09PSAnb2JqZWN0JyAmJiAhIWZhY2VfaW5wdXRbaV0sXHJcbiAgICAgICAgICAgICAgICAnaW52YWxpZCBpbnB1dCBmb3IgY3ViZSBtYXAgZmFjZScpO1xyXG4gICAgICAgICAgICAgIGNvcHlGbGFncyhmYWNlc1tpXSwgdGV4dHVyZSk7XHJcbiAgICAgICAgICAgICAgcGFyc2VNaXBNYXBGcm9tT2JqZWN0KGZhY2VzW2ldLCBmYWNlX2lucHV0W2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDY7ICsraSkge1xyXG4gICAgICAgICAgICAgIHBhcnNlTWlwTWFwRnJvbU9iamVjdChmYWNlc1tpXSwgYTApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNoZWNrJDEucmFpc2UoJ2ludmFsaWQgYXJndW1lbnRzIHRvIGN1YmUgbWFwJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvcHlGbGFncyh0ZXh0dXJlLCBmYWNlc1swXSk7XHJcblxyXG4gICAgICBpZiAoIWxpbWl0cy5ucG90VGV4dHVyZUN1YmUpIHtcclxuICAgICAgICBjaGVjayQxKGlzUG93MiQxKHRleHR1cmUud2lkdGgpICYmIGlzUG93MiQxKHRleHR1cmUuaGVpZ2h0KSwgJ3lvdXIgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IG5vbiBwb3dlciBvciB0d28gdGV4dHVyZSBkaW1lbnNpb25zJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0ZXhJbmZvLmdlbk1pcG1hcHMpIHtcclxuICAgICAgICB0ZXh0dXJlLm1pcG1hc2sgPSAoZmFjZXNbMF0ud2lkdGggPDwgMSkgLSAxO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRleHR1cmUubWlwbWFzayA9IGZhY2VzWzBdLm1pcG1hc2s7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNoZWNrJDEudGV4dHVyZUN1YmUodGV4dHVyZSwgdGV4SW5mbywgZmFjZXMsIGxpbWl0cyk7XHJcbiAgICAgIHRleHR1cmUuaW50ZXJuYWxmb3JtYXQgPSBmYWNlc1swXS5pbnRlcm5hbGZvcm1hdDtcclxuXHJcbiAgICAgIHJlZ2xUZXh0dXJlQ3ViZS53aWR0aCA9IGZhY2VzWzBdLndpZHRoO1xyXG4gICAgICByZWdsVGV4dHVyZUN1YmUuaGVpZ2h0ID0gZmFjZXNbMF0uaGVpZ2h0O1xyXG5cclxuICAgICAgdGVtcEJpbmQodGV4dHVyZSk7XHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCA2OyArK2kpIHtcclxuICAgICAgICBzZXRNaXBNYXAoZmFjZXNbaV0sIEdMX1RFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCQxICsgaSk7XHJcbiAgICAgIH1cclxuICAgICAgc2V0VGV4SW5mbyh0ZXhJbmZvLCBHTF9URVhUVVJFX0NVQkVfTUFQJDEpO1xyXG4gICAgICB0ZW1wUmVzdG9yZSgpO1xyXG5cclxuICAgICAgaWYgKGNvbmZpZy5wcm9maWxlKSB7XHJcbiAgICAgICAgdGV4dHVyZS5zdGF0cy5zaXplID0gZ2V0VGV4dHVyZVNpemUoXHJcbiAgICAgICAgICB0ZXh0dXJlLmludGVybmFsZm9ybWF0LFxyXG4gICAgICAgICAgdGV4dHVyZS50eXBlLFxyXG4gICAgICAgICAgcmVnbFRleHR1cmVDdWJlLndpZHRoLFxyXG4gICAgICAgICAgcmVnbFRleHR1cmVDdWJlLmhlaWdodCxcclxuICAgICAgICAgIHRleEluZm8uZ2VuTWlwbWFwcyxcclxuICAgICAgICAgIHRydWUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZWdsVGV4dHVyZUN1YmUuZm9ybWF0ID0gdGV4dHVyZUZvcm1hdHNJbnZlcnRbdGV4dHVyZS5pbnRlcm5hbGZvcm1hdF07XHJcbiAgICAgIHJlZ2xUZXh0dXJlQ3ViZS50eXBlID0gdGV4dHVyZVR5cGVzSW52ZXJ0W3RleHR1cmUudHlwZV07XHJcblxyXG4gICAgICByZWdsVGV4dHVyZUN1YmUubWFnID0gbWFnRmlsdGVyc0ludmVydFt0ZXhJbmZvLm1hZ0ZpbHRlcl07XHJcbiAgICAgIHJlZ2xUZXh0dXJlQ3ViZS5taW4gPSBtaW5GaWx0ZXJzSW52ZXJ0W3RleEluZm8ubWluRmlsdGVyXTtcclxuXHJcbiAgICAgIHJlZ2xUZXh0dXJlQ3ViZS53cmFwUyA9IHdyYXBNb2Rlc0ludmVydFt0ZXhJbmZvLndyYXBTXTtcclxuICAgICAgcmVnbFRleHR1cmVDdWJlLndyYXBUID0gd3JhcE1vZGVzSW52ZXJ0W3RleEluZm8ud3JhcFRdO1xyXG5cclxuICAgICAgZm9yIChpID0gMDsgaSA8IDY7ICsraSkge1xyXG4gICAgICAgIGZyZWVNaXBNYXAoZmFjZXNbaV0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcmVnbFRleHR1cmVDdWJlXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc3ViaW1hZ2UgKGZhY2UsIGltYWdlLCB4XywgeV8sIGxldmVsXykge1xyXG4gICAgICBjaGVjayQxKCEhaW1hZ2UsICdtdXN0IHNwZWNpZnkgaW1hZ2UgZGF0YScpO1xyXG4gICAgICBjaGVjayQxKHR5cGVvZiBmYWNlID09PSAnbnVtYmVyJyAmJiBmYWNlID09PSAoZmFjZSB8IDApICYmXHJcbiAgICAgICAgZmFjZSA+PSAwICYmIGZhY2UgPCA2LCAnaW52YWxpZCBmYWNlJyk7XHJcblxyXG4gICAgICB2YXIgeCA9IHhfIHwgMDtcclxuICAgICAgdmFyIHkgPSB5XyB8IDA7XHJcbiAgICAgIHZhciBsZXZlbCA9IGxldmVsXyB8IDA7XHJcblxyXG4gICAgICB2YXIgaW1hZ2VEYXRhID0gYWxsb2NJbWFnZSgpO1xyXG4gICAgICBjb3B5RmxhZ3MoaW1hZ2VEYXRhLCB0ZXh0dXJlKTtcclxuICAgICAgaW1hZ2VEYXRhLndpZHRoID0gMDtcclxuICAgICAgaW1hZ2VEYXRhLmhlaWdodCA9IDA7XHJcbiAgICAgIHBhcnNlSW1hZ2UoaW1hZ2VEYXRhLCBpbWFnZSk7XHJcbiAgICAgIGltYWdlRGF0YS53aWR0aCA9IGltYWdlRGF0YS53aWR0aCB8fCAoKHRleHR1cmUud2lkdGggPj4gbGV2ZWwpIC0geCk7XHJcbiAgICAgIGltYWdlRGF0YS5oZWlnaHQgPSBpbWFnZURhdGEuaGVpZ2h0IHx8ICgodGV4dHVyZS5oZWlnaHQgPj4gbGV2ZWwpIC0geSk7XHJcblxyXG4gICAgICBjaGVjayQxKFxyXG4gICAgICAgIHRleHR1cmUudHlwZSA9PT0gaW1hZ2VEYXRhLnR5cGUgJiZcclxuICAgICAgICB0ZXh0dXJlLmZvcm1hdCA9PT0gaW1hZ2VEYXRhLmZvcm1hdCAmJlxyXG4gICAgICAgIHRleHR1cmUuaW50ZXJuYWxmb3JtYXQgPT09IGltYWdlRGF0YS5pbnRlcm5hbGZvcm1hdCxcclxuICAgICAgICAnaW5jb21wYXRpYmxlIGZvcm1hdCBmb3IgdGV4dHVyZS5zdWJpbWFnZScpO1xyXG4gICAgICBjaGVjayQxKFxyXG4gICAgICAgIHggPj0gMCAmJiB5ID49IDAgJiZcclxuICAgICAgICB4ICsgaW1hZ2VEYXRhLndpZHRoIDw9IHRleHR1cmUud2lkdGggJiZcclxuICAgICAgICB5ICsgaW1hZ2VEYXRhLmhlaWdodCA8PSB0ZXh0dXJlLmhlaWdodCxcclxuICAgICAgICAndGV4dHVyZS5zdWJpbWFnZSB3cml0ZSBvdXQgb2YgYm91bmRzJyk7XHJcbiAgICAgIGNoZWNrJDEoXHJcbiAgICAgICAgdGV4dHVyZS5taXBtYXNrICYgKDEgPDwgbGV2ZWwpLFxyXG4gICAgICAgICdtaXNzaW5nIG1pcG1hcCBkYXRhJyk7XHJcbiAgICAgIGNoZWNrJDEoXHJcbiAgICAgICAgaW1hZ2VEYXRhLmRhdGEgfHwgaW1hZ2VEYXRhLmVsZW1lbnQgfHwgaW1hZ2VEYXRhLm5lZWRzQ29weSxcclxuICAgICAgICAnbWlzc2luZyBpbWFnZSBkYXRhJyk7XHJcblxyXG4gICAgICB0ZW1wQmluZCh0ZXh0dXJlKTtcclxuICAgICAgc2V0U3ViSW1hZ2UoaW1hZ2VEYXRhLCBHTF9URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1gkMSArIGZhY2UsIHgsIHksIGxldmVsKTtcclxuICAgICAgdGVtcFJlc3RvcmUoKTtcclxuXHJcbiAgICAgIGZyZWVJbWFnZShpbWFnZURhdGEpO1xyXG5cclxuICAgICAgcmV0dXJuIHJlZ2xUZXh0dXJlQ3ViZVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlc2l6ZSAocmFkaXVzXykge1xyXG4gICAgICB2YXIgcmFkaXVzID0gcmFkaXVzXyB8IDA7XHJcbiAgICAgIGlmIChyYWRpdXMgPT09IHRleHR1cmUud2lkdGgpIHtcclxuICAgICAgICByZXR1cm5cclxuICAgICAgfVxyXG5cclxuICAgICAgcmVnbFRleHR1cmVDdWJlLndpZHRoID0gdGV4dHVyZS53aWR0aCA9IHJhZGl1cztcclxuICAgICAgcmVnbFRleHR1cmVDdWJlLmhlaWdodCA9IHRleHR1cmUuaGVpZ2h0ID0gcmFkaXVzO1xyXG5cclxuICAgICAgdGVtcEJpbmQodGV4dHVyZSk7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjsgKytpKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IHRleHR1cmUubWlwbWFzayA+PiBqOyArK2opIHtcclxuICAgICAgICAgIGdsLnRleEltYWdlMkQoXHJcbiAgICAgICAgICAgIEdMX1RFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCQxICsgaSxcclxuICAgICAgICAgICAgaixcclxuICAgICAgICAgICAgdGV4dHVyZS5mb3JtYXQsXHJcbiAgICAgICAgICAgIHJhZGl1cyA+PiBqLFxyXG4gICAgICAgICAgICByYWRpdXMgPj4gaixcclxuICAgICAgICAgICAgMCxcclxuICAgICAgICAgICAgdGV4dHVyZS5mb3JtYXQsXHJcbiAgICAgICAgICAgIHRleHR1cmUudHlwZSxcclxuICAgICAgICAgICAgbnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHRlbXBSZXN0b3JlKCk7XHJcblxyXG4gICAgICBpZiAoY29uZmlnLnByb2ZpbGUpIHtcclxuICAgICAgICB0ZXh0dXJlLnN0YXRzLnNpemUgPSBnZXRUZXh0dXJlU2l6ZShcclxuICAgICAgICAgIHRleHR1cmUuaW50ZXJuYWxmb3JtYXQsXHJcbiAgICAgICAgICB0ZXh0dXJlLnR5cGUsXHJcbiAgICAgICAgICByZWdsVGV4dHVyZUN1YmUud2lkdGgsXHJcbiAgICAgICAgICByZWdsVGV4dHVyZUN1YmUuaGVpZ2h0LFxyXG4gICAgICAgICAgZmFsc2UsXHJcbiAgICAgICAgICB0cnVlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJlZ2xUZXh0dXJlQ3ViZVxyXG4gICAgfVxyXG5cclxuICAgIHJlZ2xUZXh0dXJlQ3ViZShhMCwgYTEsIGEyLCBhMywgYTQsIGE1KTtcclxuXHJcbiAgICByZWdsVGV4dHVyZUN1YmUuc3ViaW1hZ2UgPSBzdWJpbWFnZTtcclxuICAgIHJlZ2xUZXh0dXJlQ3ViZS5yZXNpemUgPSByZXNpemU7XHJcbiAgICByZWdsVGV4dHVyZUN1YmUuX3JlZ2xUeXBlID0gJ3RleHR1cmVDdWJlJztcclxuICAgIHJlZ2xUZXh0dXJlQ3ViZS5fdGV4dHVyZSA9IHRleHR1cmU7XHJcbiAgICBpZiAoY29uZmlnLnByb2ZpbGUpIHtcclxuICAgICAgcmVnbFRleHR1cmVDdWJlLnN0YXRzID0gdGV4dHVyZS5zdGF0cztcclxuICAgIH1cclxuICAgIHJlZ2xUZXh0dXJlQ3ViZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB0ZXh0dXJlLmRlY1JlZigpO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gcmVnbFRleHR1cmVDdWJlXHJcbiAgfVxyXG5cclxuICAvLyBDYWxsZWQgd2hlbiByZWdsIGlzIGRlc3Ryb3llZFxyXG4gIGZ1bmN0aW9uIGRlc3Ryb3lUZXh0dXJlcyAoKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVRleFVuaXRzOyArK2kpIHtcclxuICAgICAgZ2wuYWN0aXZlVGV4dHVyZShHTF9URVhUVVJFMCQxICsgaSk7XHJcbiAgICAgIGdsLmJpbmRUZXh0dXJlKEdMX1RFWFRVUkVfMkQkMSwgbnVsbCk7XHJcbiAgICAgIHRleHR1cmVVbml0c1tpXSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICB2YWx1ZXModGV4dHVyZVNldCkuZm9yRWFjaChkZXN0cm95KTtcclxuXHJcbiAgICBzdGF0cy5jdWJlQ291bnQgPSAwO1xyXG4gICAgc3RhdHMudGV4dHVyZUNvdW50ID0gMDtcclxuICB9XHJcblxyXG4gIGlmIChjb25maWcucHJvZmlsZSkge1xyXG4gICAgc3RhdHMuZ2V0VG90YWxUZXh0dXJlU2l6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHRvdGFsID0gMDtcclxuICAgICAgT2JqZWN0LmtleXModGV4dHVyZVNldCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgdG90YWwgKz0gdGV4dHVyZVNldFtrZXldLnN0YXRzLnNpemU7XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gdG90YWxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByZXN0b3JlVGV4dHVyZXMgKCkge1xyXG4gICAgdmFsdWVzKHRleHR1cmVTZXQpLmZvckVhY2goZnVuY3Rpb24gKHRleHR1cmUpIHtcclxuICAgICAgdGV4dHVyZS50ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG4gICAgICBnbC5iaW5kVGV4dHVyZSh0ZXh0dXJlLnRhcmdldCwgdGV4dHVyZS50ZXh0dXJlKTtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgKytpKSB7XHJcbiAgICAgICAgaWYgKCh0ZXh0dXJlLm1pcG1hc2sgJiAoMSA8PCBpKSkgPT09IDApIHtcclxuICAgICAgICAgIGNvbnRpbnVlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0ZXh0dXJlLnRhcmdldCA9PT0gR0xfVEVYVFVSRV8yRCQxKSB7XHJcbiAgICAgICAgICBnbC50ZXhJbWFnZTJEKEdMX1RFWFRVUkVfMkQkMSxcclxuICAgICAgICAgICAgaSxcclxuICAgICAgICAgICAgdGV4dHVyZS5pbnRlcm5hbGZvcm1hdCxcclxuICAgICAgICAgICAgdGV4dHVyZS53aWR0aCA+PiBpLFxyXG4gICAgICAgICAgICB0ZXh0dXJlLmhlaWdodCA+PiBpLFxyXG4gICAgICAgICAgICAwLFxyXG4gICAgICAgICAgICB0ZXh0dXJlLmludGVybmFsZm9ybWF0LFxyXG4gICAgICAgICAgICB0ZXh0dXJlLnR5cGUsXHJcbiAgICAgICAgICAgIG51bGwpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDY7ICsraikge1xyXG4gICAgICAgICAgICBnbC50ZXhJbWFnZTJEKEdMX1RFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCQxICsgaixcclxuICAgICAgICAgICAgICBpLFxyXG4gICAgICAgICAgICAgIHRleHR1cmUuaW50ZXJuYWxmb3JtYXQsXHJcbiAgICAgICAgICAgICAgdGV4dHVyZS53aWR0aCA+PiBpLFxyXG4gICAgICAgICAgICAgIHRleHR1cmUuaGVpZ2h0ID4+IGksXHJcbiAgICAgICAgICAgICAgMCxcclxuICAgICAgICAgICAgICB0ZXh0dXJlLmludGVybmFsZm9ybWF0LFxyXG4gICAgICAgICAgICAgIHRleHR1cmUudHlwZSxcclxuICAgICAgICAgICAgICBudWxsKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgc2V0VGV4SW5mbyh0ZXh0dXJlLnRleEluZm8sIHRleHR1cmUudGFyZ2V0KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGNyZWF0ZTJEOiBjcmVhdGVUZXh0dXJlMkQsXHJcbiAgICBjcmVhdGVDdWJlOiBjcmVhdGVUZXh0dXJlQ3ViZSxcclxuICAgIGNsZWFyOiBkZXN0cm95VGV4dHVyZXMsXHJcbiAgICBnZXRUZXh0dXJlOiBmdW5jdGlvbiAod3JhcHBlcikge1xyXG4gICAgICByZXR1cm4gbnVsbFxyXG4gICAgfSxcclxuICAgIHJlc3RvcmU6IHJlc3RvcmVUZXh0dXJlc1xyXG4gIH1cclxufVxyXG5cclxudmFyIEdMX1JFTkRFUkJVRkZFUiA9IDB4OEQ0MTtcclxuXHJcbnZhciBHTF9SR0JBNCQxID0gMHg4MDU2O1xyXG52YXIgR0xfUkdCNV9BMSQxID0gMHg4MDU3O1xyXG52YXIgR0xfUkdCNTY1JDEgPSAweDhENjI7XHJcbnZhciBHTF9ERVBUSF9DT01QT05FTlQxNiA9IDB4ODFBNTtcclxudmFyIEdMX1NURU5DSUxfSU5ERVg4ID0gMHg4RDQ4O1xyXG52YXIgR0xfREVQVEhfU1RFTkNJTCQxID0gMHg4NEY5O1xyXG5cclxudmFyIEdMX1NSR0I4X0FMUEhBOF9FWFQgPSAweDhDNDM7XHJcblxyXG52YXIgR0xfUkdCQTMyRl9FWFQgPSAweDg4MTQ7XHJcblxyXG52YXIgR0xfUkdCQTE2Rl9FWFQgPSAweDg4MUE7XHJcbnZhciBHTF9SR0IxNkZfRVhUID0gMHg4ODFCO1xyXG5cclxudmFyIEZPUk1BVF9TSVpFUyA9IFtdO1xyXG5cclxuRk9STUFUX1NJWkVTW0dMX1JHQkE0JDFdID0gMjtcclxuRk9STUFUX1NJWkVTW0dMX1JHQjVfQTEkMV0gPSAyO1xyXG5GT1JNQVRfU0laRVNbR0xfUkdCNTY1JDFdID0gMjtcclxuXHJcbkZPUk1BVF9TSVpFU1tHTF9ERVBUSF9DT01QT05FTlQxNl0gPSAyO1xyXG5GT1JNQVRfU0laRVNbR0xfU1RFTkNJTF9JTkRFWDhdID0gMTtcclxuRk9STUFUX1NJWkVTW0dMX0RFUFRIX1NURU5DSUwkMV0gPSA0O1xyXG5cclxuRk9STUFUX1NJWkVTW0dMX1NSR0I4X0FMUEhBOF9FWFRdID0gNDtcclxuRk9STUFUX1NJWkVTW0dMX1JHQkEzMkZfRVhUXSA9IDE2O1xyXG5GT1JNQVRfU0laRVNbR0xfUkdCQTE2Rl9FWFRdID0gODtcclxuRk9STUFUX1NJWkVTW0dMX1JHQjE2Rl9FWFRdID0gNjtcclxuXHJcbmZ1bmN0aW9uIGdldFJlbmRlcmJ1ZmZlclNpemUgKGZvcm1hdCwgd2lkdGgsIGhlaWdodCkge1xyXG4gIHJldHVybiBGT1JNQVRfU0laRVNbZm9ybWF0XSAqIHdpZHRoICogaGVpZ2h0XHJcbn1cclxuXHJcbnZhciB3cmFwUmVuZGVyYnVmZmVycyA9IGZ1bmN0aW9uIChnbCwgZXh0ZW5zaW9ucywgbGltaXRzLCBzdGF0cywgY29uZmlnKSB7XHJcbiAgdmFyIGZvcm1hdFR5cGVzID0ge1xyXG4gICAgJ3JnYmE0JzogR0xfUkdCQTQkMSxcclxuICAgICdyZ2I1NjUnOiBHTF9SR0I1NjUkMSxcclxuICAgICdyZ2I1IGExJzogR0xfUkdCNV9BMSQxLFxyXG4gICAgJ2RlcHRoJzogR0xfREVQVEhfQ09NUE9ORU5UMTYsXHJcbiAgICAnc3RlbmNpbCc6IEdMX1NURU5DSUxfSU5ERVg4LFxyXG4gICAgJ2RlcHRoIHN0ZW5jaWwnOiBHTF9ERVBUSF9TVEVOQ0lMJDFcclxuICB9O1xyXG5cclxuICBpZiAoZXh0ZW5zaW9ucy5leHRfc3JnYikge1xyXG4gICAgZm9ybWF0VHlwZXNbJ3NyZ2JhJ10gPSBHTF9TUkdCOF9BTFBIQThfRVhUO1xyXG4gIH1cclxuXHJcbiAgaWYgKGV4dGVuc2lvbnMuZXh0X2NvbG9yX2J1ZmZlcl9oYWxmX2Zsb2F0KSB7XHJcbiAgICBmb3JtYXRUeXBlc1sncmdiYTE2ZiddID0gR0xfUkdCQTE2Rl9FWFQ7XHJcbiAgICBmb3JtYXRUeXBlc1sncmdiMTZmJ10gPSBHTF9SR0IxNkZfRVhUO1xyXG4gIH1cclxuXHJcbiAgaWYgKGV4dGVuc2lvbnMud2ViZ2xfY29sb3JfYnVmZmVyX2Zsb2F0KSB7XHJcbiAgICBmb3JtYXRUeXBlc1sncmdiYTMyZiddID0gR0xfUkdCQTMyRl9FWFQ7XHJcbiAgfVxyXG5cclxuICB2YXIgZm9ybWF0VHlwZXNJbnZlcnQgPSBbXTtcclxuICBPYmplY3Qua2V5cyhmb3JtYXRUeXBlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICB2YXIgdmFsID0gZm9ybWF0VHlwZXNba2V5XTtcclxuICAgIGZvcm1hdFR5cGVzSW52ZXJ0W3ZhbF0gPSBrZXk7XHJcbiAgfSk7XHJcblxyXG4gIHZhciByZW5kZXJidWZmZXJDb3VudCA9IDA7XHJcbiAgdmFyIHJlbmRlcmJ1ZmZlclNldCA9IHt9O1xyXG5cclxuICBmdW5jdGlvbiBSRUdMUmVuZGVyYnVmZmVyIChyZW5kZXJidWZmZXIpIHtcclxuICAgIHRoaXMuaWQgPSByZW5kZXJidWZmZXJDb3VudCsrO1xyXG4gICAgdGhpcy5yZWZDb3VudCA9IDE7XHJcblxyXG4gICAgdGhpcy5yZW5kZXJidWZmZXIgPSByZW5kZXJidWZmZXI7XHJcblxyXG4gICAgdGhpcy5mb3JtYXQgPSBHTF9SR0JBNCQxO1xyXG4gICAgdGhpcy53aWR0aCA9IDA7XHJcbiAgICB0aGlzLmhlaWdodCA9IDA7XHJcblxyXG4gICAgaWYgKGNvbmZpZy5wcm9maWxlKSB7XHJcbiAgICAgIHRoaXMuc3RhdHMgPSB7c2l6ZTogMH07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBSRUdMUmVuZGVyYnVmZmVyLnByb3RvdHlwZS5kZWNSZWYgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAoLS10aGlzLnJlZkNvdW50IDw9IDApIHtcclxuICAgICAgZGVzdHJveSh0aGlzKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBkZXN0cm95IChyYikge1xyXG4gICAgdmFyIGhhbmRsZSA9IHJiLnJlbmRlcmJ1ZmZlcjtcclxuICAgIGNoZWNrJDEoaGFuZGxlLCAnbXVzdCBub3QgZG91YmxlIGRlc3Ryb3kgcmVuZGVyYnVmZmVyJyk7XHJcbiAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKEdMX1JFTkRFUkJVRkZFUiwgbnVsbCk7XHJcbiAgICBnbC5kZWxldGVSZW5kZXJidWZmZXIoaGFuZGxlKTtcclxuICAgIHJiLnJlbmRlcmJ1ZmZlciA9IG51bGw7XHJcbiAgICByYi5yZWZDb3VudCA9IDA7XHJcbiAgICBkZWxldGUgcmVuZGVyYnVmZmVyU2V0W3JiLmlkXTtcclxuICAgIHN0YXRzLnJlbmRlcmJ1ZmZlckNvdW50LS07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjcmVhdGVSZW5kZXJidWZmZXIgKGEsIGIpIHtcclxuICAgIHZhciByZW5kZXJidWZmZXIgPSBuZXcgUkVHTFJlbmRlcmJ1ZmZlcihnbC5jcmVhdGVSZW5kZXJidWZmZXIoKSk7XHJcbiAgICByZW5kZXJidWZmZXJTZXRbcmVuZGVyYnVmZmVyLmlkXSA9IHJlbmRlcmJ1ZmZlcjtcclxuICAgIHN0YXRzLnJlbmRlcmJ1ZmZlckNvdW50Kys7XHJcblxyXG4gICAgZnVuY3Rpb24gcmVnbFJlbmRlcmJ1ZmZlciAoYSwgYikge1xyXG4gICAgICB2YXIgdyA9IDA7XHJcbiAgICAgIHZhciBoID0gMDtcclxuICAgICAgdmFyIGZvcm1hdCA9IEdMX1JHQkE0JDE7XHJcblxyXG4gICAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnICYmIGEpIHtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IGE7XHJcbiAgICAgICAgaWYgKCdzaGFwZScgaW4gb3B0aW9ucykge1xyXG4gICAgICAgICAgdmFyIHNoYXBlID0gb3B0aW9ucy5zaGFwZTtcclxuICAgICAgICAgIGNoZWNrJDEoQXJyYXkuaXNBcnJheShzaGFwZSkgJiYgc2hhcGUubGVuZ3RoID49IDIsXHJcbiAgICAgICAgICAgICdpbnZhbGlkIHJlbmRlcmJ1ZmZlciBzaGFwZScpO1xyXG4gICAgICAgICAgdyA9IHNoYXBlWzBdIHwgMDtcclxuICAgICAgICAgIGggPSBzaGFwZVsxXSB8IDA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGlmICgncmFkaXVzJyBpbiBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHcgPSBoID0gb3B0aW9ucy5yYWRpdXMgfCAwO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKCd3aWR0aCcgaW4gb3B0aW9ucykge1xyXG4gICAgICAgICAgICB3ID0gb3B0aW9ucy53aWR0aCB8IDA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoJ2hlaWdodCcgaW4gb3B0aW9ucykge1xyXG4gICAgICAgICAgICBoID0gb3B0aW9ucy5oZWlnaHQgfCAwO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoJ2Zvcm1hdCcgaW4gb3B0aW9ucykge1xyXG4gICAgICAgICAgY2hlY2skMS5wYXJhbWV0ZXIob3B0aW9ucy5mb3JtYXQsIGZvcm1hdFR5cGVzLFxyXG4gICAgICAgICAgICAnaW52YWxpZCByZW5kZXJidWZmZXIgZm9ybWF0Jyk7XHJcbiAgICAgICAgICBmb3JtYXQgPSBmb3JtYXRUeXBlc1tvcHRpb25zLmZvcm1hdF07XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIHcgPSBhIHwgMDtcclxuICAgICAgICBpZiAodHlwZW9mIGIgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICBoID0gYiB8IDA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGggPSB3O1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmICghYSkge1xyXG4gICAgICAgIHcgPSBoID0gMTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjaGVjayQxLnJhaXNlKCdpbnZhbGlkIGFyZ3VtZW50cyB0byByZW5kZXJidWZmZXIgY29uc3RydWN0b3InKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gY2hlY2sgc2hhcGVcclxuICAgICAgY2hlY2skMShcclxuICAgICAgICB3ID4gMCAmJiBoID4gMCAmJlxyXG4gICAgICAgIHcgPD0gbGltaXRzLm1heFJlbmRlcmJ1ZmZlclNpemUgJiYgaCA8PSBsaW1pdHMubWF4UmVuZGVyYnVmZmVyU2l6ZSxcclxuICAgICAgICAnaW52YWxpZCByZW5kZXJidWZmZXIgc2l6ZScpO1xyXG5cclxuICAgICAgaWYgKHcgPT09IHJlbmRlcmJ1ZmZlci53aWR0aCAmJlxyXG4gICAgICAgICAgaCA9PT0gcmVuZGVyYnVmZmVyLmhlaWdodCAmJlxyXG4gICAgICAgICAgZm9ybWF0ID09PSByZW5kZXJidWZmZXIuZm9ybWF0KSB7XHJcbiAgICAgICAgcmV0dXJuXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJlZ2xSZW5kZXJidWZmZXIud2lkdGggPSByZW5kZXJidWZmZXIud2lkdGggPSB3O1xyXG4gICAgICByZWdsUmVuZGVyYnVmZmVyLmhlaWdodCA9IHJlbmRlcmJ1ZmZlci5oZWlnaHQgPSBoO1xyXG4gICAgICByZW5kZXJidWZmZXIuZm9ybWF0ID0gZm9ybWF0O1xyXG5cclxuICAgICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihHTF9SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlci5yZW5kZXJidWZmZXIpO1xyXG4gICAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKEdMX1JFTkRFUkJVRkZFUiwgZm9ybWF0LCB3LCBoKTtcclxuXHJcbiAgICAgIGNoZWNrJDEoXHJcbiAgICAgICAgZ2wuZ2V0RXJyb3IoKSA9PT0gMCxcclxuICAgICAgICAnaW52YWxpZCByZW5kZXIgYnVmZmVyIGZvcm1hdCcpO1xyXG5cclxuICAgICAgaWYgKGNvbmZpZy5wcm9maWxlKSB7XHJcbiAgICAgICAgcmVuZGVyYnVmZmVyLnN0YXRzLnNpemUgPSBnZXRSZW5kZXJidWZmZXJTaXplKHJlbmRlcmJ1ZmZlci5mb3JtYXQsIHJlbmRlcmJ1ZmZlci53aWR0aCwgcmVuZGVyYnVmZmVyLmhlaWdodCk7XHJcbiAgICAgIH1cclxuICAgICAgcmVnbFJlbmRlcmJ1ZmZlci5mb3JtYXQgPSBmb3JtYXRUeXBlc0ludmVydFtyZW5kZXJidWZmZXIuZm9ybWF0XTtcclxuXHJcbiAgICAgIHJldHVybiByZWdsUmVuZGVyYnVmZmVyXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVzaXplICh3XywgaF8pIHtcclxuICAgICAgdmFyIHcgPSB3XyB8IDA7XHJcbiAgICAgIHZhciBoID0gKGhfIHwgMCkgfHwgdztcclxuXHJcbiAgICAgIGlmICh3ID09PSByZW5kZXJidWZmZXIud2lkdGggJiYgaCA9PT0gcmVuZGVyYnVmZmVyLmhlaWdodCkge1xyXG4gICAgICAgIHJldHVybiByZWdsUmVuZGVyYnVmZmVyXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGNoZWNrIHNoYXBlXHJcbiAgICAgIGNoZWNrJDEoXHJcbiAgICAgICAgdyA+IDAgJiYgaCA+IDAgJiZcclxuICAgICAgICB3IDw9IGxpbWl0cy5tYXhSZW5kZXJidWZmZXJTaXplICYmIGggPD0gbGltaXRzLm1heFJlbmRlcmJ1ZmZlclNpemUsXHJcbiAgICAgICAgJ2ludmFsaWQgcmVuZGVyYnVmZmVyIHNpemUnKTtcclxuXHJcbiAgICAgIHJlZ2xSZW5kZXJidWZmZXIud2lkdGggPSByZW5kZXJidWZmZXIud2lkdGggPSB3O1xyXG4gICAgICByZWdsUmVuZGVyYnVmZmVyLmhlaWdodCA9IHJlbmRlcmJ1ZmZlci5oZWlnaHQgPSBoO1xyXG5cclxuICAgICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihHTF9SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlci5yZW5kZXJidWZmZXIpO1xyXG4gICAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKEdMX1JFTkRFUkJVRkZFUiwgcmVuZGVyYnVmZmVyLmZvcm1hdCwgdywgaCk7XHJcblxyXG4gICAgICBjaGVjayQxKFxyXG4gICAgICAgIGdsLmdldEVycm9yKCkgPT09IDAsXHJcbiAgICAgICAgJ2ludmFsaWQgcmVuZGVyIGJ1ZmZlciBmb3JtYXQnKTtcclxuXHJcbiAgICAgIC8vIGFsc28sIHJlY29tcHV0ZSBzaXplLlxyXG4gICAgICBpZiAoY29uZmlnLnByb2ZpbGUpIHtcclxuICAgICAgICByZW5kZXJidWZmZXIuc3RhdHMuc2l6ZSA9IGdldFJlbmRlcmJ1ZmZlclNpemUoXHJcbiAgICAgICAgICByZW5kZXJidWZmZXIuZm9ybWF0LCByZW5kZXJidWZmZXIud2lkdGgsIHJlbmRlcmJ1ZmZlci5oZWlnaHQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcmVnbFJlbmRlcmJ1ZmZlclxyXG4gICAgfVxyXG5cclxuICAgIHJlZ2xSZW5kZXJidWZmZXIoYSwgYik7XHJcblxyXG4gICAgcmVnbFJlbmRlcmJ1ZmZlci5yZXNpemUgPSByZXNpemU7XHJcbiAgICByZWdsUmVuZGVyYnVmZmVyLl9yZWdsVHlwZSA9ICdyZW5kZXJidWZmZXInO1xyXG4gICAgcmVnbFJlbmRlcmJ1ZmZlci5fcmVuZGVyYnVmZmVyID0gcmVuZGVyYnVmZmVyO1xyXG4gICAgaWYgKGNvbmZpZy5wcm9maWxlKSB7XHJcbiAgICAgIHJlZ2xSZW5kZXJidWZmZXIuc3RhdHMgPSByZW5kZXJidWZmZXIuc3RhdHM7XHJcbiAgICB9XHJcbiAgICByZWdsUmVuZGVyYnVmZmVyLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJlbmRlcmJ1ZmZlci5kZWNSZWYoKTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIHJlZ2xSZW5kZXJidWZmZXJcclxuICB9XHJcblxyXG4gIGlmIChjb25maWcucHJvZmlsZSkge1xyXG4gICAgc3RhdHMuZ2V0VG90YWxSZW5kZXJidWZmZXJTaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgdG90YWwgPSAwO1xyXG4gICAgICBPYmplY3Qua2V5cyhyZW5kZXJidWZmZXJTZXQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIHRvdGFsICs9IHJlbmRlcmJ1ZmZlclNldFtrZXldLnN0YXRzLnNpemU7XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gdG90YWxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByZXN0b3JlUmVuZGVyYnVmZmVycyAoKSB7XHJcbiAgICB2YWx1ZXMocmVuZGVyYnVmZmVyU2V0KS5mb3JFYWNoKGZ1bmN0aW9uIChyYikge1xyXG4gICAgICByYi5yZW5kZXJidWZmZXIgPSBnbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcclxuICAgICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihHTF9SRU5ERVJCVUZGRVIsIHJiLnJlbmRlcmJ1ZmZlcik7XHJcbiAgICAgIGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoR0xfUkVOREVSQlVGRkVSLCByYi5mb3JtYXQsIHJiLndpZHRoLCByYi5oZWlnaHQpO1xyXG4gICAgfSk7XHJcbiAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKEdMX1JFTkRFUkJVRkZFUiwgbnVsbCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgY3JlYXRlOiBjcmVhdGVSZW5kZXJidWZmZXIsXHJcbiAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YWx1ZXMocmVuZGVyYnVmZmVyU2V0KS5mb3JFYWNoKGRlc3Ryb3kpO1xyXG4gICAgfSxcclxuICAgIHJlc3RvcmU6IHJlc3RvcmVSZW5kZXJidWZmZXJzXHJcbiAgfVxyXG59O1xyXG5cclxuLy8gV2Ugc3RvcmUgdGhlc2UgY29uc3RhbnRzIHNvIHRoYXQgdGhlIG1pbmlmaWVyIGNhbiBpbmxpbmUgdGhlbVxyXG52YXIgR0xfRlJBTUVCVUZGRVIkMSA9IDB4OEQ0MDtcclxudmFyIEdMX1JFTkRFUkJVRkZFUiQxID0gMHg4RDQxO1xyXG5cclxudmFyIEdMX1RFWFRVUkVfMkQkMiA9IDB4MERFMTtcclxudmFyIEdMX1RFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCQyID0gMHg4NTE1O1xyXG5cclxudmFyIEdMX0NPTE9SX0FUVEFDSE1FTlQwJDEgPSAweDhDRTA7XHJcbnZhciBHTF9ERVBUSF9BVFRBQ0hNRU5UID0gMHg4RDAwO1xyXG52YXIgR0xfU1RFTkNJTF9BVFRBQ0hNRU5UID0gMHg4RDIwO1xyXG52YXIgR0xfREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5UID0gMHg4MjFBO1xyXG5cclxudmFyIEdMX0ZSQU1FQlVGRkVSX0NPTVBMRVRFJDEgPSAweDhDRDU7XHJcbnZhciBHTF9GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0FUVEFDSE1FTlQgPSAweDhDRDY7XHJcbnZhciBHTF9GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX01JU1NJTkdfQVRUQUNITUVOVCA9IDB4OENENztcclxudmFyIEdMX0ZSQU1FQlVGRkVSX0lOQ09NUExFVEVfRElNRU5TSU9OUyA9IDB4OENEOTtcclxudmFyIEdMX0ZSQU1FQlVGRkVSX1VOU1VQUE9SVEVEID0gMHg4Q0REO1xyXG5cclxudmFyIEdMX0hBTEZfRkxPQVRfT0VTJDIgPSAweDhENjE7XHJcbnZhciBHTF9VTlNJR05FRF9CWVRFJDYgPSAweDE0MDE7XHJcbnZhciBHTF9GTE9BVCQ1ID0gMHgxNDA2O1xyXG5cclxudmFyIEdMX1JHQiQxID0gMHgxOTA3O1xyXG52YXIgR0xfUkdCQSQyID0gMHgxOTA4O1xyXG5cclxudmFyIEdMX0RFUFRIX0NPTVBPTkVOVCQxID0gMHgxOTAyO1xyXG5cclxudmFyIGNvbG9yVGV4dHVyZUZvcm1hdEVudW1zID0gW1xyXG4gIEdMX1JHQiQxLFxyXG4gIEdMX1JHQkEkMlxyXG5dO1xyXG5cclxuLy8gZm9yIGV2ZXJ5IHRleHR1cmUgZm9ybWF0LCBzdG9yZVxyXG4vLyB0aGUgbnVtYmVyIG9mIGNoYW5uZWxzXHJcbnZhciB0ZXh0dXJlRm9ybWF0Q2hhbm5lbHMgPSBbXTtcclxudGV4dHVyZUZvcm1hdENoYW5uZWxzW0dMX1JHQkEkMl0gPSA0O1xyXG50ZXh0dXJlRm9ybWF0Q2hhbm5lbHNbR0xfUkdCJDFdID0gMztcclxuXHJcbi8vIGZvciBldmVyeSB0ZXh0dXJlIHR5cGUsIHN0b3JlXHJcbi8vIHRoZSBzaXplIGluIGJ5dGVzLlxyXG52YXIgdGV4dHVyZVR5cGVTaXplcyA9IFtdO1xyXG50ZXh0dXJlVHlwZVNpemVzW0dMX1VOU0lHTkVEX0JZVEUkNl0gPSAxO1xyXG50ZXh0dXJlVHlwZVNpemVzW0dMX0ZMT0FUJDVdID0gNDtcclxudGV4dHVyZVR5cGVTaXplc1tHTF9IQUxGX0ZMT0FUX09FUyQyXSA9IDI7XHJcblxyXG52YXIgR0xfUkdCQTQkMiA9IDB4ODA1NjtcclxudmFyIEdMX1JHQjVfQTEkMiA9IDB4ODA1NztcclxudmFyIEdMX1JHQjU2NSQyID0gMHg4RDYyO1xyXG52YXIgR0xfREVQVEhfQ09NUE9ORU5UMTYkMSA9IDB4ODFBNTtcclxudmFyIEdMX1NURU5DSUxfSU5ERVg4JDEgPSAweDhENDg7XHJcbnZhciBHTF9ERVBUSF9TVEVOQ0lMJDIgPSAweDg0Rjk7XHJcblxyXG52YXIgR0xfU1JHQjhfQUxQSEE4X0VYVCQxID0gMHg4QzQzO1xyXG5cclxudmFyIEdMX1JHQkEzMkZfRVhUJDEgPSAweDg4MTQ7XHJcblxyXG52YXIgR0xfUkdCQTE2Rl9FWFQkMSA9IDB4ODgxQTtcclxudmFyIEdMX1JHQjE2Rl9FWFQkMSA9IDB4ODgxQjtcclxuXHJcbnZhciBjb2xvclJlbmRlcmJ1ZmZlckZvcm1hdEVudW1zID0gW1xyXG4gIEdMX1JHQkE0JDIsXHJcbiAgR0xfUkdCNV9BMSQyLFxyXG4gIEdMX1JHQjU2NSQyLFxyXG4gIEdMX1NSR0I4X0FMUEhBOF9FWFQkMSxcclxuICBHTF9SR0JBMTZGX0VYVCQxLFxyXG4gIEdMX1JHQjE2Rl9FWFQkMSxcclxuICBHTF9SR0JBMzJGX0VYVCQxXHJcbl07XHJcblxyXG52YXIgc3RhdHVzQ29kZSA9IHt9O1xyXG5zdGF0dXNDb2RlW0dMX0ZSQU1FQlVGRkVSX0NPTVBMRVRFJDFdID0gJ2NvbXBsZXRlJztcclxuc3RhdHVzQ29kZVtHTF9GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0FUVEFDSE1FTlRdID0gJ2luY29tcGxldGUgYXR0YWNobWVudCc7XHJcbnN0YXR1c0NvZGVbR0xfRlJBTUVCVUZGRVJfSU5DT01QTEVURV9ESU1FTlNJT05TXSA9ICdpbmNvbXBsZXRlIGRpbWVuc2lvbnMnO1xyXG5zdGF0dXNDb2RlW0dMX0ZSQU1FQlVGRkVSX0lOQ09NUExFVEVfTUlTU0lOR19BVFRBQ0hNRU5UXSA9ICdpbmNvbXBsZXRlLCBtaXNzaW5nIGF0dGFjaG1lbnQnO1xyXG5zdGF0dXNDb2RlW0dMX0ZSQU1FQlVGRkVSX1VOU1VQUE9SVEVEXSA9ICd1bnN1cHBvcnRlZCc7XHJcblxyXG5mdW5jdGlvbiB3cmFwRkJPU3RhdGUgKFxyXG4gIGdsLFxyXG4gIGV4dGVuc2lvbnMsXHJcbiAgbGltaXRzLFxyXG4gIHRleHR1cmVTdGF0ZSxcclxuICByZW5kZXJidWZmZXJTdGF0ZSxcclxuICBzdGF0cykge1xyXG4gIHZhciBmcmFtZWJ1ZmZlclN0YXRlID0ge1xyXG4gICAgY3VyOiBudWxsLFxyXG4gICAgbmV4dDogbnVsbCxcclxuICAgIGRpcnR5OiBmYWxzZSxcclxuICAgIHNldEZCTzogbnVsbFxyXG4gIH07XHJcblxyXG4gIHZhciBjb2xvclRleHR1cmVGb3JtYXRzID0gWydyZ2JhJ107XHJcbiAgdmFyIGNvbG9yUmVuZGVyYnVmZmVyRm9ybWF0cyA9IFsncmdiYTQnLCAncmdiNTY1JywgJ3JnYjUgYTEnXTtcclxuXHJcbiAgaWYgKGV4dGVuc2lvbnMuZXh0X3NyZ2IpIHtcclxuICAgIGNvbG9yUmVuZGVyYnVmZmVyRm9ybWF0cy5wdXNoKCdzcmdiYScpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGV4dGVuc2lvbnMuZXh0X2NvbG9yX2J1ZmZlcl9oYWxmX2Zsb2F0KSB7XHJcbiAgICBjb2xvclJlbmRlcmJ1ZmZlckZvcm1hdHMucHVzaCgncmdiYTE2ZicsICdyZ2IxNmYnKTtcclxuICB9XHJcblxyXG4gIGlmIChleHRlbnNpb25zLndlYmdsX2NvbG9yX2J1ZmZlcl9mbG9hdCkge1xyXG4gICAgY29sb3JSZW5kZXJidWZmZXJGb3JtYXRzLnB1c2goJ3JnYmEzMmYnKTtcclxuICB9XHJcblxyXG4gIHZhciBjb2xvclR5cGVzID0gWyd1aW50OCddO1xyXG4gIGlmIChleHRlbnNpb25zLm9lc190ZXh0dXJlX2hhbGZfZmxvYXQpIHtcclxuICAgIGNvbG9yVHlwZXMucHVzaCgnaGFsZiBmbG9hdCcsICdmbG9hdDE2Jyk7XHJcbiAgfVxyXG4gIGlmIChleHRlbnNpb25zLm9lc190ZXh0dXJlX2Zsb2F0KSB7XHJcbiAgICBjb2xvclR5cGVzLnB1c2goJ2Zsb2F0JywgJ2Zsb2F0MzInKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIEZyYW1lYnVmZmVyQXR0YWNobWVudCAodGFyZ2V0LCB0ZXh0dXJlLCByZW5kZXJidWZmZXIpIHtcclxuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZTtcclxuICAgIHRoaXMucmVuZGVyYnVmZmVyID0gcmVuZGVyYnVmZmVyO1xyXG5cclxuICAgIHZhciB3ID0gMDtcclxuICAgIHZhciBoID0gMDtcclxuICAgIGlmICh0ZXh0dXJlKSB7XHJcbiAgICAgIHcgPSB0ZXh0dXJlLndpZHRoO1xyXG4gICAgICBoID0gdGV4dHVyZS5oZWlnaHQ7XHJcbiAgICB9IGVsc2UgaWYgKHJlbmRlcmJ1ZmZlcikge1xyXG4gICAgICB3ID0gcmVuZGVyYnVmZmVyLndpZHRoO1xyXG4gICAgICBoID0gcmVuZGVyYnVmZmVyLmhlaWdodDtcclxuICAgIH1cclxuICAgIHRoaXMud2lkdGggPSB3O1xyXG4gICAgdGhpcy5oZWlnaHQgPSBoO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZGVjUmVmIChhdHRhY2htZW50KSB7XHJcbiAgICBpZiAoYXR0YWNobWVudCkge1xyXG4gICAgICBpZiAoYXR0YWNobWVudC50ZXh0dXJlKSB7XHJcbiAgICAgICAgYXR0YWNobWVudC50ZXh0dXJlLl90ZXh0dXJlLmRlY1JlZigpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChhdHRhY2htZW50LnJlbmRlcmJ1ZmZlcikge1xyXG4gICAgICAgIGF0dGFjaG1lbnQucmVuZGVyYnVmZmVyLl9yZW5kZXJidWZmZXIuZGVjUmVmKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGluY1JlZkFuZENoZWNrU2hhcGUgKGF0dGFjaG1lbnQsIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgIGlmICghYXR0YWNobWVudCkge1xyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuICAgIGlmIChhdHRhY2htZW50LnRleHR1cmUpIHtcclxuICAgICAgdmFyIHRleHR1cmUgPSBhdHRhY2htZW50LnRleHR1cmUuX3RleHR1cmU7XHJcbiAgICAgIHZhciB0dyA9IE1hdGgubWF4KDEsIHRleHR1cmUud2lkdGgpO1xyXG4gICAgICB2YXIgdGggPSBNYXRoLm1heCgxLCB0ZXh0dXJlLmhlaWdodCk7XHJcbiAgICAgIGNoZWNrJDEodHcgPT09IHdpZHRoICYmIHRoID09PSBoZWlnaHQsXHJcbiAgICAgICAgJ2luY29uc2lzdGVudCB3aWR0aC9oZWlnaHQgZm9yIHN1cHBsaWVkIHRleHR1cmUnKTtcclxuICAgICAgdGV4dHVyZS5yZWZDb3VudCArPSAxO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFyIHJlbmRlcmJ1ZmZlciA9IGF0dGFjaG1lbnQucmVuZGVyYnVmZmVyLl9yZW5kZXJidWZmZXI7XHJcbiAgICAgIGNoZWNrJDEoXHJcbiAgICAgICAgcmVuZGVyYnVmZmVyLndpZHRoID09PSB3aWR0aCAmJiByZW5kZXJidWZmZXIuaGVpZ2h0ID09PSBoZWlnaHQsXHJcbiAgICAgICAgJ2luY29uc2lzdGVudCB3aWR0aC9oZWlnaHQgZm9yIHJlbmRlcmJ1ZmZlcicpO1xyXG4gICAgICByZW5kZXJidWZmZXIucmVmQ291bnQgKz0gMTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGF0dGFjaCAobG9jYXRpb24sIGF0dGFjaG1lbnQpIHtcclxuICAgIGlmIChhdHRhY2htZW50KSB7XHJcbiAgICAgIGlmIChhdHRhY2htZW50LnRleHR1cmUpIHtcclxuICAgICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChcclxuICAgICAgICAgIEdMX0ZSQU1FQlVGRkVSJDEsXHJcbiAgICAgICAgICBsb2NhdGlvbixcclxuICAgICAgICAgIGF0dGFjaG1lbnQudGFyZ2V0LFxyXG4gICAgICAgICAgYXR0YWNobWVudC50ZXh0dXJlLl90ZXh0dXJlLnRleHR1cmUsXHJcbiAgICAgICAgICAwKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihcclxuICAgICAgICAgIEdMX0ZSQU1FQlVGRkVSJDEsXHJcbiAgICAgICAgICBsb2NhdGlvbixcclxuICAgICAgICAgIEdMX1JFTkRFUkJVRkZFUiQxLFxyXG4gICAgICAgICAgYXR0YWNobWVudC5yZW5kZXJidWZmZXIuX3JlbmRlcmJ1ZmZlci5yZW5kZXJidWZmZXIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBwYXJzZUF0dGFjaG1lbnQgKGF0dGFjaG1lbnQpIHtcclxuICAgIHZhciB0YXJnZXQgPSBHTF9URVhUVVJFXzJEJDI7XHJcbiAgICB2YXIgdGV4dHVyZSA9IG51bGw7XHJcbiAgICB2YXIgcmVuZGVyYnVmZmVyID0gbnVsbDtcclxuXHJcbiAgICB2YXIgZGF0YSA9IGF0dGFjaG1lbnQ7XHJcbiAgICBpZiAodHlwZW9mIGF0dGFjaG1lbnQgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgIGRhdGEgPSBhdHRhY2htZW50LmRhdGE7XHJcbiAgICAgIGlmICgndGFyZ2V0JyBpbiBhdHRhY2htZW50KSB7XHJcbiAgICAgICAgdGFyZ2V0ID0gYXR0YWNobWVudC50YXJnZXQgfCAwO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY2hlY2skMS50eXBlKGRhdGEsICdmdW5jdGlvbicsICdpbnZhbGlkIGF0dGFjaG1lbnQgZGF0YScpO1xyXG5cclxuICAgIHZhciB0eXBlID0gZGF0YS5fcmVnbFR5cGU7XHJcbiAgICBpZiAodHlwZSA9PT0gJ3RleHR1cmUyZCcpIHtcclxuICAgICAgdGV4dHVyZSA9IGRhdGE7XHJcbiAgICAgIGNoZWNrJDEodGFyZ2V0ID09PSBHTF9URVhUVVJFXzJEJDIpO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAndGV4dHVyZUN1YmUnKSB7XHJcbiAgICAgIHRleHR1cmUgPSBkYXRhO1xyXG4gICAgICBjaGVjayQxKFxyXG4gICAgICAgIHRhcmdldCA+PSBHTF9URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1gkMiAmJlxyXG4gICAgICAgIHRhcmdldCA8IEdMX1RFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCQyICsgNixcclxuICAgICAgICAnaW52YWxpZCBjdWJlIG1hcCB0YXJnZXQnKTtcclxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3JlbmRlcmJ1ZmZlcicpIHtcclxuICAgICAgcmVuZGVyYnVmZmVyID0gZGF0YTtcclxuICAgICAgdGFyZ2V0ID0gR0xfUkVOREVSQlVGRkVSJDE7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjaGVjayQxLnJhaXNlKCdpbnZhbGlkIHJlZ2wgb2JqZWN0IGZvciBhdHRhY2htZW50Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5ldyBGcmFtZWJ1ZmZlckF0dGFjaG1lbnQodGFyZ2V0LCB0ZXh0dXJlLCByZW5kZXJidWZmZXIpXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBhbGxvY0F0dGFjaG1lbnQgKFxyXG4gICAgd2lkdGgsXHJcbiAgICBoZWlnaHQsXHJcbiAgICBpc1RleHR1cmUsXHJcbiAgICBmb3JtYXQsXHJcbiAgICB0eXBlKSB7XHJcbiAgICBpZiAoaXNUZXh0dXJlKSB7XHJcbiAgICAgIHZhciB0ZXh0dXJlID0gdGV4dHVyZVN0YXRlLmNyZWF0ZTJEKHtcclxuICAgICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgICAgZm9ybWF0OiBmb3JtYXQsXHJcbiAgICAgICAgdHlwZTogdHlwZVxyXG4gICAgICB9KTtcclxuICAgICAgdGV4dHVyZS5fdGV4dHVyZS5yZWZDb3VudCA9IDA7XHJcbiAgICAgIHJldHVybiBuZXcgRnJhbWVidWZmZXJBdHRhY2htZW50KEdMX1RFWFRVUkVfMkQkMiwgdGV4dHVyZSwgbnVsbClcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhciByYiA9IHJlbmRlcmJ1ZmZlclN0YXRlLmNyZWF0ZSh7XHJcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxyXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxyXG4gICAgICAgIGZvcm1hdDogZm9ybWF0XHJcbiAgICAgIH0pO1xyXG4gICAgICByYi5fcmVuZGVyYnVmZmVyLnJlZkNvdW50ID0gMDtcclxuICAgICAgcmV0dXJuIG5ldyBGcmFtZWJ1ZmZlckF0dGFjaG1lbnQoR0xfUkVOREVSQlVGRkVSJDEsIG51bGwsIHJiKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdW53cmFwQXR0YWNobWVudCAoYXR0YWNobWVudCkge1xyXG4gICAgcmV0dXJuIGF0dGFjaG1lbnQgJiYgKGF0dGFjaG1lbnQudGV4dHVyZSB8fCBhdHRhY2htZW50LnJlbmRlcmJ1ZmZlcilcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlc2l6ZUF0dGFjaG1lbnQgKGF0dGFjaG1lbnQsIHcsIGgpIHtcclxuICAgIGlmIChhdHRhY2htZW50KSB7XHJcbiAgICAgIGlmIChhdHRhY2htZW50LnRleHR1cmUpIHtcclxuICAgICAgICBhdHRhY2htZW50LnRleHR1cmUucmVzaXplKHcsIGgpO1xyXG4gICAgICB9IGVsc2UgaWYgKGF0dGFjaG1lbnQucmVuZGVyYnVmZmVyKSB7XHJcbiAgICAgICAgYXR0YWNobWVudC5yZW5kZXJidWZmZXIucmVzaXplKHcsIGgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB2YXIgZnJhbWVidWZmZXJDb3VudCA9IDA7XHJcbiAgdmFyIGZyYW1lYnVmZmVyU2V0ID0ge307XHJcblxyXG4gIGZ1bmN0aW9uIFJFR0xGcmFtZWJ1ZmZlciAoKSB7XHJcbiAgICB0aGlzLmlkID0gZnJhbWVidWZmZXJDb3VudCsrO1xyXG4gICAgZnJhbWVidWZmZXJTZXRbdGhpcy5pZF0gPSB0aGlzO1xyXG5cclxuICAgIHRoaXMuZnJhbWVidWZmZXIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xyXG4gICAgdGhpcy53aWR0aCA9IDA7XHJcbiAgICB0aGlzLmhlaWdodCA9IDA7XHJcblxyXG4gICAgdGhpcy5jb2xvckF0dGFjaG1lbnRzID0gW107XHJcbiAgICB0aGlzLmRlcHRoQXR0YWNobWVudCA9IG51bGw7XHJcbiAgICB0aGlzLnN0ZW5jaWxBdHRhY2htZW50ID0gbnVsbDtcclxuICAgIHRoaXMuZGVwdGhTdGVuY2lsQXR0YWNobWVudCA9IG51bGw7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBkZWNGQk9SZWZzIChmcmFtZWJ1ZmZlcikge1xyXG4gICAgZnJhbWVidWZmZXIuY29sb3JBdHRhY2htZW50cy5mb3JFYWNoKGRlY1JlZik7XHJcbiAgICBkZWNSZWYoZnJhbWVidWZmZXIuZGVwdGhBdHRhY2htZW50KTtcclxuICAgIGRlY1JlZihmcmFtZWJ1ZmZlci5zdGVuY2lsQXR0YWNobWVudCk7XHJcbiAgICBkZWNSZWYoZnJhbWVidWZmZXIuZGVwdGhTdGVuY2lsQXR0YWNobWVudCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBkZXN0cm95IChmcmFtZWJ1ZmZlcikge1xyXG4gICAgdmFyIGhhbmRsZSA9IGZyYW1lYnVmZmVyLmZyYW1lYnVmZmVyO1xyXG4gICAgY2hlY2skMShoYW5kbGUsICdtdXN0IG5vdCBkb3VibGUgZGVzdHJveSBmcmFtZWJ1ZmZlcicpO1xyXG4gICAgZ2wuZGVsZXRlRnJhbWVidWZmZXIoaGFuZGxlKTtcclxuICAgIGZyYW1lYnVmZmVyLmZyYW1lYnVmZmVyID0gbnVsbDtcclxuICAgIHN0YXRzLmZyYW1lYnVmZmVyQ291bnQtLTtcclxuICAgIGRlbGV0ZSBmcmFtZWJ1ZmZlclNldFtmcmFtZWJ1ZmZlci5pZF07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB1cGRhdGVGcmFtZWJ1ZmZlciAoZnJhbWVidWZmZXIpIHtcclxuICAgIHZhciBpO1xyXG5cclxuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihHTF9GUkFNRUJVRkZFUiQxLCBmcmFtZWJ1ZmZlci5mcmFtZWJ1ZmZlcik7XHJcbiAgICB2YXIgY29sb3JBdHRhY2htZW50cyA9IGZyYW1lYnVmZmVyLmNvbG9yQXR0YWNobWVudHM7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgY29sb3JBdHRhY2htZW50cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICBhdHRhY2goR0xfQ09MT1JfQVRUQUNITUVOVDAkMSArIGksIGNvbG9yQXR0YWNobWVudHNbaV0pO1xyXG4gICAgfVxyXG4gICAgZm9yIChpID0gY29sb3JBdHRhY2htZW50cy5sZW5ndGg7IGkgPCBsaW1pdHMubWF4Q29sb3JBdHRhY2htZW50czsgKytpKSB7XHJcbiAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKFxyXG4gICAgICAgIEdMX0ZSQU1FQlVGRkVSJDEsXHJcbiAgICAgICAgR0xfQ09MT1JfQVRUQUNITUVOVDAkMSArIGksXHJcbiAgICAgICAgR0xfVEVYVFVSRV8yRCQyLFxyXG4gICAgICAgIG51bGwsXHJcbiAgICAgICAgMCk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoXHJcbiAgICAgIEdMX0ZSQU1FQlVGRkVSJDEsXHJcbiAgICAgIEdMX0RFUFRIX1NURU5DSUxfQVRUQUNITUVOVCxcclxuICAgICAgR0xfVEVYVFVSRV8yRCQyLFxyXG4gICAgICBudWxsLFxyXG4gICAgICAwKTtcclxuICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKFxyXG4gICAgICBHTF9GUkFNRUJVRkZFUiQxLFxyXG4gICAgICBHTF9ERVBUSF9BVFRBQ0hNRU5ULFxyXG4gICAgICBHTF9URVhUVVJFXzJEJDIsXHJcbiAgICAgIG51bGwsXHJcbiAgICAgIDApO1xyXG4gICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoXHJcbiAgICAgIEdMX0ZSQU1FQlVGRkVSJDEsXHJcbiAgICAgIEdMX1NURU5DSUxfQVRUQUNITUVOVCxcclxuICAgICAgR0xfVEVYVFVSRV8yRCQyLFxyXG4gICAgICBudWxsLFxyXG4gICAgICAwKTtcclxuXHJcbiAgICBhdHRhY2goR0xfREVQVEhfQVRUQUNITUVOVCwgZnJhbWVidWZmZXIuZGVwdGhBdHRhY2htZW50KTtcclxuICAgIGF0dGFjaChHTF9TVEVOQ0lMX0FUVEFDSE1FTlQsIGZyYW1lYnVmZmVyLnN0ZW5jaWxBdHRhY2htZW50KTtcclxuICAgIGF0dGFjaChHTF9ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsIGZyYW1lYnVmZmVyLmRlcHRoU3RlbmNpbEF0dGFjaG1lbnQpO1xyXG5cclxuICAgIC8vIENoZWNrIHN0YXR1cyBjb2RlXHJcbiAgICB2YXIgc3RhdHVzID0gZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyhHTF9GUkFNRUJVRkZFUiQxKTtcclxuICAgIGlmIChzdGF0dXMgIT09IEdMX0ZSQU1FQlVGRkVSX0NPTVBMRVRFJDEpIHtcclxuICAgICAgY2hlY2skMS5yYWlzZSgnZnJhbWVidWZmZXIgY29uZmlndXJhdGlvbiBub3Qgc3VwcG9ydGVkLCBzdGF0dXMgPSAnICtcclxuICAgICAgICBzdGF0dXNDb2RlW3N0YXR1c10pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoR0xfRlJBTUVCVUZGRVIkMSwgZnJhbWVidWZmZXJTdGF0ZS5uZXh0ID8gZnJhbWVidWZmZXJTdGF0ZS5uZXh0LmZyYW1lYnVmZmVyIDogbnVsbCk7XHJcbiAgICBmcmFtZWJ1ZmZlclN0YXRlLmN1ciA9IGZyYW1lYnVmZmVyU3RhdGUubmV4dDtcclxuXHJcbiAgICAvLyBGSVhNRTogQ2xlYXIgZXJyb3IgY29kZSBoZXJlLiAgVGhpcyBpcyBhIHdvcmsgYXJvdW5kIGZvciBhIGJ1ZyBpblxyXG4gICAgLy8gaGVhZGxlc3MtZ2xcclxuICAgIGdsLmdldEVycm9yKCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjcmVhdGVGQk8gKGEwLCBhMSkge1xyXG4gICAgdmFyIGZyYW1lYnVmZmVyID0gbmV3IFJFR0xGcmFtZWJ1ZmZlcigpO1xyXG4gICAgc3RhdHMuZnJhbWVidWZmZXJDb3VudCsrO1xyXG5cclxuICAgIGZ1bmN0aW9uIHJlZ2xGcmFtZWJ1ZmZlciAoYSwgYikge1xyXG4gICAgICB2YXIgaTtcclxuXHJcbiAgICAgIGNoZWNrJDEoZnJhbWVidWZmZXJTdGF0ZS5uZXh0ICE9PSBmcmFtZWJ1ZmZlcixcclxuICAgICAgICAnY2FuIG5vdCB1cGRhdGUgZnJhbWVidWZmZXIgd2hpY2ggaXMgY3VycmVudGx5IGluIHVzZScpO1xyXG5cclxuICAgICAgdmFyIGV4dERyYXdCdWZmZXJzID0gZXh0ZW5zaW9ucy53ZWJnbF9kcmF3X2J1ZmZlcnM7XHJcblxyXG4gICAgICB2YXIgd2lkdGggPSAwO1xyXG4gICAgICB2YXIgaGVpZ2h0ID0gMDtcclxuXHJcbiAgICAgIHZhciBuZWVkc0RlcHRoID0gdHJ1ZTtcclxuICAgICAgdmFyIG5lZWRzU3RlbmNpbCA9IHRydWU7XHJcblxyXG4gICAgICB2YXIgY29sb3JCdWZmZXIgPSBudWxsO1xyXG4gICAgICB2YXIgY29sb3JUZXh0dXJlID0gdHJ1ZTtcclxuICAgICAgdmFyIGNvbG9yRm9ybWF0ID0gJ3JnYmEnO1xyXG4gICAgICB2YXIgY29sb3JUeXBlID0gJ3VpbnQ4JztcclxuICAgICAgdmFyIGNvbG9yQ291bnQgPSAxO1xyXG5cclxuICAgICAgdmFyIGRlcHRoQnVmZmVyID0gbnVsbDtcclxuICAgICAgdmFyIHN0ZW5jaWxCdWZmZXIgPSBudWxsO1xyXG4gICAgICB2YXIgZGVwdGhTdGVuY2lsQnVmZmVyID0gbnVsbDtcclxuICAgICAgdmFyIGRlcHRoU3RlbmNpbFRleHR1cmUgPSBmYWxzZTtcclxuXHJcbiAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICB3aWR0aCA9IGEgfCAwO1xyXG4gICAgICAgIGhlaWdodCA9IChiIHwgMCkgfHwgd2lkdGg7XHJcbiAgICAgIH0gZWxzZSBpZiAoIWEpIHtcclxuICAgICAgICB3aWR0aCA9IGhlaWdodCA9IDE7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY2hlY2skMS50eXBlKGEsICdvYmplY3QnLCAnaW52YWxpZCBhcmd1bWVudHMgZm9yIGZyYW1lYnVmZmVyJyk7XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBhO1xyXG5cclxuICAgICAgICBpZiAoJ3NoYXBlJyBpbiBvcHRpb25zKSB7XHJcbiAgICAgICAgICB2YXIgc2hhcGUgPSBvcHRpb25zLnNoYXBlO1xyXG4gICAgICAgICAgY2hlY2skMShBcnJheS5pc0FycmF5KHNoYXBlKSAmJiBzaGFwZS5sZW5ndGggPj0gMixcclxuICAgICAgICAgICAgJ2ludmFsaWQgc2hhcGUgZm9yIGZyYW1lYnVmZmVyJyk7XHJcbiAgICAgICAgICB3aWR0aCA9IHNoYXBlWzBdO1xyXG4gICAgICAgICAgaGVpZ2h0ID0gc2hhcGVbMV07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGlmICgncmFkaXVzJyBpbiBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHdpZHRoID0gaGVpZ2h0ID0gb3B0aW9ucy5yYWRpdXM7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoJ3dpZHRoJyBpbiBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHdpZHRoID0gb3B0aW9ucy53aWR0aDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICgnaGVpZ2h0JyBpbiBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIGhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCdjb2xvcicgaW4gb3B0aW9ucyB8fFxyXG4gICAgICAgICAgICAnY29sb3JzJyBpbiBvcHRpb25zKSB7XHJcbiAgICAgICAgICBjb2xvckJ1ZmZlciA9XHJcbiAgICAgICAgICAgIG9wdGlvbnMuY29sb3IgfHxcclxuICAgICAgICAgICAgb3B0aW9ucy5jb2xvcnM7XHJcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb2xvckJ1ZmZlcikpIHtcclxuICAgICAgICAgICAgY2hlY2skMShcclxuICAgICAgICAgICAgICBjb2xvckJ1ZmZlci5sZW5ndGggPT09IDEgfHwgZXh0RHJhd0J1ZmZlcnMsXHJcbiAgICAgICAgICAgICAgJ211bHRpcGxlIHJlbmRlciB0YXJnZXRzIG5vdCBzdXBwb3J0ZWQnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghY29sb3JCdWZmZXIpIHtcclxuICAgICAgICAgIGlmICgnY29sb3JDb3VudCcgaW4gb3B0aW9ucykge1xyXG4gICAgICAgICAgICBjb2xvckNvdW50ID0gb3B0aW9ucy5jb2xvckNvdW50IHwgMDtcclxuICAgICAgICAgICAgY2hlY2skMShjb2xvckNvdW50ID4gMCwgJ2ludmFsaWQgY29sb3IgYnVmZmVyIGNvdW50Jyk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKCdjb2xvclRleHR1cmUnIGluIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgY29sb3JUZXh0dXJlID0gISFvcHRpb25zLmNvbG9yVGV4dHVyZTtcclxuICAgICAgICAgICAgY29sb3JGb3JtYXQgPSAncmdiYTQnO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmICgnY29sb3JUeXBlJyBpbiBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIGNvbG9yVHlwZSA9IG9wdGlvbnMuY29sb3JUeXBlO1xyXG4gICAgICAgICAgICBpZiAoIWNvbG9yVGV4dHVyZSkge1xyXG4gICAgICAgICAgICAgIGlmIChjb2xvclR5cGUgPT09ICdoYWxmIGZsb2F0JyB8fCBjb2xvclR5cGUgPT09ICdmbG9hdDE2Jykge1xyXG4gICAgICAgICAgICAgICAgY2hlY2skMShleHRlbnNpb25zLmV4dF9jb2xvcl9idWZmZXJfaGFsZl9mbG9hdCxcclxuICAgICAgICAgICAgICAgICAgJ3lvdSBtdXN0IGVuYWJsZSBFWFRfY29sb3JfYnVmZmVyX2hhbGZfZmxvYXQgdG8gdXNlIDE2LWJpdCByZW5kZXIgYnVmZmVycycpO1xyXG4gICAgICAgICAgICAgICAgY29sb3JGb3JtYXQgPSAncmdiYTE2Zic7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2xvclR5cGUgPT09ICdmbG9hdCcgfHwgY29sb3JUeXBlID09PSAnZmxvYXQzMicpIHtcclxuICAgICAgICAgICAgICAgIGNoZWNrJDEoZXh0ZW5zaW9ucy53ZWJnbF9jb2xvcl9idWZmZXJfZmxvYXQsXHJcbiAgICAgICAgICAgICAgICAgICd5b3UgbXVzdCBlbmFibGUgV0VCR0xfY29sb3JfYnVmZmVyX2Zsb2F0IGluIG9yZGVyIHRvIHVzZSAzMi1iaXQgZmxvYXRpbmcgcG9pbnQgcmVuZGVyYnVmZmVycycpO1xyXG4gICAgICAgICAgICAgICAgY29sb3JGb3JtYXQgPSAncmdiYTMyZic7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGNoZWNrJDEoZXh0ZW5zaW9ucy5vZXNfdGV4dHVyZV9mbG9hdCB8fFxyXG4gICAgICAgICAgICAgICAgIShjb2xvclR5cGUgPT09ICdmbG9hdCcgfHwgY29sb3JUeXBlID09PSAnZmxvYXQzMicpLFxyXG4gICAgICAgICAgICAgICAgJ3lvdSBtdXN0IGVuYWJsZSBPRVNfdGV4dHVyZV9mbG9hdCBpbiBvcmRlciB0byB1c2UgZmxvYXRpbmcgcG9pbnQgZnJhbWVidWZmZXIgb2JqZWN0cycpO1xyXG4gICAgICAgICAgICAgIGNoZWNrJDEoZXh0ZW5zaW9ucy5vZXNfdGV4dHVyZV9oYWxmX2Zsb2F0IHx8XHJcbiAgICAgICAgICAgICAgICAhKGNvbG9yVHlwZSA9PT0gJ2hhbGYgZmxvYXQnIHx8IGNvbG9yVHlwZSA9PT0gJ2Zsb2F0MTYnKSxcclxuICAgICAgICAgICAgICAgICd5b3UgbXVzdCBlbmFibGUgT0VTX3RleHR1cmVfaGFsZl9mbG9hdCBpbiBvcmRlciB0byB1c2UgMTYtYml0IGZsb2F0aW5nIHBvaW50IGZyYW1lYnVmZmVyIG9iamVjdHMnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjaGVjayQxLm9uZU9mKGNvbG9yVHlwZSwgY29sb3JUeXBlcywgJ2ludmFsaWQgY29sb3IgdHlwZScpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmICgnY29sb3JGb3JtYXQnIGluIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgY29sb3JGb3JtYXQgPSBvcHRpb25zLmNvbG9yRm9ybWF0O1xyXG4gICAgICAgICAgICBpZiAoY29sb3JUZXh0dXJlRm9ybWF0cy5pbmRleE9mKGNvbG9yRm9ybWF0KSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgY29sb3JUZXh0dXJlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChjb2xvclJlbmRlcmJ1ZmZlckZvcm1hdHMuaW5kZXhPZihjb2xvckZvcm1hdCkgPj0gMCkge1xyXG4gICAgICAgICAgICAgIGNvbG9yVGV4dHVyZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGlmIChjb2xvclRleHR1cmUpIHtcclxuICAgICAgICAgICAgICAgIGNoZWNrJDEub25lT2YoXHJcbiAgICAgICAgICAgICAgICAgIG9wdGlvbnMuY29sb3JGb3JtYXQsIGNvbG9yVGV4dHVyZUZvcm1hdHMsXHJcbiAgICAgICAgICAgICAgICAgICdpbnZhbGlkIGNvbG9yIGZvcm1hdCBmb3IgdGV4dHVyZScpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjaGVjayQxLm9uZU9mKFxyXG4gICAgICAgICAgICAgICAgICBvcHRpb25zLmNvbG9yRm9ybWF0LCBjb2xvclJlbmRlcmJ1ZmZlckZvcm1hdHMsXHJcbiAgICAgICAgICAgICAgICAgICdpbnZhbGlkIGNvbG9yIGZvcm1hdCBmb3IgcmVuZGVyYnVmZmVyJyk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoJ2RlcHRoVGV4dHVyZScgaW4gb3B0aW9ucyB8fCAnZGVwdGhTdGVuY2lsVGV4dHVyZScgaW4gb3B0aW9ucykge1xyXG4gICAgICAgICAgZGVwdGhTdGVuY2lsVGV4dHVyZSA9ICEhKG9wdGlvbnMuZGVwdGhUZXh0dXJlIHx8XHJcbiAgICAgICAgICAgIG9wdGlvbnMuZGVwdGhTdGVuY2lsVGV4dHVyZSk7XHJcbiAgICAgICAgICBjaGVjayQxKCFkZXB0aFN0ZW5jaWxUZXh0dXJlIHx8IGV4dGVuc2lvbnMud2ViZ2xfZGVwdGhfdGV4dHVyZSxcclxuICAgICAgICAgICAgJ3dlYmdsX2RlcHRoX3RleHR1cmUgZXh0ZW5zaW9uIG5vdCBzdXBwb3J0ZWQnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICgnZGVwdGgnIGluIG9wdGlvbnMpIHtcclxuICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXB0aCA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgICAgIG5lZWRzRGVwdGggPSBvcHRpb25zLmRlcHRoO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZGVwdGhCdWZmZXIgPSBvcHRpb25zLmRlcHRoO1xyXG4gICAgICAgICAgICBuZWVkc1N0ZW5jaWwgPSBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICgnc3RlbmNpbCcgaW4gb3B0aW9ucykge1xyXG4gICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnN0ZW5jaWwgPT09ICdib29sZWFuJykge1xyXG4gICAgICAgICAgICBuZWVkc1N0ZW5jaWwgPSBvcHRpb25zLnN0ZW5jaWw7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzdGVuY2lsQnVmZmVyID0gb3B0aW9ucy5zdGVuY2lsO1xyXG4gICAgICAgICAgICBuZWVkc0RlcHRoID0gZmFsc2U7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoJ2RlcHRoU3RlbmNpbCcgaW4gb3B0aW9ucykge1xyXG4gICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlcHRoU3RlbmNpbCA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgICAgIG5lZWRzRGVwdGggPSBuZWVkc1N0ZW5jaWwgPSBvcHRpb25zLmRlcHRoU3RlbmNpbDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGRlcHRoU3RlbmNpbEJ1ZmZlciA9IG9wdGlvbnMuZGVwdGhTdGVuY2lsO1xyXG4gICAgICAgICAgICBuZWVkc0RlcHRoID0gZmFsc2U7XHJcbiAgICAgICAgICAgIG5lZWRzU3RlbmNpbCA9IGZhbHNlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gcGFyc2UgYXR0YWNobWVudHNcclxuICAgICAgdmFyIGNvbG9yQXR0YWNobWVudHMgPSBudWxsO1xyXG4gICAgICB2YXIgZGVwdGhBdHRhY2htZW50ID0gbnVsbDtcclxuICAgICAgdmFyIHN0ZW5jaWxBdHRhY2htZW50ID0gbnVsbDtcclxuICAgICAgdmFyIGRlcHRoU3RlbmNpbEF0dGFjaG1lbnQgPSBudWxsO1xyXG5cclxuICAgICAgLy8gU2V0IHVwIGNvbG9yIGF0dGFjaG1lbnRzXHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbG9yQnVmZmVyKSkge1xyXG4gICAgICAgIGNvbG9yQXR0YWNobWVudHMgPSBjb2xvckJ1ZmZlci5tYXAocGFyc2VBdHRhY2htZW50KTtcclxuICAgICAgfSBlbHNlIGlmIChjb2xvckJ1ZmZlcikge1xyXG4gICAgICAgIGNvbG9yQXR0YWNobWVudHMgPSBbcGFyc2VBdHRhY2htZW50KGNvbG9yQnVmZmVyKV07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29sb3JBdHRhY2htZW50cyA9IG5ldyBBcnJheShjb2xvckNvdW50KTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29sb3JDb3VudDsgKytpKSB7XHJcbiAgICAgICAgICBjb2xvckF0dGFjaG1lbnRzW2ldID0gYWxsb2NBdHRhY2htZW50KFxyXG4gICAgICAgICAgICB3aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0LFxyXG4gICAgICAgICAgICBjb2xvclRleHR1cmUsXHJcbiAgICAgICAgICAgIGNvbG9yRm9ybWF0LFxyXG4gICAgICAgICAgICBjb2xvclR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgY2hlY2skMShleHRlbnNpb25zLndlYmdsX2RyYXdfYnVmZmVycyB8fCBjb2xvckF0dGFjaG1lbnRzLmxlbmd0aCA8PSAxLFxyXG4gICAgICAgICd5b3UgbXVzdCBlbmFibGUgdGhlIFdFQkdMX2RyYXdfYnVmZmVycyBleHRlbnNpb24gaW4gb3JkZXIgdG8gdXNlIG11bHRpcGxlIGNvbG9yIGJ1ZmZlcnMuJyk7XHJcbiAgICAgIGNoZWNrJDEoY29sb3JBdHRhY2htZW50cy5sZW5ndGggPD0gbGltaXRzLm1heENvbG9yQXR0YWNobWVudHMsXHJcbiAgICAgICAgJ3RvbyBtYW55IGNvbG9yIGF0dGFjaG1lbnRzLCBub3Qgc3VwcG9ydGVkJyk7XHJcblxyXG4gICAgICB3aWR0aCA9IHdpZHRoIHx8IGNvbG9yQXR0YWNobWVudHNbMF0ud2lkdGg7XHJcbiAgICAgIGhlaWdodCA9IGhlaWdodCB8fCBjb2xvckF0dGFjaG1lbnRzWzBdLmhlaWdodDtcclxuXHJcbiAgICAgIGlmIChkZXB0aEJ1ZmZlcikge1xyXG4gICAgICAgIGRlcHRoQXR0YWNobWVudCA9IHBhcnNlQXR0YWNobWVudChkZXB0aEJ1ZmZlcik7XHJcbiAgICAgIH0gZWxzZSBpZiAobmVlZHNEZXB0aCAmJiAhbmVlZHNTdGVuY2lsKSB7XHJcbiAgICAgICAgZGVwdGhBdHRhY2htZW50ID0gYWxsb2NBdHRhY2htZW50KFxyXG4gICAgICAgICAgd2lkdGgsXHJcbiAgICAgICAgICBoZWlnaHQsXHJcbiAgICAgICAgICBkZXB0aFN0ZW5jaWxUZXh0dXJlLFxyXG4gICAgICAgICAgJ2RlcHRoJyxcclxuICAgICAgICAgICd1aW50MzInKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHN0ZW5jaWxCdWZmZXIpIHtcclxuICAgICAgICBzdGVuY2lsQXR0YWNobWVudCA9IHBhcnNlQXR0YWNobWVudChzdGVuY2lsQnVmZmVyKTtcclxuICAgICAgfSBlbHNlIGlmIChuZWVkc1N0ZW5jaWwgJiYgIW5lZWRzRGVwdGgpIHtcclxuICAgICAgICBzdGVuY2lsQXR0YWNobWVudCA9IGFsbG9jQXR0YWNobWVudChcclxuICAgICAgICAgIHdpZHRoLFxyXG4gICAgICAgICAgaGVpZ2h0LFxyXG4gICAgICAgICAgZmFsc2UsXHJcbiAgICAgICAgICAnc3RlbmNpbCcsXHJcbiAgICAgICAgICAndWludDgnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGRlcHRoU3RlbmNpbEJ1ZmZlcikge1xyXG4gICAgICAgIGRlcHRoU3RlbmNpbEF0dGFjaG1lbnQgPSBwYXJzZUF0dGFjaG1lbnQoZGVwdGhTdGVuY2lsQnVmZmVyKTtcclxuICAgICAgfSBlbHNlIGlmICghZGVwdGhCdWZmZXIgJiYgIXN0ZW5jaWxCdWZmZXIgJiYgbmVlZHNTdGVuY2lsICYmIG5lZWRzRGVwdGgpIHtcclxuICAgICAgICBkZXB0aFN0ZW5jaWxBdHRhY2htZW50ID0gYWxsb2NBdHRhY2htZW50KFxyXG4gICAgICAgICAgd2lkdGgsXHJcbiAgICAgICAgICBoZWlnaHQsXHJcbiAgICAgICAgICBkZXB0aFN0ZW5jaWxUZXh0dXJlLFxyXG4gICAgICAgICAgJ2RlcHRoIHN0ZW5jaWwnLFxyXG4gICAgICAgICAgJ2RlcHRoIHN0ZW5jaWwnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY2hlY2skMShcclxuICAgICAgICAoISFkZXB0aEJ1ZmZlcikgKyAoISFzdGVuY2lsQnVmZmVyKSArICghIWRlcHRoU3RlbmNpbEJ1ZmZlcikgPD0gMSxcclxuICAgICAgICAnaW52YWxpZCBmcmFtZWJ1ZmZlciBjb25maWd1cmF0aW9uLCBjYW4gc3BlY2lmeSBleGFjdGx5IG9uZSBkZXB0aC9zdGVuY2lsIGF0dGFjaG1lbnQnKTtcclxuXHJcbiAgICAgIHZhciBjb21tb25Db2xvckF0dGFjaG1lbnRTaXplID0gbnVsbDtcclxuXHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjb2xvckF0dGFjaG1lbnRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgaW5jUmVmQW5kQ2hlY2tTaGFwZShjb2xvckF0dGFjaG1lbnRzW2ldLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICBjaGVjayQxKCFjb2xvckF0dGFjaG1lbnRzW2ldIHx8XHJcbiAgICAgICAgICAoY29sb3JBdHRhY2htZW50c1tpXS50ZXh0dXJlICYmXHJcbiAgICAgICAgICAgIGNvbG9yVGV4dHVyZUZvcm1hdEVudW1zLmluZGV4T2YoY29sb3JBdHRhY2htZW50c1tpXS50ZXh0dXJlLl90ZXh0dXJlLmZvcm1hdCkgPj0gMCkgfHxcclxuICAgICAgICAgIChjb2xvckF0dGFjaG1lbnRzW2ldLnJlbmRlcmJ1ZmZlciAmJlxyXG4gICAgICAgICAgICBjb2xvclJlbmRlcmJ1ZmZlckZvcm1hdEVudW1zLmluZGV4T2YoY29sb3JBdHRhY2htZW50c1tpXS5yZW5kZXJidWZmZXIuX3JlbmRlcmJ1ZmZlci5mb3JtYXQpID49IDApLFxyXG4gICAgICAgICAgJ2ZyYW1lYnVmZmVyIGNvbG9yIGF0dGFjaG1lbnQgJyArIGkgKyAnIGlzIGludmFsaWQnKTtcclxuXHJcbiAgICAgICAgaWYgKGNvbG9yQXR0YWNobWVudHNbaV0gJiYgY29sb3JBdHRhY2htZW50c1tpXS50ZXh0dXJlKSB7XHJcbiAgICAgICAgICB2YXIgY29sb3JBdHRhY2htZW50U2l6ZSA9XHJcbiAgICAgICAgICAgICAgdGV4dHVyZUZvcm1hdENoYW5uZWxzW2NvbG9yQXR0YWNobWVudHNbaV0udGV4dHVyZS5fdGV4dHVyZS5mb3JtYXRdICpcclxuICAgICAgICAgICAgICB0ZXh0dXJlVHlwZVNpemVzW2NvbG9yQXR0YWNobWVudHNbaV0udGV4dHVyZS5fdGV4dHVyZS50eXBlXTtcclxuXHJcbiAgICAgICAgICBpZiAoY29tbW9uQ29sb3JBdHRhY2htZW50U2l6ZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjb21tb25Db2xvckF0dGFjaG1lbnRTaXplID0gY29sb3JBdHRhY2htZW50U2l6ZTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYWxsIGNvbG9yIGF0dGFjaG1lbnRzIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGJpdHBsYW5lc1xyXG4gICAgICAgICAgICAvLyAodGhhdCBpcywgdGhlIHNhbWUgbnVtZXIgb2YgYml0cyBwZXIgcGl4ZWwpXHJcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgcmVxdWlyZWQgYnkgdGhlIEdMRVMyLjAgc3RhbmRhcmQuIFNlZSB0aGUgYmVnaW5uaW5nIG9mIENoYXB0ZXIgNCBpbiB0aGF0IGRvY3VtZW50LlxyXG4gICAgICAgICAgICBjaGVjayQxKGNvbW1vbkNvbG9yQXR0YWNobWVudFNpemUgPT09IGNvbG9yQXR0YWNobWVudFNpemUsXHJcbiAgICAgICAgICAgICAgICAgICdhbGwgY29sb3IgYXR0YWNobWVudHMgbXVjaCBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBiaXRzIHBlciBwaXhlbC4nKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaW5jUmVmQW5kQ2hlY2tTaGFwZShkZXB0aEF0dGFjaG1lbnQsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICBjaGVjayQxKCFkZXB0aEF0dGFjaG1lbnQgfHxcclxuICAgICAgICAoZGVwdGhBdHRhY2htZW50LnRleHR1cmUgJiZcclxuICAgICAgICAgIGRlcHRoQXR0YWNobWVudC50ZXh0dXJlLl90ZXh0dXJlLmZvcm1hdCA9PT0gR0xfREVQVEhfQ09NUE9ORU5UJDEpIHx8XHJcbiAgICAgICAgKGRlcHRoQXR0YWNobWVudC5yZW5kZXJidWZmZXIgJiZcclxuICAgICAgICAgIGRlcHRoQXR0YWNobWVudC5yZW5kZXJidWZmZXIuX3JlbmRlcmJ1ZmZlci5mb3JtYXQgPT09IEdMX0RFUFRIX0NPTVBPTkVOVDE2JDEpLFxyXG4gICAgICAgICdpbnZhbGlkIGRlcHRoIGF0dGFjaG1lbnQgZm9yIGZyYW1lYnVmZmVyIG9iamVjdCcpO1xyXG4gICAgICBpbmNSZWZBbmRDaGVja1NoYXBlKHN0ZW5jaWxBdHRhY2htZW50LCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgY2hlY2skMSghc3RlbmNpbEF0dGFjaG1lbnQgfHxcclxuICAgICAgICAoc3RlbmNpbEF0dGFjaG1lbnQucmVuZGVyYnVmZmVyICYmXHJcbiAgICAgICAgICBzdGVuY2lsQXR0YWNobWVudC5yZW5kZXJidWZmZXIuX3JlbmRlcmJ1ZmZlci5mb3JtYXQgPT09IEdMX1NURU5DSUxfSU5ERVg4JDEpLFxyXG4gICAgICAgICdpbnZhbGlkIHN0ZW5jaWwgYXR0YWNobWVudCBmb3IgZnJhbWVidWZmZXIgb2JqZWN0Jyk7XHJcbiAgICAgIGluY1JlZkFuZENoZWNrU2hhcGUoZGVwdGhTdGVuY2lsQXR0YWNobWVudCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgIGNoZWNrJDEoIWRlcHRoU3RlbmNpbEF0dGFjaG1lbnQgfHxcclxuICAgICAgICAoZGVwdGhTdGVuY2lsQXR0YWNobWVudC50ZXh0dXJlICYmXHJcbiAgICAgICAgICBkZXB0aFN0ZW5jaWxBdHRhY2htZW50LnRleHR1cmUuX3RleHR1cmUuZm9ybWF0ID09PSBHTF9ERVBUSF9TVEVOQ0lMJDIpIHx8XHJcbiAgICAgICAgKGRlcHRoU3RlbmNpbEF0dGFjaG1lbnQucmVuZGVyYnVmZmVyICYmXHJcbiAgICAgICAgICBkZXB0aFN0ZW5jaWxBdHRhY2htZW50LnJlbmRlcmJ1ZmZlci5fcmVuZGVyYnVmZmVyLmZvcm1hdCA9PT0gR0xfREVQVEhfU1RFTkNJTCQyKSxcclxuICAgICAgICAnaW52YWxpZCBkZXB0aC1zdGVuY2lsIGF0dGFjaG1lbnQgZm9yIGZyYW1lYnVmZmVyIG9iamVjdCcpO1xyXG5cclxuICAgICAgLy8gZGVjcmVtZW50IHJlZmVyZW5jZXNcclxuICAgICAgZGVjRkJPUmVmcyhmcmFtZWJ1ZmZlcik7XHJcblxyXG4gICAgICBmcmFtZWJ1ZmZlci53aWR0aCA9IHdpZHRoO1xyXG4gICAgICBmcmFtZWJ1ZmZlci5oZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG4gICAgICBmcmFtZWJ1ZmZlci5jb2xvckF0dGFjaG1lbnRzID0gY29sb3JBdHRhY2htZW50cztcclxuICAgICAgZnJhbWVidWZmZXIuZGVwdGhBdHRhY2htZW50ID0gZGVwdGhBdHRhY2htZW50O1xyXG4gICAgICBmcmFtZWJ1ZmZlci5zdGVuY2lsQXR0YWNobWVudCA9IHN0ZW5jaWxBdHRhY2htZW50O1xyXG4gICAgICBmcmFtZWJ1ZmZlci5kZXB0aFN0ZW5jaWxBdHRhY2htZW50ID0gZGVwdGhTdGVuY2lsQXR0YWNobWVudDtcclxuXHJcbiAgICAgIHJlZ2xGcmFtZWJ1ZmZlci5jb2xvciA9IGNvbG9yQXR0YWNobWVudHMubWFwKHVud3JhcEF0dGFjaG1lbnQpO1xyXG4gICAgICByZWdsRnJhbWVidWZmZXIuZGVwdGggPSB1bndyYXBBdHRhY2htZW50KGRlcHRoQXR0YWNobWVudCk7XHJcbiAgICAgIHJlZ2xGcmFtZWJ1ZmZlci5zdGVuY2lsID0gdW53cmFwQXR0YWNobWVudChzdGVuY2lsQXR0YWNobWVudCk7XHJcbiAgICAgIHJlZ2xGcmFtZWJ1ZmZlci5kZXB0aFN0ZW5jaWwgPSB1bndyYXBBdHRhY2htZW50KGRlcHRoU3RlbmNpbEF0dGFjaG1lbnQpO1xyXG5cclxuICAgICAgcmVnbEZyYW1lYnVmZmVyLndpZHRoID0gZnJhbWVidWZmZXIud2lkdGg7XHJcbiAgICAgIHJlZ2xGcmFtZWJ1ZmZlci5oZWlnaHQgPSBmcmFtZWJ1ZmZlci5oZWlnaHQ7XHJcblxyXG4gICAgICB1cGRhdGVGcmFtZWJ1ZmZlcihmcmFtZWJ1ZmZlcik7XHJcblxyXG4gICAgICByZXR1cm4gcmVnbEZyYW1lYnVmZmVyXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVzaXplICh3XywgaF8pIHtcclxuICAgICAgY2hlY2skMShmcmFtZWJ1ZmZlclN0YXRlLm5leHQgIT09IGZyYW1lYnVmZmVyLFxyXG4gICAgICAgICdjYW4gbm90IHJlc2l6ZSBhIGZyYW1lYnVmZmVyIHdoaWNoIGlzIGN1cnJlbnRseSBpbiB1c2UnKTtcclxuXHJcbiAgICAgIHZhciB3ID0gd18gfCAwO1xyXG4gICAgICB2YXIgaCA9IChoXyB8IDApIHx8IHc7XHJcbiAgICAgIGlmICh3ID09PSBmcmFtZWJ1ZmZlci53aWR0aCAmJiBoID09PSBmcmFtZWJ1ZmZlci5oZWlnaHQpIHtcclxuICAgICAgICByZXR1cm4gcmVnbEZyYW1lYnVmZmVyXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHJlc2l6ZSBhbGwgYnVmZmVyc1xyXG4gICAgICB2YXIgY29sb3JBdHRhY2htZW50cyA9IGZyYW1lYnVmZmVyLmNvbG9yQXR0YWNobWVudHM7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sb3JBdHRhY2htZW50cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIHJlc2l6ZUF0dGFjaG1lbnQoY29sb3JBdHRhY2htZW50c1tpXSwgdywgaCk7XHJcbiAgICAgIH1cclxuICAgICAgcmVzaXplQXR0YWNobWVudChmcmFtZWJ1ZmZlci5kZXB0aEF0dGFjaG1lbnQsIHcsIGgpO1xyXG4gICAgICByZXNpemVBdHRhY2htZW50KGZyYW1lYnVmZmVyLnN0ZW5jaWxBdHRhY2htZW50LCB3LCBoKTtcclxuICAgICAgcmVzaXplQXR0YWNobWVudChmcmFtZWJ1ZmZlci5kZXB0aFN0ZW5jaWxBdHRhY2htZW50LCB3LCBoKTtcclxuXHJcbiAgICAgIGZyYW1lYnVmZmVyLndpZHRoID0gcmVnbEZyYW1lYnVmZmVyLndpZHRoID0gdztcclxuICAgICAgZnJhbWVidWZmZXIuaGVpZ2h0ID0gcmVnbEZyYW1lYnVmZmVyLmhlaWdodCA9IGg7XHJcblxyXG4gICAgICB1cGRhdGVGcmFtZWJ1ZmZlcihmcmFtZWJ1ZmZlcik7XHJcblxyXG4gICAgICByZXR1cm4gcmVnbEZyYW1lYnVmZmVyXHJcbiAgICB9XHJcblxyXG4gICAgcmVnbEZyYW1lYnVmZmVyKGEwLCBhMSk7XHJcblxyXG4gICAgcmV0dXJuIGV4dGVuZChyZWdsRnJhbWVidWZmZXIsIHtcclxuICAgICAgcmVzaXplOiByZXNpemUsXHJcbiAgICAgIF9yZWdsVHlwZTogJ2ZyYW1lYnVmZmVyJyxcclxuICAgICAgX2ZyYW1lYnVmZmVyOiBmcmFtZWJ1ZmZlcixcclxuICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGRlc3Ryb3koZnJhbWVidWZmZXIpO1xyXG4gICAgICAgIGRlY0ZCT1JlZnMoZnJhbWVidWZmZXIpO1xyXG4gICAgICB9LFxyXG4gICAgICB1c2U6IGZ1bmN0aW9uIChibG9jaykge1xyXG4gICAgICAgIGZyYW1lYnVmZmVyU3RhdGUuc2V0RkJPKHtcclxuICAgICAgICAgIGZyYW1lYnVmZmVyOiByZWdsRnJhbWVidWZmZXJcclxuICAgICAgICB9LCBibG9jayk7XHJcbiAgICAgIH1cclxuICAgIH0pXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjcmVhdGVDdWJlRkJPIChvcHRpb25zKSB7XHJcbiAgICB2YXIgZmFjZXMgPSBBcnJheSg2KTtcclxuXHJcbiAgICBmdW5jdGlvbiByZWdsRnJhbWVidWZmZXJDdWJlIChhKSB7XHJcbiAgICAgIHZhciBpO1xyXG5cclxuICAgICAgY2hlY2skMShmYWNlcy5pbmRleE9mKGZyYW1lYnVmZmVyU3RhdGUubmV4dCkgPCAwLFxyXG4gICAgICAgICdjYW4gbm90IHVwZGF0ZSBmcmFtZWJ1ZmZlciB3aGljaCBpcyBjdXJyZW50bHkgaW4gdXNlJyk7XHJcblxyXG4gICAgICB2YXIgZXh0RHJhd0J1ZmZlcnMgPSBleHRlbnNpb25zLndlYmdsX2RyYXdfYnVmZmVycztcclxuXHJcbiAgICAgIHZhciBwYXJhbXMgPSB7XHJcbiAgICAgICAgY29sb3I6IG51bGxcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHZhciByYWRpdXMgPSAwO1xyXG5cclxuICAgICAgdmFyIGNvbG9yQnVmZmVyID0gbnVsbDtcclxuICAgICAgdmFyIGNvbG9yRm9ybWF0ID0gJ3JnYmEnO1xyXG4gICAgICB2YXIgY29sb3JUeXBlID0gJ3VpbnQ4JztcclxuICAgICAgdmFyIGNvbG9yQ291bnQgPSAxO1xyXG5cclxuICAgICAgaWYgKHR5cGVvZiBhID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIHJhZGl1cyA9IGEgfCAwO1xyXG4gICAgICB9IGVsc2UgaWYgKCFhKSB7XHJcbiAgICAgICAgcmFkaXVzID0gMTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjaGVjayQxLnR5cGUoYSwgJ29iamVjdCcsICdpbnZhbGlkIGFyZ3VtZW50cyBmb3IgZnJhbWVidWZmZXInKTtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IGE7XHJcblxyXG4gICAgICAgIGlmICgnc2hhcGUnIGluIG9wdGlvbnMpIHtcclxuICAgICAgICAgIHZhciBzaGFwZSA9IG9wdGlvbnMuc2hhcGU7XHJcbiAgICAgICAgICBjaGVjayQxKFxyXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KHNoYXBlKSAmJiBzaGFwZS5sZW5ndGggPj0gMixcclxuICAgICAgICAgICAgJ2ludmFsaWQgc2hhcGUgZm9yIGZyYW1lYnVmZmVyJyk7XHJcbiAgICAgICAgICBjaGVjayQxKFxyXG4gICAgICAgICAgICBzaGFwZVswXSA9PT0gc2hhcGVbMV0sXHJcbiAgICAgICAgICAgICdjdWJlIGZyYW1lYnVmZmVyIG11c3QgYmUgc3F1YXJlJyk7XHJcbiAgICAgICAgICByYWRpdXMgPSBzaGFwZVswXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaWYgKCdyYWRpdXMnIGluIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgcmFkaXVzID0gb3B0aW9ucy5yYWRpdXMgfCAwO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKCd3aWR0aCcgaW4gb3B0aW9ucykge1xyXG4gICAgICAgICAgICByYWRpdXMgPSBvcHRpb25zLndpZHRoIHwgMDtcclxuICAgICAgICAgICAgaWYgKCdoZWlnaHQnIGluIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICBjaGVjayQxKG9wdGlvbnMuaGVpZ2h0ID09PSByYWRpdXMsICdtdXN0IGJlIHNxdWFyZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKCdoZWlnaHQnIGluIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgcmFkaXVzID0gb3B0aW9ucy5oZWlnaHQgfCAwO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCdjb2xvcicgaW4gb3B0aW9ucyB8fFxyXG4gICAgICAgICAgICAnY29sb3JzJyBpbiBvcHRpb25zKSB7XHJcbiAgICAgICAgICBjb2xvckJ1ZmZlciA9XHJcbiAgICAgICAgICAgIG9wdGlvbnMuY29sb3IgfHxcclxuICAgICAgICAgICAgb3B0aW9ucy5jb2xvcnM7XHJcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb2xvckJ1ZmZlcikpIHtcclxuICAgICAgICAgICAgY2hlY2skMShcclxuICAgICAgICAgICAgICBjb2xvckJ1ZmZlci5sZW5ndGggPT09IDEgfHwgZXh0RHJhd0J1ZmZlcnMsXHJcbiAgICAgICAgICAgICAgJ211bHRpcGxlIHJlbmRlciB0YXJnZXRzIG5vdCBzdXBwb3J0ZWQnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghY29sb3JCdWZmZXIpIHtcclxuICAgICAgICAgIGlmICgnY29sb3JDb3VudCcgaW4gb3B0aW9ucykge1xyXG4gICAgICAgICAgICBjb2xvckNvdW50ID0gb3B0aW9ucy5jb2xvckNvdW50IHwgMDtcclxuICAgICAgICAgICAgY2hlY2skMShjb2xvckNvdW50ID4gMCwgJ2ludmFsaWQgY29sb3IgYnVmZmVyIGNvdW50Jyk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKCdjb2xvclR5cGUnIGluIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgY2hlY2skMS5vbmVPZihcclxuICAgICAgICAgICAgICBvcHRpb25zLmNvbG9yVHlwZSwgY29sb3JUeXBlcyxcclxuICAgICAgICAgICAgICAnaW52YWxpZCBjb2xvciB0eXBlJyk7XHJcbiAgICAgICAgICAgIGNvbG9yVHlwZSA9IG9wdGlvbnMuY29sb3JUeXBlO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmICgnY29sb3JGb3JtYXQnIGluIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgY29sb3JGb3JtYXQgPSBvcHRpb25zLmNvbG9yRm9ybWF0O1xyXG4gICAgICAgICAgICBjaGVjayQxLm9uZU9mKFxyXG4gICAgICAgICAgICAgIG9wdGlvbnMuY29sb3JGb3JtYXQsIGNvbG9yVGV4dHVyZUZvcm1hdHMsXHJcbiAgICAgICAgICAgICAgJ2ludmFsaWQgY29sb3IgZm9ybWF0IGZvciB0ZXh0dXJlJyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoJ2RlcHRoJyBpbiBvcHRpb25zKSB7XHJcbiAgICAgICAgICBwYXJhbXMuZGVwdGggPSBvcHRpb25zLmRlcHRoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCdzdGVuY2lsJyBpbiBvcHRpb25zKSB7XHJcbiAgICAgICAgICBwYXJhbXMuc3RlbmNpbCA9IG9wdGlvbnMuc3RlbmNpbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICgnZGVwdGhTdGVuY2lsJyBpbiBvcHRpb25zKSB7XHJcbiAgICAgICAgICBwYXJhbXMuZGVwdGhTdGVuY2lsID0gb3B0aW9ucy5kZXB0aFN0ZW5jaWw7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgY29sb3JDdWJlcztcclxuICAgICAgaWYgKGNvbG9yQnVmZmVyKSB7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29sb3JCdWZmZXIpKSB7XHJcbiAgICAgICAgICBjb2xvckN1YmVzID0gW107XHJcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29sb3JCdWZmZXIubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgY29sb3JDdWJlc1tpXSA9IGNvbG9yQnVmZmVyW2ldO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjb2xvckN1YmVzID0gWyBjb2xvckJ1ZmZlciBdO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb2xvckN1YmVzID0gQXJyYXkoY29sb3JDb3VudCk7XHJcbiAgICAgICAgdmFyIGN1YmVNYXBQYXJhbXMgPSB7XHJcbiAgICAgICAgICByYWRpdXM6IHJhZGl1cyxcclxuICAgICAgICAgIGZvcm1hdDogY29sb3JGb3JtYXQsXHJcbiAgICAgICAgICB0eXBlOiBjb2xvclR5cGVcclxuICAgICAgICB9O1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb2xvckNvdW50OyArK2kpIHtcclxuICAgICAgICAgIGNvbG9yQ3ViZXNbaV0gPSB0ZXh0dXJlU3RhdGUuY3JlYXRlQ3ViZShjdWJlTWFwUGFyYW1zKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENoZWNrIGNvbG9yIGN1YmVzXHJcbiAgICAgIHBhcmFtcy5jb2xvciA9IEFycmF5KGNvbG9yQ3ViZXMubGVuZ3RoKTtcclxuICAgICAgZm9yIChpID0gMDsgaSA8IGNvbG9yQ3ViZXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICB2YXIgY3ViZSA9IGNvbG9yQ3ViZXNbaV07XHJcbiAgICAgICAgY2hlY2skMShcclxuICAgICAgICAgIHR5cGVvZiBjdWJlID09PSAnZnVuY3Rpb24nICYmIGN1YmUuX3JlZ2xUeXBlID09PSAndGV4dHVyZUN1YmUnLFxyXG4gICAgICAgICAgJ2ludmFsaWQgY3ViZSBtYXAnKTtcclxuICAgICAgICByYWRpdXMgPSByYWRpdXMgfHwgY3ViZS53aWR0aDtcclxuICAgICAgICBjaGVjayQxKFxyXG4gICAgICAgICAgY3ViZS53aWR0aCA9PT0gcmFkaXVzICYmIGN1YmUuaGVpZ2h0ID09PSByYWRpdXMsXHJcbiAgICAgICAgICAnaW52YWxpZCBjdWJlIG1hcCBzaGFwZScpO1xyXG4gICAgICAgIHBhcmFtcy5jb2xvcltpXSA9IHtcclxuICAgICAgICAgIHRhcmdldDogR0xfVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YJDIsXHJcbiAgICAgICAgICBkYXRhOiBjb2xvckN1YmVzW2ldXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZm9yIChpID0gMDsgaSA8IDY7ICsraSkge1xyXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29sb3JDdWJlcy5sZW5ndGg7ICsraikge1xyXG4gICAgICAgICAgcGFyYW1zLmNvbG9yW2pdLnRhcmdldCA9IEdMX1RFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCQyICsgaTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcmV1c2UgZGVwdGgtc3RlbmNpbCBhdHRhY2htZW50cyBhY3Jvc3MgYWxsIGN1YmUgbWFwc1xyXG4gICAgICAgIGlmIChpID4gMCkge1xyXG4gICAgICAgICAgcGFyYW1zLmRlcHRoID0gZmFjZXNbMF0uZGVwdGg7XHJcbiAgICAgICAgICBwYXJhbXMuc3RlbmNpbCA9IGZhY2VzWzBdLnN0ZW5jaWw7XHJcbiAgICAgICAgICBwYXJhbXMuZGVwdGhTdGVuY2lsID0gZmFjZXNbMF0uZGVwdGhTdGVuY2lsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZmFjZXNbaV0pIHtcclxuICAgICAgICAgIChmYWNlc1tpXSkocGFyYW1zKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZmFjZXNbaV0gPSBjcmVhdGVGQk8ocGFyYW1zKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBleHRlbmQocmVnbEZyYW1lYnVmZmVyQ3ViZSwge1xyXG4gICAgICAgIHdpZHRoOiByYWRpdXMsXHJcbiAgICAgICAgaGVpZ2h0OiByYWRpdXMsXHJcbiAgICAgICAgY29sb3I6IGNvbG9yQ3ViZXNcclxuICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZXNpemUgKHJhZGl1c18pIHtcclxuICAgICAgdmFyIGk7XHJcbiAgICAgIHZhciByYWRpdXMgPSByYWRpdXNfIHwgMDtcclxuICAgICAgY2hlY2skMShyYWRpdXMgPiAwICYmIHJhZGl1cyA8PSBsaW1pdHMubWF4Q3ViZU1hcFNpemUsXHJcbiAgICAgICAgJ2ludmFsaWQgcmFkaXVzIGZvciBjdWJlIGZibycpO1xyXG5cclxuICAgICAgaWYgKHJhZGl1cyA9PT0gcmVnbEZyYW1lYnVmZmVyQ3ViZS53aWR0aCkge1xyXG4gICAgICAgIHJldHVybiByZWdsRnJhbWVidWZmZXJDdWJlXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBjb2xvcnMgPSByZWdsRnJhbWVidWZmZXJDdWJlLmNvbG9yO1xyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY29sb3JzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgY29sb3JzW2ldLnJlc2l6ZShyYWRpdXMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgNjsgKytpKSB7XHJcbiAgICAgICAgZmFjZXNbaV0ucmVzaXplKHJhZGl1cyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJlZ2xGcmFtZWJ1ZmZlckN1YmUud2lkdGggPSByZWdsRnJhbWVidWZmZXJDdWJlLmhlaWdodCA9IHJhZGl1cztcclxuXHJcbiAgICAgIHJldHVybiByZWdsRnJhbWVidWZmZXJDdWJlXHJcbiAgICB9XHJcblxyXG4gICAgcmVnbEZyYW1lYnVmZmVyQ3ViZShvcHRpb25zKTtcclxuXHJcbiAgICByZXR1cm4gZXh0ZW5kKHJlZ2xGcmFtZWJ1ZmZlckN1YmUsIHtcclxuICAgICAgZmFjZXM6IGZhY2VzLFxyXG4gICAgICByZXNpemU6IHJlc2l6ZSxcclxuICAgICAgX3JlZ2xUeXBlOiAnZnJhbWVidWZmZXJDdWJlJyxcclxuICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZhY2VzLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcclxuICAgICAgICAgIGYuZGVzdHJveSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmVzdG9yZUZyYW1lYnVmZmVycyAoKSB7XHJcbiAgICB2YWx1ZXMoZnJhbWVidWZmZXJTZXQpLmZvckVhY2goZnVuY3Rpb24gKGZiKSB7XHJcbiAgICAgIGZiLmZyYW1lYnVmZmVyID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcclxuICAgICAgdXBkYXRlRnJhbWVidWZmZXIoZmIpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZXh0ZW5kKGZyYW1lYnVmZmVyU3RhdGUsIHtcclxuICAgIGdldEZyYW1lYnVmZmVyOiBmdW5jdGlvbiAob2JqZWN0KSB7XHJcbiAgICAgIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnZnVuY3Rpb24nICYmIG9iamVjdC5fcmVnbFR5cGUgPT09ICdmcmFtZWJ1ZmZlcicpIHtcclxuICAgICAgICB2YXIgZmJvID0gb2JqZWN0Ll9mcmFtZWJ1ZmZlcjtcclxuICAgICAgICBpZiAoZmJvIGluc3RhbmNlb2YgUkVHTEZyYW1lYnVmZmVyKSB7XHJcbiAgICAgICAgICByZXR1cm4gZmJvXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBudWxsXHJcbiAgICB9LFxyXG4gICAgY3JlYXRlOiBjcmVhdGVGQk8sXHJcbiAgICBjcmVhdGVDdWJlOiBjcmVhdGVDdWJlRkJPLFxyXG4gICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFsdWVzKGZyYW1lYnVmZmVyU2V0KS5mb3JFYWNoKGRlc3Ryb3kpO1xyXG4gICAgfSxcclxuICAgIHJlc3RvcmU6IHJlc3RvcmVGcmFtZWJ1ZmZlcnNcclxuICB9KVxyXG59XHJcblxyXG52YXIgR0xfRkxPQVQkNiA9IDUxMjY7XHJcblxyXG5mdW5jdGlvbiBBdHRyaWJ1dGVSZWNvcmQgKCkge1xyXG4gIHRoaXMuc3RhdGUgPSAwO1xyXG5cclxuICB0aGlzLnggPSAwLjA7XHJcbiAgdGhpcy55ID0gMC4wO1xyXG4gIHRoaXMueiA9IDAuMDtcclxuICB0aGlzLncgPSAwLjA7XHJcblxyXG4gIHRoaXMuYnVmZmVyID0gbnVsbDtcclxuICB0aGlzLnNpemUgPSAwO1xyXG4gIHRoaXMubm9ybWFsaXplZCA9IGZhbHNlO1xyXG4gIHRoaXMudHlwZSA9IEdMX0ZMT0FUJDY7XHJcbiAgdGhpcy5vZmZzZXQgPSAwO1xyXG4gIHRoaXMuc3RyaWRlID0gMDtcclxuICB0aGlzLmRpdmlzb3IgPSAwO1xyXG59XHJcblxyXG5mdW5jdGlvbiB3cmFwQXR0cmlidXRlU3RhdGUgKFxyXG4gIGdsLFxyXG4gIGV4dGVuc2lvbnMsXHJcbiAgbGltaXRzLFxyXG4gIHN0cmluZ1N0b3JlKSB7XHJcbiAgdmFyIE5VTV9BVFRSSUJVVEVTID0gbGltaXRzLm1heEF0dHJpYnV0ZXM7XHJcbiAgdmFyIGF0dHJpYnV0ZUJpbmRpbmdzID0gbmV3IEFycmF5KE5VTV9BVFRSSUJVVEVTKTtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IE5VTV9BVFRSSUJVVEVTOyArK2kpIHtcclxuICAgIGF0dHJpYnV0ZUJpbmRpbmdzW2ldID0gbmV3IEF0dHJpYnV0ZVJlY29yZCgpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIFJlY29yZDogQXR0cmlidXRlUmVjb3JkLFxyXG4gICAgc2NvcGU6IHt9LFxyXG4gICAgc3RhdGU6IGF0dHJpYnV0ZUJpbmRpbmdzXHJcbiAgfVxyXG59XHJcblxyXG52YXIgR0xfRlJBR01FTlRfU0hBREVSID0gMzU2MzI7XHJcbnZhciBHTF9WRVJURVhfU0hBREVSID0gMzU2MzM7XHJcblxyXG52YXIgR0xfQUNUSVZFX1VOSUZPUk1TID0gMHg4Qjg2O1xyXG52YXIgR0xfQUNUSVZFX0FUVFJJQlVURVMgPSAweDhCODk7XHJcblxyXG5mdW5jdGlvbiB3cmFwU2hhZGVyU3RhdGUgKGdsLCBzdHJpbmdTdG9yZSwgc3RhdHMsIGNvbmZpZykge1xyXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gIC8vIGdsc2wgY29tcGlsYXRpb24gYW5kIGxpbmtpbmdcclxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICB2YXIgZnJhZ1NoYWRlcnMgPSB7fTtcclxuICB2YXIgdmVydFNoYWRlcnMgPSB7fTtcclxuXHJcbiAgZnVuY3Rpb24gQWN0aXZlSW5mbyAobmFtZSwgaWQsIGxvY2F0aW9uLCBpbmZvKSB7XHJcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgdGhpcy5pZCA9IGlkO1xyXG4gICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xyXG4gICAgdGhpcy5pbmZvID0gaW5mbztcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGluc2VydEFjdGl2ZUluZm8gKGxpc3QsIGluZm8pIHtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xyXG4gICAgICBpZiAobGlzdFtpXS5pZCA9PT0gaW5mby5pZCkge1xyXG4gICAgICAgIGxpc3RbaV0ubG9jYXRpb24gPSBpbmZvLmxvY2F0aW9uO1xyXG4gICAgICAgIHJldHVyblxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBsaXN0LnB1c2goaW5mbyk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRTaGFkZXIgKHR5cGUsIGlkLCBjb21tYW5kKSB7XHJcbiAgICB2YXIgY2FjaGUgPSB0eXBlID09PSBHTF9GUkFHTUVOVF9TSEFERVIgPyBmcmFnU2hhZGVycyA6IHZlcnRTaGFkZXJzO1xyXG4gICAgdmFyIHNoYWRlciA9IGNhY2hlW2lkXTtcclxuXHJcbiAgICBpZiAoIXNoYWRlcikge1xyXG4gICAgICB2YXIgc291cmNlID0gc3RyaW5nU3RvcmUuc3RyKGlkKTtcclxuICAgICAgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHR5cGUpO1xyXG4gICAgICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzb3VyY2UpO1xyXG4gICAgICBnbC5jb21waWxlU2hhZGVyKHNoYWRlcik7XHJcbiAgICAgIGNoZWNrJDEuc2hhZGVyRXJyb3IoZ2wsIHNoYWRlciwgc291cmNlLCB0eXBlLCBjb21tYW5kKTtcclxuICAgICAgY2FjaGVbaWRdID0gc2hhZGVyO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzaGFkZXJcclxuICB9XHJcblxyXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gIC8vIHByb2dyYW0gbGlua2luZ1xyXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gIHZhciBwcm9ncmFtQ2FjaGUgPSB7fTtcclxuICB2YXIgcHJvZ3JhbUxpc3QgPSBbXTtcclxuXHJcbiAgdmFyIFBST0dSQU1fQ09VTlRFUiA9IDA7XHJcblxyXG4gIGZ1bmN0aW9uIFJFR0xQcm9ncmFtIChmcmFnSWQsIHZlcnRJZCkge1xyXG4gICAgdGhpcy5pZCA9IFBST0dSQU1fQ09VTlRFUisrO1xyXG4gICAgdGhpcy5mcmFnSWQgPSBmcmFnSWQ7XHJcbiAgICB0aGlzLnZlcnRJZCA9IHZlcnRJZDtcclxuICAgIHRoaXMucHJvZ3JhbSA9IG51bGw7XHJcbiAgICB0aGlzLnVuaWZvcm1zID0gW107XHJcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSBbXTtcclxuXHJcbiAgICBpZiAoY29uZmlnLnByb2ZpbGUpIHtcclxuICAgICAgdGhpcy5zdGF0cyA9IHtcclxuICAgICAgICB1bmlmb3Jtc0NvdW50OiAwLFxyXG4gICAgICAgIGF0dHJpYnV0ZXNDb3VudDogMFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gbGlua1Byb2dyYW0gKGRlc2MsIGNvbW1hbmQpIHtcclxuICAgIHZhciBpLCBpbmZvO1xyXG5cclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIGNvbXBpbGUgJiBsaW5rXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICB2YXIgZnJhZ1NoYWRlciA9IGdldFNoYWRlcihHTF9GUkFHTUVOVF9TSEFERVIsIGRlc2MuZnJhZ0lkKTtcclxuICAgIHZhciB2ZXJ0U2hhZGVyID0gZ2V0U2hhZGVyKEdMX1ZFUlRFWF9TSEFERVIsIGRlc2MudmVydElkKTtcclxuXHJcbiAgICB2YXIgcHJvZ3JhbSA9IGRlc2MucHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcclxuICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcmFnU2hhZGVyKTtcclxuICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0U2hhZGVyKTtcclxuICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xyXG4gICAgY2hlY2skMS5saW5rRXJyb3IoXHJcbiAgICAgIGdsLFxyXG4gICAgICBwcm9ncmFtLFxyXG4gICAgICBzdHJpbmdTdG9yZS5zdHIoZGVzYy5mcmFnSWQpLFxyXG4gICAgICBzdHJpbmdTdG9yZS5zdHIoZGVzYy52ZXJ0SWQpLFxyXG4gICAgICBjb21tYW5kKTtcclxuXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBncmFiIHVuaWZvcm1zXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICB2YXIgbnVtVW5pZm9ybXMgPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIEdMX0FDVElWRV9VTklGT1JNUyk7XHJcbiAgICBpZiAoY29uZmlnLnByb2ZpbGUpIHtcclxuICAgICAgZGVzYy5zdGF0cy51bmlmb3Jtc0NvdW50ID0gbnVtVW5pZm9ybXM7XHJcbiAgICB9XHJcbiAgICB2YXIgdW5pZm9ybXMgPSBkZXNjLnVuaWZvcm1zO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IG51bVVuaWZvcm1zOyArK2kpIHtcclxuICAgICAgaW5mbyA9IGdsLmdldEFjdGl2ZVVuaWZvcm0ocHJvZ3JhbSwgaSk7XHJcbiAgICAgIGlmIChpbmZvKSB7XHJcbiAgICAgICAgaWYgKGluZm8uc2l6ZSA+IDEpIHtcclxuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaW5mby5zaXplOyArK2opIHtcclxuICAgICAgICAgICAgdmFyIG5hbWUgPSBpbmZvLm5hbWUucmVwbGFjZSgnWzBdJywgJ1snICsgaiArICddJyk7XHJcbiAgICAgICAgICAgIGluc2VydEFjdGl2ZUluZm8odW5pZm9ybXMsIG5ldyBBY3RpdmVJbmZvKFxyXG4gICAgICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICAgICAgc3RyaW5nU3RvcmUuaWQobmFtZSksXHJcbiAgICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIG5hbWUpLFxyXG4gICAgICAgICAgICAgIGluZm8pKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaW5zZXJ0QWN0aXZlSW5mbyh1bmlmb3JtcywgbmV3IEFjdGl2ZUluZm8oXHJcbiAgICAgICAgICAgIGluZm8ubmFtZSxcclxuICAgICAgICAgICAgc3RyaW5nU3RvcmUuaWQoaW5mby5uYW1lKSxcclxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIGluZm8ubmFtZSksXHJcbiAgICAgICAgICAgIGluZm8pKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBncmFiIGF0dHJpYnV0ZXNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIHZhciBudW1BdHRyaWJ1dGVzID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBHTF9BQ1RJVkVfQVRUUklCVVRFUyk7XHJcbiAgICBpZiAoY29uZmlnLnByb2ZpbGUpIHtcclxuICAgICAgZGVzYy5zdGF0cy5hdHRyaWJ1dGVzQ291bnQgPSBudW1BdHRyaWJ1dGVzO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBhdHRyaWJ1dGVzID0gZGVzYy5hdHRyaWJ1dGVzO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IG51bUF0dHJpYnV0ZXM7ICsraSkge1xyXG4gICAgICBpbmZvID0gZ2wuZ2V0QWN0aXZlQXR0cmliKHByb2dyYW0sIGkpO1xyXG4gICAgICBpZiAoaW5mbykge1xyXG4gICAgICAgIGluc2VydEFjdGl2ZUluZm8oYXR0cmlidXRlcywgbmV3IEFjdGl2ZUluZm8oXHJcbiAgICAgICAgICBpbmZvLm5hbWUsXHJcbiAgICAgICAgICBzdHJpbmdTdG9yZS5pZChpbmZvLm5hbWUpLFxyXG4gICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgaW5mby5uYW1lKSxcclxuICAgICAgICAgIGluZm8pKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKGNvbmZpZy5wcm9maWxlKSB7XHJcbiAgICBzdGF0cy5nZXRNYXhVbmlmb3Jtc0NvdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgbSA9IDA7XHJcbiAgICAgIHByb2dyYW1MaXN0LmZvckVhY2goZnVuY3Rpb24gKGRlc2MpIHtcclxuICAgICAgICBpZiAoZGVzYy5zdGF0cy51bmlmb3Jtc0NvdW50ID4gbSkge1xyXG4gICAgICAgICAgbSA9IGRlc2Muc3RhdHMudW5pZm9ybXNDb3VudDtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gbVxyXG4gICAgfTtcclxuXHJcbiAgICBzdGF0cy5nZXRNYXhBdHRyaWJ1dGVzQ291bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBtID0gMDtcclxuICAgICAgcHJvZ3JhbUxpc3QuZm9yRWFjaChmdW5jdGlvbiAoZGVzYykge1xyXG4gICAgICAgIGlmIChkZXNjLnN0YXRzLmF0dHJpYnV0ZXNDb3VudCA+IG0pIHtcclxuICAgICAgICAgIG0gPSBkZXNjLnN0YXRzLmF0dHJpYnV0ZXNDb3VudDtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gbVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlc3RvcmVTaGFkZXJzICgpIHtcclxuICAgIGZyYWdTaGFkZXJzID0ge307XHJcbiAgICB2ZXJ0U2hhZGVycyA9IHt9O1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9ncmFtTGlzdC5sZW5ndGg7ICsraSkge1xyXG4gICAgICBsaW5rUHJvZ3JhbShwcm9ncmFtTGlzdFtpXSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGRlbGV0ZVNoYWRlciA9IGdsLmRlbGV0ZVNoYWRlci5iaW5kKGdsKTtcclxuICAgICAgdmFsdWVzKGZyYWdTaGFkZXJzKS5mb3JFYWNoKGRlbGV0ZVNoYWRlcik7XHJcbiAgICAgIGZyYWdTaGFkZXJzID0ge307XHJcbiAgICAgIHZhbHVlcyh2ZXJ0U2hhZGVycykuZm9yRWFjaChkZWxldGVTaGFkZXIpO1xyXG4gICAgICB2ZXJ0U2hhZGVycyA9IHt9O1xyXG5cclxuICAgICAgcHJvZ3JhbUxpc3QuZm9yRWFjaChmdW5jdGlvbiAoZGVzYykge1xyXG4gICAgICAgIGdsLmRlbGV0ZVByb2dyYW0oZGVzYy5wcm9ncmFtKTtcclxuICAgICAgfSk7XHJcbiAgICAgIHByb2dyYW1MaXN0Lmxlbmd0aCA9IDA7XHJcbiAgICAgIHByb2dyYW1DYWNoZSA9IHt9O1xyXG5cclxuICAgICAgc3RhdHMuc2hhZGVyQ291bnQgPSAwO1xyXG4gICAgfSxcclxuXHJcbiAgICBwcm9ncmFtOiBmdW5jdGlvbiAodmVydElkLCBmcmFnSWQsIGNvbW1hbmQpIHtcclxuICAgICAgY2hlY2skMS5jb21tYW5kKHZlcnRJZCA+PSAwLCAnbWlzc2luZyB2ZXJ0ZXggc2hhZGVyJywgY29tbWFuZCk7XHJcbiAgICAgIGNoZWNrJDEuY29tbWFuZChmcmFnSWQgPj0gMCwgJ21pc3NpbmcgZnJhZ21lbnQgc2hhZGVyJywgY29tbWFuZCk7XHJcblxyXG4gICAgICB2YXIgY2FjaGUgPSBwcm9ncmFtQ2FjaGVbZnJhZ0lkXTtcclxuICAgICAgaWYgKCFjYWNoZSkge1xyXG4gICAgICAgIGNhY2hlID0gcHJvZ3JhbUNhY2hlW2ZyYWdJZF0gPSB7fTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgcHJvZ3JhbSA9IGNhY2hlW3ZlcnRJZF07XHJcbiAgICAgIGlmICghcHJvZ3JhbSkge1xyXG4gICAgICAgIHByb2dyYW0gPSBuZXcgUkVHTFByb2dyYW0oZnJhZ0lkLCB2ZXJ0SWQpO1xyXG4gICAgICAgIHN0YXRzLnNoYWRlckNvdW50Kys7XHJcblxyXG4gICAgICAgIGxpbmtQcm9ncmFtKHByb2dyYW0sIGNvbW1hbmQpO1xyXG4gICAgICAgIGNhY2hlW3ZlcnRJZF0gPSBwcm9ncmFtO1xyXG4gICAgICAgIHByb2dyYW1MaXN0LnB1c2gocHJvZ3JhbSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHByb2dyYW1cclxuICAgIH0sXHJcblxyXG4gICAgcmVzdG9yZTogcmVzdG9yZVNoYWRlcnMsXHJcblxyXG4gICAgc2hhZGVyOiBnZXRTaGFkZXIsXHJcblxyXG4gICAgZnJhZzogLTEsXHJcbiAgICB2ZXJ0OiAtMVxyXG4gIH1cclxufVxyXG5cclxudmFyIEdMX1JHQkEkMyA9IDY0MDg7XHJcbnZhciBHTF9VTlNJR05FRF9CWVRFJDcgPSA1MTIxO1xyXG52YXIgR0xfUEFDS19BTElHTk1FTlQgPSAweDBEMDU7XHJcbnZhciBHTF9GTE9BVCQ3ID0gMHgxNDA2OyAvLyA1MTI2XHJcblxyXG5mdW5jdGlvbiB3cmFwUmVhZFBpeGVscyAoXHJcbiAgZ2wsXHJcbiAgZnJhbWVidWZmZXJTdGF0ZSxcclxuICByZWdsUG9sbCxcclxuICBjb250ZXh0LFxyXG4gIGdsQXR0cmlidXRlcyxcclxuICBleHRlbnNpb25zLFxyXG4gIGxpbWl0cykge1xyXG4gIGZ1bmN0aW9uIHJlYWRQaXhlbHNJbXBsIChpbnB1dCkge1xyXG4gICAgdmFyIHR5cGU7XHJcbiAgICBpZiAoZnJhbWVidWZmZXJTdGF0ZS5uZXh0ID09PSBudWxsKSB7XHJcbiAgICAgIGNoZWNrJDEoXHJcbiAgICAgICAgZ2xBdHRyaWJ1dGVzLnByZXNlcnZlRHJhd2luZ0J1ZmZlcixcclxuICAgICAgICAneW91IG11c3QgY3JlYXRlIGEgd2ViZ2wgY29udGV4dCB3aXRoIFwicHJlc2VydmVEcmF3aW5nQnVmZmVyXCI6dHJ1ZSBpbiBvcmRlciB0byByZWFkIHBpeGVscyBmcm9tIHRoZSBkcmF3aW5nIGJ1ZmZlcicpO1xyXG4gICAgICB0eXBlID0gR0xfVU5TSUdORURfQllURSQ3O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY2hlY2skMShcclxuICAgICAgICBmcmFtZWJ1ZmZlclN0YXRlLm5leHQuY29sb3JBdHRhY2htZW50c1swXS50ZXh0dXJlICE9PSBudWxsLFxyXG4gICAgICAgICAgJ1lvdSBjYW5ub3QgcmVhZCBmcm9tIGEgcmVuZGVyYnVmZmVyJyk7XHJcbiAgICAgIHR5cGUgPSBmcmFtZWJ1ZmZlclN0YXRlLm5leHQuY29sb3JBdHRhY2htZW50c1swXS50ZXh0dXJlLl90ZXh0dXJlLnR5cGU7XHJcblxyXG4gICAgICBpZiAoZXh0ZW5zaW9ucy5vZXNfdGV4dHVyZV9mbG9hdCkge1xyXG4gICAgICAgIGNoZWNrJDEoXHJcbiAgICAgICAgICB0eXBlID09PSBHTF9VTlNJR05FRF9CWVRFJDcgfHwgdHlwZSA9PT0gR0xfRkxPQVQkNyxcclxuICAgICAgICAgICdSZWFkaW5nIGZyb20gYSBmcmFtZWJ1ZmZlciBpcyBvbmx5IGFsbG93ZWQgZm9yIHRoZSB0eXBlcyBcXCd1aW50OFxcJyBhbmQgXFwnZmxvYXRcXCcnKTtcclxuXHJcbiAgICAgICAgaWYgKHR5cGUgPT09IEdMX0ZMT0FUJDcpIHtcclxuICAgICAgICAgIGNoZWNrJDEobGltaXRzLnJlYWRGbG9hdCwgJ1JlYWRpbmcgXFwnZmxvYXRcXCcgdmFsdWVzIGlzIG5vdCBwZXJtaXR0ZWQgaW4geW91ciBicm93c2VyLiBGb3IgYSBmYWxsYmFjaywgcGxlYXNlIHNlZTogaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZ2xzbC1yZWFkLWZsb2F0Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNoZWNrJDEoXHJcbiAgICAgICAgICB0eXBlID09PSBHTF9VTlNJR05FRF9CWVRFJDcsXHJcbiAgICAgICAgICAnUmVhZGluZyBmcm9tIGEgZnJhbWVidWZmZXIgaXMgb25seSBhbGxvd2VkIGZvciB0aGUgdHlwZSBcXCd1aW50OFxcJycpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHggPSAwO1xyXG4gICAgdmFyIHkgPSAwO1xyXG4gICAgdmFyIHdpZHRoID0gY29udGV4dC5mcmFtZWJ1ZmZlcldpZHRoO1xyXG4gICAgdmFyIGhlaWdodCA9IGNvbnRleHQuZnJhbWVidWZmZXJIZWlnaHQ7XHJcbiAgICB2YXIgZGF0YSA9IG51bGw7XHJcblxyXG4gICAgaWYgKGlzVHlwZWRBcnJheShpbnB1dCkpIHtcclxuICAgICAgZGF0YSA9IGlucHV0O1xyXG4gICAgfSBlbHNlIGlmIChpbnB1dCkge1xyXG4gICAgICBjaGVjayQxLnR5cGUoaW5wdXQsICdvYmplY3QnLCAnaW52YWxpZCBhcmd1bWVudHMgdG8gcmVnbC5yZWFkKCknKTtcclxuICAgICAgeCA9IGlucHV0LnggfCAwO1xyXG4gICAgICB5ID0gaW5wdXQueSB8IDA7XHJcbiAgICAgIGNoZWNrJDEoXHJcbiAgICAgICAgeCA+PSAwICYmIHggPCBjb250ZXh0LmZyYW1lYnVmZmVyV2lkdGgsXHJcbiAgICAgICAgJ2ludmFsaWQgeCBvZmZzZXQgZm9yIHJlZ2wucmVhZCcpO1xyXG4gICAgICBjaGVjayQxKFxyXG4gICAgICAgIHkgPj0gMCAmJiB5IDwgY29udGV4dC5mcmFtZWJ1ZmZlckhlaWdodCxcclxuICAgICAgICAnaW52YWxpZCB5IG9mZnNldCBmb3IgcmVnbC5yZWFkJyk7XHJcbiAgICAgIHdpZHRoID0gKGlucHV0LndpZHRoIHx8IChjb250ZXh0LmZyYW1lYnVmZmVyV2lkdGggLSB4KSkgfCAwO1xyXG4gICAgICBoZWlnaHQgPSAoaW5wdXQuaGVpZ2h0IHx8IChjb250ZXh0LmZyYW1lYnVmZmVySGVpZ2h0IC0geSkpIHwgMDtcclxuICAgICAgZGF0YSA9IGlucHV0LmRhdGEgfHwgbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBzYW5pdHkgY2hlY2sgaW5wdXQuZGF0YVxyXG4gICAgaWYgKGRhdGEpIHtcclxuICAgICAgaWYgKHR5cGUgPT09IEdMX1VOU0lHTkVEX0JZVEUkNykge1xyXG4gICAgICAgIGNoZWNrJDEoXHJcbiAgICAgICAgICBkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSxcclxuICAgICAgICAgICdidWZmZXIgbXVzdCBiZSBcXCdVaW50OEFycmF5XFwnIHdoZW4gcmVhZGluZyBmcm9tIGEgZnJhbWVidWZmZXIgb2YgdHlwZSBcXCd1aW50OFxcJycpO1xyXG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IEdMX0ZMT0FUJDcpIHtcclxuICAgICAgICBjaGVjayQxKFxyXG4gICAgICAgICAgZGF0YSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSxcclxuICAgICAgICAgICdidWZmZXIgbXVzdCBiZSBcXCdGbG9hdDMyQXJyYXlcXCcgd2hlbiByZWFkaW5nIGZyb20gYSBmcmFtZWJ1ZmZlciBvZiB0eXBlIFxcJ2Zsb2F0XFwnJyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjaGVjayQxKFxyXG4gICAgICB3aWR0aCA+IDAgJiYgd2lkdGggKyB4IDw9IGNvbnRleHQuZnJhbWVidWZmZXJXaWR0aCxcclxuICAgICAgJ2ludmFsaWQgd2lkdGggZm9yIHJlYWQgcGl4ZWxzJyk7XHJcbiAgICBjaGVjayQxKFxyXG4gICAgICBoZWlnaHQgPiAwICYmIGhlaWdodCArIHkgPD0gY29udGV4dC5mcmFtZWJ1ZmZlckhlaWdodCxcclxuICAgICAgJ2ludmFsaWQgaGVpZ2h0IGZvciByZWFkIHBpeGVscycpO1xyXG5cclxuICAgIC8vIFVwZGF0ZSBXZWJHTCBzdGF0ZVxyXG4gICAgcmVnbFBvbGwoKTtcclxuXHJcbiAgICAvLyBDb21wdXRlIHNpemVcclxuICAgIHZhciBzaXplID0gd2lkdGggKiBoZWlnaHQgKiA0O1xyXG5cclxuICAgIC8vIEFsbG9jYXRlIGRhdGFcclxuICAgIGlmICghZGF0YSkge1xyXG4gICAgICBpZiAodHlwZSA9PT0gR0xfVU5TSUdORURfQllURSQ3KSB7XHJcbiAgICAgICAgZGF0YSA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xyXG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IEdMX0ZMT0FUJDcpIHtcclxuICAgICAgICBkYXRhID0gZGF0YSB8fCBuZXcgRmxvYXQzMkFycmF5KHNpemUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVHlwZSBjaGVja1xyXG4gICAgY2hlY2skMS5pc1R5cGVkQXJyYXkoZGF0YSwgJ2RhdGEgYnVmZmVyIGZvciByZWdsLnJlYWQoKSBtdXN0IGJlIGEgdHlwZWRhcnJheScpO1xyXG4gICAgY2hlY2skMShkYXRhLmJ5dGVMZW5ndGggPj0gc2l6ZSwgJ2RhdGEgYnVmZmVyIGZvciByZWdsLnJlYWQoKSB0b28gc21hbGwnKTtcclxuXHJcbiAgICAvLyBSdW4gcmVhZCBwaXhlbHNcclxuICAgIGdsLnBpeGVsU3RvcmVpKEdMX1BBQ0tfQUxJR05NRU5ULCA0KTtcclxuICAgIGdsLnJlYWRQaXhlbHMoeCwgeSwgd2lkdGgsIGhlaWdodCwgR0xfUkdCQSQzLFxyXG4gICAgICAgICAgICAgICAgICB0eXBlLFxyXG4gICAgICAgICAgICAgICAgICBkYXRhKTtcclxuXHJcbiAgICByZXR1cm4gZGF0YVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmVhZFBpeGVsc0ZCTyAob3B0aW9ucykge1xyXG4gICAgdmFyIHJlc3VsdDtcclxuICAgIGZyYW1lYnVmZmVyU3RhdGUuc2V0RkJPKHtcclxuICAgICAgZnJhbWVidWZmZXI6IG9wdGlvbnMuZnJhbWVidWZmZXJcclxuICAgIH0sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmVzdWx0ID0gcmVhZFBpeGVsc0ltcGwob3B0aW9ucyk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXN1bHRcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlYWRQaXhlbHMgKG9wdGlvbnMpIHtcclxuICAgIGlmICghb3B0aW9ucyB8fCAhKCdmcmFtZWJ1ZmZlcicgaW4gb3B0aW9ucykpIHtcclxuICAgICAgcmV0dXJuIHJlYWRQaXhlbHNJbXBsKG9wdGlvbnMpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gcmVhZFBpeGVsc0ZCTyhvcHRpb25zKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJlYWRQaXhlbHNcclxufVxyXG5cclxuZnVuY3Rpb24gc2xpY2UgKHgpIHtcclxuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoeClcclxufVxyXG5cclxuZnVuY3Rpb24gam9pbiAoeCkge1xyXG4gIHJldHVybiBzbGljZSh4KS5qb2luKCcnKVxyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVFbnZpcm9ubWVudCAoKSB7XHJcbiAgLy8gVW5pcXVlIHZhcmlhYmxlIGlkIGNvdW50ZXJcclxuICB2YXIgdmFyQ291bnRlciA9IDA7XHJcblxyXG4gIC8vIExpbmtlZCB2YWx1ZXMgYXJlIHBhc3NlZCBmcm9tIHRoaXMgc2NvcGUgaW50byB0aGUgZ2VuZXJhdGVkIGNvZGUgYmxvY2tcclxuICAvLyBDYWxsaW5nIGxpbmsoKSBwYXNzZXMgYSB2YWx1ZSBpbnRvIHRoZSBnZW5lcmF0ZWQgc2NvcGUgYW5kIHJldHVybnNcclxuICAvLyB0aGUgdmFyaWFibGUgbmFtZSB3aGljaCBpdCBpcyBib3VuZCB0b1xyXG4gIHZhciBsaW5rZWROYW1lcyA9IFtdO1xyXG4gIHZhciBsaW5rZWRWYWx1ZXMgPSBbXTtcclxuICBmdW5jdGlvbiBsaW5rICh2YWx1ZSkge1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5rZWRWYWx1ZXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgaWYgKGxpbmtlZFZhbHVlc1tpXSA9PT0gdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gbGlua2VkTmFtZXNbaV1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBuYW1lID0gJ2cnICsgKHZhckNvdW50ZXIrKyk7XHJcbiAgICBsaW5rZWROYW1lcy5wdXNoKG5hbWUpO1xyXG4gICAgbGlua2VkVmFsdWVzLnB1c2godmFsdWUpO1xyXG4gICAgcmV0dXJuIG5hbWVcclxuICB9XHJcblxyXG4gIC8vIGNyZWF0ZSBhIGNvZGUgYmxvY2tcclxuICBmdW5jdGlvbiBibG9jayAoKSB7XHJcbiAgICB2YXIgY29kZSA9IFtdO1xyXG4gICAgZnVuY3Rpb24gcHVzaCAoKSB7XHJcbiAgICAgIGNvZGUucHVzaC5hcHBseShjb2RlLCBzbGljZShhcmd1bWVudHMpKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgdmFycyA9IFtdO1xyXG4gICAgZnVuY3Rpb24gZGVmICgpIHtcclxuICAgICAgdmFyIG5hbWUgPSAndicgKyAodmFyQ291bnRlcisrKTtcclxuICAgICAgdmFycy5wdXNoKG5hbWUpO1xyXG5cclxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgY29kZS5wdXNoKG5hbWUsICc9Jyk7XHJcbiAgICAgICAgY29kZS5wdXNoLmFwcGx5KGNvZGUsIHNsaWNlKGFyZ3VtZW50cykpO1xyXG4gICAgICAgIGNvZGUucHVzaCgnOycpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbmFtZVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBleHRlbmQocHVzaCwge1xyXG4gICAgICBkZWY6IGRlZixcclxuICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gam9pbihbXHJcbiAgICAgICAgICAodmFycy5sZW5ndGggPiAwID8gJ3ZhciAnICsgdmFycyArICc7JyA6ICcnKSxcclxuICAgICAgICAgIGpvaW4oY29kZSlcclxuICAgICAgICBdKVxyXG4gICAgICB9XHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2NvcGUgKCkge1xyXG4gICAgdmFyIGVudHJ5ID0gYmxvY2soKTtcclxuICAgIHZhciBleGl0ID0gYmxvY2soKTtcclxuXHJcbiAgICB2YXIgZW50cnlUb1N0cmluZyA9IGVudHJ5LnRvU3RyaW5nO1xyXG4gICAgdmFyIGV4aXRUb1N0cmluZyA9IGV4aXQudG9TdHJpbmc7XHJcblxyXG4gICAgZnVuY3Rpb24gc2F2ZSAob2JqZWN0LCBwcm9wKSB7XHJcbiAgICAgIGV4aXQob2JqZWN0LCBwcm9wLCAnPScsIGVudHJ5LmRlZihvYmplY3QsIHByb3ApLCAnOycpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBleHRlbmQoZnVuY3Rpb24gKCkge1xyXG4gICAgICBlbnRyeS5hcHBseShlbnRyeSwgc2xpY2UoYXJndW1lbnRzKSk7XHJcbiAgICB9LCB7XHJcbiAgICAgIGRlZjogZW50cnkuZGVmLFxyXG4gICAgICBlbnRyeTogZW50cnksXHJcbiAgICAgIGV4aXQ6IGV4aXQsXHJcbiAgICAgIHNhdmU6IHNhdmUsXHJcbiAgICAgIHNldDogZnVuY3Rpb24gKG9iamVjdCwgcHJvcCwgdmFsdWUpIHtcclxuICAgICAgICBzYXZlKG9iamVjdCwgcHJvcCk7XHJcbiAgICAgICAgZW50cnkob2JqZWN0LCBwcm9wLCAnPScsIHZhbHVlLCAnOycpO1xyXG4gICAgICB9LFxyXG4gICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBlbnRyeVRvU3RyaW5nKCkgKyBleGl0VG9TdHJpbmcoKVxyXG4gICAgICB9XHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY29uZGl0aW9uYWwgKCkge1xyXG4gICAgdmFyIHByZWQgPSBqb2luKGFyZ3VtZW50cyk7XHJcbiAgICB2YXIgdGhlbkJsb2NrID0gc2NvcGUoKTtcclxuICAgIHZhciBlbHNlQmxvY2sgPSBzY29wZSgpO1xyXG5cclxuICAgIHZhciB0aGVuVG9TdHJpbmcgPSB0aGVuQmxvY2sudG9TdHJpbmc7XHJcbiAgICB2YXIgZWxzZVRvU3RyaW5nID0gZWxzZUJsb2NrLnRvU3RyaW5nO1xyXG5cclxuICAgIHJldHVybiBleHRlbmQodGhlbkJsb2NrLCB7XHJcbiAgICAgIHRoZW46IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGVuQmxvY2suYXBwbHkodGhlbkJsb2NrLCBzbGljZShhcmd1bWVudHMpKTtcclxuICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICB9LFxyXG4gICAgICBlbHNlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZWxzZUJsb2NrLmFwcGx5KGVsc2VCbG9jaywgc2xpY2UoYXJndW1lbnRzKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgfSxcclxuICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZWxzZUNsYXVzZSA9IGVsc2VUb1N0cmluZygpO1xyXG4gICAgICAgIGlmIChlbHNlQ2xhdXNlKSB7XHJcbiAgICAgICAgICBlbHNlQ2xhdXNlID0gJ2Vsc2V7JyArIGVsc2VDbGF1c2UgKyAnfSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBqb2luKFtcclxuICAgICAgICAgICdpZignLCBwcmVkLCAnKXsnLFxyXG4gICAgICAgICAgdGhlblRvU3RyaW5nKCksXHJcbiAgICAgICAgICAnfScsIGVsc2VDbGF1c2VcclxuICAgICAgICBdKVxyXG4gICAgICB9XHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgLy8gcHJvY2VkdXJlIGxpc3RcclxuICB2YXIgZ2xvYmFsQmxvY2sgPSBibG9jaygpO1xyXG4gIHZhciBwcm9jZWR1cmVzID0ge307XHJcbiAgZnVuY3Rpb24gcHJvYyAobmFtZSwgY291bnQpIHtcclxuICAgIHZhciBhcmdzID0gW107XHJcbiAgICBmdW5jdGlvbiBhcmcgKCkge1xyXG4gICAgICB2YXIgbmFtZSA9ICdhJyArIGFyZ3MubGVuZ3RoO1xyXG4gICAgICBhcmdzLnB1c2gobmFtZSk7XHJcbiAgICAgIHJldHVybiBuYW1lXHJcbiAgICB9XHJcblxyXG4gICAgY291bnQgPSBjb3VudCB8fCAwO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XHJcbiAgICAgIGFyZygpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBib2R5ID0gc2NvcGUoKTtcclxuICAgIHZhciBib2R5VG9TdHJpbmcgPSBib2R5LnRvU3RyaW5nO1xyXG5cclxuICAgIHZhciByZXN1bHQgPSBwcm9jZWR1cmVzW25hbWVdID0gZXh0ZW5kKGJvZHksIHtcclxuICAgICAgYXJnOiBhcmcsXHJcbiAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGpvaW4oW1xyXG4gICAgICAgICAgJ2Z1bmN0aW9uKCcsIGFyZ3Muam9pbigpLCAnKXsnLFxyXG4gICAgICAgICAgYm9keVRvU3RyaW5nKCksXHJcbiAgICAgICAgICAnfSdcclxuICAgICAgICBdKVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gcmVzdWx0XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjb21waWxlICgpIHtcclxuICAgIHZhciBjb2RlID0gWydcInVzZSBzdHJpY3RcIjsnLFxyXG4gICAgICBnbG9iYWxCbG9jayxcclxuICAgICAgJ3JldHVybiB7J107XHJcbiAgICBPYmplY3Qua2V5cyhwcm9jZWR1cmVzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgIGNvZGUucHVzaCgnXCInLCBuYW1lLCAnXCI6JywgcHJvY2VkdXJlc1tuYW1lXS50b1N0cmluZygpLCAnLCcpO1xyXG4gICAgfSk7XHJcbiAgICBjb2RlLnB1c2goJ30nKTtcclxuICAgIHZhciBzcmMgPSBqb2luKGNvZGUpXHJcbiAgICAgIC5yZXBsYWNlKC87L2csICc7XFxuJylcclxuICAgICAgLnJlcGxhY2UoL30vZywgJ31cXG4nKVxyXG4gICAgICAucmVwbGFjZSgvey9nLCAne1xcbicpO1xyXG4gICAgdmFyIHByb2MgPSBGdW5jdGlvbi5hcHBseShudWxsLCBsaW5rZWROYW1lcy5jb25jYXQoc3JjKSk7XHJcbiAgICByZXR1cm4gcHJvYy5hcHBseShudWxsLCBsaW5rZWRWYWx1ZXMpXHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgZ2xvYmFsOiBnbG9iYWxCbG9jayxcclxuICAgIGxpbms6IGxpbmssXHJcbiAgICBibG9jazogYmxvY2ssXHJcbiAgICBwcm9jOiBwcm9jLFxyXG4gICAgc2NvcGU6IHNjb3BlLFxyXG4gICAgY29uZDogY29uZGl0aW9uYWwsXHJcbiAgICBjb21waWxlOiBjb21waWxlXHJcbiAgfVxyXG59XHJcblxyXG4vLyBcImN1dGVcIiBuYW1lcyBmb3IgdmVjdG9yIGNvbXBvbmVudHNcclxudmFyIENVVEVfQ09NUE9ORU5UUyA9ICd4eXp3Jy5zcGxpdCgnJyk7XHJcblxyXG52YXIgR0xfVU5TSUdORURfQllURSQ4ID0gNTEyMTtcclxuXHJcbnZhciBBVFRSSUJfU1RBVEVfUE9JTlRFUiA9IDE7XHJcbnZhciBBVFRSSUJfU1RBVEVfQ09OU1RBTlQgPSAyO1xyXG5cclxudmFyIERZTl9GVU5DJDEgPSAwO1xyXG52YXIgRFlOX1BST1AkMSA9IDE7XHJcbnZhciBEWU5fQ09OVEVYVCQxID0gMjtcclxudmFyIERZTl9TVEFURSQxID0gMztcclxudmFyIERZTl9USFVOSyA9IDQ7XHJcblxyXG52YXIgU19ESVRIRVIgPSAnZGl0aGVyJztcclxudmFyIFNfQkxFTkRfRU5BQkxFID0gJ2JsZW5kLmVuYWJsZSc7XHJcbnZhciBTX0JMRU5EX0NPTE9SID0gJ2JsZW5kLmNvbG9yJztcclxudmFyIFNfQkxFTkRfRVFVQVRJT04gPSAnYmxlbmQuZXF1YXRpb24nO1xyXG52YXIgU19CTEVORF9GVU5DID0gJ2JsZW5kLmZ1bmMnO1xyXG52YXIgU19ERVBUSF9FTkFCTEUgPSAnZGVwdGguZW5hYmxlJztcclxudmFyIFNfREVQVEhfRlVOQyA9ICdkZXB0aC5mdW5jJztcclxudmFyIFNfREVQVEhfUkFOR0UgPSAnZGVwdGgucmFuZ2UnO1xyXG52YXIgU19ERVBUSF9NQVNLID0gJ2RlcHRoLm1hc2snO1xyXG52YXIgU19DT0xPUl9NQVNLID0gJ2NvbG9yTWFzayc7XHJcbnZhciBTX0NVTExfRU5BQkxFID0gJ2N1bGwuZW5hYmxlJztcclxudmFyIFNfQ1VMTF9GQUNFID0gJ2N1bGwuZmFjZSc7XHJcbnZhciBTX0ZST05UX0ZBQ0UgPSAnZnJvbnRGYWNlJztcclxudmFyIFNfTElORV9XSURUSCA9ICdsaW5lV2lkdGgnO1xyXG52YXIgU19QT0xZR09OX09GRlNFVF9FTkFCTEUgPSAncG9seWdvbk9mZnNldC5lbmFibGUnO1xyXG52YXIgU19QT0xZR09OX09GRlNFVF9PRkZTRVQgPSAncG9seWdvbk9mZnNldC5vZmZzZXQnO1xyXG52YXIgU19TQU1QTEVfQUxQSEEgPSAnc2FtcGxlLmFscGhhJztcclxudmFyIFNfU0FNUExFX0VOQUJMRSA9ICdzYW1wbGUuZW5hYmxlJztcclxudmFyIFNfU0FNUExFX0NPVkVSQUdFID0gJ3NhbXBsZS5jb3ZlcmFnZSc7XHJcbnZhciBTX1NURU5DSUxfRU5BQkxFID0gJ3N0ZW5jaWwuZW5hYmxlJztcclxudmFyIFNfU1RFTkNJTF9NQVNLID0gJ3N0ZW5jaWwubWFzayc7XHJcbnZhciBTX1NURU5DSUxfRlVOQyA9ICdzdGVuY2lsLmZ1bmMnO1xyXG52YXIgU19TVEVOQ0lMX09QRlJPTlQgPSAnc3RlbmNpbC5vcEZyb250JztcclxudmFyIFNfU1RFTkNJTF9PUEJBQ0sgPSAnc3RlbmNpbC5vcEJhY2snO1xyXG52YXIgU19TQ0lTU09SX0VOQUJMRSA9ICdzY2lzc29yLmVuYWJsZSc7XHJcbnZhciBTX1NDSVNTT1JfQk9YID0gJ3NjaXNzb3IuYm94JztcclxudmFyIFNfVklFV1BPUlQgPSAndmlld3BvcnQnO1xyXG5cclxudmFyIFNfUFJPRklMRSA9ICdwcm9maWxlJztcclxuXHJcbnZhciBTX0ZSQU1FQlVGRkVSID0gJ2ZyYW1lYnVmZmVyJztcclxudmFyIFNfVkVSVCA9ICd2ZXJ0JztcclxudmFyIFNfRlJBRyA9ICdmcmFnJztcclxudmFyIFNfRUxFTUVOVFMgPSAnZWxlbWVudHMnO1xyXG52YXIgU19QUklNSVRJVkUgPSAncHJpbWl0aXZlJztcclxudmFyIFNfQ09VTlQgPSAnY291bnQnO1xyXG52YXIgU19PRkZTRVQgPSAnb2Zmc2V0JztcclxudmFyIFNfSU5TVEFOQ0VTID0gJ2luc3RhbmNlcyc7XHJcblxyXG52YXIgU1VGRklYX1dJRFRIID0gJ1dpZHRoJztcclxudmFyIFNVRkZJWF9IRUlHSFQgPSAnSGVpZ2h0JztcclxuXHJcbnZhciBTX0ZSQU1FQlVGRkVSX1dJRFRIID0gU19GUkFNRUJVRkZFUiArIFNVRkZJWF9XSURUSDtcclxudmFyIFNfRlJBTUVCVUZGRVJfSEVJR0hUID0gU19GUkFNRUJVRkZFUiArIFNVRkZJWF9IRUlHSFQ7XHJcbnZhciBTX1ZJRVdQT1JUX1dJRFRIID0gU19WSUVXUE9SVCArIFNVRkZJWF9XSURUSDtcclxudmFyIFNfVklFV1BPUlRfSEVJR0hUID0gU19WSUVXUE9SVCArIFNVRkZJWF9IRUlHSFQ7XHJcbnZhciBTX0RSQVdJTkdCVUZGRVIgPSAnZHJhd2luZ0J1ZmZlcic7XHJcbnZhciBTX0RSQVdJTkdCVUZGRVJfV0lEVEggPSBTX0RSQVdJTkdCVUZGRVIgKyBTVUZGSVhfV0lEVEg7XHJcbnZhciBTX0RSQVdJTkdCVUZGRVJfSEVJR0hUID0gU19EUkFXSU5HQlVGRkVSICsgU1VGRklYX0hFSUdIVDtcclxuXHJcbnZhciBORVNURURfT1BUSU9OUyA9IFtcclxuICBTX0JMRU5EX0ZVTkMsXHJcbiAgU19CTEVORF9FUVVBVElPTixcclxuICBTX1NURU5DSUxfRlVOQyxcclxuICBTX1NURU5DSUxfT1BGUk9OVCxcclxuICBTX1NURU5DSUxfT1BCQUNLLFxyXG4gIFNfU0FNUExFX0NPVkVSQUdFLFxyXG4gIFNfVklFV1BPUlQsXHJcbiAgU19TQ0lTU09SX0JPWCxcclxuICBTX1BPTFlHT05fT0ZGU0VUX09GRlNFVFxyXG5dO1xyXG5cclxudmFyIEdMX0FSUkFZX0JVRkZFUiQxID0gMzQ5NjI7XHJcbnZhciBHTF9FTEVNRU5UX0FSUkFZX0JVRkZFUiQxID0gMzQ5NjM7XHJcblxyXG52YXIgR0xfRlJBR01FTlRfU0hBREVSJDEgPSAzNTYzMjtcclxudmFyIEdMX1ZFUlRFWF9TSEFERVIkMSA9IDM1NjMzO1xyXG5cclxudmFyIEdMX1RFWFRVUkVfMkQkMyA9IDB4MERFMTtcclxudmFyIEdMX1RFWFRVUkVfQ1VCRV9NQVAkMiA9IDB4ODUxMztcclxuXHJcbnZhciBHTF9DVUxMX0ZBQ0UgPSAweDBCNDQ7XHJcbnZhciBHTF9CTEVORCA9IDB4MEJFMjtcclxudmFyIEdMX0RJVEhFUiA9IDB4MEJEMDtcclxudmFyIEdMX1NURU5DSUxfVEVTVCA9IDB4MEI5MDtcclxudmFyIEdMX0RFUFRIX1RFU1QgPSAweDBCNzE7XHJcbnZhciBHTF9TQ0lTU09SX1RFU1QgPSAweDBDMTE7XHJcbnZhciBHTF9QT0xZR09OX09GRlNFVF9GSUxMID0gMHg4MDM3O1xyXG52YXIgR0xfU0FNUExFX0FMUEhBX1RPX0NPVkVSQUdFID0gMHg4MDlFO1xyXG52YXIgR0xfU0FNUExFX0NPVkVSQUdFID0gMHg4MEEwO1xyXG5cclxudmFyIEdMX0ZMT0FUJDggPSA1MTI2O1xyXG52YXIgR0xfRkxPQVRfVkVDMiA9IDM1NjY0O1xyXG52YXIgR0xfRkxPQVRfVkVDMyA9IDM1NjY1O1xyXG52YXIgR0xfRkxPQVRfVkVDNCA9IDM1NjY2O1xyXG52YXIgR0xfSU5UJDMgPSA1MTI0O1xyXG52YXIgR0xfSU5UX1ZFQzIgPSAzNTY2NztcclxudmFyIEdMX0lOVF9WRUMzID0gMzU2Njg7XHJcbnZhciBHTF9JTlRfVkVDNCA9IDM1NjY5O1xyXG52YXIgR0xfQk9PTCA9IDM1NjcwO1xyXG52YXIgR0xfQk9PTF9WRUMyID0gMzU2NzE7XHJcbnZhciBHTF9CT09MX1ZFQzMgPSAzNTY3MjtcclxudmFyIEdMX0JPT0xfVkVDNCA9IDM1NjczO1xyXG52YXIgR0xfRkxPQVRfTUFUMiA9IDM1Njc0O1xyXG52YXIgR0xfRkxPQVRfTUFUMyA9IDM1Njc1O1xyXG52YXIgR0xfRkxPQVRfTUFUNCA9IDM1Njc2O1xyXG52YXIgR0xfU0FNUExFUl8yRCA9IDM1Njc4O1xyXG52YXIgR0xfU0FNUExFUl9DVUJFID0gMzU2ODA7XHJcblxyXG52YXIgR0xfVFJJQU5HTEVTJDEgPSA0O1xyXG5cclxudmFyIEdMX0ZST05UID0gMTAyODtcclxudmFyIEdMX0JBQ0sgPSAxMDI5O1xyXG52YXIgR0xfQ1cgPSAweDA5MDA7XHJcbnZhciBHTF9DQ1cgPSAweDA5MDE7XHJcbnZhciBHTF9NSU5fRVhUID0gMHg4MDA3O1xyXG52YXIgR0xfTUFYX0VYVCA9IDB4ODAwODtcclxudmFyIEdMX0FMV0FZUyA9IDUxOTtcclxudmFyIEdMX0tFRVAgPSA3NjgwO1xyXG52YXIgR0xfWkVSTyA9IDA7XHJcbnZhciBHTF9PTkUgPSAxO1xyXG52YXIgR0xfRlVOQ19BREQgPSAweDgwMDY7XHJcbnZhciBHTF9MRVNTID0gNTEzO1xyXG5cclxudmFyIEdMX0ZSQU1FQlVGRkVSJDIgPSAweDhENDA7XHJcbnZhciBHTF9DT0xPUl9BVFRBQ0hNRU5UMCQyID0gMHg4Q0UwO1xyXG5cclxudmFyIGJsZW5kRnVuY3MgPSB7XHJcbiAgJzAnOiAwLFxyXG4gICcxJzogMSxcclxuICAnemVybyc6IDAsXHJcbiAgJ29uZSc6IDEsXHJcbiAgJ3NyYyBjb2xvcic6IDc2OCxcclxuICAnb25lIG1pbnVzIHNyYyBjb2xvcic6IDc2OSxcclxuICAnc3JjIGFscGhhJzogNzcwLFxyXG4gICdvbmUgbWludXMgc3JjIGFscGhhJzogNzcxLFxyXG4gICdkc3QgY29sb3InOiA3NzQsXHJcbiAgJ29uZSBtaW51cyBkc3QgY29sb3InOiA3NzUsXHJcbiAgJ2RzdCBhbHBoYSc6IDc3MixcclxuICAnb25lIG1pbnVzIGRzdCBhbHBoYSc6IDc3MyxcclxuICAnY29uc3RhbnQgY29sb3InOiAzMjc2OSxcclxuICAnb25lIG1pbnVzIGNvbnN0YW50IGNvbG9yJzogMzI3NzAsXHJcbiAgJ2NvbnN0YW50IGFscGhhJzogMzI3NzEsXHJcbiAgJ29uZSBtaW51cyBjb25zdGFudCBhbHBoYSc6IDMyNzcyLFxyXG4gICdzcmMgYWxwaGEgc2F0dXJhdGUnOiA3NzZcclxufTtcclxuXHJcbi8vIFRoZXJlIGFyZSBpbnZhbGlkIHZhbHVlcyBmb3Igc3JjUkdCIGFuZCBkc3RSR0IuIFNlZTpcclxuLy8gaHR0cHM6Ly93d3cua2hyb25vcy5vcmcvcmVnaXN0cnkvd2ViZ2wvc3BlY3MvMS4wLyM2LjEzXHJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvV2ViR0wvYmxvYi8wZDMyMDFmNWY3ZWMzYzAwNjBiYzFmMDQwNzc0NjE1NDFmMTk4N2I5L2NvbmZvcm1hbmNlLXN1aXRlcy8xLjAuMy9jb25mb3JtYW5jZS9taXNjL3dlYmdsLXNwZWNpZmljLmh0bWwjTDU2XHJcbnZhciBpbnZhbGlkQmxlbmRDb21iaW5hdGlvbnMgPSBbXHJcbiAgJ2NvbnN0YW50IGNvbG9yLCBjb25zdGFudCBhbHBoYScsXHJcbiAgJ29uZSBtaW51cyBjb25zdGFudCBjb2xvciwgY29uc3RhbnQgYWxwaGEnLFxyXG4gICdjb25zdGFudCBjb2xvciwgb25lIG1pbnVzIGNvbnN0YW50IGFscGhhJyxcclxuICAnb25lIG1pbnVzIGNvbnN0YW50IGNvbG9yLCBvbmUgbWludXMgY29uc3RhbnQgYWxwaGEnLFxyXG4gICdjb25zdGFudCBhbHBoYSwgY29uc3RhbnQgY29sb3InLFxyXG4gICdjb25zdGFudCBhbHBoYSwgb25lIG1pbnVzIGNvbnN0YW50IGNvbG9yJyxcclxuICAnb25lIG1pbnVzIGNvbnN0YW50IGFscGhhLCBjb25zdGFudCBjb2xvcicsXHJcbiAgJ29uZSBtaW51cyBjb25zdGFudCBhbHBoYSwgb25lIG1pbnVzIGNvbnN0YW50IGNvbG9yJ1xyXG5dO1xyXG5cclxudmFyIGNvbXBhcmVGdW5jcyA9IHtcclxuICAnbmV2ZXInOiA1MTIsXHJcbiAgJ2xlc3MnOiA1MTMsXHJcbiAgJzwnOiA1MTMsXHJcbiAgJ2VxdWFsJzogNTE0LFxyXG4gICc9JzogNTE0LFxyXG4gICc9PSc6IDUxNCxcclxuICAnPT09JzogNTE0LFxyXG4gICdsZXF1YWwnOiA1MTUsXHJcbiAgJzw9JzogNTE1LFxyXG4gICdncmVhdGVyJzogNTE2LFxyXG4gICc+JzogNTE2LFxyXG4gICdub3RlcXVhbCc6IDUxNyxcclxuICAnIT0nOiA1MTcsXHJcbiAgJyE9PSc6IDUxNyxcclxuICAnZ2VxdWFsJzogNTE4LFxyXG4gICc+PSc6IDUxOCxcclxuICAnYWx3YXlzJzogNTE5XHJcbn07XHJcblxyXG52YXIgc3RlbmNpbE9wcyA9IHtcclxuICAnMCc6IDAsXHJcbiAgJ3plcm8nOiAwLFxyXG4gICdrZWVwJzogNzY4MCxcclxuICAncmVwbGFjZSc6IDc2ODEsXHJcbiAgJ2luY3JlbWVudCc6IDc2ODIsXHJcbiAgJ2RlY3JlbWVudCc6IDc2ODMsXHJcbiAgJ2luY3JlbWVudCB3cmFwJzogMzQwNTUsXHJcbiAgJ2RlY3JlbWVudCB3cmFwJzogMzQwNTYsXHJcbiAgJ2ludmVydCc6IDUzODZcclxufTtcclxuXHJcbnZhciBzaGFkZXJUeXBlID0ge1xyXG4gICdmcmFnJzogR0xfRlJBR01FTlRfU0hBREVSJDEsXHJcbiAgJ3ZlcnQnOiBHTF9WRVJURVhfU0hBREVSJDFcclxufTtcclxuXHJcbnZhciBvcmllbnRhdGlvblR5cGUgPSB7XHJcbiAgJ2N3JzogR0xfQ1csXHJcbiAgJ2Njdyc6IEdMX0NDV1xyXG59O1xyXG5cclxuZnVuY3Rpb24gaXNCdWZmZXJBcmdzICh4KSB7XHJcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoeCkgfHxcclxuICAgIGlzVHlwZWRBcnJheSh4KSB8fFxyXG4gICAgaXNOREFycmF5TGlrZSh4KVxyXG59XHJcblxyXG4vLyBNYWtlIHN1cmUgdmlld3BvcnQgaXMgcHJvY2Vzc2VkIGZpcnN0XHJcbmZ1bmN0aW9uIHNvcnRTdGF0ZSAoc3RhdGUpIHtcclxuICByZXR1cm4gc3RhdGUuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgaWYgKGEgPT09IFNfVklFV1BPUlQpIHtcclxuICAgICAgcmV0dXJuIC0xXHJcbiAgICB9IGVsc2UgaWYgKGIgPT09IFNfVklFV1BPUlQpIHtcclxuICAgICAgcmV0dXJuIDFcclxuICAgIH1cclxuICAgIHJldHVybiAoYSA8IGIpID8gLTEgOiAxXHJcbiAgfSlcclxufVxyXG5cclxuZnVuY3Rpb24gRGVjbGFyYXRpb24gKHRoaXNEZXAsIGNvbnRleHREZXAsIHByb3BEZXAsIGFwcGVuZCkge1xyXG4gIHRoaXMudGhpc0RlcCA9IHRoaXNEZXA7XHJcbiAgdGhpcy5jb250ZXh0RGVwID0gY29udGV4dERlcDtcclxuICB0aGlzLnByb3BEZXAgPSBwcm9wRGVwO1xyXG4gIHRoaXMuYXBwZW5kID0gYXBwZW5kO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc1N0YXRpYyAoZGVjbCkge1xyXG4gIHJldHVybiBkZWNsICYmICEoZGVjbC50aGlzRGVwIHx8IGRlY2wuY29udGV4dERlcCB8fCBkZWNsLnByb3BEZXApXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVN0YXRpY0RlY2wgKGFwcGVuZCkge1xyXG4gIHJldHVybiBuZXcgRGVjbGFyYXRpb24oZmFsc2UsIGZhbHNlLCBmYWxzZSwgYXBwZW5kKVxyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVEeW5hbWljRGVjbCAoZHluLCBhcHBlbmQpIHtcclxuICB2YXIgdHlwZSA9IGR5bi50eXBlO1xyXG4gIGlmICh0eXBlID09PSBEWU5fRlVOQyQxKSB7XHJcbiAgICB2YXIgbnVtQXJncyA9IGR5bi5kYXRhLmxlbmd0aDtcclxuICAgIHJldHVybiBuZXcgRGVjbGFyYXRpb24oXHJcbiAgICAgIHRydWUsXHJcbiAgICAgIG51bUFyZ3MgPj0gMSxcclxuICAgICAgbnVtQXJncyA+PSAyLFxyXG4gICAgICBhcHBlbmQpXHJcbiAgfSBlbHNlIGlmICh0eXBlID09PSBEWU5fVEhVTkspIHtcclxuICAgIHZhciBkYXRhID0gZHluLmRhdGE7XHJcbiAgICByZXR1cm4gbmV3IERlY2xhcmF0aW9uKFxyXG4gICAgICBkYXRhLnRoaXNEZXAsXHJcbiAgICAgIGRhdGEuY29udGV4dERlcCxcclxuICAgICAgZGF0YS5wcm9wRGVwLFxyXG4gICAgICBhcHBlbmQpXHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBuZXcgRGVjbGFyYXRpb24oXHJcbiAgICAgIHR5cGUgPT09IERZTl9TVEFURSQxLFxyXG4gICAgICB0eXBlID09PSBEWU5fQ09OVEVYVCQxLFxyXG4gICAgICB0eXBlID09PSBEWU5fUFJPUCQxLFxyXG4gICAgICBhcHBlbmQpXHJcbiAgfVxyXG59XHJcblxyXG52YXIgU0NPUEVfREVDTCA9IG5ldyBEZWNsYXJhdGlvbihmYWxzZSwgZmFsc2UsIGZhbHNlLCBmdW5jdGlvbiAoKSB7fSk7XHJcblxyXG5mdW5jdGlvbiByZWdsQ29yZSAoXHJcbiAgZ2wsXHJcbiAgc3RyaW5nU3RvcmUsXHJcbiAgZXh0ZW5zaW9ucyxcclxuICBsaW1pdHMsXHJcbiAgYnVmZmVyU3RhdGUsXHJcbiAgZWxlbWVudFN0YXRlLFxyXG4gIHRleHR1cmVTdGF0ZSxcclxuICBmcmFtZWJ1ZmZlclN0YXRlLFxyXG4gIHVuaWZvcm1TdGF0ZSxcclxuICBhdHRyaWJ1dGVTdGF0ZSxcclxuICBzaGFkZXJTdGF0ZSxcclxuICBkcmF3U3RhdGUsXHJcbiAgY29udGV4dFN0YXRlLFxyXG4gIHRpbWVyLFxyXG4gIGNvbmZpZykge1xyXG4gIHZhciBBdHRyaWJ1dGVSZWNvcmQgPSBhdHRyaWJ1dGVTdGF0ZS5SZWNvcmQ7XHJcblxyXG4gIHZhciBibGVuZEVxdWF0aW9ucyA9IHtcclxuICAgICdhZGQnOiAzMjc3NCxcclxuICAgICdzdWJ0cmFjdCc6IDMyNzc4LFxyXG4gICAgJ3JldmVyc2Ugc3VidHJhY3QnOiAzMjc3OVxyXG4gIH07XHJcbiAgaWYgKGV4dGVuc2lvbnMuZXh0X2JsZW5kX21pbm1heCkge1xyXG4gICAgYmxlbmRFcXVhdGlvbnMubWluID0gR0xfTUlOX0VYVDtcclxuICAgIGJsZW5kRXF1YXRpb25zLm1heCA9IEdMX01BWF9FWFQ7XHJcbiAgfVxyXG5cclxuICB2YXIgZXh0SW5zdGFuY2luZyA9IGV4dGVuc2lvbnMuYW5nbGVfaW5zdGFuY2VkX2FycmF5cztcclxuICB2YXIgZXh0RHJhd0J1ZmZlcnMgPSBleHRlbnNpb25zLndlYmdsX2RyYXdfYnVmZmVycztcclxuXHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgLy8gV0VCR0wgU1RBVEVcclxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICB2YXIgY3VycmVudFN0YXRlID0ge1xyXG4gICAgZGlydHk6IHRydWUsXHJcbiAgICBwcm9maWxlOiBjb25maWcucHJvZmlsZVxyXG4gIH07XHJcbiAgdmFyIG5leHRTdGF0ZSA9IHt9O1xyXG4gIHZhciBHTF9TVEFURV9OQU1FUyA9IFtdO1xyXG4gIHZhciBHTF9GTEFHUyA9IHt9O1xyXG4gIHZhciBHTF9WQVJJQUJMRVMgPSB7fTtcclxuXHJcbiAgZnVuY3Rpb24gcHJvcE5hbWUgKG5hbWUpIHtcclxuICAgIHJldHVybiBuYW1lLnJlcGxhY2UoJy4nLCAnXycpXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzdGF0ZUZsYWcgKHNuYW1lLCBjYXAsIGluaXQpIHtcclxuICAgIHZhciBuYW1lID0gcHJvcE5hbWUoc25hbWUpO1xyXG4gICAgR0xfU1RBVEVfTkFNRVMucHVzaChzbmFtZSk7XHJcbiAgICBuZXh0U3RhdGVbbmFtZV0gPSBjdXJyZW50U3RhdGVbbmFtZV0gPSAhIWluaXQ7XHJcbiAgICBHTF9GTEFHU1tuYW1lXSA9IGNhcDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHN0YXRlVmFyaWFibGUgKHNuYW1lLCBmdW5jLCBpbml0KSB7XHJcbiAgICB2YXIgbmFtZSA9IHByb3BOYW1lKHNuYW1lKTtcclxuICAgIEdMX1NUQVRFX05BTUVTLnB1c2goc25hbWUpO1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaW5pdCkpIHtcclxuICAgICAgY3VycmVudFN0YXRlW25hbWVdID0gaW5pdC5zbGljZSgpO1xyXG4gICAgICBuZXh0U3RhdGVbbmFtZV0gPSBpbml0LnNsaWNlKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjdXJyZW50U3RhdGVbbmFtZV0gPSBuZXh0U3RhdGVbbmFtZV0gPSBpbml0O1xyXG4gICAgfVxyXG4gICAgR0xfVkFSSUFCTEVTW25hbWVdID0gZnVuYztcclxuICB9XHJcblxyXG4gIC8vIERpdGhlcmluZ1xyXG4gIHN0YXRlRmxhZyhTX0RJVEhFUiwgR0xfRElUSEVSKTtcclxuXHJcbiAgLy8gQmxlbmRpbmdcclxuICBzdGF0ZUZsYWcoU19CTEVORF9FTkFCTEUsIEdMX0JMRU5EKTtcclxuICBzdGF0ZVZhcmlhYmxlKFNfQkxFTkRfQ09MT1IsICdibGVuZENvbG9yJywgWzAsIDAsIDAsIDBdKTtcclxuICBzdGF0ZVZhcmlhYmxlKFNfQkxFTkRfRVFVQVRJT04sICdibGVuZEVxdWF0aW9uU2VwYXJhdGUnLFxyXG4gICAgW0dMX0ZVTkNfQURELCBHTF9GVU5DX0FERF0pO1xyXG4gIHN0YXRlVmFyaWFibGUoU19CTEVORF9GVU5DLCAnYmxlbmRGdW5jU2VwYXJhdGUnLFxyXG4gICAgW0dMX09ORSwgR0xfWkVSTywgR0xfT05FLCBHTF9aRVJPXSk7XHJcblxyXG4gIC8vIERlcHRoXHJcbiAgc3RhdGVGbGFnKFNfREVQVEhfRU5BQkxFLCBHTF9ERVBUSF9URVNULCB0cnVlKTtcclxuICBzdGF0ZVZhcmlhYmxlKFNfREVQVEhfRlVOQywgJ2RlcHRoRnVuYycsIEdMX0xFU1MpO1xyXG4gIHN0YXRlVmFyaWFibGUoU19ERVBUSF9SQU5HRSwgJ2RlcHRoUmFuZ2UnLCBbMCwgMV0pO1xyXG4gIHN0YXRlVmFyaWFibGUoU19ERVBUSF9NQVNLLCAnZGVwdGhNYXNrJywgdHJ1ZSk7XHJcblxyXG4gIC8vIENvbG9yIG1hc2tcclxuICBzdGF0ZVZhcmlhYmxlKFNfQ09MT1JfTUFTSywgU19DT0xPUl9NQVNLLCBbdHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZV0pO1xyXG5cclxuICAvLyBGYWNlIGN1bGxpbmdcclxuICBzdGF0ZUZsYWcoU19DVUxMX0VOQUJMRSwgR0xfQ1VMTF9GQUNFKTtcclxuICBzdGF0ZVZhcmlhYmxlKFNfQ1VMTF9GQUNFLCAnY3VsbEZhY2UnLCBHTF9CQUNLKTtcclxuXHJcbiAgLy8gRnJvbnQgZmFjZSBvcmllbnRhdGlvblxyXG4gIHN0YXRlVmFyaWFibGUoU19GUk9OVF9GQUNFLCBTX0ZST05UX0ZBQ0UsIEdMX0NDVyk7XHJcblxyXG4gIC8vIExpbmUgd2lkdGhcclxuICBzdGF0ZVZhcmlhYmxlKFNfTElORV9XSURUSCwgU19MSU5FX1dJRFRILCAxKTtcclxuXHJcbiAgLy8gUG9seWdvbiBvZmZzZXRcclxuICBzdGF0ZUZsYWcoU19QT0xZR09OX09GRlNFVF9FTkFCTEUsIEdMX1BPTFlHT05fT0ZGU0VUX0ZJTEwpO1xyXG4gIHN0YXRlVmFyaWFibGUoU19QT0xZR09OX09GRlNFVF9PRkZTRVQsICdwb2x5Z29uT2Zmc2V0JywgWzAsIDBdKTtcclxuXHJcbiAgLy8gU2FtcGxlIGNvdmVyYWdlXHJcbiAgc3RhdGVGbGFnKFNfU0FNUExFX0FMUEhBLCBHTF9TQU1QTEVfQUxQSEFfVE9fQ09WRVJBR0UpO1xyXG4gIHN0YXRlRmxhZyhTX1NBTVBMRV9FTkFCTEUsIEdMX1NBTVBMRV9DT1ZFUkFHRSk7XHJcbiAgc3RhdGVWYXJpYWJsZShTX1NBTVBMRV9DT1ZFUkFHRSwgJ3NhbXBsZUNvdmVyYWdlJywgWzEsIGZhbHNlXSk7XHJcblxyXG4gIC8vIFN0ZW5jaWxcclxuICBzdGF0ZUZsYWcoU19TVEVOQ0lMX0VOQUJMRSwgR0xfU1RFTkNJTF9URVNUKTtcclxuICBzdGF0ZVZhcmlhYmxlKFNfU1RFTkNJTF9NQVNLLCAnc3RlbmNpbE1hc2snLCAtMSk7XHJcbiAgc3RhdGVWYXJpYWJsZShTX1NURU5DSUxfRlVOQywgJ3N0ZW5jaWxGdW5jJywgW0dMX0FMV0FZUywgMCwgLTFdKTtcclxuICBzdGF0ZVZhcmlhYmxlKFNfU1RFTkNJTF9PUEZST05ULCAnc3RlbmNpbE9wU2VwYXJhdGUnLFxyXG4gICAgW0dMX0ZST05ULCBHTF9LRUVQLCBHTF9LRUVQLCBHTF9LRUVQXSk7XHJcbiAgc3RhdGVWYXJpYWJsZShTX1NURU5DSUxfT1BCQUNLLCAnc3RlbmNpbE9wU2VwYXJhdGUnLFxyXG4gICAgW0dMX0JBQ0ssIEdMX0tFRVAsIEdMX0tFRVAsIEdMX0tFRVBdKTtcclxuXHJcbiAgLy8gU2Npc3NvclxyXG4gIHN0YXRlRmxhZyhTX1NDSVNTT1JfRU5BQkxFLCBHTF9TQ0lTU09SX1RFU1QpO1xyXG4gIHN0YXRlVmFyaWFibGUoU19TQ0lTU09SX0JPWCwgJ3NjaXNzb3InLFxyXG4gICAgWzAsIDAsIGdsLmRyYXdpbmdCdWZmZXJXaWR0aCwgZ2wuZHJhd2luZ0J1ZmZlckhlaWdodF0pO1xyXG5cclxuICAvLyBWaWV3cG9ydFxyXG4gIHN0YXRlVmFyaWFibGUoU19WSUVXUE9SVCwgU19WSUVXUE9SVCxcclxuICAgIFswLCAwLCBnbC5kcmF3aW5nQnVmZmVyV2lkdGgsIGdsLmRyYXdpbmdCdWZmZXJIZWlnaHRdKTtcclxuXHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgLy8gRU5WSVJPTk1FTlRcclxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICB2YXIgc2hhcmVkU3RhdGUgPSB7XHJcbiAgICBnbDogZ2wsXHJcbiAgICBjb250ZXh0OiBjb250ZXh0U3RhdGUsXHJcbiAgICBzdHJpbmdzOiBzdHJpbmdTdG9yZSxcclxuICAgIG5leHQ6IG5leHRTdGF0ZSxcclxuICAgIGN1cnJlbnQ6IGN1cnJlbnRTdGF0ZSxcclxuICAgIGRyYXc6IGRyYXdTdGF0ZSxcclxuICAgIGVsZW1lbnRzOiBlbGVtZW50U3RhdGUsXHJcbiAgICBidWZmZXI6IGJ1ZmZlclN0YXRlLFxyXG4gICAgc2hhZGVyOiBzaGFkZXJTdGF0ZSxcclxuICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZVN0YXRlLnN0YXRlLFxyXG4gICAgdW5pZm9ybXM6IHVuaWZvcm1TdGF0ZSxcclxuICAgIGZyYW1lYnVmZmVyOiBmcmFtZWJ1ZmZlclN0YXRlLFxyXG4gICAgZXh0ZW5zaW9uczogZXh0ZW5zaW9ucyxcclxuXHJcbiAgICB0aW1lcjogdGltZXIsXHJcbiAgICBpc0J1ZmZlckFyZ3M6IGlzQnVmZmVyQXJnc1xyXG4gIH07XHJcblxyXG4gIHZhciBzaGFyZWRDb25zdGFudHMgPSB7XHJcbiAgICBwcmltVHlwZXM6IHByaW1UeXBlcyxcclxuICAgIGNvbXBhcmVGdW5jczogY29tcGFyZUZ1bmNzLFxyXG4gICAgYmxlbmRGdW5jczogYmxlbmRGdW5jcyxcclxuICAgIGJsZW5kRXF1YXRpb25zOiBibGVuZEVxdWF0aW9ucyxcclxuICAgIHN0ZW5jaWxPcHM6IHN0ZW5jaWxPcHMsXHJcbiAgICBnbFR5cGVzOiBnbFR5cGVzLFxyXG4gICAgb3JpZW50YXRpb25UeXBlOiBvcmllbnRhdGlvblR5cGVcclxuICB9O1xyXG5cclxuICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcclxuICAgIHNoYXJlZFN0YXRlLmlzQXJyYXlMaWtlID0gaXNBcnJheUxpa2U7XHJcbiAgfSk7XHJcblxyXG4gIGlmIChleHREcmF3QnVmZmVycykge1xyXG4gICAgc2hhcmVkQ29uc3RhbnRzLmJhY2tCdWZmZXIgPSBbR0xfQkFDS107XHJcbiAgICBzaGFyZWRDb25zdGFudHMuZHJhd0J1ZmZlciA9IGxvb3AobGltaXRzLm1heERyYXdidWZmZXJzLCBmdW5jdGlvbiAoaSkge1xyXG4gICAgICBpZiAoaSA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBbMF1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbG9vcChpLCBmdW5jdGlvbiAoaikge1xyXG4gICAgICAgIHJldHVybiBHTF9DT0xPUl9BVFRBQ0hNRU5UMCQyICsgalxyXG4gICAgICB9KVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICB2YXIgZHJhd0NhbGxDb3VudGVyID0gMDtcclxuICBmdW5jdGlvbiBjcmVhdGVSRUdMRW52aXJvbm1lbnQgKCkge1xyXG4gICAgdmFyIGVudiA9IGNyZWF0ZUVudmlyb25tZW50KCk7XHJcbiAgICB2YXIgbGluayA9IGVudi5saW5rO1xyXG4gICAgdmFyIGdsb2JhbCA9IGVudi5nbG9iYWw7XHJcbiAgICBlbnYuaWQgPSBkcmF3Q2FsbENvdW50ZXIrKztcclxuXHJcbiAgICBlbnYuYmF0Y2hJZCA9ICcwJztcclxuXHJcbiAgICAvLyBsaW5rIHNoYXJlZCBzdGF0ZVxyXG4gICAgdmFyIFNIQVJFRCA9IGxpbmsoc2hhcmVkU3RhdGUpO1xyXG4gICAgdmFyIHNoYXJlZCA9IGVudi5zaGFyZWQgPSB7XHJcbiAgICAgIHByb3BzOiAnYTAnXHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmtleXMoc2hhcmVkU3RhdGUpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcclxuICAgICAgc2hhcmVkW3Byb3BdID0gZ2xvYmFsLmRlZihTSEFSRUQsICcuJywgcHJvcCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBJbmplY3QgcnVudGltZSBhc3NlcnRpb24gc3R1ZmYgZm9yIGRlYnVnIGJ1aWxkc1xyXG4gICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGVudi5DSEVDSyA9IGxpbmsoY2hlY2skMSk7XHJcbiAgICAgIGVudi5jb21tYW5kU3RyID0gY2hlY2skMS5ndWVzc0NvbW1hbmQoKTtcclxuICAgICAgZW52LmNvbW1hbmQgPSBsaW5rKGVudi5jb21tYW5kU3RyKTtcclxuICAgICAgZW52LmFzc2VydCA9IGZ1bmN0aW9uIChibG9jaywgcHJlZCwgbWVzc2FnZSkge1xyXG4gICAgICAgIGJsb2NrKFxyXG4gICAgICAgICAgJ2lmKCEoJywgcHJlZCwgJykpJyxcclxuICAgICAgICAgIHRoaXMuQ0hFQ0ssICcuY29tbWFuZFJhaXNlKCcsIGxpbmsobWVzc2FnZSksICcsJywgdGhpcy5jb21tYW5kLCAnKTsnKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHNoYXJlZENvbnN0YW50cy5pbnZhbGlkQmxlbmRDb21iaW5hdGlvbnMgPSBpbnZhbGlkQmxlbmRDb21iaW5hdGlvbnM7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBDb3B5IEdMIHN0YXRlIHZhcmlhYmxlcyBvdmVyXHJcbiAgICB2YXIgbmV4dFZhcnMgPSBlbnYubmV4dCA9IHt9O1xyXG4gICAgdmFyIGN1cnJlbnRWYXJzID0gZW52LmN1cnJlbnQgPSB7fTtcclxuICAgIE9iamVjdC5rZXlzKEdMX1ZBUklBQkxFUykuZm9yRWFjaChmdW5jdGlvbiAodmFyaWFibGUpIHtcclxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudFN0YXRlW3ZhcmlhYmxlXSkpIHtcclxuICAgICAgICBuZXh0VmFyc1t2YXJpYWJsZV0gPSBnbG9iYWwuZGVmKHNoYXJlZC5uZXh0LCAnLicsIHZhcmlhYmxlKTtcclxuICAgICAgICBjdXJyZW50VmFyc1t2YXJpYWJsZV0gPSBnbG9iYWwuZGVmKHNoYXJlZC5jdXJyZW50LCAnLicsIHZhcmlhYmxlKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZSBzaGFyZWQgY29uc3RhbnRzXHJcbiAgICB2YXIgY29uc3RhbnRzID0gZW52LmNvbnN0YW50cyA9IHt9O1xyXG4gICAgT2JqZWN0LmtleXMoc2hhcmVkQ29uc3RhbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgIGNvbnN0YW50c1tuYW1lXSA9IGdsb2JhbC5kZWYoSlNPTi5zdHJpbmdpZnkoc2hhcmVkQ29uc3RhbnRzW25hbWVdKSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBIZWxwZXIgZnVuY3Rpb24gZm9yIGNhbGxpbmcgYSBibG9ja1xyXG4gICAgZW52Lmludm9rZSA9IGZ1bmN0aW9uIChibG9jaywgeCkge1xyXG4gICAgICBzd2l0Y2ggKHgudHlwZSkge1xyXG4gICAgICAgIGNhc2UgRFlOX0ZVTkMkMTpcclxuICAgICAgICAgIHZhciBhcmdMaXN0ID0gW1xyXG4gICAgICAgICAgICAndGhpcycsXHJcbiAgICAgICAgICAgIHNoYXJlZC5jb250ZXh0LFxyXG4gICAgICAgICAgICBzaGFyZWQucHJvcHMsXHJcbiAgICAgICAgICAgIGVudi5iYXRjaElkXHJcbiAgICAgICAgICBdO1xyXG4gICAgICAgICAgcmV0dXJuIGJsb2NrLmRlZihcclxuICAgICAgICAgICAgbGluayh4LmRhdGEpLCAnLmNhbGwoJyxcclxuICAgICAgICAgICAgICBhcmdMaXN0LnNsaWNlKDAsIE1hdGgubWF4KHguZGF0YS5sZW5ndGggKyAxLCA0KSksXHJcbiAgICAgICAgICAgICAnKScpXHJcbiAgICAgICAgY2FzZSBEWU5fUFJPUCQxOlxyXG4gICAgICAgICAgcmV0dXJuIGJsb2NrLmRlZihzaGFyZWQucHJvcHMsIHguZGF0YSlcclxuICAgICAgICBjYXNlIERZTl9DT05URVhUJDE6XHJcbiAgICAgICAgICByZXR1cm4gYmxvY2suZGVmKHNoYXJlZC5jb250ZXh0LCB4LmRhdGEpXHJcbiAgICAgICAgY2FzZSBEWU5fU1RBVEUkMTpcclxuICAgICAgICAgIHJldHVybiBibG9jay5kZWYoJ3RoaXMnLCB4LmRhdGEpXHJcbiAgICAgICAgY2FzZSBEWU5fVEhVTks6XHJcbiAgICAgICAgICB4LmRhdGEuYXBwZW5kKGVudiwgYmxvY2spO1xyXG4gICAgICAgICAgcmV0dXJuIHguZGF0YS5yZWZcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBlbnYuYXR0cmliQ2FjaGUgPSB7fTtcclxuXHJcbiAgICB2YXIgc2NvcGVBdHRyaWJzID0ge307XHJcbiAgICBlbnYuc2NvcGVBdHRyaWIgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICB2YXIgaWQgPSBzdHJpbmdTdG9yZS5pZChuYW1lKTtcclxuICAgICAgaWYgKGlkIGluIHNjb3BlQXR0cmlicykge1xyXG4gICAgICAgIHJldHVybiBzY29wZUF0dHJpYnNbaWRdXHJcbiAgICAgIH1cclxuICAgICAgdmFyIGJpbmRpbmcgPSBhdHRyaWJ1dGVTdGF0ZS5zY29wZVtpZF07XHJcbiAgICAgIGlmICghYmluZGluZykge1xyXG4gICAgICAgIGJpbmRpbmcgPSBhdHRyaWJ1dGVTdGF0ZS5zY29wZVtpZF0gPSBuZXcgQXR0cmlidXRlUmVjb3JkKCk7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHJlc3VsdCA9IHNjb3BlQXR0cmlic1tpZF0gPSBsaW5rKGJpbmRpbmcpO1xyXG4gICAgICByZXR1cm4gcmVzdWx0XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBlbnZcclxuICB9XHJcblxyXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gIC8vIFBBUlNJTkdcclxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICBmdW5jdGlvbiBwYXJzZVByb2ZpbGUgKG9wdGlvbnMpIHtcclxuICAgIHZhciBzdGF0aWNPcHRpb25zID0gb3B0aW9ucy5zdGF0aWM7XHJcbiAgICB2YXIgZHluYW1pY09wdGlvbnMgPSBvcHRpb25zLmR5bmFtaWM7XHJcblxyXG4gICAgdmFyIHByb2ZpbGVFbmFibGU7XHJcbiAgICBpZiAoU19QUk9GSUxFIGluIHN0YXRpY09wdGlvbnMpIHtcclxuICAgICAgdmFyIHZhbHVlID0gISFzdGF0aWNPcHRpb25zW1NfUFJPRklMRV07XHJcbiAgICAgIHByb2ZpbGVFbmFibGUgPSBjcmVhdGVTdGF0aWNEZWNsKGZ1bmN0aW9uIChlbnYsIHNjb3BlKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlXHJcbiAgICAgIH0pO1xyXG4gICAgICBwcm9maWxlRW5hYmxlLmVuYWJsZSA9IHZhbHVlO1xyXG4gICAgfSBlbHNlIGlmIChTX1BST0ZJTEUgaW4gZHluYW1pY09wdGlvbnMpIHtcclxuICAgICAgdmFyIGR5biA9IGR5bmFtaWNPcHRpb25zW1NfUFJPRklMRV07XHJcbiAgICAgIHByb2ZpbGVFbmFibGUgPSBjcmVhdGVEeW5hbWljRGVjbChkeW4sIGZ1bmN0aW9uIChlbnYsIHNjb3BlKSB7XHJcbiAgICAgICAgcmV0dXJuIGVudi5pbnZva2Uoc2NvcGUsIGR5bilcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHByb2ZpbGVFbmFibGVcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHBhcnNlRnJhbWVidWZmZXIgKG9wdGlvbnMsIGVudikge1xyXG4gICAgdmFyIHN0YXRpY09wdGlvbnMgPSBvcHRpb25zLnN0YXRpYztcclxuICAgIHZhciBkeW5hbWljT3B0aW9ucyA9IG9wdGlvbnMuZHluYW1pYztcclxuXHJcbiAgICBpZiAoU19GUkFNRUJVRkZFUiBpbiBzdGF0aWNPcHRpb25zKSB7XHJcbiAgICAgIHZhciBmcmFtZWJ1ZmZlciA9IHN0YXRpY09wdGlvbnNbU19GUkFNRUJVRkZFUl07XHJcbiAgICAgIGlmIChmcmFtZWJ1ZmZlcikge1xyXG4gICAgICAgIGZyYW1lYnVmZmVyID0gZnJhbWVidWZmZXJTdGF0ZS5nZXRGcmFtZWJ1ZmZlcihmcmFtZWJ1ZmZlcik7XHJcbiAgICAgICAgY2hlY2skMS5jb21tYW5kKGZyYW1lYnVmZmVyLCAnaW52YWxpZCBmcmFtZWJ1ZmZlciBvYmplY3QnKTtcclxuICAgICAgICByZXR1cm4gY3JlYXRlU3RhdGljRGVjbChmdW5jdGlvbiAoZW52LCBibG9jaykge1xyXG4gICAgICAgICAgdmFyIEZSQU1FQlVGRkVSID0gZW52LmxpbmsoZnJhbWVidWZmZXIpO1xyXG4gICAgICAgICAgdmFyIHNoYXJlZCA9IGVudi5zaGFyZWQ7XHJcbiAgICAgICAgICBibG9jay5zZXQoXHJcbiAgICAgICAgICAgIHNoYXJlZC5mcmFtZWJ1ZmZlcixcclxuICAgICAgICAgICAgJy5uZXh0JyxcclxuICAgICAgICAgICAgRlJBTUVCVUZGRVIpO1xyXG4gICAgICAgICAgdmFyIENPTlRFWFQgPSBzaGFyZWQuY29udGV4dDtcclxuICAgICAgICAgIGJsb2NrLnNldChcclxuICAgICAgICAgICAgQ09OVEVYVCxcclxuICAgICAgICAgICAgJy4nICsgU19GUkFNRUJVRkZFUl9XSURUSCxcclxuICAgICAgICAgICAgRlJBTUVCVUZGRVIgKyAnLndpZHRoJyk7XHJcbiAgICAgICAgICBibG9jay5zZXQoXHJcbiAgICAgICAgICAgIENPTlRFWFQsXHJcbiAgICAgICAgICAgICcuJyArIFNfRlJBTUVCVUZGRVJfSEVJR0hULFxyXG4gICAgICAgICAgICBGUkFNRUJVRkZFUiArICcuaGVpZ2h0Jyk7XHJcbiAgICAgICAgICByZXR1cm4gRlJBTUVCVUZGRVJcclxuICAgICAgICB9KVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVTdGF0aWNEZWNsKGZ1bmN0aW9uIChlbnYsIHNjb3BlKSB7XHJcbiAgICAgICAgICB2YXIgc2hhcmVkID0gZW52LnNoYXJlZDtcclxuICAgICAgICAgIHNjb3BlLnNldChcclxuICAgICAgICAgICAgc2hhcmVkLmZyYW1lYnVmZmVyLFxyXG4gICAgICAgICAgICAnLm5leHQnLFxyXG4gICAgICAgICAgICAnbnVsbCcpO1xyXG4gICAgICAgICAgdmFyIENPTlRFWFQgPSBzaGFyZWQuY29udGV4dDtcclxuICAgICAgICAgIHNjb3BlLnNldChcclxuICAgICAgICAgICAgQ09OVEVYVCxcclxuICAgICAgICAgICAgJy4nICsgU19GUkFNRUJVRkZFUl9XSURUSCxcclxuICAgICAgICAgICAgQ09OVEVYVCArICcuJyArIFNfRFJBV0lOR0JVRkZFUl9XSURUSCk7XHJcbiAgICAgICAgICBzY29wZS5zZXQoXHJcbiAgICAgICAgICAgIENPTlRFWFQsXHJcbiAgICAgICAgICAgICcuJyArIFNfRlJBTUVCVUZGRVJfSEVJR0hULFxyXG4gICAgICAgICAgICBDT05URVhUICsgJy4nICsgU19EUkFXSU5HQlVGRkVSX0hFSUdIVCk7XHJcbiAgICAgICAgICByZXR1cm4gJ251bGwnXHJcbiAgICAgICAgfSlcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChTX0ZSQU1FQlVGRkVSIGluIGR5bmFtaWNPcHRpb25zKSB7XHJcbiAgICAgIHZhciBkeW4gPSBkeW5hbWljT3B0aW9uc1tTX0ZSQU1FQlVGRkVSXTtcclxuICAgICAgcmV0dXJuIGNyZWF0ZUR5bmFtaWNEZWNsKGR5biwgZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcclxuICAgICAgICB2YXIgRlJBTUVCVUZGRVJfRlVOQyA9IGVudi5pbnZva2Uoc2NvcGUsIGR5bik7XHJcbiAgICAgICAgdmFyIHNoYXJlZCA9IGVudi5zaGFyZWQ7XHJcbiAgICAgICAgdmFyIEZSQU1FQlVGRkVSX1NUQVRFID0gc2hhcmVkLmZyYW1lYnVmZmVyO1xyXG4gICAgICAgIHZhciBGUkFNRUJVRkZFUiA9IHNjb3BlLmRlZihcclxuICAgICAgICAgIEZSQU1FQlVGRkVSX1NUQVRFLCAnLmdldEZyYW1lYnVmZmVyKCcsIEZSQU1FQlVGRkVSX0ZVTkMsICcpJyk7XHJcblxyXG4gICAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgZW52LmFzc2VydChzY29wZSxcclxuICAgICAgICAgICAgJyEnICsgRlJBTUVCVUZGRVJfRlVOQyArICd8fCcgKyBGUkFNRUJVRkZFUixcclxuICAgICAgICAgICAgJ2ludmFsaWQgZnJhbWVidWZmZXIgb2JqZWN0Jyk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHNjb3BlLnNldChcclxuICAgICAgICAgIEZSQU1FQlVGRkVSX1NUQVRFLFxyXG4gICAgICAgICAgJy5uZXh0JyxcclxuICAgICAgICAgIEZSQU1FQlVGRkVSKTtcclxuICAgICAgICB2YXIgQ09OVEVYVCA9IHNoYXJlZC5jb250ZXh0O1xyXG4gICAgICAgIHNjb3BlLnNldChcclxuICAgICAgICAgIENPTlRFWFQsXHJcbiAgICAgICAgICAnLicgKyBTX0ZSQU1FQlVGRkVSX1dJRFRILFxyXG4gICAgICAgICAgRlJBTUVCVUZGRVIgKyAnPycgKyBGUkFNRUJVRkZFUiArICcud2lkdGg6JyArXHJcbiAgICAgICAgICBDT05URVhUICsgJy4nICsgU19EUkFXSU5HQlVGRkVSX1dJRFRIKTtcclxuICAgICAgICBzY29wZS5zZXQoXHJcbiAgICAgICAgICBDT05URVhULFxyXG4gICAgICAgICAgJy4nICsgU19GUkFNRUJVRkZFUl9IRUlHSFQsXHJcbiAgICAgICAgICBGUkFNRUJVRkZFUiArXHJcbiAgICAgICAgICAnPycgKyBGUkFNRUJVRkZFUiArICcuaGVpZ2h0OicgK1xyXG4gICAgICAgICAgQ09OVEVYVCArICcuJyArIFNfRFJBV0lOR0JVRkZFUl9IRUlHSFQpO1xyXG4gICAgICAgIHJldHVybiBGUkFNRUJVRkZFUlxyXG4gICAgICB9KVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIG51bGxcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHBhcnNlVmlld3BvcnRTY2lzc29yIChvcHRpb25zLCBmcmFtZWJ1ZmZlciwgZW52KSB7XHJcbiAgICB2YXIgc3RhdGljT3B0aW9ucyA9IG9wdGlvbnMuc3RhdGljO1xyXG4gICAgdmFyIGR5bmFtaWNPcHRpb25zID0gb3B0aW9ucy5keW5hbWljO1xyXG5cclxuICAgIGZ1bmN0aW9uIHBhcnNlQm94IChwYXJhbSkge1xyXG4gICAgICBpZiAocGFyYW0gaW4gc3RhdGljT3B0aW9ucykge1xyXG4gICAgICAgIHZhciBib3ggPSBzdGF0aWNPcHRpb25zW3BhcmFtXTtcclxuICAgICAgICBjaGVjayQxLmNvbW1hbmRUeXBlKGJveCwgJ29iamVjdCcsICdpbnZhbGlkICcgKyBwYXJhbSwgZW52LmNvbW1hbmRTdHIpO1xyXG5cclxuICAgICAgICB2YXIgaXNTdGF0aWMgPSB0cnVlO1xyXG4gICAgICAgIHZhciB4ID0gYm94LnggfCAwO1xyXG4gICAgICAgIHZhciB5ID0gYm94LnkgfCAwO1xyXG4gICAgICAgIHZhciB3LCBoO1xyXG4gICAgICAgIGlmICgnd2lkdGgnIGluIGJveCkge1xyXG4gICAgICAgICAgdyA9IGJveC53aWR0aCB8IDA7XHJcbiAgICAgICAgICBjaGVjayQxLmNvbW1hbmQodyA+PSAwLCAnaW52YWxpZCAnICsgcGFyYW0sIGVudi5jb21tYW5kU3RyKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaXNTdGF0aWMgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCdoZWlnaHQnIGluIGJveCkge1xyXG4gICAgICAgICAgaCA9IGJveC5oZWlnaHQgfCAwO1xyXG4gICAgICAgICAgY2hlY2skMS5jb21tYW5kKGggPj0gMCwgJ2ludmFsaWQgJyArIHBhcmFtLCBlbnYuY29tbWFuZFN0cik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGlzU3RhdGljID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbmV3IERlY2xhcmF0aW9uKFxyXG4gICAgICAgICAgIWlzU3RhdGljICYmIGZyYW1lYnVmZmVyICYmIGZyYW1lYnVmZmVyLnRoaXNEZXAsXHJcbiAgICAgICAgICAhaXNTdGF0aWMgJiYgZnJhbWVidWZmZXIgJiYgZnJhbWVidWZmZXIuY29udGV4dERlcCxcclxuICAgICAgICAgICFpc1N0YXRpYyAmJiBmcmFtZWJ1ZmZlciAmJiBmcmFtZWJ1ZmZlci5wcm9wRGVwLFxyXG4gICAgICAgICAgZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcclxuICAgICAgICAgICAgdmFyIENPTlRFWFQgPSBlbnYuc2hhcmVkLmNvbnRleHQ7XHJcbiAgICAgICAgICAgIHZhciBCT1hfVyA9IHc7XHJcbiAgICAgICAgICAgIGlmICghKCd3aWR0aCcgaW4gYm94KSkge1xyXG4gICAgICAgICAgICAgIEJPWF9XID0gc2NvcGUuZGVmKENPTlRFWFQsICcuJywgU19GUkFNRUJVRkZFUl9XSURUSCwgJy0nLCB4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgQk9YX0ggPSBoO1xyXG4gICAgICAgICAgICBpZiAoISgnaGVpZ2h0JyBpbiBib3gpKSB7XHJcbiAgICAgICAgICAgICAgQk9YX0ggPSBzY29wZS5kZWYoQ09OVEVYVCwgJy4nLCBTX0ZSQU1FQlVGRkVSX0hFSUdIVCwgJy0nLCB5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gW3gsIHksIEJPWF9XLCBCT1hfSF1cclxuICAgICAgICAgIH0pXHJcbiAgICAgIH0gZWxzZSBpZiAocGFyYW0gaW4gZHluYW1pY09wdGlvbnMpIHtcclxuICAgICAgICB2YXIgZHluQm94ID0gZHluYW1pY09wdGlvbnNbcGFyYW1dO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVEeW5hbWljRGVjbChkeW5Cb3gsIGZ1bmN0aW9uIChlbnYsIHNjb3BlKSB7XHJcbiAgICAgICAgICB2YXIgQk9YID0gZW52Lmludm9rZShzY29wZSwgZHluQm94KTtcclxuXHJcbiAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZW52LmFzc2VydChzY29wZSxcclxuICAgICAgICAgICAgICBCT1ggKyAnJiZ0eXBlb2YgJyArIEJPWCArICc9PT1cIm9iamVjdFwiJyxcclxuICAgICAgICAgICAgICAnaW52YWxpZCAnICsgcGFyYW0pO1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgdmFyIENPTlRFWFQgPSBlbnYuc2hhcmVkLmNvbnRleHQ7XHJcbiAgICAgICAgICB2YXIgQk9YX1ggPSBzY29wZS5kZWYoQk9YLCAnLnh8MCcpO1xyXG4gICAgICAgICAgdmFyIEJPWF9ZID0gc2NvcGUuZGVmKEJPWCwgJy55fDAnKTtcclxuICAgICAgICAgIHZhciBCT1hfVyA9IHNjb3BlLmRlZihcclxuICAgICAgICAgICAgJ1wid2lkdGhcIiBpbiAnLCBCT1gsICc/JywgQk9YLCAnLndpZHRofDA6JyxcclxuICAgICAgICAgICAgJygnLCBDT05URVhULCAnLicsIFNfRlJBTUVCVUZGRVJfV0lEVEgsICctJywgQk9YX1gsICcpJyk7XHJcbiAgICAgICAgICB2YXIgQk9YX0ggPSBzY29wZS5kZWYoXHJcbiAgICAgICAgICAgICdcImhlaWdodFwiIGluICcsIEJPWCwgJz8nLCBCT1gsICcuaGVpZ2h0fDA6JyxcclxuICAgICAgICAgICAgJygnLCBDT05URVhULCAnLicsIFNfRlJBTUVCVUZGRVJfSEVJR0hULCAnLScsIEJPWF9ZLCAnKScpO1xyXG5cclxuICAgICAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLFxyXG4gICAgICAgICAgICAgIEJPWF9XICsgJz49MCYmJyArXHJcbiAgICAgICAgICAgICAgQk9YX0ggKyAnPj0wJyxcclxuICAgICAgICAgICAgICAnaW52YWxpZCAnICsgcGFyYW0pO1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIFtCT1hfWCwgQk9YX1ksIEJPWF9XLCBCT1hfSF1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoZnJhbWVidWZmZXIpIHtcclxuICAgICAgICAgIHJlc3VsdC50aGlzRGVwID0gcmVzdWx0LnRoaXNEZXAgfHwgZnJhbWVidWZmZXIudGhpc0RlcDtcclxuICAgICAgICAgIHJlc3VsdC5jb250ZXh0RGVwID0gcmVzdWx0LmNvbnRleHREZXAgfHwgZnJhbWVidWZmZXIuY29udGV4dERlcDtcclxuICAgICAgICAgIHJlc3VsdC5wcm9wRGVwID0gcmVzdWx0LnByb3BEZXAgfHwgZnJhbWVidWZmZXIucHJvcERlcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxyXG4gICAgICB9IGVsc2UgaWYgKGZyYW1lYnVmZmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNsYXJhdGlvbihcclxuICAgICAgICAgIGZyYW1lYnVmZmVyLnRoaXNEZXAsXHJcbiAgICAgICAgICBmcmFtZWJ1ZmZlci5jb250ZXh0RGVwLFxyXG4gICAgICAgICAgZnJhbWVidWZmZXIucHJvcERlcCxcclxuICAgICAgICAgIGZ1bmN0aW9uIChlbnYsIHNjb3BlKSB7XHJcbiAgICAgICAgICAgIHZhciBDT05URVhUID0gZW52LnNoYXJlZC5jb250ZXh0O1xyXG4gICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgIDAsIDAsXHJcbiAgICAgICAgICAgICAgc2NvcGUuZGVmKENPTlRFWFQsICcuJywgU19GUkFNRUJVRkZFUl9XSURUSCksXHJcbiAgICAgICAgICAgICAgc2NvcGUuZGVmKENPTlRFWFQsICcuJywgU19GUkFNRUJVRkZFUl9IRUlHSFQpXVxyXG4gICAgICAgICAgfSlcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbnVsbFxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHZpZXdwb3J0ID0gcGFyc2VCb3goU19WSUVXUE9SVCk7XHJcblxyXG4gICAgaWYgKHZpZXdwb3J0KSB7XHJcbiAgICAgIHZhciBwcmV2Vmlld3BvcnQgPSB2aWV3cG9ydDtcclxuICAgICAgdmlld3BvcnQgPSBuZXcgRGVjbGFyYXRpb24oXHJcbiAgICAgICAgdmlld3BvcnQudGhpc0RlcCxcclxuICAgICAgICB2aWV3cG9ydC5jb250ZXh0RGVwLFxyXG4gICAgICAgIHZpZXdwb3J0LnByb3BEZXAsXHJcbiAgICAgICAgZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcclxuICAgICAgICAgIHZhciBWSUVXUE9SVCA9IHByZXZWaWV3cG9ydC5hcHBlbmQoZW52LCBzY29wZSk7XHJcbiAgICAgICAgICB2YXIgQ09OVEVYVCA9IGVudi5zaGFyZWQuY29udGV4dDtcclxuICAgICAgICAgIHNjb3BlLnNldChcclxuICAgICAgICAgICAgQ09OVEVYVCxcclxuICAgICAgICAgICAgJy4nICsgU19WSUVXUE9SVF9XSURUSCxcclxuICAgICAgICAgICAgVklFV1BPUlRbMl0pO1xyXG4gICAgICAgICAgc2NvcGUuc2V0KFxyXG4gICAgICAgICAgICBDT05URVhULFxyXG4gICAgICAgICAgICAnLicgKyBTX1ZJRVdQT1JUX0hFSUdIVCxcclxuICAgICAgICAgICAgVklFV1BPUlRbM10pO1xyXG4gICAgICAgICAgcmV0dXJuIFZJRVdQT1JUXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdmlld3BvcnQ6IHZpZXdwb3J0LFxyXG4gICAgICBzY2lzc29yX2JveDogcGFyc2VCb3goU19TQ0lTU09SX0JPWClcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHBhcnNlUHJvZ3JhbSAob3B0aW9ucykge1xyXG4gICAgdmFyIHN0YXRpY09wdGlvbnMgPSBvcHRpb25zLnN0YXRpYztcclxuICAgIHZhciBkeW5hbWljT3B0aW9ucyA9IG9wdGlvbnMuZHluYW1pYztcclxuXHJcbiAgICBmdW5jdGlvbiBwYXJzZVNoYWRlciAobmFtZSkge1xyXG4gICAgICBpZiAobmFtZSBpbiBzdGF0aWNPcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIGlkID0gc3RyaW5nU3RvcmUuaWQoc3RhdGljT3B0aW9uc1tuYW1lXSk7XHJcbiAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICBzaGFkZXJTdGF0ZS5zaGFkZXIoc2hhZGVyVHlwZVtuYW1lXSwgaWQsIGNoZWNrJDEuZ3Vlc3NDb21tYW5kKCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVTdGF0aWNEZWNsKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHJldHVybiBpZFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJlc3VsdC5pZCA9IGlkO1xyXG4gICAgICAgIHJldHVybiByZXN1bHRcclxuICAgICAgfSBlbHNlIGlmIChuYW1lIGluIGR5bmFtaWNPcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIGR5biA9IGR5bmFtaWNPcHRpb25zW25hbWVdO1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVEeW5hbWljRGVjbChkeW4sIGZ1bmN0aW9uIChlbnYsIHNjb3BlKSB7XHJcbiAgICAgICAgICB2YXIgc3RyID0gZW52Lmludm9rZShzY29wZSwgZHluKTtcclxuICAgICAgICAgIHZhciBpZCA9IHNjb3BlLmRlZihlbnYuc2hhcmVkLnN0cmluZ3MsICcuaWQoJywgc3RyLCAnKScpO1xyXG4gICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHNjb3BlKFxyXG4gICAgICAgICAgICAgIGVudi5zaGFyZWQuc2hhZGVyLCAnLnNoYWRlcignLFxyXG4gICAgICAgICAgICAgIHNoYWRlclR5cGVbbmFtZV0sICcsJyxcclxuICAgICAgICAgICAgICBpZCwgJywnLFxyXG4gICAgICAgICAgICAgIGVudi5jb21tYW5kLCAnKTsnKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgcmV0dXJuIGlkXHJcbiAgICAgICAgfSlcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbnVsbFxyXG4gICAgfVxyXG5cclxuICAgIHZhciBmcmFnID0gcGFyc2VTaGFkZXIoU19GUkFHKTtcclxuICAgIHZhciB2ZXJ0ID0gcGFyc2VTaGFkZXIoU19WRVJUKTtcclxuXHJcbiAgICB2YXIgcHJvZ3JhbSA9IG51bGw7XHJcbiAgICB2YXIgcHJvZ1ZhcjtcclxuICAgIGlmIChpc1N0YXRpYyhmcmFnKSAmJiBpc1N0YXRpYyh2ZXJ0KSkge1xyXG4gICAgICBwcm9ncmFtID0gc2hhZGVyU3RhdGUucHJvZ3JhbSh2ZXJ0LmlkLCBmcmFnLmlkKTtcclxuICAgICAgcHJvZ1ZhciA9IGNyZWF0ZVN0YXRpY0RlY2woZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcclxuICAgICAgICByZXR1cm4gZW52LmxpbmsocHJvZ3JhbSlcclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBwcm9nVmFyID0gbmV3IERlY2xhcmF0aW9uKFxyXG4gICAgICAgIChmcmFnICYmIGZyYWcudGhpc0RlcCkgfHwgKHZlcnQgJiYgdmVydC50aGlzRGVwKSxcclxuICAgICAgICAoZnJhZyAmJiBmcmFnLmNvbnRleHREZXApIHx8ICh2ZXJ0ICYmIHZlcnQuY29udGV4dERlcCksXHJcbiAgICAgICAgKGZyYWcgJiYgZnJhZy5wcm9wRGVwKSB8fCAodmVydCAmJiB2ZXJ0LnByb3BEZXApLFxyXG4gICAgICAgIGZ1bmN0aW9uIChlbnYsIHNjb3BlKSB7XHJcbiAgICAgICAgICB2YXIgU0hBREVSX1NUQVRFID0gZW52LnNoYXJlZC5zaGFkZXI7XHJcbiAgICAgICAgICB2YXIgZnJhZ0lkO1xyXG4gICAgICAgICAgaWYgKGZyYWcpIHtcclxuICAgICAgICAgICAgZnJhZ0lkID0gZnJhZy5hcHBlbmQoZW52LCBzY29wZSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmcmFnSWQgPSBzY29wZS5kZWYoU0hBREVSX1NUQVRFLCAnLicsIFNfRlJBRyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB2YXIgdmVydElkO1xyXG4gICAgICAgICAgaWYgKHZlcnQpIHtcclxuICAgICAgICAgICAgdmVydElkID0gdmVydC5hcHBlbmQoZW52LCBzY29wZSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2ZXJ0SWQgPSBzY29wZS5kZWYoU0hBREVSX1NUQVRFLCAnLicsIFNfVkVSVCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB2YXIgcHJvZ0RlZiA9IFNIQURFUl9TVEFURSArICcucHJvZ3JhbSgnICsgdmVydElkICsgJywnICsgZnJhZ0lkO1xyXG4gICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHByb2dEZWYgKz0gJywnICsgZW52LmNvbW1hbmQ7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIHJldHVybiBzY29wZS5kZWYocHJvZ0RlZiArICcpJylcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBmcmFnOiBmcmFnLFxyXG4gICAgICB2ZXJ0OiB2ZXJ0LFxyXG4gICAgICBwcm9nVmFyOiBwcm9nVmFyLFxyXG4gICAgICBwcm9ncmFtOiBwcm9ncmFtXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBwYXJzZURyYXcgKG9wdGlvbnMsIGVudikge1xyXG4gICAgdmFyIHN0YXRpY09wdGlvbnMgPSBvcHRpb25zLnN0YXRpYztcclxuICAgIHZhciBkeW5hbWljT3B0aW9ucyA9IG9wdGlvbnMuZHluYW1pYztcclxuXHJcbiAgICBmdW5jdGlvbiBwYXJzZUVsZW1lbnRzICgpIHtcclxuICAgICAgaWYgKFNfRUxFTUVOVFMgaW4gc3RhdGljT3B0aW9ucykge1xyXG4gICAgICAgIHZhciBlbGVtZW50cyA9IHN0YXRpY09wdGlvbnNbU19FTEVNRU5UU107XHJcbiAgICAgICAgaWYgKGlzQnVmZmVyQXJncyhlbGVtZW50cykpIHtcclxuICAgICAgICAgIGVsZW1lbnRzID0gZWxlbWVudFN0YXRlLmdldEVsZW1lbnRzKGVsZW1lbnRTdGF0ZS5jcmVhdGUoZWxlbWVudHMsIHRydWUpKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnRzKSB7XHJcbiAgICAgICAgICBlbGVtZW50cyA9IGVsZW1lbnRTdGF0ZS5nZXRFbGVtZW50cyhlbGVtZW50cyk7XHJcbiAgICAgICAgICBjaGVjayQxLmNvbW1hbmQoZWxlbWVudHMsICdpbnZhbGlkIGVsZW1lbnRzJywgZW52LmNvbW1hbmRTdHIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlU3RhdGljRGVjbChmdW5jdGlvbiAoZW52LCBzY29wZSkge1xyXG4gICAgICAgICAgaWYgKGVsZW1lbnRzKSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBlbnYubGluayhlbGVtZW50cyk7XHJcbiAgICAgICAgICAgIGVudi5FTEVNRU5UUyA9IHJlc3VsdDtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZW52LkVMRU1FTlRTID0gbnVsbDtcclxuICAgICAgICAgIHJldHVybiBudWxsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmVzdWx0LnZhbHVlID0gZWxlbWVudHM7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxyXG4gICAgICB9IGVsc2UgaWYgKFNfRUxFTUVOVFMgaW4gZHluYW1pY09wdGlvbnMpIHtcclxuICAgICAgICB2YXIgZHluID0gZHluYW1pY09wdGlvbnNbU19FTEVNRU5UU107XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR5bmFtaWNEZWNsKGR5biwgZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcclxuICAgICAgICAgIHZhciBzaGFyZWQgPSBlbnYuc2hhcmVkO1xyXG5cclxuICAgICAgICAgIHZhciBJU19CVUZGRVJfQVJHUyA9IHNoYXJlZC5pc0J1ZmZlckFyZ3M7XHJcbiAgICAgICAgICB2YXIgRUxFTUVOVF9TVEFURSA9IHNoYXJlZC5lbGVtZW50cztcclxuXHJcbiAgICAgICAgICB2YXIgZWxlbWVudERlZm4gPSBlbnYuaW52b2tlKHNjb3BlLCBkeW4pO1xyXG4gICAgICAgICAgdmFyIGVsZW1lbnRzID0gc2NvcGUuZGVmKCdudWxsJyk7XHJcbiAgICAgICAgICB2YXIgZWxlbWVudFN0cmVhbSA9IHNjb3BlLmRlZihJU19CVUZGRVJfQVJHUywgJygnLCBlbGVtZW50RGVmbiwgJyknKTtcclxuXHJcbiAgICAgICAgICB2YXIgaWZ0ZSA9IGVudi5jb25kKGVsZW1lbnRTdHJlYW0pXHJcbiAgICAgICAgICAgIC50aGVuKGVsZW1lbnRzLCAnPScsIEVMRU1FTlRfU1RBVEUsICcuY3JlYXRlU3RyZWFtKCcsIGVsZW1lbnREZWZuLCAnKTsnKVxyXG4gICAgICAgICAgICAuZWxzZShlbGVtZW50cywgJz0nLCBFTEVNRU5UX1NUQVRFLCAnLmdldEVsZW1lbnRzKCcsIGVsZW1lbnREZWZuLCAnKTsnKTtcclxuXHJcbiAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZW52LmFzc2VydChpZnRlLmVsc2UsXHJcbiAgICAgICAgICAgICAgJyEnICsgZWxlbWVudERlZm4gKyAnfHwnICsgZWxlbWVudHMsXHJcbiAgICAgICAgICAgICAgJ2ludmFsaWQgZWxlbWVudHMnKTtcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIHNjb3BlLmVudHJ5KGlmdGUpO1xyXG4gICAgICAgICAgc2NvcGUuZXhpdChcclxuICAgICAgICAgICAgZW52LmNvbmQoZWxlbWVudFN0cmVhbSlcclxuICAgICAgICAgICAgICAudGhlbihFTEVNRU5UX1NUQVRFLCAnLmRlc3Ryb3lTdHJlYW0oJywgZWxlbWVudHMsICcpOycpKTtcclxuXHJcbiAgICAgICAgICBlbnYuRUxFTUVOVFMgPSBlbGVtZW50cztcclxuXHJcbiAgICAgICAgICByZXR1cm4gZWxlbWVudHNcclxuICAgICAgICB9KVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbnVsbFxyXG4gICAgfVxyXG5cclxuICAgIHZhciBlbGVtZW50cyA9IHBhcnNlRWxlbWVudHMoKTtcclxuXHJcbiAgICBmdW5jdGlvbiBwYXJzZVByaW1pdGl2ZSAoKSB7XHJcbiAgICAgIGlmIChTX1BSSU1JVElWRSBpbiBzdGF0aWNPcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIHByaW1pdGl2ZSA9IHN0YXRpY09wdGlvbnNbU19QUklNSVRJVkVdO1xyXG4gICAgICAgIGNoZWNrJDEuY29tbWFuZFBhcmFtZXRlcihwcmltaXRpdmUsIHByaW1UeXBlcywgJ2ludmFsaWQgcHJpbWl0dmUnLCBlbnYuY29tbWFuZFN0cik7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVN0YXRpY0RlY2woZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcclxuICAgICAgICAgIHJldHVybiBwcmltVHlwZXNbcHJpbWl0aXZlXVxyXG4gICAgICAgIH0pXHJcbiAgICAgIH0gZWxzZSBpZiAoU19QUklNSVRJVkUgaW4gZHluYW1pY09wdGlvbnMpIHtcclxuICAgICAgICB2YXIgZHluUHJpbWl0aXZlID0gZHluYW1pY09wdGlvbnNbU19QUklNSVRJVkVdO1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVEeW5hbWljRGVjbChkeW5QcmltaXRpdmUsIGZ1bmN0aW9uIChlbnYsIHNjb3BlKSB7XHJcbiAgICAgICAgICB2YXIgUFJJTV9UWVBFUyA9IGVudi5jb25zdGFudHMucHJpbVR5cGVzO1xyXG4gICAgICAgICAgdmFyIHByaW0gPSBlbnYuaW52b2tlKHNjb3BlLCBkeW5QcmltaXRpdmUpO1xyXG4gICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGVudi5hc3NlcnQoc2NvcGUsXHJcbiAgICAgICAgICAgICAgcHJpbSArICcgaW4gJyArIFBSSU1fVFlQRVMsXHJcbiAgICAgICAgICAgICAgJ2ludmFsaWQgcHJpbWl0aXZlLCBtdXN0IGJlIG9uZSBvZiAnICsgT2JqZWN0LmtleXMocHJpbVR5cGVzKSk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIHJldHVybiBzY29wZS5kZWYoUFJJTV9UWVBFUywgJ1snLCBwcmltLCAnXScpXHJcbiAgICAgICAgfSlcclxuICAgICAgfSBlbHNlIGlmIChlbGVtZW50cykge1xyXG4gICAgICAgIGlmIChpc1N0YXRpYyhlbGVtZW50cykpIHtcclxuICAgICAgICAgIGlmIChlbGVtZW50cy52YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlU3RhdGljRGVjbChmdW5jdGlvbiAoZW52LCBzY29wZSkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBzY29wZS5kZWYoZW52LkVMRU1FTlRTLCAnLnByaW1UeXBlJylcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVTdGF0aWNEZWNsKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gR0xfVFJJQU5HTEVTJDFcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmV0dXJuIG5ldyBEZWNsYXJhdGlvbihcclxuICAgICAgICAgICAgZWxlbWVudHMudGhpc0RlcCxcclxuICAgICAgICAgICAgZWxlbWVudHMuY29udGV4dERlcCxcclxuICAgICAgICAgICAgZWxlbWVudHMucHJvcERlcCxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcclxuICAgICAgICAgICAgICB2YXIgZWxlbWVudHMgPSBlbnYuRUxFTUVOVFM7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlLmRlZihlbGVtZW50cywgJz8nLCBlbGVtZW50cywgJy5wcmltVHlwZTonLCBHTF9UUklBTkdMRVMkMSlcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG51bGxcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwYXJzZVBhcmFtIChwYXJhbSwgaXNPZmZzZXQpIHtcclxuICAgICAgaWYgKHBhcmFtIGluIHN0YXRpY09wdGlvbnMpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSBzdGF0aWNPcHRpb25zW3BhcmFtXSB8IDA7XHJcbiAgICAgICAgY2hlY2skMS5jb21tYW5kKCFpc09mZnNldCB8fCB2YWx1ZSA+PSAwLCAnaW52YWxpZCAnICsgcGFyYW0sIGVudi5jb21tYW5kU3RyKTtcclxuICAgICAgICByZXR1cm4gY3JlYXRlU3RhdGljRGVjbChmdW5jdGlvbiAoZW52LCBzY29wZSkge1xyXG4gICAgICAgICAgaWYgKGlzT2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIGVudi5PRkZTRVQgPSB2YWx1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiB2YWx1ZVxyXG4gICAgICAgIH0pXHJcbiAgICAgIH0gZWxzZSBpZiAocGFyYW0gaW4gZHluYW1pY09wdGlvbnMpIHtcclxuICAgICAgICB2YXIgZHluVmFsdWUgPSBkeW5hbWljT3B0aW9uc1twYXJhbV07XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR5bmFtaWNEZWNsKGR5blZhbHVlLCBmdW5jdGlvbiAoZW52LCBzY29wZSkge1xyXG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGVudi5pbnZva2Uoc2NvcGUsIGR5blZhbHVlKTtcclxuICAgICAgICAgIGlmIChpc09mZnNldCkge1xyXG4gICAgICAgICAgICBlbnYuT0ZGU0VUID0gcmVzdWx0O1xyXG4gICAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLFxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICsgJz49MCcsXHJcbiAgICAgICAgICAgICAgICAnaW52YWxpZCAnICsgcGFyYW0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiByZXN1bHRcclxuICAgICAgICB9KVxyXG4gICAgICB9IGVsc2UgaWYgKGlzT2Zmc2V0ICYmIGVsZW1lbnRzKSB7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVN0YXRpY0RlY2woZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcclxuICAgICAgICAgIGVudi5PRkZTRVQgPSAnMCc7XHJcbiAgICAgICAgICByZXR1cm4gMFxyXG4gICAgICAgIH0pXHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG51bGxcclxuICAgIH1cclxuXHJcbiAgICB2YXIgT0ZGU0VUID0gcGFyc2VQYXJhbShTX09GRlNFVCwgdHJ1ZSk7XHJcblxyXG4gICAgZnVuY3Rpb24gcGFyc2VWZXJ0Q291bnQgKCkge1xyXG4gICAgICBpZiAoU19DT1VOVCBpbiBzdGF0aWNPcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIGNvdW50ID0gc3RhdGljT3B0aW9uc1tTX0NPVU5UXSB8IDA7XHJcbiAgICAgICAgY2hlY2skMS5jb21tYW5kKFxyXG4gICAgICAgICAgdHlwZW9mIGNvdW50ID09PSAnbnVtYmVyJyAmJiBjb3VudCA+PSAwLCAnaW52YWxpZCB2ZXJ0ZXggY291bnQnLCBlbnYuY29tbWFuZFN0cik7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVN0YXRpY0RlY2woZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgcmV0dXJuIGNvdW50XHJcbiAgICAgICAgfSlcclxuICAgICAgfSBlbHNlIGlmIChTX0NPVU5UIGluIGR5bmFtaWNPcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIGR5bkNvdW50ID0gZHluYW1pY09wdGlvbnNbU19DT1VOVF07XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR5bmFtaWNEZWNsKGR5bkNvdW50LCBmdW5jdGlvbiAoZW52LCBzY29wZSkge1xyXG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGVudi5pbnZva2Uoc2NvcGUsIGR5bkNvdW50KTtcclxuICAgICAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLFxyXG4gICAgICAgICAgICAgICd0eXBlb2YgJyArIHJlc3VsdCArICc9PT1cIm51bWJlclwiJiYnICtcclxuICAgICAgICAgICAgICByZXN1bHQgKyAnPj0wJiYnICtcclxuICAgICAgICAgICAgICByZXN1bHQgKyAnPT09KCcgKyByZXN1bHQgKyAnfDApJyxcclxuICAgICAgICAgICAgICAnaW52YWxpZCB2ZXJ0ZXggY291bnQnKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdFxyXG4gICAgICAgIH0pXHJcbiAgICAgIH0gZWxzZSBpZiAoZWxlbWVudHMpIHtcclxuICAgICAgICBpZiAoaXNTdGF0aWMoZWxlbWVudHMpKSB7XHJcbiAgICAgICAgICBpZiAoZWxlbWVudHMpIHtcclxuICAgICAgICAgICAgaWYgKE9GRlNFVCkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBuZXcgRGVjbGFyYXRpb24oXHJcbiAgICAgICAgICAgICAgICBPRkZTRVQudGhpc0RlcCxcclxuICAgICAgICAgICAgICAgIE9GRlNFVC5jb250ZXh0RGVwLFxyXG4gICAgICAgICAgICAgICAgT0ZGU0VULnByb3BEZXAsXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZW52LCBzY29wZSkge1xyXG4gICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gc2NvcGUuZGVmKFxyXG4gICAgICAgICAgICAgICAgICAgIGVudi5FTEVNRU5UUywgJy52ZXJ0Q291bnQtJywgZW52Lk9GRlNFVCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICsgJz49MCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAnaW52YWxpZCB2ZXJ0ZXggb2Zmc2V0L2VsZW1lbnQgYnVmZmVyIHRvbyBzbWFsbCcpO1xyXG4gICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVN0YXRpY0RlY2woZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzY29wZS5kZWYoZW52LkVMRU1FTlRTLCAnLnZlcnRDb3VudCcpXHJcbiAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZVN0YXRpY0RlY2woZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgIHJldHVybiAtMVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgcmVzdWx0Lk1JU1NJTkcgPSB0cnVlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB2YXIgdmFyaWFibGUgPSBuZXcgRGVjbGFyYXRpb24oXHJcbiAgICAgICAgICAgIGVsZW1lbnRzLnRoaXNEZXAgfHwgT0ZGU0VULnRoaXNEZXAsXHJcbiAgICAgICAgICAgIGVsZW1lbnRzLmNvbnRleHREZXAgfHwgT0ZGU0VULmNvbnRleHREZXAsXHJcbiAgICAgICAgICAgIGVsZW1lbnRzLnByb3BEZXAgfHwgT0ZGU0VULnByb3BEZXAsXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlbnYsIHNjb3BlKSB7XHJcbiAgICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gZW52LkVMRU1FTlRTO1xyXG4gICAgICAgICAgICAgIGlmIChlbnYuT0ZGU0VUKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGUuZGVmKGVsZW1lbnRzLCAnPycsIGVsZW1lbnRzLCAnLnZlcnRDb3VudC0nLFxyXG4gICAgICAgICAgICAgICAgICBlbnYuT0ZGU0VULCAnOi0xJylcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlLmRlZihlbGVtZW50cywgJz8nLCBlbGVtZW50cywgJy52ZXJ0Q291bnQ6LTEnKVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXJpYWJsZS5EWU5BTUlDID0gdHJ1ZTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgcmV0dXJuIHZhcmlhYmxlXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBudWxsXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgZWxlbWVudHM6IGVsZW1lbnRzLFxyXG4gICAgICBwcmltaXRpdmU6IHBhcnNlUHJpbWl0aXZlKCksXHJcbiAgICAgIGNvdW50OiBwYXJzZVZlcnRDb3VudCgpLFxyXG4gICAgICBpbnN0YW5jZXM6IHBhcnNlUGFyYW0oU19JTlNUQU5DRVMsIGZhbHNlKSxcclxuICAgICAgb2Zmc2V0OiBPRkZTRVRcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHBhcnNlR0xTdGF0ZSAob3B0aW9ucywgZW52KSB7XHJcbiAgICB2YXIgc3RhdGljT3B0aW9ucyA9IG9wdGlvbnMuc3RhdGljO1xyXG4gICAgdmFyIGR5bmFtaWNPcHRpb25zID0gb3B0aW9ucy5keW5hbWljO1xyXG5cclxuICAgIHZhciBTVEFURSA9IHt9O1xyXG5cclxuICAgIEdMX1NUQVRFX05BTUVTLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcclxuICAgICAgdmFyIHBhcmFtID0gcHJvcE5hbWUocHJvcCk7XHJcblxyXG4gICAgICBmdW5jdGlvbiBwYXJzZVBhcmFtIChwYXJzZVN0YXRpYywgcGFyc2VEeW5hbWljKSB7XHJcbiAgICAgICAgaWYgKHByb3AgaW4gc3RhdGljT3B0aW9ucykge1xyXG4gICAgICAgICAgdmFyIHZhbHVlID0gcGFyc2VTdGF0aWMoc3RhdGljT3B0aW9uc1twcm9wXSk7XHJcbiAgICAgICAgICBTVEFURVtwYXJhbV0gPSBjcmVhdGVTdGF0aWNEZWNsKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2UgaWYgKHByb3AgaW4gZHluYW1pY09wdGlvbnMpIHtcclxuICAgICAgICAgIHZhciBkeW4gPSBkeW5hbWljT3B0aW9uc1twcm9wXTtcclxuICAgICAgICAgIFNUQVRFW3BhcmFtXSA9IGNyZWF0ZUR5bmFtaWNEZWNsKGR5biwgZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRHluYW1pYyhlbnYsIHNjb3BlLCBlbnYuaW52b2tlKHNjb3BlLCBkeW4pKVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBzd2l0Y2ggKHByb3ApIHtcclxuICAgICAgICBjYXNlIFNfQ1VMTF9FTkFCTEU6XHJcbiAgICAgICAgY2FzZSBTX0JMRU5EX0VOQUJMRTpcclxuICAgICAgICBjYXNlIFNfRElUSEVSOlxyXG4gICAgICAgIGNhc2UgU19TVEVOQ0lMX0VOQUJMRTpcclxuICAgICAgICBjYXNlIFNfREVQVEhfRU5BQkxFOlxyXG4gICAgICAgIGNhc2UgU19TQ0lTU09SX0VOQUJMRTpcclxuICAgICAgICBjYXNlIFNfUE9MWUdPTl9PRkZTRVRfRU5BQkxFOlxyXG4gICAgICAgIGNhc2UgU19TQU1QTEVfQUxQSEE6XHJcbiAgICAgICAgY2FzZSBTX1NBTVBMRV9FTkFCTEU6XHJcbiAgICAgICAgY2FzZSBTX0RFUFRIX01BU0s6XHJcbiAgICAgICAgICByZXR1cm4gcGFyc2VQYXJhbShcclxuICAgICAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kVHlwZSh2YWx1ZSwgJ2Jvb2xlYW4nLCBwcm9wLCBlbnYuY29tbWFuZFN0cik7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlbnYsIHNjb3BlLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgZW52LmFzc2VydChzY29wZSxcclxuICAgICAgICAgICAgICAgICAgJ3R5cGVvZiAnICsgdmFsdWUgKyAnPT09XCJib29sZWFuXCInLFxyXG4gICAgICAgICAgICAgICAgICAnaW52YWxpZCBmbGFnICcgKyBwcm9wLCBlbnYuY29tbWFuZFN0cik7XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlXHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgIGNhc2UgU19ERVBUSF9GVU5DOlxyXG4gICAgICAgICAgcmV0dXJuIHBhcnNlUGFyYW0oXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZFBhcmFtZXRlcih2YWx1ZSwgY29tcGFyZUZ1bmNzLCAnaW52YWxpZCAnICsgcHJvcCwgZW52LmNvbW1hbmRTdHIpO1xyXG4gICAgICAgICAgICAgIHJldHVybiBjb21wYXJlRnVuY3NbdmFsdWVdXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlbnYsIHNjb3BlLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgIHZhciBDT01QQVJFX0ZVTkNTID0gZW52LmNvbnN0YW50cy5jb21wYXJlRnVuY3M7XHJcbiAgICAgICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLFxyXG4gICAgICAgICAgICAgICAgICB2YWx1ZSArICcgaW4gJyArIENPTVBBUkVfRlVOQ1MsXHJcbiAgICAgICAgICAgICAgICAgICdpbnZhbGlkICcgKyBwcm9wICsgJywgbXVzdCBiZSBvbmUgb2YgJyArIE9iamVjdC5rZXlzKGNvbXBhcmVGdW5jcykpO1xyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIHJldHVybiBzY29wZS5kZWYoQ09NUEFSRV9GVU5DUywgJ1snLCB2YWx1ZSwgJ10nKVxyXG4gICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICBjYXNlIFNfREVQVEhfUkFOR0U6XHJcbiAgICAgICAgICByZXR1cm4gcGFyc2VQYXJhbShcclxuICAgICAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKFxyXG4gICAgICAgICAgICAgICAgaXNBcnJheUxpa2UodmFsdWUpICYmXHJcbiAgICAgICAgICAgICAgICB2YWx1ZS5sZW5ndGggPT09IDIgJiZcclxuICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZVswXSA9PT0gJ251bWJlcicgJiZcclxuICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZVsxXSA9PT0gJ251bWJlcicgJiZcclxuICAgICAgICAgICAgICAgIHZhbHVlWzBdIDw9IHZhbHVlWzFdLFxyXG4gICAgICAgICAgICAgICAgJ2RlcHRoIHJhbmdlIGlzIDJkIGFycmF5JyxcclxuICAgICAgICAgICAgICAgIGVudi5jb21tYW5kU3RyKTtcclxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWVcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGVudiwgc2NvcGUsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLFxyXG4gICAgICAgICAgICAgICAgICBlbnYuc2hhcmVkLmlzQXJyYXlMaWtlICsgJygnICsgdmFsdWUgKyAnKSYmJyArXHJcbiAgICAgICAgICAgICAgICAgIHZhbHVlICsgJy5sZW5ndGg9PT0yJiYnICtcclxuICAgICAgICAgICAgICAgICAgJ3R5cGVvZiAnICsgdmFsdWUgKyAnWzBdPT09XCJudW1iZXJcIiYmJyArXHJcbiAgICAgICAgICAgICAgICAgICd0eXBlb2YgJyArIHZhbHVlICsgJ1sxXT09PVwibnVtYmVyXCImJicgK1xyXG4gICAgICAgICAgICAgICAgICB2YWx1ZSArICdbMF08PScgKyB2YWx1ZSArICdbMV0nLFxyXG4gICAgICAgICAgICAgICAgICAnZGVwdGggcmFuZ2UgbXVzdCBiZSBhIDJkIGFycmF5Jyk7XHJcbiAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgIHZhciBaX05FQVIgPSBzY29wZS5kZWYoJysnLCB2YWx1ZSwgJ1swXScpO1xyXG4gICAgICAgICAgICAgIHZhciBaX0ZBUiA9IHNjb3BlLmRlZignKycsIHZhbHVlLCAnWzFdJyk7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIFtaX05FQVIsIFpfRkFSXVxyXG4gICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICBjYXNlIFNfQkxFTkRfRlVOQzpcclxuICAgICAgICAgIHJldHVybiBwYXJzZVBhcmFtKFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmRUeXBlKHZhbHVlLCAnb2JqZWN0JywgJ2JsZW5kLmZ1bmMnLCBlbnYuY29tbWFuZFN0cik7XHJcbiAgICAgICAgICAgICAgdmFyIHNyY1JHQiA9ICgnc3JjUkdCJyBpbiB2YWx1ZSA/IHZhbHVlLnNyY1JHQiA6IHZhbHVlLnNyYyk7XHJcbiAgICAgICAgICAgICAgdmFyIHNyY0FscGhhID0gKCdzcmNBbHBoYScgaW4gdmFsdWUgPyB2YWx1ZS5zcmNBbHBoYSA6IHZhbHVlLnNyYyk7XHJcbiAgICAgICAgICAgICAgdmFyIGRzdFJHQiA9ICgnZHN0UkdCJyBpbiB2YWx1ZSA/IHZhbHVlLmRzdFJHQiA6IHZhbHVlLmRzdCk7XHJcbiAgICAgICAgICAgICAgdmFyIGRzdEFscGhhID0gKCdkc3RBbHBoYScgaW4gdmFsdWUgPyB2YWx1ZS5kc3RBbHBoYSA6IHZhbHVlLmRzdCk7XHJcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kUGFyYW1ldGVyKHNyY1JHQiwgYmxlbmRGdW5jcywgcGFyYW0gKyAnLnNyY1JHQicsIGVudi5jb21tYW5kU3RyKTtcclxuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmRQYXJhbWV0ZXIoc3JjQWxwaGEsIGJsZW5kRnVuY3MsIHBhcmFtICsgJy5zcmNBbHBoYScsIGVudi5jb21tYW5kU3RyKTtcclxuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmRQYXJhbWV0ZXIoZHN0UkdCLCBibGVuZEZ1bmNzLCBwYXJhbSArICcuZHN0UkdCJywgZW52LmNvbW1hbmRTdHIpO1xyXG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZFBhcmFtZXRlcihkc3RBbHBoYSwgYmxlbmRGdW5jcywgcGFyYW0gKyAnLmRzdEFscGhhJywgZW52LmNvbW1hbmRTdHIpO1xyXG5cclxuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmQoXHJcbiAgICAgICAgICAgICAgICAoaW52YWxpZEJsZW5kQ29tYmluYXRpb25zLmluZGV4T2Yoc3JjUkdCICsgJywgJyArIGRzdFJHQikgPT09IC0xKSxcclxuICAgICAgICAgICAgICAgICd1bmFsbG93ZWQgYmxlbmRpbmcgY29tYmluYXRpb24gKHNyY1JHQiwgZHN0UkdCKSA9ICgnICsgc3JjUkdCICsgJywgJyArIGRzdFJHQiArICcpJywgZW52LmNvbW1hbmRTdHIpO1xyXG5cclxuICAgICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgYmxlbmRGdW5jc1tzcmNSR0JdLFxyXG4gICAgICAgICAgICAgICAgYmxlbmRGdW5jc1tkc3RSR0JdLFxyXG4gICAgICAgICAgICAgICAgYmxlbmRGdW5jc1tzcmNBbHBoYV0sXHJcbiAgICAgICAgICAgICAgICBibGVuZEZ1bmNzW2RzdEFscGhhXVxyXG4gICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGVudiwgc2NvcGUsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgdmFyIEJMRU5EX0ZVTkNTID0gZW52LmNvbnN0YW50cy5ibGVuZEZ1bmNzO1xyXG5cclxuICAgICAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGVudi5hc3NlcnQoc2NvcGUsXHJcbiAgICAgICAgICAgICAgICAgIHZhbHVlICsgJyYmdHlwZW9mICcgKyB2YWx1ZSArICc9PT1cIm9iamVjdFwiJyxcclxuICAgICAgICAgICAgICAgICAgJ2ludmFsaWQgYmxlbmQgZnVuYywgbXVzdCBiZSBhbiBvYmplY3QnKTtcclxuICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgZnVuY3Rpb24gcmVhZCAocHJlZml4LCBzdWZmaXgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmdW5jID0gc2NvcGUuZGVmKFxyXG4gICAgICAgICAgICAgICAgICAnXCInLCBwcmVmaXgsIHN1ZmZpeCwgJ1wiIGluICcsIHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAnPycsIHZhbHVlLCAnLicsIHByZWZpeCwgc3VmZml4LFxyXG4gICAgICAgICAgICAgICAgICAnOicsIHZhbHVlLCAnLicsIHByZWZpeCk7XHJcblxyXG4gICAgICAgICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgIGVudi5hc3NlcnQoc2NvcGUsXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuYyArICcgaW4gJyArIEJMRU5EX0ZVTkNTLFxyXG4gICAgICAgICAgICAgICAgICAgICdpbnZhbGlkICcgKyBwcm9wICsgJy4nICsgcHJlZml4ICsgc3VmZml4ICsgJywgbXVzdCBiZSBvbmUgb2YgJyArIE9iamVjdC5rZXlzKGJsZW5kRnVuY3MpKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jXHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICB2YXIgc3JjUkdCID0gcmVhZCgnc3JjJywgJ1JHQicpO1xyXG4gICAgICAgICAgICAgIHZhciBkc3RSR0IgPSByZWFkKCdkc3QnLCAnUkdCJyk7XHJcblxyXG4gICAgICAgICAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIElOVkFMSURfQkxFTkRfQ09NQklOQVRJT05TID0gZW52LmNvbnN0YW50cy5pbnZhbGlkQmxlbmRDb21iaW5hdGlvbnM7XHJcblxyXG4gICAgICAgICAgICAgICAgZW52LmFzc2VydChzY29wZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgSU5WQUxJRF9CTEVORF9DT01CSU5BVElPTlMgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAnLmluZGV4T2YoJyArIHNyY1JHQiArICcrXCIsIFwiKycgKyBkc3RSR0IgKyAnKSA9PT0gLTEgJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3VuYWxsb3dlZCBibGVuZGluZyBjb21iaW5hdGlvbiBmb3IgKHNyY1JHQiwgZHN0UkdCKSdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICB2YXIgU1JDX1JHQiA9IHNjb3BlLmRlZihCTEVORF9GVU5DUywgJ1snLCBzcmNSR0IsICddJyk7XHJcbiAgICAgICAgICAgICAgdmFyIFNSQ19BTFBIQSA9IHNjb3BlLmRlZihCTEVORF9GVU5DUywgJ1snLCByZWFkKCdzcmMnLCAnQWxwaGEnKSwgJ10nKTtcclxuICAgICAgICAgICAgICB2YXIgRFNUX1JHQiA9IHNjb3BlLmRlZihCTEVORF9GVU5DUywgJ1snLCBkc3RSR0IsICddJyk7XHJcbiAgICAgICAgICAgICAgdmFyIERTVF9BTFBIQSA9IHNjb3BlLmRlZihCTEVORF9GVU5DUywgJ1snLCByZWFkKCdkc3QnLCAnQWxwaGEnKSwgJ10nKTtcclxuXHJcbiAgICAgICAgICAgICAgcmV0dXJuIFtTUkNfUkdCLCBEU1RfUkdCLCBTUkNfQUxQSEEsIERTVF9BTFBIQV1cclxuICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgY2FzZSBTX0JMRU5EX0VRVUFUSU9OOlxyXG4gICAgICAgICAgcmV0dXJuIHBhcnNlUGFyYW0oXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmRQYXJhbWV0ZXIodmFsdWUsIGJsZW5kRXF1YXRpb25zLCAnaW52YWxpZCAnICsgcHJvcCwgZW52LmNvbW1hbmRTdHIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgICAgYmxlbmRFcXVhdGlvbnNbdmFsdWVdLFxyXG4gICAgICAgICAgICAgICAgICBibGVuZEVxdWF0aW9uc1t2YWx1ZV1cclxuICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZFBhcmFtZXRlcihcclxuICAgICAgICAgICAgICAgICAgdmFsdWUucmdiLCBibGVuZEVxdWF0aW9ucywgcHJvcCArICcucmdiJywgZW52LmNvbW1hbmRTdHIpO1xyXG4gICAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kUGFyYW1ldGVyKFxyXG4gICAgICAgICAgICAgICAgICB2YWx1ZS5hbHBoYSwgYmxlbmRFcXVhdGlvbnMsIHByb3AgKyAnLmFscGhhJywgZW52LmNvbW1hbmRTdHIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgICAgYmxlbmRFcXVhdGlvbnNbdmFsdWUucmdiXSxcclxuICAgICAgICAgICAgICAgICAgYmxlbmRFcXVhdGlvbnNbdmFsdWUuYWxwaGFdXHJcbiAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZFJhaXNlKCdpbnZhbGlkIGJsZW5kLmVxdWF0aW9uJywgZW52LmNvbW1hbmRTdHIpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGVudiwgc2NvcGUsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgdmFyIEJMRU5EX0VRVUFUSU9OUyA9IGVudi5jb25zdGFudHMuYmxlbmRFcXVhdGlvbnM7XHJcblxyXG4gICAgICAgICAgICAgIHZhciBSR0IgPSBzY29wZS5kZWYoKTtcclxuICAgICAgICAgICAgICB2YXIgQUxQSEEgPSBzY29wZS5kZWYoKTtcclxuXHJcbiAgICAgICAgICAgICAgdmFyIGlmdGUgPSBlbnYuY29uZCgndHlwZW9mICcsIHZhbHVlLCAnPT09XCJzdHJpbmdcIicpO1xyXG5cclxuICAgICAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNoZWNrUHJvcCAoYmxvY2ssIG5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgIGVudi5hc3NlcnQoYmxvY2ssXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKyAnIGluICcgKyBCTEVORF9FUVVBVElPTlMsXHJcbiAgICAgICAgICAgICAgICAgICAgJ2ludmFsaWQgJyArIG5hbWUgKyAnLCBtdXN0IGJlIG9uZSBvZiAnICsgT2JqZWN0LmtleXMoYmxlbmRFcXVhdGlvbnMpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNoZWNrUHJvcChpZnRlLnRoZW4sIHByb3AsIHZhbHVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBlbnYuYXNzZXJ0KGlmdGUuZWxzZSxcclxuICAgICAgICAgICAgICAgICAgdmFsdWUgKyAnJiZ0eXBlb2YgJyArIHZhbHVlICsgJz09PVwib2JqZWN0XCInLFxyXG4gICAgICAgICAgICAgICAgICAnaW52YWxpZCAnICsgcHJvcCk7XHJcbiAgICAgICAgICAgICAgICBjaGVja1Byb3AoaWZ0ZS5lbHNlLCBwcm9wICsgJy5yZ2InLCB2YWx1ZSArICcucmdiJyk7XHJcbiAgICAgICAgICAgICAgICBjaGVja1Byb3AoaWZ0ZS5lbHNlLCBwcm9wICsgJy5hbHBoYScsIHZhbHVlICsgJy5hbHBoYScpO1xyXG4gICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICBpZnRlLnRoZW4oXHJcbiAgICAgICAgICAgICAgICBSR0IsICc9JywgQUxQSEEsICc9JywgQkxFTkRfRVFVQVRJT05TLCAnWycsIHZhbHVlLCAnXTsnKTtcclxuICAgICAgICAgICAgICBpZnRlLmVsc2UoXHJcbiAgICAgICAgICAgICAgICBSR0IsICc9JywgQkxFTkRfRVFVQVRJT05TLCAnWycsIHZhbHVlLCAnLnJnYl07JyxcclxuICAgICAgICAgICAgICAgIEFMUEhBLCAnPScsIEJMRU5EX0VRVUFUSU9OUywgJ1snLCB2YWx1ZSwgJy5hbHBoYV07Jyk7XHJcblxyXG4gICAgICAgICAgICAgIHNjb3BlKGlmdGUpO1xyXG5cclxuICAgICAgICAgICAgICByZXR1cm4gW1JHQiwgQUxQSEFdXHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgIGNhc2UgU19CTEVORF9DT0xPUjpcclxuICAgICAgICAgIHJldHVybiBwYXJzZVBhcmFtKFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmQoXHJcbiAgICAgICAgICAgICAgICBpc0FycmF5TGlrZSh2YWx1ZSkgJiZcclxuICAgICAgICAgICAgICAgIHZhbHVlLmxlbmd0aCA9PT0gNCxcclxuICAgICAgICAgICAgICAgICdibGVuZC5jb2xvciBtdXN0IGJlIGEgNGQgYXJyYXknLCBlbnYuY29tbWFuZFN0cik7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGxvb3AoNCwgZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiArdmFsdWVbaV1cclxuICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZW52LCBzY29wZSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGVudi5hc3NlcnQoc2NvcGUsXHJcbiAgICAgICAgICAgICAgICAgIGVudi5zaGFyZWQuaXNBcnJheUxpa2UgKyAnKCcgKyB2YWx1ZSArICcpJiYnICtcclxuICAgICAgICAgICAgICAgICAgdmFsdWUgKyAnLmxlbmd0aD09PTQnLFxyXG4gICAgICAgICAgICAgICAgICAnYmxlbmQuY29sb3IgbXVzdCBiZSBhIDRkIGFycmF5Jyk7XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGxvb3AoNCwgZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzY29wZS5kZWYoJysnLCB2YWx1ZSwgJ1snLCBpLCAnXScpXHJcbiAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgY2FzZSBTX1NURU5DSUxfTUFTSzpcclxuICAgICAgICAgIHJldHVybiBwYXJzZVBhcmFtKFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmRUeXBlKHZhbHVlLCAnbnVtYmVyJywgcGFyYW0sIGVudi5jb21tYW5kU3RyKTtcclxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgfCAwXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlbnYsIHNjb3BlLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgZW52LmFzc2VydChzY29wZSxcclxuICAgICAgICAgICAgICAgICAgJ3R5cGVvZiAnICsgdmFsdWUgKyAnPT09XCJudW1iZXJcIicsXHJcbiAgICAgICAgICAgICAgICAgICdpbnZhbGlkIHN0ZW5jaWwubWFzaycpO1xyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIHJldHVybiBzY29wZS5kZWYodmFsdWUsICd8MCcpXHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgIGNhc2UgU19TVEVOQ0lMX0ZVTkM6XHJcbiAgICAgICAgICByZXR1cm4gcGFyc2VQYXJhbShcclxuICAgICAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kVHlwZSh2YWx1ZSwgJ29iamVjdCcsIHBhcmFtLCBlbnYuY29tbWFuZFN0cik7XHJcbiAgICAgICAgICAgICAgdmFyIGNtcCA9IHZhbHVlLmNtcCB8fCAna2VlcCc7XHJcbiAgICAgICAgICAgICAgdmFyIHJlZiA9IHZhbHVlLnJlZiB8fCAwO1xyXG4gICAgICAgICAgICAgIHZhciBtYXNrID0gJ21hc2snIGluIHZhbHVlID8gdmFsdWUubWFzayA6IC0xO1xyXG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZFBhcmFtZXRlcihjbXAsIGNvbXBhcmVGdW5jcywgcHJvcCArICcuY21wJywgZW52LmNvbW1hbmRTdHIpO1xyXG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZFR5cGUocmVmLCAnbnVtYmVyJywgcHJvcCArICcucmVmJywgZW52LmNvbW1hbmRTdHIpO1xyXG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZFR5cGUobWFzaywgJ251bWJlcicsIHByb3AgKyAnLm1hc2snLCBlbnYuY29tbWFuZFN0cik7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgIGNvbXBhcmVGdW5jc1tjbXBdLFxyXG4gICAgICAgICAgICAgICAgcmVmLFxyXG4gICAgICAgICAgICAgICAgbWFza1xyXG4gICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGVudiwgc2NvcGUsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgdmFyIENPTVBBUkVfRlVOQ1MgPSBlbnYuY29uc3RhbnRzLmNvbXBhcmVGdW5jcztcclxuICAgICAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGFzc2VydCAoKSB7XHJcbiAgICAgICAgICAgICAgICAgIGVudi5hc3NlcnQoc2NvcGUsXHJcbiAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLmpvaW4uY2FsbChhcmd1bWVudHMsICcnKSxcclxuICAgICAgICAgICAgICAgICAgICAnaW52YWxpZCBzdGVuY2lsLmZ1bmMnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFzc2VydCh2YWx1ZSArICcmJnR5cGVvZiAnLCB2YWx1ZSwgJz09PVwib2JqZWN0XCInKTtcclxuICAgICAgICAgICAgICAgIGFzc2VydCgnIShcImNtcFwiIGluICcsIHZhbHVlLCAnKXx8KCcsXHJcbiAgICAgICAgICAgICAgICAgIHZhbHVlLCAnLmNtcCBpbiAnLCBDT01QQVJFX0ZVTkNTLCAnKScpO1xyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIHZhciBjbXAgPSBzY29wZS5kZWYoXHJcbiAgICAgICAgICAgICAgICAnXCJjbXBcIiBpbiAnLCB2YWx1ZSxcclxuICAgICAgICAgICAgICAgICc/JywgQ09NUEFSRV9GVU5DUywgJ1snLCB2YWx1ZSwgJy5jbXBdJyxcclxuICAgICAgICAgICAgICAgICc6JywgR0xfS0VFUCk7XHJcbiAgICAgICAgICAgICAgdmFyIHJlZiA9IHNjb3BlLmRlZih2YWx1ZSwgJy5yZWZ8MCcpO1xyXG4gICAgICAgICAgICAgIHZhciBtYXNrID0gc2NvcGUuZGVmKFxyXG4gICAgICAgICAgICAgICAgJ1wibWFza1wiIGluICcsIHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgJz8nLCB2YWx1ZSwgJy5tYXNrfDA6LTEnKTtcclxuICAgICAgICAgICAgICByZXR1cm4gW2NtcCwgcmVmLCBtYXNrXVxyXG4gICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICBjYXNlIFNfU1RFTkNJTF9PUEZST05UOlxyXG4gICAgICAgIGNhc2UgU19TVEVOQ0lMX09QQkFDSzpcclxuICAgICAgICAgIHJldHVybiBwYXJzZVBhcmFtKFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmRUeXBlKHZhbHVlLCAnb2JqZWN0JywgcGFyYW0sIGVudi5jb21tYW5kU3RyKTtcclxuICAgICAgICAgICAgICB2YXIgZmFpbCA9IHZhbHVlLmZhaWwgfHwgJ2tlZXAnO1xyXG4gICAgICAgICAgICAgIHZhciB6ZmFpbCA9IHZhbHVlLnpmYWlsIHx8ICdrZWVwJztcclxuICAgICAgICAgICAgICB2YXIgenBhc3MgPSB2YWx1ZS56cGFzcyB8fCAna2VlcCc7XHJcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kUGFyYW1ldGVyKGZhaWwsIHN0ZW5jaWxPcHMsIHByb3AgKyAnLmZhaWwnLCBlbnYuY29tbWFuZFN0cik7XHJcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kUGFyYW1ldGVyKHpmYWlsLCBzdGVuY2lsT3BzLCBwcm9wICsgJy56ZmFpbCcsIGVudi5jb21tYW5kU3RyKTtcclxuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmRQYXJhbWV0ZXIoenBhc3MsIHN0ZW5jaWxPcHMsIHByb3AgKyAnLnpwYXNzJywgZW52LmNvbW1hbmRTdHIpO1xyXG4gICAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICBwcm9wID09PSBTX1NURU5DSUxfT1BCQUNLID8gR0xfQkFDSyA6IEdMX0ZST05ULFxyXG4gICAgICAgICAgICAgICAgc3RlbmNpbE9wc1tmYWlsXSxcclxuICAgICAgICAgICAgICAgIHN0ZW5jaWxPcHNbemZhaWxdLFxyXG4gICAgICAgICAgICAgICAgc3RlbmNpbE9wc1t6cGFzc11cclxuICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlbnYsIHNjb3BlLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgIHZhciBTVEVOQ0lMX09QUyA9IGVudi5jb25zdGFudHMuc3RlbmNpbE9wcztcclxuXHJcbiAgICAgICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLFxyXG4gICAgICAgICAgICAgICAgICB2YWx1ZSArICcmJnR5cGVvZiAnICsgdmFsdWUgKyAnPT09XCJvYmplY3RcIicsXHJcbiAgICAgICAgICAgICAgICAgICdpbnZhbGlkICcgKyBwcm9wKTtcclxuICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgZnVuY3Rpb24gcmVhZCAobmFtZSkge1xyXG4gICAgICAgICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgIGVudi5hc3NlcnQoc2NvcGUsXHJcbiAgICAgICAgICAgICAgICAgICAgJyEoXCInICsgbmFtZSArICdcIiBpbiAnICsgdmFsdWUgKyAnKXx8JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJygnICsgdmFsdWUgKyAnLicgKyBuYW1lICsgJyBpbiAnICsgU1RFTkNJTF9PUFMgKyAnKScsXHJcbiAgICAgICAgICAgICAgICAgICAgJ2ludmFsaWQgJyArIHByb3AgKyAnLicgKyBuYW1lICsgJywgbXVzdCBiZSBvbmUgb2YgJyArIE9iamVjdC5rZXlzKHN0ZW5jaWxPcHMpKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBzY29wZS5kZWYoXHJcbiAgICAgICAgICAgICAgICAgICdcIicsIG5hbWUsICdcIiBpbiAnLCB2YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgJz8nLCBTVEVOQ0lMX09QUywgJ1snLCB2YWx1ZSwgJy4nLCBuYW1lLCAnXTonLFxyXG4gICAgICAgICAgICAgICAgICBHTF9LRUVQKVxyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgIHByb3AgPT09IFNfU1RFTkNJTF9PUEJBQ0sgPyBHTF9CQUNLIDogR0xfRlJPTlQsXHJcbiAgICAgICAgICAgICAgICByZWFkKCdmYWlsJyksXHJcbiAgICAgICAgICAgICAgICByZWFkKCd6ZmFpbCcpLFxyXG4gICAgICAgICAgICAgICAgcmVhZCgnenBhc3MnKVxyXG4gICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgY2FzZSBTX1BPTFlHT05fT0ZGU0VUX09GRlNFVDpcclxuICAgICAgICAgIHJldHVybiBwYXJzZVBhcmFtKFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmRUeXBlKHZhbHVlLCAnb2JqZWN0JywgcGFyYW0sIGVudi5jb21tYW5kU3RyKTtcclxuICAgICAgICAgICAgICB2YXIgZmFjdG9yID0gdmFsdWUuZmFjdG9yIHwgMDtcclxuICAgICAgICAgICAgICB2YXIgdW5pdHMgPSB2YWx1ZS51bml0cyB8IDA7XHJcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kVHlwZShmYWN0b3IsICdudW1iZXInLCBwYXJhbSArICcuZmFjdG9yJywgZW52LmNvbW1hbmRTdHIpO1xyXG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZFR5cGUodW5pdHMsICdudW1iZXInLCBwYXJhbSArICcudW5pdHMnLCBlbnYuY29tbWFuZFN0cik7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIFtmYWN0b3IsIHVuaXRzXVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZW52LCBzY29wZSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGVudi5hc3NlcnQoc2NvcGUsXHJcbiAgICAgICAgICAgICAgICAgIHZhbHVlICsgJyYmdHlwZW9mICcgKyB2YWx1ZSArICc9PT1cIm9iamVjdFwiJyxcclxuICAgICAgICAgICAgICAgICAgJ2ludmFsaWQgJyArIHByb3ApO1xyXG4gICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICB2YXIgRkFDVE9SID0gc2NvcGUuZGVmKHZhbHVlLCAnLmZhY3RvcnwwJyk7XHJcbiAgICAgICAgICAgICAgdmFyIFVOSVRTID0gc2NvcGUuZGVmKHZhbHVlLCAnLnVuaXRzfDAnKTtcclxuXHJcbiAgICAgICAgICAgICAgcmV0dXJuIFtGQUNUT1IsIFVOSVRTXVxyXG4gICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICBjYXNlIFNfQ1VMTF9GQUNFOlxyXG4gICAgICAgICAgcmV0dXJuIHBhcnNlUGFyYW0oXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgIHZhciBmYWNlID0gMDtcclxuICAgICAgICAgICAgICBpZiAodmFsdWUgPT09ICdmcm9udCcpIHtcclxuICAgICAgICAgICAgICAgIGZhY2UgPSBHTF9GUk9OVDtcclxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAnYmFjaycpIHtcclxuICAgICAgICAgICAgICAgIGZhY2UgPSBHTF9CQUNLO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmQoISFmYWNlLCBwYXJhbSwgZW52LmNvbW1hbmRTdHIpO1xyXG4gICAgICAgICAgICAgIHJldHVybiBmYWNlXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlbnYsIHNjb3BlLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgZW52LmFzc2VydChzY29wZSxcclxuICAgICAgICAgICAgICAgICAgdmFsdWUgKyAnPT09XCJmcm9udFwifHwnICtcclxuICAgICAgICAgICAgICAgICAgdmFsdWUgKyAnPT09XCJiYWNrXCInLFxyXG4gICAgICAgICAgICAgICAgICAnaW52YWxpZCBjdWxsLmZhY2UnKTtcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICByZXR1cm4gc2NvcGUuZGVmKHZhbHVlLCAnPT09XCJmcm9udFwiPycsIEdMX0ZST05ULCAnOicsIEdMX0JBQ0spXHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgIGNhc2UgU19MSU5FX1dJRFRIOlxyXG4gICAgICAgICAgcmV0dXJuIHBhcnNlUGFyYW0oXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZChcclxuICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiZcclxuICAgICAgICAgICAgICAgIHZhbHVlID49IGxpbWl0cy5saW5lV2lkdGhEaW1zWzBdICYmXHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA8PSBsaW1pdHMubGluZVdpZHRoRGltc1sxXSxcclxuICAgICAgICAgICAgICAgICdpbnZhbGlkIGxpbmUgd2lkdGgsIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXIgYmV0d2VlbiAnICtcclxuICAgICAgICAgICAgICAgIGxpbWl0cy5saW5lV2lkdGhEaW1zWzBdICsgJyBhbmQgJyArIGxpbWl0cy5saW5lV2lkdGhEaW1zWzFdLCBlbnYuY29tbWFuZFN0cik7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlbnYsIHNjb3BlLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgZW52LmFzc2VydChzY29wZSxcclxuICAgICAgICAgICAgICAgICAgJ3R5cGVvZiAnICsgdmFsdWUgKyAnPT09XCJudW1iZXJcIiYmJyArXHJcbiAgICAgICAgICAgICAgICAgIHZhbHVlICsgJz49JyArIGxpbWl0cy5saW5lV2lkdGhEaW1zWzBdICsgJyYmJyArXHJcbiAgICAgICAgICAgICAgICAgIHZhbHVlICsgJzw9JyArIGxpbWl0cy5saW5lV2lkdGhEaW1zWzFdLFxyXG4gICAgICAgICAgICAgICAgICAnaW52YWxpZCBsaW5lIHdpZHRoJyk7XHJcbiAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZVxyXG4gICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICBjYXNlIFNfRlJPTlRfRkFDRTpcclxuICAgICAgICAgIHJldHVybiBwYXJzZVBhcmFtKFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmRQYXJhbWV0ZXIodmFsdWUsIG9yaWVudGF0aW9uVHlwZSwgcGFyYW0sIGVudi5jb21tYW5kU3RyKTtcclxuICAgICAgICAgICAgICByZXR1cm4gb3JpZW50YXRpb25UeXBlW3ZhbHVlXVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZW52LCBzY29wZSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGVudi5hc3NlcnQoc2NvcGUsXHJcbiAgICAgICAgICAgICAgICAgIHZhbHVlICsgJz09PVwiY3dcInx8JyArXHJcbiAgICAgICAgICAgICAgICAgIHZhbHVlICsgJz09PVwiY2N3XCInLFxyXG4gICAgICAgICAgICAgICAgICAnaW52YWxpZCBmcm9udEZhY2UsIG11c3QgYmUgb25lIG9mIGN3LGNjdycpO1xyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIHJldHVybiBzY29wZS5kZWYodmFsdWUgKyAnPT09XCJjd1wiPycgKyBHTF9DVyArICc6JyArIEdMX0NDVylcclxuICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgY2FzZSBTX0NPTE9SX01BU0s6XHJcbiAgICAgICAgICByZXR1cm4gcGFyc2VQYXJhbShcclxuICAgICAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKFxyXG4gICAgICAgICAgICAgICAgaXNBcnJheUxpa2UodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gNCxcclxuICAgICAgICAgICAgICAgICdjb2xvci5tYXNrIG11c3QgYmUgbGVuZ3RoIDQgYXJyYXknLCBlbnYuY29tbWFuZFN0cik7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gISF2IH0pXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlbnYsIHNjb3BlLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgZW52LmFzc2VydChzY29wZSxcclxuICAgICAgICAgICAgICAgICAgZW52LnNoYXJlZC5pc0FycmF5TGlrZSArICcoJyArIHZhbHVlICsgJykmJicgK1xyXG4gICAgICAgICAgICAgICAgICB2YWx1ZSArICcubGVuZ3RoPT09NCcsXHJcbiAgICAgICAgICAgICAgICAgICdpbnZhbGlkIGNvbG9yLm1hc2snKTtcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICByZXR1cm4gbG9vcCg0LCBmdW5jdGlvbiAoaSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICchIScgKyB2YWx1ZSArICdbJyArIGkgKyAnXSdcclxuICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICBjYXNlIFNfU0FNUExFX0NPVkVSQUdFOlxyXG4gICAgICAgICAgcmV0dXJuIHBhcnNlUGFyYW0oXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZCh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlLCBwYXJhbSwgZW52LmNvbW1hbmRTdHIpO1xyXG4gICAgICAgICAgICAgIHZhciBzYW1wbGVWYWx1ZSA9ICd2YWx1ZScgaW4gdmFsdWUgPyB2YWx1ZS52YWx1ZSA6IDE7XHJcbiAgICAgICAgICAgICAgdmFyIHNhbXBsZUludmVydCA9ICEhdmFsdWUuaW52ZXJ0O1xyXG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZChcclxuICAgICAgICAgICAgICAgIHR5cGVvZiBzYW1wbGVWYWx1ZSA9PT0gJ251bWJlcicgJiZcclxuICAgICAgICAgICAgICAgIHNhbXBsZVZhbHVlID49IDAgJiYgc2FtcGxlVmFsdWUgPD0gMSxcclxuICAgICAgICAgICAgICAgICdzYW1wbGUuY292ZXJhZ2UudmFsdWUgbXVzdCBiZSBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEnLCBlbnYuY29tbWFuZFN0cik7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIFtzYW1wbGVWYWx1ZSwgc2FtcGxlSW52ZXJ0XVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZW52LCBzY29wZSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGVudi5hc3NlcnQoc2NvcGUsXHJcbiAgICAgICAgICAgICAgICAgIHZhbHVlICsgJyYmdHlwZW9mICcgKyB2YWx1ZSArICc9PT1cIm9iamVjdFwiJyxcclxuICAgICAgICAgICAgICAgICAgJ2ludmFsaWQgc2FtcGxlLmNvdmVyYWdlJyk7XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgdmFyIFZBTFVFID0gc2NvcGUuZGVmKFxyXG4gICAgICAgICAgICAgICAgJ1widmFsdWVcIiBpbiAnLCB2YWx1ZSwgJz8rJywgdmFsdWUsICcudmFsdWU6MScpO1xyXG4gICAgICAgICAgICAgIHZhciBJTlZFUlQgPSBzY29wZS5kZWYoJyEhJywgdmFsdWUsICcuaW52ZXJ0Jyk7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIFtWQUxVRSwgSU5WRVJUXVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gU1RBVEVcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHBhcnNlVW5pZm9ybXMgKHVuaWZvcm1zLCBlbnYpIHtcclxuICAgIHZhciBzdGF0aWNVbmlmb3JtcyA9IHVuaWZvcm1zLnN0YXRpYztcclxuICAgIHZhciBkeW5hbWljVW5pZm9ybXMgPSB1bmlmb3Jtcy5keW5hbWljO1xyXG5cclxuICAgIHZhciBVTklGT1JNUyA9IHt9O1xyXG5cclxuICAgIE9iamVjdC5rZXlzKHN0YXRpY1VuaWZvcm1zKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgIHZhciB2YWx1ZSA9IHN0YXRpY1VuaWZvcm1zW25hbWVdO1xyXG4gICAgICB2YXIgcmVzdWx0O1xyXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fFxyXG4gICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgICByZXN1bHQgPSBjcmVhdGVTdGF0aWNEZWNsKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHJldHVybiB2YWx1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHZhciByZWdsVHlwZSA9IHZhbHVlLl9yZWdsVHlwZTtcclxuICAgICAgICBpZiAocmVnbFR5cGUgPT09ICd0ZXh0dXJlMmQnIHx8XHJcbiAgICAgICAgICAgIHJlZ2xUeXBlID09PSAndGV4dHVyZUN1YmUnKSB7XHJcbiAgICAgICAgICByZXN1bHQgPSBjcmVhdGVTdGF0aWNEZWNsKGZ1bmN0aW9uIChlbnYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVudi5saW5rKHZhbHVlKVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChyZWdsVHlwZSA9PT0gJ2ZyYW1lYnVmZmVyJyB8fFxyXG4gICAgICAgICAgICAgICAgICAgcmVnbFR5cGUgPT09ICdmcmFtZWJ1ZmZlckN1YmUnKSB7XHJcbiAgICAgICAgICBjaGVjayQxLmNvbW1hbmQodmFsdWUuY29sb3IubGVuZ3RoID4gMCxcclxuICAgICAgICAgICAgJ21pc3NpbmcgY29sb3IgYXR0YWNobWVudCBmb3IgZnJhbWVidWZmZXIgc2VudCB0byB1bmlmb3JtIFwiJyArIG5hbWUgKyAnXCInLCBlbnYuY29tbWFuZFN0cik7XHJcbiAgICAgICAgICByZXN1bHQgPSBjcmVhdGVTdGF0aWNEZWNsKGZ1bmN0aW9uIChlbnYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVudi5saW5rKHZhbHVlLmNvbG9yWzBdKVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNoZWNrJDEuY29tbWFuZFJhaXNlKCdpbnZhbGlkIGRhdGEgZm9yIHVuaWZvcm0gXCInICsgbmFtZSArICdcIicsIGVudi5jb21tYW5kU3RyKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheUxpa2UodmFsdWUpKSB7XHJcbiAgICAgICAgcmVzdWx0ID0gY3JlYXRlU3RhdGljRGVjbChmdW5jdGlvbiAoZW52KSB7XHJcbiAgICAgICAgICB2YXIgSVRFTSA9IGVudi5nbG9iYWwuZGVmKCdbJyxcclxuICAgICAgICAgICAgbG9vcCh2YWx1ZS5sZW5ndGgsIGZ1bmN0aW9uIChpKSB7XHJcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKFxyXG4gICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlW2ldID09PSAnbnVtYmVyJyB8fFxyXG4gICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlW2ldID09PSAnYm9vbGVhbicsXHJcbiAgICAgICAgICAgICAgICAnaW52YWxpZCB1bmlmb3JtICcgKyBuYW1lLCBlbnYuY29tbWFuZFN0cik7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlW2ldXHJcbiAgICAgICAgICAgIH0pLCAnXScpO1xyXG4gICAgICAgICAgcmV0dXJuIElURU1cclxuICAgICAgICB9KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjaGVjayQxLmNvbW1hbmRSYWlzZSgnaW52YWxpZCBvciBtaXNzaW5nIGRhdGEgZm9yIHVuaWZvcm0gXCInICsgbmFtZSArICdcIicsIGVudi5jb21tYW5kU3RyKTtcclxuICAgICAgfVxyXG4gICAgICByZXN1bHQudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgVU5JRk9STVNbbmFtZV0gPSByZXN1bHQ7XHJcbiAgICB9KTtcclxuXHJcbiAgICBPYmplY3Qua2V5cyhkeW5hbWljVW5pZm9ybXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICB2YXIgZHluID0gZHluYW1pY1VuaWZvcm1zW2tleV07XHJcbiAgICAgIFVOSUZPUk1TW2tleV0gPSBjcmVhdGVEeW5hbWljRGVjbChkeW4sIGZ1bmN0aW9uIChlbnYsIHNjb3BlKSB7XHJcbiAgICAgICAgcmV0dXJuIGVudi5pbnZva2Uoc2NvcGUsIGR5bilcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gVU5JRk9STVNcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHBhcnNlQXR0cmlidXRlcyAoYXR0cmlidXRlcywgZW52KSB7XHJcbiAgICB2YXIgc3RhdGljQXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMuc3RhdGljO1xyXG4gICAgdmFyIGR5bmFtaWNBdHRyaWJ1dGVzID0gYXR0cmlidXRlcy5keW5hbWljO1xyXG5cclxuICAgIHZhciBhdHRyaWJ1dGVEZWZzID0ge307XHJcblxyXG4gICAgT2JqZWN0LmtleXMoc3RhdGljQXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlKSB7XHJcbiAgICAgIHZhciB2YWx1ZSA9IHN0YXRpY0F0dHJpYnV0ZXNbYXR0cmlidXRlXTtcclxuICAgICAgdmFyIGlkID0gc3RyaW5nU3RvcmUuaWQoYXR0cmlidXRlKTtcclxuXHJcbiAgICAgIHZhciByZWNvcmQgPSBuZXcgQXR0cmlidXRlUmVjb3JkKCk7XHJcbiAgICAgIGlmIChpc0J1ZmZlckFyZ3ModmFsdWUpKSB7XHJcbiAgICAgICAgcmVjb3JkLnN0YXRlID0gQVRUUklCX1NUQVRFX1BPSU5URVI7XHJcbiAgICAgICAgcmVjb3JkLmJ1ZmZlciA9IGJ1ZmZlclN0YXRlLmdldEJ1ZmZlcihcclxuICAgICAgICAgIGJ1ZmZlclN0YXRlLmNyZWF0ZSh2YWx1ZSwgR0xfQVJSQVlfQlVGRkVSJDEsIGZhbHNlLCB0cnVlKSk7XHJcbiAgICAgICAgcmVjb3JkLnR5cGUgPSAwO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhciBidWZmZXIgPSBidWZmZXJTdGF0ZS5nZXRCdWZmZXIodmFsdWUpO1xyXG4gICAgICAgIGlmIChidWZmZXIpIHtcclxuICAgICAgICAgIHJlY29yZC5zdGF0ZSA9IEFUVFJJQl9TVEFURV9QT0lOVEVSO1xyXG4gICAgICAgICAgcmVjb3JkLmJ1ZmZlciA9IGJ1ZmZlcjtcclxuICAgICAgICAgIHJlY29yZC50eXBlID0gMDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY2hlY2skMS5jb21tYW5kKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUsXHJcbiAgICAgICAgICAgICdpbnZhbGlkIGRhdGEgZm9yIGF0dHJpYnV0ZSAnICsgYXR0cmlidXRlLCBlbnYuY29tbWFuZFN0cik7XHJcbiAgICAgICAgICBpZiAoJ2NvbnN0YW50JyBpbiB2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgY29uc3RhbnQgPSB2YWx1ZS5jb25zdGFudDtcclxuICAgICAgICAgICAgcmVjb3JkLmJ1ZmZlciA9ICdudWxsJztcclxuICAgICAgICAgICAgcmVjb3JkLnN0YXRlID0gQVRUUklCX1NUQVRFX0NPTlNUQU5UO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnN0YW50ID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgIHJlY29yZC54ID0gY29uc3RhbnQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKFxyXG4gICAgICAgICAgICAgICAgaXNBcnJheUxpa2UoY29uc3RhbnQpICYmXHJcbiAgICAgICAgICAgICAgICBjb25zdGFudC5sZW5ndGggPiAwICYmXHJcbiAgICAgICAgICAgICAgICBjb25zdGFudC5sZW5ndGggPD0gNCxcclxuICAgICAgICAgICAgICAgICdpbnZhbGlkIGNvbnN0YW50IGZvciBhdHRyaWJ1dGUgJyArIGF0dHJpYnV0ZSwgZW52LmNvbW1hbmRTdHIpO1xyXG4gICAgICAgICAgICAgIENVVEVfQ09NUE9ORU5UUy5mb3JFYWNoKGZ1bmN0aW9uIChjLCBpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA8IGNvbnN0YW50Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICByZWNvcmRbY10gPSBjb25zdGFudFtpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGlzQnVmZmVyQXJncyh2YWx1ZS5idWZmZXIpKSB7XHJcbiAgICAgICAgICAgICAgYnVmZmVyID0gYnVmZmVyU3RhdGUuZ2V0QnVmZmVyKFxyXG4gICAgICAgICAgICAgICAgYnVmZmVyU3RhdGUuY3JlYXRlKHZhbHVlLmJ1ZmZlciwgR0xfQVJSQVlfQlVGRkVSJDEsIGZhbHNlLCB0cnVlKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgYnVmZmVyID0gYnVmZmVyU3RhdGUuZ2V0QnVmZmVyKHZhbHVlLmJ1ZmZlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKCEhYnVmZmVyLCAnbWlzc2luZyBidWZmZXIgZm9yIGF0dHJpYnV0ZSBcIicgKyBhdHRyaWJ1dGUgKyAnXCInLCBlbnYuY29tbWFuZFN0cik7XHJcblxyXG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdmFsdWUub2Zmc2V0IHwgMDtcclxuICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKG9mZnNldCA+PSAwLFxyXG4gICAgICAgICAgICAgICdpbnZhbGlkIG9mZnNldCBmb3IgYXR0cmlidXRlIFwiJyArIGF0dHJpYnV0ZSArICdcIicsIGVudi5jb21tYW5kU3RyKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBzdHJpZGUgPSB2YWx1ZS5zdHJpZGUgfCAwO1xyXG4gICAgICAgICAgICBjaGVjayQxLmNvbW1hbmQoc3RyaWRlID49IDAgJiYgc3RyaWRlIDwgMjU2LFxyXG4gICAgICAgICAgICAgICdpbnZhbGlkIHN0cmlkZSBmb3IgYXR0cmlidXRlIFwiJyArIGF0dHJpYnV0ZSArICdcIiwgbXVzdCBiZSBpbnRlZ2VyIGJldHdlZWVuIFswLCAyNTVdJywgZW52LmNvbW1hbmRTdHIpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHNpemUgPSB2YWx1ZS5zaXplIHwgMDtcclxuICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKCEoJ3NpemUnIGluIHZhbHVlKSB8fCAoc2l6ZSA+IDAgJiYgc2l6ZSA8PSA0KSxcclxuICAgICAgICAgICAgICAnaW52YWxpZCBzaXplIGZvciBhdHRyaWJ1dGUgXCInICsgYXR0cmlidXRlICsgJ1wiLCBtdXN0IGJlIDEsMiwzLDQnLCBlbnYuY29tbWFuZFN0cik7XHJcblxyXG4gICAgICAgICAgICB2YXIgbm9ybWFsaXplZCA9ICEhdmFsdWUubm9ybWFsaXplZDtcclxuXHJcbiAgICAgICAgICAgIHZhciB0eXBlID0gMDtcclxuICAgICAgICAgICAgaWYgKCd0eXBlJyBpbiB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZFBhcmFtZXRlcihcclxuICAgICAgICAgICAgICAgIHZhbHVlLnR5cGUsIGdsVHlwZXMsXHJcbiAgICAgICAgICAgICAgICAnaW52YWxpZCB0eXBlIGZvciBhdHRyaWJ1dGUgJyArIGF0dHJpYnV0ZSwgZW52LmNvbW1hbmRTdHIpO1xyXG4gICAgICAgICAgICAgIHR5cGUgPSBnbFR5cGVzW3ZhbHVlLnR5cGVdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgZGl2aXNvciA9IHZhbHVlLmRpdmlzb3IgfCAwO1xyXG4gICAgICAgICAgICBpZiAoJ2Rpdmlzb3InIGluIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKGRpdmlzb3IgPT09IDAgfHwgZXh0SW5zdGFuY2luZyxcclxuICAgICAgICAgICAgICAgICdjYW5ub3Qgc3BlY2lmeSBkaXZpc29yIGZvciBhdHRyaWJ1dGUgXCInICsgYXR0cmlidXRlICsgJ1wiLCBpbnN0YW5jaW5nIG5vdCBzdXBwb3J0ZWQnLCBlbnYuY29tbWFuZFN0cik7XHJcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKGRpdmlzb3IgPj0gMCxcclxuICAgICAgICAgICAgICAgICdpbnZhbGlkIGRpdmlzb3IgZm9yIGF0dHJpYnV0ZSBcIicgKyBhdHRyaWJ1dGUgKyAnXCInLCBlbnYuY29tbWFuZFN0cik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgIHZhciBjb21tYW5kID0gZW52LmNvbW1hbmRTdHI7XHJcblxyXG4gICAgICAgICAgICAgIHZhciBWQUxJRF9LRVlTID0gW1xyXG4gICAgICAgICAgICAgICAgJ2J1ZmZlcicsXHJcbiAgICAgICAgICAgICAgICAnb2Zmc2V0JyxcclxuICAgICAgICAgICAgICAgICdkaXZpc29yJyxcclxuICAgICAgICAgICAgICAgICdub3JtYWxpemVkJyxcclxuICAgICAgICAgICAgICAgICd0eXBlJyxcclxuICAgICAgICAgICAgICAgICdzaXplJyxcclxuICAgICAgICAgICAgICAgICdzdHJpZGUnXHJcbiAgICAgICAgICAgICAgXTtcclxuXHJcbiAgICAgICAgICAgICAgT2JqZWN0LmtleXModmFsdWUpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcclxuICAgICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZChcclxuICAgICAgICAgICAgICAgICAgVkFMSURfS0VZUy5pbmRleE9mKHByb3ApID49IDAsXHJcbiAgICAgICAgICAgICAgICAgICd1bmtub3duIHBhcmFtZXRlciBcIicgKyBwcm9wICsgJ1wiIGZvciBhdHRyaWJ1dGUgcG9pbnRlciBcIicgKyBhdHRyaWJ1dGUgKyAnXCIgKHZhbGlkIHBhcmFtZXRlcnMgYXJlICcgKyBWQUxJRF9LRVlTICsgJyknLFxyXG4gICAgICAgICAgICAgICAgICBjb21tYW5kKTtcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZWNvcmQuYnVmZmVyID0gYnVmZmVyO1xyXG4gICAgICAgICAgICByZWNvcmQuc3RhdGUgPSBBVFRSSUJfU1RBVEVfUE9JTlRFUjtcclxuICAgICAgICAgICAgcmVjb3JkLnNpemUgPSBzaXplO1xyXG4gICAgICAgICAgICByZWNvcmQubm9ybWFsaXplZCA9IG5vcm1hbGl6ZWQ7XHJcbiAgICAgICAgICAgIHJlY29yZC50eXBlID0gdHlwZSB8fCBidWZmZXIuZHR5cGU7XHJcbiAgICAgICAgICAgIHJlY29yZC5vZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgIHJlY29yZC5zdHJpZGUgPSBzdHJpZGU7XHJcbiAgICAgICAgICAgIHJlY29yZC5kaXZpc29yID0gZGl2aXNvcjtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGF0dHJpYnV0ZURlZnNbYXR0cmlidXRlXSA9IGNyZWF0ZVN0YXRpY0RlY2woZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcclxuICAgICAgICB2YXIgY2FjaGUgPSBlbnYuYXR0cmliQ2FjaGU7XHJcbiAgICAgICAgaWYgKGlkIGluIGNhY2hlKSB7XHJcbiAgICAgICAgICByZXR1cm4gY2FjaGVbaWRdXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZXN1bHQgPSB7XHJcbiAgICAgICAgICBpc1N0cmVhbTogZmFsc2VcclxuICAgICAgICB9O1xyXG4gICAgICAgIE9iamVjdC5rZXlzKHJlY29yZCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHJlY29yZFtrZXldO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChyZWNvcmQuYnVmZmVyKSB7XHJcbiAgICAgICAgICByZXN1bHQuYnVmZmVyID0gZW52LmxpbmsocmVjb3JkLmJ1ZmZlcik7XHJcbiAgICAgICAgICByZXN1bHQudHlwZSA9IHJlc3VsdC50eXBlIHx8IChyZXN1bHQuYnVmZmVyICsgJy5kdHlwZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYWNoZVtpZF0gPSByZXN1bHQ7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIE9iamVjdC5rZXlzKGR5bmFtaWNBdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcclxuICAgICAgdmFyIGR5biA9IGR5bmFtaWNBdHRyaWJ1dGVzW2F0dHJpYnV0ZV07XHJcblxyXG4gICAgICBmdW5jdGlvbiBhcHBlbmRBdHRyaWJ1dGVDb2RlIChlbnYsIGJsb2NrKSB7XHJcbiAgICAgICAgdmFyIFZBTFVFID0gZW52Lmludm9rZShibG9jaywgZHluKTtcclxuXHJcbiAgICAgICAgdmFyIHNoYXJlZCA9IGVudi5zaGFyZWQ7XHJcblxyXG4gICAgICAgIHZhciBJU19CVUZGRVJfQVJHUyA9IHNoYXJlZC5pc0J1ZmZlckFyZ3M7XHJcbiAgICAgICAgdmFyIEJVRkZFUl9TVEFURSA9IHNoYXJlZC5idWZmZXI7XHJcblxyXG4gICAgICAgIC8vIFBlcmZvcm0gdmFsaWRhdGlvbiBvbiBhdHRyaWJ1dGVcclxuICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIGVudi5hc3NlcnQoYmxvY2ssXHJcbiAgICAgICAgICAgIFZBTFVFICsgJyYmKHR5cGVvZiAnICsgVkFMVUUgKyAnPT09XCJvYmplY3RcInx8dHlwZW9mICcgK1xyXG4gICAgICAgICAgICBWQUxVRSArICc9PT1cImZ1bmN0aW9uXCIpJiYoJyArXHJcbiAgICAgICAgICAgIElTX0JVRkZFUl9BUkdTICsgJygnICsgVkFMVUUgKyAnKXx8JyArXHJcbiAgICAgICAgICAgIEJVRkZFUl9TVEFURSArICcuZ2V0QnVmZmVyKCcgKyBWQUxVRSArICcpfHwnICtcclxuICAgICAgICAgICAgQlVGRkVSX1NUQVRFICsgJy5nZXRCdWZmZXIoJyArIFZBTFVFICsgJy5idWZmZXIpfHwnICtcclxuICAgICAgICAgICAgSVNfQlVGRkVSX0FSR1MgKyAnKCcgKyBWQUxVRSArICcuYnVmZmVyKXx8JyArXHJcbiAgICAgICAgICAgICcoXCJjb25zdGFudFwiIGluICcgKyBWQUxVRSArXHJcbiAgICAgICAgICAgICcmJih0eXBlb2YgJyArIFZBTFVFICsgJy5jb25zdGFudD09PVwibnVtYmVyXCJ8fCcgK1xyXG4gICAgICAgICAgICBzaGFyZWQuaXNBcnJheUxpa2UgKyAnKCcgKyBWQUxVRSArICcuY29uc3RhbnQpKSkpJyxcclxuICAgICAgICAgICAgJ2ludmFsaWQgZHluYW1pYyBhdHRyaWJ1dGUgXCInICsgYXR0cmlidXRlICsgJ1wiJyk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIGFsbG9jYXRlIG5hbWVzIGZvciByZXN1bHRcclxuICAgICAgICB2YXIgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgaXNTdHJlYW06IGJsb2NrLmRlZihmYWxzZSlcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBkZWZhdWx0UmVjb3JkID0gbmV3IEF0dHJpYnV0ZVJlY29yZCgpO1xyXG4gICAgICAgIGRlZmF1bHRSZWNvcmQuc3RhdGUgPSBBVFRSSUJfU1RBVEVfUE9JTlRFUjtcclxuICAgICAgICBPYmplY3Qua2V5cyhkZWZhdWx0UmVjb3JkKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgIHJlc3VsdFtrZXldID0gYmxvY2suZGVmKCcnICsgZGVmYXVsdFJlY29yZFtrZXldKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdmFyIEJVRkZFUiA9IHJlc3VsdC5idWZmZXI7XHJcbiAgICAgICAgdmFyIFRZUEUgPSByZXN1bHQudHlwZTtcclxuICAgICAgICBibG9jayhcclxuICAgICAgICAgICdpZignLCBJU19CVUZGRVJfQVJHUywgJygnLCBWQUxVRSwgJykpeycsXHJcbiAgICAgICAgICByZXN1bHQuaXNTdHJlYW0sICc9dHJ1ZTsnLFxyXG4gICAgICAgICAgQlVGRkVSLCAnPScsIEJVRkZFUl9TVEFURSwgJy5jcmVhdGVTdHJlYW0oJywgR0xfQVJSQVlfQlVGRkVSJDEsICcsJywgVkFMVUUsICcpOycsXHJcbiAgICAgICAgICBUWVBFLCAnPScsIEJVRkZFUiwgJy5kdHlwZTsnLFxyXG4gICAgICAgICAgJ31lbHNleycsXHJcbiAgICAgICAgICBCVUZGRVIsICc9JywgQlVGRkVSX1NUQVRFLCAnLmdldEJ1ZmZlcignLCBWQUxVRSwgJyk7JyxcclxuICAgICAgICAgICdpZignLCBCVUZGRVIsICcpeycsXHJcbiAgICAgICAgICBUWVBFLCAnPScsIEJVRkZFUiwgJy5kdHlwZTsnLFxyXG4gICAgICAgICAgJ31lbHNlIGlmKFwiY29uc3RhbnRcIiBpbiAnLCBWQUxVRSwgJyl7JyxcclxuICAgICAgICAgIHJlc3VsdC5zdGF0ZSwgJz0nLCBBVFRSSUJfU1RBVEVfQ09OU1RBTlQsICc7JyxcclxuICAgICAgICAgICdpZih0eXBlb2YgJyArIFZBTFVFICsgJy5jb25zdGFudCA9PT0gXCJudW1iZXJcIil7JyxcclxuICAgICAgICAgIHJlc3VsdFtDVVRFX0NPTVBPTkVOVFNbMF1dLCAnPScsIFZBTFVFLCAnLmNvbnN0YW50OycsXHJcbiAgICAgICAgICBDVVRFX0NPTVBPTkVOVFMuc2xpY2UoMSkubWFwKGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRbbl1cclxuICAgICAgICAgIH0pLmpvaW4oJz0nKSwgJz0wOycsXHJcbiAgICAgICAgICAnfWVsc2V7JyxcclxuICAgICAgICAgIENVVEVfQ09NUE9ORU5UUy5tYXAoZnVuY3Rpb24gKG5hbWUsIGkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgICByZXN1bHRbbmFtZV0gKyAnPScgKyBWQUxVRSArICcuY29uc3RhbnQubGVuZ3RoPicgKyBpICtcclxuICAgICAgICAgICAgICAnPycgKyBWQUxVRSArICcuY29uc3RhbnRbJyArIGkgKyAnXTowOydcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgICAgfSkuam9pbignJyksXHJcbiAgICAgICAgICAnfX1lbHNleycsXHJcbiAgICAgICAgICAnaWYoJywgSVNfQlVGRkVSX0FSR1MsICcoJywgVkFMVUUsICcuYnVmZmVyKSl7JyxcclxuICAgICAgICAgIEJVRkZFUiwgJz0nLCBCVUZGRVJfU1RBVEUsICcuY3JlYXRlU3RyZWFtKCcsIEdMX0FSUkFZX0JVRkZFUiQxLCAnLCcsIFZBTFVFLCAnLmJ1ZmZlcik7JyxcclxuICAgICAgICAgICd9ZWxzZXsnLFxyXG4gICAgICAgICAgQlVGRkVSLCAnPScsIEJVRkZFUl9TVEFURSwgJy5nZXRCdWZmZXIoJywgVkFMVUUsICcuYnVmZmVyKTsnLFxyXG4gICAgICAgICAgJ30nLFxyXG4gICAgICAgICAgVFlQRSwgJz1cInR5cGVcIiBpbiAnLCBWQUxVRSwgJz8nLFxyXG4gICAgICAgICAgc2hhcmVkLmdsVHlwZXMsICdbJywgVkFMVUUsICcudHlwZV06JywgQlVGRkVSLCAnLmR0eXBlOycsXHJcbiAgICAgICAgICByZXN1bHQubm9ybWFsaXplZCwgJz0hIScsIFZBTFVFLCAnLm5vcm1hbGl6ZWQ7Jyk7XHJcbiAgICAgICAgZnVuY3Rpb24gZW1pdFJlYWRSZWNvcmQgKG5hbWUpIHtcclxuICAgICAgICAgIGJsb2NrKHJlc3VsdFtuYW1lXSwgJz0nLCBWQUxVRSwgJy4nLCBuYW1lLCAnfDA7Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVtaXRSZWFkUmVjb3JkKCdzaXplJyk7XHJcbiAgICAgICAgZW1pdFJlYWRSZWNvcmQoJ29mZnNldCcpO1xyXG4gICAgICAgIGVtaXRSZWFkUmVjb3JkKCdzdHJpZGUnKTtcclxuICAgICAgICBlbWl0UmVhZFJlY29yZCgnZGl2aXNvcicpO1xyXG5cclxuICAgICAgICBibG9jaygnfX0nKTtcclxuXHJcbiAgICAgICAgYmxvY2suZXhpdChcclxuICAgICAgICAgICdpZignLCByZXN1bHQuaXNTdHJlYW0sICcpeycsXHJcbiAgICAgICAgICBCVUZGRVJfU1RBVEUsICcuZGVzdHJveVN0cmVhbSgnLCBCVUZGRVIsICcpOycsXHJcbiAgICAgICAgICAnfScpO1xyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGF0dHJpYnV0ZURlZnNbYXR0cmlidXRlXSA9IGNyZWF0ZUR5bmFtaWNEZWNsKGR5biwgYXBwZW5kQXR0cmlidXRlQ29kZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gYXR0cmlidXRlRGVmc1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcGFyc2VDb250ZXh0IChjb250ZXh0KSB7XHJcbiAgICB2YXIgc3RhdGljQ29udGV4dCA9IGNvbnRleHQuc3RhdGljO1xyXG4gICAgdmFyIGR5bmFtaWNDb250ZXh0ID0gY29udGV4dC5keW5hbWljO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG5cclxuICAgIE9iamVjdC5rZXlzKHN0YXRpY0NvbnRleHQpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgdmFyIHZhbHVlID0gc3RhdGljQ29udGV4dFtuYW1lXTtcclxuICAgICAgcmVzdWx0W25hbWVdID0gY3JlYXRlU3RhdGljRGVjbChmdW5jdGlvbiAoZW52LCBzY29wZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgICByZXR1cm4gJycgKyB2YWx1ZVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXR1cm4gZW52LmxpbmsodmFsdWUpXHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIE9iamVjdC5rZXlzKGR5bmFtaWNDb250ZXh0KS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgIHZhciBkeW4gPSBkeW5hbWljQ29udGV4dFtuYW1lXTtcclxuICAgICAgcmVzdWx0W25hbWVdID0gY3JlYXRlRHluYW1pY0RlY2woZHluLCBmdW5jdGlvbiAoZW52LCBzY29wZSkge1xyXG4gICAgICAgIHJldHVybiBlbnYuaW52b2tlKHNjb3BlLCBkeW4pXHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdFxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcGFyc2VBcmd1bWVudHMgKG9wdGlvbnMsIGF0dHJpYnV0ZXMsIHVuaWZvcm1zLCBjb250ZXh0LCBlbnYpIHtcclxuICAgIHZhciBzdGF0aWNPcHRpb25zID0gb3B0aW9ucy5zdGF0aWM7XHJcbiAgICB2YXIgZHluYW1pY09wdGlvbnMgPSBvcHRpb25zLmR5bmFtaWM7XHJcblxyXG4gICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBLRVlfTkFNRVMgPSBbXHJcbiAgICAgICAgU19GUkFNRUJVRkZFUixcclxuICAgICAgICBTX1ZFUlQsXHJcbiAgICAgICAgU19GUkFHLFxyXG4gICAgICAgIFNfRUxFTUVOVFMsXHJcbiAgICAgICAgU19QUklNSVRJVkUsXHJcbiAgICAgICAgU19PRkZTRVQsXHJcbiAgICAgICAgU19DT1VOVCxcclxuICAgICAgICBTX0lOU1RBTkNFUyxcclxuICAgICAgICBTX1BST0ZJTEVcclxuICAgICAgXS5jb25jYXQoR0xfU1RBVEVfTkFNRVMpO1xyXG5cclxuICAgICAgZnVuY3Rpb24gY2hlY2tLZXlzIChkaWN0KSB7XHJcbiAgICAgICAgT2JqZWN0LmtleXMoZGljdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICBjaGVjayQxLmNvbW1hbmQoXHJcbiAgICAgICAgICAgIEtFWV9OQU1FUy5pbmRleE9mKGtleSkgPj0gMCxcclxuICAgICAgICAgICAgJ3Vua25vd24gcGFyYW1ldGVyIFwiJyArIGtleSArICdcIicsXHJcbiAgICAgICAgICAgIGVudi5jb21tYW5kU3RyKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY2hlY2tLZXlzKHN0YXRpY09wdGlvbnMpO1xyXG4gICAgICBjaGVja0tleXMoZHluYW1pY09wdGlvbnMpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdmFyIGZyYW1lYnVmZmVyID0gcGFyc2VGcmFtZWJ1ZmZlcihvcHRpb25zLCBlbnYpO1xyXG4gICAgdmFyIHZpZXdwb3J0QW5kU2Npc3NvciA9IHBhcnNlVmlld3BvcnRTY2lzc29yKG9wdGlvbnMsIGZyYW1lYnVmZmVyLCBlbnYpO1xyXG4gICAgdmFyIGRyYXcgPSBwYXJzZURyYXcob3B0aW9ucywgZW52KTtcclxuICAgIHZhciBzdGF0ZSA9IHBhcnNlR0xTdGF0ZShvcHRpb25zLCBlbnYpO1xyXG4gICAgdmFyIHNoYWRlciA9IHBhcnNlUHJvZ3JhbShvcHRpb25zLCBlbnYpO1xyXG5cclxuICAgIGZ1bmN0aW9uIGNvcHlCb3ggKG5hbWUpIHtcclxuICAgICAgdmFyIGRlZm4gPSB2aWV3cG9ydEFuZFNjaXNzb3JbbmFtZV07XHJcbiAgICAgIGlmIChkZWZuKSB7XHJcbiAgICAgICAgc3RhdGVbbmFtZV0gPSBkZWZuO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBjb3B5Qm94KFNfVklFV1BPUlQpO1xyXG4gICAgY29weUJveChwcm9wTmFtZShTX1NDSVNTT1JfQk9YKSk7XHJcblxyXG4gICAgdmFyIGRpcnR5ID0gT2JqZWN0LmtleXMoc3RhdGUpLmxlbmd0aCA+IDA7XHJcblxyXG4gICAgdmFyIHJlc3VsdCA9IHtcclxuICAgICAgZnJhbWVidWZmZXI6IGZyYW1lYnVmZmVyLFxyXG4gICAgICBkcmF3OiBkcmF3LFxyXG4gICAgICBzaGFkZXI6IHNoYWRlcixcclxuICAgICAgc3RhdGU6IHN0YXRlLFxyXG4gICAgICBkaXJ0eTogZGlydHlcclxuICAgIH07XHJcblxyXG4gICAgcmVzdWx0LnByb2ZpbGUgPSBwYXJzZVByb2ZpbGUob3B0aW9ucywgZW52KTtcclxuICAgIHJlc3VsdC51bmlmb3JtcyA9IHBhcnNlVW5pZm9ybXModW5pZm9ybXMsIGVudik7XHJcbiAgICByZXN1bHQuYXR0cmlidXRlcyA9IHBhcnNlQXR0cmlidXRlcyhhdHRyaWJ1dGVzLCBlbnYpO1xyXG4gICAgcmVzdWx0LmNvbnRleHQgPSBwYXJzZUNvbnRleHQoY29udGV4dCwgZW52KTtcclxuICAgIHJldHVybiByZXN1bHRcclxuICB9XHJcblxyXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gIC8vIENPTU1PTiBVUERBVEUgRlVOQ1RJT05TXHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgZnVuY3Rpb24gZW1pdENvbnRleHQgKGVudiwgc2NvcGUsIGNvbnRleHQpIHtcclxuICAgIHZhciBzaGFyZWQgPSBlbnYuc2hhcmVkO1xyXG4gICAgdmFyIENPTlRFWFQgPSBzaGFyZWQuY29udGV4dDtcclxuXHJcbiAgICB2YXIgY29udGV4dEVudGVyID0gZW52LnNjb3BlKCk7XHJcblxyXG4gICAgT2JqZWN0LmtleXMoY29udGV4dCkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICBzY29wZS5zYXZlKENPTlRFWFQsICcuJyArIG5hbWUpO1xyXG4gICAgICB2YXIgZGVmbiA9IGNvbnRleHRbbmFtZV07XHJcbiAgICAgIGNvbnRleHRFbnRlcihDT05URVhULCAnLicsIG5hbWUsICc9JywgZGVmbi5hcHBlbmQoZW52LCBzY29wZSksICc7Jyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBzY29wZShjb250ZXh0RW50ZXIpO1xyXG4gIH1cclxuXHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgLy8gQ09NTU9OIERSQVdJTkcgRlVOQ1RJT05TXHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgZnVuY3Rpb24gZW1pdFBvbGxGcmFtZWJ1ZmZlciAoZW52LCBzY29wZSwgZnJhbWVidWZmZXIsIHNraXBDaGVjaykge1xyXG4gICAgdmFyIHNoYXJlZCA9IGVudi5zaGFyZWQ7XHJcblxyXG4gICAgdmFyIEdMID0gc2hhcmVkLmdsO1xyXG4gICAgdmFyIEZSQU1FQlVGRkVSX1NUQVRFID0gc2hhcmVkLmZyYW1lYnVmZmVyO1xyXG4gICAgdmFyIEVYVF9EUkFXX0JVRkZFUlM7XHJcbiAgICBpZiAoZXh0RHJhd0J1ZmZlcnMpIHtcclxuICAgICAgRVhUX0RSQVdfQlVGRkVSUyA9IHNjb3BlLmRlZihzaGFyZWQuZXh0ZW5zaW9ucywgJy53ZWJnbF9kcmF3X2J1ZmZlcnMnKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgY29uc3RhbnRzID0gZW52LmNvbnN0YW50cztcclxuXHJcbiAgICB2YXIgRFJBV19CVUZGRVJTID0gY29uc3RhbnRzLmRyYXdCdWZmZXI7XHJcbiAgICB2YXIgQkFDS19CVUZGRVIgPSBjb25zdGFudHMuYmFja0J1ZmZlcjtcclxuXHJcbiAgICB2YXIgTkVYVDtcclxuICAgIGlmIChmcmFtZWJ1ZmZlcikge1xyXG4gICAgICBORVhUID0gZnJhbWVidWZmZXIuYXBwZW5kKGVudiwgc2NvcGUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgTkVYVCA9IHNjb3BlLmRlZihGUkFNRUJVRkZFUl9TVEFURSwgJy5uZXh0Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFza2lwQ2hlY2spIHtcclxuICAgICAgc2NvcGUoJ2lmKCcsIE5FWFQsICchPT0nLCBGUkFNRUJVRkZFUl9TVEFURSwgJy5jdXIpeycpO1xyXG4gICAgfVxyXG4gICAgc2NvcGUoXHJcbiAgICAgICdpZignLCBORVhULCAnKXsnLFxyXG4gICAgICBHTCwgJy5iaW5kRnJhbWVidWZmZXIoJywgR0xfRlJBTUVCVUZGRVIkMiwgJywnLCBORVhULCAnLmZyYW1lYnVmZmVyKTsnKTtcclxuICAgIGlmIChleHREcmF3QnVmZmVycykge1xyXG4gICAgICBzY29wZShFWFRfRFJBV19CVUZGRVJTLCAnLmRyYXdCdWZmZXJzV0VCR0woJyxcclxuICAgICAgICBEUkFXX0JVRkZFUlMsICdbJywgTkVYVCwgJy5jb2xvckF0dGFjaG1lbnRzLmxlbmd0aF0pOycpO1xyXG4gICAgfVxyXG4gICAgc2NvcGUoJ31lbHNleycsXHJcbiAgICAgIEdMLCAnLmJpbmRGcmFtZWJ1ZmZlcignLCBHTF9GUkFNRUJVRkZFUiQyLCAnLG51bGwpOycpO1xyXG4gICAgaWYgKGV4dERyYXdCdWZmZXJzKSB7XHJcbiAgICAgIHNjb3BlKEVYVF9EUkFXX0JVRkZFUlMsICcuZHJhd0J1ZmZlcnNXRUJHTCgnLCBCQUNLX0JVRkZFUiwgJyk7Jyk7XHJcbiAgICB9XHJcbiAgICBzY29wZShcclxuICAgICAgJ30nLFxyXG4gICAgICBGUkFNRUJVRkZFUl9TVEFURSwgJy5jdXI9JywgTkVYVCwgJzsnKTtcclxuICAgIGlmICghc2tpcENoZWNrKSB7XHJcbiAgICAgIHNjb3BlKCd9Jyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBlbWl0UG9sbFN0YXRlIChlbnYsIHNjb3BlLCBhcmdzKSB7XHJcbiAgICB2YXIgc2hhcmVkID0gZW52LnNoYXJlZDtcclxuXHJcbiAgICB2YXIgR0wgPSBzaGFyZWQuZ2w7XHJcblxyXG4gICAgdmFyIENVUlJFTlRfVkFSUyA9IGVudi5jdXJyZW50O1xyXG4gICAgdmFyIE5FWFRfVkFSUyA9IGVudi5uZXh0O1xyXG4gICAgdmFyIENVUlJFTlRfU1RBVEUgPSBzaGFyZWQuY3VycmVudDtcclxuICAgIHZhciBORVhUX1NUQVRFID0gc2hhcmVkLm5leHQ7XHJcblxyXG4gICAgdmFyIGJsb2NrID0gZW52LmNvbmQoQ1VSUkVOVF9TVEFURSwgJy5kaXJ0eScpO1xyXG5cclxuICAgIEdMX1NUQVRFX05BTUVTLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcclxuICAgICAgdmFyIHBhcmFtID0gcHJvcE5hbWUocHJvcCk7XHJcbiAgICAgIGlmIChwYXJhbSBpbiBhcmdzLnN0YXRlKSB7XHJcbiAgICAgICAgcmV0dXJuXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBORVhULCBDVVJSRU5UO1xyXG4gICAgICBpZiAocGFyYW0gaW4gTkVYVF9WQVJTKSB7XHJcbiAgICAgICAgTkVYVCA9IE5FWFRfVkFSU1twYXJhbV07XHJcbiAgICAgICAgQ1VSUkVOVCA9IENVUlJFTlRfVkFSU1twYXJhbV07XHJcbiAgICAgICAgdmFyIHBhcnRzID0gbG9vcChjdXJyZW50U3RhdGVbcGFyYW1dLmxlbmd0aCwgZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICAgIHJldHVybiBibG9jay5kZWYoTkVYVCwgJ1snLCBpLCAnXScpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYmxvY2soZW52LmNvbmQocGFydHMubWFwKGZ1bmN0aW9uIChwLCBpKSB7XHJcbiAgICAgICAgICByZXR1cm4gcCArICchPT0nICsgQ1VSUkVOVCArICdbJyArIGkgKyAnXSdcclxuICAgICAgICB9KS5qb2luKCd8fCcpKVxyXG4gICAgICAgICAgLnRoZW4oXHJcbiAgICAgICAgICAgIEdMLCAnLicsIEdMX1ZBUklBQkxFU1twYXJhbV0sICcoJywgcGFydHMsICcpOycsXHJcbiAgICAgICAgICAgIHBhcnRzLm1hcChmdW5jdGlvbiAocCwgaSkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBDVVJSRU5UICsgJ1snICsgaSArICddPScgKyBwXHJcbiAgICAgICAgICAgIH0pLmpvaW4oJzsnKSwgJzsnKSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgTkVYVCA9IGJsb2NrLmRlZihORVhUX1NUQVRFLCAnLicsIHBhcmFtKTtcclxuICAgICAgICB2YXIgaWZ0ZSA9IGVudi5jb25kKE5FWFQsICchPT0nLCBDVVJSRU5UX1NUQVRFLCAnLicsIHBhcmFtKTtcclxuICAgICAgICBibG9jayhpZnRlKTtcclxuICAgICAgICBpZiAocGFyYW0gaW4gR0xfRkxBR1MpIHtcclxuICAgICAgICAgIGlmdGUoXHJcbiAgICAgICAgICAgIGVudi5jb25kKE5FWFQpXHJcbiAgICAgICAgICAgICAgICAudGhlbihHTCwgJy5lbmFibGUoJywgR0xfRkxBR1NbcGFyYW1dLCAnKTsnKVxyXG4gICAgICAgICAgICAgICAgLmVsc2UoR0wsICcuZGlzYWJsZSgnLCBHTF9GTEFHU1twYXJhbV0sICcpOycpLFxyXG4gICAgICAgICAgICBDVVJSRU5UX1NUQVRFLCAnLicsIHBhcmFtLCAnPScsIE5FWFQsICc7Jyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGlmdGUoXHJcbiAgICAgICAgICAgIEdMLCAnLicsIEdMX1ZBUklBQkxFU1twYXJhbV0sICcoJywgTkVYVCwgJyk7JyxcclxuICAgICAgICAgICAgQ1VSUkVOVF9TVEFURSwgJy4nLCBwYXJhbSwgJz0nLCBORVhULCAnOycpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBpZiAoT2JqZWN0LmtleXMoYXJncy5zdGF0ZSkubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIGJsb2NrKENVUlJFTlRfU1RBVEUsICcuZGlydHk9ZmFsc2U7Jyk7XHJcbiAgICB9XHJcbiAgICBzY29wZShibG9jayk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBlbWl0U2V0T3B0aW9ucyAoZW52LCBzY29wZSwgb3B0aW9ucywgZmlsdGVyKSB7XHJcbiAgICB2YXIgc2hhcmVkID0gZW52LnNoYXJlZDtcclxuICAgIHZhciBDVVJSRU5UX1ZBUlMgPSBlbnYuY3VycmVudDtcclxuICAgIHZhciBDVVJSRU5UX1NUQVRFID0gc2hhcmVkLmN1cnJlbnQ7XHJcbiAgICB2YXIgR0wgPSBzaGFyZWQuZ2w7XHJcbiAgICBzb3J0U3RhdGUoT2JqZWN0LmtleXMob3B0aW9ucykpLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKSB7XHJcbiAgICAgIHZhciBkZWZuID0gb3B0aW9uc1twYXJhbV07XHJcbiAgICAgIGlmIChmaWx0ZXIgJiYgIWZpbHRlcihkZWZuKSkge1xyXG4gICAgICAgIHJldHVyblxyXG4gICAgICB9XHJcbiAgICAgIHZhciB2YXJpYWJsZSA9IGRlZm4uYXBwZW5kKGVudiwgc2NvcGUpO1xyXG4gICAgICBpZiAoR0xfRkxBR1NbcGFyYW1dKSB7XHJcbiAgICAgICAgdmFyIGZsYWcgPSBHTF9GTEFHU1twYXJhbV07XHJcbiAgICAgICAgaWYgKGlzU3RhdGljKGRlZm4pKSB7XHJcbiAgICAgICAgICBpZiAodmFyaWFibGUpIHtcclxuICAgICAgICAgICAgc2NvcGUoR0wsICcuZW5hYmxlKCcsIGZsYWcsICcpOycpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc2NvcGUoR0wsICcuZGlzYWJsZSgnLCBmbGFnLCAnKTsnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgc2NvcGUoZW52LmNvbmQodmFyaWFibGUpXHJcbiAgICAgICAgICAgIC50aGVuKEdMLCAnLmVuYWJsZSgnLCBmbGFnLCAnKTsnKVxyXG4gICAgICAgICAgICAuZWxzZShHTCwgJy5kaXNhYmxlKCcsIGZsYWcsICcpOycpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2NvcGUoQ1VSUkVOVF9TVEFURSwgJy4nLCBwYXJhbSwgJz0nLCB2YXJpYWJsZSwgJzsnKTtcclxuICAgICAgfSBlbHNlIGlmIChpc0FycmF5TGlrZSh2YXJpYWJsZSkpIHtcclxuICAgICAgICB2YXIgQ1VSUkVOVCA9IENVUlJFTlRfVkFSU1twYXJhbV07XHJcbiAgICAgICAgc2NvcGUoXHJcbiAgICAgICAgICBHTCwgJy4nLCBHTF9WQVJJQUJMRVNbcGFyYW1dLCAnKCcsIHZhcmlhYmxlLCAnKTsnLFxyXG4gICAgICAgICAgdmFyaWFibGUubWFwKGZ1bmN0aW9uICh2LCBpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBDVVJSRU5UICsgJ1snICsgaSArICddPScgKyB2XHJcbiAgICAgICAgICB9KS5qb2luKCc7JyksICc7Jyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc2NvcGUoXHJcbiAgICAgICAgICBHTCwgJy4nLCBHTF9WQVJJQUJMRVNbcGFyYW1dLCAnKCcsIHZhcmlhYmxlLCAnKTsnLFxyXG4gICAgICAgICAgQ1VSUkVOVF9TVEFURSwgJy4nLCBwYXJhbSwgJz0nLCB2YXJpYWJsZSwgJzsnKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBpbmplY3RFeHRlbnNpb25zIChlbnYsIHNjb3BlKSB7XHJcbiAgICBpZiAoZXh0SW5zdGFuY2luZykge1xyXG4gICAgICBlbnYuaW5zdGFuY2luZyA9IHNjb3BlLmRlZihcclxuICAgICAgICBlbnYuc2hhcmVkLmV4dGVuc2lvbnMsICcuYW5nbGVfaW5zdGFuY2VkX2FycmF5cycpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZW1pdFByb2ZpbGUgKGVudiwgc2NvcGUsIGFyZ3MsIHVzZVNjb3BlLCBpbmNyZW1lbnRDb3VudGVyKSB7XHJcbiAgICB2YXIgc2hhcmVkID0gZW52LnNoYXJlZDtcclxuICAgIHZhciBTVEFUUyA9IGVudi5zdGF0cztcclxuICAgIHZhciBDVVJSRU5UX1NUQVRFID0gc2hhcmVkLmN1cnJlbnQ7XHJcbiAgICB2YXIgVElNRVIgPSBzaGFyZWQudGltZXI7XHJcbiAgICB2YXIgcHJvZmlsZUFyZyA9IGFyZ3MucHJvZmlsZTtcclxuXHJcbiAgICBmdW5jdGlvbiBwZXJmQ291bnRlciAoKSB7XHJcbiAgICAgIGlmICh0eXBlb2YgcGVyZm9ybWFuY2UgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuICdEYXRlLm5vdygpJ1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAncGVyZm9ybWFuY2Uubm93KCknXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgQ1BVX1NUQVJULCBRVUVSWV9DT1VOVEVSO1xyXG4gICAgZnVuY3Rpb24gZW1pdFByb2ZpbGVTdGFydCAoYmxvY2spIHtcclxuICAgICAgQ1BVX1NUQVJUID0gc2NvcGUuZGVmKCk7XHJcbiAgICAgIGJsb2NrKENQVV9TVEFSVCwgJz0nLCBwZXJmQ291bnRlcigpLCAnOycpO1xyXG4gICAgICBpZiAodHlwZW9mIGluY3JlbWVudENvdW50ZXIgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgYmxvY2soU1RBVFMsICcuY291bnQrPScsIGluY3JlbWVudENvdW50ZXIsICc7Jyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYmxvY2soU1RBVFMsICcuY291bnQrKzsnKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGltZXIpIHtcclxuICAgICAgICBpZiAodXNlU2NvcGUpIHtcclxuICAgICAgICAgIFFVRVJZX0NPVU5URVIgPSBzY29wZS5kZWYoKTtcclxuICAgICAgICAgIGJsb2NrKFFVRVJZX0NPVU5URVIsICc9JywgVElNRVIsICcuZ2V0TnVtUGVuZGluZ1F1ZXJpZXMoKTsnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYmxvY2soVElNRVIsICcuYmVnaW5RdWVyeSgnLCBTVEFUUywgJyk7Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZW1pdFByb2ZpbGVFbmQgKGJsb2NrKSB7XHJcbiAgICAgIGJsb2NrKFNUQVRTLCAnLmNwdVRpbWUrPScsIHBlcmZDb3VudGVyKCksICctJywgQ1BVX1NUQVJULCAnOycpO1xyXG4gICAgICBpZiAodGltZXIpIHtcclxuICAgICAgICBpZiAodXNlU2NvcGUpIHtcclxuICAgICAgICAgIGJsb2NrKFRJTUVSLCAnLnB1c2hTY29wZVN0YXRzKCcsXHJcbiAgICAgICAgICAgIFFVRVJZX0NPVU5URVIsICcsJyxcclxuICAgICAgICAgICAgVElNRVIsICcuZ2V0TnVtUGVuZGluZ1F1ZXJpZXMoKSwnLFxyXG4gICAgICAgICAgICBTVEFUUywgJyk7Jyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGJsb2NrKFRJTUVSLCAnLmVuZFF1ZXJ5KCk7Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2NvcGVQcm9maWxlICh2YWx1ZSkge1xyXG4gICAgICB2YXIgcHJldiA9IHNjb3BlLmRlZihDVVJSRU5UX1NUQVRFLCAnLnByb2ZpbGUnKTtcclxuICAgICAgc2NvcGUoQ1VSUkVOVF9TVEFURSwgJy5wcm9maWxlPScsIHZhbHVlLCAnOycpO1xyXG4gICAgICBzY29wZS5leGl0KENVUlJFTlRfU1RBVEUsICcucHJvZmlsZT0nLCBwcmV2LCAnOycpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBVU0VfUFJPRklMRTtcclxuICAgIGlmIChwcm9maWxlQXJnKSB7XHJcbiAgICAgIGlmIChpc1N0YXRpYyhwcm9maWxlQXJnKSkge1xyXG4gICAgICAgIGlmIChwcm9maWxlQXJnLmVuYWJsZSkge1xyXG4gICAgICAgICAgZW1pdFByb2ZpbGVTdGFydChzY29wZSk7XHJcbiAgICAgICAgICBlbWl0UHJvZmlsZUVuZChzY29wZS5leGl0KTtcclxuICAgICAgICAgIHNjb3BlUHJvZmlsZSgndHJ1ZScpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBzY29wZVByb2ZpbGUoJ2ZhbHNlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVyblxyXG4gICAgICB9XHJcbiAgICAgIFVTRV9QUk9GSUxFID0gcHJvZmlsZUFyZy5hcHBlbmQoZW52LCBzY29wZSk7XHJcbiAgICAgIHNjb3BlUHJvZmlsZShVU0VfUFJPRklMRSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBVU0VfUFJPRklMRSA9IHNjb3BlLmRlZihDVVJSRU5UX1NUQVRFLCAnLnByb2ZpbGUnKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgc3RhcnQgPSBlbnYuYmxvY2soKTtcclxuICAgIGVtaXRQcm9maWxlU3RhcnQoc3RhcnQpO1xyXG4gICAgc2NvcGUoJ2lmKCcsIFVTRV9QUk9GSUxFLCAnKXsnLCBzdGFydCwgJ30nKTtcclxuICAgIHZhciBlbmQgPSBlbnYuYmxvY2soKTtcclxuICAgIGVtaXRQcm9maWxlRW5kKGVuZCk7XHJcbiAgICBzY29wZS5leGl0KCdpZignLCBVU0VfUFJPRklMRSwgJyl7JywgZW5kLCAnfScpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZW1pdEF0dHJpYnV0ZXMgKGVudiwgc2NvcGUsIGFyZ3MsIGF0dHJpYnV0ZXMsIGZpbHRlcikge1xyXG4gICAgdmFyIHNoYXJlZCA9IGVudi5zaGFyZWQ7XHJcblxyXG4gICAgZnVuY3Rpb24gdHlwZUxlbmd0aCAoeCkge1xyXG4gICAgICBzd2l0Y2ggKHgpIHtcclxuICAgICAgICBjYXNlIEdMX0ZMT0FUX1ZFQzI6XHJcbiAgICAgICAgY2FzZSBHTF9JTlRfVkVDMjpcclxuICAgICAgICBjYXNlIEdMX0JPT0xfVkVDMjpcclxuICAgICAgICAgIHJldHVybiAyXHJcbiAgICAgICAgY2FzZSBHTF9GTE9BVF9WRUMzOlxyXG4gICAgICAgIGNhc2UgR0xfSU5UX1ZFQzM6XHJcbiAgICAgICAgY2FzZSBHTF9CT09MX1ZFQzM6XHJcbiAgICAgICAgICByZXR1cm4gM1xyXG4gICAgICAgIGNhc2UgR0xfRkxPQVRfVkVDNDpcclxuICAgICAgICBjYXNlIEdMX0lOVF9WRUM0OlxyXG4gICAgICAgIGNhc2UgR0xfQk9PTF9WRUM0OlxyXG4gICAgICAgICAgcmV0dXJuIDRcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgcmV0dXJuIDFcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGVtaXRCaW5kQXR0cmlidXRlIChBVFRSSUJVVEUsIHNpemUsIHJlY29yZCkge1xyXG4gICAgICB2YXIgR0wgPSBzaGFyZWQuZ2w7XHJcblxyXG4gICAgICB2YXIgTE9DQVRJT04gPSBzY29wZS5kZWYoQVRUUklCVVRFLCAnLmxvY2F0aW9uJyk7XHJcbiAgICAgIHZhciBCSU5ESU5HID0gc2NvcGUuZGVmKHNoYXJlZC5hdHRyaWJ1dGVzLCAnWycsIExPQ0FUSU9OLCAnXScpO1xyXG5cclxuICAgICAgdmFyIFNUQVRFID0gcmVjb3JkLnN0YXRlO1xyXG4gICAgICB2YXIgQlVGRkVSID0gcmVjb3JkLmJ1ZmZlcjtcclxuICAgICAgdmFyIENPTlNUX0NPTVBPTkVOVFMgPSBbXHJcbiAgICAgICAgcmVjb3JkLngsXHJcbiAgICAgICAgcmVjb3JkLnksXHJcbiAgICAgICAgcmVjb3JkLnosXHJcbiAgICAgICAgcmVjb3JkLndcclxuICAgICAgXTtcclxuXHJcbiAgICAgIHZhciBDT01NT05fS0VZUyA9IFtcclxuICAgICAgICAnYnVmZmVyJyxcclxuICAgICAgICAnbm9ybWFsaXplZCcsXHJcbiAgICAgICAgJ29mZnNldCcsXHJcbiAgICAgICAgJ3N0cmlkZSdcclxuICAgICAgXTtcclxuXHJcbiAgICAgIGZ1bmN0aW9uIGVtaXRCdWZmZXIgKCkge1xyXG4gICAgICAgIHNjb3BlKFxyXG4gICAgICAgICAgJ2lmKCEnLCBCSU5ESU5HLCAnLmJ1ZmZlcil7JyxcclxuICAgICAgICAgIEdMLCAnLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KCcsIExPQ0FUSU9OLCAnKTt9Jyk7XHJcblxyXG4gICAgICAgIHZhciBUWVBFID0gcmVjb3JkLnR5cGU7XHJcbiAgICAgICAgdmFyIFNJWkU7XHJcbiAgICAgICAgaWYgKCFyZWNvcmQuc2l6ZSkge1xyXG4gICAgICAgICAgU0laRSA9IHNpemU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIFNJWkUgPSBzY29wZS5kZWYocmVjb3JkLnNpemUsICd8fCcsIHNpemUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc2NvcGUoJ2lmKCcsXHJcbiAgICAgICAgICBCSU5ESU5HLCAnLnR5cGUhPT0nLCBUWVBFLCAnfHwnLFxyXG4gICAgICAgICAgQklORElORywgJy5zaXplIT09JywgU0laRSwgJ3x8JyxcclxuICAgICAgICAgIENPTU1PTl9LRVlTLm1hcChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBCSU5ESU5HICsgJy4nICsga2V5ICsgJyE9PScgKyByZWNvcmRba2V5XVxyXG4gICAgICAgICAgfSkuam9pbignfHwnKSxcclxuICAgICAgICAgICcpeycsXHJcbiAgICAgICAgICBHTCwgJy5iaW5kQnVmZmVyKCcsIEdMX0FSUkFZX0JVRkZFUiQxLCAnLCcsIEJVRkZFUiwgJy5idWZmZXIpOycsXHJcbiAgICAgICAgICBHTCwgJy52ZXJ0ZXhBdHRyaWJQb2ludGVyKCcsIFtcclxuICAgICAgICAgICAgTE9DQVRJT04sXHJcbiAgICAgICAgICAgIFNJWkUsXHJcbiAgICAgICAgICAgIFRZUEUsXHJcbiAgICAgICAgICAgIHJlY29yZC5ub3JtYWxpemVkLFxyXG4gICAgICAgICAgICByZWNvcmQuc3RyaWRlLFxyXG4gICAgICAgICAgICByZWNvcmQub2Zmc2V0XHJcbiAgICAgICAgICBdLCAnKTsnLFxyXG4gICAgICAgICAgQklORElORywgJy50eXBlPScsIFRZUEUsICc7JyxcclxuICAgICAgICAgIEJJTkRJTkcsICcuc2l6ZT0nLCBTSVpFLCAnOycsXHJcbiAgICAgICAgICBDT01NT05fS0VZUy5tYXAoZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gQklORElORyArICcuJyArIGtleSArICc9JyArIHJlY29yZFtrZXldICsgJzsnXHJcbiAgICAgICAgICB9KS5qb2luKCcnKSxcclxuICAgICAgICAgICd9Jyk7XHJcblxyXG4gICAgICAgIGlmIChleHRJbnN0YW5jaW5nKSB7XHJcbiAgICAgICAgICB2YXIgRElWSVNPUiA9IHJlY29yZC5kaXZpc29yO1xyXG4gICAgICAgICAgc2NvcGUoXHJcbiAgICAgICAgICAgICdpZignLCBCSU5ESU5HLCAnLmRpdmlzb3IhPT0nLCBESVZJU09SLCAnKXsnLFxyXG4gICAgICAgICAgICBlbnYuaW5zdGFuY2luZywgJy52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoJywgW0xPQ0FUSU9OLCBESVZJU09SXSwgJyk7JyxcclxuICAgICAgICAgICAgQklORElORywgJy5kaXZpc29yPScsIERJVklTT1IsICc7fScpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gZW1pdENvbnN0YW50ICgpIHtcclxuICAgICAgICBzY29wZShcclxuICAgICAgICAgICdpZignLCBCSU5ESU5HLCAnLmJ1ZmZlcil7JyxcclxuICAgICAgICAgIEdMLCAnLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheSgnLCBMT0NBVElPTiwgJyk7JyxcclxuICAgICAgICAgICd9aWYoJywgQ1VURV9DT01QT05FTlRTLm1hcChmdW5jdGlvbiAoYywgaSkge1xyXG4gICAgICAgICAgICByZXR1cm4gQklORElORyArICcuJyArIGMgKyAnIT09JyArIENPTlNUX0NPTVBPTkVOVFNbaV1cclxuICAgICAgICAgIH0pLmpvaW4oJ3x8JyksICcpeycsXHJcbiAgICAgICAgICBHTCwgJy52ZXJ0ZXhBdHRyaWI0ZignLCBMT0NBVElPTiwgJywnLCBDT05TVF9DT01QT05FTlRTLCAnKTsnLFxyXG4gICAgICAgICAgQ1VURV9DT01QT05FTlRTLm1hcChmdW5jdGlvbiAoYywgaSkge1xyXG4gICAgICAgICAgICByZXR1cm4gQklORElORyArICcuJyArIGMgKyAnPScgKyBDT05TVF9DT01QT05FTlRTW2ldICsgJzsnXHJcbiAgICAgICAgICB9KS5qb2luKCcnKSxcclxuICAgICAgICAgICd9Jyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChTVEFURSA9PT0gQVRUUklCX1NUQVRFX1BPSU5URVIpIHtcclxuICAgICAgICBlbWl0QnVmZmVyKCk7XHJcbiAgICAgIH0gZWxzZSBpZiAoU1RBVEUgPT09IEFUVFJJQl9TVEFURV9DT05TVEFOVCkge1xyXG4gICAgICAgIGVtaXRDb25zdGFudCgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNjb3BlKCdpZignLCBTVEFURSwgJz09PScsIEFUVFJJQl9TVEFURV9QT0lOVEVSLCAnKXsnKTtcclxuICAgICAgICBlbWl0QnVmZmVyKCk7XHJcbiAgICAgICAgc2NvcGUoJ31lbHNleycpO1xyXG4gICAgICAgIGVtaXRDb25zdGFudCgpO1xyXG4gICAgICAgIHNjb3BlKCd9Jyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBhdHRyaWJ1dGVzLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xyXG4gICAgICB2YXIgbmFtZSA9IGF0dHJpYnV0ZS5uYW1lO1xyXG4gICAgICB2YXIgYXJnID0gYXJncy5hdHRyaWJ1dGVzW25hbWVdO1xyXG4gICAgICB2YXIgcmVjb3JkO1xyXG4gICAgICBpZiAoYXJnKSB7XHJcbiAgICAgICAgaWYgKCFmaWx0ZXIoYXJnKSkge1xyXG4gICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlY29yZCA9IGFyZy5hcHBlbmQoZW52LCBzY29wZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKCFmaWx0ZXIoU0NPUEVfREVDTCkpIHtcclxuICAgICAgICAgIHJldHVyblxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc2NvcGVBdHRyaWIgPSBlbnYuc2NvcGVBdHRyaWIobmFtZSk7XHJcbiAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLFxyXG4gICAgICAgICAgICBzY29wZUF0dHJpYiArICcuc3RhdGUnLFxyXG4gICAgICAgICAgICAnbWlzc2luZyBhdHRyaWJ1dGUgJyArIG5hbWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJlY29yZCA9IHt9O1xyXG4gICAgICAgIE9iamVjdC5rZXlzKG5ldyBBdHRyaWJ1dGVSZWNvcmQoKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICByZWNvcmRba2V5XSA9IHNjb3BlLmRlZihzY29wZUF0dHJpYiwgJy4nLCBrZXkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGVtaXRCaW5kQXR0cmlidXRlKFxyXG4gICAgICAgIGVudi5saW5rKGF0dHJpYnV0ZSksIHR5cGVMZW5ndGgoYXR0cmlidXRlLmluZm8udHlwZSksIHJlY29yZCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGVtaXRVbmlmb3JtcyAoZW52LCBzY29wZSwgYXJncywgdW5pZm9ybXMsIGZpbHRlcikge1xyXG4gICAgdmFyIHNoYXJlZCA9IGVudi5zaGFyZWQ7XHJcbiAgICB2YXIgR0wgPSBzaGFyZWQuZ2w7XHJcblxyXG4gICAgdmFyIGluZml4O1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1bmlmb3Jtcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICB2YXIgdW5pZm9ybSA9IHVuaWZvcm1zW2ldO1xyXG4gICAgICB2YXIgbmFtZSA9IHVuaWZvcm0ubmFtZTtcclxuICAgICAgdmFyIHR5cGUgPSB1bmlmb3JtLmluZm8udHlwZTtcclxuICAgICAgdmFyIGFyZyA9IGFyZ3MudW5pZm9ybXNbbmFtZV07XHJcbiAgICAgIHZhciBVTklGT1JNID0gZW52LmxpbmsodW5pZm9ybSk7XHJcbiAgICAgIHZhciBMT0NBVElPTiA9IFVOSUZPUk0gKyAnLmxvY2F0aW9uJztcclxuXHJcbiAgICAgIHZhciBWQUxVRTtcclxuICAgICAgaWYgKGFyZykge1xyXG4gICAgICAgIGlmICghZmlsdGVyKGFyZykpIHtcclxuICAgICAgICAgIGNvbnRpbnVlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc1N0YXRpYyhhcmcpKSB7XHJcbiAgICAgICAgICB2YXIgdmFsdWUgPSBhcmcudmFsdWU7XHJcbiAgICAgICAgICBjaGVjayQxLmNvbW1hbmQoXHJcbiAgICAgICAgICAgIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcsXHJcbiAgICAgICAgICAgICdtaXNzaW5nIHVuaWZvcm0gXCInICsgbmFtZSArICdcIicsIGVudi5jb21tYW5kU3RyKTtcclxuICAgICAgICAgIGlmICh0eXBlID09PSBHTF9TQU1QTEVSXzJEIHx8IHR5cGUgPT09IEdMX1NBTVBMRVJfQ1VCRSkge1xyXG4gICAgICAgICAgICBjaGVjayQxLmNvbW1hbmQoXHJcbiAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmXHJcbiAgICAgICAgICAgICAgKCh0eXBlID09PSBHTF9TQU1QTEVSXzJEICYmXHJcbiAgICAgICAgICAgICAgICAodmFsdWUuX3JlZ2xUeXBlID09PSAndGV4dHVyZTJkJyB8fFxyXG4gICAgICAgICAgICAgICAgdmFsdWUuX3JlZ2xUeXBlID09PSAnZnJhbWVidWZmZXInKSkgfHxcclxuICAgICAgICAgICAgICAodHlwZSA9PT0gR0xfU0FNUExFUl9DVUJFICYmXHJcbiAgICAgICAgICAgICAgICAodmFsdWUuX3JlZ2xUeXBlID09PSAndGV4dHVyZUN1YmUnIHx8XHJcbiAgICAgICAgICAgICAgICB2YWx1ZS5fcmVnbFR5cGUgPT09ICdmcmFtZWJ1ZmZlckN1YmUnKSkpLFxyXG4gICAgICAgICAgICAgICdpbnZhbGlkIHRleHR1cmUgZm9yIHVuaWZvcm0gJyArIG5hbWUsIGVudi5jb21tYW5kU3RyKTtcclxuICAgICAgICAgICAgdmFyIFRFWF9WQUxVRSA9IGVudi5saW5rKHZhbHVlLl90ZXh0dXJlIHx8IHZhbHVlLmNvbG9yWzBdLl90ZXh0dXJlKTtcclxuICAgICAgICAgICAgc2NvcGUoR0wsICcudW5pZm9ybTFpKCcsIExPQ0FUSU9OLCAnLCcsIFRFWF9WQUxVRSArICcuYmluZCgpKTsnKTtcclxuICAgICAgICAgICAgc2NvcGUuZXhpdChURVhfVkFMVUUsICcudW5iaW5kKCk7Jyk7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKFxyXG4gICAgICAgICAgICB0eXBlID09PSBHTF9GTE9BVF9NQVQyIHx8XHJcbiAgICAgICAgICAgIHR5cGUgPT09IEdMX0ZMT0FUX01BVDMgfHxcclxuICAgICAgICAgICAgdHlwZSA9PT0gR0xfRkxPQVRfTUFUNCkge1xyXG4gICAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmQoaXNBcnJheUxpa2UodmFsdWUpLFxyXG4gICAgICAgICAgICAgICAgJ2ludmFsaWQgbWF0cml4IGZvciB1bmlmb3JtICcgKyBuYW1lLCBlbnYuY29tbWFuZFN0cik7XHJcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKFxyXG4gICAgICAgICAgICAgICAgKHR5cGUgPT09IEdMX0ZMT0FUX01BVDIgJiYgdmFsdWUubGVuZ3RoID09PSA0KSB8fFxyXG4gICAgICAgICAgICAgICAgKHR5cGUgPT09IEdMX0ZMT0FUX01BVDMgJiYgdmFsdWUubGVuZ3RoID09PSA5KSB8fFxyXG4gICAgICAgICAgICAgICAgKHR5cGUgPT09IEdMX0ZMT0FUX01BVDQgJiYgdmFsdWUubGVuZ3RoID09PSAxNiksXHJcbiAgICAgICAgICAgICAgICAnaW52YWxpZCBsZW5ndGggZm9yIG1hdHJpeCB1bmlmb3JtICcgKyBuYW1lLCBlbnYuY29tbWFuZFN0cik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB2YXIgTUFUX1ZBTFVFID0gZW52Lmdsb2JhbC5kZWYoJ25ldyBGbG9hdDMyQXJyYXkoWycgK1xyXG4gICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHZhbHVlKSArICddKScpO1xyXG4gICAgICAgICAgICB2YXIgZGltID0gMjtcclxuICAgICAgICAgICAgaWYgKHR5cGUgPT09IEdMX0ZMT0FUX01BVDMpIHtcclxuICAgICAgICAgICAgICBkaW0gPSAzO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IEdMX0ZMT0FUX01BVDQpIHtcclxuICAgICAgICAgICAgICBkaW0gPSA0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNjb3BlKFxyXG4gICAgICAgICAgICAgIEdMLCAnLnVuaWZvcm1NYXRyaXgnLCBkaW0sICdmdignLFxyXG4gICAgICAgICAgICAgIExPQ0FUSU9OLCAnLGZhbHNlLCcsIE1BVF9WQUxVRSwgJyk7Jyk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICAgICAgICBjYXNlIEdMX0ZMT0FUJDg6XHJcbiAgICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmRUeXBlKHZhbHVlLCAnbnVtYmVyJywgJ3VuaWZvcm0gJyArIG5hbWUsIGVudi5jb21tYW5kU3RyKTtcclxuICAgICAgICAgICAgICAgIGluZml4ID0gJzFmJztcclxuICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgICAgY2FzZSBHTF9GTE9BVF9WRUMyOlxyXG4gICAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKFxyXG4gICAgICAgICAgICAgICAgICBpc0FycmF5TGlrZSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAyLFxyXG4gICAgICAgICAgICAgICAgICAndW5pZm9ybSAnICsgbmFtZSwgZW52LmNvbW1hbmRTdHIpO1xyXG4gICAgICAgICAgICAgICAgaW5maXggPSAnMmYnO1xyXG4gICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgICAgICBjYXNlIEdMX0ZMT0FUX1ZFQzM6XHJcbiAgICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmQoXHJcbiAgICAgICAgICAgICAgICAgIGlzQXJyYXlMaWtlKHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDMsXHJcbiAgICAgICAgICAgICAgICAgICd1bmlmb3JtICcgKyBuYW1lLCBlbnYuY29tbWFuZFN0cik7XHJcbiAgICAgICAgICAgICAgICBpbmZpeCA9ICczZic7XHJcbiAgICAgICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgICAgIGNhc2UgR0xfRkxPQVRfVkVDNDpcclxuICAgICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZChcclxuICAgICAgICAgICAgICAgICAgaXNBcnJheUxpa2UodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gNCxcclxuICAgICAgICAgICAgICAgICAgJ3VuaWZvcm0gJyArIG5hbWUsIGVudi5jb21tYW5kU3RyKTtcclxuICAgICAgICAgICAgICAgIGluZml4ID0gJzRmJztcclxuICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgICAgY2FzZSBHTF9CT09MOlxyXG4gICAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kVHlwZSh2YWx1ZSwgJ2Jvb2xlYW4nLCAndW5pZm9ybSAnICsgbmFtZSwgZW52LmNvbW1hbmRTdHIpO1xyXG4gICAgICAgICAgICAgICAgaW5maXggPSAnMWknO1xyXG4gICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgICAgICBjYXNlIEdMX0lOVCQzOlxyXG4gICAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kVHlwZSh2YWx1ZSwgJ251bWJlcicsICd1bmlmb3JtICcgKyBuYW1lLCBlbnYuY29tbWFuZFN0cik7XHJcbiAgICAgICAgICAgICAgICBpbmZpeCA9ICcxaSc7XHJcbiAgICAgICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgICAgIGNhc2UgR0xfQk9PTF9WRUMyOlxyXG4gICAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKFxyXG4gICAgICAgICAgICAgICAgICBpc0FycmF5TGlrZSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAyLFxyXG4gICAgICAgICAgICAgICAgICAndW5pZm9ybSAnICsgbmFtZSwgZW52LmNvbW1hbmRTdHIpO1xyXG4gICAgICAgICAgICAgICAgaW5maXggPSAnMmknO1xyXG4gICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgICAgICBjYXNlIEdMX0lOVF9WRUMyOlxyXG4gICAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKFxyXG4gICAgICAgICAgICAgICAgICBpc0FycmF5TGlrZSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAyLFxyXG4gICAgICAgICAgICAgICAgICAndW5pZm9ybSAnICsgbmFtZSwgZW52LmNvbW1hbmRTdHIpO1xyXG4gICAgICAgICAgICAgICAgaW5maXggPSAnMmknO1xyXG4gICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgICAgICBjYXNlIEdMX0JPT0xfVkVDMzpcclxuICAgICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZChcclxuICAgICAgICAgICAgICAgICAgaXNBcnJheUxpa2UodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMyxcclxuICAgICAgICAgICAgICAgICAgJ3VuaWZvcm0gJyArIG5hbWUsIGVudi5jb21tYW5kU3RyKTtcclxuICAgICAgICAgICAgICAgIGluZml4ID0gJzNpJztcclxuICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgICAgY2FzZSBHTF9JTlRfVkVDMzpcclxuICAgICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZChcclxuICAgICAgICAgICAgICAgICAgaXNBcnJheUxpa2UodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMyxcclxuICAgICAgICAgICAgICAgICAgJ3VuaWZvcm0gJyArIG5hbWUsIGVudi5jb21tYW5kU3RyKTtcclxuICAgICAgICAgICAgICAgIGluZml4ID0gJzNpJztcclxuICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgICAgY2FzZSBHTF9CT09MX1ZFQzQ6XHJcbiAgICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmQoXHJcbiAgICAgICAgICAgICAgICAgIGlzQXJyYXlMaWtlKHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDQsXHJcbiAgICAgICAgICAgICAgICAgICd1bmlmb3JtICcgKyBuYW1lLCBlbnYuY29tbWFuZFN0cik7XHJcbiAgICAgICAgICAgICAgICBpbmZpeCA9ICc0aSc7XHJcbiAgICAgICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgICAgIGNhc2UgR0xfSU5UX1ZFQzQ6XHJcbiAgICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmQoXHJcbiAgICAgICAgICAgICAgICAgIGlzQXJyYXlMaWtlKHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDQsXHJcbiAgICAgICAgICAgICAgICAgICd1bmlmb3JtICcgKyBuYW1lLCBlbnYuY29tbWFuZFN0cik7XHJcbiAgICAgICAgICAgICAgICBpbmZpeCA9ICc0aSc7XHJcbiAgICAgICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNjb3BlKEdMLCAnLnVuaWZvcm0nLCBpbmZpeCwgJygnLCBMT0NBVElPTiwgJywnLFxyXG4gICAgICAgICAgICAgIGlzQXJyYXlMaWtlKHZhbHVlKSA/IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHZhbHVlKSA6IHZhbHVlLFxyXG4gICAgICAgICAgICAgICcpOycpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY29udGludWVcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgVkFMVUUgPSBhcmcuYXBwZW5kKGVudiwgc2NvcGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoIWZpbHRlcihTQ09QRV9ERUNMKSkge1xyXG4gICAgICAgICAgY29udGludWVcclxuICAgICAgICB9XHJcbiAgICAgICAgVkFMVUUgPSBzY29wZS5kZWYoc2hhcmVkLnVuaWZvcm1zLCAnWycsIHN0cmluZ1N0b3JlLmlkKG5hbWUpLCAnXScpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodHlwZSA9PT0gR0xfU0FNUExFUl8yRCkge1xyXG4gICAgICAgIHNjb3BlKFxyXG4gICAgICAgICAgJ2lmKCcsIFZBTFVFLCAnJiYnLCBWQUxVRSwgJy5fcmVnbFR5cGU9PT1cImZyYW1lYnVmZmVyXCIpeycsXHJcbiAgICAgICAgICBWQUxVRSwgJz0nLCBWQUxVRSwgJy5jb2xvclswXTsnLFxyXG4gICAgICAgICAgJ30nKTtcclxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBHTF9TQU1QTEVSX0NVQkUpIHtcclxuICAgICAgICBzY29wZShcclxuICAgICAgICAgICdpZignLCBWQUxVRSwgJyYmJywgVkFMVUUsICcuX3JlZ2xUeXBlPT09XCJmcmFtZWJ1ZmZlckN1YmVcIil7JyxcclxuICAgICAgICAgIFZBTFVFLCAnPScsIFZBTFVFLCAnLmNvbG9yWzBdOycsXHJcbiAgICAgICAgICAnfScpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBwZXJmb3JtIHR5cGUgdmFsaWRhdGlvblxyXG4gICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBjaGVjayAocHJlZCwgbWVzc2FnZSkge1xyXG4gICAgICAgICAgZW52LmFzc2VydChzY29wZSwgcHJlZCxcclxuICAgICAgICAgICAgJ2JhZCBkYXRhIG9yIG1pc3NpbmcgZm9yIHVuaWZvcm0gXCInICsgbmFtZSArICdcIi4gICcgKyBtZXNzYWdlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrVHlwZSAodHlwZSkge1xyXG4gICAgICAgICAgY2hlY2soXHJcbiAgICAgICAgICAgICd0eXBlb2YgJyArIFZBTFVFICsgJz09PVwiJyArIHR5cGUgKyAnXCInLFxyXG4gICAgICAgICAgICAnaW52YWxpZCB0eXBlLCBleHBlY3RlZCAnICsgdHlwZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBjaGVja1ZlY3RvciAobiwgdHlwZSkge1xyXG4gICAgICAgICAgY2hlY2soXHJcbiAgICAgICAgICAgIHNoYXJlZC5pc0FycmF5TGlrZSArICcoJyArIFZBTFVFICsgJykmJicgKyBWQUxVRSArICcubGVuZ3RoPT09JyArIG4sXHJcbiAgICAgICAgICAgICdpbnZhbGlkIHZlY3Rvciwgc2hvdWxkIGhhdmUgbGVuZ3RoICcgKyBuLCBlbnYuY29tbWFuZFN0cik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBjaGVja1RleHR1cmUgKHRhcmdldCkge1xyXG4gICAgICAgICAgY2hlY2soXHJcbiAgICAgICAgICAgICd0eXBlb2YgJyArIFZBTFVFICsgJz09PVwiZnVuY3Rpb25cIiYmJyArXHJcbiAgICAgICAgICAgIFZBTFVFICsgJy5fcmVnbFR5cGU9PT1cInRleHR1cmUnICtcclxuICAgICAgICAgICAgKHRhcmdldCA9PT0gR0xfVEVYVFVSRV8yRCQzID8gJzJkJyA6ICdDdWJlJykgKyAnXCInLFxyXG4gICAgICAgICAgICAnaW52YWxpZCB0ZXh0dXJlIHR5cGUnLCBlbnYuY29tbWFuZFN0cik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICAgIGNhc2UgR0xfSU5UJDM6XHJcbiAgICAgICAgICAgIGNoZWNrVHlwZSgnbnVtYmVyJyk7XHJcbiAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICBjYXNlIEdMX0lOVF9WRUMyOlxyXG4gICAgICAgICAgICBjaGVja1ZlY3RvcigyLCAnbnVtYmVyJyk7XHJcbiAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICBjYXNlIEdMX0lOVF9WRUMzOlxyXG4gICAgICAgICAgICBjaGVja1ZlY3RvcigzLCAnbnVtYmVyJyk7XHJcbiAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICBjYXNlIEdMX0lOVF9WRUM0OlxyXG4gICAgICAgICAgICBjaGVja1ZlY3Rvcig0LCAnbnVtYmVyJyk7XHJcbiAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICBjYXNlIEdMX0ZMT0FUJDg6XHJcbiAgICAgICAgICAgIGNoZWNrVHlwZSgnbnVtYmVyJyk7XHJcbiAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICBjYXNlIEdMX0ZMT0FUX1ZFQzI6XHJcbiAgICAgICAgICAgIGNoZWNrVmVjdG9yKDIsICdudW1iZXInKTtcclxuICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgIGNhc2UgR0xfRkxPQVRfVkVDMzpcclxuICAgICAgICAgICAgY2hlY2tWZWN0b3IoMywgJ251bWJlcicpO1xyXG4gICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgY2FzZSBHTF9GTE9BVF9WRUM0OlxyXG4gICAgICAgICAgICBjaGVja1ZlY3Rvcig0LCAnbnVtYmVyJyk7XHJcbiAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICBjYXNlIEdMX0JPT0w6XHJcbiAgICAgICAgICAgIGNoZWNrVHlwZSgnYm9vbGVhbicpO1xyXG4gICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgY2FzZSBHTF9CT09MX1ZFQzI6XHJcbiAgICAgICAgICAgIGNoZWNrVmVjdG9yKDIsICdib29sZWFuJyk7XHJcbiAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICBjYXNlIEdMX0JPT0xfVkVDMzpcclxuICAgICAgICAgICAgY2hlY2tWZWN0b3IoMywgJ2Jvb2xlYW4nKTtcclxuICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgIGNhc2UgR0xfQk9PTF9WRUM0OlxyXG4gICAgICAgICAgICBjaGVja1ZlY3Rvcig0LCAnYm9vbGVhbicpO1xyXG4gICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgY2FzZSBHTF9GTE9BVF9NQVQyOlxyXG4gICAgICAgICAgICBjaGVja1ZlY3Rvcig0LCAnbnVtYmVyJyk7XHJcbiAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICBjYXNlIEdMX0ZMT0FUX01BVDM6XHJcbiAgICAgICAgICAgIGNoZWNrVmVjdG9yKDksICdudW1iZXInKTtcclxuICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgIGNhc2UgR0xfRkxPQVRfTUFUNDpcclxuICAgICAgICAgICAgY2hlY2tWZWN0b3IoMTYsICdudW1iZXInKTtcclxuICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgIGNhc2UgR0xfU0FNUExFUl8yRDpcclxuICAgICAgICAgICAgY2hlY2tUZXh0dXJlKEdMX1RFWFRVUkVfMkQkMyk7XHJcbiAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICBjYXNlIEdMX1NBTVBMRVJfQ1VCRTpcclxuICAgICAgICAgICAgY2hlY2tUZXh0dXJlKEdMX1RFWFRVUkVfQ1VCRV9NQVAkMik7XHJcbiAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHZhciB1bnJvbGwgPSAxO1xyXG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICBjYXNlIEdMX1NBTVBMRVJfMkQ6XHJcbiAgICAgICAgY2FzZSBHTF9TQU1QTEVSX0NVQkU6XHJcbiAgICAgICAgICB2YXIgVEVYID0gc2NvcGUuZGVmKFZBTFVFLCAnLl90ZXh0dXJlJyk7XHJcbiAgICAgICAgICBzY29wZShHTCwgJy51bmlmb3JtMWkoJywgTE9DQVRJT04sICcsJywgVEVYLCAnLmJpbmQoKSk7Jyk7XHJcbiAgICAgICAgICBzY29wZS5leGl0KFRFWCwgJy51bmJpbmQoKTsnKTtcclxuICAgICAgICAgIGNvbnRpbnVlXHJcblxyXG4gICAgICAgIGNhc2UgR0xfSU5UJDM6XHJcbiAgICAgICAgY2FzZSBHTF9CT09MOlxyXG4gICAgICAgICAgaW5maXggPSAnMWknO1xyXG4gICAgICAgICAgYnJlYWtcclxuXHJcbiAgICAgICAgY2FzZSBHTF9JTlRfVkVDMjpcclxuICAgICAgICBjYXNlIEdMX0JPT0xfVkVDMjpcclxuICAgICAgICAgIGluZml4ID0gJzJpJztcclxuICAgICAgICAgIHVucm9sbCA9IDI7XHJcbiAgICAgICAgICBicmVha1xyXG5cclxuICAgICAgICBjYXNlIEdMX0lOVF9WRUMzOlxyXG4gICAgICAgIGNhc2UgR0xfQk9PTF9WRUMzOlxyXG4gICAgICAgICAgaW5maXggPSAnM2knO1xyXG4gICAgICAgICAgdW5yb2xsID0gMztcclxuICAgICAgICAgIGJyZWFrXHJcblxyXG4gICAgICAgIGNhc2UgR0xfSU5UX1ZFQzQ6XHJcbiAgICAgICAgY2FzZSBHTF9CT09MX1ZFQzQ6XHJcbiAgICAgICAgICBpbmZpeCA9ICc0aSc7XHJcbiAgICAgICAgICB1bnJvbGwgPSA0O1xyXG4gICAgICAgICAgYnJlYWtcclxuXHJcbiAgICAgICAgY2FzZSBHTF9GTE9BVCQ4OlxyXG4gICAgICAgICAgaW5maXggPSAnMWYnO1xyXG4gICAgICAgICAgYnJlYWtcclxuXHJcbiAgICAgICAgY2FzZSBHTF9GTE9BVF9WRUMyOlxyXG4gICAgICAgICAgaW5maXggPSAnMmYnO1xyXG4gICAgICAgICAgdW5yb2xsID0gMjtcclxuICAgICAgICAgIGJyZWFrXHJcblxyXG4gICAgICAgIGNhc2UgR0xfRkxPQVRfVkVDMzpcclxuICAgICAgICAgIGluZml4ID0gJzNmJztcclxuICAgICAgICAgIHVucm9sbCA9IDM7XHJcbiAgICAgICAgICBicmVha1xyXG5cclxuICAgICAgICBjYXNlIEdMX0ZMT0FUX1ZFQzQ6XHJcbiAgICAgICAgICBpbmZpeCA9ICc0Zic7XHJcbiAgICAgICAgICB1bnJvbGwgPSA0O1xyXG4gICAgICAgICAgYnJlYWtcclxuXHJcbiAgICAgICAgY2FzZSBHTF9GTE9BVF9NQVQyOlxyXG4gICAgICAgICAgaW5maXggPSAnTWF0cml4MmZ2JztcclxuICAgICAgICAgIGJyZWFrXHJcblxyXG4gICAgICAgIGNhc2UgR0xfRkxPQVRfTUFUMzpcclxuICAgICAgICAgIGluZml4ID0gJ01hdHJpeDNmdic7XHJcbiAgICAgICAgICBicmVha1xyXG5cclxuICAgICAgICBjYXNlIEdMX0ZMT0FUX01BVDQ6XHJcbiAgICAgICAgICBpbmZpeCA9ICdNYXRyaXg0ZnYnO1xyXG4gICAgICAgICAgYnJlYWtcclxuICAgICAgfVxyXG5cclxuICAgICAgc2NvcGUoR0wsICcudW5pZm9ybScsIGluZml4LCAnKCcsIExPQ0FUSU9OLCAnLCcpO1xyXG4gICAgICBpZiAoaW5maXguY2hhckF0KDApID09PSAnTScpIHtcclxuICAgICAgICB2YXIgbWF0U2l6ZSA9IE1hdGgucG93KHR5cGUgLSBHTF9GTE9BVF9NQVQyICsgMiwgMik7XHJcbiAgICAgICAgdmFyIFNUT1JBR0UgPSBlbnYuZ2xvYmFsLmRlZignbmV3IEZsb2F0MzJBcnJheSgnLCBtYXRTaXplLCAnKScpO1xyXG4gICAgICAgIHNjb3BlKFxyXG4gICAgICAgICAgJ2ZhbHNlLChBcnJheS5pc0FycmF5KCcsIFZBTFVFLCAnKXx8JywgVkFMVUUsICcgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpPycsIFZBTFVFLCAnOignLFxyXG4gICAgICAgICAgbG9vcChtYXRTaXplLCBmdW5jdGlvbiAoaSkge1xyXG4gICAgICAgICAgICByZXR1cm4gU1RPUkFHRSArICdbJyArIGkgKyAnXT0nICsgVkFMVUUgKyAnWycgKyBpICsgJ10nXHJcbiAgICAgICAgICB9KSwgJywnLCBTVE9SQUdFLCAnKScpO1xyXG4gICAgICB9IGVsc2UgaWYgKHVucm9sbCA+IDEpIHtcclxuICAgICAgICBzY29wZShsb29wKHVucm9sbCwgZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICAgIHJldHVybiBWQUxVRSArICdbJyArIGkgKyAnXSdcclxuICAgICAgICB9KSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc2NvcGUoVkFMVUUpO1xyXG4gICAgICB9XHJcbiAgICAgIHNjb3BlKCcpOycpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZW1pdERyYXcgKGVudiwgb3V0ZXIsIGlubmVyLCBhcmdzKSB7XHJcbiAgICB2YXIgc2hhcmVkID0gZW52LnNoYXJlZDtcclxuICAgIHZhciBHTCA9IHNoYXJlZC5nbDtcclxuICAgIHZhciBEUkFXX1NUQVRFID0gc2hhcmVkLmRyYXc7XHJcblxyXG4gICAgdmFyIGRyYXdPcHRpb25zID0gYXJncy5kcmF3O1xyXG5cclxuICAgIGZ1bmN0aW9uIGVtaXRFbGVtZW50cyAoKSB7XHJcbiAgICAgIHZhciBkZWZuID0gZHJhd09wdGlvbnMuZWxlbWVudHM7XHJcbiAgICAgIHZhciBFTEVNRU5UUztcclxuICAgICAgdmFyIHNjb3BlID0gb3V0ZXI7XHJcbiAgICAgIGlmIChkZWZuKSB7XHJcbiAgICAgICAgaWYgKChkZWZuLmNvbnRleHREZXAgJiYgYXJncy5jb250ZXh0RHluYW1pYykgfHwgZGVmbi5wcm9wRGVwKSB7XHJcbiAgICAgICAgICBzY29wZSA9IGlubmVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBFTEVNRU5UUyA9IGRlZm4uYXBwZW5kKGVudiwgc2NvcGUpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIEVMRU1FTlRTID0gc2NvcGUuZGVmKERSQVdfU1RBVEUsICcuJywgU19FTEVNRU5UUyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKEVMRU1FTlRTKSB7XHJcbiAgICAgICAgc2NvcGUoXHJcbiAgICAgICAgICAnaWYoJyArIEVMRU1FTlRTICsgJyknICtcclxuICAgICAgICAgIEdMICsgJy5iaW5kQnVmZmVyKCcgKyBHTF9FTEVNRU5UX0FSUkFZX0JVRkZFUiQxICsgJywnICsgRUxFTUVOVFMgKyAnLmJ1ZmZlci5idWZmZXIpOycpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBFTEVNRU5UU1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGVtaXRDb3VudCAoKSB7XHJcbiAgICAgIHZhciBkZWZuID0gZHJhd09wdGlvbnMuY291bnQ7XHJcbiAgICAgIHZhciBDT1VOVDtcclxuICAgICAgdmFyIHNjb3BlID0gb3V0ZXI7XHJcbiAgICAgIGlmIChkZWZuKSB7XHJcbiAgICAgICAgaWYgKChkZWZuLmNvbnRleHREZXAgJiYgYXJncy5jb250ZXh0RHluYW1pYykgfHwgZGVmbi5wcm9wRGVwKSB7XHJcbiAgICAgICAgICBzY29wZSA9IGlubmVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBDT1VOVCA9IGRlZm4uYXBwZW5kKGVudiwgc2NvcGUpO1xyXG4gICAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgaWYgKGRlZm4uTUlTU0lORykge1xyXG4gICAgICAgICAgICBlbnYuYXNzZXJ0KG91dGVyLCAnZmFsc2UnLCAnbWlzc2luZyB2ZXJ0ZXggY291bnQnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChkZWZuLkRZTkFNSUMpIHtcclxuICAgICAgICAgICAgZW52LmFzc2VydChzY29wZSwgQ09VTlQgKyAnPj0wJywgJ21pc3NpbmcgdmVydGV4IGNvdW50Jyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgQ09VTlQgPSBzY29wZS5kZWYoRFJBV19TVEFURSwgJy4nLCBTX0NPVU5UKTtcclxuICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIGVudi5hc3NlcnQoc2NvcGUsIENPVU5UICsgJz49MCcsICdtaXNzaW5nIHZlcnRleCBjb3VudCcpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBDT1VOVFxyXG4gICAgfVxyXG5cclxuICAgIHZhciBFTEVNRU5UUyA9IGVtaXRFbGVtZW50cygpO1xyXG4gICAgZnVuY3Rpb24gZW1pdFZhbHVlIChuYW1lKSB7XHJcbiAgICAgIHZhciBkZWZuID0gZHJhd09wdGlvbnNbbmFtZV07XHJcbiAgICAgIGlmIChkZWZuKSB7XHJcbiAgICAgICAgaWYgKChkZWZuLmNvbnRleHREZXAgJiYgYXJncy5jb250ZXh0RHluYW1pYykgfHwgZGVmbi5wcm9wRGVwKSB7XHJcbiAgICAgICAgICByZXR1cm4gZGVmbi5hcHBlbmQoZW52LCBpbm5lcilcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmV0dXJuIGRlZm4uYXBwZW5kKGVudiwgb3V0ZXIpXHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBvdXRlci5kZWYoRFJBV19TVEFURSwgJy4nLCBuYW1lKVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIFBSSU1JVElWRSA9IGVtaXRWYWx1ZShTX1BSSU1JVElWRSk7XHJcbiAgICB2YXIgT0ZGU0VUID0gZW1pdFZhbHVlKFNfT0ZGU0VUKTtcclxuXHJcbiAgICB2YXIgQ09VTlQgPSBlbWl0Q291bnQoKTtcclxuICAgIGlmICh0eXBlb2YgQ09VTlQgPT09ICdudW1iZXInKSB7XHJcbiAgICAgIGlmIChDT1VOVCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVyblxyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpbm5lcignaWYoJywgQ09VTlQsICcpeycpO1xyXG4gICAgICBpbm5lci5leGl0KCd9Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIElOU1RBTkNFUywgRVhUX0lOU1RBTkNJTkc7XHJcbiAgICBpZiAoZXh0SW5zdGFuY2luZykge1xyXG4gICAgICBJTlNUQU5DRVMgPSBlbWl0VmFsdWUoU19JTlNUQU5DRVMpO1xyXG4gICAgICBFWFRfSU5TVEFOQ0lORyA9IGVudi5pbnN0YW5jaW5nO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBFTEVNRU5UX1RZUEUgPSBFTEVNRU5UUyArICcudHlwZSc7XHJcblxyXG4gICAgdmFyIGVsZW1lbnRzU3RhdGljID0gZHJhd09wdGlvbnMuZWxlbWVudHMgJiYgaXNTdGF0aWMoZHJhd09wdGlvbnMuZWxlbWVudHMpO1xyXG5cclxuICAgIGZ1bmN0aW9uIGVtaXRJbnN0YW5jaW5nICgpIHtcclxuICAgICAgZnVuY3Rpb24gZHJhd0VsZW1lbnRzICgpIHtcclxuICAgICAgICBpbm5lcihFWFRfSU5TVEFOQ0lORywgJy5kcmF3RWxlbWVudHNJbnN0YW5jZWRBTkdMRSgnLCBbXHJcbiAgICAgICAgICBQUklNSVRJVkUsXHJcbiAgICAgICAgICBDT1VOVCxcclxuICAgICAgICAgIEVMRU1FTlRfVFlQRSxcclxuICAgICAgICAgIE9GRlNFVCArICc8PCgoJyArIEVMRU1FTlRfVFlQRSArICctJyArIEdMX1VOU0lHTkVEX0JZVEUkOCArICcpPj4xKScsXHJcbiAgICAgICAgICBJTlNUQU5DRVNcclxuICAgICAgICBdLCAnKTsnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gZHJhd0FycmF5cyAoKSB7XHJcbiAgICAgICAgaW5uZXIoRVhUX0lOU1RBTkNJTkcsICcuZHJhd0FycmF5c0luc3RhbmNlZEFOR0xFKCcsXHJcbiAgICAgICAgICBbUFJJTUlUSVZFLCBPRkZTRVQsIENPVU5ULCBJTlNUQU5DRVNdLCAnKTsnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKEVMRU1FTlRTKSB7XHJcbiAgICAgICAgaWYgKCFlbGVtZW50c1N0YXRpYykge1xyXG4gICAgICAgICAgaW5uZXIoJ2lmKCcsIEVMRU1FTlRTLCAnKXsnKTtcclxuICAgICAgICAgIGRyYXdFbGVtZW50cygpO1xyXG4gICAgICAgICAgaW5uZXIoJ31lbHNleycpO1xyXG4gICAgICAgICAgZHJhd0FycmF5cygpO1xyXG4gICAgICAgICAgaW5uZXIoJ30nKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZHJhd0VsZW1lbnRzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRyYXdBcnJheXMoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGVtaXRSZWd1bGFyICgpIHtcclxuICAgICAgZnVuY3Rpb24gZHJhd0VsZW1lbnRzICgpIHtcclxuICAgICAgICBpbm5lcihHTCArICcuZHJhd0VsZW1lbnRzKCcgKyBbXHJcbiAgICAgICAgICBQUklNSVRJVkUsXHJcbiAgICAgICAgICBDT1VOVCxcclxuICAgICAgICAgIEVMRU1FTlRfVFlQRSxcclxuICAgICAgICAgIE9GRlNFVCArICc8PCgoJyArIEVMRU1FTlRfVFlQRSArICctJyArIEdMX1VOU0lHTkVEX0JZVEUkOCArICcpPj4xKSdcclxuICAgICAgICBdICsgJyk7Jyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIGRyYXdBcnJheXMgKCkge1xyXG4gICAgICAgIGlubmVyKEdMICsgJy5kcmF3QXJyYXlzKCcgKyBbUFJJTUlUSVZFLCBPRkZTRVQsIENPVU5UXSArICcpOycpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoRUxFTUVOVFMpIHtcclxuICAgICAgICBpZiAoIWVsZW1lbnRzU3RhdGljKSB7XHJcbiAgICAgICAgICBpbm5lcignaWYoJywgRUxFTUVOVFMsICcpeycpO1xyXG4gICAgICAgICAgZHJhd0VsZW1lbnRzKCk7XHJcbiAgICAgICAgICBpbm5lcignfWVsc2V7Jyk7XHJcbiAgICAgICAgICBkcmF3QXJyYXlzKCk7XHJcbiAgICAgICAgICBpbm5lcignfScpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBkcmF3RWxlbWVudHMoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZHJhd0FycmF5cygpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGV4dEluc3RhbmNpbmcgJiYgKHR5cGVvZiBJTlNUQU5DRVMgIT09ICdudW1iZXInIHx8IElOU1RBTkNFUyA+PSAwKSkge1xyXG4gICAgICBpZiAodHlwZW9mIElOU1RBTkNFUyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICBpbm5lcignaWYoJywgSU5TVEFOQ0VTLCAnPjApeycpO1xyXG4gICAgICAgIGVtaXRJbnN0YW5jaW5nKCk7XHJcbiAgICAgICAgaW5uZXIoJ31lbHNlIGlmKCcsIElOU1RBTkNFUywgJzwwKXsnKTtcclxuICAgICAgICBlbWl0UmVndWxhcigpO1xyXG4gICAgICAgIGlubmVyKCd9Jyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZW1pdEluc3RhbmNpbmcoKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZW1pdFJlZ3VsYXIoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNyZWF0ZUJvZHkgKGVtaXRCb2R5LCBwYXJlbnRFbnYsIGFyZ3MsIHByb2dyYW0sIGNvdW50KSB7XHJcbiAgICB2YXIgZW52ID0gY3JlYXRlUkVHTEVudmlyb25tZW50KCk7XHJcbiAgICB2YXIgc2NvcGUgPSBlbnYucHJvYygnYm9keScsIGNvdW50KTtcclxuICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xyXG4gICAgICBlbnYuY29tbWFuZFN0ciA9IHBhcmVudEVudi5jb21tYW5kU3RyO1xyXG4gICAgICBlbnYuY29tbWFuZCA9IGVudi5saW5rKHBhcmVudEVudi5jb21tYW5kU3RyKTtcclxuICAgIH0pO1xyXG4gICAgaWYgKGV4dEluc3RhbmNpbmcpIHtcclxuICAgICAgZW52Lmluc3RhbmNpbmcgPSBzY29wZS5kZWYoXHJcbiAgICAgICAgZW52LnNoYXJlZC5leHRlbnNpb25zLCAnLmFuZ2xlX2luc3RhbmNlZF9hcnJheXMnKTtcclxuICAgIH1cclxuICAgIGVtaXRCb2R5KGVudiwgc2NvcGUsIGFyZ3MsIHByb2dyYW0pO1xyXG4gICAgcmV0dXJuIGVudi5jb21waWxlKCkuYm9keVxyXG4gIH1cclxuXHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgLy8gRFJBVyBQUk9DXHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgZnVuY3Rpb24gZW1pdERyYXdCb2R5IChlbnYsIGRyYXcsIGFyZ3MsIHByb2dyYW0pIHtcclxuICAgIGluamVjdEV4dGVuc2lvbnMoZW52LCBkcmF3KTtcclxuICAgIGVtaXRBdHRyaWJ1dGVzKGVudiwgZHJhdywgYXJncywgcHJvZ3JhbS5hdHRyaWJ1dGVzLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0cnVlXHJcbiAgICB9KTtcclxuICAgIGVtaXRVbmlmb3JtcyhlbnYsIGRyYXcsIGFyZ3MsIHByb2dyYW0udW5pZm9ybXMsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRydWVcclxuICAgIH0pO1xyXG4gICAgZW1pdERyYXcoZW52LCBkcmF3LCBkcmF3LCBhcmdzKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGVtaXREcmF3UHJvYyAoZW52LCBhcmdzKSB7XHJcbiAgICB2YXIgZHJhdyA9IGVudi5wcm9jKCdkcmF3JywgMSk7XHJcblxyXG4gICAgaW5qZWN0RXh0ZW5zaW9ucyhlbnYsIGRyYXcpO1xyXG5cclxuICAgIGVtaXRDb250ZXh0KGVudiwgZHJhdywgYXJncy5jb250ZXh0KTtcclxuICAgIGVtaXRQb2xsRnJhbWVidWZmZXIoZW52LCBkcmF3LCBhcmdzLmZyYW1lYnVmZmVyKTtcclxuXHJcbiAgICBlbWl0UG9sbFN0YXRlKGVudiwgZHJhdywgYXJncyk7XHJcbiAgICBlbWl0U2V0T3B0aW9ucyhlbnYsIGRyYXcsIGFyZ3Muc3RhdGUpO1xyXG5cclxuICAgIGVtaXRQcm9maWxlKGVudiwgZHJhdywgYXJncywgZmFsc2UsIHRydWUpO1xyXG5cclxuICAgIHZhciBwcm9ncmFtID0gYXJncy5zaGFkZXIucHJvZ1Zhci5hcHBlbmQoZW52LCBkcmF3KTtcclxuICAgIGRyYXcoZW52LnNoYXJlZC5nbCwgJy51c2VQcm9ncmFtKCcsIHByb2dyYW0sICcucHJvZ3JhbSk7Jyk7XHJcblxyXG4gICAgaWYgKGFyZ3Muc2hhZGVyLnByb2dyYW0pIHtcclxuICAgICAgZW1pdERyYXdCb2R5KGVudiwgZHJhdywgYXJncywgYXJncy5zaGFkZXIucHJvZ3JhbSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YXIgZHJhd0NhY2hlID0gZW52Lmdsb2JhbC5kZWYoJ3t9Jyk7XHJcbiAgICAgIHZhciBQUk9HX0lEID0gZHJhdy5kZWYocHJvZ3JhbSwgJy5pZCcpO1xyXG4gICAgICB2YXIgQ0FDSEVEX1BST0MgPSBkcmF3LmRlZihkcmF3Q2FjaGUsICdbJywgUFJPR19JRCwgJ10nKTtcclxuICAgICAgZHJhdyhcclxuICAgICAgICBlbnYuY29uZChDQUNIRURfUFJPQylcclxuICAgICAgICAgIC50aGVuKENBQ0hFRF9QUk9DLCAnLmNhbGwodGhpcyxhMCk7JylcclxuICAgICAgICAgIC5lbHNlKFxyXG4gICAgICAgICAgICBDQUNIRURfUFJPQywgJz0nLCBkcmF3Q2FjaGUsICdbJywgUFJPR19JRCwgJ109JyxcclxuICAgICAgICAgICAgZW52LmxpbmsoZnVuY3Rpb24gKHByb2dyYW0pIHtcclxuICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQm9keShlbWl0RHJhd0JvZHksIGVudiwgYXJncywgcHJvZ3JhbSwgMSlcclxuICAgICAgICAgICAgfSksICcoJywgcHJvZ3JhbSwgJyk7JyxcclxuICAgICAgICAgICAgQ0FDSEVEX1BST0MsICcuY2FsbCh0aGlzLGEwKTsnKSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKE9iamVjdC5rZXlzKGFyZ3Muc3RhdGUpLmxlbmd0aCA+IDApIHtcclxuICAgICAgZHJhdyhlbnYuc2hhcmVkLmN1cnJlbnQsICcuZGlydHk9dHJ1ZTsnKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gIC8vIEJBVENIIFBST0NcclxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgZnVuY3Rpb24gZW1pdEJhdGNoRHluYW1pY1NoYWRlckJvZHkgKGVudiwgc2NvcGUsIGFyZ3MsIHByb2dyYW0pIHtcclxuICAgIGVudi5iYXRjaElkID0gJ2ExJztcclxuXHJcbiAgICBpbmplY3RFeHRlbnNpb25zKGVudiwgc2NvcGUpO1xyXG5cclxuICAgIGZ1bmN0aW9uIGFsbCAoKSB7XHJcbiAgICAgIHJldHVybiB0cnVlXHJcbiAgICB9XHJcblxyXG4gICAgZW1pdEF0dHJpYnV0ZXMoZW52LCBzY29wZSwgYXJncywgcHJvZ3JhbS5hdHRyaWJ1dGVzLCBhbGwpO1xyXG4gICAgZW1pdFVuaWZvcm1zKGVudiwgc2NvcGUsIGFyZ3MsIHByb2dyYW0udW5pZm9ybXMsIGFsbCk7XHJcbiAgICBlbWl0RHJhdyhlbnYsIHNjb3BlLCBzY29wZSwgYXJncyk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBlbWl0QmF0Y2hCb2R5IChlbnYsIHNjb3BlLCBhcmdzLCBwcm9ncmFtKSB7XHJcbiAgICBpbmplY3RFeHRlbnNpb25zKGVudiwgc2NvcGUpO1xyXG5cclxuICAgIHZhciBjb250ZXh0RHluYW1pYyA9IGFyZ3MuY29udGV4dERlcDtcclxuXHJcbiAgICB2YXIgQkFUQ0hfSUQgPSBzY29wZS5kZWYoKTtcclxuICAgIHZhciBQUk9QX0xJU1QgPSAnYTAnO1xyXG4gICAgdmFyIE5VTV9QUk9QUyA9ICdhMSc7XHJcbiAgICB2YXIgUFJPUFMgPSBzY29wZS5kZWYoKTtcclxuICAgIGVudi5zaGFyZWQucHJvcHMgPSBQUk9QUztcclxuICAgIGVudi5iYXRjaElkID0gQkFUQ0hfSUQ7XHJcblxyXG4gICAgdmFyIG91dGVyID0gZW52LnNjb3BlKCk7XHJcbiAgICB2YXIgaW5uZXIgPSBlbnYuc2NvcGUoKTtcclxuXHJcbiAgICBzY29wZShcclxuICAgICAgb3V0ZXIuZW50cnksXHJcbiAgICAgICdmb3IoJywgQkFUQ0hfSUQsICc9MDsnLCBCQVRDSF9JRCwgJzwnLCBOVU1fUFJPUFMsICc7KysnLCBCQVRDSF9JRCwgJyl7JyxcclxuICAgICAgUFJPUFMsICc9JywgUFJPUF9MSVNULCAnWycsIEJBVENIX0lELCAnXTsnLFxyXG4gICAgICBpbm5lcixcclxuICAgICAgJ30nLFxyXG4gICAgICBvdXRlci5leGl0KTtcclxuXHJcbiAgICBmdW5jdGlvbiBpc0lubmVyRGVmbiAoZGVmbikge1xyXG4gICAgICByZXR1cm4gKChkZWZuLmNvbnRleHREZXAgJiYgY29udGV4dER5bmFtaWMpIHx8IGRlZm4ucHJvcERlcClcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpc091dGVyRGVmbiAoZGVmbikge1xyXG4gICAgICByZXR1cm4gIWlzSW5uZXJEZWZuKGRlZm4pXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGFyZ3MubmVlZHNDb250ZXh0KSB7XHJcbiAgICAgIGVtaXRDb250ZXh0KGVudiwgaW5uZXIsIGFyZ3MuY29udGV4dCk7XHJcbiAgICB9XHJcbiAgICBpZiAoYXJncy5uZWVkc0ZyYW1lYnVmZmVyKSB7XHJcbiAgICAgIGVtaXRQb2xsRnJhbWVidWZmZXIoZW52LCBpbm5lciwgYXJncy5mcmFtZWJ1ZmZlcik7XHJcbiAgICB9XHJcbiAgICBlbWl0U2V0T3B0aW9ucyhlbnYsIGlubmVyLCBhcmdzLnN0YXRlLCBpc0lubmVyRGVmbik7XHJcblxyXG4gICAgaWYgKGFyZ3MucHJvZmlsZSAmJiBpc0lubmVyRGVmbihhcmdzLnByb2ZpbGUpKSB7XHJcbiAgICAgIGVtaXRQcm9maWxlKGVudiwgaW5uZXIsIGFyZ3MsIGZhbHNlLCB0cnVlKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXByb2dyYW0pIHtcclxuICAgICAgdmFyIHByb2dDYWNoZSA9IGVudi5nbG9iYWwuZGVmKCd7fScpO1xyXG4gICAgICB2YXIgUFJPR1JBTSA9IGFyZ3Muc2hhZGVyLnByb2dWYXIuYXBwZW5kKGVudiwgaW5uZXIpO1xyXG4gICAgICB2YXIgUFJPR19JRCA9IGlubmVyLmRlZihQUk9HUkFNLCAnLmlkJyk7XHJcbiAgICAgIHZhciBDQUNIRURfUFJPQyA9IGlubmVyLmRlZihwcm9nQ2FjaGUsICdbJywgUFJPR19JRCwgJ10nKTtcclxuICAgICAgaW5uZXIoXHJcbiAgICAgICAgZW52LnNoYXJlZC5nbCwgJy51c2VQcm9ncmFtKCcsIFBST0dSQU0sICcucHJvZ3JhbSk7JyxcclxuICAgICAgICAnaWYoIScsIENBQ0hFRF9QUk9DLCAnKXsnLFxyXG4gICAgICAgIENBQ0hFRF9QUk9DLCAnPScsIHByb2dDYWNoZSwgJ1snLCBQUk9HX0lELCAnXT0nLFxyXG4gICAgICAgIGVudi5saW5rKGZ1bmN0aW9uIChwcm9ncmFtKSB7XHJcbiAgICAgICAgICByZXR1cm4gY3JlYXRlQm9keShcclxuICAgICAgICAgICAgZW1pdEJhdGNoRHluYW1pY1NoYWRlckJvZHksIGVudiwgYXJncywgcHJvZ3JhbSwgMilcclxuICAgICAgICB9KSwgJygnLCBQUk9HUkFNLCAnKTt9JyxcclxuICAgICAgICBDQUNIRURfUFJPQywgJy5jYWxsKHRoaXMsYTBbJywgQkFUQ0hfSUQsICddLCcsIEJBVENIX0lELCAnKTsnKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGVtaXRBdHRyaWJ1dGVzKGVudiwgb3V0ZXIsIGFyZ3MsIHByb2dyYW0uYXR0cmlidXRlcywgaXNPdXRlckRlZm4pO1xyXG4gICAgICBlbWl0QXR0cmlidXRlcyhlbnYsIGlubmVyLCBhcmdzLCBwcm9ncmFtLmF0dHJpYnV0ZXMsIGlzSW5uZXJEZWZuKTtcclxuICAgICAgZW1pdFVuaWZvcm1zKGVudiwgb3V0ZXIsIGFyZ3MsIHByb2dyYW0udW5pZm9ybXMsIGlzT3V0ZXJEZWZuKTtcclxuICAgICAgZW1pdFVuaWZvcm1zKGVudiwgaW5uZXIsIGFyZ3MsIHByb2dyYW0udW5pZm9ybXMsIGlzSW5uZXJEZWZuKTtcclxuICAgICAgZW1pdERyYXcoZW52LCBvdXRlciwgaW5uZXIsIGFyZ3MpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZW1pdEJhdGNoUHJvYyAoZW52LCBhcmdzKSB7XHJcbiAgICB2YXIgYmF0Y2ggPSBlbnYucHJvYygnYmF0Y2gnLCAyKTtcclxuICAgIGVudi5iYXRjaElkID0gJzAnO1xyXG5cclxuICAgIGluamVjdEV4dGVuc2lvbnMoZW52LCBiYXRjaCk7XHJcblxyXG4gICAgLy8gQ2hlY2sgaWYgYW55IGNvbnRleHQgdmFyaWFibGVzIGRlcGVuZCBvbiBwcm9wc1xyXG4gICAgdmFyIGNvbnRleHREeW5hbWljID0gZmFsc2U7XHJcbiAgICB2YXIgbmVlZHNDb250ZXh0ID0gdHJ1ZTtcclxuICAgIE9iamVjdC5rZXlzKGFyZ3MuY29udGV4dCkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICBjb250ZXh0RHluYW1pYyA9IGNvbnRleHREeW5hbWljIHx8IGFyZ3MuY29udGV4dFtuYW1lXS5wcm9wRGVwO1xyXG4gICAgfSk7XHJcbiAgICBpZiAoIWNvbnRleHREeW5hbWljKSB7XHJcbiAgICAgIGVtaXRDb250ZXh0KGVudiwgYmF0Y2gsIGFyZ3MuY29udGV4dCk7XHJcbiAgICAgIG5lZWRzQ29udGV4dCA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGZyYW1lYnVmZmVyIHN0YXRlIGFmZmVjdHMgZnJhbWVidWZmZXJXaWR0aC9oZWlnaHQgY29udGV4dCB2YXJzXHJcbiAgICB2YXIgZnJhbWVidWZmZXIgPSBhcmdzLmZyYW1lYnVmZmVyO1xyXG4gICAgdmFyIG5lZWRzRnJhbWVidWZmZXIgPSBmYWxzZTtcclxuICAgIGlmIChmcmFtZWJ1ZmZlcikge1xyXG4gICAgICBpZiAoZnJhbWVidWZmZXIucHJvcERlcCkge1xyXG4gICAgICAgIGNvbnRleHREeW5hbWljID0gbmVlZHNGcmFtZWJ1ZmZlciA9IHRydWU7XHJcbiAgICAgIH0gZWxzZSBpZiAoZnJhbWVidWZmZXIuY29udGV4dERlcCAmJiBjb250ZXh0RHluYW1pYykge1xyXG4gICAgICAgIG5lZWRzRnJhbWVidWZmZXIgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghbmVlZHNGcmFtZWJ1ZmZlcikge1xyXG4gICAgICAgIGVtaXRQb2xsRnJhbWVidWZmZXIoZW52LCBiYXRjaCwgZnJhbWVidWZmZXIpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBlbWl0UG9sbEZyYW1lYnVmZmVyKGVudiwgYmF0Y2gsIG51bGwpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHZpZXdwb3J0IGlzIHdlaXJkIGJlY2F1c2UgaXQgY2FuIGFmZmVjdCBjb250ZXh0IHZhcnNcclxuICAgIGlmIChhcmdzLnN0YXRlLnZpZXdwb3J0ICYmIGFyZ3Muc3RhdGUudmlld3BvcnQucHJvcERlcCkge1xyXG4gICAgICBjb250ZXh0RHluYW1pYyA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaXNJbm5lckRlZm4gKGRlZm4pIHtcclxuICAgICAgcmV0dXJuIChkZWZuLmNvbnRleHREZXAgJiYgY29udGV4dER5bmFtaWMpIHx8IGRlZm4ucHJvcERlcFxyXG4gICAgfVxyXG5cclxuICAgIC8vIHNldCB3ZWJnbCBvcHRpb25zXHJcbiAgICBlbWl0UG9sbFN0YXRlKGVudiwgYmF0Y2gsIGFyZ3MpO1xyXG4gICAgZW1pdFNldE9wdGlvbnMoZW52LCBiYXRjaCwgYXJncy5zdGF0ZSwgZnVuY3Rpb24gKGRlZm4pIHtcclxuICAgICAgcmV0dXJuICFpc0lubmVyRGVmbihkZWZuKVxyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKCFhcmdzLnByb2ZpbGUgfHwgIWlzSW5uZXJEZWZuKGFyZ3MucHJvZmlsZSkpIHtcclxuICAgICAgZW1pdFByb2ZpbGUoZW52LCBiYXRjaCwgYXJncywgZmFsc2UsICdhMScpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNhdmUgdGhlc2UgdmFsdWVzIHRvIGFyZ3Mgc28gdGhhdCB0aGUgYmF0Y2ggYm9keSByb3V0aW5lIGNhbiB1c2UgdGhlbVxyXG4gICAgYXJncy5jb250ZXh0RGVwID0gY29udGV4dER5bmFtaWM7XHJcbiAgICBhcmdzLm5lZWRzQ29udGV4dCA9IG5lZWRzQ29udGV4dDtcclxuICAgIGFyZ3MubmVlZHNGcmFtZWJ1ZmZlciA9IG5lZWRzRnJhbWVidWZmZXI7XHJcblxyXG4gICAgLy8gZGV0ZXJtaW5lIGlmIHNoYWRlciBpcyBkeW5hbWljXHJcbiAgICB2YXIgcHJvZ0RlZm4gPSBhcmdzLnNoYWRlci5wcm9nVmFyO1xyXG4gICAgaWYgKChwcm9nRGVmbi5jb250ZXh0RGVwICYmIGNvbnRleHREeW5hbWljKSB8fCBwcm9nRGVmbi5wcm9wRGVwKSB7XHJcbiAgICAgIGVtaXRCYXRjaEJvZHkoXHJcbiAgICAgICAgZW52LFxyXG4gICAgICAgIGJhdGNoLFxyXG4gICAgICAgIGFyZ3MsXHJcbiAgICAgICAgbnVsbCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YXIgUFJPR1JBTSA9IHByb2dEZWZuLmFwcGVuZChlbnYsIGJhdGNoKTtcclxuICAgICAgYmF0Y2goZW52LnNoYXJlZC5nbCwgJy51c2VQcm9ncmFtKCcsIFBST0dSQU0sICcucHJvZ3JhbSk7Jyk7XHJcbiAgICAgIGlmIChhcmdzLnNoYWRlci5wcm9ncmFtKSB7XHJcbiAgICAgICAgZW1pdEJhdGNoQm9keShcclxuICAgICAgICAgIGVudixcclxuICAgICAgICAgIGJhdGNoLFxyXG4gICAgICAgICAgYXJncyxcclxuICAgICAgICAgIGFyZ3Muc2hhZGVyLnByb2dyYW0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhciBiYXRjaENhY2hlID0gZW52Lmdsb2JhbC5kZWYoJ3t9Jyk7XHJcbiAgICAgICAgdmFyIFBST0dfSUQgPSBiYXRjaC5kZWYoUFJPR1JBTSwgJy5pZCcpO1xyXG4gICAgICAgIHZhciBDQUNIRURfUFJPQyA9IGJhdGNoLmRlZihiYXRjaENhY2hlLCAnWycsIFBST0dfSUQsICddJyk7XHJcbiAgICAgICAgYmF0Y2goXHJcbiAgICAgICAgICBlbnYuY29uZChDQUNIRURfUFJPQylcclxuICAgICAgICAgICAgLnRoZW4oQ0FDSEVEX1BST0MsICcuY2FsbCh0aGlzLGEwLGExKTsnKVxyXG4gICAgICAgICAgICAuZWxzZShcclxuICAgICAgICAgICAgICBDQUNIRURfUFJPQywgJz0nLCBiYXRjaENhY2hlLCAnWycsIFBST0dfSUQsICddPScsXHJcbiAgICAgICAgICAgICAgZW52LmxpbmsoZnVuY3Rpb24gKHByb2dyYW0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVCb2R5KGVtaXRCYXRjaEJvZHksIGVudiwgYXJncywgcHJvZ3JhbSwgMilcclxuICAgICAgICAgICAgICB9KSwgJygnLCBQUk9HUkFNLCAnKTsnLFxyXG4gICAgICAgICAgICAgIENBQ0hFRF9QUk9DLCAnLmNhbGwodGhpcyxhMCxhMSk7JykpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKE9iamVjdC5rZXlzKGFyZ3Muc3RhdGUpLmxlbmd0aCA+IDApIHtcclxuICAgICAgYmF0Y2goZW52LnNoYXJlZC5jdXJyZW50LCAnLmRpcnR5PXRydWU7Jyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAvLyBTQ09QRSBDT01NQU5EXHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgZnVuY3Rpb24gZW1pdFNjb3BlUHJvYyAoZW52LCBhcmdzKSB7XHJcbiAgICB2YXIgc2NvcGUgPSBlbnYucHJvYygnc2NvcGUnLCAzKTtcclxuICAgIGVudi5iYXRjaElkID0gJ2EyJztcclxuXHJcbiAgICB2YXIgc2hhcmVkID0gZW52LnNoYXJlZDtcclxuICAgIHZhciBDVVJSRU5UX1NUQVRFID0gc2hhcmVkLmN1cnJlbnQ7XHJcblxyXG4gICAgZW1pdENvbnRleHQoZW52LCBzY29wZSwgYXJncy5jb250ZXh0KTtcclxuXHJcbiAgICBpZiAoYXJncy5mcmFtZWJ1ZmZlcikge1xyXG4gICAgICBhcmdzLmZyYW1lYnVmZmVyLmFwcGVuZChlbnYsIHNjb3BlKTtcclxuICAgIH1cclxuXHJcbiAgICBzb3J0U3RhdGUoT2JqZWN0LmtleXMoYXJncy5zdGF0ZSkpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgdmFyIGRlZm4gPSBhcmdzLnN0YXRlW25hbWVdO1xyXG4gICAgICB2YXIgdmFsdWUgPSBkZWZuLmFwcGVuZChlbnYsIHNjb3BlKTtcclxuICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSkge1xyXG4gICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKHYsIGkpIHtcclxuICAgICAgICAgIHNjb3BlLnNldChlbnYubmV4dFtuYW1lXSwgJ1snICsgaSArICddJywgdik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc2NvcGUuc2V0KHNoYXJlZC5uZXh0LCAnLicgKyBuYW1lLCB2YWx1ZSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGVtaXRQcm9maWxlKGVudiwgc2NvcGUsIGFyZ3MsIHRydWUsIHRydWUpXHJcblxyXG4gICAgO1tTX0VMRU1FTlRTLCBTX09GRlNFVCwgU19DT1VOVCwgU19JTlNUQU5DRVMsIFNfUFJJTUlUSVZFXS5mb3JFYWNoKFxyXG4gICAgICBmdW5jdGlvbiAob3B0KSB7XHJcbiAgICAgICAgdmFyIHZhcmlhYmxlID0gYXJncy5kcmF3W29wdF07XHJcbiAgICAgICAgaWYgKCF2YXJpYWJsZSkge1xyXG4gICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNjb3BlLnNldChzaGFyZWQuZHJhdywgJy4nICsgb3B0LCAnJyArIHZhcmlhYmxlLmFwcGVuZChlbnYsIHNjb3BlKSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIE9iamVjdC5rZXlzKGFyZ3MudW5pZm9ybXMpLmZvckVhY2goZnVuY3Rpb24gKG9wdCkge1xyXG4gICAgICBzY29wZS5zZXQoXHJcbiAgICAgICAgc2hhcmVkLnVuaWZvcm1zLFxyXG4gICAgICAgICdbJyArIHN0cmluZ1N0b3JlLmlkKG9wdCkgKyAnXScsXHJcbiAgICAgICAgYXJncy51bmlmb3Jtc1tvcHRdLmFwcGVuZChlbnYsIHNjb3BlKSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBPYmplY3Qua2V5cyhhcmdzLmF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgdmFyIHJlY29yZCA9IGFyZ3MuYXR0cmlidXRlc1tuYW1lXS5hcHBlbmQoZW52LCBzY29wZSk7XHJcbiAgICAgIHZhciBzY29wZUF0dHJpYiA9IGVudi5zY29wZUF0dHJpYihuYW1lKTtcclxuICAgICAgT2JqZWN0LmtleXMobmV3IEF0dHJpYnV0ZVJlY29yZCgpKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XHJcbiAgICAgICAgc2NvcGUuc2V0KHNjb3BlQXR0cmliLCAnLicgKyBwcm9wLCByZWNvcmRbcHJvcF0pO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGZ1bmN0aW9uIHNhdmVTaGFkZXIgKG5hbWUpIHtcclxuICAgICAgdmFyIHNoYWRlciA9IGFyZ3Muc2hhZGVyW25hbWVdO1xyXG4gICAgICBpZiAoc2hhZGVyKSB7XHJcbiAgICAgICAgc2NvcGUuc2V0KHNoYXJlZC5zaGFkZXIsICcuJyArIG5hbWUsIHNoYWRlci5hcHBlbmQoZW52LCBzY29wZSkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBzYXZlU2hhZGVyKFNfVkVSVCk7XHJcbiAgICBzYXZlU2hhZGVyKFNfRlJBRyk7XHJcblxyXG4gICAgaWYgKE9iamVjdC5rZXlzKGFyZ3Muc3RhdGUpLmxlbmd0aCA+IDApIHtcclxuICAgICAgc2NvcGUoQ1VSUkVOVF9TVEFURSwgJy5kaXJ0eT10cnVlOycpO1xyXG4gICAgICBzY29wZS5leGl0KENVUlJFTlRfU1RBVEUsICcuZGlydHk9dHJ1ZTsnKTtcclxuICAgIH1cclxuXHJcbiAgICBzY29wZSgnYTEoJywgZW52LnNoYXJlZC5jb250ZXh0LCAnLGEwLCcsIGVudi5iYXRjaElkLCAnKTsnKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGlzRHluYW1pY09iamVjdCAob2JqZWN0KSB7XHJcbiAgICBpZiAodHlwZW9mIG9iamVjdCAhPT0gJ29iamVjdCcgfHwgaXNBcnJheUxpa2Uob2JqZWN0KSkge1xyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuICAgIHZhciBwcm9wcyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgIGlmIChkeW5hbWljLmlzRHluYW1pYyhvYmplY3RbcHJvcHNbaV1dKSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc3BsYXRPYmplY3QgKGVudiwgb3B0aW9ucywgbmFtZSkge1xyXG4gICAgdmFyIG9iamVjdCA9IG9wdGlvbnMuc3RhdGljW25hbWVdO1xyXG4gICAgaWYgKCFvYmplY3QgfHwgIWlzRHluYW1pY09iamVjdChvYmplY3QpKSB7XHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG5cclxuICAgIHZhciBnbG9iYWxzID0gZW52Lmdsb2JhbDtcclxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcclxuICAgIHZhciB0aGlzRGVwID0gZmFsc2U7XHJcbiAgICB2YXIgY29udGV4dERlcCA9IGZhbHNlO1xyXG4gICAgdmFyIHByb3BEZXAgPSBmYWxzZTtcclxuICAgIHZhciBvYmplY3RSZWYgPSBlbnYuZ2xvYmFsLmRlZigne30nKTtcclxuICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgIHZhciB2YWx1ZSA9IG9iamVjdFtrZXldO1xyXG4gICAgICBpZiAoZHluYW1pYy5pc0R5bmFtaWModmFsdWUpKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XSA9IGR5bmFtaWMudW5ib3godmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZGVwcyA9IGNyZWF0ZUR5bmFtaWNEZWNsKHZhbHVlLCBudWxsKTtcclxuICAgICAgICB0aGlzRGVwID0gdGhpc0RlcCB8fCBkZXBzLnRoaXNEZXA7XHJcbiAgICAgICAgcHJvcERlcCA9IHByb3BEZXAgfHwgZGVwcy5wcm9wRGVwO1xyXG4gICAgICAgIGNvbnRleHREZXAgPSBjb250ZXh0RGVwIHx8IGRlcHMuY29udGV4dERlcDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBnbG9iYWxzKG9iamVjdFJlZiwgJy4nLCBrZXksICc9Jyk7XHJcbiAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcclxuICAgICAgICAgIGNhc2UgJ251bWJlcic6XHJcbiAgICAgICAgICAgIGdsb2JhbHModmFsdWUpO1xyXG4gICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgY2FzZSAnc3RyaW5nJzpcclxuICAgICAgICAgICAgZ2xvYmFscygnXCInLCB2YWx1ZSwgJ1wiJyk7XHJcbiAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICBjYXNlICdvYmplY3QnOlxyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICBnbG9iYWxzKCdbJywgdmFsdWUuam9pbigpLCAnXScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBnbG9iYWxzKGVudi5saW5rKHZhbHVlKSk7XHJcbiAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdsb2JhbHMoJzsnKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgZnVuY3Rpb24gYXBwZW5kQmxvY2sgKGVudiwgYmxvY2spIHtcclxuICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3Rba2V5XTtcclxuICAgICAgICBpZiAoIWR5bmFtaWMuaXNEeW5hbWljKHZhbHVlKSkge1xyXG4gICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZWYgPSBlbnYuaW52b2tlKGJsb2NrLCB2YWx1ZSk7XHJcbiAgICAgICAgYmxvY2sob2JqZWN0UmVmLCAnLicsIGtleSwgJz0nLCByZWYsICc7Jyk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIG9wdGlvbnMuZHluYW1pY1tuYW1lXSA9IG5ldyBkeW5hbWljLkR5bmFtaWNWYXJpYWJsZShEWU5fVEhVTkssIHtcclxuICAgICAgdGhpc0RlcDogdGhpc0RlcCxcclxuICAgICAgY29udGV4dERlcDogY29udGV4dERlcCxcclxuICAgICAgcHJvcERlcDogcHJvcERlcCxcclxuICAgICAgcmVmOiBvYmplY3RSZWYsXHJcbiAgICAgIGFwcGVuZDogYXBwZW5kQmxvY2tcclxuICAgIH0pO1xyXG4gICAgZGVsZXRlIG9wdGlvbnMuc3RhdGljW25hbWVdO1xyXG4gIH1cclxuXHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgLy8gTUFJTiBEUkFXIENPTU1BTkRcclxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICBmdW5jdGlvbiBjb21waWxlQ29tbWFuZCAob3B0aW9ucywgYXR0cmlidXRlcywgdW5pZm9ybXMsIGNvbnRleHQsIHN0YXRzKSB7XHJcbiAgICB2YXIgZW52ID0gY3JlYXRlUkVHTEVudmlyb25tZW50KCk7XHJcblxyXG4gICAgLy8gbGluayBzdGF0cywgc28gdGhhdCB3ZSBjYW4gZWFzaWx5IGFjY2VzcyBpdCBpbiB0aGUgcHJvZ3JhbS5cclxuICAgIGVudi5zdGF0cyA9IGVudi5saW5rKHN0YXRzKTtcclxuXHJcbiAgICAvLyBzcGxhdCBvcHRpb25zIGFuZCBhdHRyaWJ1dGVzIHRvIGFsbG93IGZvciBkeW5hbWljIG5lc3RlZCBwcm9wZXJ0aWVzXHJcbiAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzLnN0YXRpYykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgIHNwbGF0T2JqZWN0KGVudiwgYXR0cmlidXRlcywga2V5KTtcclxuICAgIH0pO1xyXG4gICAgTkVTVEVEX09QVElPTlMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICBzcGxhdE9iamVjdChlbnYsIG9wdGlvbnMsIG5hbWUpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdmFyIGFyZ3MgPSBwYXJzZUFyZ3VtZW50cyhvcHRpb25zLCBhdHRyaWJ1dGVzLCB1bmlmb3JtcywgY29udGV4dCwgZW52KTtcclxuXHJcbiAgICBlbWl0RHJhd1Byb2MoZW52LCBhcmdzKTtcclxuICAgIGVtaXRTY29wZVByb2MoZW52LCBhcmdzKTtcclxuICAgIGVtaXRCYXRjaFByb2MoZW52LCBhcmdzKTtcclxuXHJcbiAgICByZXR1cm4gZW52LmNvbXBpbGUoKVxyXG4gIH1cclxuXHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgLy8gUE9MTCAvIFJFRlJFU0hcclxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICByZXR1cm4ge1xyXG4gICAgbmV4dDogbmV4dFN0YXRlLFxyXG4gICAgY3VycmVudDogY3VycmVudFN0YXRlLFxyXG4gICAgcHJvY3M6IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBlbnYgPSBjcmVhdGVSRUdMRW52aXJvbm1lbnQoKTtcclxuICAgICAgdmFyIHBvbGwgPSBlbnYucHJvYygncG9sbCcpO1xyXG4gICAgICB2YXIgcmVmcmVzaCA9IGVudi5wcm9jKCdyZWZyZXNoJyk7XHJcbiAgICAgIHZhciBjb21tb24gPSBlbnYuYmxvY2soKTtcclxuICAgICAgcG9sbChjb21tb24pO1xyXG4gICAgICByZWZyZXNoKGNvbW1vbik7XHJcblxyXG4gICAgICB2YXIgc2hhcmVkID0gZW52LnNoYXJlZDtcclxuICAgICAgdmFyIEdMID0gc2hhcmVkLmdsO1xyXG4gICAgICB2YXIgTkVYVF9TVEFURSA9IHNoYXJlZC5uZXh0O1xyXG4gICAgICB2YXIgQ1VSUkVOVF9TVEFURSA9IHNoYXJlZC5jdXJyZW50O1xyXG5cclxuICAgICAgY29tbW9uKENVUlJFTlRfU1RBVEUsICcuZGlydHk9ZmFsc2U7Jyk7XHJcblxyXG4gICAgICBlbWl0UG9sbEZyYW1lYnVmZmVyKGVudiwgcG9sbCk7XHJcbiAgICAgIGVtaXRQb2xsRnJhbWVidWZmZXIoZW52LCByZWZyZXNoLCBudWxsLCB0cnVlKTtcclxuXHJcbiAgICAgIC8vIFJlZnJlc2ggdXBkYXRlcyBhbGwgYXR0cmlidXRlIHN0YXRlIGNoYW5nZXNcclxuICAgICAgdmFyIElOU1RBTkNJTkc7XHJcbiAgICAgIGlmIChleHRJbnN0YW5jaW5nKSB7XHJcbiAgICAgICAgSU5TVEFOQ0lORyA9IGVudi5saW5rKGV4dEluc3RhbmNpbmcpO1xyXG4gICAgICB9XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGltaXRzLm1heEF0dHJpYnV0ZXM7ICsraSkge1xyXG4gICAgICAgIHZhciBCSU5ESU5HID0gcmVmcmVzaC5kZWYoc2hhcmVkLmF0dHJpYnV0ZXMsICdbJywgaSwgJ10nKTtcclxuICAgICAgICB2YXIgaWZ0ZSA9IGVudi5jb25kKEJJTkRJTkcsICcuYnVmZmVyJyk7XHJcbiAgICAgICAgaWZ0ZS50aGVuKFxyXG4gICAgICAgICAgR0wsICcuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoJywgaSwgJyk7JyxcclxuICAgICAgICAgIEdMLCAnLmJpbmRCdWZmZXIoJyxcclxuICAgICAgICAgICAgR0xfQVJSQVlfQlVGRkVSJDEsICcsJyxcclxuICAgICAgICAgICAgQklORElORywgJy5idWZmZXIuYnVmZmVyKTsnLFxyXG4gICAgICAgICAgR0wsICcudmVydGV4QXR0cmliUG9pbnRlcignLFxyXG4gICAgICAgICAgICBpLCAnLCcsXHJcbiAgICAgICAgICAgIEJJTkRJTkcsICcuc2l6ZSwnLFxyXG4gICAgICAgICAgICBCSU5ESU5HLCAnLnR5cGUsJyxcclxuICAgICAgICAgICAgQklORElORywgJy5ub3JtYWxpemVkLCcsXHJcbiAgICAgICAgICAgIEJJTkRJTkcsICcuc3RyaWRlLCcsXHJcbiAgICAgICAgICAgIEJJTkRJTkcsICcub2Zmc2V0KTsnXHJcbiAgICAgICAgKS5lbHNlKFxyXG4gICAgICAgICAgR0wsICcuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KCcsIGksICcpOycsXHJcbiAgICAgICAgICBHTCwgJy52ZXJ0ZXhBdHRyaWI0ZignLFxyXG4gICAgICAgICAgICBpLCAnLCcsXHJcbiAgICAgICAgICAgIEJJTkRJTkcsICcueCwnLFxyXG4gICAgICAgICAgICBCSU5ESU5HLCAnLnksJyxcclxuICAgICAgICAgICAgQklORElORywgJy56LCcsXHJcbiAgICAgICAgICAgIEJJTkRJTkcsICcudyk7JyxcclxuICAgICAgICAgIEJJTkRJTkcsICcuYnVmZmVyPW51bGw7Jyk7XHJcbiAgICAgICAgcmVmcmVzaChpZnRlKTtcclxuICAgICAgICBpZiAoZXh0SW5zdGFuY2luZykge1xyXG4gICAgICAgICAgcmVmcmVzaChcclxuICAgICAgICAgICAgSU5TVEFOQ0lORywgJy52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoJyxcclxuICAgICAgICAgICAgaSwgJywnLFxyXG4gICAgICAgICAgICBCSU5ESU5HLCAnLmRpdmlzb3IpOycpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgT2JqZWN0LmtleXMoR0xfRkxBR1MpLmZvckVhY2goZnVuY3Rpb24gKGZsYWcpIHtcclxuICAgICAgICB2YXIgY2FwID0gR0xfRkxBR1NbZmxhZ107XHJcbiAgICAgICAgdmFyIE5FWFQgPSBjb21tb24uZGVmKE5FWFRfU1RBVEUsICcuJywgZmxhZyk7XHJcbiAgICAgICAgdmFyIGJsb2NrID0gZW52LmJsb2NrKCk7XHJcbiAgICAgICAgYmxvY2soJ2lmKCcsIE5FWFQsICcpeycsXHJcbiAgICAgICAgICBHTCwgJy5lbmFibGUoJywgY2FwLCAnKX1lbHNleycsXHJcbiAgICAgICAgICBHTCwgJy5kaXNhYmxlKCcsIGNhcCwgJyl9JyxcclxuICAgICAgICAgIENVUlJFTlRfU1RBVEUsICcuJywgZmxhZywgJz0nLCBORVhULCAnOycpO1xyXG4gICAgICAgIHJlZnJlc2goYmxvY2spO1xyXG4gICAgICAgIHBvbGwoXHJcbiAgICAgICAgICAnaWYoJywgTkVYVCwgJyE9PScsIENVUlJFTlRfU1RBVEUsICcuJywgZmxhZywgJyl7JyxcclxuICAgICAgICAgIGJsb2NrLFxyXG4gICAgICAgICAgJ30nKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBPYmplY3Qua2V5cyhHTF9WQVJJQUJMRVMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICB2YXIgZnVuYyA9IEdMX1ZBUklBQkxFU1tuYW1lXTtcclxuICAgICAgICB2YXIgaW5pdCA9IGN1cnJlbnRTdGF0ZVtuYW1lXTtcclxuICAgICAgICB2YXIgTkVYVCwgQ1VSUkVOVDtcclxuICAgICAgICB2YXIgYmxvY2sgPSBlbnYuYmxvY2soKTtcclxuICAgICAgICBibG9jayhHTCwgJy4nLCBmdW5jLCAnKCcpO1xyXG4gICAgICAgIGlmIChpc0FycmF5TGlrZShpbml0KSkge1xyXG4gICAgICAgICAgdmFyIG4gPSBpbml0Lmxlbmd0aDtcclxuICAgICAgICAgIE5FWFQgPSBlbnYuZ2xvYmFsLmRlZihORVhUX1NUQVRFLCAnLicsIG5hbWUpO1xyXG4gICAgICAgICAgQ1VSUkVOVCA9IGVudi5nbG9iYWwuZGVmKENVUlJFTlRfU1RBVEUsICcuJywgbmFtZSk7XHJcbiAgICAgICAgICBibG9jayhcclxuICAgICAgICAgICAgbG9vcChuLCBmdW5jdGlvbiAoaSkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBORVhUICsgJ1snICsgaSArICddJ1xyXG4gICAgICAgICAgICB9KSwgJyk7JyxcclxuICAgICAgICAgICAgbG9vcChuLCBmdW5jdGlvbiAoaSkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBDVVJSRU5UICsgJ1snICsgaSArICddPScgKyBORVhUICsgJ1snICsgaSArICddOydcclxuICAgICAgICAgICAgfSkuam9pbignJykpO1xyXG4gICAgICAgICAgcG9sbChcclxuICAgICAgICAgICAgJ2lmKCcsIGxvb3AobiwgZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gTkVYVCArICdbJyArIGkgKyAnXSE9PScgKyBDVVJSRU5UICsgJ1snICsgaSArICddJ1xyXG4gICAgICAgICAgICB9KS5qb2luKCd8fCcpLCAnKXsnLFxyXG4gICAgICAgICAgICBibG9jayxcclxuICAgICAgICAgICAgJ30nKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgTkVYVCA9IGNvbW1vbi5kZWYoTkVYVF9TVEFURSwgJy4nLCBuYW1lKTtcclxuICAgICAgICAgIENVUlJFTlQgPSBjb21tb24uZGVmKENVUlJFTlRfU1RBVEUsICcuJywgbmFtZSk7XHJcbiAgICAgICAgICBibG9jayhcclxuICAgICAgICAgICAgTkVYVCwgJyk7JyxcclxuICAgICAgICAgICAgQ1VSUkVOVF9TVEFURSwgJy4nLCBuYW1lLCAnPScsIE5FWFQsICc7Jyk7XHJcbiAgICAgICAgICBwb2xsKFxyXG4gICAgICAgICAgICAnaWYoJywgTkVYVCwgJyE9PScsIENVUlJFTlQsICcpeycsXHJcbiAgICAgICAgICAgIGJsb2NrLFxyXG4gICAgICAgICAgICAnfScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZWZyZXNoKGJsb2NrKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICByZXR1cm4gZW52LmNvbXBpbGUoKVxyXG4gICAgfSkoKSxcclxuICAgIGNvbXBpbGU6IGNvbXBpbGVDb21tYW5kXHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBzdGF0cyAoKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIGJ1ZmZlckNvdW50OiAwLFxyXG4gICAgZWxlbWVudHNDb3VudDogMCxcclxuICAgIGZyYW1lYnVmZmVyQ291bnQ6IDAsXHJcbiAgICBzaGFkZXJDb3VudDogMCxcclxuICAgIHRleHR1cmVDb3VudDogMCxcclxuICAgIGN1YmVDb3VudDogMCxcclxuICAgIHJlbmRlcmJ1ZmZlckNvdW50OiAwLFxyXG4gICAgbWF4VGV4dHVyZVVuaXRzOiAwXHJcbiAgfVxyXG59XHJcblxyXG52YXIgR0xfUVVFUllfUkVTVUxUX0VYVCA9IDB4ODg2NjtcclxudmFyIEdMX1FVRVJZX1JFU1VMVF9BVkFJTEFCTEVfRVhUID0gMHg4ODY3O1xyXG52YXIgR0xfVElNRV9FTEFQU0VEX0VYVCA9IDB4ODhCRjtcclxuXHJcbnZhciBjcmVhdGVUaW1lciA9IGZ1bmN0aW9uIChnbCwgZXh0ZW5zaW9ucykge1xyXG4gIHZhciBleHRUaW1lciA9IGV4dGVuc2lvbnMuZXh0X2Rpc2pvaW50X3RpbWVyX3F1ZXJ5O1xyXG5cclxuICBpZiAoIWV4dFRpbWVyKSB7XHJcbiAgICByZXR1cm4gbnVsbFxyXG4gIH1cclxuXHJcbiAgLy8gUVVFUlkgUE9PTCBCRUdJTlxyXG4gIHZhciBxdWVyeVBvb2wgPSBbXTtcclxuICBmdW5jdGlvbiBhbGxvY1F1ZXJ5ICgpIHtcclxuICAgIHJldHVybiBxdWVyeVBvb2wucG9wKCkgfHwgZXh0VGltZXIuY3JlYXRlUXVlcnlFWFQoKVxyXG4gIH1cclxuICBmdW5jdGlvbiBmcmVlUXVlcnkgKHF1ZXJ5KSB7XHJcbiAgICBxdWVyeVBvb2wucHVzaChxdWVyeSk7XHJcbiAgfVxyXG4gIC8vIFFVRVJZIFBPT0wgRU5EXHJcblxyXG4gIHZhciBwZW5kaW5nUXVlcmllcyA9IFtdO1xyXG4gIGZ1bmN0aW9uIGJlZ2luUXVlcnkgKHN0YXRzKSB7XHJcbiAgICB2YXIgcXVlcnkgPSBhbGxvY1F1ZXJ5KCk7XHJcbiAgICBleHRUaW1lci5iZWdpblF1ZXJ5RVhUKEdMX1RJTUVfRUxBUFNFRF9FWFQsIHF1ZXJ5KTtcclxuICAgIHBlbmRpbmdRdWVyaWVzLnB1c2gocXVlcnkpO1xyXG4gICAgcHVzaFNjb3BlU3RhdHMocGVuZGluZ1F1ZXJpZXMubGVuZ3RoIC0gMSwgcGVuZGluZ1F1ZXJpZXMubGVuZ3RoLCBzdGF0cyk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBlbmRRdWVyeSAoKSB7XHJcbiAgICBleHRUaW1lci5lbmRRdWVyeUVYVChHTF9USU1FX0VMQVBTRURfRVhUKTtcclxuICB9XHJcblxyXG4gIC8vXHJcbiAgLy8gUGVuZGluZyBzdGF0cyBwb29sLlxyXG4gIC8vXHJcbiAgZnVuY3Rpb24gUGVuZGluZ1N0YXRzICgpIHtcclxuICAgIHRoaXMuc3RhcnRRdWVyeUluZGV4ID0gLTE7XHJcbiAgICB0aGlzLmVuZFF1ZXJ5SW5kZXggPSAtMTtcclxuICAgIHRoaXMuc3VtID0gMDtcclxuICAgIHRoaXMuc3RhdHMgPSBudWxsO1xyXG4gIH1cclxuICB2YXIgcGVuZGluZ1N0YXRzUG9vbCA9IFtdO1xyXG4gIGZ1bmN0aW9uIGFsbG9jUGVuZGluZ1N0YXRzICgpIHtcclxuICAgIHJldHVybiBwZW5kaW5nU3RhdHNQb29sLnBvcCgpIHx8IG5ldyBQZW5kaW5nU3RhdHMoKVxyXG4gIH1cclxuICBmdW5jdGlvbiBmcmVlUGVuZGluZ1N0YXRzIChwZW5kaW5nU3RhdHMpIHtcclxuICAgIHBlbmRpbmdTdGF0c1Bvb2wucHVzaChwZW5kaW5nU3RhdHMpO1xyXG4gIH1cclxuICAvLyBQZW5kaW5nIHN0YXRzIHBvb2wgZW5kXHJcblxyXG4gIHZhciBwZW5kaW5nU3RhdHMgPSBbXTtcclxuICBmdW5jdGlvbiBwdXNoU2NvcGVTdGF0cyAoc3RhcnQsIGVuZCwgc3RhdHMpIHtcclxuICAgIHZhciBwcyA9IGFsbG9jUGVuZGluZ1N0YXRzKCk7XHJcbiAgICBwcy5zdGFydFF1ZXJ5SW5kZXggPSBzdGFydDtcclxuICAgIHBzLmVuZFF1ZXJ5SW5kZXggPSBlbmQ7XHJcbiAgICBwcy5zdW0gPSAwO1xyXG4gICAgcHMuc3RhdHMgPSBzdGF0cztcclxuICAgIHBlbmRpbmdTdGF0cy5wdXNoKHBzKTtcclxuICB9XHJcblxyXG4gIC8vIHdlIHNob3VsZCBjYWxsIHRoaXMgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgZnJhbWUsXHJcbiAgLy8gaW4gb3JkZXIgdG8gdXBkYXRlIGdwdVRpbWVcclxuICB2YXIgdGltZVN1bSA9IFtdO1xyXG4gIHZhciBxdWVyeVB0ciA9IFtdO1xyXG4gIGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XHJcbiAgICB2YXIgcHRyLCBpO1xyXG5cclxuICAgIHZhciBuID0gcGVuZGluZ1F1ZXJpZXMubGVuZ3RoO1xyXG4gICAgaWYgKG4gPT09IDApIHtcclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVzZXJ2ZSBzcGFjZVxyXG4gICAgcXVlcnlQdHIubGVuZ3RoID0gTWF0aC5tYXgocXVlcnlQdHIubGVuZ3RoLCBuICsgMSk7XHJcbiAgICB0aW1lU3VtLmxlbmd0aCA9IE1hdGgubWF4KHRpbWVTdW0ubGVuZ3RoLCBuICsgMSk7XHJcbiAgICB0aW1lU3VtWzBdID0gMDtcclxuICAgIHF1ZXJ5UHRyWzBdID0gMDtcclxuXHJcbiAgICAvLyBVcGRhdGUgYWxsIHBlbmRpbmcgdGltZXIgcXVlcmllc1xyXG4gICAgdmFyIHF1ZXJ5VGltZSA9IDA7XHJcbiAgICBwdHIgPSAwO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IHBlbmRpbmdRdWVyaWVzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgIHZhciBxdWVyeSA9IHBlbmRpbmdRdWVyaWVzW2ldO1xyXG4gICAgICBpZiAoZXh0VGltZXIuZ2V0UXVlcnlPYmplY3RFWFQocXVlcnksIEdMX1FVRVJZX1JFU1VMVF9BVkFJTEFCTEVfRVhUKSkge1xyXG4gICAgICAgIHF1ZXJ5VGltZSArPSBleHRUaW1lci5nZXRRdWVyeU9iamVjdEVYVChxdWVyeSwgR0xfUVVFUllfUkVTVUxUX0VYVCk7XHJcbiAgICAgICAgZnJlZVF1ZXJ5KHF1ZXJ5KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBwZW5kaW5nUXVlcmllc1twdHIrK10gPSBxdWVyeTtcclxuICAgICAgfVxyXG4gICAgICB0aW1lU3VtW2kgKyAxXSA9IHF1ZXJ5VGltZTtcclxuICAgICAgcXVlcnlQdHJbaSArIDFdID0gcHRyO1xyXG4gICAgfVxyXG4gICAgcGVuZGluZ1F1ZXJpZXMubGVuZ3RoID0gcHRyO1xyXG5cclxuICAgIC8vIFVwZGF0ZSBhbGwgcGVuZGluZyBzdGF0IHF1ZXJpZXNcclxuICAgIHB0ciA9IDA7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgcGVuZGluZ1N0YXRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgIHZhciBzdGF0cyA9IHBlbmRpbmdTdGF0c1tpXTtcclxuICAgICAgdmFyIHN0YXJ0ID0gc3RhdHMuc3RhcnRRdWVyeUluZGV4O1xyXG4gICAgICB2YXIgZW5kID0gc3RhdHMuZW5kUXVlcnlJbmRleDtcclxuICAgICAgc3RhdHMuc3VtICs9IHRpbWVTdW1bZW5kXSAtIHRpbWVTdW1bc3RhcnRdO1xyXG4gICAgICB2YXIgc3RhcnRQdHIgPSBxdWVyeVB0cltzdGFydF07XHJcbiAgICAgIHZhciBlbmRQdHIgPSBxdWVyeVB0cltlbmRdO1xyXG4gICAgICBpZiAoZW5kUHRyID09PSBzdGFydFB0cikge1xyXG4gICAgICAgIHN0YXRzLnN0YXRzLmdwdVRpbWUgKz0gc3RhdHMuc3VtIC8gMWU2O1xyXG4gICAgICAgIGZyZWVQZW5kaW5nU3RhdHMoc3RhdHMpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHN0YXRzLnN0YXJ0UXVlcnlJbmRleCA9IHN0YXJ0UHRyO1xyXG4gICAgICAgIHN0YXRzLmVuZFF1ZXJ5SW5kZXggPSBlbmRQdHI7XHJcbiAgICAgICAgcGVuZGluZ1N0YXRzW3B0cisrXSA9IHN0YXRzO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBwZW5kaW5nU3RhdHMubGVuZ3RoID0gcHRyO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGJlZ2luUXVlcnk6IGJlZ2luUXVlcnksXHJcbiAgICBlbmRRdWVyeTogZW5kUXVlcnksXHJcbiAgICBwdXNoU2NvcGVTdGF0czogcHVzaFNjb3BlU3RhdHMsXHJcbiAgICB1cGRhdGU6IHVwZGF0ZSxcclxuICAgIGdldE51bVBlbmRpbmdRdWVyaWVzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBwZW5kaW5nUXVlcmllcy5sZW5ndGhcclxuICAgIH0sXHJcbiAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICBxdWVyeVBvb2wucHVzaC5hcHBseShxdWVyeVBvb2wsIHBlbmRpbmdRdWVyaWVzKTtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWVyeVBvb2wubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBleHRUaW1lci5kZWxldGVRdWVyeUVYVChxdWVyeVBvb2xbaV0pO1xyXG4gICAgICB9XHJcbiAgICAgIHBlbmRpbmdRdWVyaWVzLmxlbmd0aCA9IDA7XHJcbiAgICAgIHF1ZXJ5UG9vbC5sZW5ndGggPSAwO1xyXG4gICAgfSxcclxuICAgIHJlc3RvcmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcGVuZGluZ1F1ZXJpZXMubGVuZ3RoID0gMDtcclxuICAgICAgcXVlcnlQb29sLmxlbmd0aCA9IDA7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxudmFyIEdMX0NPTE9SX0JVRkZFUl9CSVQgPSAxNjM4NDtcclxudmFyIEdMX0RFUFRIX0JVRkZFUl9CSVQgPSAyNTY7XHJcbnZhciBHTF9TVEVOQ0lMX0JVRkZFUl9CSVQgPSAxMDI0O1xyXG5cclxudmFyIEdMX0FSUkFZX0JVRkZFUiA9IDM0OTYyO1xyXG5cclxudmFyIENPTlRFWFRfTE9TVF9FVkVOVCA9ICd3ZWJnbGNvbnRleHRsb3N0JztcclxudmFyIENPTlRFWFRfUkVTVE9SRURfRVZFTlQgPSAnd2ViZ2xjb250ZXh0cmVzdG9yZWQnO1xyXG5cclxudmFyIERZTl9QUk9QID0gMTtcclxudmFyIERZTl9DT05URVhUID0gMjtcclxudmFyIERZTl9TVEFURSA9IDM7XHJcblxyXG5mdW5jdGlvbiBmaW5kIChoYXlzdGFjaywgbmVlZGxlKSB7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYXlzdGFjay5sZW5ndGg7ICsraSkge1xyXG4gICAgaWYgKGhheXN0YWNrW2ldID09PSBuZWVkbGUpIHtcclxuICAgICAgcmV0dXJuIGlcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIC0xXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHdyYXBSRUdMIChhcmdzKSB7XHJcbiAgdmFyIGNvbmZpZyA9IHBhcnNlQXJncyhhcmdzKTtcclxuICBpZiAoIWNvbmZpZykge1xyXG4gICAgcmV0dXJuIG51bGxcclxuICB9XHJcblxyXG4gIHZhciBnbCA9IGNvbmZpZy5nbDtcclxuICB2YXIgZ2xBdHRyaWJ1dGVzID0gZ2wuZ2V0Q29udGV4dEF0dHJpYnV0ZXMoKTtcclxuICB2YXIgY29udGV4dExvc3QgPSBnbC5pc0NvbnRleHRMb3N0KCk7XHJcblxyXG4gIHZhciBleHRlbnNpb25TdGF0ZSA9IGNyZWF0ZUV4dGVuc2lvbkNhY2hlKGdsLCBjb25maWcpO1xyXG4gIGlmICghZXh0ZW5zaW9uU3RhdGUpIHtcclxuICAgIHJldHVybiBudWxsXHJcbiAgfVxyXG5cclxuICB2YXIgc3RyaW5nU3RvcmUgPSBjcmVhdGVTdHJpbmdTdG9yZSgpO1xyXG4gIHZhciBzdGF0cyQkMSA9IHN0YXRzKCk7XHJcbiAgdmFyIGV4dGVuc2lvbnMgPSBleHRlbnNpb25TdGF0ZS5leHRlbnNpb25zO1xyXG4gIHZhciB0aW1lciA9IGNyZWF0ZVRpbWVyKGdsLCBleHRlbnNpb25zKTtcclxuXHJcbiAgdmFyIFNUQVJUX1RJTUUgPSBjbG9jaygpO1xyXG4gIHZhciBXSURUSCA9IGdsLmRyYXdpbmdCdWZmZXJXaWR0aDtcclxuICB2YXIgSEVJR0hUID0gZ2wuZHJhd2luZ0J1ZmZlckhlaWdodDtcclxuXHJcbiAgdmFyIGNvbnRleHRTdGF0ZSA9IHtcclxuICAgIHRpY2s6IDAsXHJcbiAgICB0aW1lOiAwLFxyXG4gICAgdmlld3BvcnRXaWR0aDogV0lEVEgsXHJcbiAgICB2aWV3cG9ydEhlaWdodDogSEVJR0hULFxyXG4gICAgZnJhbWVidWZmZXJXaWR0aDogV0lEVEgsXHJcbiAgICBmcmFtZWJ1ZmZlckhlaWdodDogSEVJR0hULFxyXG4gICAgZHJhd2luZ0J1ZmZlcldpZHRoOiBXSURUSCxcclxuICAgIGRyYXdpbmdCdWZmZXJIZWlnaHQ6IEhFSUdIVCxcclxuICAgIHBpeGVsUmF0aW86IGNvbmZpZy5waXhlbFJhdGlvXHJcbiAgfTtcclxuICB2YXIgdW5pZm9ybVN0YXRlID0ge307XHJcbiAgdmFyIGRyYXdTdGF0ZSA9IHtcclxuICAgIGVsZW1lbnRzOiBudWxsLFxyXG4gICAgcHJpbWl0aXZlOiA0LCAvLyBHTF9UUklBTkdMRVNcclxuICAgIGNvdW50OiAtMSxcclxuICAgIG9mZnNldDogMCxcclxuICAgIGluc3RhbmNlczogLTFcclxuICB9O1xyXG5cclxuICB2YXIgbGltaXRzID0gd3JhcExpbWl0cyhnbCwgZXh0ZW5zaW9ucyk7XHJcbiAgdmFyIGF0dHJpYnV0ZVN0YXRlID0gd3JhcEF0dHJpYnV0ZVN0YXRlKFxyXG4gICAgZ2wsXHJcbiAgICBleHRlbnNpb25zLFxyXG4gICAgbGltaXRzLFxyXG4gICAgc3RyaW5nU3RvcmUpO1xyXG4gIHZhciBidWZmZXJTdGF0ZSA9IHdyYXBCdWZmZXJTdGF0ZShcclxuICAgIGdsLFxyXG4gICAgc3RhdHMkJDEsXHJcbiAgICBjb25maWcsXHJcbiAgICBhdHRyaWJ1dGVTdGF0ZSk7XHJcbiAgdmFyIGVsZW1lbnRTdGF0ZSA9IHdyYXBFbGVtZW50c1N0YXRlKGdsLCBleHRlbnNpb25zLCBidWZmZXJTdGF0ZSwgc3RhdHMkJDEpO1xyXG4gIHZhciBzaGFkZXJTdGF0ZSA9IHdyYXBTaGFkZXJTdGF0ZShnbCwgc3RyaW5nU3RvcmUsIHN0YXRzJCQxLCBjb25maWcpO1xyXG4gIHZhciB0ZXh0dXJlU3RhdGUgPSBjcmVhdGVUZXh0dXJlU2V0KFxyXG4gICAgZ2wsXHJcbiAgICBleHRlbnNpb25zLFxyXG4gICAgbGltaXRzLFxyXG4gICAgZnVuY3Rpb24gKCkgeyBjb3JlLnByb2NzLnBvbGwoKTsgfSxcclxuICAgIGNvbnRleHRTdGF0ZSxcclxuICAgIHN0YXRzJCQxLFxyXG4gICAgY29uZmlnKTtcclxuICB2YXIgcmVuZGVyYnVmZmVyU3RhdGUgPSB3cmFwUmVuZGVyYnVmZmVycyhnbCwgZXh0ZW5zaW9ucywgbGltaXRzLCBzdGF0cyQkMSwgY29uZmlnKTtcclxuICB2YXIgZnJhbWVidWZmZXJTdGF0ZSA9IHdyYXBGQk9TdGF0ZShcclxuICAgIGdsLFxyXG4gICAgZXh0ZW5zaW9ucyxcclxuICAgIGxpbWl0cyxcclxuICAgIHRleHR1cmVTdGF0ZSxcclxuICAgIHJlbmRlcmJ1ZmZlclN0YXRlLFxyXG4gICAgc3RhdHMkJDEpO1xyXG4gIHZhciBjb3JlID0gcmVnbENvcmUoXHJcbiAgICBnbCxcclxuICAgIHN0cmluZ1N0b3JlLFxyXG4gICAgZXh0ZW5zaW9ucyxcclxuICAgIGxpbWl0cyxcclxuICAgIGJ1ZmZlclN0YXRlLFxyXG4gICAgZWxlbWVudFN0YXRlLFxyXG4gICAgdGV4dHVyZVN0YXRlLFxyXG4gICAgZnJhbWVidWZmZXJTdGF0ZSxcclxuICAgIHVuaWZvcm1TdGF0ZSxcclxuICAgIGF0dHJpYnV0ZVN0YXRlLFxyXG4gICAgc2hhZGVyU3RhdGUsXHJcbiAgICBkcmF3U3RhdGUsXHJcbiAgICBjb250ZXh0U3RhdGUsXHJcbiAgICB0aW1lcixcclxuICAgIGNvbmZpZyk7XHJcbiAgdmFyIHJlYWRQaXhlbHMgPSB3cmFwUmVhZFBpeGVscyhcclxuICAgIGdsLFxyXG4gICAgZnJhbWVidWZmZXJTdGF0ZSxcclxuICAgIGNvcmUucHJvY3MucG9sbCxcclxuICAgIGNvbnRleHRTdGF0ZSxcclxuICAgIGdsQXR0cmlidXRlcywgZXh0ZW5zaW9ucywgbGltaXRzKTtcclxuXHJcbiAgdmFyIG5leHRTdGF0ZSA9IGNvcmUubmV4dDtcclxuICB2YXIgY2FudmFzID0gZ2wuY2FudmFzO1xyXG5cclxuICB2YXIgcmFmQ2FsbGJhY2tzID0gW107XHJcbiAgdmFyIGxvc3NDYWxsYmFja3MgPSBbXTtcclxuICB2YXIgcmVzdG9yZUNhbGxiYWNrcyA9IFtdO1xyXG4gIHZhciBkZXN0cm95Q2FsbGJhY2tzID0gW2NvbmZpZy5vbkRlc3Ryb3ldO1xyXG5cclxuICB2YXIgYWN0aXZlUkFGID0gbnVsbDtcclxuICBmdW5jdGlvbiBoYW5kbGVSQUYgKCkge1xyXG4gICAgaWYgKHJhZkNhbGxiYWNrcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgaWYgKHRpbWVyKSB7XHJcbiAgICAgICAgdGltZXIudXBkYXRlKCk7XHJcbiAgICAgIH1cclxuICAgICAgYWN0aXZlUkFGID0gbnVsbDtcclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcblxyXG4gICAgLy8gc2NoZWR1bGUgbmV4dCBhbmltYXRpb24gZnJhbWVcclxuICAgIGFjdGl2ZVJBRiA9IHJhZi5uZXh0KGhhbmRsZVJBRik7XHJcblxyXG4gICAgLy8gcG9sbCBmb3IgY2hhbmdlc1xyXG4gICAgcG9sbCgpO1xyXG5cclxuICAgIC8vIGZpcmUgYSBjYWxsYmFjayBmb3IgYWxsIHBlbmRpbmcgcmFmc1xyXG4gICAgZm9yICh2YXIgaSA9IHJhZkNhbGxiYWNrcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xyXG4gICAgICB2YXIgY2IgPSByYWZDYWxsYmFja3NbaV07XHJcbiAgICAgIGlmIChjYikge1xyXG4gICAgICAgIGNiKGNvbnRleHRTdGF0ZSwgbnVsbCwgMCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBmbHVzaCBhbGwgcGVuZGluZyB3ZWJnbCBjYWxsc1xyXG4gICAgZ2wuZmx1c2goKTtcclxuXHJcbiAgICAvLyBwb2xsIEdQVSB0aW1lcnMgKmFmdGVyKiBnbC5mbHVzaCBzbyB3ZSBkb24ndCBkZWxheSBjb21tYW5kIGRpc3BhdGNoXHJcbiAgICBpZiAodGltZXIpIHtcclxuICAgICAgdGltZXIudXBkYXRlKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzdGFydFJBRiAoKSB7XHJcbiAgICBpZiAoIWFjdGl2ZVJBRiAmJiByYWZDYWxsYmFja3MubGVuZ3RoID4gMCkge1xyXG4gICAgICBhY3RpdmVSQUYgPSByYWYubmV4dChoYW5kbGVSQUYpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc3RvcFJBRiAoKSB7XHJcbiAgICBpZiAoYWN0aXZlUkFGKSB7XHJcbiAgICAgIHJhZi5jYW5jZWwoaGFuZGxlUkFGKTtcclxuICAgICAgYWN0aXZlUkFGID0gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGhhbmRsZUNvbnRleHRMb3NzIChldmVudCkge1xyXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAvLyBzZXQgY29udGV4dCBsb3N0IGZsYWdcclxuICAgIGNvbnRleHRMb3N0ID0gdHJ1ZTtcclxuXHJcbiAgICAvLyBwYXVzZSByZXF1ZXN0IGFuaW1hdGlvbiBmcmFtZVxyXG4gICAgc3RvcFJBRigpO1xyXG5cclxuICAgIC8vIGxvc2UgY29udGV4dFxyXG4gICAgbG9zc0NhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChjYikge1xyXG4gICAgICBjYigpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBoYW5kbGVDb250ZXh0UmVzdG9yZWQgKGV2ZW50KSB7XHJcbiAgICAvLyBjbGVhciBlcnJvciBjb2RlXHJcbiAgICBnbC5nZXRFcnJvcigpO1xyXG5cclxuICAgIC8vIGNsZWFyIGNvbnRleHQgbG9zdCBmbGFnXHJcbiAgICBjb250ZXh0TG9zdCA9IGZhbHNlO1xyXG5cclxuICAgIC8vIHJlZnJlc2ggc3RhdGVcclxuICAgIGV4dGVuc2lvblN0YXRlLnJlc3RvcmUoKTtcclxuICAgIHNoYWRlclN0YXRlLnJlc3RvcmUoKTtcclxuICAgIGJ1ZmZlclN0YXRlLnJlc3RvcmUoKTtcclxuICAgIHRleHR1cmVTdGF0ZS5yZXN0b3JlKCk7XHJcbiAgICByZW5kZXJidWZmZXJTdGF0ZS5yZXN0b3JlKCk7XHJcbiAgICBmcmFtZWJ1ZmZlclN0YXRlLnJlc3RvcmUoKTtcclxuICAgIGlmICh0aW1lcikge1xyXG4gICAgICB0aW1lci5yZXN0b3JlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcmVmcmVzaCBzdGF0ZVxyXG4gICAgY29yZS5wcm9jcy5yZWZyZXNoKCk7XHJcblxyXG4gICAgLy8gcmVzdGFydCBSQUZcclxuICAgIHN0YXJ0UkFGKCk7XHJcblxyXG4gICAgLy8gcmVzdG9yZSBjb250ZXh0XHJcbiAgICByZXN0b3JlQ2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7XHJcbiAgICAgIGNiKCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGlmIChjYW52YXMpIHtcclxuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKENPTlRFWFRfTE9TVF9FVkVOVCwgaGFuZGxlQ29udGV4dExvc3MsIGZhbHNlKTtcclxuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKENPTlRFWFRfUkVTVE9SRURfRVZFTlQsIGhhbmRsZUNvbnRleHRSZXN0b3JlZCwgZmFsc2UpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZGVzdHJveSAoKSB7XHJcbiAgICByYWZDYWxsYmFja3MubGVuZ3RoID0gMDtcclxuICAgIHN0b3BSQUYoKTtcclxuXHJcbiAgICBpZiAoY2FudmFzKSB7XHJcbiAgICAgIGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKENPTlRFWFRfTE9TVF9FVkVOVCwgaGFuZGxlQ29udGV4dExvc3MpO1xyXG4gICAgICBjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihDT05URVhUX1JFU1RPUkVEX0VWRU5ULCBoYW5kbGVDb250ZXh0UmVzdG9yZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIHNoYWRlclN0YXRlLmNsZWFyKCk7XHJcbiAgICBmcmFtZWJ1ZmZlclN0YXRlLmNsZWFyKCk7XHJcbiAgICByZW5kZXJidWZmZXJTdGF0ZS5jbGVhcigpO1xyXG4gICAgdGV4dHVyZVN0YXRlLmNsZWFyKCk7XHJcbiAgICBlbGVtZW50U3RhdGUuY2xlYXIoKTtcclxuICAgIGJ1ZmZlclN0YXRlLmNsZWFyKCk7XHJcblxyXG4gICAgaWYgKHRpbWVyKSB7XHJcbiAgICAgIHRpbWVyLmNsZWFyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZGVzdHJveUNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChjYikge1xyXG4gICAgICBjYigpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjb21waWxlUHJvY2VkdXJlIChvcHRpb25zKSB7XHJcbiAgICBjaGVjayQxKCEhb3B0aW9ucywgJ2ludmFsaWQgYXJncyB0byByZWdsKHsuLi59KScpO1xyXG4gICAgY2hlY2skMS50eXBlKG9wdGlvbnMsICdvYmplY3QnLCAnaW52YWxpZCBhcmdzIHRvIHJlZ2woey4uLn0pJyk7XHJcblxyXG4gICAgZnVuY3Rpb24gZmxhdHRlbk5lc3RlZE9wdGlvbnMgKG9wdGlvbnMpIHtcclxuICAgICAgdmFyIHJlc3VsdCA9IGV4dGVuZCh7fSwgb3B0aW9ucyk7XHJcbiAgICAgIGRlbGV0ZSByZXN1bHQudW5pZm9ybXM7XHJcbiAgICAgIGRlbGV0ZSByZXN1bHQuYXR0cmlidXRlcztcclxuICAgICAgZGVsZXRlIHJlc3VsdC5jb250ZXh0O1xyXG5cclxuICAgICAgaWYgKCdzdGVuY2lsJyBpbiByZXN1bHQgJiYgcmVzdWx0LnN0ZW5jaWwub3ApIHtcclxuICAgICAgICByZXN1bHQuc3RlbmNpbC5vcEJhY2sgPSByZXN1bHQuc3RlbmNpbC5vcEZyb250ID0gcmVzdWx0LnN0ZW5jaWwub3A7XHJcbiAgICAgICAgZGVsZXRlIHJlc3VsdC5zdGVuY2lsLm9wO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBtZXJnZSAobmFtZSkge1xyXG4gICAgICAgIGlmIChuYW1lIGluIHJlc3VsdCkge1xyXG4gICAgICAgICAgdmFyIGNoaWxkID0gcmVzdWx0W25hbWVdO1xyXG4gICAgICAgICAgZGVsZXRlIHJlc3VsdFtuYW1lXTtcclxuICAgICAgICAgIE9iamVjdC5rZXlzKGNoaWxkKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdFtuYW1lICsgJy4nICsgcHJvcF0gPSBjaGlsZFtwcm9wXTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBtZXJnZSgnYmxlbmQnKTtcclxuICAgICAgbWVyZ2UoJ2RlcHRoJyk7XHJcbiAgICAgIG1lcmdlKCdjdWxsJyk7XHJcbiAgICAgIG1lcmdlKCdzdGVuY2lsJyk7XHJcbiAgICAgIG1lcmdlKCdwb2x5Z29uT2Zmc2V0Jyk7XHJcbiAgICAgIG1lcmdlKCdzY2lzc29yJyk7XHJcbiAgICAgIG1lcmdlKCdzYW1wbGUnKTtcclxuXHJcbiAgICAgIHJldHVybiByZXN1bHRcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzZXBhcmF0ZUR5bmFtaWMgKG9iamVjdCkge1xyXG4gICAgICB2YXIgc3RhdGljSXRlbXMgPSB7fTtcclxuICAgICAgdmFyIGR5bmFtaWNJdGVtcyA9IHt9O1xyXG4gICAgICBPYmplY3Qua2V5cyhvYmplY3QpLmZvckVhY2goZnVuY3Rpb24gKG9wdGlvbikge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdFtvcHRpb25dO1xyXG4gICAgICAgIGlmIChkeW5hbWljLmlzRHluYW1pYyh2YWx1ZSkpIHtcclxuICAgICAgICAgIGR5bmFtaWNJdGVtc1tvcHRpb25dID0gZHluYW1pYy51bmJveCh2YWx1ZSwgb3B0aW9uKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgc3RhdGljSXRlbXNbb3B0aW9uXSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgZHluYW1pYzogZHluYW1pY0l0ZW1zLFxyXG4gICAgICAgIHN0YXRpYzogc3RhdGljSXRlbXNcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFRyZWF0IGNvbnRleHQgdmFyaWFibGVzIHNlcGFyYXRlIGZyb20gb3RoZXIgZHluYW1pYyB2YXJpYWJsZXNcclxuICAgIHZhciBjb250ZXh0ID0gc2VwYXJhdGVEeW5hbWljKG9wdGlvbnMuY29udGV4dCB8fCB7fSk7XHJcbiAgICB2YXIgdW5pZm9ybXMgPSBzZXBhcmF0ZUR5bmFtaWMob3B0aW9ucy51bmlmb3JtcyB8fCB7fSk7XHJcbiAgICB2YXIgYXR0cmlidXRlcyA9IHNlcGFyYXRlRHluYW1pYyhvcHRpb25zLmF0dHJpYnV0ZXMgfHwge30pO1xyXG4gICAgdmFyIG9wdHMgPSBzZXBhcmF0ZUR5bmFtaWMoZmxhdHRlbk5lc3RlZE9wdGlvbnMob3B0aW9ucykpO1xyXG5cclxuICAgIHZhciBzdGF0cyQkMSA9IHtcclxuICAgICAgZ3B1VGltZTogMC4wLFxyXG4gICAgICBjcHVUaW1lOiAwLjAsXHJcbiAgICAgIGNvdW50OiAwXHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBjb21waWxlZCA9IGNvcmUuY29tcGlsZShvcHRzLCBhdHRyaWJ1dGVzLCB1bmlmb3JtcywgY29udGV4dCwgc3RhdHMkJDEpO1xyXG5cclxuICAgIHZhciBkcmF3ID0gY29tcGlsZWQuZHJhdztcclxuICAgIHZhciBiYXRjaCA9IGNvbXBpbGVkLmJhdGNoO1xyXG4gICAgdmFyIHNjb3BlID0gY29tcGlsZWQuc2NvcGU7XHJcblxyXG4gICAgLy8gRklYTUU6IHdlIHNob3VsZCBtb2RpZnkgY29kZSBnZW5lcmF0aW9uIGZvciBiYXRjaCBjb21tYW5kcyBzbyB0aGlzXHJcbiAgICAvLyBpc24ndCBuZWNlc3NhcnlcclxuICAgIHZhciBFTVBUWV9BUlJBWSA9IFtdO1xyXG4gICAgZnVuY3Rpb24gcmVzZXJ2ZSAoY291bnQpIHtcclxuICAgICAgd2hpbGUgKEVNUFRZX0FSUkFZLmxlbmd0aCA8IGNvdW50KSB7XHJcbiAgICAgICAgRU1QVFlfQVJSQVkucHVzaChudWxsKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gRU1QVFlfQVJSQVlcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBSRUdMQ29tbWFuZCAoYXJncywgYm9keSkge1xyXG4gICAgICB2YXIgaTtcclxuICAgICAgaWYgKGNvbnRleHRMb3N0KSB7XHJcbiAgICAgICAgY2hlY2skMS5yYWlzZSgnY29udGV4dCBsb3N0Jyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHR5cGVvZiBhcmdzID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgcmV0dXJuIHNjb3BlLmNhbGwodGhpcywgbnVsbCwgYXJncywgMClcclxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYm9keSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIGlmICh0eXBlb2YgYXJncyA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcmdzOyArK2kpIHtcclxuICAgICAgICAgICAgc2NvcGUuY2FsbCh0aGlzLCBudWxsLCBib2R5LCBpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVyblxyXG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmdzKSkge1xyXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgc2NvcGUuY2FsbCh0aGlzLCBhcmdzW2ldLCBib2R5LCBpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVyblxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXR1cm4gc2NvcGUuY2FsbCh0aGlzLCBhcmdzLCBib2R5LCAwKVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJncyA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICBpZiAoYXJncyA+IDApIHtcclxuICAgICAgICAgIHJldHVybiBiYXRjaC5jYWxsKHRoaXMsIHJlc2VydmUoYXJncyB8IDApLCBhcmdzIHwgMClcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmdzKSkge1xyXG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCkge1xyXG4gICAgICAgICAgcmV0dXJuIGJhdGNoLmNhbGwodGhpcywgYXJncywgYXJncy5sZW5ndGgpXHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBkcmF3LmNhbGwodGhpcywgYXJncylcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBleHRlbmQoUkVHTENvbW1hbmQsIHtcclxuICAgICAgc3RhdHM6IHN0YXRzJCQxXHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgdmFyIHNldEZCTyA9IGZyYW1lYnVmZmVyU3RhdGUuc2V0RkJPID0gY29tcGlsZVByb2NlZHVyZSh7XHJcbiAgICBmcmFtZWJ1ZmZlcjogZHluYW1pYy5kZWZpbmUuY2FsbChudWxsLCBEWU5fUFJPUCwgJ2ZyYW1lYnVmZmVyJylcclxuICB9KTtcclxuXHJcbiAgZnVuY3Rpb24gY2xlYXJJbXBsIChfLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgY2xlYXJGbGFncyA9IDA7XHJcbiAgICBjb3JlLnByb2NzLnBvbGwoKTtcclxuXHJcbiAgICB2YXIgYyA9IG9wdGlvbnMuY29sb3I7XHJcbiAgICBpZiAoYykge1xyXG4gICAgICBnbC5jbGVhckNvbG9yKCtjWzBdIHx8IDAsICtjWzFdIHx8IDAsICtjWzJdIHx8IDAsICtjWzNdIHx8IDApO1xyXG4gICAgICBjbGVhckZsYWdzIHw9IEdMX0NPTE9SX0JVRkZFUl9CSVQ7XHJcbiAgICB9XHJcbiAgICBpZiAoJ2RlcHRoJyBpbiBvcHRpb25zKSB7XHJcbiAgICAgIGdsLmNsZWFyRGVwdGgoK29wdGlvbnMuZGVwdGgpO1xyXG4gICAgICBjbGVhckZsYWdzIHw9IEdMX0RFUFRIX0JVRkZFUl9CSVQ7XHJcbiAgICB9XHJcbiAgICBpZiAoJ3N0ZW5jaWwnIGluIG9wdGlvbnMpIHtcclxuICAgICAgZ2wuY2xlYXJTdGVuY2lsKG9wdGlvbnMuc3RlbmNpbCB8IDApO1xyXG4gICAgICBjbGVhckZsYWdzIHw9IEdMX1NURU5DSUxfQlVGRkVSX0JJVDtcclxuICAgIH1cclxuXHJcbiAgICBjaGVjayQxKCEhY2xlYXJGbGFncywgJ2NhbGxlZCByZWdsLmNsZWFyIHdpdGggbm8gYnVmZmVyIHNwZWNpZmllZCcpO1xyXG4gICAgZ2wuY2xlYXIoY2xlYXJGbGFncyk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjbGVhciAob3B0aW9ucykge1xyXG4gICAgY2hlY2skMShcclxuICAgICAgdHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmIG9wdGlvbnMsXHJcbiAgICAgICdyZWdsLmNsZWFyKCkgdGFrZXMgYW4gb2JqZWN0IGFzIGlucHV0Jyk7XHJcbiAgICBpZiAoJ2ZyYW1lYnVmZmVyJyBpbiBvcHRpb25zKSB7XHJcbiAgICAgIGlmIChvcHRpb25zLmZyYW1lYnVmZmVyICYmXHJcbiAgICAgICAgICBvcHRpb25zLmZyYW1lYnVmZmVyX3JlZ2xUeXBlID09PSAnZnJhbWVidWZmZXJDdWJlJykge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjsgKytpKSB7XHJcbiAgICAgICAgICBzZXRGQk8oZXh0ZW5kKHtcclxuICAgICAgICAgICAgZnJhbWVidWZmZXI6IG9wdGlvbnMuZnJhbWVidWZmZXIuZmFjZXNbaV1cclxuICAgICAgICAgIH0sIG9wdGlvbnMpLCBjbGVhckltcGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzZXRGQk8ob3B0aW9ucywgY2xlYXJJbXBsKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY2xlYXJJbXBsKG51bGwsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZnJhbWUgKGNiKSB7XHJcbiAgICBjaGVjayQxLnR5cGUoY2IsICdmdW5jdGlvbicsICdyZWdsLmZyYW1lKCkgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XHJcbiAgICByYWZDYWxsYmFja3MucHVzaChjYik7XHJcblxyXG4gICAgZnVuY3Rpb24gY2FuY2VsICgpIHtcclxuICAgICAgLy8gRklYTUU6ICBzaG91bGQgd2UgY2hlY2sgc29tZXRoaW5nIG90aGVyIHRoYW4gZXF1YWxzIGNiIGhlcmU/XHJcbiAgICAgIC8vIHdoYXQgaWYgYSB1c2VyIGNhbGxzIGZyYW1lIHR3aWNlIHdpdGggdGhlIHNhbWUgY2FsbGJhY2suLi5cclxuICAgICAgLy9cclxuICAgICAgdmFyIGkgPSBmaW5kKHJhZkNhbGxiYWNrcywgY2IpO1xyXG4gICAgICBjaGVjayQxKGkgPj0gMCwgJ2Nhbm5vdCBjYW5jZWwgYSBmcmFtZSB0d2ljZScpO1xyXG4gICAgICBmdW5jdGlvbiBwZW5kaW5nQ2FuY2VsICgpIHtcclxuICAgICAgICB2YXIgaW5kZXggPSBmaW5kKHJhZkNhbGxiYWNrcywgcGVuZGluZ0NhbmNlbCk7XHJcbiAgICAgICAgcmFmQ2FsbGJhY2tzW2luZGV4XSA9IHJhZkNhbGxiYWNrc1tyYWZDYWxsYmFja3MubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgcmFmQ2FsbGJhY2tzLmxlbmd0aCAtPSAxO1xyXG4gICAgICAgIGlmIChyYWZDYWxsYmFja3MubGVuZ3RoIDw9IDApIHtcclxuICAgICAgICAgIHN0b3BSQUYoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmFmQ2FsbGJhY2tzW2ldID0gcGVuZGluZ0NhbmNlbDtcclxuICAgIH1cclxuXHJcbiAgICBzdGFydFJBRigpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGNhbmNlbDogY2FuY2VsXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBwb2xsIHZpZXdwb3J0XHJcbiAgZnVuY3Rpb24gcG9sbFZpZXdwb3J0ICgpIHtcclxuICAgIHZhciB2aWV3cG9ydCA9IG5leHRTdGF0ZS52aWV3cG9ydDtcclxuICAgIHZhciBzY2lzc29yQm94ID0gbmV4dFN0YXRlLnNjaXNzb3JfYm94O1xyXG4gICAgdmlld3BvcnRbMF0gPSB2aWV3cG9ydFsxXSA9IHNjaXNzb3JCb3hbMF0gPSBzY2lzc29yQm94WzFdID0gMDtcclxuICAgIGNvbnRleHRTdGF0ZS52aWV3cG9ydFdpZHRoID1cclxuICAgICAgY29udGV4dFN0YXRlLmZyYW1lYnVmZmVyV2lkdGggPVxyXG4gICAgICBjb250ZXh0U3RhdGUuZHJhd2luZ0J1ZmZlcldpZHRoID1cclxuICAgICAgdmlld3BvcnRbMl0gPVxyXG4gICAgICBzY2lzc29yQm94WzJdID0gZ2wuZHJhd2luZ0J1ZmZlcldpZHRoO1xyXG4gICAgY29udGV4dFN0YXRlLnZpZXdwb3J0SGVpZ2h0ID1cclxuICAgICAgY29udGV4dFN0YXRlLmZyYW1lYnVmZmVySGVpZ2h0ID1cclxuICAgICAgY29udGV4dFN0YXRlLmRyYXdpbmdCdWZmZXJIZWlnaHQgPVxyXG4gICAgICB2aWV3cG9ydFszXSA9XHJcbiAgICAgIHNjaXNzb3JCb3hbM10gPSBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcG9sbCAoKSB7XHJcbiAgICBjb250ZXh0U3RhdGUudGljayArPSAxO1xyXG4gICAgY29udGV4dFN0YXRlLnRpbWUgPSBub3coKTtcclxuICAgIHBvbGxWaWV3cG9ydCgpO1xyXG4gICAgY29yZS5wcm9jcy5wb2xsKCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByZWZyZXNoICgpIHtcclxuICAgIHBvbGxWaWV3cG9ydCgpO1xyXG4gICAgY29yZS5wcm9jcy5yZWZyZXNoKCk7XHJcbiAgICBpZiAodGltZXIpIHtcclxuICAgICAgdGltZXIudXBkYXRlKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBub3cgKCkge1xyXG4gICAgcmV0dXJuIChjbG9jaygpIC0gU1RBUlRfVElNRSkgLyAxMDAwLjBcclxuICB9XHJcblxyXG4gIHJlZnJlc2goKTtcclxuXHJcbiAgZnVuY3Rpb24gYWRkTGlzdGVuZXIgKGV2ZW50LCBjYWxsYmFjaykge1xyXG4gICAgY2hlY2skMS50eXBlKGNhbGxiYWNrLCAnZnVuY3Rpb24nLCAnbGlzdGVuZXIgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XHJcblxyXG4gICAgdmFyIGNhbGxiYWNrcztcclxuICAgIHN3aXRjaCAoZXZlbnQpIHtcclxuICAgICAgY2FzZSAnZnJhbWUnOlxyXG4gICAgICAgIHJldHVybiBmcmFtZShjYWxsYmFjaylcclxuICAgICAgY2FzZSAnbG9zdCc6XHJcbiAgICAgICAgY2FsbGJhY2tzID0gbG9zc0NhbGxiYWNrcztcclxuICAgICAgICBicmVha1xyXG4gICAgICBjYXNlICdyZXN0b3JlJzpcclxuICAgICAgICBjYWxsYmFja3MgPSByZXN0b3JlQ2FsbGJhY2tzO1xyXG4gICAgICAgIGJyZWFrXHJcbiAgICAgIGNhc2UgJ2Rlc3Ryb3knOlxyXG4gICAgICAgIGNhbGxiYWNrcyA9IGRlc3Ryb3lDYWxsYmFja3M7XHJcbiAgICAgICAgYnJlYWtcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICBjaGVjayQxLnJhaXNlKCdpbnZhbGlkIGV2ZW50LCBtdXN0IGJlIG9uZSBvZiBmcmFtZSxsb3N0LHJlc3RvcmUsZGVzdHJveScpO1xyXG4gICAgfVxyXG5cclxuICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGNhbmNlbDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICBpZiAoY2FsbGJhY2tzW2ldID09PSBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICBjYWxsYmFja3NbaV0gPSBjYWxsYmFja3NbY2FsbGJhY2tzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICBjYWxsYmFja3MucG9wKCk7XHJcbiAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdmFyIHJlZ2wgPSBleHRlbmQoY29tcGlsZVByb2NlZHVyZSwge1xyXG4gICAgLy8gQ2xlYXIgY3VycmVudCBGQk9cclxuICAgIGNsZWFyOiBjbGVhcixcclxuXHJcbiAgICAvLyBTaG9ydCBjdXRzIGZvciBkeW5hbWljIHZhcmlhYmxlc1xyXG4gICAgcHJvcDogZHluYW1pYy5kZWZpbmUuYmluZChudWxsLCBEWU5fUFJPUCksXHJcbiAgICBjb250ZXh0OiBkeW5hbWljLmRlZmluZS5iaW5kKG51bGwsIERZTl9DT05URVhUKSxcclxuICAgIHRoaXM6IGR5bmFtaWMuZGVmaW5lLmJpbmQobnVsbCwgRFlOX1NUQVRFKSxcclxuXHJcbiAgICAvLyBleGVjdXRlcyBhbiBlbXB0eSBkcmF3IGNvbW1hbmRcclxuICAgIGRyYXc6IGNvbXBpbGVQcm9jZWR1cmUoe30pLFxyXG5cclxuICAgIC8vIFJlc291cmNlc1xyXG4gICAgYnVmZmVyOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICByZXR1cm4gYnVmZmVyU3RhdGUuY3JlYXRlKG9wdGlvbnMsIEdMX0FSUkFZX0JVRkZFUiwgZmFsc2UsIGZhbHNlKVxyXG4gICAgfSxcclxuICAgIGVsZW1lbnRzOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICByZXR1cm4gZWxlbWVudFN0YXRlLmNyZWF0ZShvcHRpb25zLCBmYWxzZSlcclxuICAgIH0sXHJcbiAgICB0ZXh0dXJlOiB0ZXh0dXJlU3RhdGUuY3JlYXRlMkQsXHJcbiAgICBjdWJlOiB0ZXh0dXJlU3RhdGUuY3JlYXRlQ3ViZSxcclxuICAgIHJlbmRlcmJ1ZmZlcjogcmVuZGVyYnVmZmVyU3RhdGUuY3JlYXRlLFxyXG4gICAgZnJhbWVidWZmZXI6IGZyYW1lYnVmZmVyU3RhdGUuY3JlYXRlLFxyXG4gICAgZnJhbWVidWZmZXJDdWJlOiBmcmFtZWJ1ZmZlclN0YXRlLmNyZWF0ZUN1YmUsXHJcblxyXG4gICAgLy8gRXhwb3NlIGNvbnRleHQgYXR0cmlidXRlc1xyXG4gICAgYXR0cmlidXRlczogZ2xBdHRyaWJ1dGVzLFxyXG5cclxuICAgIC8vIEZyYW1lIHJlbmRlcmluZ1xyXG4gICAgZnJhbWU6IGZyYW1lLFxyXG4gICAgb246IGFkZExpc3RlbmVyLFxyXG5cclxuICAgIC8vIFN5c3RlbSBsaW1pdHNcclxuICAgIGxpbWl0czogbGltaXRzLFxyXG4gICAgaGFzRXh0ZW5zaW9uOiBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICByZXR1cm4gbGltaXRzLmV4dGVuc2lvbnMuaW5kZXhPZihuYW1lLnRvTG93ZXJDYXNlKCkpID49IDBcclxuICAgIH0sXHJcblxyXG4gICAgLy8gUmVhZCBwaXhlbHNcclxuICAgIHJlYWQ6IHJlYWRQaXhlbHMsXHJcblxyXG4gICAgLy8gRGVzdHJveSByZWdsIGFuZCBhbGwgYXNzb2NpYXRlZCByZXNvdXJjZXNcclxuICAgIGRlc3Ryb3k6IGRlc3Ryb3ksXHJcblxyXG4gICAgLy8gRGlyZWN0IEdMIHN0YXRlIG1hbmlwdWxhdGlvblxyXG4gICAgX2dsOiBnbCxcclxuICAgIF9yZWZyZXNoOiByZWZyZXNoLFxyXG5cclxuICAgIHBvbGw6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcG9sbCgpO1xyXG4gICAgICBpZiAodGltZXIpIHtcclxuICAgICAgICB0aW1lci51cGRhdGUoKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBDdXJyZW50IHRpbWVcclxuICAgIG5vdzogbm93LFxyXG5cclxuICAgIC8vIHJlZ2wgU3RhdGlzdGljcyBJbmZvcm1hdGlvblxyXG4gICAgc3RhdHM6IHN0YXRzJCQxXHJcbiAgfSk7XHJcblxyXG4gIGNvbmZpZy5vbkRvbmUobnVsbCwgcmVnbCk7XHJcblxyXG4gIHJldHVybiByZWdsXHJcbn1cclxuXHJcblxyXG5leHBvcnQge3dyYXBSRUdMIGFzIHJlZ2x9XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZ2wuanMubWFwXHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7Ozs7OztBQUNBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFwQkE7QUFzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFNQTtBQUNBO0FBSUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFyQkE7QUFDQTtBQXVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBTEE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWJBO0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXZCQTtBQXlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQS9DQTtBQWlEQTtBQUNBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBYkE7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZBO0FBQ0E7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBcEJBO0FBc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFDQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUdBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWpCQTtBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFiQTtBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFPQTtBQUNBO0FBR0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZkE7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUdBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwQkE7QUFzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXZDQTtBQUNBO0FBeUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFLQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFLQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFNQTtBQU1BO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQVpBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWZBO0FBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBMUNBO0FBNENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWEE7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBbkJBO0FBcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFSQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWpCQTtBQUNBO0FBbUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFqQkE7QUFDQTtBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWhCQTtBQUNBO0FBa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXBCQTtBQXNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBSUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBSUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFLQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUlBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQVFBO0FBQ0E7QUFFQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFNQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFNQTtBQUNBO0FBRUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBL2JBO0FBaWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBU0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBY0E7QUFDQTtBQUdBO0FBSUE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWRBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBY0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFFQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFsRUE7QUFvRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW5EQTtBQXFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTVEQTtBQUNBO0FBOERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZEE7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFxQkE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBakhBO0FBbUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbkJBO0FBcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQ0E7QUFPQTtBQUNBO0FBS0E7QUFLQTtBQUNBO0FBQ0E7QUFJQTtBQUFBO0FBSUE7QUFDQTtBQU9BO0FBZ0JBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWJBO0FBQ0E7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBM0RBO0FBQ0E7QUE2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/webgl/regl.js\n");

/***/ }),

/***/ "./src/webgl/wgl2di.js":
/*!*****************************!*\
  !*** ./src/webgl/wgl2di.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.WGL2DI = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _regl = __webpack_require__(/*! ./regl.js */ \"./src/webgl/regl.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar WGL2DI = function () {\n\tfunction WGL2DI(div_id, width, height) {\n\t\t_classCallCheck(this, WGL2DI);\n\n\t\tthis.regl = null;\n\t\tthis.pick_buffer = null;\n\t\tthis.objects = [];\n\t\tthis.keys = {};\n\t\tthis.object_types = [];\n\t\tthis.objects_in_view = 0;\n\t\t//html elements\n\t\tthis.div_container = $(\"#\" + div_id);\n\t\tthis.canvas = null;\n\t\tthis.label_context;\n\t\tthis.label_context = null;\n\t\tthis.height = 0;\n\t\tthis.width = 0;\n\t\tthis._setUpDocument(width, height);\n\t\tthis.images_to_load = 0;\n\t\tthis.is_filtered = {};\n\t\tthis.is_hidden = {};\n\n\t\t//handlers\n\t\tthis.handlers = {\n\t\t\tobject_clicked: {},\n\t\t\tobject_over: {},\n\t\t\tobject_out: {},\n\t\t\tbrush_stopped: {}\n\t\t};\n\n\t\t//switches\n\t\tthis.draw_labels = false;\n\n\t\t//circle shapes\n\t\tthis.circle_properties = { \"position\": 1, \"color\": 1, \"pick_color\": 1, \"radius\": 1, \"start_angle\": 1, \"end_angle\": 1, \"opacity\": 1 };\n\t\tthis.circles_to_draw = {};\n\t\tthis.circles = {};\n\t\tfor (var prop in this.circle_properties) {\n\t\t\tthis.circles_to_draw[prop] = [];\n\t\t\tthis.circles[prop] = [];\n\t\t}\n\t\tthis.circles.count = 0;\n\t\tthis.object_types.push({ data: this.circles,\n\t\t\tdata_in_view: this.circles_to_draw,\n\t\t\tproperties: this.circle_properties,\n\t\t\tvertices: 1,\n\t\t\tprimitive: \"points\" });\n\n\t\t//line shapes\n\t\tthis.line_properties = { 'position': 2, \"color\": 2, \"pick_color\": 2 };\n\t\tthis.lines_to_draw = {};\n\t\tthis.lines = {};\n\t\tfor (var prop in this.line_properties) {\n\t\t\tvar list = [];\n\t\t\tthis.lines[prop] = list;\n\t\t\tthis.lines_to_draw[prop] = list;\n\t\t}\n\t\tthis.lines.count = 0;\n\t\tthis.object_types.push({ data: this.lines,\n\t\t\tdata_in_view: this.lines_to_draw,\n\t\t\tproperties: this.line_properties,\n\t\t\tvertices: 2,\n\t\t\tprimitive: \"lines\" });\n\n\t\t//rectangles\n\t\tthis.rect_properties = { 'position': 2, \"color\": 2, \"pick_color\": 2 };\n\t\tthis.rects_to_draw = {};\n\t\tthis.rects = {};\n\t\tfor (var prop in this.rect_properties) {\n\t\t\tthis.rects[prop] = [];\n\t\t\tthis.rects_to_draw[prop] = [];\n\t\t}\n\t\tthis.rects.count = 0;\n\n\t\tthis.object_types.push({ data: this.rects,\n\t\t\tdata_in_view: this.rects_to_draw,\n\t\t\tproperties: this.rect_properties,\n\t\t\tvertices: 6,\n\t\t\tprimitive: \"triangles\" });\n\n\t\t//squares\n\t\tthis.square_properties = { 'position': 2, \"color\": 2, \"pick_color\": 2, side_length: 2, \"right_clip\": 1, \"bottom_clip\": 1 };\n\t\tthis.squares_to_draw = {};\n\t\tthis.squares = {};\n\t\tfor (var prop in this.square_properties) {\n\t\t\tthis.squares[prop] = [];\n\t\t\tthis.squares_to_draw[prop] = [];\n\t\t}\n\t\tthis.squares.count = 0;\n\t\tthis.object_types.push({ data: this.squares,\n\t\t\tdata_in_view: this.squares_to_draw,\n\t\t\tproperties: this.square_properties,\n\t\t\tvertices: 1,\n\t\t\tprimitive: \"points\" });\n\n\t\tthis.scale = 1.0;\n\t\tthis.x_scale = 1.0;\n\t\tthis.y_scale = 1.0;\n\t\tthis.offset = [0, 0];\n\n\t\t//images\n\t\tthis.image_properties = { 'position': 2, \"pick_color\": 2, \"color\": 2 };\n\t\tthis.images_to_draw = {};\n\t\tthis.images = {};\n\t\tfor (var prop in this.image_properties) {\n\t\t\tthis.images[prop] = [];\n\t\t\tthis.images_to_draw[prop] = [];\n\t\t}\n\n\t\tthis.images.count = 0;\n\t\tthis.images.props = [];\n\t\tthis.images.globals = [this.offset[0], this.offset[1], this.x_scale, this.y_scale];\n\t\tthis.object_types.push({ data: this.images,\n\t\t\tdata_in_view: this.images_to_draw,\n\t\t\tproperties: this.image_properties,\n\t\t\tvertices: 6,\n\t\t\tprimitive: \"triangles\" });\n\t\tthis.images.display_as_image = true;\n\n\t\t//The last moose position recorded\n\t\tthis.mouse_position = null;\n\t\t//Was an object clicked\n\t\tthis.object_clicked = null;\n\t\t//an object was clicked\n\t\tthis.dragging = false;\n\t\t//object which mouse is over\n\t\tthis.object_mouse_over = null;\n\t\tthis.mouse_over_color = null; //[255,0,0];\n\n\t\tthis.zoom_amount = 0;\n\n\t\tvar self = this;\n\n\t\t(0, _regl.regl)({\n\t\t\tonDone: function onDone(err, regl) {\n\t\t\t\tself.regl = regl;\n\t\t\t\tself.pickbuffer = regl.framebuffer({ colorFormat: 'rgba', height: self.height, width: self.width });\n\t\t\t\tself._initDrawMethods();\n\t\t\t\tself._addHandlers();\n\t\t\t},\n\t\t\tcanvas: self.canvas[0]\n\n\t\t});\n\t}\n\n\t_createClass(WGL2DI, [{\n\t\tkey: \"remove\",\n\t\tvalue: function remove() {}\n\t}, {\n\t\tkey: \"_setUpDocument\",\n\t\tvalue: function _setUpDocument(width, height) {\n\t\t\tif (!height) {\n\t\t\t\theight = this.div_container.height();\n\t\t\t\twidth = this.div_container.width();\n\t\t\t} else {\n\n\t\t\t\tthis.height = height;\n\t\t\t\tthis.width = width;\n\t\t\t\tthis.div_container.height(height);\n\t\t\t\tthis.div_container.width(width);\n\t\t\t}\n\t\t\tthis.canvas = $(\"<canvas>\").attr({\n\t\t\t\theight: height,\n\t\t\t\twidth: width\n\t\t\t}).css({\n\t\t\t\tposition: \"absolute\",\n\t\t\t\tleft: \"0px\",\n\t\t\t\tright: \"0px\"\n\t\t\t});\n\t\t\tthis.label_canvas = $(\"<canvas>\").attr({\n\t\t\t\theight: height,\n\t\t\t\twidth: width\n\t\t\t}).css({\n\t\t\t\tposition: \"absolute\",\n\t\t\t\tleft: \"0px\",\n\t\t\t\tright: \"0px\"\n\t\t\t});\n\t\t\tthis.label_context = this.label_canvas[0].getContext(\"2d\");\n\t\t\tthis.div_container.append(this.canvas).append(this.label_canvas);\n\t\t}\n\t}, {\n\t\tkey: \"setSize\",\n\t\tvalue: function setSize(width, height) {\n\t\t\tvar self = this;\n\t\t\twidth = Math.round(width);\n\t\t\theight = Math.round(height);\n\t\t\tthis.height = height;\n\t\t\tthis.width = width;\n\t\t\tthis.div_container.height(height).width(width);\n\t\t\tthis.canvas.attr({ height: height, width: width });\n\t\t\tthis.label_canvas.attr({ height: height, width: width });\n\t\t\tthis.pickbuffer.destroy();\n\t\t\tthis.pickbuffer = this.regl.framebuffer({ colorFormat: 'rgba', height: height, width: width });\n\t\t\t//this is necessary, but I  don't know why?\n\t\t\tvar loop = this.regl.frame(function () {});\n\t\t\tsetTimeout(function () {\n\t\t\t\tself.refresh();\n\t\t\t\tloop.cancel();\n\t\t\t}, 100);\n\t\t}\n\t}, {\n\t\tkey: \"_getMousePosition\",\n\t\tvalue: function _getMousePosition(e) {\n\t\t\tvar rect = this.canvas[0].getBoundingClientRect();\n\t\t\treturn [e.originalEvent.clientX - rect.left, e.originalEvent.clientY - rect.top];\n\t\t}\n\t}, {\n\t\tkey: \"_getActualPosition\",\n\t\tvalue: function _getActualPosition(position) {\n\t\t\tvar x = position[0] / this.x_scale - this.offset[0];\n\t\t\tvar y = position[1] / this.y_scale - this.offset[1];\n\t\t\treturn [x, y];\n\t\t}\n\t}, {\n\t\tkey: \"_drawLabels\",\n\t\tvalue: function _drawLabels() {\n\t\t\tvar time = Date.now();\n\t\t\tif (this.objects_in_view > 5000) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.label_context.font = \"14px Arial\";\n\n\t\t\tfor (var i in this.object_types) {\n\t\t\t\tvar pos = this.object_types[i].data_in_view.position;\n\n\t\t\t\tfor (var ii = 0; ii < pos.length; ii++) {\n\n\t\t\t\t\tvar x = (pos[ii][0] + this.offset[0]) * this.x_scale;\n\t\t\t\t\tvar y = (pos[ii][1] + this.offset[1]) * this.y_scale;\n\n\t\t\t\t\tthis.label_context.fillText(\"H1\", x, y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"setObjectColor\",\n\t\tvalue: function setObjectColor(key, color) {\n\t\t\tvar obj = this.objects[this.keys[key]];\n\t\t\tvar obj_type = this.object_types[obj[1]];\n\t\t\tfor (var x = obj[0]; x < obj[0] + obj_type.vertices; x++) {\n\t\t\t\tobj_type.data.color[x][0] = color[0] / 255;\n\t\t\t\tobj_type.data.color[x][1] = color[1] / 255;\n\t\t\t\tobj_type.data.color[x][2] = color[2] / 255;\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"getObjectColor\",\n\t\tvalue: function getObjectColor(key) {\n\t\t\tvar obj = this.objects[this.keys[key]];\n\t\t\tvar obj_type = this.object_types[obj[1]];\n\t\t\tvar col = obj_type.data.color[obj[0]];\n\t\t\treturn [col[0] * 255, col[1] * 255, col[2] * 255];\n\t\t}\n\t}, {\n\t\tkey: \"addLine\",\n\t\tvalue: function addLine(positionTo, positionFrom, color, key) {\n\t\t\tvar index = this.objects.length;\n\n\t\t\tif (key && !this.keys[key]) {\n\t\t\t\tthis.keys[key] = index;\n\t\t\t} else {\n\t\t\t\tkey = index;\n\t\t\t\tthis.keys[index] = index;\n\t\t\t}\n\t\t\tvar line_index = this.lines.position.length;\n\t\t\tthis.lines.position.push(positionFrom);\n\t\t\tthis.lines.position.push(positionTo);\n\t\t\tthis.lines.color.push([color[0] / 255, color[1] / 255, color[2] / 255]);\n\t\t\tthis.lines.color.push([color[0] / 255, color[1] / 255, color[2] / 255]);\n\t\t\tthis.lines.pick_color.push(this._getRGBFromIndex(index + 1));\n\t\t\tthis.lines.pick_color.push(this._getRGBFromIndex(index + 1));\n\t\t\tthis.objects.push([line_index, 1, key]);\n\t\t\tthis.lines.count++;\n\t\t}\n\t}, {\n\t\tkey: \"addThickLine\",\n\t\tvalue: function addThickLine(positionTo, positionFrom, width, color, key) {\n\t\t\tvar index = this.objects.length;\n\t\t\tif (key && !this.keys[key]) {\n\t\t\t\tthis.keys[key] = index;\n\t\t\t} else {\n\t\t\t\tkey = index;\n\t\t\t\tthis.keys[index] = index;\n\t\t\t}\n\t\t\tvar rect_index = this.rects.position.length;\n\t\t\tvar x_diff = positionTo[0] - positionFrom[0];\n\t\t\tvar y_diff = positionTo[1] - positionFrom[1];\n\t\t\tvar factor = 0.5 * width / Math.sqrt(x_diff * x_diff + y_diff * y_diff);\n\t\t\tvar x_offset = factor * y_diff;\n\t\t\tvar y_offset = factor * x_diff;\n\t\t\tthis.rects.position.push([positionTo[0] + x_offset, positionTo[1] - y_offset]); //TL\n\t\t\tthis.rects.position.push([positionFrom[0] + x_offset, positionFrom[1] - y_offset]); //BL\n\t\t\tthis.rects.position.push([positionFrom[0] - x_offset, positionFrom[1] + y_offset]); //BR\n\n\t\t\tthis.rects.position.push([positionFrom[0] - x_offset, positionFrom[1] + y_offset]); //BR\n\t\t\tthis.rects.position.push([positionTo[0] - x_offset, positionTo[1] + y_offset]); //TR\n\t\t\tthis.rects.position.push([positionTo[0] + x_offset, positionTo[1] - y_offset]); //TL\n\n\n\t\t\tvar c = [color[0] / 255, color[1] / 255, color[2] / 255];\n\t\t\tvar pc = this._getRGBFromIndex(index + 1);\n\t\t\tfor (var a = 0; a < 6; a++) {\n\t\t\t\tthis.rects.color.push(c);\n\t\t\t\tthis.rects.pick_color.push(pc);\n\t\t\t}\n\t\t\tthis.objects.push([rect_index, 2, key]);\n\t\t\tthis.iamges.count++;\n\t\t\treturn key;\n\t\t}\n\t}, {\n\t\tkey: \"addImage\",\n\t\tvalue: function addImage(position, height, width, image, key) {\n\t\t\tvar self = this;\n\t\t\tvar index = this.objects.length;\n\t\t\tif (key && !this.keys[key]) {\n\t\t\t\tthis.keys[key] = index;\n\t\t\t} else {\n\t\t\t\tkey = index;\n\t\t\t\tthis.keys[index] = index;\n\t\t\t}\n\t\t\tvar x = position[0];\n\t\t\tvar y = position[1];\n\t\t\tvar image_index = this.images.position.length;\n\t\t\tthis.images.position.push([x, y]);\n\t\t\tthis.images.position.push([x, y + height]);\n\t\t\tthis.images.position.push([x + width, y + height]), this.images.position.push([x + width, y + height]);\n\t\t\tthis.images.position.push([x + width, y]);\n\t\t\tthis.images.position.push([x, y]);\n\t\t\tthis.image_position = [[-1, 1], [-1, 0], [0, 0], [0, 0], [0, 1], [-1.0]];\n\t\t\tvar pc = this._getRGBFromIndex(index + 1);\n\t\t\tfor (var a = 0; a < 6; a++) {\n\t\t\t\tthis.images.pick_color.push(pc);\n\t\t\t\tthis.images.color.push([0.1, 0.7, 0.1]);\n\t\t\t}\n\t\t\tvar i_index = this.images.props.length;\n\t\t\tthis.images.props.push({ count: 6, is_buffer: 0, x_y: [x, y], w_h: [width, height],\n\t\t\t\ttext: this.loading_image, position: this.images.position.slice(image_index, image_index + 6), globals: this.images.globals, color: this.images.color.slice(image_index, image_index + 6) });\n\t\t\tvar im = new Image();\n\t\t\tim.src = image;\n\t\t\tthis.images_to_load++;\n\t\t\tim.onload = function () {\n\t\t\t\tself.images.props[i_index].text = self.regl.texture({ data: im, min: \"linear\" });\n\t\t\t\tself.images_to_load--;\n\t\t\t};\n\t\t\tthis.images.count++;\n\n\t\t\tthis.objects.push([image_index, 4, key]);\n\t\t}\n\t}, {\n\t\tkey: \"addRectangle\",\n\t\tvalue: function addRectangle(position, height, width, color, key) {\n\t\t\tvar index = this.objects.length;\n\t\t\tif (key && !this.keys[key]) {\n\t\t\t\tthis.keys[key] = index;\n\t\t\t} else {\n\t\t\t\tkey = index;\n\t\t\t\tthis.keys[index] = index;\n\t\t\t}\n\t\t\tvar rect_index = this.rects.position.length;\n\t\t\tthis.rects.position.push(position);\n\t\t\tthis.rects.position.push([position[0], position[1] + height]);\n\t\t\tthis.rects.position.push([position[0] + width, position[1] + height]);\n\n\t\t\tthis.rects.position.push([position[0] + width, position[1] + height]);\n\t\t\tthis.rects.position.push([position[0] + width, position[1]]);\n\t\t\tthis.rects.position.push([position[0], position[1]]);\n\n\t\t\tvar c = [color[0] / 255, color[1] / 255, color[2] / 255];\n\t\t\tvar pc = this._getRGBFromIndex(index + 1);\n\t\t\tfor (var a = 0; a < 6; a++) {\n\t\t\t\tthis.rects.color.push(c);\n\t\t\t\tthis.rects.pick_color.push(pc);\n\t\t\t}\n\t\t\tthis.objects.push([rect_index, 2, key]);\n\t\t\tthis.rects.count++;\n\t\t\treturn key;\n\t\t}\n\t}, {\n\t\tkey: \"addArc\",\n\t\tvalue: function addArc(position, radius, color, start_angle, end_angle, key) {\n\t\t\tvar index = this.objects.length;\n\t\t\tif (key && !this.keys[key]) {\n\t\t\t\tthis.keys[key] = index;\n\t\t\t} else {\n\t\t\t\tkey = index;\n\t\t\t\tthis.keys[index] = index;\n\t\t\t}\n\t\t\tvar circ_index = this.circles.position.length;\n\t\t\tthis.circles.position.push(position);\n\t\t\tthis.circles.radius.push(radius);\n\t\t\tthis.circles.color.push([color[0] / 255, color[1] / 255, color[2] / 255]);\n\t\t\tthis.circles.pick_color.push(this._getRGBFromIndex(index + 1));\n\t\t\tthis.circles.start_angle.push(start_angle);\n\t\t\tthis.circles.end_angle.push(end_angle);\n\t\t\tthis.objects.push([circ_index, 0, key]);\n\t\t\tthis.circles.count++;\n\t\t}\n\t}, {\n\t\tkey: \"addCircle\",\n\t\tvalue: function addCircle(position, radius, color, key) {\n\t\t\tvar index = this.objects.length;\n\t\t\tif (key && !this.keys[key]) {\n\t\t\t\tthis.keys[key] = index;\n\t\t\t} else {\n\t\t\t\tkey = index;\n\t\t\t\tthis.keys[index] = index;\n\t\t\t}\n\t\t\tvar circ_index = this.circles.position.length;\n\t\t\tthis.circles.position.push(position);\n\t\t\tthis.circles.radius.push(radius);\n\t\t\tthis.circles.opacity.push(1);\n\t\t\tthis.circles.color.push([color[0] / 255, color[1] / 255, color[2] / 255]);\n\t\t\tthis.circles.pick_color.push(this._getRGBFromIndex(index + 1));\n\t\t\tthis.circles.start_angle.push(10);\n\t\t\tthis.circles.end_angle.push(0);\n\t\t\tthis.objects.push([circ_index, 0, key]);\n\t\t\tthis.circles.count++;\n\t\t}\n\t}, {\n\t\tkey: \"addPointRectangle\",\n\t\tvalue: function addPointRectangle(position, height, width, color, key) {\n\t\t\tvar side_length = height > width ? height : width;\n\t\t\tvar index = this.objects.length;\n\t\t\tif (key && !this.keys[key]) {\n\t\t\t\tthis.keys[key] = index;\n\t\t\t} else {\n\t\t\t\tkey = index;\n\t\t\t\tthis.keys[index] = index;\n\t\t\t}\n\n\t\t\tvar square_index = this.squares.position.length;\n\t\t\tthis.squares.position.push([position[0] + side_length / 2, position[1] + side_length / 2]);\n\t\t\tthis.squares.color.push([color[0] / 255, color[1] / 255, color[2] / 255]);\n\t\t\tthis.squares.side_length.push(side_length);\n\t\t\tthis.squares.right_clip.push(width / side_length);\n\t\t\tthis.squares.bottom_clip.push(height / side_length);\n\t\t\tthis.squares.pick_color.push(this._getRGBFromIndex(index + 1));\n\t\t\tthis.objects.push([square_index, 3, key]);\n\t\t\tthis.squares.count++;\n\t\t}\n\t}, {\n\t\tkey: \"_getRGBFromIndex\",\n\t\tvalue: function _getRGBFromIndex(index) {\n\t\t\tvar b = Math.floor(index / 65536);\n\t\t\tvar temp = index % 65536;\n\t\t\tvar g = Math.floor(temp / 256);\n\t\t\tvar r = temp % 256;\n\t\t\treturn [r / 255, g / 255, b / 255];\n\t\t}\n\t}, {\n\t\tkey: \"_getIndexFromRGB\",\n\t\tvalue: function _getIndexFromRGB(rgb) {\n\t\t\treturn rgb[2] * 65536 + rgb[1] * 256 + rgb[0];\n\t\t}\n\t}, {\n\t\tkey: \"_drawPickBuffer\",\n\t\tvalue: function _drawPickBuffer(in_view) {\n\t\t\tthis.regl.clear({\n\t\t\t\tcolor: [0, 0, 0, 0],\n\t\t\t\tdepth: 1,\n\t\t\t\tframebuffer: this.pickbuffer\n\t\t\t});\n\t\t\tthis._drawObjects(true, in_view);\n\t\t}\n\t\t//refesh all \n\t\t//in_view only those in view\n\n\t}, {\n\t\tkey: \"refresh\",\n\t\tvalue: function refresh(in_view) {\n\t\t\tthis.label_context.clearRect(0, 0, this.width, this.height);\n\t\t\tthis._drawObjects(false, in_view);\n\t\t\tthis._drawPickBuffer(in_view);\n\t\t\tthis.label_context.font = \"30px Arial\";\n\t\t}\n\t}, {\n\t\tkey: \"zoom\",\n\t\tvalue: function zoom(amount) {\n\t\t\tthis.x_scale *= amount;\n\t\t\tthis.y_scale *= amount;\n\t\t\tthis._drawObjects(false);\n\t\t}\n\t}, {\n\t\tkey: \"_drawObject\",\n\t\tvalue: function _drawObject(object, color) {\n\n\t\t\tvar type = this.object_types[object[1]];\n\t\t\tvar obj = {\n\t\t\t\tstage_width: this.width,\n\t\t\t\tstage_height: this.height,\n\t\t\t\tx_scale: this.x_scale,\n\t\t\t\ty_scale: this.y_scale,\n\t\t\t\tbuffer: null,\n\t\t\t\toffset: this.offset,\n\t\t\t\tcount: type.vertices,\n\t\t\t\tprimitive: type.primitive,\n\t\t\t\tis_buffer: 0\n\n\t\t\t};\n\n\t\t\tfor (var prop in type.properties) {\n\t\t\t\tif (prop === 'pick_color') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tobj[prop] = [];\n\t\t\t\tvar st = object[0];\n\t\t\t\tvar en = st + type.vertices;\n\t\t\t\tfor (var pos = st; pos < en; pos++) {\n\t\t\t\t\tif (prop !== 'color') {\n\t\t\t\t\t\tobj[prop].push(type.data[prop][pos]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tobj[prop].push(color);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttype.method(obj);\n\t\t}\n\t}, {\n\t\tkey: \"_drawObjects\",\n\t\tvalue: function _drawObjects(buffer, in_view) {\n\t\t\t//dr\n\t\t\tthis.images.globals[0] = this.offset[0];\n\t\t\tthis.images.globals[1] = this.offset[1];\n\t\t\tthis.images.globals[2] = this.x_scale;\n\t\t\tthis.images.globals[3] = this.y_scale;\n\t\t\tif (this.images.display_as_image) {\n\t\t\t\tthis.__drawImages(this.images.props);\n\t\t\t}\n\n\t\t\tvar data_source = in_view ? \"data_in_view\" : \"data\";\n\t\t\tfor (var i in this.object_types) {\n\t\t\t\tvar type = this.object_types[i];\n\t\t\t\tif (type[data_source].count === 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (buffer) {\n\t\t\t\t\tbuffer = this.pickbuffer;\n\t\t\t\t} else {\n\t\t\t\t\tbuffer = null;\n\t\t\t\t}\n\t\t\t\t//don't draw images unless buffer\n\t\t\t\tif (!buffer && i == 4 && this.images.display_as_image) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tvar obj = {\n\t\t\t\t\tstage_width: this.width,\n\t\t\t\t\tstage_height: this.height,\n\t\t\t\t\tx_scale: this.x_scale,\n\t\t\t\t\ty_scale: this.y_scale,\n\t\t\t\t\tglobals: this.images.globals,\n\t\t\t\t\tbuffer: buffer,\n\t\t\t\t\toffset: this.offset,\n\t\t\t\t\tcount: type[data_source].count * type.vertices,\n\t\t\t\t\tprimitive: type.primitive,\n\t\t\t\t\tis_buffer: buffer ? 1 : 0\n\n\t\t\t\t};\n\t\t\t\t//dummy values\n\t\t\t\tif (i == 4) {\n\t\t\t\t\tobj.w_h = [0, 0];\n\t\t\t\t\tobj.x_y = [0, 0];\n\t\t\t\t\tobj.text = this.loading_image;\n\t\t\t\t\tobj.is_buffer = 1;\n\t\t\t\t}\n\t\t\t\tfor (var prop in type.properties) {\n\n\t\t\t\t\tif (buffer) {\n\t\t\t\t\t\tif (prop === 'pick_color') {\n\t\t\t\t\t\t\tobj['color'] = type[data_source][prop];\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (prop === 'color') {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tobj[prop] = type[data_source][prop];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (prop === 'pick_color') {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tobj[prop] = type[data_source][prop];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttype.method(obj);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"filterObjects\",\n\t\tvalue: function filterObjects(keys, object_type) {\n\t\t\tif (!object_type) {\n\t\t\t\tobject_type = 0;\n\t\t\t}\n\t\t\t//this.is_filtered={};\n\n\t\t\tvar obj_type = this.object_types[object_type];\n\t\t\tvar _iteratorNormalCompletion = true;\n\t\t\tvar _didIteratorError = false;\n\t\t\tvar _iteratorError = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator = this.objects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\t\t\tvar obj = _step.value;\n\n\t\t\t\t\tvar key = obj[2];\n\t\t\t\t\tif (keys[key]) {\n\t\t\t\t\t\tobj_type.data.opacity[obj[0]] = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//this.is_filtered[key]=true;\n\t\t\t\t\t\tobj_type.data.opacity[obj[0]] = 0.4;\n\t\t\t\t\t}\n\t\t\t\t\tif (this.is_hidden[key]) {\n\t\t\t\t\t\tobj_type.data.opacity[obj[0]] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError = true;\n\t\t\t\t_iteratorError = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t\t\t_iterator.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError) {\n\t\t\t\t\t\tthrow _iteratorError;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"hideObjects\",\n\t\tvalue: function hideObjects(keys, object_type) {\n\t\t\tif (!object_type) {\n\t\t\t\tobject_type = 0;\n\t\t\t}\n\t\t\tthis.is_hidden = {};\n\n\t\t\tvar obj_type = this.object_types[object_type];\n\t\t\tvar _iteratorNormalCompletion2 = true;\n\t\t\tvar _didIteratorError2 = false;\n\t\t\tvar _iteratorError2 = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator2 = this.objects[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t\t\t\t\tvar obj = _step2.value;\n\n\t\t\t\t\tvar key = obj[2];\n\t\t\t\t\tif (keys[key]) {\n\n\t\t\t\t\t\tobj_type.data.opacity[obj[0]] = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.is_hidden[key] = true;\n\t\t\t\t\t\tobj_type.data.opacity[obj[0]] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError2 = true;\n\t\t\t\t_iteratorError2 = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t\t\t\t\t\t_iterator2.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError2) {\n\t\t\t\t\t\tthrow _iteratorError2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"initialise\",\n\t\tvalue: function initialise() {\n\t\t\tvar self = this;\n\n\t\t\tvar im = new Image();\n\n\t\t\tim.onload = function () {\n\t\t\t\tself.loading_image = self.regl.texture({ data: im, min: \"linear\" });\n\t\t\t\tvar _iteratorNormalCompletion3 = true;\n\t\t\t\tvar _didIteratorError3 = false;\n\t\t\t\tvar _iteratorError3 = undefined;\n\n\t\t\t\ttry {\n\t\t\t\t\tfor (var _iterator3 = self.images.props[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t\t\t\t\t\tvar prop = _step3.value;\n\n\t\t\t\t\t\tif (!prop.text) {\n\t\t\t\t\t\t\tprop.text = self.loading_image;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (err) {\n\t\t\t\t\t_didIteratorError3 = true;\n\t\t\t\t\t_iteratorError3 = err;\n\t\t\t\t} finally {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t\t\t\t\t\t\t_iterator3.return();\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tif (_didIteratorError3) {\n\t\t\t\t\t\t\tthrow _iteratorError3;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tself.refresh();\n\t\t\t\tself._getObjectsInView();\n\t\t\t};\n\t\t\tim.src = \"tn13.png\";\n\t\t}\n\t}, {\n\t\tkey: \"_getObjectAtPosition\",\n\t\tvalue: function _getObjectAtPosition(position) {\n\t\t\tvar pixel = this.regl.read({\n\t\t\t\tx: position[0],\n\t\t\t\ty: this.height - position[1],\n\t\t\t\twidth: 1,\n\t\t\t\theight: 1,\n\t\t\t\tdata: new Uint8Array(6),\n\t\t\t\tframebuffer: this.pickbuffer\n\t\t\t});\n\t\t\tvar index = this._getIndexFromRGB(pixel);\n\t\t\tif (index > 0) {\n\t\t\t\treturn this.objects[index - 1];\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}, {\n\t\tkey: \"checkImagesLoaded\",\n\t\tvalue: function checkImagesLoaded() {\n\t\t\tvar self = this;\n\n\t\t\tif (this.images_to_load > 0) {\n\t\t\t\tsetTimeout(function () {\n\t\t\t\t\tself.refresh();\n\t\t\t\t\tself.checkImagesLoaded();\n\t\t\t\t}, 2000);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"_getObjectsInView\",\n\t\tvalue: function _getObjectsInView() {\n\t\t\tvar time = Date.now();\n\t\t\tvar max = this.width * this.height * 4;\n\t\t\tvar pixels = this.regl.read({\n\t\t\t\tx: 0,\n\t\t\t\ty: 0,\n\t\t\t\twidth: this.width,\n\t\t\t\theight: this.height,\n\t\t\t\tdata: new Uint8Array(max),\n\t\t\t\tframebuffer: this.pickbuffer\n\t\t\t});\n\t\t\tvar obj = {};\n\t\t\tthis._clearObjectsInView();\n\t\t\tfor (var i = 0; i < max - 4; i += 4) {\n\t\t\t\tvar index = pixels[i + 2] * 65536 + pixels[i + 1] * 256 + pixels[i];\n\t\t\t\tif (index > 0) {\n\t\t\t\t\tif (!obj[index - 1]) {\n\t\t\t\t\t\tobj[index - 1] = true;\n\t\t\t\t\t\tthis.objects_in_view++;\n\t\t\t\t\t\tif (this.objects_in_view > 100000) {\n\t\t\t\t\t\t\tfor (var t in this.object_types) {\n\t\t\t\t\t\t\t\tvar type = this.object_types[t];\n\t\t\t\t\t\t\t\tfor (var prop in type.properties) {\n\t\t\t\t\t\t\t\t\ttype.data_in_view[prop] = type.data[prop];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttype.data_in_view.count = type.data.count;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis.objects_in_view = this.objects.length;\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//console.log(\"objects in view old way \"+(Date.now()-time));\n\t\t\tvar l = -this.offset[0];\n\t\t\tvar r = l + this.width / this.x_scale;\n\t\t\tvar t = -this.offset[1];\n\t\t\tvar b = t + this.height / this.y_scale;\n\t\t\tvar old_count = 0;\n\t\t\tvar new_count = 0;\n\t\t\tfor (var i = 0; i < this.objects.length; i++) {\n\t\t\t\tif (obj[i]) {\n\t\t\t\t\tvar item = this.objects[i];\n\t\t\t\t\tvar type = this.object_types[item[1]];\n\t\t\t\t\tnew_count++;\n\n\t\t\t\t\tvar st = item[0];\n\t\t\t\t\tvar en = st + type.vertices;\n\t\t\t\t\tfor (var prop in type.properties) {\n\t\t\t\t\t\tfor (var pos = st; pos < en; pos++) {\n\t\t\t\t\t\t\ttype.data_in_view[prop].push(type.data[prop][pos]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ttype.data_in_view.count++;\n\t\t\t\t} else {\n\n\t\t\t\t\tvar item = this.objects[i];\n\t\t\t\t\tvar type = this.object_types[item[1]];\n\t\t\t\t\tvar act_pos = this.object_types[item[1]].data.position[item[0]];\n\t\t\t\t\tif (act_pos[0] > l && act_pos[0] < r && act_pos[1] > t && act_pos[1] < b) {\n\t\t\t\t\t\told_count++;\n\t\t\t\t\t\tvar st = item[0];\n\t\t\t\t\t\tvar en = st + type.vertices;\n\t\t\t\t\t\tfor (var prop in type.properties) {\n\t\t\t\t\t\t\tfor (var pos = st; pos < en; pos++) {\n\t\t\t\t\t\t\t\ttype.data_in_view[prop].push(type.data[prop][pos]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttype.data_in_view.count++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tconsole.log(\"In view:\" + this.objects.length + \":\" + new_count + \":\" + old_count);\n\n\t\t\tconsole.log(\"time to get objects in view \" + (Date.now() - time));\n\t\t}\n\t}, {\n\t\tkey: \"_clearObjectsInView\",\n\t\tvalue: function _clearObjectsInView() {\n\t\t\tthis.objects_in_view = 0;\n\t\t\tfor (var i in this.object_types) {\n\t\t\t\tvar obj = this.object_types[i];\n\n\t\t\t\tfor (var prop in obj.properties) {\n\t\t\t\t\tobj.data_in_view[prop] = [];\n\t\t\t\t}\n\n\t\t\t\tobj.data_in_view.count = 0;\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"addHandler\",\n\t\tvalue: function addHandler(handler_type, handler, name) {\n\t\t\tvar handler_dict = this.handlers[handler_type];\n\t\t\tif (!handler_dict) {\n\t\t\t\tthrow \"Handler Not Supported\";\n\t\t\t}\n\t\t\tif (!name) {\n\t\t\t\tname = Object.keys(handler_dict).length;\n\t\t\t}\n\t\t\thandler_dict[name] = handler;\n\t\t\treturn name;\n\t\t}\n\t}, {\n\t\tkey: \"removeHandler\",\n\t\tvalue: function removeHandler(handler_type, name) {\n\t\t\tvar handler_dict = this.handlers[handler_type];\n\t\t\tif (!handler_dict) {\n\t\t\t\tthrow \"Handler Not Supported\";\n\t\t\t}\n\t\t\tdelete handler_dict['name'];\n\t\t}\n\t}, {\n\t\tkey: \"_setUpBrush\",\n\t\tvalue: function _setUpBrush(origin) {\n\t\t\tvar self = this;\n\t\t\tvar div = $(\"<div>\").css({ position: \"absolute\", left: origin[0],\n\t\t\t\ttop: origin[1], height: \"0px\", width: \"0px\",\n\t\t\t\t\"background-color\": \"gray\", opacity: 0.2 }).appendTo(this.div_container);\n\n\t\t\tdiv.draggable({\n\t\t\t\tstart: function start(ev, ui) {\n\t\t\t\t\tself.brush.moving = true;\n\t\t\t\t},\n\t\t\t\tstop: function stop(ev, ui) {\n\t\t\t\t\tself._brushingStopped();\n\t\t\t\t}\n\n\t\t\t}).resizable({\n\t\t\t\thandles: \"all\",\n\t\t\t\tstart: function start(ev, ui) {\n\t\t\t\t\tself.brush.moving = true;\n\t\t\t\t},\n\t\t\t\tstop: function stop(ev, ui) {\n\t\t\t\t\tself._brushingStopped();\n\t\t\t\t}\n\n\t\t\t});\n\t\t\tthis.brush = { origin: origin, div: div, resizing: true };\n\t\t}\n\t}, {\n\t\tkey: \"clearBrush\",\n\t\tvalue: function clearBrush() {\n\t\t\tif (this.brush) {\n\t\t\t\tthis.brush.div.remove();\n\t\t\t\tthis.brush = null;\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"_brushingStopped\",\n\t\tvalue: function _brushingStopped() {\n\t\t\tthis.brush.resizing = false;\n\t\t\tvar pos = this.brush.div.position();\n\t\t\tvar lt = this._getActualPosition([pos.left, pos.top]);\n\t\t\tvar br = this._getActualPosition([pos.left + this.brush.div.width(), pos.top + this.brush.div.height()]);\n\t\t\tvar info = { x_min: lt[0], x_max: br[0], y_min: lt[1], y_max: br[1] };\n\t\t\tfor (var i in this.handlers.brush_stopped) {\n\t\t\t\tthis.handlers.brush_stopped[i](info);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"_addHandlers\",\n\t\tvalue: function _addHandlers() {\n\t\t\tvar self = this;\n\t\t\tthis.div_container.mousemove(function (e) {\n\t\t\t\tif (self.brush) {\n\t\t\t\t\tif (self.brush.resizing) {\n\t\t\t\t\t\tvar origin = self.brush.origin;\n\t\t\t\t\t\tvar now = self._getMousePosition(e);\n\t\t\t\t\t\tvar left = Math.round(origin[0] < now[0] ? origin[0] : now[0]) + \"px\";\n\t\t\t\t\t\tvar top = Math.round(origin[1] < now[1] ? origin[1] : now[1]) + \"px\";\n\t\t\t\t\t\tvar width = Math.abs(origin[0] - now[0]) + \"px\";\n\t\t\t\t\t\tvar height = Math.abs(origin[1] - now[1]) + \"px\";\n\t\t\t\t\t\tself.brush.div.css({ top: top, left: left, height: height, width: width });\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else if (self.brush.moving) {\n\t\t\t\t\t\tself.dragging = false;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//is this a drag or just a click without the mouse moving\n\t\t\t\tif (self.mouse_position && !self.dragging) {\n\t\t\t\t\tvar x_amount = (e.pageX - self.mouse_position[0]) / self.x_scale;\n\t\t\t\t\tvar y_amount = (e.pageY - self.mouse_position[1]) / self.y_scale;\n\t\t\t\t\tif (Math.abs(x_amount) > 3 || Math.abs(y_amount) > 3) {\n\t\t\t\t\t\tself.dragging = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (self.dragging) {\n\t\t\t\t\tvar x_amount = (e.pageX - self.mouse_position[0]) / self.x_scale;\n\t\t\t\t\tvar y_amount = (e.pageY - self.mouse_position[1]) / self.y_scale;\n\t\t\t\t\tif (self.object_clicked) {\n\n\t\t\t\t\t\tvar type = self.object_types[self.object_clicked[1]];\n\t\t\t\t\t\tvar start = self.object_clicked[0];\n\t\t\t\t\t\tvar end = start + type.vertices;\n\n\t\t\t\t\t\tfor (var index = start; index < end; index++) {\n\t\t\t\t\t\t\ttype.data.position[index][0] += x_amount;\n\t\t\t\t\t\t\ttype.data.position[index][1] += y_amount;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (self.object_clicked[1] == 4) {\n\t\t\t\t\t\t\tvar p_index = start / 6;\n\t\t\t\t\t\t\tself.images.props[p_index].x_y = [type.data.position[start][0], type.data.position[start][1]];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tself.refresh(true);\n\t\t\t\t\t\t//self._drawLabels();\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tself.offset[0] += x_amount;\n\t\t\t\t\t\tself.offset[1] += y_amount;\n\t\t\t\t\t\tself._drawObjects(false);\n\t\t\t\t\t}\n\t\t\t\t\tself.mouse_position[1] = e.pageY;\n\t\t\t\t\tself.mouse_position[0] = e.pageX;\n\t\t\t\t}\n\t\t\t\t//no drag event going on call any listners if mouse over/out an object\n\t\t\t\telse {\n\t\t\t\t\t\tvar position = self._getMousePosition(e);\n\t\t\t\t\t\tvar obj = self._getObjectAtPosition(position);\n\t\t\t\t\t\tif (obj && !self.object_mouse_over) {\n\t\t\t\t\t\t\tfor (var i in self.handlers['object_over']) {\n\t\t\t\t\t\t\t\tself.handlers.object_over[i](obj[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tself.object_mouse_over = obj;\n\t\t\t\t\t\t\tif (self.mouse_over_color) {\n\t\t\t\t\t\t\t\tself.object_temp_color = self.getObjectColor(obj[2]);\n\t\t\t\t\t\t\t\tself.setObjectColor(obj[2], self.mouse_over_color);\n\t\t\t\t\t\t\t\tself.refresh(true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (!obj && self.object_mouse_over) {\n\t\t\t\t\t\t\tfor (var i in self.handlers['object_out']) {\n\t\t\t\t\t\t\t\tself.handlers.object_out[i](self.object_mouse_over[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (self.mouse_over_color) {\n\t\t\t\t\t\t\t\tself.setObjectColor(self.object_mouse_over[2], self.object_temp_color);\n\t\t\t\t\t\t\t\tself.refresh(true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tself.object_mouse_over = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//move directly from one object to another\n\t\t\t\t\t\telse if (obj && obj[2] !== self.object_mouse_over[2]) {\n\t\t\t\t\t\t\t\tfor (var i in self.handlers['object_over']) {\n\t\t\t\t\t\t\t\t\tself.handlers.object_over[i](obj[2]);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tfor (var i in self.handlers['object_out']) {\n\t\t\t\t\t\t\t\t\tself.handlers.object_out[i](self.object_mouse_over[2]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (self.mouse_over_color) {\n\t\t\t\t\t\t\t\t\tself.setObjectColor(self.object_mouse_over[2], self.object_temp_color);\n\t\t\t\t\t\t\t\t\tself.object_temp_color = self.getObjectColor(obj[2]);\n\t\t\t\t\t\t\t\t\tself.setObjectColor(obj[2], self.mouse_over_color);\n\t\t\t\t\t\t\t\t\tself.refresh(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tself.object_mouse_over = obj;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t});\n\t\t\tthis.div_container.mouseup(function (evt) {\n\t\t\t\t//just a click event - inform handlers\n\t\t\t\tif (self.brush && self.brush.resizing) {\n\t\t\t\t\tself._brushingStopped();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (!self.dragging) {\n\t\t\t\t\tif (self.object_clicked) {\n\t\t\t\t\t\tvar position = self._getMousePosition(evt);\n\t\t\t\t\t\tvar obj = self._getObjectAtPosition(position);\n\t\t\t\t\t\tif (obj) {\n\t\t\t\t\t\t\tfor (var i in self.handlers.object_clicked) {\n\t\t\t\t\t\t\t\tself.handlers.object_clicked[i](obj[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t//an object has finshed its drag\n\t\t\t\t\tif (self.object_clicked) {\n\t\t\t\t\t\tself.object_clicked = null;\n\t\t\t\t\t\tself.refresh(true);\n\t\t\t\t\t}\n\t\t\t\t\t//update which objects are now in view\n\t\t\t\t\telse {\n\t\t\t\t\t\t\tself._drawPickBuffer();\n\t\t\t\t\t\t\tself._getObjectsInView();\n\t\t\t\t\t\t\tif (self.brush) {\n\t\t\t\t\t\t\t\tself._brushingStopped();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tself.refresh(true);\n\t\t\t\t\t\t}\n\t\t\t\t\tself.dragging = false;\n\t\t\t\t}\n\t\t\t\tself.object_clicked = null;\n\t\t\t\tself.mouse_position = null;\n\t\t\t});\n\n\t\t\tthis.div_container.bind('mousewheel DOMMouseScroll', function (event) {\n\t\t\t\tvar position = self._getActualPosition(self._getMousePosition(event));\n\t\t\t\tif (event.originalEvent.wheelDelta > 0 || event.originalEvent.detail < 0) {\n\t\t\t\t\tself.zoom_amount += 0.05;\n\t\t\t\t} else {\n\t\t\t\t\tself.zoom_amount -= 0.05;\n\t\t\t\t}\n\n\t\t\t\tself.x_scale *= 1 + self.zoom_amount;\n\t\t\t\tself.y_scale *= 1 + self.zoom_amount;\n\n\t\t\t\t//self.images.display_as_image=self.x_scale>0.04;\n\n\t\t\t\tvar new_position = self._getActualPosition(self._getMousePosition(event));\n\t\t\t\tself.offset[0] += new_position[0] - position[0];\n\t\t\t\tself.offset[1] += new_position[1] - position[1];\n\t\t\t\tif (!self.loop) {\n\t\t\t\t\tself.loop = self.regl.frame(function () {\n\t\t\t\t\t\tself._drawObjects(false);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t//clear the timeout user has not finished zooming\n\t\t\t\tclearTimeout($.data(this, 'timer'));\n\t\t\t\t//when user finishes call the esxpensive methods;\n\t\t\t\t$.data(this, 'timer', setTimeout(function () {\n\t\t\t\t\tself.zoom_amount = 0;\n\t\t\t\t\tself.loop.cancel();\n\t\t\t\t\tself.loop = null;\n\t\t\t\t\tself._drawPickBuffer(false);\n\t\t\t\t\tself._getObjectsInView();\n\t\t\t\t\tif (self.brush) {}\n\t\t\t\t\tself.refresh(true);\n\t\t\t\t}, 350));\n\t\t\t});\n\t\t\tthis.div_container.mousedown(function (evt) {\n\t\t\t\tif (evt.which === 3) {}\n\t\t\t\t//add right click behaviour\n\n\t\t\t\t//create brush\n\t\t\t\tif (evt.shiftKey && !self.brush) {\n\t\t\t\t\tvar origin = self._getMousePosition(evt);\n\t\t\t\t\tself._setUpBrush(origin);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t//get mouse position and work out if an object was clicked\n\t\t\t\tvar position = self._getMousePosition(evt);\n\t\t\t\tself.mouse_position = [evt.pageX, evt.pageY];\n\t\t\t\tvar obj = self._getObjectAtPosition(position);\n\n\t\t\t\tif (obj) {\n\t\t\t\t\tself.object_clicked = obj;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}, {\n\t\tkey: \"_initDrawMethods\",\n\t\tvalue: function _initDrawMethods() {\n\t\t\tvar self = this;\n\n\t\t\t//loading images\n\n\n\t\t\tthis.__drawCircles = this.regl({\n\t\t\t\tfrag: 'precision highp float;\\n\\\n\t\t\tvarying vec3 fragColor;\\n\\\n\t\t\tvarying float op;\\n\\\n\t\t\t\t\tvarying float s_angle;\\n\\\n\t\t\t\t\tvarying float e_angle;\\n\\\n\t\t\tvoid main(){\\n\\\n\t\t\t\t\t\t\tfloat r = 0.0;\\n\\\n\t\t\t\t\t\t\tvec2 cxy = 2.0 * gl_PointCoord - 1.0;\\n\\\n\t\t\t\t\t\t\tr = dot(cxy, cxy);\\n\\\n\t\t\t\t\t\t\tif (r > 1.0) {\\n\\\n\t\t\t\t\t\t\t\tdiscard;\\n\\\n\t\t\t\t\t\t\t\treturn;\\n\\\n\t\t\t\t\t\t\t}\\n\\\n\t\t\t\t\t\t\telse{\\n\\\n\t\t\t\t\t\t\t\tif (s_angle != 10.0){\\n\\\n\t\t\t\t\t\t\t\t\tfloat angle=0.0;\\n\\\n\t\t\t\t\t\t\t\t\tangle =atan(cxy[1],cxy[0]);\\n\\\n\t\t\t\t\t\t\t\t\tif (angle>s_angle && angle < e_angle){\\n\\\n\t\t\t\t\t\t\t\t\t\tif(r>0.75){\\n\\\n\t\t\t\t\t\t\t\t\t\t\tgl_FragColor=vec4(0.1,0.1,0.1,op);\\n\\\n\t\t\t\t\t\t\t\t\t\t}\\n\\\n\t\t\t\t\t\t\t\t\t\telse{\\n\\\n\t\t\t\t\t\t\t\t\t\t\tgl_FragColor = vec4(fragColor,op);\\n\\\n\t\t\t\t\t\t\t\t\t\t}\\n\\\n\t\t\t\t\t\t\t\t\t}\\n\\\n\t\t\t\t\t\t\t\t\telse{\\n\\\n\t\t\t\t\t\t\t\t\t\tdiscard;\\n\\\n\t\t\t\t\t\t\t\t\t}\\n\\\n\t\t\t\t\t\t\t\t}\\n\\\n\t\t\t\t\t\t\t\telse{\\n\\\n\t\t\t\t\t\t\t\t\tif(r>0.75){\\n\\\n\t\t\t\t\t\t\t\t\t\tgl_FragColor=vec4(0.1,0.1,0.1,op);\\n\\\n\t\t\t\t\t\t\t\t\t}\\n\\\n\t\t\t\t\t\t\t\t\telse{\\n\\\n\t\t\t\t\t\t\t\t\t\tgl_FragColor = vec4(fragColor,op);\\n\\\n\t\t\t\t\t\t\t\t\t}\\n\\\n\t\t\t\t\t\t\t\t}\\n\\\n\t\t\t\t\t\t\t}\\n\\\n\t\t\t\t\t}\\n',\n\n\t\t\t\tvert: 'attribute vec2 position;\\n\\\n\t\t\tattribute vec3 color;\\n\\\n\t\t\tattribute float opacity;\\n\\\n\t\t\t\t\tattribute mat4 segments1;\\n\\\n\t\t\tvarying vec3 fragColor;\\n\\\n\t\t\tvarying float op;\\n\\\n\t\t\t\t\tattribute float start_angle;\\n\\\n\t\t\t\t\tvarying float s_angle;\\n\\\n\t\t\t\t\tvarying float e_angle;\\n\\\n\t\t\t\t\tattribute float end_angle;\\n\\\n\t\t\tattribute float radius;\\n\\\n\t\t\t\t\tuniform float x_scale;\\n\\\n\t\t\t\t\tuniform float y_scale;\\n\\\n\t\t\t\t\tuniform vec2 offset;\\n\\\n\t\t\t\t\tuniform float stage_height;\\n\\\n\t\t\t\t\tuniform float stage_width;\\n\\\n\t\t\tvec2 normalizeCoords(vec2 position){\\n\\\n\t\t\t\t\t\t\tfloat x = (position[0]+offset[0])*x_scale;\\n\\\n\t\t\t\t\t\t\tfloat y = (position[1]+offset[1])*y_scale;\\n\\\n\t\t\t\treturn vec2(2.0 * ((x / stage_width) - 0.5),-(2.0 * ((y / stage_height) - 0.5)));\\n\\\n\t\t\t\t\t}\\n\\\n\t\t\tvoid main() {\\n\\\n\t\t\t   if (opacity==0.0){\\n\\\n\t\t\t         return;\\n\\\n\t\t\t\t}\\n\\\n\t\t\t\tgl_PointSize = radius*x_scale;\\n\\\n\t\t\t\t\t\t\tfragColor = color;\\n\\\n\t\t\t\t\t\t\top=opacity;\\n\\\n\t\t\t\t\t\t\ts_angle=start_angle;\\n\\\n\t\t\t\t\t\t\te_angle = end_angle;\\n\\\n\t\t\t\t\t\t\tvec2 real_position = normalizeCoords(position);\\n\\\n\t\t\t\t\t\t\tgl_Position = vec4(real_position, 0.0, 1.0);\\n\\\n\t\t\t}\\n',\n\n\t\t\t\tattributes: {\n\t\t\t\t\tposition: self.regl.prop('position'),\n\t\t\t\t\tcolor: self.regl.prop('color'),\n\t\t\t\t\tradius: self.regl.prop('radius'),\n\t\t\t\t\tstart_angle: self.regl.prop('start_angle'),\n\t\t\t\t\tend_angle: self.regl.prop(\"end_angle\"),\n\t\t\t\t\topacity: self.regl.prop(\"opacity\")\n\n\t\t\t\t},\n\n\t\t\t\tuniforms: {\n\t\t\t\t\tx_scale: self.regl.prop('x_scale'),\n\t\t\t\t\ty_scale: self.regl.prop('y_scale'),\n\t\t\t\t\tstage_width: self.regl.prop('stage_width'),\n\t\t\t\t\tstage_height: self.regl.prop('stage_height'),\n\t\t\t\t\toffset: self.regl.prop(\"offset\")\n\t\t\t\t},\n\n\t\t\t\tcount: self.regl.prop('count'),\n\t\t\t\tprimitive: self.regl.prop('primitive'),\n\t\t\t\tframebuffer: self.regl.prop(\"buffer\")\n\t\t\t});\n\t\t\tthis.object_types[0]['method'] = this.__drawCircles;\n\n\t\t\tthis.__drawLines = this.regl({\n\n\t\t\t\t// fragment shader\n\t\t\t\tfrag: ' precision highp float;\\n\\\n\t\t\t\t\t\tvarying vec3 fragColor;\\n\\\n\t\t\t\t\t\tvoid main () {\\n\\\n\t\t\t\t\t\t\t gl_FragColor = vec4(fragColor,1);\\n\\\n\t\t\t\t\t\t}\\n',\n\n\t\t\t\tvert: '\\\n\t\t\t\t\t\tattribute vec2 position;\\n\\\n\t\t\t\t\t\tattribute vec3 color;\\n\\\n\t\t\t\t\t\tuniform float x_scale;\\n\\\n\t\t\t\t\t\tuniform float y_scale;\\n\\\n\t\t\t\t\t\tuniform vec2 offset;\\n\\\n\t\t\t\t\t\tuniform float stage_height;\\n\\\n\t\t\t\t\t\tuniform float stage_width;\\n\\\n\t\t\t\t\t\tvarying vec3 fragColor;\\n\\\n\t\t\t\t\t\tvec2 normalizeCoords(vec2 position){\\n\\\n\t\t\t\t\t\t\tfloat x = (position[0]+offset[0])*x_scale;\\n\\\n\t\t\t\t\t\t\tfloat y = (position[1]+offset[1])*y_scale;\\n\\\n\t\t\t\treturn vec2(2.0 * ((x / stage_width) - 0.5),-(2.0 * ((y / stage_height) - 0.5)));\\n\\\n\t\t\t\t\t\t}\\n\\\n\t\t\t\t\t\tvoid main () {\\n\\\n\t\t\t\t\t\t\tfragColor=color;\\n\\\n\t\t\t\t\t\t\tvec2 norm_pos =normalizeCoords(position);\\n\\\n\t\t\t\t\t\t\tgl_Position = vec4(norm_pos, 0.0, 1.0);\\n\\\n\t\t\t\t\t\t}\\n',\n\n\t\t\t\tattributes: {\n\t\t\t\t\tposition: self.regl.prop(\"position\"),\n\t\t\t\t\tcolor: self.regl.prop(\"color\")\n\n\t\t\t\t},\n\n\t\t\t\tuniforms: {\n\t\t\t\t\tx_scale: self.regl.prop('x_scale'),\n\t\t\t\t\ty_scale: self.regl.prop('y_scale'),\n\t\t\t\t\tstage_width: self.regl.prop('stage_width'),\n\t\t\t\t\tstage_height: self.regl.prop('stage_height'),\n\t\t\t\t\toffset: self.regl.prop(\"offset\")\n\t\t\t\t},\n\t\t\t\tprimitive: self.regl.prop(\"primitive\"),\n\t\t\t\tframebuffer: self.regl.prop(\"buffer\"),\n\t\t\t\tcount: self.regl.prop(\"count\")\n\n\t\t\t});\n\t\t\tthis.object_types[1]['method'] = this.__drawLines;\n\t\t\tthis.object_types[2]['method'] = this.__drawLines;\n\t\t\tthis.__drawSquares = this.regl({\n\t\t\t\tfrag: 'precision highp float;\\n\\\n\t\t\t\t\tvarying vec3 fragColor;\\n\\\n\t\t\t\t\tvarying float r_clip;\\n\\\n\t\t\t\t\tvarying float b_clip;\\n\\\n\t\t\t\t\tuniform int is_buffer; \\n\\\n\t\t\tvoid main(){\\n\\\n\t\t\t\t\t\tif (gl_PointCoord[0]>r_clip || gl_PointCoord[1]>b_clip){\\n\\\n\t\t\t\t\t\t\tdiscard;\\n\\\n\t\t\t\t\t\t}\\n\\\n\t\t\t\t\t\tfloat r_border=b_clip*0.02;\\n\\\n\t\t\t\t\t\tfloat b_border=b_clip*0.02;\\n\\\n\t\t\t\t\t\tif (is_buffer==0  && (gl_PointCoord[0]<r_border || gl_PointCoord[0]>r_clip-r_border || gl_PointCoord[1]<b_border || gl_PointCoord[1]>b_clip-b_border)){\\n\\\n\t\t\t\t\t\t\tgl_FragColor = vec4(0.1,0.1,0.1,1);\\n\\\n\t\t\t\t\t\t}\\n\\\n\t\t\t\t\t\telse{\\n\\\n\t\t\t\t\t\t\tgl_FragColor = vec4(fragColor,1);\\n\\\n\t\t\t\t\t\t}\\n\\\n\t\t\t\t\t}\\n',\n\n\t\t\t\tvert: 'attribute vec2 position;\\n\\\n\t\t\t\t\tattribute float side_length;\\n\\\n\t\t\t\t\tattribute vec3 color;\\n\\\n\t\t\t\t\tattribute float right_clip;\\n\\\n\t\t\t\t\tattribute float bottom_clip;\\n\\\n\t\t\t\t\tvarying float r_clip;\\n\\\n\t\t\t\t\tvarying float b_clip;\\n\\\n\t\t\t\t\tuniform float x_scale;\\n\\\n\t\t\t\t\tuniform float y_scale;\\n\\\n\t\t\t\t\tuniform vec2 offset;\\n\\\n\t\t\t\t\tuniform float stage_height;\\n\\\n\t\t\t\t\tuniform float stage_width;\\n\\\n\t\t\t\t\tvarying vec3 fragColor;\\n\\\n\t\t\tvec2 normalizeCoords(vec2 position){\\n\\\n\t\t\t\t\t\t\tfloat x = (position[0]+offset[0])*x_scale;\\n\\\n\t\t\t\t\t\t\tfloat y = (position[1]+offset[1])*y_scale;\\n\\\n\t\t\t\treturn vec2(2.0 * ((x / stage_width) - 0.5),-(2.0 * ((y / stage_height) - 0.5)));\\n\\\n\t\t\t\t\t}\\n\\\n\t\t\tvoid main() {\\n\\\n\t\t\t\tgl_PointSize = side_length*x_scale;\\n\\\n\t\t\t\t\t\t\tfragColor = color;\\n\\\n\t\t\t\t\t\t\tr_clip=right_clip;\\n\\\n\t\t\t\t\t\t\tb_clip=bottom_clip;\\n\\\n\t\t\t\t\t\t\tvec2 real_position = normalizeCoords(position);\\n\\\n\t\t\t\t\t\t\tgl_Position = vec4(real_position, 0.0, 1.0);\\n\\\n\t\t\t}\\n',\n\n\t\t\t\tattributes: {\n\t\t\t\t\tposition: self.regl.prop('position'),\n\t\t\t\t\tcolor: self.regl.prop('color'),\n\t\t\t\t\tside_length: self.regl.prop('side_length'),\n\t\t\t\t\tright_clip: self.regl.prop(\"right_clip\"),\n\t\t\t\t\tbottom_clip: self.regl.prop(\"bottom_clip\")\n\n\t\t\t\t},\n\n\t\t\t\tuniforms: {\n\t\t\t\t\tx_scale: self.regl.prop('x_scale'),\n\t\t\t\t\ty_scale: self.regl.prop('y_scale'),\n\t\t\t\t\tstage_width: self.regl.prop('stage_width'),\n\t\t\t\t\tstage_height: self.regl.prop('stage_height'),\n\t\t\t\t\toffset: self.regl.prop(\"offset\"),\n\t\t\t\t\tis_buffer: self.regl.prop(\"is_buffer\")\n\t\t\t\t},\n\n\t\t\t\tcount: self.regl.prop('count'),\n\t\t\t\tprimitive: self.regl.prop('primitive'),\n\t\t\t\tframebuffer: self.regl.prop(\"buffer\")\n\t\t\t});\n\t\t\tthis.object_types[3]['method'] = this.__drawSquares;\n\n\t\t\tthis.__drawImages = this.regl({\n\t\t\t\tfrag: \"\\n\\t\\t\\t\\tprecision mediump float;\\n\\t\\t\\t\\tuniform sampler2D text;\\n\\t\\t\\t\\tvarying vec2 uv;\\n\\t\\t\\t\\tvarying vec3 fragColor;\\n\\t\\t\\t\\tvarying float is_buff;\\n\\t\\t\\t\\tvoid main () {\\n\\t\\t\\t\\t\\tif (is_buff==0.0){\\n\\t\\t\\t\\t\\t\\tgl_FragColor = vec4(fragColor,1)*texture2D(text, uv);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tgl_FragColor=vec4(fragColor,1.0);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\",\n\n\t\t\t\tvert: \"\\n\\t\\t\\t\\tprecision mediump float;\\n\\t\\t\\t\\tattribute vec2 position;\\n\\t\\t\\t\\tattribute vec3 color;\\n\\t\\t\\t\\tuniform vec2 x_y;\\n\\t\\t\\t\\tuniform vec2 w_h;\\n\\t\\t\\t\\tuniform float stage_height;\\n\\t\\t\\t\\tuniform float stage_width;\\n\\t\\t\\t\\tuniform vec4 globals;\\n\\t\\t\\t\\tuniform float is_buffer;\\n\\n\\n\\t\\t\\t\\tvarying vec2 uv;\\n\\t\\t\\t\\tvarying vec3 fragColor;\\n\\t\\t\\t\\tvarying float is_buff;\\n\\t\\t\\t\\n\\n\\t\\t\\t\\tvec2 normalizeCoords(vec2 pos){\\n\\t\\t\\t\\t\\tfloat x = (pos[0]+globals[0])*globals[2];\\n\\t\\t\\t\\t\\tfloat y = (pos[1]+globals[1])*globals[3];\\n\\t\\t\\t\\t\\treturn vec2(2.0 * ((x / stage_width) - 0.5),-(2.0 * ((y / stage_height) - 0.5)));\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvoid main () {\\n\\t\\t\\t\\t\\tvec2 new_pos=normalizeCoords(position);\\n\\t\\t\\t\\t\\tis_buff=is_buffer;\\n\\t\\t\\t\\t\\tfragColor = color;\\n\\t\\t\\t\\t\\n\\n\\t\\t\\t\\t\\tif (is_buffer==0.0){\\n\\n\\t\\t\\t\\t\\t\\tfloat x_factor = 1.0/(((w_h[0]*globals[2])/stage_width)*2.0);\\n\\t\\t\\t\\t\\t\\tfloat y_factor = 1.0/(((w_h[1]*globals[3])/stage_height)*2.0);\\n\\t\\t\\t\\t\\t\\n\\n\\t\\t\\t\\t\\t\\tfloat x_offset=(((x_y[0]+globals[0])*globals[2])/stage_width)*2.0*x_factor;\\n\\t\\t\\t\\t\\t\\tfloat y_offset=(((x_y[1]+globals[1])*globals[3])/stage_height)*2.0*y_factor;\\n\\t\\t\\t\\t\\t\\tuv = vec2((new_pos[0]*x_factor)+x_factor-x_offset,-(new_pos[1]*y_factor)+y_factor-y_offset);\\n\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\n\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tgl_Position = vec4(new_pos, 0, 1);\\n\\n\\t\\t\\t\\t}\",\n\n\t\t\t\tattributes: {\n\t\t\t\t\tposition: self.regl.prop(\"position\"),\n\t\t\t\t\tcolor: self.regl.prop(\"color\")\n\t\t\t\t},\n\n\t\t\t\tuniforms: {\n\t\t\t\t\tstage_height: self.regl.context(\"viewportHeight\"),\n\t\t\t\t\tstage_width: self.regl.context(\"viewportWidth\"),\n\t\t\t\t\tw_h: self.regl.prop(\"w_h\"),\n\t\t\t\t\tx_y: self.regl.prop(\"x_y\"),\n\t\t\t\t\ttext: self.regl.prop(\"text\"),\n\t\t\t\t\tglobals: self.regl.prop(\"globals\"),\n\t\t\t\t\tis_buffer: self.regl.prop(\"is_buffer\")\n\n\t\t\t\t},\n\n\t\t\t\tcount: self.regl.prop(\"count\"),\n\t\t\t\tframebuffer: self.regl.prop(\"buffer\")\n\t\t\t});\n\n\t\t\tthis.object_types[4]['method'] = this.__drawImages;\n\t\t}\n\t}]);\n\n\treturn WGL2DI;\n}();\n\nexports.WGL2DI = WGL2DI;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvd2ViZ2wvd2dsMmRpLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3NyYy93ZWJnbC93Z2wyZGkuanM/ZTNmYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3JlZ2x9IGZyb20gXCIuL3JlZ2wuanNcIjtcblxuXG5jbGFzcyBXR0wyREl7XG5cdGNvbnN0cnVjdG9yKGRpdl9pZCx3aWR0aCxoZWlnaHQpe1xuICAgIFx0dGhpcy5yZWdsPW51bGw7XG5cdFx0dGhpcy5waWNrX2J1ZmZlcj1udWxsO1xuXHRcdHRoaXMub2JqZWN0cz1bXTtcblx0XHR0aGlzLmtleXM9e307XG5cdFx0dGhpcy5vYmplY3RfdHlwZXM9W107XG5cdFx0dGhpcy5vYmplY3RzX2luX3ZpZXc9MDtcblx0XHQvL2h0bWwgZWxlbWVudHNcblx0XHR0aGlzLmRpdl9jb250YWluZXI9JChcIiNcIitkaXZfaWQpO1xuXHRcdHRoaXMuY2FudmFzPW51bGw7XG5cdFx0dGhpcy5sYWJlbF9jb250ZXh0O1xuXHRcdHRoaXMubGFiZWxfY29udGV4dD1udWxsO1xuXHRcdHRoaXMuaGVpZ2h0PTA7XG5cdFx0dGhpcy53aWR0aD0wO1xuXHRcdHRoaXMuX3NldFVwRG9jdW1lbnQod2lkdGgsaGVpZ2h0KTtcblx0XHR0aGlzLmltYWdlc190b19sb2FkPTA7XG5cdFx0dGhpcy5pc19maWx0ZXJlZD17fTtcblx0XHR0aGlzLmlzX2hpZGRlbj17fTtcblxuICAgIFxuICAgIFxuXHRcdC8vaGFuZGxlcnNcblx0XHR0aGlzLmhhbmRsZXJzPXtcblx0XHRcdG9iamVjdF9jbGlja2VkOnt9LFxuXHRcdFx0b2JqZWN0X292ZXI6e30sXG5cdFx0XHRvYmplY3Rfb3V0Ont9LFxuXHRcdFx0YnJ1c2hfc3RvcHBlZDp7fVxuXHRcdH07XG5cblx0XHQvL3N3aXRjaGVzXG5cdFx0dGhpcy5kcmF3X2xhYmVscz1mYWxzZTtcblxuXG5cblxuXHRcdC8vY2lyY2xlIHNoYXBlc1xuXHRcdHRoaXMuY2lyY2xlX3Byb3BlcnRpZXM9e1wicG9zaXRpb25cIjoxLFwiY29sb3JcIjoxLFwicGlja19jb2xvclwiOjEsXCJyYWRpdXNcIjoxLFwic3RhcnRfYW5nbGVcIjoxLFwiZW5kX2FuZ2xlXCI6MSxcIm9wYWNpdHlcIjoxfTtcblx0XHR0aGlzLmNpcmNsZXNfdG9fZHJhdz17fTtcblx0XHR0aGlzLmNpcmNsZXM9e307XG5cdFx0Zm9yICh2YXIgcHJvcCBpbiB0aGlzLmNpcmNsZV9wcm9wZXJ0aWVzKXtcblx0XHRcdHRoaXMuY2lyY2xlc190b19kcmF3W3Byb3BdPVtdO1xuXHRcdFx0dGhpcy5jaXJjbGVzW3Byb3BdPVtdO1xuXHRcdH1cblx0XHR0aGlzLmNpcmNsZXMuY291bnQ9MDtcblx0XHR0aGlzLm9iamVjdF90eXBlcy5wdXNoKHtkYXRhOnRoaXMuY2lyY2xlcyxcblx0XHRcdFx0XHRcdFx0XHRkYXRhX2luX3ZpZXc6dGhpcy5jaXJjbGVzX3RvX2RyYXcsXG5cdFx0XHRcdFx0XHRcdFx0cHJvcGVydGllczp0aGlzLmNpcmNsZV9wcm9wZXJ0aWVzLFxuXHRcdFx0XHRcdFx0XHRcdHZlcnRpY2VzOjEsXG5cdFx0XHRcdFx0XHRcdHByaW1pdGl2ZTpcInBvaW50c1wifSk7XG5cblxuXHRcdC8vbGluZSBzaGFwZXNcblx0XHR0aGlzLmxpbmVfcHJvcGVydGllcz17J3Bvc2l0aW9uJzoyLFwiY29sb3JcIjoyLFwicGlja19jb2xvclwiOjJ9O1xuXHRcdHRoaXMubGluZXNfdG9fZHJhdz17fTtcblx0XHR0aGlzLmxpbmVzPXt9O1xuXHRcdGZvciAodmFyIHByb3AgaW4gdGhpcy5saW5lX3Byb3BlcnRpZXMpe1xuXHRcdFx0dmFyIGxpc3Q9W107XG5cdFx0XHR0aGlzLmxpbmVzW3Byb3BdPWxpc3Q7ICAgXG5cdFx0XHR0aGlzLmxpbmVzX3RvX2RyYXdbcHJvcF09bGlzdDtcblx0XHR9XG5cdFx0dGhpcy5saW5lcy5jb3VudD0wO1xuXHRcdHRoaXMub2JqZWN0X3R5cGVzLnB1c2goe2RhdGE6dGhpcy5saW5lcyxcblx0XHRcdFx0XHRcdFx0XHRkYXRhX2luX3ZpZXc6dGhpcy5saW5lc190b19kcmF3LFxuXHRcdFx0XHRcdFx0XHRcdHByb3BlcnRpZXM6dGhpcy5saW5lX3Byb3BlcnRpZXMsXG5cdFx0XHRcdFx0XHRcdFx0dmVydGljZXM6Mixcblx0XHRcdFx0XHRcdFx0XHRwcmltaXRpdmU6XCJsaW5lc1wifSk7XG5cblx0XHQvL3JlY3RhbmdsZXNcblx0XHR0aGlzLnJlY3RfcHJvcGVydGllcz17J3Bvc2l0aW9uJzoyLFwiY29sb3JcIjoyLFwicGlja19jb2xvclwiOjJ9O1xuXHRcdHRoaXMucmVjdHNfdG9fZHJhdz17fTtcblx0XHR0aGlzLnJlY3RzPXt9O1xuXHRcdGZvciAodmFyIHByb3AgaW4gdGhpcy5yZWN0X3Byb3BlcnRpZXMpeyAgICAgXG5cdFx0XHR0aGlzLnJlY3RzW3Byb3BdPVtdOyAgIFxuXHRcdFx0dGhpcy5yZWN0c190b19kcmF3W3Byb3BdPVtdO1xuXHRcdH1cblx0XHR0aGlzLnJlY3RzLmNvdW50PTA7XG5cblx0XHR0aGlzLm9iamVjdF90eXBlcy5wdXNoKHtkYXRhOnRoaXMucmVjdHMsXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YV9pbl92aWV3OnRoaXMucmVjdHNfdG9fZHJhdyxcblx0XHRcdFx0XHRcdFx0XHRwcm9wZXJ0aWVzOnRoaXMucmVjdF9wcm9wZXJ0aWVzLFxuXHRcdFx0XHRcdFx0XHRcdHZlcnRpY2VzOjYsXG5cdFx0XHRcdFx0XHRcdFx0cHJpbWl0aXZlOlwidHJpYW5nbGVzXCJ9KTtcblxuXG5cdFx0Ly9zcXVhcmVzXG5cdFx0dGhpcy5zcXVhcmVfcHJvcGVydGllcz17J3Bvc2l0aW9uJzoyLFwiY29sb3JcIjoyLFwicGlja19jb2xvclwiOjIsc2lkZV9sZW5ndGg6MixcInJpZ2h0X2NsaXBcIjoxLFwiYm90dG9tX2NsaXBcIjoxfTtcblx0XHR0aGlzLnNxdWFyZXNfdG9fZHJhdz17fTtcblx0XHR0aGlzLnNxdWFyZXM9e307XG5cdFx0Zm9yICh2YXIgcHJvcCBpbiB0aGlzLnNxdWFyZV9wcm9wZXJ0aWVzKXsgICAgIFxuXHRcdFx0dGhpcy5zcXVhcmVzW3Byb3BdPVtdOyAgIFxuXHRcdFx0dGhpcy5zcXVhcmVzX3RvX2RyYXdbcHJvcF09W107XG5cdFx0fVxuXHRcdHRoaXMuc3F1YXJlcy5jb3VudD0wO1xuXHRcdHRoaXMub2JqZWN0X3R5cGVzLnB1c2goe2RhdGE6dGhpcy5zcXVhcmVzLFxuXHRcdFx0XHRcdFx0XHRcdGRhdGFfaW5fdmlldzp0aGlzLnNxdWFyZXNfdG9fZHJhdyxcblx0XHRcdFx0XHRcdFx0XHRwcm9wZXJ0aWVzOnRoaXMuc3F1YXJlX3Byb3BlcnRpZXMsXG5cdFx0XHRcdFx0XHRcdFx0dmVydGljZXM6MSxcblx0XHRcdFx0XHRcdFx0XHRwcmltaXRpdmU6XCJwb2ludHNcIn0pO1xuXG5cblx0XHR0aGlzLnNjYWxlPTEuMDtcblx0XHR0aGlzLnhfc2NhbGU9MS4wO1xuXHRcdHRoaXMueV9zY2FsZT0xLjA7XG5cdFx0dGhpcy5vZmZzZXQ9WzAsMF07XG5cblxuXHRcdC8vaW1hZ2VzXG5cdFx0dGhpcy5pbWFnZV9wcm9wZXJ0aWVzPXsncG9zaXRpb24nOjIsXCJwaWNrX2NvbG9yXCI6MixcImNvbG9yXCI6Mn07XG5cdFx0dGhpcy5pbWFnZXNfdG9fZHJhdz17fTtcblx0XHR0aGlzLmltYWdlcz17fTtcblx0XHRmb3IgKHZhciBwcm9wIGluIHRoaXMuaW1hZ2VfcHJvcGVydGllcyl7ICAgICBcblx0XHRcdHRoaXMuaW1hZ2VzW3Byb3BdPVtdOyAgIFxuXHRcdFx0dGhpcy5pbWFnZXNfdG9fZHJhd1twcm9wXT1bXTtcblx0XHR9XG5cdFx0XG5cdFx0dGhpcy5pbWFnZXMuY291bnQ9MDtcblx0XHR0aGlzLmltYWdlcy5wcm9wcz1bXTtcblx0XHR0aGlzLmltYWdlcy5nbG9iYWxzPVt0aGlzLm9mZnNldFswXSx0aGlzLm9mZnNldFsxXSx0aGlzLnhfc2NhbGUsdGhpcy55X3NjYWxlXTtcblx0XHR0aGlzLm9iamVjdF90eXBlcy5wdXNoKHtkYXRhOnRoaXMuaW1hZ2VzLFxuXHRcdFx0XHRcdFx0XHRcdGRhdGFfaW5fdmlldzp0aGlzLmltYWdlc190b19kcmF3LFxuXHRcdFx0XHRcdFx0XHRcdHByb3BlcnRpZXM6dGhpcy5pbWFnZV9wcm9wZXJ0aWVzLFxuXHRcdFx0XHRcdFx0XHRcdHZlcnRpY2VzOjYsXG5cdFx0XHRcdFx0XHRcdFx0cHJpbWl0aXZlOlwidHJpYW5nbGVzXCJ9KTtcblx0ICAgIHRoaXMuaW1hZ2VzLmRpc3BsYXlfYXNfaW1hZ2U9dHJ1ZTtcblxuXG5cblxuXHRcdC8vVGhlIGxhc3QgbW9vc2UgcG9zaXRpb24gcmVjb3JkZWRcblx0XHR0aGlzLm1vdXNlX3Bvc2l0aW9uPW51bGw7XG5cdFx0Ly9XYXMgYW4gb2JqZWN0IGNsaWNrZWRcblx0XHR0aGlzLm9iamVjdF9jbGlja2VkPW51bGw7XG5cdFx0Ly9hbiBvYmplY3Qgd2FzIGNsaWNrZWRcblx0XHR0aGlzLmRyYWdnaW5nPWZhbHNlO1xuXHRcdC8vb2JqZWN0IHdoaWNoIG1vdXNlIGlzIG92ZXJcblx0XHR0aGlzLm9iamVjdF9tb3VzZV9vdmVyPW51bGw7XG5cdFx0dGhpcy5tb3VzZV9vdmVyX2NvbG9yPW51bGw7Ly9bMjU1LDAsMF07XG5cblx0XHR0aGlzLnpvb21fYW1vdW50PTA7XG5cblxuXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdFx0cmVnbCh7XG5cdFx0XHRvbkRvbmU6IGZ1bmN0aW9uKGVycixyZWdsKXtcblx0XHRcdFx0c2VsZi5yZWdsPXJlZ2w7XG5cdFx0XHRcdHNlbGYucGlja2J1ZmZlciA9IHJlZ2wuZnJhbWVidWZmZXIoeyBjb2xvckZvcm1hdDogJ3JnYmEnLGhlaWdodDpzZWxmLmhlaWdodCx3aWR0aDpzZWxmLndpZHRofSk7XG5cdFx0XHRcdHNlbGYuX2luaXREcmF3TWV0aG9kcygpO1xuXHRcdFx0XHRzZWxmLl9hZGRIYW5kbGVycygpO1xuXHRcdFx0fSxcblx0XHRcdGNhbnZhczpzZWxmLmNhbnZhc1swXSxcblx0XHRcdFxuXG5cdFx0fSk7XG5cblx0fVxuXG5cdHJlbW92ZSgpe31cblxuXG5cdF9zZXRVcERvY3VtZW50KHdpZHRoLGhlaWdodCl7XG5cdFx0aWYgKCFoZWlnaHQpe1xuXHRcdFx0aGVpZ2h0PXRoaXMuZGl2X2NvbnRhaW5lci5oZWlnaHQoKTtcblx0XHRcdHdpZHRoPXRoaXMuZGl2X2NvbnRhaW5lci53aWR0aCgpO1xuXG5cdFx0fWVsc2V7XG5cblx0XHRcdHRoaXMuaGVpZ2h0PWhlaWdodDtcblx0XHRcdHRoaXMud2lkdGg9d2lkdGg7XG5cdFx0XHR0aGlzLmRpdl9jb250YWluZXIuaGVpZ2h0KGhlaWdodCk7XG5cdFx0XHR0aGlzLmRpdl9jb250YWluZXIud2lkdGgod2lkdGgpO1xuXHRcdH1cblx0XHR0aGlzLmNhbnZhcyA9JChcIjxjYW52YXM+XCIpXG5cdFx0LmF0dHIoe1xuXHRcdFx0aGVpZ2h0OmhlaWdodCxcblx0XHRcdHdpZHRoOndpZHRoICAgXG5cdFx0fSlcblx0XHQuY3NzKHtcblx0XHRcdHBvc2l0aW9uOlwiYWJzb2x1dGVcIixcblx0XHRcdGxlZnQ6XCIwcHhcIixcblx0XHRcdHJpZ2h0OlwiMHB4XCJcblx0XHR9KTtcblx0XHR0aGlzLmxhYmVsX2NhbnZhcz0kKFwiPGNhbnZhcz5cIilcblx0ICAgLmF0dHIoe1xuXHRcdFx0aGVpZ2h0OmhlaWdodCxcblx0XHRcdHdpZHRoOndpZHRoICAgXG5cdFx0fSlcblx0XHQuY3NzKHtcblx0XHRcdHBvc2l0aW9uOlwiYWJzb2x1dGVcIixcblx0XHRcdGxlZnQ6XCIwcHhcIixcblx0XHRcdHJpZ2h0OlwiMHB4XCJcblx0XHR9KTtcblx0XHR0aGlzLmxhYmVsX2NvbnRleHQ9dGhpcy5sYWJlbF9jYW52YXNbMF0uZ2V0Q29udGV4dChcIjJkXCIpO1xuXHRcdHRoaXMuZGl2X2NvbnRhaW5lci5hcHBlbmQodGhpcy5jYW52YXMpLmFwcGVuZCh0aGlzLmxhYmVsX2NhbnZhcyk7XG5cdH1cblxuXHRzZXRTaXplKHdpZHRoLGhlaWdodCl7XG5cdFx0bGV0IHNlbGY9dGhpcztcblx0XHR3aWR0aD1NYXRoLnJvdW5kKHdpZHRoKTtcblx0XHRoZWlnaHQ9TWF0aC5yb3VuZChoZWlnaHQpO1xuXHRcdHRoaXMuaGVpZ2h0PWhlaWdodDtcblx0XHR0aGlzLndpZHRoPXdpZHRoO1xuXHRcdHRoaXMuZGl2X2NvbnRhaW5lci5oZWlnaHQoaGVpZ2h0KS53aWR0aCh3aWR0aCk7XG5cdFx0dGhpcy5jYW52YXMuYXR0cih7aGVpZ2h0OmhlaWdodCx3aWR0aDp3aWR0aH0pO1xuXHRcdHRoaXMubGFiZWxfY2FudmFzLmF0dHIoe2hlaWdodDpoZWlnaHQsd2lkdGg6d2lkdGh9KTtcblx0XHR0aGlzLnBpY2tidWZmZXIuZGVzdHJveSgpXG5cdFx0dGhpcy5waWNrYnVmZmVyID0gdGhpcy5yZWdsLmZyYW1lYnVmZmVyKHsgY29sb3JGb3JtYXQ6ICdyZ2JhJyxoZWlnaHQ6aGVpZ2h0LHdpZHRoOndpZHRofSk7XG5cdFx0Ly90aGlzIGlzIG5lY2Vzc2FyeSwgYnV0IEkgIGRvbid0IGtub3cgd2h5P1xuXHRcdGxldCBsb29wID10aGlzLnJlZ2wuZnJhbWUoZnVuY3Rpb24oKXtcblx0XHRcdFxuXHRcdH0pO1xuXHRcdHNldFRpbWVvdXQoKCk9Pntcblx0XHRcdHNlbGYucmVmcmVzaCgpO1xuXHRcdFx0bG9vcC5jYW5jZWwoKTtcblxuXHRcdFx0fSwxMDApO1xuXHRcdFxuXG5cblx0fVxuXG5cdF9nZXRNb3VzZVBvc2l0aW9uKGUpe1xuICAgIFx0dmFyIHJlY3QgPSB0aGlzLmNhbnZhc1swXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBcdHJldHVybiBbZS5vcmlnaW5hbEV2ZW50LmNsaWVudFgtcmVjdC5sZWZ0LGUub3JpZ2luYWxFdmVudC5jbGllbnRZLXJlY3QudG9wXTtcblx0fVxuXG5cdF9nZXRBY3R1YWxQb3NpdGlvbihwb3NpdGlvbil7XG4gICAgXHR2YXIgeCA9IChwb3NpdGlvblswXS90aGlzLnhfc2NhbGUpIC0gdGhpcy5vZmZzZXRbMF07XG4gICAgXHR2YXIgeSA9IChwb3NpdGlvblsxXS90aGlzLnlfc2NhbGUpIC0gdGhpcy5vZmZzZXRbMV07XG4gICAgXHRyZXR1cm4gW3gseV07XG5cdH1cblxuXHRfZHJhd0xhYmVscygpe1xuICAgIFx0dmFyIHRpbWUgPURhdGUubm93KCk7XG4gICAgXHRpZiAodGhpcy5vYmplY3RzX2luX3ZpZXc+NTAwMCl7XG4gICAgICAgIFx0cmV0dXJuO1xuICAgIFx0fVxuICAgIFx0dGhpcy5sYWJlbF9jb250ZXh0LmZvbnQgPSBcIjE0cHggQXJpYWxcIjtcbiAgIFxuICAgIFx0Zm9yKHZhciBpIGluIHRoaXMub2JqZWN0X3R5cGVzKXtcbiAgICAgICAgXHR2YXIgcG9zID10aGlzLm9iamVjdF90eXBlc1tpXS5kYXRhX2luX3ZpZXcucG9zaXRpb247XG4gICAgICAgIFxuICAgICAgICBcdGZvciAodmFyIGlpPTA7aWk8cG9zLmxlbmd0aDtpaSsrKXtcbiAgICAgICBcbiAgICAgICAgICBcdFx0dmFyIHg9KHBvc1tpaV1bMF0rdGhpcy5vZmZzZXRbMF0pKnRoaXMueF9zY2FsZTtcbiAgICAgICAgICBcdFx0dmFyIHk9KHBvc1tpaV1bMV0rdGhpcy5vZmZzZXRbMV0pKnRoaXMueV9zY2FsZTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICBcdHRoaXMubGFiZWxfY29udGV4dC5maWxsVGV4dChcIkgxXCIseCx5KTtcbiAgICAgICAgICAgXG4gICAgICAgIFx0fVxuICAgIFx0fSAgICBcblx0fVxuXG5cdHNldE9iamVjdENvbG9yKGtleSxjb2xvcil7XG5cdFx0dmFyIG9iaiA9IHRoaXMub2JqZWN0c1t0aGlzLmtleXNba2V5XV07XG5cdFx0dmFyIG9ial90eXBlPSB0aGlzLm9iamVjdF90eXBlc1tvYmpbMV1dO1xuXHRcdGZvciAodmFyIHg9b2JqWzBdO3g8b2JqWzBdK29ial90eXBlLnZlcnRpY2VzO3grKyl7XG5cdFx0XHRvYmpfdHlwZS5kYXRhLmNvbG9yW3hdWzBdPWNvbG9yWzBdLzI1NTtcblx0XHRcdG9ial90eXBlLmRhdGEuY29sb3JbeF1bMV09Y29sb3JbMV0vMjU1O1xuXHRcdFx0b2JqX3R5cGUuZGF0YS5jb2xvclt4XVsyXT1jb2xvclsyXS8yNTU7XG5cdFx0fVxuXHR9XG5cblxuXHRnZXRPYmplY3RDb2xvcihrZXkpe1xuXHRcdHZhciBvYmogPSB0aGlzLm9iamVjdHNbdGhpcy5rZXlzW2tleV1dO1xuXHRcdHZhciBvYmpfdHlwZT0gdGhpcy5vYmplY3RfdHlwZXNbb2JqWzFdXTtcblx0XHR2YXIgY29sPSBvYmpfdHlwZS5kYXRhLmNvbG9yW29ialswXV07XG5cdFx0cmV0dXJuIFtjb2xbMF0qMjU1LGNvbFsxXSoyNTUsY29sWzJdKjI1NV07XG5cblx0fVxuXG5cblxuXG5cdGFkZExpbmUocG9zaXRpb25Ubyxwb3NpdGlvbkZyb20sY29sb3Isa2V5KXtcbiAgICBcdHZhciBpbmRleCA9IHRoaXMub2JqZWN0cy5sZW5ndGg7XG4gICAgXG4gICAgIFx0aWYgKGtleSAmJiAhIHRoaXMua2V5c1trZXldKXtcbiAgICAgICAgXHR0aGlzLmtleXNba2V5XT1pbmRleDtcbiAgICBcdH1cbiAgICBcdGVsc2V7XG4gICAgICAgIFx0a2V5PWluZGV4O1xuICAgICAgICBcdHRoaXMua2V5c1tpbmRleF09aW5kZXg7XG4gICAgXHR9XG5cdFx0dmFyIGxpbmVfaW5kZXg9dGhpcy5saW5lcy5wb3NpdGlvbi5sZW5ndGg7XG5cdFx0dGhpcy5saW5lcy5wb3NpdGlvbi5wdXNoKHBvc2l0aW9uRnJvbSk7XG5cdFx0dGhpcy5saW5lcy5wb3NpdGlvbi5wdXNoKHBvc2l0aW9uVG8pO1xuXHRcdHRoaXMubGluZXMuY29sb3IucHVzaChbY29sb3JbMF0vMjU1LGNvbG9yWzFdLzI1NSxjb2xvclsyXS8yNTVdKTtcblx0XHR0aGlzLmxpbmVzLmNvbG9yLnB1c2goW2NvbG9yWzBdLzI1NSxjb2xvclsxXS8yNTUsY29sb3JbMl0vMjU1XSk7XG5cdFx0dGhpcy5saW5lcy5waWNrX2NvbG9yLnB1c2godGhpcy5fZ2V0UkdCRnJvbUluZGV4KGluZGV4KzEpKTtcblx0XHR0aGlzLmxpbmVzLnBpY2tfY29sb3IucHVzaCh0aGlzLl9nZXRSR0JGcm9tSW5kZXgoaW5kZXgrMSkpO1xuXHRcdHRoaXMub2JqZWN0cy5wdXNoKFtsaW5lX2luZGV4LDEsa2V5XSk7XG5cdFx0dGhpcy5saW5lcy5jb3VudCsrO1xuXHR9XG5cblx0YWRkVGhpY2tMaW5lKHBvc2l0aW9uVG8scG9zaXRpb25Gcm9tLHdpZHRoLGNvbG9yLGtleSl7XG5cdFx0dmFyIGluZGV4ID0gdGhpcy5vYmplY3RzLmxlbmd0aDtcblx0XHRpZiAoa2V5ICYmICEgdGhpcy5rZXlzW2tleV0pe1xuXHRcdFx0dGhpcy5rZXlzW2tleV09aW5kZXg7XG5cdFx0fVxuXHRcdGVsc2V7XG5cdFx0XHRrZXk9aW5kZXg7XG5cdFx0XHR0aGlzLmtleXNbaW5kZXhdPWluZGV4O1xuXHRcdH1cblx0XHR2YXIgcmVjdF9pbmRleD10aGlzLnJlY3RzLnBvc2l0aW9uLmxlbmd0aDtcblx0XHR2YXIgeF9kaWZmPSBwb3NpdGlvblRvWzBdLXBvc2l0aW9uRnJvbVswXTtcblx0XHR2YXIgeV9kaWZmID0gcG9zaXRpb25Ub1sxXS1wb3NpdGlvbkZyb21bMV07XG5cdFx0dmFyIGZhY3RvciA9ICgwLjUqd2lkdGgpL01hdGguc3FydCgoeF9kaWZmKnhfZGlmZikrKHlfZGlmZip5X2RpZmYpKTtcblx0XHR2YXIgeF9vZmZzZXQ9IGZhY3Rvcip5X2RpZmY7XG5cdFx0dmFyIHlfb2Zmc2V0PSBmYWN0b3IqeF9kaWZmO1xuXHRcdHRoaXMucmVjdHMucG9zaXRpb24ucHVzaChbcG9zaXRpb25Ub1swXSt4X29mZnNldCxwb3NpdGlvblRvWzFdLXlfb2Zmc2V0XSk7IC8vVExcblx0XHR0aGlzLnJlY3RzLnBvc2l0aW9uLnB1c2goW3Bvc2l0aW9uRnJvbVswXSt4X29mZnNldCxwb3NpdGlvbkZyb21bMV0teV9vZmZzZXRdKTsgLy9CTFxuXHRcdHRoaXMucmVjdHMucG9zaXRpb24ucHVzaChbcG9zaXRpb25Gcm9tWzBdLXhfb2Zmc2V0LHBvc2l0aW9uRnJvbVsxXSt5X29mZnNldF0pOyAvL0JSXG5cblx0XHR0aGlzLnJlY3RzLnBvc2l0aW9uLnB1c2goW3Bvc2l0aW9uRnJvbVswXS14X29mZnNldCxwb3NpdGlvbkZyb21bMV0reV9vZmZzZXRdKTsgLy9CUlxuXHRcdHRoaXMucmVjdHMucG9zaXRpb24ucHVzaChbcG9zaXRpb25Ub1swXS14X29mZnNldCxwb3NpdGlvblRvWzFdK3lfb2Zmc2V0XSk7IC8vVFJcblx0XHR0aGlzLnJlY3RzLnBvc2l0aW9uLnB1c2goW3Bvc2l0aW9uVG9bMF0reF9vZmZzZXQscG9zaXRpb25Ub1sxXS15X29mZnNldF0pOyAvL1RMXG5cblxuXHRcdHZhciBjICA9IFtjb2xvclswXS8yNTUsY29sb3JbMV0vMjU1LGNvbG9yWzJdLzI1NV07XG5cdFx0dmFyIHBjID0gdGhpcy5fZ2V0UkdCRnJvbUluZGV4KGluZGV4KzEpO1xuXHRcdGZvciAodmFyIGE9MDthPDY7YSsrKXtcblx0XHRcdCB0aGlzLnJlY3RzLmNvbG9yLnB1c2goYyk7XG5cdFx0XHQgdGhpcy5yZWN0cy5waWNrX2NvbG9yLnB1c2gocGMpO1xuXHRcdH1cblx0XHR0aGlzLm9iamVjdHMucHVzaChbcmVjdF9pbmRleCwyLGtleV0pO1xuXHRcdHRoaXMuaWFtZ2VzLmNvdW50Kys7XG5cdFx0cmV0dXJuIGtleTtcblx0fVxuXG5cblx0YWRkSW1hZ2UocG9zaXRpb24saGVpZ2h0LHdpZHRoLGltYWdlLGtleSl7XG5cdFx0bGV0IHNlbGYgPXRoaXM7XG5cdFx0dmFyIGluZGV4ID0gdGhpcy5vYmplY3RzLmxlbmd0aDtcblx0XHRpZiAoa2V5ICYmICEgdGhpcy5rZXlzW2tleV0pe1xuXHRcdFx0dGhpcy5rZXlzW2tleV09aW5kZXg7XG5cdFx0fVxuXHRcdGVsc2V7XG5cdFx0XHRrZXk9aW5kZXg7XG5cdFx0XHR0aGlzLmtleXNbaW5kZXhdPWluZGV4O1xuXHRcdH1cblx0XHRsZXQgeCA9IHBvc2l0aW9uWzBdO1xuXHRcdGxldCB5ID0gcG9zaXRpb25bMV07XG5cdFx0dmFyIGltYWdlX2luZGV4PXRoaXMuaW1hZ2VzLnBvc2l0aW9uLmxlbmd0aDtcblx0XHR0aGlzLmltYWdlcy5wb3NpdGlvbi5wdXNoKFt4LHldKTtcblx0XHR0aGlzLmltYWdlcy5wb3NpdGlvbi5wdXNoKFt4LHkraGVpZ2h0XSk7XG5cdFx0dGhpcy5pbWFnZXMucG9zaXRpb24ucHVzaChbeCt3aWR0aCx5K2hlaWdodF0pLFxuXHRcdHRoaXMuaW1hZ2VzLnBvc2l0aW9uLnB1c2goW3grd2lkdGgseStoZWlnaHRdKTtcblx0XHR0aGlzLmltYWdlcy5wb3NpdGlvbi5wdXNoKFt4K3dpZHRoLHldKTtcblx0XHR0aGlzLmltYWdlcy5wb3NpdGlvbi5wdXNoKFt4LHldKTtcblx0XHR0aGlzLmltYWdlX3Bvc2l0aW9uPVtbLTEsMV0sWy0xLDBdLFswLDBdLFswLDBdLFswLDFdLFstMS4wXV07XG5cdFx0dmFyIHBjID0gdGhpcy5fZ2V0UkdCRnJvbUluZGV4KGluZGV4KzEpO1xuXHRcdGZvciAodmFyIGE9MDthPDY7YSsrKXtcblx0XHRcdCB0aGlzLmltYWdlcy5waWNrX2NvbG9yLnB1c2gocGMpO1xuXHRcdFx0IHRoaXMuaW1hZ2VzLmNvbG9yLnB1c2goWzAuMSwwLjcsMC4xXSk7XG5cdFx0fVxuXHRcdGxldCBpX2luZGV4PXRoaXMuaW1hZ2VzLnByb3BzLmxlbmd0aDtcblx0XHR0aGlzLmltYWdlcy5wcm9wcy5wdXNoKHtjb3VudDo2LGlzX2J1ZmZlcjowLHhfeTpbeCx5XSx3X2g6W3dpZHRoLGhlaWdodF0sXG5cdFx0dGV4dDp0aGlzLmxvYWRpbmdfaW1hZ2UscG9zaXRpb246dGhpcy5pbWFnZXMucG9zaXRpb24uc2xpY2UoaW1hZ2VfaW5kZXgsaW1hZ2VfaW5kZXgrNiksZ2xvYmFsczp0aGlzLmltYWdlcy5nbG9iYWxzLGNvbG9yOnRoaXMuaW1hZ2VzLmNvbG9yLnNsaWNlKGltYWdlX2luZGV4LGltYWdlX2luZGV4KzYpfSk7XG5cdFx0dmFyIGltID0gbmV3IEltYWdlKClcbiAgICAgICAgaW0uc3JjID0gaW1hZ2U7XG4gICAgICAgIHRoaXMuaW1hZ2VzX3RvX2xvYWQrKztcbiAgICAgICAgaW0ub25sb2FkPWZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgIHNlbGYuaW1hZ2VzLnByb3BzW2lfaW5kZXhdLnRleHQ9c2VsZi5yZWdsLnRleHR1cmUoe2RhdGE6aW0sbWluOlwibGluZWFyXCJ9KTtcbiAgICAgICAgICAgICAgc2VsZi5pbWFnZXNfdG9fbG9hZC0tO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW1hZ2VzLmNvdW50Kys7XG5cblxuXHRcdHRoaXMub2JqZWN0cy5wdXNoKFtpbWFnZV9pbmRleCw0LGtleV0pO1xuXG5cblx0fVxuXG5cdGFkZFJlY3RhbmdsZShwb3NpdGlvbixoZWlnaHQsd2lkdGgsY29sb3Isa2V5KXtcblx0XHR2YXIgaW5kZXggPSB0aGlzLm9iamVjdHMubGVuZ3RoO1xuXHRcdGlmIChrZXkgJiYgISB0aGlzLmtleXNba2V5XSl7XG5cdFx0XHR0aGlzLmtleXNba2V5XT1pbmRleDtcblx0XHR9XG5cdFx0ZWxzZXtcblx0XHRcdGtleT1pbmRleDtcblx0XHRcdHRoaXMua2V5c1tpbmRleF09aW5kZXg7XG5cdFx0fVxuXHRcdHZhciByZWN0X2luZGV4PXRoaXMucmVjdHMucG9zaXRpb24ubGVuZ3RoO1xuXHRcdHRoaXMucmVjdHMucG9zaXRpb24ucHVzaChwb3NpdGlvbik7XG5cdFx0dGhpcy5yZWN0cy5wb3NpdGlvbi5wdXNoKFtwb3NpdGlvblswXSxwb3NpdGlvblsxXStoZWlnaHRdKTtcblx0XHR0aGlzLnJlY3RzLnBvc2l0aW9uLnB1c2goW3Bvc2l0aW9uWzBdK3dpZHRoLHBvc2l0aW9uWzFdK2hlaWdodF0pO1xuXG5cdFx0dGhpcy5yZWN0cy5wb3NpdGlvbi5wdXNoKFtwb3NpdGlvblswXSt3aWR0aCxwb3NpdGlvblsxXStoZWlnaHRdKTtcblx0XHR0aGlzLnJlY3RzLnBvc2l0aW9uLnB1c2goW3Bvc2l0aW9uWzBdK3dpZHRoLHBvc2l0aW9uWzFdXSk7XG5cdFx0dGhpcy5yZWN0cy5wb3NpdGlvbi5wdXNoKFtwb3NpdGlvblswXSxwb3NpdGlvblsxXV0pO1xuXG5cblx0XHR2YXIgYyAgPSBbY29sb3JbMF0vMjU1LGNvbG9yWzFdLzI1NSxjb2xvclsyXS8yNTVdO1xuXHRcdHZhciBwYyA9IHRoaXMuX2dldFJHQkZyb21JbmRleChpbmRleCsxKTtcblx0XHRmb3IgKHZhciBhPTA7YTw2O2ErKyl7XG5cdFx0XHQgdGhpcy5yZWN0cy5jb2xvci5wdXNoKGMpO1xuXHRcdFx0IHRoaXMucmVjdHMucGlja19jb2xvci5wdXNoKHBjKTtcblx0XHR9XG5cdFx0dGhpcy5vYmplY3RzLnB1c2goW3JlY3RfaW5kZXgsMixrZXldKTtcblx0XHR0aGlzLnJlY3RzLmNvdW50Kys7XG5cdFx0cmV0dXJuIGtleTtcblx0fVx0XG5cblx0YWRkQXJjKHBvc2l0aW9uLHJhZGl1cyxjb2xvcixzdGFydF9hbmdsZSxlbmRfYW5nbGUsa2V5KXtcblx0XHR2YXIgaW5kZXggPSB0aGlzLm9iamVjdHMubGVuZ3RoO1xuXHRcdCBpZiAoa2V5ICYmICEgdGhpcy5rZXlzW2tleV0pe1xuXHRcdFx0dGhpcy5rZXlzW2tleV09aW5kZXg7XG5cdFx0fVxuXHRcdGVsc2V7XG5cdFx0XHRrZXk9aW5kZXg7XG5cdFx0XHR0aGlzLmtleXNbaW5kZXhdPWluZGV4O1xuXHRcdH1cblx0XHR2YXIgY2lyY19pbmRleD10aGlzLmNpcmNsZXMucG9zaXRpb24ubGVuZ3RoO1xuXHRcdHRoaXMuY2lyY2xlcy5wb3NpdGlvbi5wdXNoKHBvc2l0aW9uKTtcblx0XHR0aGlzLmNpcmNsZXMucmFkaXVzLnB1c2gocmFkaXVzKTtcblx0XHR0aGlzLmNpcmNsZXMuY29sb3IucHVzaChbY29sb3JbMF0vMjU1LGNvbG9yWzFdLzI1NSxjb2xvclsyXS8yNTVdKTtcblx0XHR0aGlzLmNpcmNsZXMucGlja19jb2xvci5wdXNoKHRoaXMuX2dldFJHQkZyb21JbmRleChpbmRleCsxKSk7XG5cdFx0dGhpcy5jaXJjbGVzLnN0YXJ0X2FuZ2xlLnB1c2goc3RhcnRfYW5nbGUpO1xuXHRcdHRoaXMuY2lyY2xlcy5lbmRfYW5nbGUucHVzaChlbmRfYW5nbGUpO1xuXHRcdHRoaXMub2JqZWN0cy5wdXNoKFtjaXJjX2luZGV4LDAsa2V5XSk7XG5cdFx0dGhpcy5jaXJjbGVzLmNvdW50Kys7XG5cdH1cblxuXG5cdGFkZENpcmNsZShwb3NpdGlvbixyYWRpdXMsY29sb3Isa2V5KXtcblx0XHR2YXIgaW5kZXggPSB0aGlzLm9iamVjdHMubGVuZ3RoO1xuXHRcdCBpZiAoa2V5ICYmICEgdGhpcy5rZXlzW2tleV0pe1xuXHRcdFx0dGhpcy5rZXlzW2tleV09aW5kZXg7XG5cdFx0fVxuXHRcdGVsc2V7XG5cdFx0XHRrZXk9aW5kZXg7XG5cdFx0XHR0aGlzLmtleXNbaW5kZXhdPWluZGV4O1xuXHRcdH1cblx0XHR2YXIgY2lyY19pbmRleD10aGlzLmNpcmNsZXMucG9zaXRpb24ubGVuZ3RoO1xuXHRcdHRoaXMuY2lyY2xlcy5wb3NpdGlvbi5wdXNoKHBvc2l0aW9uKTtcblx0XHR0aGlzLmNpcmNsZXMucmFkaXVzLnB1c2gocmFkaXVzKTtcblx0XHR0aGlzLmNpcmNsZXMub3BhY2l0eS5wdXNoKDEpO1xuXHRcdHRoaXMuY2lyY2xlcy5jb2xvci5wdXNoKFtjb2xvclswXS8yNTUsY29sb3JbMV0vMjU1LGNvbG9yWzJdLzI1NV0pO1xuXHRcdHRoaXMuY2lyY2xlcy5waWNrX2NvbG9yLnB1c2godGhpcy5fZ2V0UkdCRnJvbUluZGV4KGluZGV4KzEpKTtcblx0XHR0aGlzLmNpcmNsZXMuc3RhcnRfYW5nbGUucHVzaCgxMCk7XG5cdFx0dGhpcy5jaXJjbGVzLmVuZF9hbmdsZS5wdXNoKDApO1xuXHRcdHRoaXMub2JqZWN0cy5wdXNoKFtjaXJjX2luZGV4LDAsa2V5XSk7XG5cdFx0dGhpcy5jaXJjbGVzLmNvdW50Kys7XG5cdH1cblxuXHRhZGRQb2ludFJlY3RhbmdsZShwb3NpdGlvbixoZWlnaHQsd2lkdGgsY29sb3Isa2V5KXtcblx0XHR2YXIgc2lkZV9sZW5ndGg9IGhlaWdodD53aWR0aD9oZWlnaHQ6d2lkdGg7XG5cdFx0dmFyIGluZGV4ID0gdGhpcy5vYmplY3RzLmxlbmd0aDtcblx0XHRpZiAoa2V5ICYmICEgdGhpcy5rZXlzW2tleV0pe1xuXHRcdFx0dGhpcy5rZXlzW2tleV09aW5kZXg7XG5cdFx0fVxuXHRcdGVsc2V7XG5cdFx0XHRrZXk9aW5kZXg7XG5cdFx0XHR0aGlzLmtleXNbaW5kZXhdPWluZGV4O1xuXHRcdH1cblxuXHRcdHZhciBzcXVhcmVfaW5kZXg9dGhpcy5zcXVhcmVzLnBvc2l0aW9uLmxlbmd0aDtcblx0XHR0aGlzLnNxdWFyZXMucG9zaXRpb24ucHVzaChbcG9zaXRpb25bMF0rc2lkZV9sZW5ndGgvMixwb3NpdGlvblsxXStzaWRlX2xlbmd0aC8yXSk7XG5cdFx0dGhpcy5zcXVhcmVzLmNvbG9yLnB1c2goW2NvbG9yWzBdLzI1NSxjb2xvclsxXS8yNTUsY29sb3JbMl0vMjU1XSk7XG5cdFx0dGhpcy5zcXVhcmVzLnNpZGVfbGVuZ3RoLnB1c2goc2lkZV9sZW5ndGgpO1xuXHRcdHRoaXMuc3F1YXJlcy5yaWdodF9jbGlwLnB1c2god2lkdGgvc2lkZV9sZW5ndGgpO1xuXHRcdHRoaXMuc3F1YXJlcy5ib3R0b21fY2xpcC5wdXNoKGhlaWdodC9zaWRlX2xlbmd0aCk7XG5cdFx0dGhpcy5zcXVhcmVzLnBpY2tfY29sb3IucHVzaCh0aGlzLl9nZXRSR0JGcm9tSW5kZXgoaW5kZXgrMSkpO1xuXHRcdHRoaXMub2JqZWN0cy5wdXNoKFtzcXVhcmVfaW5kZXgsMyxrZXldKTtcblx0XHR0aGlzLnNxdWFyZXMuY291bnQrKztcblx0fVxuXG5cblxuXG5cdF9nZXRSR0JGcm9tSW5kZXgoaW5kZXgpe1xuXHRcdHZhciBiID0gTWF0aC5mbG9vcihpbmRleC82NTUzNik7XG5cdFx0dmFyIHRlbXAgPSBpbmRleCU2NTUzNjtcblx0XHR2YXIgZz0gTWF0aC5mbG9vcih0ZW1wLzI1Nik7XG5cdFx0dmFyIHIgPSB0ZW1wJTI1Njtcblx0XHRyZXR1cm4gW3IvMjU1LGcvMjU1LGIvMjU1XTtcbiAgICAgICAgICAgIFxuXHR9XG5cdF9nZXRJbmRleEZyb21SR0IocmdiKXtcbiAgICBcdHJldHVybiAocmdiWzJdKjY1NTM2KSsocmdiWzFdKjI1NikrcmdiWzBdOyAgICBcblx0fVxuXG5cdF9kcmF3UGlja0J1ZmZlcihpbl92aWV3KXtcbiAgICAgICBcdHRoaXMucmVnbC5jbGVhcih7XG4gICAgICAgIFx0Y29sb3I6IFswLCAwLCAwLCAwXSxcblx0XHRcdGRlcHRoOiAxLFxuICAgICAgICBcdGZyYW1lYnVmZmVyOnRoaXMucGlja2J1ZmZlclxuICAgIFx0fSk7XG4gICAgIFx0dGhpcy5fZHJhd09iamVjdHModHJ1ZSxpbl92aWV3KTtcbiAgICBcblx0fVxuXHQvL3JlZmVzaCBhbGwgXG5cdC8vaW5fdmlldyBvbmx5IHRob3NlIGluIHZpZXdcblx0cmVmcmVzaChpbl92aWV3KXtcbiAgICBcdHRoaXMubGFiZWxfY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIFx0dGhpcy5fZHJhd09iamVjdHMoZmFsc2UsaW5fdmlldyk7XG4gICAgXHR0aGlzLl9kcmF3UGlja0J1ZmZlcihpbl92aWV3KTtcbiAgICBcdHRoaXMubGFiZWxfY29udGV4dC5mb250ID0gXCIzMHB4IEFyaWFsXCI7XG4gICBcblx0fVxuXG5cdHpvb20oYW1vdW50KXtcbiAgICBcdHRoaXMueF9zY2FsZSo9YW1vdW50O1xuICAgIFx0dGhpcy55X3NjYWxlKj1hbW91bnQ7XG4gICBcdFx0dGhpcy5fZHJhd09iamVjdHMoZmFsc2UpO1xuXHR9XG5cblx0X2RyYXdPYmplY3Qob2JqZWN0LGNvbG9yKXtcbiAgICBcblx0XHR2YXIgdHlwZSA9dGhpcy5vYmplY3RfdHlwZXNbb2JqZWN0WzFdXTtcblx0XHR2YXIgb2JqPXtcblx0XHRcdHN0YWdlX3dpZHRoOnRoaXMud2lkdGgsXG5cdFx0XHRzdGFnZV9oZWlnaHQ6dGhpcy5oZWlnaHQsXG5cdFx0XHR4X3NjYWxlOnRoaXMueF9zY2FsZSxcblx0XHRcdHlfc2NhbGU6dGhpcy55X3NjYWxlLFxuXHRcdFx0YnVmZmVyOm51bGwsXG5cdFx0XHRvZmZzZXQ6dGhpcy5vZmZzZXQsXG5cdFx0XHRjb3VudDp0eXBlLnZlcnRpY2VzLFxuXHRcdFx0cHJpbWl0aXZlOnR5cGUucHJpbWl0aXZlLFxuXHRcdFx0aXNfYnVmZmVyOjBcblxuXHRcdH07XG5cdFxuXG5cdFx0Zm9yICh2YXIgcHJvcCBpbiB0eXBlLnByb3BlcnRpZXMpeyAgIFxuXHRcdFx0aWYgKHByb3A9PT0ncGlja19jb2xvcicpe1xuXHRcdFx0XHQgIGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0b2JqW3Byb3BdPVtdO1xuXHRcdFx0dmFyIHN0PSBvYmplY3RbMF07XG5cdFx0XHR2YXIgZW4gPXN0K3R5cGUudmVydGljZXM7XG5cdFx0XHRmb3IgKHZhciBwb3M9c3Q7cG9zPGVuO3BvcysrKXtcblx0XHRcdFx0aWYgKHByb3AhPT0nY29sb3InKXtcblx0XHRcdFx0XHRvYmpbcHJvcF0ucHVzaCh0eXBlLmRhdGFbcHJvcF1bcG9zXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZXtcblx0XHRcdFx0XHRvYmpbcHJvcF0ucHVzaChjb2xvcik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHR5cGUubWV0aG9kKG9iaik7XG5cdH1cblxuXG5cdF9kcmF3T2JqZWN0cyhidWZmZXIsaW5fdmlldyl7XG5cdFx0Ly9kclxuXHRcdHRoaXMuaW1hZ2VzLmdsb2JhbHNbMF09dGhpcy5vZmZzZXRbMF07XG5cdFx0dGhpcy5pbWFnZXMuZ2xvYmFsc1sxXT10aGlzLm9mZnNldFsxXVxuXHRcdHRoaXMuaW1hZ2VzLmdsb2JhbHNbMl09dGhpcy54X3NjYWxlO1xuXHRcdHRoaXMuaW1hZ2VzLmdsb2JhbHNbM109dGhpcy55X3NjYWxlO1xuXHRcdGlmICh0aGlzLmltYWdlcy5kaXNwbGF5X2FzX2ltYWdlKXtcblx0XHRcdHRoaXMuX19kcmF3SW1hZ2VzKHRoaXMuaW1hZ2VzLnByb3BzKTtcblx0XHR9XG5cdFx0XG5cblx0XHR2YXIgZGF0YV9zb3VyY2U9aW5fdmlldz9cImRhdGFfaW5fdmlld1wiOlwiZGF0YVwiO1xuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5vYmplY3RfdHlwZXMpe1xuXHRcdFx0dmFyIHR5cGUgPXRoaXMub2JqZWN0X3R5cGVzW2ldO1xuXHRcdFx0aWYgKHR5cGVbZGF0YV9zb3VyY2VdLmNvdW50PT09MCl7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoYnVmZmVyKXtcblx0XHRcdFx0YnVmZmVyPXRoaXMucGlja2J1ZmZlcjtcblx0XHRcdH1cblx0XHRcdGVsc2V7XG5cdFx0XHRcdGJ1ZmZlcj1udWxsO1xuXHRcdFx0fVxuXHRcdFx0Ly9kb24ndCBkcmF3IGltYWdlcyB1bmxlc3MgYnVmZmVyXG5cdFx0XHRpZiAoIShidWZmZXIpICYmIGk9PTQgJiYgdGhpcy5pbWFnZXMuZGlzcGxheV9hc19pbWFnZSl7XG5cdFx0XHRcdGNvbnRpbnVlXG5cdFx0XHR9XG5cdFx0XHR2YXIgb2JqPXtcblx0XHRcdCAgIHN0YWdlX3dpZHRoOnRoaXMud2lkdGgsXG5cdFx0XHQgICBzdGFnZV9oZWlnaHQ6dGhpcy5oZWlnaHQsXG5cdFx0XHQgICB4X3NjYWxlOnRoaXMueF9zY2FsZSxcblx0XHRcdCAgIHlfc2NhbGU6dGhpcy55X3NjYWxlLFxuXHRcdFx0ICAgZ2xvYmFsczp0aGlzLmltYWdlcy5nbG9iYWxzLFxuXHRcdFx0ICAgYnVmZmVyOmJ1ZmZlcixcblx0XHRcdCAgIG9mZnNldDp0aGlzLm9mZnNldCxcblx0XHRcdCAgIGNvdW50OnR5cGVbZGF0YV9zb3VyY2VdLmNvdW50ICogdHlwZS52ZXJ0aWNlcyxcblx0XHRcdCAgIHByaW1pdGl2ZTp0eXBlLnByaW1pdGl2ZSxcblx0XHRcdCAgIGlzX2J1ZmZlcjpidWZmZXI/MTowXG5cblxuXHRcdFx0fTtcblx0XHRcdC8vZHVtbXkgdmFsdWVzXG5cdFx0XHRpZiAoaT09NCl7XG5cdFx0XHRcdG9iai53X2g9WzAsMF07XG5cdFx0XHRcdG9iai54X3k9WzAsMF07XG5cdFx0XHRcdG9iai50ZXh0PXRoaXMubG9hZGluZ19pbWFnZTtcblx0XHRcdFx0b2JqLmlzX2J1ZmZlcj0xO1xuXHRcdFx0XHRcblx0XHRcdFx0XG5cdFx0XHRcblxuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgcHJvcCBpbiB0eXBlLnByb3BlcnRpZXMpe1xuXG5cdFx0XHRcdGlmIChidWZmZXIpe1xuXHRcdFx0XHRcdGlmIChwcm9wPT09J3BpY2tfY29sb3InKXtcblx0XHRcdFx0XHRcdG9ialsnY29sb3InXT10eXBlW2RhdGFfc291cmNlXVtwcm9wXTtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAocHJvcD09PSdjb2xvcicpe1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG9ialtwcm9wXT10eXBlW2RhdGFfc291cmNlXVtwcm9wXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNle1xuXHRcdFx0XHRcdGlmIChwcm9wPT09J3BpY2tfY29sb3InKXtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRvYmpbcHJvcF09dHlwZVtkYXRhX3NvdXJjZV1bcHJvcF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHR5cGUubWV0aG9kKG9iaik7XG5cdFx0fVxuXHR9XG5cblx0ZmlsdGVyT2JqZWN0cyhrZXlzLG9iamVjdF90eXBlKXtcblx0XHRpZiAoISBvYmplY3RfdHlwZSl7XG5cdFx0XHRvYmplY3RfdHlwZT0wO1xuXHRcdH1cblx0XHQvL3RoaXMuaXNfZmlsdGVyZWQ9e307XG5cdFx0XG5cdFx0bGV0IG9ial90eXBlPSB0aGlzLm9iamVjdF90eXBlc1tvYmplY3RfdHlwZV07XG5cdFx0Zm9yKGxldCBvYmogb2YgdGhpcy5vYmplY3RzKXtcdFxuXHRcdFx0bGV0IGtleSA9b2JqWzJdO1xuXHRcdFx0aWYgKGtleXNba2V5XSl7XG5cdFx0XHRcdG9ial90eXBlLmRhdGEub3BhY2l0eVtvYmpbMF1dPTE7XG5cdFx0XHR9XG5cdFx0XHRlbHNle1xuXHRcdFx0XHQvL3RoaXMuaXNfZmlsdGVyZWRba2V5XT10cnVlO1xuXHRcdFx0XHRvYmpfdHlwZS5kYXRhLm9wYWNpdHlbb2JqWzBdXT0wLjQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5pc19oaWRkZW5ba2V5XSl7XG5cdFx0XHRcdG9ial90eXBlLmRhdGEub3BhY2l0eVtvYmpbMF1dPTA7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHR9XG5cdH1cblxuXHRoaWRlT2JqZWN0cyhrZXlzLG9iamVjdF90eXBlKXtcblx0XHRpZiAoISBvYmplY3RfdHlwZSl7XG5cdFx0XHRvYmplY3RfdHlwZT0wO1xuXHRcdH1cblx0XHR0aGlzLmlzX2hpZGRlbj17fTtcblx0XHRcblx0XHRsZXQgb2JqX3R5cGU9IHRoaXMub2JqZWN0X3R5cGVzW29iamVjdF90eXBlXTtcblx0XHRmb3IobGV0IG9iaiBvZiB0aGlzLm9iamVjdHMpe1x0XG5cdFx0XHRsZXQga2V5ID1vYmpbMl07XG5cdFx0XHRpZiAoa2V5c1trZXldKXtcblx0XHRcdFx0XG5cdFx0XHRcdFx0b2JqX3R5cGUuZGF0YS5vcGFjaXR5W29ialswXV09MVxuXHRcdFx0XHRcblx0XHRcdH1cblx0XHRcdGVsc2V7XG5cdFx0XHRcdHRoaXMuaXNfaGlkZGVuW2tleV09dHJ1ZTtcblx0XHRcdFx0b2JqX3R5cGUuZGF0YS5vcGFjaXR5W29ialswXV09MDtcblx0XHRcdFx0XG5cdFx0XHR9XG5cdFx0XG5cdFx0XHRcblx0XHR9XG5cdH1cblxuXG5cblx0aW5pdGlhbGlzZSgpe1xuXHRcdGxldCBzZWxmID0gdGhpcztcblxuXHRcdHZhciBpbSA9IG5ldyBJbWFnZSgpXG4gICAgICAgXG4gICAgICAgIGltLm9ubG9hZD1mdW5jdGlvbigpe1xuICAgICAgICAgICAgICBzZWxmLmxvYWRpbmdfaW1hZ2U9c2VsZi5yZWdsLnRleHR1cmUoe2RhdGE6aW0sbWluOlwibGluZWFyXCJ9KTtcbiAgICAgICAgICAgICAgZm9yIChsZXQgcHJvcCBvZiBzZWxmLmltYWdlcy5wcm9wcyl7XG4gICAgICAgICAgICAgIFx0aWYgKCFwcm9wLnRleHQpe1xuICAgICAgICAgICAgICBcdFx0cHJvcC50ZXh0PXNlbGYubG9hZGluZ19pbWFnZTtcbiAgICAgICAgICAgICAgXHR9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc2VsZi5yZWZyZXNoKCk7XG4gICAgXHRcdCAgc2VsZi5fZ2V0T2JqZWN0c0luVmlldygpO1xuICAgICAgICB9XG4gICAgICAgIGltLnNyYyA9IFwidG4xMy5wbmdcIlxuICAgIFxuXHR9XG5cblx0X2dldE9iamVjdEF0UG9zaXRpb24ocG9zaXRpb24pe1xuXHRcdHZhciBwaXhlbCA9IHRoaXMucmVnbC5yZWFkKHtcblx0XHRcdHg6IHBvc2l0aW9uWzBdLFxuXHRcdFx0eTogdGhpcy5oZWlnaHQgLSBwb3NpdGlvblsxXSxcblx0XHRcdHdpZHRoOiAxLFxuXHRcdFx0aGVpZ2h0OiAxLFxuXHRcdFx0ZGF0YTogbmV3IFVpbnQ4QXJyYXkoNiksXG5cdFx0XHRmcmFtZWJ1ZmZlcjogdGhpcy5waWNrYnVmZmVyXG5cdFx0fSk7XG5cdFx0dmFyIGluZGV4ID0gdGhpcy5fZ2V0SW5kZXhGcm9tUkdCKHBpeGVsKTtcblx0XHRpZiAoaW5kZXg+MCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5vYmplY3RzW2luZGV4LTFdO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGNoZWNrSW1hZ2VzTG9hZGVkKCl7XG5cdFx0bGV0IHNlbGYgPSB0aGlzO1xuXHRcdFxuXHRcdGlmICh0aGlzLmltYWdlc190b19sb2FkPjApe1xuXHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpe1xuXHRcdFx0XHRzZWxmLnJlZnJlc2goKTtcblx0XHRcdFx0c2VsZi5jaGVja0ltYWdlc0xvYWRlZCgpO1xuXHRcdFx0fSwyMDAwKVxuXHRcdH1cblx0fVxuXG5cdF9nZXRPYmplY3RzSW5WaWV3KCl7XG5cdFx0dmFyIHRpbWUgPSBEYXRlLm5vdygpO1xuXHRcdHZhciBtYXggPSB0aGlzLndpZHRoKnRoaXMuaGVpZ2h0KjQ7XG5cdFx0dmFyIHBpeGVscyA9IHRoaXMucmVnbC5yZWFkKHtcblx0XHRcdHg6IDAsXG5cdFx0XHR5OiAwLFxuXHRcdFx0d2lkdGg6dGhpcy53aWR0aCxcblx0XHRcdGhlaWdodDogdGhpcy5oZWlnaHQsXG5cdFx0XHRkYXRhOiBuZXcgVWludDhBcnJheShtYXgpLFxuXHRcdFx0ZnJhbWVidWZmZXI6IHRoaXMucGlja2J1ZmZlclxuXHRcdH0pO1xuXHRcdHZhciBvYmo9e307XG5cdFx0dGhpcy5fY2xlYXJPYmplY3RzSW5WaWV3KCk7XG5cdFx0Zm9yICh2YXIgaT0wO2k8bWF4LTQ7aSs9NCl7XG5cdFx0XHR2YXIgIGluZGV4ID0gcGl4ZWxzW2krMl0qNjU1MzYrcGl4ZWxzW2krMV0qMjU2K3BpeGVsc1tpXTtcblx0XHRcdGlmIChpbmRleD4wKXtcblx0XHRcdFx0aWYoIW9ialtpbmRleC0xXSl7XG5cdFx0XHRcdFx0b2JqW2luZGV4LTFdPXRydWU7XG5cdFx0XHRcdFx0dGhpcy5vYmplY3RzX2luX3ZpZXcrKztcblx0XHRcdFx0XHRpZiAodGhpcy5vYmplY3RzX2luX3ZpZXc+MTAwMDAwKXtcblx0XHRcdFx0XHRcdGZvciAodmFyIHQgaW4gdGhpcy5vYmplY3RfdHlwZXMpe1xuXHRcdFx0XHRcdFx0XHR2YXIgdHlwZSA9IHRoaXMub2JqZWN0X3R5cGVzW3RdO1xuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBwcm9wIGluIHR5cGUucHJvcGVydGllcyl7ICAgICBcblx0XHRcdFx0XHRcdFx0XHR0eXBlLmRhdGFfaW5fdmlld1twcm9wXT0odHlwZS5kYXRhW3Byb3BdKTsgICAgICAgXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dHlwZS5kYXRhX2luX3ZpZXcuY291bnQ9dHlwZS5kYXRhLmNvdW50O1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR0aGlzLm9iamVjdHNfaW5fdmlldz10aGlzLm9iamVjdHMubGVuZ3RoO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICAgICAgXG5cdFx0XHR9ICAgICAgIFxuXHRcdH1cblx0XHQgLy9jb25zb2xlLmxvZyhcIm9iamVjdHMgaW4gdmlldyBvbGQgd2F5IFwiKyhEYXRlLm5vdygpLXRpbWUpKTtcblx0XHR2YXIgbCA9ICAtdGhpcy5vZmZzZXRbMF07XG5cdFx0dmFyIHIgPSBsKyh0aGlzLndpZHRoL3RoaXMueF9zY2FsZSk7XG5cdFx0dmFyIHQgPSAgLXRoaXMub2Zmc2V0WzFdO1xuXHRcdHZhciBiID0gdCsodGhpcy5oZWlnaHQvdGhpcy55X3NjYWxlKTtcblx0XHR2YXIgb2xkX2NvdW50PTA7XG5cdFx0dmFyIG5ld19jb3VudD0wO1xuXHRcdGZvciAodmFyIGk9MDtpPHRoaXMub2JqZWN0cy5sZW5ndGg7aSsrKXtcblx0XHRcdGlmIChvYmpbaV0pe1xuXHRcdFx0XHR2YXIgaXRlbT0gdGhpcy5vYmplY3RzW2ldO1xuXHRcdFx0XHR2YXIgdHlwZSA9dGhpcy5vYmplY3RfdHlwZXNbaXRlbVsxXV07XG5cdFx0XHRcdG5ld19jb3VudCsrO1xuXG5cdFx0XHRcdHZhciBzdD0gaXRlbVswXTtcblx0XHRcdFx0dmFyIGVuID1zdCt0eXBlLnZlcnRpY2VzO1xuXHRcdFx0XHRmb3IgKHZhciBwcm9wIGluIHR5cGUucHJvcGVydGllcyl7ICAgIFxuXHRcdFx0XHRcdGZvciAodmFyIHBvcz1zdDtwb3M8ZW47cG9zKyspe1xuXHRcdFx0XHRcdFx0dHlwZS5kYXRhX2luX3ZpZXdbcHJvcF0ucHVzaCh0eXBlLmRhdGFbcHJvcF1bcG9zXSk7ICAgICAgIFxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cdFx0XHRcdHR5cGUuZGF0YV9pbl92aWV3LmNvdW50Kys7XG5cblx0XHRcdH1cblx0XHRcdGVsc2V7XG5cblx0XHRcdFx0dmFyIGl0ZW09IHRoaXMub2JqZWN0c1tpXTtcblx0XHRcdFx0dmFyIHR5cGUgPXRoaXMub2JqZWN0X3R5cGVzW2l0ZW1bMV1dO1xuXHRcdFx0XHR2YXIgYWN0X3BvcyA9dGhpcy5vYmplY3RfdHlwZXNbaXRlbVsxXV0uZGF0YS5wb3NpdGlvbltpdGVtWzBdXTtcblx0XHRcdFx0aWYgKGFjdF9wb3NbMF0+bCAmJiBhY3RfcG9zWzBdPHIgJiYgYWN0X3Bvc1sxXSA+dCAmJiBhY3RfcG9zWzFdPGIpe1xuXHRcdFx0XHRcdCBvbGRfY291bnQrKztcblx0XHRcdFx0XHR2YXIgc3Q9IGl0ZW1bMF07XG5cdFx0XHRcdFx0dmFyIGVuID1zdCt0eXBlLnZlcnRpY2VzO1xuXHRcdFx0XHRcdGZvciAodmFyIHByb3AgaW4gdHlwZS5wcm9wZXJ0aWVzKXsgICAgXG5cdFx0XHRcdFx0XHRmb3IgKHZhciBwb3M9c3Q7cG9zPGVuO3BvcysrKXtcblx0XHRcdFx0XHRcdFx0dHlwZS5kYXRhX2luX3ZpZXdbcHJvcF0ucHVzaCh0eXBlLmRhdGFbcHJvcF1bcG9zXSk7ICAgICAgIFxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dHlwZS5kYXRhX2luX3ZpZXcuY291bnQrKztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cblxuXG5cblx0XHR9XG5cdFx0Y29uc29sZS5sb2coXCJJbiB2aWV3OlwiK3RoaXMub2JqZWN0cy5sZW5ndGgrXCI6XCIrbmV3X2NvdW50K1wiOlwiK29sZF9jb3VudCk7XG5cblx0XHRjb25zb2xlLmxvZyhcInRpbWUgdG8gZ2V0IG9iamVjdHMgaW4gdmlldyBcIisoRGF0ZS5ub3coKS10aW1lKSk7ICAgIFxuXHR9XG5cblx0X2NsZWFyT2JqZWN0c0luVmlldygpe1xuXHRcdHRoaXMub2JqZWN0c19pbl92aWV3PTA7XG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLm9iamVjdF90eXBlcyl7XG5cdFx0XHR2YXIgb2JqID0gdGhpcy5vYmplY3RfdHlwZXNbaV07XG5cblx0XHRcdFx0Zm9yICh2YXIgcHJvcCBpbiBvYmoucHJvcGVydGllcyl7XG5cdFx0XHRcdFx0b2JqLmRhdGFfaW5fdmlld1twcm9wXT1bXTtcblx0XHRcdFx0fSAgICAgXG5cblx0XHRcdG9iai5kYXRhX2luX3ZpZXcuY291bnQ9MDtcblx0XHR9ICBcblx0fVxuXG5cdGFkZEhhbmRsZXIoaGFuZGxlcl90eXBlLGhhbmRsZXIsbmFtZSl7XG5cdFx0dmFyIGhhbmRsZXJfZGljdCA9IHRoaXMuaGFuZGxlcnNbaGFuZGxlcl90eXBlXTtcblx0XHRpZiAoIWhhbmRsZXJfZGljdCl7XG5cdFx0XHR0aHJvdyBcIkhhbmRsZXIgTm90IFN1cHBvcnRlZFwiO1xuXHRcdH1cblx0XHRpZiAoIW5hbWUpe1xuXHRcdFx0bmFtZSA9IE9iamVjdC5rZXlzKGhhbmRsZXJfZGljdCkubGVuZ3RoO1xuXHRcdH1cblx0XHRoYW5kbGVyX2RpY3RbbmFtZV09aGFuZGxlcjtcblx0XHRyZXR1cm4gbmFtZTtcblx0fVxuXG5cdHJlbW92ZUhhbmRsZXIoaGFuZGxlcl90eXBlLG5hbWUpe1xuXHRcdHZhciBoYW5kbGVyX2RpY3QgPSB0aGlzLmhhbmRsZXJzW2hhbmRsZXJfdHlwZV07XG5cdFx0aWYgKCFoYW5kbGVyX2RpY3Qpe1xuXHRcdFx0dGhyb3cgXCJIYW5kbGVyIE5vdCBTdXBwb3J0ZWRcIjtcblx0XHR9XG5cdFx0ZGVsZXRlIGhhbmRsZXJfZGljdFsnbmFtZSddO1xuXG5cblx0fVxuXG5cdF9zZXRVcEJydXNoKG9yaWdpbil7XG5cdFx0bGV0IHNlbGYgPSB0aGlzO1xuXHRcdGxldCBkaXYgPSQoXCI8ZGl2PlwiKS5jc3Moe3Bvc2l0aW9uOlwiYWJzb2x1dGVcIixsZWZ0Om9yaWdpblswXSxcblx0XHRcdFx0XHRcdFx0XHRcdHRvcDpvcmlnaW5bMV0saGVpZ2h0OlwiMHB4XCIsd2lkdGg6XCIwcHhcIixcblx0XHRcdFx0XHRcdFx0XHRcdFwiYmFja2dyb3VuZC1jb2xvclwiOlwiZ3JheVwiLG9wYWNpdHk6MC4yfSlcblx0XHRcdFx0XHRcdFx0XHQgIC5hcHBlbmRUbyh0aGlzLmRpdl9jb250YWluZXIpO1xuXG5cdFx0ZGl2LmRyYWdnYWJsZSh7XG5cdFx0XHRzdGFydDpmdW5jdGlvbihldix1aSl7XG5cdFx0XHRcdHNlbGYuYnJ1c2gubW92aW5nPXRydWU7XG5cdFx0XHR9LFxuXHRcdFx0c3RvcDpmdW5jdGlvbiAoZXYsdWkpe1xuXHRcdFx0XHRzZWxmLl9icnVzaGluZ1N0b3BwZWQoKTtcblxuXHRcdFx0fVxuXG5cdFx0fSkucmVzaXphYmxlKHtcblx0XHRcdGhhbmRsZXM6XCJhbGxcIixcblx0XHRcdHN0YXJ0OmZ1bmN0aW9uKGV2LHVpKXtcblx0XHRcdFx0c2VsZi5icnVzaC5tb3Zpbmc9dHJ1ZTtcblx0XHRcdH0sXG5cdFx0XHRzdG9wOmZ1bmN0aW9uIChldix1aSl7XG5cdFx0XHRcdHNlbGYuX2JydXNoaW5nU3RvcHBlZCgpO1xuXG5cdFx0XHR9XG5cblx0XHR9KTtcblx0XHR0aGlzLmJydXNoPXtvcmlnaW46b3JpZ2luLGRpdjpkaXYscmVzaXppbmc6dHJ1ZX07XG5cdH1cblxuXHRjbGVhckJydXNoKCl7XG5cdFx0aWYgKHRoaXMuYnJ1c2gpe1xuXHRcdFx0dGhpcy5icnVzaC5kaXYucmVtb3ZlKCk7XG5cdFx0XHR0aGlzLmJydXNoPW51bGw7XG5cdFx0fVxuXHR9XG5cblx0X2JydXNoaW5nU3RvcHBlZCgpe1xuXHRcdHRoaXMuYnJ1c2gucmVzaXppbmc9ZmFsc2U7XG5cdFx0bGV0IHBvcyA9IHRoaXMuYnJ1c2guZGl2LnBvc2l0aW9uKCk7XG5cdFx0bGV0IGx0ID10aGlzLl9nZXRBY3R1YWxQb3NpdGlvbihbcG9zLmxlZnQscG9zLnRvcF0pO1xuXHRcdGxldCBiciA9IHRoaXMuX2dldEFjdHVhbFBvc2l0aW9uKFtwb3MubGVmdCt0aGlzLmJydXNoLmRpdi53aWR0aCgpLHBvcy50b3ArdGhpcy5icnVzaC5kaXYuaGVpZ2h0KCldKTtcblx0XHRsZXQgaW5mbyA9IHt4X21pbjpsdFswXSx4X21heDpiclswXSx5X21pbjpsdFsxXSx5X21heDpiclsxXX07XG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLmhhbmRsZXJzLmJydXNoX3N0b3BwZWQpe1xuXHRcdFx0dGhpcy5oYW5kbGVycy5icnVzaF9zdG9wcGVkW2ldKGluZm8pO1xuXHRcdH1cblxuXHR9XG5cblxuXHRfYWRkSGFuZGxlcnMoKXtcblx0XHR2YXIgc2VsZj10aGlzO1xuXHRcdHRoaXMuZGl2X2NvbnRhaW5lci5tb3VzZW1vdmUoZnVuY3Rpb24oZSl7XG5cdFx0XHRpZiAoc2VsZi5icnVzaCl7XG5cdFx0XHRcdGlmIChzZWxmLmJydXNoLnJlc2l6aW5nKXtcblx0XHRcdFx0XHRsZXQgb3JpZ2luID1zZWxmLmJydXNoLm9yaWdpbjtcblx0XHRcdFx0XHRsZXQgbm93ID0gc2VsZi5fZ2V0TW91c2VQb3NpdGlvbihlKTtcblx0XHRcdFx0XHRsZXQgbGVmdCA9IE1hdGgucm91bmQoKG9yaWdpblswXTxub3dbMF0/b3JpZ2luWzBdOm5vd1swXSkpK1wicHhcIjtcblx0XHRcdFx0XHRsZXQgdG9wID1NYXRoLnJvdW5kKChvcmlnaW5bMV08bm93WzFdP29yaWdpblsxXTpub3dbMV0pKStcInB4XCI7XG5cdFx0XHRcdFx0bGV0IHdpZHRoID0gKE1hdGguYWJzKG9yaWdpblswXS1ub3dbMF0pKStcInB4XCI7XG5cdFx0XHRcdFx0bGV0IGhlaWdodD0gKE1hdGguYWJzKG9yaWdpblsxXS1ub3dbMV0pKStcInB4XCI7XG5cdFx0XHRcdFx0c2VsZi5icnVzaC5kaXYuY3NzKHt0b3A6dG9wLGxlZnQ6bGVmdCxoZWlnaHQ6aGVpZ2h0LHdpZHRoOndpZHRofSk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKHNlbGYuYnJ1c2gubW92aW5nKXtcblx0XHRcdFx0XHRzZWxmLmRyYWdnaW5nPWZhbHNlO1xuXHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0fVxuXHRcdFx0Ly9pcyB0aGlzIGEgZHJhZyBvciBqdXN0IGEgY2xpY2sgd2l0aG91dCB0aGUgbW91c2UgbW92aW5nXG5cdFx0XHRpZiAoc2VsZi5tb3VzZV9wb3NpdGlvbiAmJiAgISBzZWxmLmRyYWdnaW5nKXtcblx0XHRcdFx0dmFyIHhfYW1vdW50PSAoZS5wYWdlWC1zZWxmLm1vdXNlX3Bvc2l0aW9uWzBdKS9zZWxmLnhfc2NhbGU7XG5cdFx0XHRcdHZhciB5X2Ftb3VudCA9IChlLnBhZ2VZLXNlbGYubW91c2VfcG9zaXRpb25bMV0pL3NlbGYueV9zY2FsZTtcblx0XHRcdFx0aWYgKE1hdGguYWJzKHhfYW1vdW50KSA+IDMgfHwgTWF0aC5hYnMoeV9hbW91bnQpPjMpe1xuXHRcdFx0XHRcdHNlbGYuZHJhZ2dpbmcgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChzZWxmLmRyYWdnaW5nKXtcblx0XHRcdFx0dmFyIHhfYW1vdW50PSAoZS5wYWdlWC1zZWxmLm1vdXNlX3Bvc2l0aW9uWzBdKS9zZWxmLnhfc2NhbGU7XG5cdFx0XHRcdHZhciB5X2Ftb3VudCA9IChlLnBhZ2VZLXNlbGYubW91c2VfcG9zaXRpb25bMV0pL3NlbGYueV9zY2FsZTtcblx0XHRcdFx0aWYgKHNlbGYub2JqZWN0X2NsaWNrZWQpe1xuXG5cdFx0XHRcdFx0dmFyIHR5cGUgPXNlbGYub2JqZWN0X3R5cGVzW3NlbGYub2JqZWN0X2NsaWNrZWRbMV1dO1xuXHRcdFx0XHRcdHZhciBzdGFydCA9IHNlbGYub2JqZWN0X2NsaWNrZWRbMF07XG5cdFx0XHRcdFx0dmFyIGVuZCA9IHN0YXJ0K3R5cGUudmVydGljZXM7XG5cblx0XHRcdFx0XHRmb3IgKHZhciBpbmRleD1zdGFydDtpbmRleDxlbmQ7aW5kZXgrKyl7XG5cdFx0XHRcdFx0XHR0eXBlLmRhdGEucG9zaXRpb25baW5kZXhdWzBdKz14X2Ftb3VudDtcblx0XHRcdFx0XHRcdHR5cGUuZGF0YS5wb3NpdGlvbltpbmRleF1bMV0rPXlfYW1vdW50O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoc2VsZi5vYmplY3RfY2xpY2tlZFsxXT09NCl7XG5cdFx0XHRcdFx0XHRsZXQgcF9pbmRleCA9IHN0YXJ0LzY7XG5cdFx0XHRcdFx0XHRzZWxmLmltYWdlcy5wcm9wc1twX2luZGV4XS54X3k9W3R5cGUuZGF0YS5wb3NpdGlvbltzdGFydF1bMF0sdHlwZS5kYXRhLnBvc2l0aW9uW3N0YXJ0XVsxXV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHNlbGYucmVmcmVzaCh0cnVlKTtcblx0XHRcdFx0XHQvL3NlbGYuX2RyYXdMYWJlbHMoKTtcblxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2V7XG5cblx0XHRcdFx0XHRzZWxmLm9mZnNldFswXSs9eF9hbW91bnQ7XG5cdFx0XHRcdFx0c2VsZi5vZmZzZXRbMV0rPXlfYW1vdW50O1xuXHRcdFx0XHRcdHNlbGYuX2RyYXdPYmplY3RzKGZhbHNlKTsgIFxuXG5cdFx0XHRcdH1cblx0XHRcdFx0c2VsZi5tb3VzZV9wb3NpdGlvblsxXT1lLnBhZ2VZO1xuXHRcdFx0XHRzZWxmLm1vdXNlX3Bvc2l0aW9uWzBdPWUucGFnZVg7ICAgICAgXG5cdFx0XHR9XG5cdFx0XHQvL25vIGRyYWcgZXZlbnQgZ29pbmcgb24gY2FsbCBhbnkgbGlzdG5lcnMgaWYgbW91c2Ugb3Zlci9vdXQgYW4gb2JqZWN0XG5cdFx0XHRlbHNle1xuXHRcdFx0XHR2YXIgcG9zaXRpb24gPXNlbGYuX2dldE1vdXNlUG9zaXRpb24oZSk7XG5cdFx0XHRcdHZhciBvYmogPSBzZWxmLl9nZXRPYmplY3RBdFBvc2l0aW9uKHBvc2l0aW9uKTtcblx0XHRcdFx0aWYgKG9iaiAmJiAhc2VsZi5vYmplY3RfbW91c2Vfb3Zlcil7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSBpbiBzZWxmLmhhbmRsZXJzWydvYmplY3Rfb3ZlciddKXtcblx0XHRcdFx0XHRcdHNlbGYuaGFuZGxlcnMub2JqZWN0X292ZXJbaV0ob2JqWzJdKTsgICAgICAgICAgICAgICAgICBcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c2VsZi5vYmplY3RfbW91c2Vfb3Zlcj1vYmo7XG5cdFx0XHRcdFx0aWYgKHNlbGYubW91c2Vfb3Zlcl9jb2xvcil7XG5cdFx0XHRcdFx0XHRzZWxmLm9iamVjdF90ZW1wX2NvbG9yPXNlbGYuZ2V0T2JqZWN0Q29sb3Iob2JqWzJdKTtcblx0XHRcdFx0XHRcdHNlbGYuc2V0T2JqZWN0Q29sb3Iob2JqWzJdLHNlbGYubW91c2Vfb3Zlcl9jb2xvcik7XG5cdFx0XHRcdFx0XHRzZWxmLnJlZnJlc2godHJ1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKCFvYmogJiYgc2VsZi5vYmplY3RfbW91c2Vfb3Zlcil7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSBpbiBzZWxmLmhhbmRsZXJzWydvYmplY3Rfb3V0J10pe1xuXHRcdFx0XHRcdFx0c2VsZi5oYW5kbGVycy5vYmplY3Rfb3V0W2ldKHNlbGYub2JqZWN0X21vdXNlX292ZXJbMl0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoc2VsZi5tb3VzZV9vdmVyX2NvbG9yKXtcblx0XHRcdFx0XHRcdHNlbGYuc2V0T2JqZWN0Q29sb3Ioc2VsZi5vYmplY3RfbW91c2Vfb3ZlclsyXSxzZWxmLm9iamVjdF90ZW1wX2NvbG9yKTtcblx0XHRcdFx0XHRcdHNlbGYucmVmcmVzaCh0cnVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c2VsZi5vYmplY3RfbW91c2Vfb3Zlcj1udWxsO1xuXG5cdFx0XHRcdH1cblx0XHRcdFx0Ly9tb3ZlIGRpcmVjdGx5IGZyb20gb25lIG9iamVjdCB0byBhbm90aGVyXG5cdFx0XHRcdGVsc2UgaWYob2JqICYmIChvYmpbMl0hPT1zZWxmLm9iamVjdF9tb3VzZV9vdmVyWzJdKSl7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSBpbiBzZWxmLmhhbmRsZXJzWydvYmplY3Rfb3ZlciddKXsgICAgXG5cdFx0XHRcdFx0XHRzZWxmLmhhbmRsZXJzLm9iamVjdF9vdmVyW2ldKG9ialsyXSk7ICBcblx0XHRcdFx0XHR9XG5cblxuXHRcdFx0XHRcdGZvciAodmFyIGkgaW4gc2VsZi5oYW5kbGVyc1snb2JqZWN0X291dCddKXtcblx0XHRcdFx0XHRcdHNlbGYuaGFuZGxlcnMub2JqZWN0X291dFtpXShzZWxmLm9iamVjdF9tb3VzZV9vdmVyWzJdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHNlbGYubW91c2Vfb3Zlcl9jb2xvcil7XG5cdFx0XHRcdFx0XHRzZWxmLnNldE9iamVjdENvbG9yKHNlbGYub2JqZWN0X21vdXNlX292ZXJbMl0sc2VsZi5vYmplY3RfdGVtcF9jb2xvcik7XG5cdFx0XHRcdFx0XHRzZWxmLm9iamVjdF90ZW1wX2NvbG9yPXNlbGYuZ2V0T2JqZWN0Q29sb3Iob2JqWzJdKTtcblx0XHRcdFx0XHRcdHNlbGYuc2V0T2JqZWN0Q29sb3Iob2JqWzJdLHNlbGYubW91c2Vfb3Zlcl9jb2xvcik7XG5cdFx0XHRcdFx0XHRzZWxmLnJlZnJlc2godHJ1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHNlbGYub2JqZWN0X21vdXNlX292ZXI9b2JqO1xuXG5cblxuXG5cblx0XHRcdFx0fSAgICAgICAgIFxuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHRoaXMuZGl2X2NvbnRhaW5lci5tb3VzZXVwKGZ1bmN0aW9uKGV2dCl7XG5cdFx0XHQvL2p1c3QgYSBjbGljayBldmVudCAtIGluZm9ybSBoYW5kbGVyc1xuXHRcdFx0aWYgKHNlbGYuYnJ1c2ggJiYgc2VsZi5icnVzaC5yZXNpemluZyl7XG5cdFx0XHRcdHNlbGYuX2JydXNoaW5nU3RvcHBlZCgpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZiAoIXNlbGYuZHJhZ2dpbmcpe1xuXHRcdFx0XHRpZiAoc2VsZi5vYmplY3RfY2xpY2tlZCl7XG5cdFx0XHRcdFx0dmFyIHBvc2l0aW9uID1zZWxmLl9nZXRNb3VzZVBvc2l0aW9uKGV2dCk7XG5cdFx0XHRcdFx0dmFyIG9iaiA9IHNlbGYuX2dldE9iamVjdEF0UG9zaXRpb24ocG9zaXRpb24pO1xuXHRcdFx0XHRcdGlmIChvYmope1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaSBpbiBzZWxmLmhhbmRsZXJzLm9iamVjdF9jbGlja2VkKXtcblx0XHRcdFx0XHRcdFx0c2VsZi5oYW5kbGVycy5vYmplY3RfY2xpY2tlZFtpXShvYmpbMl0pO1xuXHRcdFx0XHRcdFx0fSAgXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdH0gICAgICAgIFxuXHRcdFx0ZWxzZXtcblx0XHRcdFx0Ly9hbiBvYmplY3QgaGFzIGZpbnNoZWQgaXRzIGRyYWdcblx0XHRcdFx0aWYgKHNlbGYub2JqZWN0X2NsaWNrZWQpe1xuXHRcdFx0XHRcdHNlbGYub2JqZWN0X2NsaWNrZWQ9bnVsbDtcblx0XHRcdFx0XHRzZWxmLnJlZnJlc2godHJ1ZSk7ICAgICAgICAgICAgICBcblx0XHRcdFx0fVxuXHRcdFx0XHQvL3VwZGF0ZSB3aGljaCBvYmplY3RzIGFyZSBub3cgaW4gdmlld1xuXHRcdFx0XHRlbHNle1xuXHRcdFx0XHRcdHNlbGYuX2RyYXdQaWNrQnVmZmVyKCk7XG5cdFx0XHRcdFx0c2VsZi5fZ2V0T2JqZWN0c0luVmlldygpO1xuXHRcdFx0XHRcdGlmIChzZWxmLmJydXNoKXtcblx0XHRcdFx0XHRcdHNlbGYuX2JydXNoaW5nU3RvcHBlZCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0ICAgc2VsZi5yZWZyZXNoKHRydWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNlbGYuZHJhZ2dpbmc9ZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRzZWxmLm9iamVjdF9jbGlja2VkPW51bGw7XG5cdFx0XHRzZWxmLm1vdXNlX3Bvc2l0aW9uPW51bGw7ICAgXG5cdFx0fSk7ICBcblxuXHRcdHRoaXMuZGl2X2NvbnRhaW5lci5iaW5kKCdtb3VzZXdoZWVsIERPTU1vdXNlU2Nyb2xsJywgZnVuY3Rpb24oZXZlbnQpe1xuXHRcdFx0dmFyIHBvc2l0aW9uID1zZWxmLl9nZXRBY3R1YWxQb3NpdGlvbihzZWxmLl9nZXRNb3VzZVBvc2l0aW9uKGV2ZW50KSk7XG5cdFx0aWYgKGV2ZW50Lm9yaWdpbmFsRXZlbnQud2hlZWxEZWx0YSA+IDAgfHwgZXZlbnQub3JpZ2luYWxFdmVudC5kZXRhaWwgPCAwKSB7XG5cdFx0XHRcdHNlbGYuem9vbV9hbW91bnQrPTAuMDU7XG5cblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRcdHNlbGYuem9vbV9hbW91bnQtPTAuMDU7XG5cblx0XHRcdH1cblxuXHRcdFx0c2VsZi54X3NjYWxlKj0oMStzZWxmLnpvb21fYW1vdW50KTtcblx0XHRcdHNlbGYueV9zY2FsZSo9KDErc2VsZi56b29tX2Ftb3VudCk7XG5cdFx0XHRcblx0XHRcdC8vc2VsZi5pbWFnZXMuZGlzcGxheV9hc19pbWFnZT1zZWxmLnhfc2NhbGU+MC4wNDtcblx0XHRcdFxuXHRcdFx0dmFyIG5ld19wb3NpdGlvbj1zZWxmLl9nZXRBY3R1YWxQb3NpdGlvbihzZWxmLl9nZXRNb3VzZVBvc2l0aW9uKGV2ZW50KSk7XG5cdFx0XHRzZWxmLm9mZnNldFswXSs9bmV3X3Bvc2l0aW9uWzBdLXBvc2l0aW9uWzBdO1xuXHRcdFx0c2VsZi5vZmZzZXRbMV0rPW5ld19wb3NpdGlvblsxXS1wb3NpdGlvblsxXTtcblx0XHRcdGlmICghc2VsZi5sb29wKXtcblx0XHRcdFx0c2VsZi5sb29wID0gc2VsZi5yZWdsLmZyYW1lKGZ1bmN0aW9uKCl7XG5cdFx0XHRcdHNlbGYuX2RyYXdPYmplY3RzKGZhbHNlKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblxuXHRcdFx0XG5cdFx0XHQvL2NsZWFyIHRoZSB0aW1lb3V0IHVzZXIgaGFzIG5vdCBmaW5pc2hlZCB6b29taW5nXG5cdFx0XHRjbGVhclRpbWVvdXQoJC5kYXRhKHRoaXMsICd0aW1lcicpKTtcblx0XHRcdC8vd2hlbiB1c2VyIGZpbmlzaGVzIGNhbGwgdGhlIGVzeHBlbnNpdmUgbWV0aG9kcztcblx0XHRcdCQuZGF0YSh0aGlzLCAndGltZXInLCBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLnpvb21fYW1vdW50PTA7XG5cdFx0XHRcdHNlbGYubG9vcC5jYW5jZWwoKTtcblx0XHRcdFx0c2VsZi5sb29wPW51bGw7XG5cdFx0XHRcdHNlbGYuX2RyYXdQaWNrQnVmZmVyKGZhbHNlKTtcblx0XHRcdFx0c2VsZi5fZ2V0T2JqZWN0c0luVmlldygpO1xuXHRcdFx0XHRpZiAoc2VsZi5icnVzaCl7XG5cblx0XHRcdFx0fVxuXHRcdFx0XHRzZWxmLnJlZnJlc2godHJ1ZSk7XG5cdFx0XHR9LCAzNTApKTtcblxuXHRcdH0pO1xuXHRcdHRoaXMuZGl2X2NvbnRhaW5lci5tb3VzZWRvd24oZnVuY3Rpb24gKGV2dCl7XG5cdFx0XHRpZiAoZXZ0LndoaWNoPT09Myl7XG5cdFx0XHRcdC8vYWRkIHJpZ2h0IGNsaWNrIGJlaGF2aW91clxuXHRcdFx0fVxuXHRcdFx0Ly9jcmVhdGUgYnJ1c2hcblx0XHRcdGlmIChldnQuc2hpZnRLZXkgJiYgIShzZWxmLmJydXNoKSl7XG5cdFx0XHRcdGxldCBvcmlnaW4gPXNlbGYuX2dldE1vdXNlUG9zaXRpb24oZXZ0KTtcblx0XHRcdFx0c2VsZi5fc2V0VXBCcnVzaChvcmlnaW4pO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFxuXHRcdFx0fVxuXHRcdFx0Ly9nZXQgbW91c2UgcG9zaXRpb24gYW5kIHdvcmsgb3V0IGlmIGFuIG9iamVjdCB3YXMgY2xpY2tlZFxuXHRcdFx0dmFyIHBvc2l0aW9uID1zZWxmLl9nZXRNb3VzZVBvc2l0aW9uKGV2dCk7XG5cdFx0XHRzZWxmLm1vdXNlX3Bvc2l0aW9uPSBbZXZ0LnBhZ2VYLCBldnQucGFnZVldO1xuXHRcdFx0dmFyIG9iaiA9IHNlbGYuX2dldE9iamVjdEF0UG9zaXRpb24ocG9zaXRpb24pO1xuXHRcdFx0XG5cdFx0XHRpZiAob2JqKXtcblx0XHRcdFx0c2VsZi5vYmplY3RfY2xpY2tlZD0gb2JqO1xuXHRcdFx0fVxuXG5cdFx0fSk7XG5cblx0fVxuXG5cblx0X2luaXREcmF3TWV0aG9kcygpe1xuXHRcdHZhciBzZWxmID0gdGhpcztcblxuXHRcdC8vbG9hZGluZyBpbWFnZXNcblx0XHRcblxuXG5cdFx0dGhpcy5fX2RyYXdDaXJjbGVzID0gdGhpcy5yZWdsKHtcblx0XHRcdGZyYWc6IFxuXHRcdFx0XHQgJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXFxuXHRcdFx0dmFyeWluZyB2ZWMzIGZyYWdDb2xvcjtcXG5cXFxuXHRcdFx0dmFyeWluZyBmbG9hdCBvcDtcXG5cXFxuXHRcdFx0XHRcdHZhcnlpbmcgZmxvYXQgc19hbmdsZTtcXG5cXFxuXHRcdFx0XHRcdHZhcnlpbmcgZmxvYXQgZV9hbmdsZTtcXG5cXFxuXHRcdFx0dm9pZCBtYWluKCl7XFxuXFxcblx0XHRcdFx0XHRcdFx0ZmxvYXQgciA9IDAuMDtcXG5cXFxuXHRcdFx0XHRcdFx0XHR2ZWMyIGN4eSA9IDIuMCAqIGdsX1BvaW50Q29vcmQgLSAxLjA7XFxuXFxcblx0XHRcdFx0XHRcdFx0ciA9IGRvdChjeHksIGN4eSk7XFxuXFxcblx0XHRcdFx0XHRcdFx0aWYgKHIgPiAxLjApIHtcXG5cXFxuXHRcdFx0XHRcdFx0XHRcdGRpc2NhcmQ7XFxuXFxcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XFxuXFxcblx0XHRcdFx0XHRcdFx0fVxcblxcXG5cdFx0XHRcdFx0XHRcdGVsc2V7XFxuXFxcblx0XHRcdFx0XHRcdFx0XHRpZiAoc19hbmdsZSAhPSAxMC4wKXtcXG5cXFxuXHRcdFx0XHRcdFx0XHRcdFx0ZmxvYXQgYW5nbGU9MC4wO1xcblxcXG5cdFx0XHRcdFx0XHRcdFx0XHRhbmdsZSA9YXRhbihjeHlbMV0sY3h5WzBdKTtcXG5cXFxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKGFuZ2xlPnNfYW5nbGUgJiYgYW5nbGUgPCBlX2FuZ2xlKXtcXG5cXFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZihyPjAuNzUpe1xcblxcXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Z2xfRnJhZ0NvbG9yPXZlYzQoMC4xLDAuMSwwLjEsb3ApO1xcblxcXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cXG5cXFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRlbHNle1xcblxcXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Z2xfRnJhZ0NvbG9yID0gdmVjNChmcmFnQ29sb3Isb3ApO1xcblxcXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cXG5cXFxuXHRcdFx0XHRcdFx0XHRcdFx0fVxcblxcXG5cdFx0XHRcdFx0XHRcdFx0XHRlbHNle1xcblxcXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGRpc2NhcmQ7XFxuXFxcblx0XHRcdFx0XHRcdFx0XHRcdH1cXG5cXFxuXHRcdFx0XHRcdFx0XHRcdH1cXG5cXFxuXHRcdFx0XHRcdFx0XHRcdGVsc2V7XFxuXFxcblx0XHRcdFx0XHRcdFx0XHRcdGlmKHI+MC43NSl7XFxuXFxcblx0XHRcdFx0XHRcdFx0XHRcdFx0Z2xfRnJhZ0NvbG9yPXZlYzQoMC4xLDAuMSwwLjEsb3ApO1xcblxcXG5cdFx0XHRcdFx0XHRcdFx0XHR9XFxuXFxcblx0XHRcdFx0XHRcdFx0XHRcdGVsc2V7XFxuXFxcblx0XHRcdFx0XHRcdFx0XHRcdFx0Z2xfRnJhZ0NvbG9yID0gdmVjNChmcmFnQ29sb3Isb3ApO1xcblxcXG5cdFx0XHRcdFx0XHRcdFx0XHR9XFxuXFxcblx0XHRcdFx0XHRcdFx0XHR9XFxuXFxcblx0XHRcdFx0XHRcdFx0fVxcblxcXG5cdFx0XHRcdFx0fVxcbidcblxuXHRcdFx0XHRcdCxcblx0XHRcdHZlcnQ6IFxuXHRcdFx0J2F0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uO1xcblxcXG5cdFx0XHRhdHRyaWJ1dGUgdmVjMyBjb2xvcjtcXG5cXFxuXHRcdFx0YXR0cmlidXRlIGZsb2F0IG9wYWNpdHk7XFxuXFxcblx0XHRcdFx0XHRhdHRyaWJ1dGUgbWF0NCBzZWdtZW50czE7XFxuXFxcblx0XHRcdHZhcnlpbmcgdmVjMyBmcmFnQ29sb3I7XFxuXFxcblx0XHRcdHZhcnlpbmcgZmxvYXQgb3A7XFxuXFxcblx0XHRcdFx0XHRhdHRyaWJ1dGUgZmxvYXQgc3RhcnRfYW5nbGU7XFxuXFxcblx0XHRcdFx0XHR2YXJ5aW5nIGZsb2F0IHNfYW5nbGU7XFxuXFxcblx0XHRcdFx0XHR2YXJ5aW5nIGZsb2F0IGVfYW5nbGU7XFxuXFxcblx0XHRcdFx0XHRhdHRyaWJ1dGUgZmxvYXQgZW5kX2FuZ2xlO1xcblxcXG5cdFx0XHRhdHRyaWJ1dGUgZmxvYXQgcmFkaXVzO1xcblxcXG5cdFx0XHRcdFx0dW5pZm9ybSBmbG9hdCB4X3NjYWxlO1xcblxcXG5cdFx0XHRcdFx0dW5pZm9ybSBmbG9hdCB5X3NjYWxlO1xcblxcXG5cdFx0XHRcdFx0dW5pZm9ybSB2ZWMyIG9mZnNldDtcXG5cXFxuXHRcdFx0XHRcdHVuaWZvcm0gZmxvYXQgc3RhZ2VfaGVpZ2h0O1xcblxcXG5cdFx0XHRcdFx0dW5pZm9ybSBmbG9hdCBzdGFnZV93aWR0aDtcXG5cXFxuXHRcdFx0dmVjMiBub3JtYWxpemVDb29yZHModmVjMiBwb3NpdGlvbil7XFxuXFxcblx0XHRcdFx0XHRcdFx0ZmxvYXQgeCA9IChwb3NpdGlvblswXStvZmZzZXRbMF0pKnhfc2NhbGU7XFxuXFxcblx0XHRcdFx0XHRcdFx0ZmxvYXQgeSA9IChwb3NpdGlvblsxXStvZmZzZXRbMV0pKnlfc2NhbGU7XFxuXFxcblx0XHRcdFx0cmV0dXJuIHZlYzIoMi4wICogKCh4IC8gc3RhZ2Vfd2lkdGgpIC0gMC41KSwtKDIuMCAqICgoeSAvIHN0YWdlX2hlaWdodCkgLSAwLjUpKSk7XFxuXFxcblx0XHRcdFx0XHR9XFxuXFxcblx0XHRcdHZvaWQgbWFpbigpIHtcXG5cXFxuXHRcdFx0ICAgaWYgKG9wYWNpdHk9PTAuMCl7XFxuXFxcblx0XHRcdCAgICAgICAgIHJldHVybjtcXG5cXFxuXHRcdFx0XHR9XFxuXFxcblx0XHRcdFx0Z2xfUG9pbnRTaXplID0gcmFkaXVzKnhfc2NhbGU7XFxuXFxcblx0XHRcdFx0XHRcdFx0ZnJhZ0NvbG9yID0gY29sb3I7XFxuXFxcblx0XHRcdFx0XHRcdFx0b3A9b3BhY2l0eTtcXG5cXFxuXHRcdFx0XHRcdFx0XHRzX2FuZ2xlPXN0YXJ0X2FuZ2xlO1xcblxcXG5cdFx0XHRcdFx0XHRcdGVfYW5nbGUgPSBlbmRfYW5nbGU7XFxuXFxcblx0XHRcdFx0XHRcdFx0dmVjMiByZWFsX3Bvc2l0aW9uID0gbm9ybWFsaXplQ29vcmRzKHBvc2l0aW9uKTtcXG5cXFxuXHRcdFx0XHRcdFx0XHRnbF9Qb3NpdGlvbiA9IHZlYzQocmVhbF9wb3NpdGlvbiwgMC4wLCAxLjApO1xcblxcXG5cdFx0XHR9XFxuJ1xuXHRcdFx0LFxuXG5cdFx0XHRhdHRyaWJ1dGVzOiB7XG5cdFx0XHRcdHBvc2l0aW9uOiBzZWxmLnJlZ2wucHJvcCgncG9zaXRpb24nKSxcblx0XHRcdFx0Y29sb3I6IHNlbGYucmVnbC5wcm9wKCdjb2xvcicpLFxuXHRcdFx0XHRcdFx0XHRyYWRpdXM6c2VsZi5yZWdsLnByb3AoJ3JhZGl1cycpLFxuXHRcdFx0XHRcdFx0XHRzdGFydF9hbmdsZTpzZWxmLnJlZ2wucHJvcCgnc3RhcnRfYW5nbGUnKSxcblx0XHRcdFx0XHRcdFx0ZW5kX2FuZ2xlOnNlbGYucmVnbC5wcm9wKFwiZW5kX2FuZ2xlXCIpLFxuXHRcdFx0XHRcdFx0XHRvcGFjaXR5OnNlbGYucmVnbC5wcm9wKFwib3BhY2l0eVwiKVxuXG5cdFx0XHR9LFxuXG5cdFx0XG5cblx0XHRcdHVuaWZvcm1zOiB7XG5cdFx0XHRcdFx0XHRcdCAgeF9zY2FsZTpzZWxmLnJlZ2wucHJvcCgneF9zY2FsZScpLFxuXHRcdFx0XHRcdFx0XHQgIHlfc2NhbGU6c2VsZi5yZWdsLnByb3AoJ3lfc2NhbGUnKSxcblx0XHRcdFx0XHRcdFx0ICBzdGFnZV93aWR0aDogc2VsZi5yZWdsLnByb3AoJ3N0YWdlX3dpZHRoJyksXG5cdFx0XHRcdFx0XHRcdCAgc3RhZ2VfaGVpZ2h0OiBzZWxmLnJlZ2wucHJvcCgnc3RhZ2VfaGVpZ2h0JyksXG5cdFx0XHRcdFx0XHRcdCAgb2Zmc2V0OnNlbGYucmVnbC5wcm9wKFwib2Zmc2V0XCIpXG5cdFx0XHRcdFx0XHQgIH0sXG5cblx0XHRcdGNvdW50OiAgc2VsZi5yZWdsLnByb3AoJ2NvdW50JyksXG5cdFx0XHRwcmltaXRpdmU6IHNlbGYucmVnbC5wcm9wKCdwcmltaXRpdmUnKSxcblx0XHRcdFx0XHRmcmFtZWJ1ZmZlcjpzZWxmLnJlZ2wucHJvcChcImJ1ZmZlclwiKVxuXHRcdH0pO1xuXHRcdHRoaXMub2JqZWN0X3R5cGVzWzBdWydtZXRob2QnXT10aGlzLl9fZHJhd0NpcmNsZXM7XG5cblx0XHR0aGlzLl9fZHJhd0xpbmVzID0gdGhpcy5yZWdsKHtcblxuXHRcdFx0XHQvLyBmcmFnbWVudCBzaGFkZXJcblx0XHRcdFx0ZnJhZzogJyBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcblx0XHRcdFx0XHRcdHZhcnlpbmcgdmVjMyBmcmFnQ29sb3I7XFxuXFxcblx0XHRcdFx0XHRcdHZvaWQgbWFpbiAoKSB7XFxuXFxcblx0XHRcdFx0XHRcdFx0IGdsX0ZyYWdDb2xvciA9IHZlYzQoZnJhZ0NvbG9yLDEpO1xcblxcXG5cdFx0XHRcdFx0XHR9XFxuJyxcblxuXG5cdFx0XHRcdHZlcnQ6ICdcXFxuXHRcdFx0XHRcdFx0YXR0cmlidXRlIHZlYzIgcG9zaXRpb247XFxuXFxcblx0XHRcdFx0XHRcdGF0dHJpYnV0ZSB2ZWMzIGNvbG9yO1xcblxcXG5cdFx0XHRcdFx0XHR1bmlmb3JtIGZsb2F0IHhfc2NhbGU7XFxuXFxcblx0XHRcdFx0XHRcdHVuaWZvcm0gZmxvYXQgeV9zY2FsZTtcXG5cXFxuXHRcdFx0XHRcdFx0dW5pZm9ybSB2ZWMyIG9mZnNldDtcXG5cXFxuXHRcdFx0XHRcdFx0dW5pZm9ybSBmbG9hdCBzdGFnZV9oZWlnaHQ7XFxuXFxcblx0XHRcdFx0XHRcdHVuaWZvcm0gZmxvYXQgc3RhZ2Vfd2lkdGg7XFxuXFxcblx0XHRcdFx0XHRcdHZhcnlpbmcgdmVjMyBmcmFnQ29sb3I7XFxuXFxcblx0XHRcdFx0XHRcdHZlYzIgbm9ybWFsaXplQ29vcmRzKHZlYzIgcG9zaXRpb24pe1xcblxcXG5cdFx0XHRcdFx0XHRcdGZsb2F0IHggPSAocG9zaXRpb25bMF0rb2Zmc2V0WzBdKSp4X3NjYWxlO1xcblxcXG5cdFx0XHRcdFx0XHRcdGZsb2F0IHkgPSAocG9zaXRpb25bMV0rb2Zmc2V0WzFdKSp5X3NjYWxlO1xcblxcXG5cdFx0XHRcdHJldHVybiB2ZWMyKDIuMCAqICgoeCAvIHN0YWdlX3dpZHRoKSAtIDAuNSksLSgyLjAgKiAoKHkgLyBzdGFnZV9oZWlnaHQpIC0gMC41KSkpO1xcblxcXG5cdFx0XHRcdFx0XHR9XFxuXFxcblx0XHRcdFx0XHRcdHZvaWQgbWFpbiAoKSB7XFxuXFxcblx0XHRcdFx0XHRcdFx0ZnJhZ0NvbG9yPWNvbG9yO1xcblxcXG5cdFx0XHRcdFx0XHRcdHZlYzIgbm9ybV9wb3MgPW5vcm1hbGl6ZUNvb3Jkcyhwb3NpdGlvbik7XFxuXFxcblx0XHRcdFx0XHRcdFx0Z2xfUG9zaXRpb24gPSB2ZWM0KG5vcm1fcG9zLCAwLjAsIDEuMCk7XFxuXFxcblx0XHRcdFx0XHRcdH1cXG4nLFxuXG5cblx0XHRcdFx0YXR0cmlidXRlczoge1xuXHRcdFx0XHRcdHBvc2l0aW9uOiBzZWxmLnJlZ2wucHJvcChcInBvc2l0aW9uXCIpLFxuXHRcdFx0XHRcdGNvbG9yOnNlbGYucmVnbC5wcm9wKFwiY29sb3JcIilcblxuXG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0dW5pZm9ybXM6IHtcblx0XHRcdFx0XHQgIHhfc2NhbGU6c2VsZi5yZWdsLnByb3AoJ3hfc2NhbGUnKSxcblx0XHRcdFx0XHQgIHlfc2NhbGU6c2VsZi5yZWdsLnByb3AoJ3lfc2NhbGUnKSxcblx0XHRcdFx0XHQgIHN0YWdlX3dpZHRoOiBzZWxmLnJlZ2wucHJvcCgnc3RhZ2Vfd2lkdGgnKSxcblx0XHRcdFx0XHQgIHN0YWdlX2hlaWdodDogc2VsZi5yZWdsLnByb3AoJ3N0YWdlX2hlaWdodCcpLFxuXHRcdFx0XHRcdCAgb2Zmc2V0OnNlbGYucmVnbC5wcm9wKFwib2Zmc2V0XCIpXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHByaW1pdGl2ZTpzZWxmLnJlZ2wucHJvcChcInByaW1pdGl2ZVwiKSxcblx0XHRcdFx0ZnJhbWVidWZmZXI6c2VsZi5yZWdsLnByb3AoXCJidWZmZXJcIiksXG5cdFx0XHRcdGNvdW50OnNlbGYucmVnbC5wcm9wKFwiY291bnRcIilcblxuXG5cblx0XHRcdH0pO1xuXHRcdHRoaXMub2JqZWN0X3R5cGVzWzFdWydtZXRob2QnXT10aGlzLl9fZHJhd0xpbmVzO1xuXHRcdHRoaXMub2JqZWN0X3R5cGVzWzJdWydtZXRob2QnXT10aGlzLl9fZHJhd0xpbmVzO1xuXHRcdHRoaXMuX19kcmF3U3F1YXJlcyA9IHRoaXMucmVnbCh7XG5cdFx0XHRmcmFnOiBcblx0XHRcdFx0ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcblx0XHRcdFx0XHR2YXJ5aW5nIHZlYzMgZnJhZ0NvbG9yO1xcblxcXG5cdFx0XHRcdFx0dmFyeWluZyBmbG9hdCByX2NsaXA7XFxuXFxcblx0XHRcdFx0XHR2YXJ5aW5nIGZsb2F0IGJfY2xpcDtcXG5cXFxuXHRcdFx0XHRcdHVuaWZvcm0gaW50IGlzX2J1ZmZlcjsgXFxuXFxcblx0XHRcdHZvaWQgbWFpbigpe1xcblxcXG5cdFx0XHRcdFx0XHRpZiAoZ2xfUG9pbnRDb29yZFswXT5yX2NsaXAgfHwgZ2xfUG9pbnRDb29yZFsxXT5iX2NsaXApe1xcblxcXG5cdFx0XHRcdFx0XHRcdGRpc2NhcmQ7XFxuXFxcblx0XHRcdFx0XHRcdH1cXG5cXFxuXHRcdFx0XHRcdFx0ZmxvYXQgcl9ib3JkZXI9Yl9jbGlwKjAuMDI7XFxuXFxcblx0XHRcdFx0XHRcdGZsb2F0IGJfYm9yZGVyPWJfY2xpcCowLjAyO1xcblxcXG5cdFx0XHRcdFx0XHRpZiAoaXNfYnVmZmVyPT0wICAmJiAoZ2xfUG9pbnRDb29yZFswXTxyX2JvcmRlciB8fCBnbF9Qb2ludENvb3JkWzBdPnJfY2xpcC1yX2JvcmRlciB8fCBnbF9Qb2ludENvb3JkWzFdPGJfYm9yZGVyIHx8IGdsX1BvaW50Q29vcmRbMV0+Yl9jbGlwLWJfYm9yZGVyKSl7XFxuXFxcblx0XHRcdFx0XHRcdFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCgwLjEsMC4xLDAuMSwxKTtcXG5cXFxuXHRcdFx0XHRcdFx0fVxcblxcXG5cdFx0XHRcdFx0XHRlbHNle1xcblxcXG5cdFx0XHRcdFx0XHRcdGdsX0ZyYWdDb2xvciA9IHZlYzQoZnJhZ0NvbG9yLDEpO1xcblxcXG5cdFx0XHRcdFx0XHR9XFxuXFxcblx0XHRcdFx0XHR9XFxuJ1xuXG5cdFx0XHRcdFx0LFxuXHRcdFx0dmVydDogXG5cdFx0XHQnYXR0cmlidXRlIHZlYzIgcG9zaXRpb247XFxuXFxcblx0XHRcdFx0XHRhdHRyaWJ1dGUgZmxvYXQgc2lkZV9sZW5ndGg7XFxuXFxcblx0XHRcdFx0XHRhdHRyaWJ1dGUgdmVjMyBjb2xvcjtcXG5cXFxuXHRcdFx0XHRcdGF0dHJpYnV0ZSBmbG9hdCByaWdodF9jbGlwO1xcblxcXG5cdFx0XHRcdFx0YXR0cmlidXRlIGZsb2F0IGJvdHRvbV9jbGlwO1xcblxcXG5cdFx0XHRcdFx0dmFyeWluZyBmbG9hdCByX2NsaXA7XFxuXFxcblx0XHRcdFx0XHR2YXJ5aW5nIGZsb2F0IGJfY2xpcDtcXG5cXFxuXHRcdFx0XHRcdHVuaWZvcm0gZmxvYXQgeF9zY2FsZTtcXG5cXFxuXHRcdFx0XHRcdHVuaWZvcm0gZmxvYXQgeV9zY2FsZTtcXG5cXFxuXHRcdFx0XHRcdHVuaWZvcm0gdmVjMiBvZmZzZXQ7XFxuXFxcblx0XHRcdFx0XHR1bmlmb3JtIGZsb2F0IHN0YWdlX2hlaWdodDtcXG5cXFxuXHRcdFx0XHRcdHVuaWZvcm0gZmxvYXQgc3RhZ2Vfd2lkdGg7XFxuXFxcblx0XHRcdFx0XHR2YXJ5aW5nIHZlYzMgZnJhZ0NvbG9yO1xcblxcXG5cdFx0XHR2ZWMyIG5vcm1hbGl6ZUNvb3Jkcyh2ZWMyIHBvc2l0aW9uKXtcXG5cXFxuXHRcdFx0XHRcdFx0XHRmbG9hdCB4ID0gKHBvc2l0aW9uWzBdK29mZnNldFswXSkqeF9zY2FsZTtcXG5cXFxuXHRcdFx0XHRcdFx0XHRmbG9hdCB5ID0gKHBvc2l0aW9uWzFdK29mZnNldFsxXSkqeV9zY2FsZTtcXG5cXFxuXHRcdFx0XHRyZXR1cm4gdmVjMigyLjAgKiAoKHggLyBzdGFnZV93aWR0aCkgLSAwLjUpLC0oMi4wICogKCh5IC8gc3RhZ2VfaGVpZ2h0KSAtIDAuNSkpKTtcXG5cXFxuXHRcdFx0XHRcdH1cXG5cXFxuXHRcdFx0dm9pZCBtYWluKCkge1xcblxcXG5cdFx0XHRcdGdsX1BvaW50U2l6ZSA9IHNpZGVfbGVuZ3RoKnhfc2NhbGU7XFxuXFxcblx0XHRcdFx0XHRcdFx0ZnJhZ0NvbG9yID0gY29sb3I7XFxuXFxcblx0XHRcdFx0XHRcdFx0cl9jbGlwPXJpZ2h0X2NsaXA7XFxuXFxcblx0XHRcdFx0XHRcdFx0Yl9jbGlwPWJvdHRvbV9jbGlwO1xcblxcXG5cdFx0XHRcdFx0XHRcdHZlYzIgcmVhbF9wb3NpdGlvbiA9IG5vcm1hbGl6ZUNvb3Jkcyhwb3NpdGlvbik7XFxuXFxcblx0XHRcdFx0XHRcdFx0Z2xfUG9zaXRpb24gPSB2ZWM0KHJlYWxfcG9zaXRpb24sIDAuMCwgMS4wKTtcXG5cXFxuXHRcdFx0fVxcbidcblx0XHRcdCxcblxuXHRcdFx0YXR0cmlidXRlczoge1xuXHRcdFx0XHRwb3NpdGlvbjogc2VsZi5yZWdsLnByb3AoJ3Bvc2l0aW9uJyksXG5cdFx0XHRcdGNvbG9yOiBzZWxmLnJlZ2wucHJvcCgnY29sb3InKSxcblx0XHRcdFx0XHRcdFx0c2lkZV9sZW5ndGg6c2VsZi5yZWdsLnByb3AoJ3NpZGVfbGVuZ3RoJyksXG5cdFx0XHRcdFx0XHRcdHJpZ2h0X2NsaXA6c2VsZi5yZWdsLnByb3AoXCJyaWdodF9jbGlwXCIpLFxuXHRcdFx0XHRcdFx0XHRib3R0b21fY2xpcDpzZWxmLnJlZ2wucHJvcChcImJvdHRvbV9jbGlwXCIpXG5cblx0XHRcdH0sXG5cblx0XHRcdHVuaWZvcm1zOiB7XG5cdFx0XHRcdFx0XHRcdCAgeF9zY2FsZTpzZWxmLnJlZ2wucHJvcCgneF9zY2FsZScpLFxuXHRcdFx0XHRcdFx0XHQgIHlfc2NhbGU6c2VsZi5yZWdsLnByb3AoJ3lfc2NhbGUnKSxcblx0XHRcdFx0XHRcdFx0ICBzdGFnZV93aWR0aDogc2VsZi5yZWdsLnByb3AoJ3N0YWdlX3dpZHRoJyksXG5cdFx0XHRcdFx0XHRcdCAgc3RhZ2VfaGVpZ2h0OiBzZWxmLnJlZ2wucHJvcCgnc3RhZ2VfaGVpZ2h0JyksXG5cdFx0XHRcdFx0XHRcdCAgb2Zmc2V0OnNlbGYucmVnbC5wcm9wKFwib2Zmc2V0XCIpLFxuXHRcdFx0XHRcdFx0XHQgIGlzX2J1ZmZlcjpzZWxmLnJlZ2wucHJvcChcImlzX2J1ZmZlclwiKVxuXHRcdFx0XHRcdFx0ICB9LFxuXG5cdFx0XHRjb3VudDogIHNlbGYucmVnbC5wcm9wKCdjb3VudCcpLFxuXHRcdFx0cHJpbWl0aXZlOiBzZWxmLnJlZ2wucHJvcCgncHJpbWl0aXZlJyksXG5cdFx0XHRcdFx0ZnJhbWVidWZmZXI6c2VsZi5yZWdsLnByb3AoXCJidWZmZXJcIilcblx0XHR9KTtcblx0XHR0aGlzLm9iamVjdF90eXBlc1szXVsnbWV0aG9kJ109dGhpcy5fX2RyYXdTcXVhcmVzO1xuXG5cdFx0dGhpcy5fX2RyYXdJbWFnZXMgPSB0aGlzLnJlZ2woe1xuXHRcdFx0ZnJhZzogYFxuXHRcdFx0XHRwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcblx0XHRcdFx0dW5pZm9ybSBzYW1wbGVyMkQgdGV4dDtcblx0XHRcdFx0dmFyeWluZyB2ZWMyIHV2O1xuXHRcdFx0XHR2YXJ5aW5nIHZlYzMgZnJhZ0NvbG9yO1xuXHRcdFx0XHR2YXJ5aW5nIGZsb2F0IGlzX2J1ZmY7XG5cdFx0XHRcdHZvaWQgbWFpbiAoKSB7XG5cdFx0XHRcdFx0aWYgKGlzX2J1ZmY9PTAuMCl7XG5cdFx0XHRcdFx0XHRnbF9GcmFnQ29sb3IgPSB2ZWM0KGZyYWdDb2xvciwxKSp0ZXh0dXJlMkQodGV4dCwgdXYpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNle1xuXHRcdFx0XHRcdFx0Z2xfRnJhZ0NvbG9yPXZlYzQoZnJhZ0NvbG9yLDEuMCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9YCxcblxuIFx0XHRcdHZlcnQ6IGBcblx0XHRcdFx0cHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG5cdFx0XHRcdGF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uO1xuXHRcdFx0XHRhdHRyaWJ1dGUgdmVjMyBjb2xvcjtcblx0XHRcdFx0dW5pZm9ybSB2ZWMyIHhfeTtcblx0XHRcdFx0dW5pZm9ybSB2ZWMyIHdfaDtcblx0XHRcdFx0dW5pZm9ybSBmbG9hdCBzdGFnZV9oZWlnaHQ7XG5cdFx0XHRcdHVuaWZvcm0gZmxvYXQgc3RhZ2Vfd2lkdGg7XG5cdFx0XHRcdHVuaWZvcm0gdmVjNCBnbG9iYWxzO1xuXHRcdFx0XHR1bmlmb3JtIGZsb2F0IGlzX2J1ZmZlcjtcblxuXG5cdFx0XHRcdHZhcnlpbmcgdmVjMiB1djtcblx0XHRcdFx0dmFyeWluZyB2ZWMzIGZyYWdDb2xvcjtcblx0XHRcdFx0dmFyeWluZyBmbG9hdCBpc19idWZmO1xuXHRcdFx0XG5cblx0XHRcdFx0dmVjMiBub3JtYWxpemVDb29yZHModmVjMiBwb3Mpe1xuXHRcdFx0XHRcdGZsb2F0IHggPSAocG9zWzBdK2dsb2JhbHNbMF0pKmdsb2JhbHNbMl07XG5cdFx0XHRcdFx0ZmxvYXQgeSA9IChwb3NbMV0rZ2xvYmFsc1sxXSkqZ2xvYmFsc1szXTtcblx0XHRcdFx0XHRyZXR1cm4gdmVjMigyLjAgKiAoKHggLyBzdGFnZV93aWR0aCkgLSAwLjUpLC0oMi4wICogKCh5IC8gc3RhZ2VfaGVpZ2h0KSAtIDAuNSkpKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZvaWQgbWFpbiAoKSB7XG5cdFx0XHRcdFx0dmVjMiBuZXdfcG9zPW5vcm1hbGl6ZUNvb3Jkcyhwb3NpdGlvbik7XG5cdFx0XHRcdFx0aXNfYnVmZj1pc19idWZmZXI7XG5cdFx0XHRcdFx0ZnJhZ0NvbG9yID0gY29sb3I7XG5cdFx0XHRcdFxuXG5cdFx0XHRcdFx0aWYgKGlzX2J1ZmZlcj09MC4wKXtcblxuXHRcdFx0XHRcdFx0ZmxvYXQgeF9mYWN0b3IgPSAxLjAvKCgod19oWzBdKmdsb2JhbHNbMl0pL3N0YWdlX3dpZHRoKSoyLjApO1xuXHRcdFx0XHRcdFx0ZmxvYXQgeV9mYWN0b3IgPSAxLjAvKCgod19oWzFdKmdsb2JhbHNbM10pL3N0YWdlX2hlaWdodCkqMi4wKTtcblx0XHRcdFx0XHRcblxuXHRcdFx0XHRcdFx0ZmxvYXQgeF9vZmZzZXQ9KCgoeF95WzBdK2dsb2JhbHNbMF0pKmdsb2JhbHNbMl0pL3N0YWdlX3dpZHRoKSoyLjAqeF9mYWN0b3I7XG5cdFx0XHRcdFx0XHRmbG9hdCB5X29mZnNldD0oKCh4X3lbMV0rZ2xvYmFsc1sxXSkqZ2xvYmFsc1szXSkvc3RhZ2VfaGVpZ2h0KSoyLjAqeV9mYWN0b3I7XG5cdFx0XHRcdFx0XHR1diA9IHZlYzIoKG5ld19wb3NbMF0qeF9mYWN0b3IpK3hfZmFjdG9yLXhfb2Zmc2V0LC0obmV3X3Bvc1sxXSp5X2ZhY3RvcikreV9mYWN0b3IteV9vZmZzZXQpO1xuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdFxuXG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Z2xfUG9zaXRpb24gPSB2ZWM0KG5ld19wb3MsIDAsIDEpO1xuXG5cdFx0XHRcdH1gLFxuXG5cdFx0XHRhdHRyaWJ1dGVzOiB7XG4gICAgXHRcdFx0cG9zaXRpb246c2VsZi5yZWdsLnByb3AoXCJwb3NpdGlvblwiKSxcbiAgICBcdFx0XHRjb2xvcjpzZWxmLnJlZ2wucHJvcChcImNvbG9yXCIpXG4gICBcdFx0XHR9LFxuXG4gIFx0XHRcdHVuaWZvcm1zOiB7XG4gICAgXHRcdFx0c3RhZ2VfaGVpZ2h0OnNlbGYucmVnbC5jb250ZXh0KFwidmlld3BvcnRIZWlnaHRcIiksXG4gICAgXHRcdFx0c3RhZ2Vfd2lkdGg6c2VsZi5yZWdsLmNvbnRleHQoXCJ2aWV3cG9ydFdpZHRoXCIpLFxuICAgIFx0XHRcdHdfaDpzZWxmLnJlZ2wucHJvcChcIndfaFwiKSxcbiAgICBcdFx0XHR4X3k6c2VsZi5yZWdsLnByb3AoXCJ4X3lcIiksXG4gICAgXHRcdFx0dGV4dDpzZWxmLnJlZ2wucHJvcChcInRleHRcIiksXG4gICAgXHRcdFx0Z2xvYmFsczpzZWxmLnJlZ2wucHJvcChcImdsb2JhbHNcIiksXG5cdFx0XHRcdGlzX2J1ZmZlcjpzZWxmLnJlZ2wucHJvcChcImlzX2J1ZmZlclwiKSxcblxuICBcdFx0XHR9LFxuXG4gIFx0XHRcdGNvdW50OiBzZWxmLnJlZ2wucHJvcChcImNvdW50XCIpLFxuICBcdFx0XHRmcmFtZWJ1ZmZlcjpzZWxmLnJlZ2wucHJvcChcImJ1ZmZlclwiKVxuXHRcdH0pO1xuXG5cdFx0dGhpcy5vYmplY3RfdHlwZXNbNF1bJ21ldGhvZCddPXRoaXMuX19kcmF3SW1hZ2VzXG5cdH1cbn1cblxuXG5leHBvcnQge1dHTDJESX07XG5cblxuXG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7OztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFZQTtBQUNBOzs7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUZBO0FBS0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUVBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUdBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZBO0FBQ0E7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFYQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFPQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBcEJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFxQkE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQU9BO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFHQTtBQXJCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBc0JBOzs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQVRBO0FBV0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQS9CQTtBQWlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBWEE7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFEQTtBQUNBO0FBMENBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTNDQTtBQUNBO0FBOEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQXJHQTtBQXVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFIQTtBQUNBO0FBU0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVZBO0FBQ0E7QUE4QkE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQWhEQTtBQW9EQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFEQTtBQUNBO0FBcUJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdEJBO0FBQ0E7QUFrREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBdkVBO0FBeUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFjQTtBQUNBO0FBZ0RBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQUNBO0FBVUE7QUFDQTtBQWxGQTtBQUNBO0FBb0ZBO0FBQ0E7Ozs7OztBQUlBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/webgl/wgl2di.js\n");

/***/ })

/******/ });